
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Fri Mar 15 07:56:11 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; TaliForth2 system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=					TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]					TALI_OPTION_CR_EOL := [ "lf" ]

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=126					turnkey   = zpage_end-1    ; word to resume in pre-compiled image
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd b4 80	lda $80b4,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad b4 80	lda $80b4	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 33		ldy #$33	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 d6 80	lda $80d6,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad d6 80	lda $80d6	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 54 89	jsr $8954	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 62		lda #$62	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 bb		lda #$bb	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 aa		lda #$aa	                lda #<(user_words_end-forth_words_start)
.803f	95 00		sta $00,x	                sta 0,x
.8041	a9 01		lda #$01	                lda #>(user_words_end-forth_words_start)
.8043	95 01		sta $01,x	                sta 1,x
.8045	20 c6 90	jsr $90c6	                jsr xt_evaluate
.8048	80 0e		bra $8058	                bra _init_hist_buffers
.804a					_turnkey:
.804a	78		sei		                sei
.804b	a2 76		ldx #$76	                ldx #dsp0-2
.804d	a5 7e		lda $7e		                lda turnkey
.804f	95 00		sta $00,x	                sta 0,x
.8051	a5 7f		lda $7f		                lda turnkey+1
.8053	95 01		sta $01,x	                sta 1,x
.8055	20 2e 8f	jsr $8f2e	                jsr xt_execute
.8058					_init_hist_buffers:
.8058	9c 00 7c	stz $7c00	                stz hist_buff
.805b	9c 80 7c	stz $7c80	                stz hist_buff+$80
.805e	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8061	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8064	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8067	9c 80 7e	stz $7e80	                stz hist_buff+$280
.806a	9c 00 7f	stz $7f00	                stz hist_buff+$300
.806d	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8070					xt_abort:
.8070	a2 78		ldx #$78	                ldx #dsp0
.8072					xt_quit:
.8072	8a		txa		                txa             ; Save the DSP that we just defined
.8073	a2 ff		ldx #$ff	                ldx #rsp0
.8075	9a		txs		                txs
.8076	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8077	64 0e		stz $0e		                stz ip
.8079	64 0f		stz $0f		                stz ip+1
.807b	64 06		stz $06		                stz insrc
.807d	64 07		stz $07		                stz insrc+1
.807f	64 16		stz $16		                stz state
.8081	64 17		stz $17		                stz state+1
.8083					_get_line:
.8083	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8085	85 08		sta $08		                sta cib
.8087	a9 02		lda #$02	                lda #>buffer0
.8089	85 09		sta $09		                sta cib+1
.808b	64 0a		stz $0a		                stz ciblen
.808d	64 0b		stz $0b		                stz ciblen+1
.808f	20 e9 9a	jsr $9ae9	                jsr xt_refill           ; ( -- f )
.8092	b5 00		lda $00,x	                lda 0,x
.8094	d0 05		bne $809b	                bne _success
.8096	a9 06		lda #$06	                lda #err_refill
.8098	4c 22 d9	jmp $d922	                jmp error
.809b					_success:
.809b	e8		inx		                inx                     ; drop
.809c	e8		inx		                inx
.809d	20 74 d8	jsr $d874	                jsr interpret
.80a0	e0 78		cpx #$78	                cpx #dsp0
.80a2	f0 05		beq $80a9	                beq _stack_ok
.80a4	90 03		bcc $80a9	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a6	4c 20 d9	jmp $d920	                jmp underflow_error
.80a9					_stack_ok:
.80a9	a5 16		lda $16		                lda state
.80ab	f0 02		beq $80af	                beq _print
.80ad	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80af					_print:
.80af	20 73 d9	jsr $d973	                jsr print_string
.80b2	80 cf		bra $8083	                bra _get_line
.80b4					z_cold:
.80b4					z_abort:
.80b4					z_quit:
.80b4					cold_zp_table:
>80b4	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80b6	0c bd				        .word dictionary_start  ; dp
>80b8	00 00				        .word 0                 ; workword
>80ba	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80bc	00 02				        .word buffer0           ; cib
>80be	00 00				        .word 0                 ; ciblen
>80c0	00 00				        .word 0                 ; toin
>80c2	00 00				        .word 0                 ; ip
>80c4	27 f0				        .word kernel_putc       ; output
>80c6	21 f0				        .word kernel_getc       ; input
>80c8	00 00				        .word 0                 ; havekey
>80ca	00 00				        .word 0                 ; state (0 = interpret)
>80cc	0a 00				        .word 10                ; base
>80ce	14 00				        .word 20                ; nc-limit
>80d0	00 00				        .word 0                 ; uf_strip (off by default)
>80d2	00 03				        .word cp0               ; up (user vars put right at beginning of
>80d4	00 00				        .word 0                 ; status
.80d6					cold_zp_table_end:
.80d6					cold_user_table:
>80d6	00 00				        .word 0                         ;  0 BLK
>80d8	00 00				        .word 0                         ;  2 SCR
>80da	00				        .byte 0                         ;  4 CURRENT = FORTH-WORDLIST
>80db	04				        .byte 4                         ;  5 #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80dc	0c bd				        .word dictionary_start          ;  6 FORTH-WORDLIST
>80de	54 cb				        .word editor_dictionary_start   ;  8 EDITOR-WORDLIST
>80e0	a4 cb				        .word assembler_dictionary_start ; a ASSEMBLER-WORDLIST
>80e2	13 cb				        .word root_dictionary_start     ;  c ROOT-WORDLIST
>80e4	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ;  e User wordlists
>80ec	00 00 00 00 00 00 00 00
>80f4	01				        .byte 1                         ; 1e #ORDER
>80f5	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; 1f search-order
>80fd	00
>80fe	00 04				        .word cp0+256                   ; 28 Address of buffer (right after USER vars)
>8100	00 00				        .word 0                         ; 2a block in buffer
>8102	00 00				        .word 0                         ; 2c buffer status (not in use)
>8104	4c 85				        .word xt_block_word_error       ; 2e block-read vector
>8106	4c 85				        .word xt_block_word_error       ; 30 block-write vector
>8108	00 00				        .word 0                         ; 32 'COLD
.810a					cold_user_table_end:
.810a					xt_abort_quote:
.810a	20 40 9d	jsr $9d40	                jsr xt_s_quote          ; S"
.810d	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.810f	a9 15		lda #$15	                lda #<abort_quote_runtime
.8111	20 af d7	jsr $d7af	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.8114	60		rts		z_abort_quote:  rts
.8115					abort_quote_runtime:
.8115	b5 04		lda $04,x	                lda 4,x
.8117	15 05		ora $05,x	                ora 5,x
.8119	f0 09		beq $8124	                beq _done       ; if FALSE, we're done
.811b	20 f4 a4	jsr $a4f4	                jsr xt_type
.811e	20 54 89	jsr $8954	                jsr xt_cr
.8121	4c 70 80	jmp $8070	                jmp xt_abort    ; not JSR, so never come back
.8124					_done:
.8124	8a		txa		                txa
.8125	18		clc		                clc
.8126	69 06		adc #$06	                adc #6
.8128	aa		tax		                tax
.8129	60		rts		                rts
.812a					xt_abs:
.812a	20 0c d9	jsr $d90c	                jsr underflow_1
.812d	b5 01		lda $01,x	                lda 1,x
.812f	10 0d		bpl $813e	                bpl _done       ; positive number, easy money!
.8131	38		sec		                sec
.8132	a9 00		lda #$00	                lda #0
.8134	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8136	95 00		sta $00,x	                sta 0,x
.8138	a9 00		lda #$00	                lda #0          ; MSB
.813a	f5 01		sbc $01,x	                sbc 1,x
.813c	95 01		sta $01,x	                sta 1,x
.813e					_done:
.813e	60		rts		z_abs:          rts
.813f					xt_accept:
.813f	20 11 d9	jsr $d911	                jsr underflow_2
.8142	b5 00		lda $00,x	                lda 0,x
.8144	15 01		ora $01,x	                ora 1,x
.8146	d0 09		bne $8151	                bne _not_zero
.8148	e8		inx		                inx
.8149	e8		inx		                inx
.814a	74 00		stz $00,x	                stz 0,x
.814c	74 01		stz $01,x	                stz 1,x
.814e	4c 1d 82	jmp $821d	                jmp accept_done
.8151					_not_zero:
.8151	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.8153	85 26		sta $26		                sta tmp2
.8155	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.8157	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8159	85 24		sta $24		                sta tmp1
.815b	b5 03		lda $03,x	                lda 3,x
.815d	85 25		sta $25		                sta tmp1+1
.815f	e8		inx		                inx
.8160	e8		inx		                inx
.8161	a0 00		ldy #$00	                ldy #0
.8163	a5 20		lda $20		                lda status
.8165	29 f7		and #$f7	                and #$f7
.8167	1a		inc a		               ina
.8168	09 08		ora #$08	                ora #$08
.816a	85 20		sta $20		                sta status
.816c					accept_loop:
.816c	20 29 93	jsr $9329	                jsr key_a
.816f	c9 0a		cmp #$0a	                cmp #AscLF
.8171	f0 20		beq $8193	                beq _eol
.8173	c9 0d		cmp #$0d	                cmp #AscCR
.8175	f0 1c		beq $8193	                beq _eol
.8177	c9 08		cmp #$08	                cmp #AscBS
.8179	f0 22		beq $819d	                beq _backspace
.817b	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.817d	f0 1e		beq $819d	                beq _backspace
.817f	c9 10		cmp #$10	                cmp #AscCP
.8181	f0 36		beq $81b9	                beq _ctrl_p
.8183	c9 0e		cmp #$0e	                cmp #AscCN
.8185	f0 44		beq $81cb	                beq _ctrl_n
.8187	91 24		sta ($24),y	                sta (tmp1),y
.8189	c8		iny		                iny
.818a	20 e7 8d	jsr $8de7	                jsr emit_a
.818d	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.818f	d0 db		bne $816c	                bne accept_loop       ; fall through if buffer limit reached
.8191	80 03		bra $8196	                bra _buffer_full
.8193					_eol:
.8193	20 0f a1	jsr $a10f	                jsr xt_space    ; print final space
.8196					_buffer_full:
.8196	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.8198	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.819a	4c 1d 82	jmp $821d	                jmp accept_done
.819d					_backspace:
.819d	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.819f	d0 06		bne $81a7	                bne +
.81a1	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.81a3	20 e7 8d	jsr $8de7	                jsr emit_a
.81a6	c8		iny		                iny
.81a7					+
.81a7	88		dey		                dey
.81a8	a9 08		lda #$08	                lda #AscBS      ; move back one
.81aa	20 e7 8d	jsr $8de7	                jsr emit_a
.81ad	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.81af	20 e7 8d	jsr $8de7	                jsr emit_a
.81b2	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81b4	20 e7 8d	jsr $8de7	                jsr emit_a
.81b7	80 b3		bra $816c	                bra accept_loop
.81b9					_ctrl_p:
.81b9	a5 20		lda $20		                lda status
.81bb	29 07		and #$07	                and #7
.81bd	d0 08		bne $81c7	                bne _ctrl_p_dec
.81bf	a5 20		lda $20		                lda status
.81c1	09 07		ora #$07	                ora #7
.81c3	85 20		sta $20		                sta status
.81c5	80 11		bra $81d8	                bra _recall_history
.81c7					_ctrl_p_dec:
.81c7	c6 20		dec $20		                dec status
.81c9	80 0d		bra $81d8	                bra _recall_history
.81cb					_ctrl_n:
.81cb	a9 08		lda #$08	                lda #$8
.81cd	24 20		bit $20		                bit status
.81cf	d0 07		bne $81d8	                bne _recall_history
.81d1	a5 20		lda $20		                lda status
.81d3	29 f7		and #$f7	                and #$f7
.81d5	1a		inc a		               ina
.81d6	85 20		sta $20		                sta status
.81d8					_recall_history:
.81d8	a9 08		lda #$08	                lda #%00001000
.81da	14 20		trb $20		                trb status
.81dc	20 38 82	jsr $8238	                jsr accept_total_recall
.81df	a9 0d		lda #$0d	                lda #AscCR
.81e1	20 e7 8d	jsr $8de7	                jsr emit_a
.81e4					input_clear:
.81e4	c0 00		cpy #$00	                cpy #0
.81e6	f0 08		beq $81f0	                beq input_cleared
.81e8	a9 20		lda #$20	                lda #AscSP
.81ea	20 e7 8d	jsr $8de7	                jsr emit_a
.81ed	88		dey		                dey
.81ee	80 f4		bra $81e4	                bra input_clear
.81f0					input_cleared:
.81f0	a9 0d		lda #$0d	                lda #AscCR
.81f2	20 e7 8d	jsr $8de7	                jsr emit_a
.81f5	b1 28		lda ($28),y	                lda (tmp3),y
.81f7	85 21		sta $21		                sta status+1
.81f9	e6 28		inc $28		                inc tmp3
.81fb	d0 02		bne $81ff	                bne +           ; Increment the upper byte on carry.
.81fd	e6 29		inc $29		                inc tmp3+1
.81ff					+
.81ff	a9 0d		lda #$0d	                lda #AscCR
.8201	20 e7 8d	jsr $8de7	                jsr emit_a
.8204					_history_loop:
.8204	c4 21		cpy $21		                cpy status+1
.8206	d0 03		bne $820b	                bne +
.8208	4c 6c 81	jmp $816c	                jmp accept_loop       ; Needs a long jump
.820b					+
.820b	c4 26		cpy $26		                cpy tmp2
.820d	f0 0a		beq $8219	                beq _hist_filled_buffer
.820f	b1 28		lda ($28),y	                lda (tmp3),y
.8211	91 24		sta ($24),y	                sta (tmp1),y
.8213	20 e7 8d	jsr $8de7	                jsr emit_a
.8216	c8		iny		                iny
.8217	80 eb		bra $8204	                bra _history_loop
.8219					_hist_filled_buffer:
.8219	88		dey		                dey
.821a	4c 6c 81	jmp $816c	                jmp accept_loop
.821d					accept_done:
.821d	20 38 82	jsr $8238	                jsr accept_total_recall
.8220	85 21		sta $21		                sta status+1
.8222	a0 00		ldy #$00	                ldy #0
.8224	91 28		sta ($28),y	                sta (tmp3),y
.8226	e6 28		inc $28		                inc tmp3
.8228	d0 02		bne $822c	                bne +           ; Increment the upper byte on carry.
.822a	e6 29		inc $29		                inc tmp3+1
.822c					+
.822c					_save_history_loop:
.822c	c4 21		cpy $21		                cpy status+1
.822e	f0 07		beq $8237	                beq _save_history_done
.8230	b1 24		lda ($24),y	                lda (tmp1),y
.8232	91 28		sta ($28),y	                sta (tmp3),y
.8234	c8		iny		                iny
.8235	80 f5		bra $822c	                bra _save_history_loop
.8237					_save_history_done:
.8237					z_accept:
.8237	60		rts		                rts
.8238					accept_total_recall:
.8238	a9 00		lda #$00	                lda #<hist_buff
.823a	85 28		sta $28		                sta tmp3
.823c	a9 7c		lda #$7c	                lda #>hist_buff
.823e	85 29		sta $29		                sta tmp3+1
.8240	a5 20		lda $20		                lda status
.8242	6a		ror a		                ror
.8243	29 03		and #$03	                and #3
.8245	18		clc		                clc
.8246	65 29		adc $29		                adc tmp3+1
.8248	85 29		sta $29		                sta tmp3+1
.824a	a5 20		lda $20		                lda status
.824c	6a		ror a		                ror             ; Rotate through carry into msb.
.824d	6a		ror a		                ror
.824e	29 80		and #$80	                and #$80
.8250	18		clc		                clc
.8251	65 28		adc $28		                adc tmp3
.8253	85 28		sta $28		                sta tmp3
.8255	90 02		bcc $8259	                bcc +           ; Increment the upper byte on carry.
.8257	e6 29		inc $29		                inc tmp3+1
.8259					+
.8259	98		tya		                tya
.825a	c9 80		cmp #$80	                cmp #$80
.825c	90 02		bcc $8260	                bcc +
.825e	a9 7f		lda #$7f	                lda #$7F
.8260					+
.8260	60		rts		                rts
.8261					xt_action_of:
.8261	a5 16		lda $16		                lda state
.8263	05 17		ora $17		                ora state+1
.8265	f0 0c		beq $8273	                beq _interpreting
.8267					_compiling:
.8267	20 8f 85	jsr $858f	                jsr xt_bracket_tick
.826a	a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.826c	a9 d0		lda #$d0	                lda #<xt_defer_fetch
.826e	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.8271	80 06		bra $8279	                bra _done
.8273					_interpreting:
.8273	20 02 a2	jsr $a202	                jsr xt_tick
.8276	20 d0 8a	jsr $8ad0	                jsr xt_defer_fetch
.8279					_done:
.8279	60		rts		z_action_of:           rts
.827a					xt_again:
.827a	20 0c d9	jsr $d90c	                jsr underflow_1
.827d	a0 00		ldy #$00	                ldy #0
.827f	a9 4c		lda #$4c	                lda #$4C        ; JMP
.8281	91 00		sta ($00),y	                sta (cp),y
.8283	c8		iny		                iny
.8284	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8286	91 00		sta ($00),y	                sta (cp),y
.8288	c8		iny		                iny
.8289	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.828b	91 00		sta ($00),y	                sta (cp),y
.828d	c8		iny		                iny
.828e	98		tya		                tya
.828f	18		clc		                clc
.8290	65 00		adc $00		                adc cp
.8292	85 00		sta $00		                sta cp
.8294	90 02		bcc $8298	                bcc _done
.8296	e6 01		inc $01		                inc cp+1
.8298					_done:
.8298	e8		inx		                inx
.8299	e8		inx		                inx
.829a	60		rts		z_again:        rts
.829b					xt_align:
.829b					xt_aligned:
.829b					z_align:
.829b	60		rts		z_aligned:      rts             ; stripped out during native compile
.829c					xt_allot:
.829c	20 0c d9	jsr $d90c	                jsr underflow_1
.829f	b5 01		lda $01,x	                lda 1,x
.82a1	30 22		bmi $82c5	                bmi _release
.82a3	18		clc		                clc
.82a4	a5 00		lda $00		                lda cp
.82a6	75 00		adc $00,x	                adc 0,x
.82a8	85 00		sta $00		                sta cp
.82aa	a5 01		lda $01		                lda cp+1
.82ac	75 01		adc $01,x	                adc 1,x
.82ae	85 01		sta $01		                sta cp+1
.82b0	a0 00		ldy #$00	                ldy #<cp_end
.82b2	c4 00		cpy $00		                cpy cp
.82b4	a9 7c		lda #$7c	                lda #>cp_end
.82b6	e5 01		sbc $01		                sbc cp+1
.82b8	b0 48		bcs $8302	                bcs _done               ; we're fine.
.82ba	84 00		sty $00		                sty cp                  ; still #<cp_end
.82bc	a9 7c		lda #$7c	                lda #>cp_end
.82be	85 01		sta $01		                sta cp+1
.82c0	a9 00		lda #$00	                lda #err_allot
.82c2	4c 22 d9	jmp $d922	                jmp error
.82c5					_release:
.82c5	ca		dex		                dex
.82c6	ca		dex		                dex
.82c7	a5 00		lda $00		                lda cp
.82c9	95 00		sta $00,x	                sta 0,x
.82cb	a5 01		lda $01		                lda cp+1
.82cd	95 01		sta $01,x	                sta 1,x
.82cf	20 d4 99	jsr $99d4	                jsr xt_plus                     ; new CP is now TOS
.82d2	ca		dex		                dex
.82d3	ca		dex		                dex                             ; new CP now NOS
.82d4	a9 00		lda #$00	                lda #<cp0
.82d6	95 00		sta $00,x	                sta 0,x
.82d8	a9 03		lda #$03	                lda #>cp0
.82da	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82dc	20 33 d8	jsr $d833	                jsr compare_16bit               ; still ( CP CP0 )
.82df	f0 17		beq $82f8	                beq _nega_done
.82e1	30 15		bmi $82f8	                bmi _nega_done
.82e3	a9 00		lda #$00	                lda #<cp0
.82e5	85 00		sta $00		                sta cp
.82e7	a9 03		lda #$03	                lda #>cp0
.82e9	85 01		sta $01		                sta cp+1
.82eb	a9 0c		lda #$0c	                lda #<dictionary_start
.82ed	85 02		sta $02		                sta dp
.82ef	a9 bd		lda #$bd	                lda #>dictionary_start
.82f1	85 03		sta $03		                sta dp+1
.82f3	a9 0a		lda #$0a	                lda #err_negallot
.82f5	4c 22 d9	jmp $d922	                jmp error
.82f8					_nega_done:
.82f8	b5 02		lda $02,x	                lda 2,x
.82fa	85 00		sta $00		                sta cp
.82fc	b5 03		lda $03,x	                lda 3,x
.82fe	85 01		sta $01		                sta cp+1
.8300	e8		inx		                inx
.8301	e8		inx		                inx                     ; drop through to _done
.8302					_done:
.8302	e8		inx		                inx
.8303	e8		inx		                inx
.8304					z_allot:
.8304	60		rts		                rts
.8305					xt_allow_native:
.8305	20 4e d8	jsr $d84e	                jsr current_to_dp
.8308	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.830a	b1 02		lda ($02),y	                lda (dp),y
.830c	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.830e	91 02		sta ($02),y	                sta (dp),y
.8310					z_allow_native:
.8310	60		rts		                rts
.8311					xt_also:
.8311	20 25 91	jsr $9125	                jsr xt_get_order
.8314	20 84 98	jsr $9884	                jsr xt_over
.8317	20 9f a1	jsr $a19f	                jsr xt_swap
.831a	20 0e 98	jsr $980e	                jsr xt_one_plus
.831d	20 0c 9d	jsr $9d0c	                jsr xt_set_order
.8320	60		rts		z_also:         rts
.8321					xt_always_native:
.8321	20 4e d8	jsr $d84e	                jsr current_to_dp
.8324	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8326	b1 02		lda ($02),y	                lda (dp),y
.8328	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.832a	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.832c	91 02		sta ($02),y	                sta (dp),y
.832e					z_always_native:
.832e	60		rts		                rts
.832f					xt_and:
.832f	20 11 d9	jsr $d911	                jsr underflow_2
.8332	b5 00		lda $00,x	                lda 0,x
.8334	35 02		and $02,x	                and 2,x
.8336	95 02		sta $02,x	                sta 2,x
.8338	b5 01		lda $01,x	                lda 1,x
.833a	35 03		and $03,x	                and 3,x
.833c	95 03		sta $03,x	                sta 3,x
.833e	e8		inx		                inx
.833f	e8		inx		                inx
.8340	60		rts		z_and:          rts
.8341					xt_at_xy:
.8341	20 11 d9	jsr $d911	                jsr underflow_2
.8344	a5 18		lda $18		                lda base
.8346	48		pha		                pha
.8347	a9 0a		lda #$0a	                lda #10
.8349	85 18		sta $18		                sta base
.834b	a9 1b		lda #$1b	                lda #AscESC
.834d	20 e7 8d	jsr $8de7	                jsr emit_a
.8350	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.8352	20 e7 8d	jsr $8de7	                jsr emit_a
.8355	20 0e 98	jsr $980e	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8358	20 79 d9	jsr $d979	                jsr print_u
.835b	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.835d	20 e7 8d	jsr $8de7	                jsr emit_a
.8360	20 0e 98	jsr $980e	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8363	20 79 d9	jsr $d979	                jsr print_u
.8366	a9 48		lda #$48	                lda #'H'
.8368	20 e7 8d	jsr $8de7	                jsr emit_a
.836b	68		pla		                pla
.836c	85 18		sta $18		                sta base
.836e	60		rts		z_at_xy:        rts
.836f					xt_backslash:
.836f	a5 0a		lda $0a		                lda ciblen
.8371	85 0c		sta $0c		                sta toin
.8373	a5 0b		lda $0b		                lda ciblen+1
.8375	85 0d		sta $0d		                sta toin+1
.8377	60		rts		z_backslash:    rts
.8378					xt_base:
.8378	ca		dex		                dex
.8379	ca		dex		                dex
.837a	a9 18		lda #$18	                lda #<base
.837c	95 00		sta $00,x	                sta 0,x         ; LSB
.837e	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8380	60		rts		z_base:         rts
.8381					xt_begin:
.8381	20 63 91	jsr $9163	                jsr xt_here
.8384	60		rts		z_begin:        rts
.8385					xt_bell:
.8385	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.8387	20 e7 8d	jsr $8de7	                jsr emit_a
.838a	60		rts		z_bell:         rts
.838b					xt_bl:
.838b	ca		dex		                dex
.838c	ca		dex		                dex
.838d	a9 20		lda #$20	                lda #AscSP
.838f	95 00		sta $00,x	                sta 0,x
.8391	74 01		stz $01,x	                stz 1,x
.8393	60		rts		z_bl:           rts
.8394					xt_blk:
.8394	ca		dex		                dex
.8395	ca		dex		                dex
.8396	18		clc		                clc
.8397	a5 1e		lda $1e		                lda up
.8399	69 00		adc #$00	                adc #blk_offset ; Add offset
.839b	95 00		sta $00,x	                sta 0,x
.839d	a5 1f		lda $1f		                lda up+1
.839f	69 00		adc #$00	                adc #0          ; Adding carry
.83a1	95 01		sta $01,x	                sta 1,x
.83a3	60		rts		z_blk:          rts
.83a4					xt_blkbuffer:
.83a4	ca		dex		                dex
.83a5	ca		dex		                dex
.83a6	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83a8	b1 1e		lda ($1e),y	                lda (up),y
.83aa	95 00		sta $00,x	                sta 0,x
.83ac	c8		iny		                iny             ; Move along to the next byte
.83ad	b1 1e		lda ($1e),y	                lda (up),y
.83af	95 01		sta $01,x	                sta 1,x
.83b1	60		rts		z_blkbuffer:    rts
.83b2					xt_block:
.83b2	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83b4	b1 1e		lda ($1e),y	                lda (up),y
.83b6	d5 00		cmp $00,x	                cmp 0,x
.83b8	d0 0f		bne $83c9	                bne _not_in_buffer
.83ba	c8		iny		                iny
.83bb	b1 1e		lda ($1e),y	                lda (up),y
.83bd	d5 01		cmp $01,x	                cmp 1,x
.83bf	d0 08		bne $83c9	                bne _not_in_buffer
.83c1	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83c3	b1 1e		lda ($1e),y	                lda (up),y
.83c5	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.83c7	d0 30		bne $83f9	                bne _done       ; It's already in the buffer and in use.
.83c9					_not_in_buffer:
.83c9	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83cb	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83cd	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83cf	d0 0c		bne $83dd	                bne _buffer_available ; Unused or not dirty = available
.83d1	20 a4 83	jsr $83a4	                jsr xt_blkbuffer
.83d4	20 96 85	jsr $8596	                jsr xt_buffblocknum
.83d7	20 71 8f	jsr $8f71	                jsr xt_fetch
.83da	20 51 85	jsr $8551	                jsr xt_block_write
.83dd					_buffer_available:
.83dd	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83df	b5 00		lda $00,x	                lda 0,x
.83e1	91 1e		sta ($1e),y	                sta (up),y
.83e3	c8		iny		                iny
.83e4	b5 01		lda $01,x	                lda 1,x
.83e6	91 1e		sta ($1e),y	                sta (up),y
.83e8	20 a4 83	jsr $83a4	                jsr xt_blkbuffer
.83eb	20 9f a1	jsr $a19f	                jsr xt_swap
.83ee	20 2e 85	jsr $852e	                jsr xt_block_read
.83f1	a9 01		lda #$01	                lda #1
.83f3	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83f5	91 1e		sta ($1e),y	                sta (up),y
.83f7	ca		dex		                dex
.83f8	ca		dex		                dex
.83f9					_done:
.83f9	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83fb	b1 1e		lda ($1e),y	                lda (up),y
.83fd	95 00		sta $00,x	                sta 0,x
.83ff	c8		iny		                iny
.8400	b1 1e		lda ($1e),y	                lda (up),y
.8402	95 01		sta $01,x	                sta 1,x
.8404	60		rts		z_block:        rts
.8405					xt_block_ramdrive_init:
.8405	20 0c d9	jsr $d90c	                jsr underflow_1
.8408	4c 23 85	jmp $8523	                jmp _after_ramdrive_code
.840b					_ramdrive_code:
>840b	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>8413	77 61 70 20 64 65 63 69 6d 61 6c
>841e	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>8425	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8429	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>8431	20 72 61 6d 64 72 69 76 65
>843a	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8442	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>8450	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8458	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8468	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8478	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>8480	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>848f	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>8497	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84a7	31 30 32 34 20 6d 6f 76 65 20 3b
>84b2	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84ba	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>84ca	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>84da	20 21
>84dc	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84e4	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84f4	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>8504	6f 72 20 21
>8508	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>8510	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>8520	65 20 21
.8523					_after_ramdrive_code:
.8523	20 9a a0	jsr $a09a	                jsr sliteral_runtime
>8526	0b 84 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.852a	20 c6 90	jsr $90c6	                jsr xt_evaluate
.852d					z_block_ramdrive_init:
.852d	60		rts		                rts
.852e					xt_block_read:
.852e	a0 2e		ldy #$2e	                ldy #blockread_offset
.8530	b1 1e		lda ($1e),y	                lda (up),y
.8532	85 24		sta $24		                sta tmp1
.8534	c8		iny		                iny
.8535	b1 1e		lda ($1e),y	                lda (up),y
.8537	85 25		sta $25		                sta tmp1+1
.8539	6c 24 00	jmp ($0024)	                jmp (tmp1)
.853c					z_block_read:
.853c					xt_block_read_vector:
.853c	ca		dex		                dex
.853d	ca		dex		                dex
.853e	18		clc		                clc
.853f	a5 1e		lda $1e		                lda up
.8541	69 2e		adc #$2e	                adc #blockread_offset
.8543	95 00		sta $00,x	                sta 0,x
.8545	a5 1f		lda $1f		                lda up+1
.8547	69 00		adc #$00	                adc #0          ; Add carry
.8549	95 01		sta $01,x	                sta 1,x
.854b					z_block_read_vector:
.854b	60		rts		                rts
.854c					xt_block_word_error:
.854c	a9 0c		lda #$0c	                lda #err_blockwords
.854e	4c 22 d9	jmp $d922	                jmp error       ; no RTS needed
.8551					z_block_word_error:
.8551					xt_block_write:
.8551	a0 30		ldy #$30	                ldy #blockwrite_offset
.8553	b1 1e		lda ($1e),y	                lda (up),y
.8555	85 24		sta $24		                sta tmp1
.8557	c8		iny		                iny
.8558	b1 1e		lda ($1e),y	                lda (up),y
.855a	85 25		sta $25		                sta tmp1+1
.855c	6c 24 00	jmp ($0024)	                jmp (tmp1)
.855f					z_block_write:
.855f					xt_block_write_vector:
.855f	ca		dex		                dex
.8560	ca		dex		                dex
.8561	18		clc		                clc
.8562	a5 1e		lda $1e		                lda up
.8564	69 30		adc #$30	                adc #blockwrite_offset
.8566	95 00		sta $00,x	                sta 0,x
.8568	a5 1f		lda $1f		                lda up+1
.856a	69 00		adc #$00	                adc #0          ; Add carry
.856c	95 01		sta $01,x	                sta 1,x
.856e					z_block_write_vector:
.856e	60		rts		                rts
.856f					xt_bounds:
.856f	20 11 d9	jsr $d911	                jsr underflow_2
.8572	18		clc		                clc
.8573	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.8575	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.8577	75 02		adc $02,x	                adc 2,x
.8579	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.857b	94 00		sty $00,x	                sty 0,x
.857d	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.857f	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8581	75 03		adc $03,x	                adc 3,x
.8583	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.8585	94 01		sty $01,x	                sty 1,x
.8587	60		rts		z_bounds:       rts
.8588					xt_bracket_char:
.8588	20 22 86	jsr $8622	                jsr xt_char
.858b	20 7b 93	jsr $937b	                jsr xt_literal
.858e	60		rts		z_bracket_char: rts
.858f					xt_bracket_tick:
.858f	20 02 a2	jsr $a202	                jsr xt_tick
.8592	20 7b 93	jsr $937b	                jsr xt_literal
.8595	60		rts		z_bracket_tick: rts
.8596					xt_buffblocknum:
.8596	ca		dex		                dex
.8597	ca		dex		                dex
.8598	18		clc		                clc
.8599	a5 1e		lda $1e		                lda up
.859b	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.859d	95 00		sta $00,x	                sta 0,x
.859f	a5 1f		lda $1f		                lda up+1
.85a1	69 00		adc #$00	                adc #0                          ; Adding carry
.85a3	95 01		sta $01,x	                sta 1,x
.85a5	60		rts		z_buffblocknum: rts
.85a6					xt_buffer:
.85a6	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85a8	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.85aa	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.85ac	d0 0c		bne $85ba	                bne _buffer_available ; Unused or not dirty = available
.85ae	20 a4 83	jsr $83a4	                jsr xt_blkbuffer
.85b1	20 96 85	jsr $8596	                jsr xt_buffblocknum
.85b4	20 71 8f	jsr $8f71	                jsr xt_fetch
.85b7	20 51 85	jsr $8551	                jsr xt_block_write
.85ba					_buffer_available:
.85ba	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85bc	b5 00		lda $00,x	                lda 0,x
.85be	91 1e		sta ($1e),y	                sta (up),y
.85c0	c8		iny		                iny
.85c1	b5 01		lda $01,x	                lda 1,x
.85c3	91 1e		sta ($1e),y	                sta (up),y
.85c5	a9 01		lda #$01	                lda #1
.85c7	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85c9	91 1e		sta ($1e),y	                sta (up),y
.85cb					_done:
.85cb	a0 28		ldy #$28	                ldy #blkbuffer_offset
.85cd	b1 1e		lda ($1e),y	                lda (up),y
.85cf	95 00		sta $00,x	                sta 0,x
.85d1	c8		iny		                iny
.85d2	b1 1e		lda ($1e),y	                lda (up),y
.85d4	95 01		sta $01,x	                sta 1,x
.85d6	60		rts		z_buffer:       rts
.85d7					xt_buffer_colon:
.85d7	20 5a 89	jsr $895a	                jsr xt_create
.85da	20 9c 82	jsr $829c	                jsr xt_allot
.85dd	60		rts		z_buffer_colon: rts
.85de					xt_buffstatus:
.85de	ca		dex		                dex
.85df	ca		dex		                dex
.85e0	18		clc		                clc
.85e1	a5 1e		lda $1e		                lda up
.85e3	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85e5	95 00		sta $00,x	                sta 0,x
.85e7	a5 1f		lda $1f		                lda up+1
.85e9	69 00		adc #$00	                adc #0                  ; Adding carry
.85eb	95 01		sta $01,x	                sta 1,x
.85ed	60		rts		z_buffstatus:   rts
.85ee					xt_bye:
.85ee	4c 2b f0	jmp $f02b	                jmp platform_bye
.85f1					z_bye:
.85f1					xt_c_comma:
.85f1	20 0c d9	jsr $d90c	                jsr underflow_1
.85f4	b5 00		lda $00,x	                lda 0,x
.85f6	20 bf d7	jsr $d7bf	                jsr cmpl_a
.85f9	e8		inx		                inx
.85fa	e8		inx		                inx
.85fb	60		rts		z_c_comma:      rts
.85fc					xt_c_fetch:
.85fc	20 0c d9	jsr $d90c	                jsr underflow_1
.85ff	a1 00		lda ($00,x)	                lda (0,x)
.8601	95 00		sta $00,x	                sta 0,x
.8603	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8605	60		rts		z_c_fetch:      rts
.8606					xt_c_store:
.8606	20 11 d9	jsr $d911	                jsr underflow_2
.8609	b5 02		lda $02,x	                lda 2,x
.860b	81 00		sta ($00,x)	                sta (0,x)
.860d	e8		inx		                inx
.860e	e8		inx		                inx
.860f	e8		inx		                inx
.8610	e8		inx		                inx
.8611	60		rts		z_c_store:      rts
.8612					xt_cell_plus:
.8612	20 0c d9	jsr $d90c	                jsr underflow_1
.8615	f6 00		inc $00,x	                inc 0,x
.8617	d0 02		bne $861b	                bne +
.8619	f6 01		inc $01,x	                inc 1,x
.861b					+
.861b	f6 00		inc $00,x	                inc 0,x
.861d	d0 02		bne $8621	                bne _done
.861f	f6 01		inc $01,x	                inc 1,x
.8621					_done:
.8621	60		rts		z_cell_plus:    rts
.8622					xt_char:
.8622	20 d0 98	jsr $98d0	                jsr xt_parse_name
.8625	b5 00		lda $00,x	                lda 0,x
.8627	15 01		ora $01,x	                ora 1,x
.8629	d0 05		bne $8630	                bne _not_empty
.862b	a9 05		lda #$05	                lda #err_noname
.862d	4c 22 d9	jmp $d922	                jmp error
.8630					_not_empty:
.8630	e8		inx		                inx             ; drop number of characters, leave addr
.8631	e8		inx		                inx
.8632	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8634	95 00		sta $00,x	                sta 0,x
.8636	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8638	60		rts		z_char:         rts
.8639					xt_chars:
.8639	20 0c d9	jsr $d90c	                jsr underflow_1
.863c	60		rts		z_chars:        rts
.863d					xt_cleave:
.863d	20 11 d9	jsr $d911	                jsr underflow_2
.8640	20 54 95	jsr $9554	                jsr xt_minus_leading    ; -LEADING ( addr u )
.8643	20 53 92	jsr $9253	                jsr xt_input_to_r       ; save old imput state
.8646	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8648	85 0a		sta $0a		                sta ciblen
.864a	b5 01		lda $01,x	                lda 1,x
.864c	85 0b		sta $0b		                sta ciblen+1
.864e	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.8650	85 08		sta $08		                sta cib
.8652	b5 03		lda $03,x	                lda 3,x
.8654	85 09		sta $09		                sta cib+1
.8656	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8658	64 0d		stz $0d		                stz toin+1
.865a	20 d0 98	jsr $98d0	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.865d	b5 00		lda $00,x	                lda 0,x
.865f	15 01		ora $01,x	                ora 1,x
.8661	f0 23		beq $8686	                beq _done
.8663	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.8665	38		sec		                sec
.8666	f5 00		sbc $00,x	                sbc 0,x
.8668	95 04		sta $04,x	                sta 4,x
.866a	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.866c	f5 01		sbc $01,x	                sbc 1,x
.866e	95 05		sta $05,x	                sta 5,x
.8670	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8672	18		clc		                clc
.8673	75 00		adc $00,x	                adc 0,x
.8675	95 06		sta $06,x	                sta 6,x
.8677	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.8679	75 01		adc $01,x	                adc 1,x
.867b	95 07		sta $07,x	                sta 7,x
.867d	20 6f a4	jsr $a46f	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.8680	20 54 95	jsr $9554	                jsr xt_minus_leading
.8683	20 6f a4	jsr $a46f	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.8686					_done:
.8686	20 94 9a	jsr $9a94	                jsr xt_r_to_input
.8689	60		rts		z_cleave:       rts
.868a					xt_cmove:
.868a	20 16 d9	jsr $d916	                jsr underflow_3
.868d	b5 02		lda $02,x	                lda 2,x
.868f	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8691	b5 03		lda $03,x	                lda 3,x
.8693	85 27		sta $27		                sta tmp2+1
.8695	b5 04		lda $04,x	                lda 4,x
.8697	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.8699	b5 05		lda $05,x	                lda 5,x
.869b	85 25		sta $25		                sta tmp1+1
.869d	a0 00		ldy #$00	                ldy #0
.869f	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.86a1	f0 0f		beq $86b2	                beq _dopartial
.86a3					_page:
.86a3	b1 24		lda ($24),y	                lda (tmp1),y
.86a5	91 26		sta ($26),y	                sta (tmp2),y
.86a7	c8		iny		                iny
.86a8	d0 f9		bne $86a3	                bne _page
.86aa	e6 25		inc $25		                inc tmp1+1
.86ac	e6 27		inc $27		                inc tmp2+1
.86ae	d6 01		dec $01,x	                dec 1,x
.86b0	d0 f1		bne $86a3	                bne _page
.86b2					_dopartial:
.86b2	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86b4	f0 09		beq $86bf	                beq _done
.86b6					_partial:
.86b6	b1 24		lda ($24),y	                lda (tmp1),y
.86b8	91 26		sta ($26),y	                sta (tmp2),y
.86ba	c8		iny		                iny
.86bb	d6 00		dec $00,x	                dec 0,x
.86bd	d0 f7		bne $86b6	                bne _partial
.86bf					_done:
.86bf	8a		txa		                txa
.86c0	18		clc		                clc
.86c1	69 06		adc #$06	                adc #6
.86c3	aa		tax		                tax
.86c4	60		rts		z_cmove:        rts
.86c5					xt_cmove_up:
.86c5	20 16 d9	jsr $d916	                jsr underflow_3
.86c8	b5 02		lda $02,x	                lda 2,x
.86ca	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86cc	b5 03		lda $03,x	                lda 3,x
.86ce	18		clc		                clc
.86cf	75 01		adc $01,x	                adc 1,x
.86d1	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86d3	b5 04		lda $04,x	                lda 4,x
.86d5	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86d7	b5 05		lda $05,x	                lda 5,x
.86d9	18		clc		                clc
.86da	75 01		adc $01,x	                adc 1,x
.86dc	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86de	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86e0	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86e2	f0 0e		beq $86f2	                beq _nopartial
.86e4					_outerloop:
.86e4	88		dey		                dey
.86e5	f0 07		beq $86ee	                beq _finishpage
.86e7					_innerloop:
.86e7	b1 24		lda ($24),y	                lda (tmp1),y
.86e9	91 26		sta ($26),y	                sta (tmp2),y
.86eb	88		dey		                dey
.86ec	d0 f9		bne $86e7	                bne _innerloop
.86ee					_finishpage:
.86ee	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.86f0	92 26		sta ($26)	                sta (tmp2)
.86f2					_nopartial:
.86f2	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.86f4	c6 27		dec $27		                dec tmp2+1
.86f6	d6 01		dec $01,x	                dec 1,x
.86f8	d0 ea		bne $86e4	                bne _outerloop
.86fa					_done:
.86fa	8a		txa		                txa
.86fb	18		clc		                clc
.86fc	69 06		adc #$06	                adc #6
.86fe	aa		tax		                tax
.86ff	60		rts		z_cmove_up:     rts
.8700					xt_colon:
.8700	a5 16		lda $16		                lda state
.8702	05 17		ora $17		                ora state+1
.8704	f0 05		beq $870b	                beq +
.8706	a9 07		lda #$07	                lda #err_state
.8708	4c 22 d9	jmp $d922	                jmp error
.870b					+
.870b	c6 16		dec $16		                dec state
.870d	c6 17		dec $17		                dec state+1
.870f	a9 40		lda #$40	                lda #%01000000
.8711	04 20		tsb $20		                tsb status
.8713	20 4e d8	jsr $d84e	                jsr current_to_dp
.8716	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8718	48		pha		                pha
.8719	a5 02		lda $02		                lda dp
.871b	48		pha		                pha
.871c	a9 80		lda #$80	                lda #%10000000
.871e	04 20		tsb $20		                tsb status
.8720	20 5a 89	jsr $895a	                jsr xt_create
.8723	20 4e d8	jsr $d84e	                jsr current_to_dp   ; This might be able to be omitted
.8726	a5 02		lda $02		                lda dp
.8728	85 04		sta $04		                sta workword
.872a	a5 03		lda $03		                lda dp+1
.872c	85 05		sta $05		                sta workword+1
.872e	68		pla		                pla
.872f	85 02		sta $02		                sta dp
.8731	68		pla		                pla
.8732	85 03		sta $03		                sta dp+1
.8734	20 61 d8	jsr $d861	                jsr dp_to_current
.8737	a5 00		lda $00		                lda cp
.8739	38		sec		                sec
.873a	e9 03		sbc #$03	                sbc #3
.873c	85 00		sta $00		                sta cp
.873e	b0 02		bcs $8742	                bcs _done
.8740	c6 01		dec $01		                dec cp+1
.8742					_done:
.8742	60		rts		z_colon:        rts
.8743					xt_colon_noname:
.8743	a5 16		lda $16		                lda state
.8745	05 17		ora $17		                ora state+1
.8747	f0 05		beq $874e	                beq +
.8749	a9 07		lda #$07	                lda #err_state
.874b	4c 22 d9	jmp $d922	                jmp error
.874e					+
.874e	c6 16		dec $16		                dec state
.8750	c6 17		dec $17		                dec state+1
.8752	a9 40		lda #$40	                lda #%01000000
.8754	14 20		trb $20		                trb status
.8756	a5 00		lda $00		                lda cp
.8758	85 04		sta $04		                sta workword
.875a	a5 01		lda $01		                lda cp+1
.875c	85 05		sta $05		                sta workword+1
.875e					_done:
.875e	60		rts		z_colon_noname:        rts
.875f					xt_comma:
.875f	20 0c d9	jsr $d90c	                jsr underflow_1
.8762	b5 00		lda $00,x	                lda 0,x
.8764	92 00		sta ($00)	                sta (cp)
.8766	e6 00		inc $00		                inc cp
.8768	d0 02		bne $876c	                bne +
.876a	e6 01		inc $01		                inc cp+1
.876c					+
.876c	b5 01		lda $01,x	                lda 1,x
.876e	92 00		sta ($00)	                sta (cp)
.8770	e6 00		inc $00		                inc cp
.8772	d0 02		bne $8776	                bne _done
.8774	e6 01		inc $01		                inc cp+1
.8776					_done:
.8776	e8		inx		                inx
.8777	e8		inx		                inx
.8778	60		rts		z_comma:        rts
.8779					xt_compare:
.8779	20 1b d9	jsr $d91b	                jsr underflow_4
.877c	b5 02		lda $02,x	                lda 2,x
.877e	85 26		sta $26		                sta tmp2
.8780	b5 03		lda $03,x	                lda 3,x
.8782	85 27		sta $27		                sta tmp2+1
.8784	b5 06		lda $06,x	                lda 6,x
.8786	85 24		sta $24		                sta tmp1
.8788	b5 07		lda $07,x	                lda 7,x
.878a	85 25		sta $25		                sta tmp1+1
.878c					_compare_loop:
.878c	b5 04		lda $04,x	                lda 4,x
.878e	15 05		ora $05,x	                ora 5,x
.8790	f0 2c		beq $87be	                beq _str1_done
.8792	b5 00		lda $00,x	                lda 0,x
.8794	15 01		ora $01,x	                ora 1,x
.8796	f0 3a		beq $87d2	                beq _greater    ; Str2 empty first
.8798					_check_letter:
.8798	b2 24		lda ($24)	                lda (tmp1)
.879a	d2 26		cmp ($26)	                cmp (tmp2)
.879c	90 26		bcc $87c4	                bcc _less
.879e	d0 32		bne $87d2	                bne _greater
.87a0					_next_letter:
.87a0	e6 24		inc $24		                inc tmp1
.87a2	d0 02		bne $87a6	                bne +
.87a4	e6 25		inc $25		                inc tmp1+1
.87a6					+
.87a6	e6 26		inc $26		                inc tmp2
.87a8	d0 02		bne $87ac	                bne +
.87aa	e6 27		inc $27		                inc tmp2+1
.87ac					+
.87ac	b5 04		lda $04,x	                lda 4,x
.87ae	d0 02		bne $87b2	                bne +
.87b0	d6 05		dec $05,x	                dec 5,x
.87b2					+
.87b2	d6 04		dec $04,x	                dec 4,x
.87b4	b5 00		lda $00,x	                lda 0,x
.87b6	d0 02		bne $87ba	                bne +
.87b8	d6 01		dec $01,x	                dec 1,x
.87ba					+
.87ba	d6 00		dec $00,x	                dec 0,x
.87bc	80 ce		bra $878c	                bra _compare_loop
.87be					_str1_done:
.87be	b5 00		lda $00,x	                lda 0,x
.87c0	15 01		ora $01,x	                ora 1,x
.87c2	f0 08		beq $87cc	                beq _equal      ; Both out of letters
.87c4					_less:
.87c4	a9 ff		lda #$ff	                lda #$FF
.87c6	95 06		sta $06,x	                sta 6,x
.87c8	95 07		sta $07,x	                sta 7,x
.87ca	80 0c		bra $87d8	                bra _done
.87cc					_equal:
.87cc	74 06		stz $06,x	                stz 6,x
.87ce	74 07		stz $07,x	                stz 7,x
.87d0	80 06		bra $87d8	                bra _done
.87d2					_greater:
.87d2	a9 01		lda #$01	                lda #1
.87d4	95 06		sta $06,x	                sta 6,x
.87d6	74 07		stz $07,x	                stz 7,x
.87d8					_done:
.87d8	8a		txa		                txa
.87d9	18		clc		                clc
.87da	69 06		adc #$06	                adc #6
.87dc	aa		tax		                tax
.87dd	60		rts		z_compare:      rts
.87de					xt_compile_comma:
.87de	20 0c d9	jsr $d90c	                jsr underflow_1
.87e1	b5 01		lda $01,x	                lda 1,x                 ; MSB
.87e3	48		pha		                pha
.87e4	b5 00		lda $00,x	                lda 0,x
.87e6	48		pha		                pha                     ; LSB
.87e7	20 69 92	jsr $9269	                jsr xt_int_to_name      ; ( xt -- nt )
.87ea	b5 00		lda $00,x	                lda 0,x
.87ec	15 01		ora $01,x	                ora 1,x
.87ee	d0 03		bne $87f3	                bne _check_nt
.87f0	4c db 88	jmp $88db	                jmp _compile_as_jump
.87f3					_check_nt:
.87f3	b5 00		lda $00,x	                lda 0,x
.87f5	85 2c		sta $2c		                sta tmptos
.87f7	b5 01		lda $01,x	                lda 1,x
.87f9	85 2d		sta $2d		                sta tmptos+1
.87fb	f6 00		inc $00,x	                inc 0,x
.87fd	d0 02		bne $8801	                bne +
.87ff	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.8801					+
.8801	a1 00		lda ($00,x)	                lda (0,x)
.8803	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.8805	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8807	f0 0d		beq $8816	                beq _compile_check
.8809	a5 2c		lda $2c		                lda tmptos
.880b	95 00		sta $00,x	                sta 0,x
.880d	a5 2d		lda $2d		                lda tmptos+1
.880f	95 01		sta $01,x	                sta 1,x
.8811	20 66 a7	jsr $a766	                jsr xt_wordsize         ; ( nt -- u )
.8814	80 27		bra $883d	                bra _compile_as_code
.8816					_compile_check:
.8816	a5 28		lda $28		                lda tmp3
.8818	29 08		and #$08	                and #NN
.881a	f0 03		beq $881f	                beq _check_size_limit
.881c	4c db 88	jmp $88db	                jmp _compile_as_jump    ; too far for BRA
.881f					_check_size_limit:
.881f	a5 2c		lda $2c		                lda tmptos
.8821	95 00		sta $00,x	                sta 0,x
.8823	a5 2d		lda $2d		                lda tmptos+1
.8825	95 01		sta $01,x	                sta 1,x
.8827	20 66 a7	jsr $a766	                jsr xt_wordsize         ; ( nt -- u )
.882a	b5 01		lda $01,x	                lda 1,x
.882c	c5 1b		cmp $1b		                cmp nc_limit+1
.882e	90 0d		bcc $883d	                bcc _compile_as_code    ; user-defined limit MSB
.8830	d0 08		bne $883a	                bne _jumpto_compile_as_jump
.8832	b5 00		lda $00,x	                lda 0,x
.8834	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.8836	90 05		bcc $883d	                bcc _compile_as_code    ; Allow native compiling for less
.8838	f0 03		beq $883d	                beq _compile_as_code    ; than or equal to the limit.
.883a					_jumpto_compile_as_jump:
.883a	4c db 88	jmp $88db	                jmp _compile_as_jump    ; too far for BRA
.883d					_compile_as_code:
.883d	ca		dex		                dex
.883e	ca		dex		                dex                     ; ( -- u ? )
.883f	ca		dex		                dex
.8840	ca		dex		                dex                     ; ( -- u ? ? )
.8841	b5 04		lda $04,x	                lda 4,x
.8843	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.8845	b5 05		lda $05,x	                lda 5,x
.8847	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8849	68		pla		                pla
.884a	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.884c	68		pla		                pla
.884d	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.884f	a5 00		lda $00		                lda cp                  ; LSB of cp
.8851	95 02		sta $02,x	                sta 2,x
.8853	a5 01		lda $01		                lda cp+1
.8855	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8857	a0 00		ldy #$00	                ldy #0
.8859					_strip_loop:
.8859	b9 c9 88	lda $88c9,y	                lda _strip_table,y      ; LSB of first word
.885c	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.885e	d0 07		bne $8867	                bne _next_entry
.8860	b9 ca 88	lda $88ca,y	                lda _strip_table+1,y
.8863	d5 05		cmp $05,x	                cmp 5,x
.8865	f0 0c		beq $8873	                beq _found_entry
.8867					_next_entry:
.8867	b9 c9 88	lda $88c9,y	                lda _strip_table,y      ; pointing to LSB
.886a	19 ca 88	ora $88ca,y	                ora _strip_table+1,y    ; get MSB
.886d	f0 22		beq $8891	                beq _underflow_strip    ; table done, let's get out of here
.886f	c8		iny		                iny
.8870	c8		iny		                iny
.8871	80 e6		bra $8859	                bra _strip_loop
.8873					_found_entry:
.8873	98		tya		                tya
.8874	4a		lsr a		                lsr
.8875	a8		tay		                tay
.8876	b9 d5 88	lda $88d5,y	                lda _strip_size,y
.8879	85 2c		sta $2c		                sta tmptos              ; save a copy
.887b	18		clc		                clc
.887c	75 04		adc $04,x	                adc 4,x
.887e	95 04		sta $04,x	                sta 4,x
.8880	90 02		bcc $8884	                bcc+
.8882	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8884					+
.8884	06 2c		asl $2c		                asl tmptos
.8886	38		sec		                sec
.8887	b5 00		lda $00,x	                lda 0,x
.8889	e5 2c		sbc $2c		                sbc tmptos
.888b	95 00		sta $00,x	                sta 0,x
.888d	b0 02		bcs $8891	                bcs +
.888f	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8891					+
.8891					_underflow_strip:
.8891	a5 1c		lda $1c		                lda uf_strip
.8893	05 1d		ora $1d		                ora uf_strip+1
.8895	f0 1c		beq $88b3	                beq _specials_done
.8897	a5 28		lda $28		                lda tmp3
.8899	29 10		and #$10	                and #UF
.889b	f0 16		beq $88b3	                beq _specials_done
.889d	18		clc		                clc
.889e	b5 04		lda $04,x	                lda 4,x
.88a0	69 03		adc #$03	                adc #3
.88a2	95 04		sta $04,x	                sta 4,x
.88a4	90 02		bcc $88a8	                bcc +
.88a6	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.88a8					+
.88a8	38		sec		                sec
.88a9	b5 00		lda $00,x	                lda 0,x
.88ab	e9 03		sbc #$03	                sbc #3
.88ad	95 00		sta $00,x	                sta 0,x
.88af	b0 02		bcs $88b3	                bcs +
.88b1	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88b3					+
.88b3					_specials_done:
.88b3	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88b5	48		pha		                pha
.88b6	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88b8	48		pha		                pha
.88b9	20 b3 95	jsr $95b3	                jsr xt_move
.88bc	18		clc		                clc
.88bd	68		pla		                pla                     ; LSB
.88be	65 00		adc $00		                adc cp
.88c0	85 00		sta $00		                sta cp
.88c2	68		pla		                pla                     ; MSB
.88c3	65 01		adc $01		                adc cp+1
.88c5	85 01		sta $01		                sta cp+1
.88c7	80 2c		bra $88f5	                bra _done
.88c9					_strip_table:
>88c9	83 9a 6e 9a 61 a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88cf	93 a4 19 a4 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88d5					_strip_size:
>88d5	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88db					_compile_as_jump:
.88db	a9 20		lda #$20	                lda #$20
.88dd	92 00		sta ($00)	                sta (cp)
.88df	a0 01		ldy #$01	                ldy #1
.88e1	68		pla		                pla             ; LSB
.88e2	91 00		sta ($00),y	                sta (cp),y
.88e4	c8		iny		                iny
.88e5	68		pla		                pla             ; MSB
.88e6	91 00		sta ($00),y	                sta (cp),y
.88e8	a9 03		lda #$03	                lda #3
.88ea	18		clc		                clc
.88eb	65 00		adc $00		                adc cp
.88ed	85 00		sta $00		                sta cp
.88ef	90 02		bcc $88f3	                bcc +
.88f1	e6 01		inc $01		                inc cp+1
.88f3					+
.88f3	e8		inx		                inx             ; drop xt
.88f4	e8		inx		                inx
.88f5					_done:
.88f5					z_compile_comma:
.88f5	60		rts		                rts
.88f6					xt_compile_only:
.88f6	20 4e d8	jsr $d84e	                jsr current_to_dp
.88f9	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.88fb	b1 02		lda ($02),y	                lda (dp),y
.88fd	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.88ff	91 02		sta ($02),y	                sta (dp),y
.8901	60		rts		z_compile_only: rts
.8902					xt_value:
.8902					xt_constant:
.8902	20 0c d9	jsr $d90c	                jsr underflow_1
.8905	20 5a 89	jsr $895a	                jsr xt_create
.8908	38		sec		                sec
.8909	a5 00		lda $00		                lda cp
.890b	e9 02		sbc #$02	                sbc #2
.890d	85 24		sta $24		                sta tmp1
.890f	a5 01		lda $01		                lda cp+1
.8911	e9 00		sbc #$00	                sbc #0
.8913	85 25		sta $25		                sta tmp1+1
.8915	a9 c8		lda #$c8	                lda #<doconst           ; LSB of DOCONST
.8917	92 24		sta ($24)	                sta (tmp1)
.8919	a0 01		ldy #$01	                ldy #1
.891b	a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.891d	91 24		sta ($24),y	                sta (tmp1),y
.891f	20 5f 87	jsr $875f	                jsr xt_comma            ; drop through to adjust_z
.8922					adjust_z:
.8922	20 2c 93	jsr $932c	                jsr xt_latestnt         ; gives us ( -- nt )
.8925	b5 00		lda $00,x	                lda 0,x
.8927	85 24		sta $24		                sta tmp1
.8929	b5 01		lda $01,x	                lda 1,x
.892b	85 25		sta $25		                sta tmp1+1
.892d	a0 06		ldy #$06	                ldy #6
.892f	b1 24		lda ($24),y	                lda (tmp1),y
.8931	18		clc		                clc
.8932	69 02		adc #$02	                adc #2
.8934	91 24		sta ($24),y	                sta (tmp1),y
.8936	c8		iny		                iny
.8937	b1 24		lda ($24),y	                lda (tmp1),y
.8939	69 00		adc #$00	                adc #0                  ; only need carry
.893b	91 24		sta ($24),y	                sta (tmp1),y
.893d	e8		inx		                inx
.893e	e8		inx		                inx
.893f					z_value:
.893f	60		rts		z_constant:     rts
.8940					xt_count:
.8940	20 0c d9	jsr $d90c	                jsr underflow_1
.8943	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.8945	a8		tay		                tay
.8946	f6 00		inc $00,x	                inc 0,x         ; LSB
.8948	d0 02		bne $894c	                bne +
.894a	f6 01		inc $01,x	                inc 1,x         ; MSB
.894c	98		tya		+               tya
.894d	ca		dex		                dex
.894e	ca		dex		                dex
.894f	95 00		sta $00,x	                sta 0,x         ; LSB
.8951	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8953	60		rts		z_count:        rts
.8954					xt_cr:
.8954	a9 0a		lda #$0a	                lda #AscLF
.8956	20 e7 8d	jsr $8de7	                jsr emit_a
.8959	60		rts		z_cr:           rts
.895a					xt_create:
.895a	20 d0 98	jsr $98d0	                jsr xt_parse_name       ; ( addr u )
.895d	b5 00		lda $00,x	                lda 0,x
.895f	15 01		ora $01,x	                ora 1,x
.8961	d0 05		bne $8968	                bne _got_name
.8963	a9 05		lda #$05	                lda #err_noname
.8965	4c 22 d9	jmp $d922	                jmp error
.8968					_got_name:
.8968	74 01		stz $01,x	                stz 1,x
.896a	20 a9 a3	jsr $a3a9	                jsr xt_two_dup          ; ( addr u addr u )
.896d	20 cc 8f	jsr $8fcc	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8970	b5 00		lda $00,x	                lda 0,x
.8972	15 01		ora $01,x	                ora 1,x
.8974	f0 1e		beq $8994	                beq _new_name           ; We haven't seen this one before.
.8976	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.8977	e8		inx		                inx
.8978	24 20		bit $20		                bit status
.897a	10 08		bpl $8984	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.897c	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.897e	05 20		ora $20		                ora status
.8980	85 20		sta $20		                sta status
.8982	80 18		bra $899c	                bra _process_name
.8984					_redefined_name:
.8984	a9 02		lda #$02	                lda #str_redefined
.8986	20 48 d9	jsr $d948	                jsr print_string_no_lf
.8989	20 a9 a3	jsr $a3a9	                jsr xt_two_dup           ; ( addr u addr u )
.898c	20 f4 a4	jsr $a4f4	                jsr xt_type
.898f	20 0f a1	jsr $a10f	                jsr xt_space
.8992	80 08		bra $899c	                bra _process_name
.8994					_new_name:
.8994	e8		inx		                inx                     ; Drop flag (0) from find-name.
.8995	e8		inx		                inx
.8996	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.8998	25 20		and $20		                and status
.899a	85 20		sta $20		                sta status
.899c					_process_name:
.899c	b5 00		lda $00,x	                lda 0,x
.899e	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.89a0	a5 00		lda $00		                lda cp
.89a2	85 24		sta $24		                sta tmp1
.89a4	a5 01		lda $01		                lda cp+1
.89a6	85 25		sta $25		                sta tmp1+1
.89a8	b5 00		lda $00,x	                lda 0,x
.89aa	18		clc		                clc
.89ab	69 08		adc #$08	                adc #8
.89ad	85 28		sta $28		                sta tmp3                ; total header length
.89af	18		clc		                clc
.89b0	69 03		adc #$03	                adc #3
.89b2	95 00		sta $00,x	                sta 0,x
.89b4	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89b6	20 9c 82	jsr $829c	                jsr xt_allot    ; ( addr )
.89b9	20 4e d8	jsr $d84e	                jsr current_to_dp
.89bc	a0 00		ldy #$00	                ldy #0
.89be	a5 26		lda $26		                lda tmp2
.89c0	91 24		sta ($24),y	                sta (tmp1),y
.89c2	a9 08		lda #$08	                lda #NN
.89c4	09 20		ora #$20	                ora #HC
.89c6	c8		iny		                iny
.89c7	91 24		sta ($24),y	                sta (tmp1),y
.89c9	c8		iny		                iny
.89ca	a5 02		lda $02		                lda dp
.89cc	91 24		sta ($24),y	                sta (tmp1),y
.89ce	c8		iny		                iny
.89cf	a5 03		lda $03		                lda dp+1
.89d1	91 24		sta ($24),y	                sta (tmp1),y
.89d3	c8		iny		                iny
.89d4	a5 25		lda $25		                lda tmp1+1
.89d6	85 03		sta $03		                sta dp+1
.89d8	a5 24		lda $24		                lda tmp1
.89da	85 02		sta $02		                sta dp
.89dc	18		clc		                clc
.89dd	65 28		adc $28		                adc tmp3        ; add total header length
.89df	91 24		sta ($24),y	                sta (tmp1),y
.89e1	48		pha		                pha             ; we need this in the next step
.89e2	c8		iny		                iny
.89e3	a5 25		lda $25		                lda tmp1+1
.89e5	69 00		adc #$00	                adc #0          ; only need the carry
.89e7	91 24		sta ($24),y	                sta (tmp1),y
.89e9	c8		iny		                iny
.89ea	68		pla		                pla             ; LSB of "z_" address
.89eb	18		clc		                clc
.89ec	69 03		adc #$03	                adc #3
.89ee	91 24		sta ($24),y	                sta (tmp1),y
.89f0	88		dey		                dey             ; get the MSB of xt back
.89f1	b1 24		lda ($24),y	                lda (tmp1),y
.89f3	69 00		adc #$00	                adc #0          ; only need the carry
.89f5	c8		iny		                iny
.89f6	c8		iny		                iny
.89f7	91 24		sta ($24),y	                sta (tmp1),y
.89f9	c8		iny		                iny
.89fa	b5 00		lda $00,x	                lda 0,x
.89fc	38		sec		                sec
.89fd	e9 08		sbc #$08	                sbc #8
.89ff	85 2c		sta $2c		                sta tmptos
.8a01	b5 01		lda $01,x	                lda 1,x
.8a03	e9 00		sbc #$00	                sbc #0          ; only need carry
.8a05	85 2d		sta $2d		                sta tmptos+1
.8a07					_name_loop:
.8a07	b1 2c		lda ($2c),y	                lda (tmptos),y
.8a09	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8a0b	b0 07		bcs $8a14	                bcs _store_name
.8a0d	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8a0f	90 03		bcc $8a14	                bcc _store_name
.8a11	18		clc		                clc
.8a12	69 20		adc #$20	                adc #$20
.8a14					_store_name:
.8a14	91 24		sta ($24),y	                sta (tmp1),y
.8a16	c8		iny		                iny
.8a17	c6 26		dec $26		                dec tmp2
.8a19	d0 ec		bne $8a07	                bne _name_loop
.8a1b	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a1d	91 24		sta ($24),y	                sta (tmp1),y
.8a1f	c8		iny		                iny
.8a20	a9 0e		lda #$0e	                lda #<dovar
.8a22	91 24		sta ($24),y	                sta (tmp1),y
.8a24	c8		iny		                iny
.8a25	a9 d8		lda #$d8	                lda #>dovar
.8a27	91 24		sta ($24),y	                sta (tmp1),y
.8a29	20 61 d8	jsr $d861	                jsr dp_to_current
.8a2c	e8		inx		                inx
.8a2d	e8		inx		                inx
.8a2e	60		rts		z_create:       rts
.8a2f					xt_d_minus:
.8a2f	20 1b d9	jsr $d91b	                jsr underflow_4 ; two double numbers
.8a32	38		sec		                sec
.8a33	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a35	f5 02		sbc $02,x	                sbc 2,x
.8a37	95 06		sta $06,x	                sta 6,x
.8a39	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a3b	f5 03		sbc $03,x	                sbc 3,x
.8a3d	95 07		sta $07,x	                sta 7,x
.8a3f	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a41	f5 00		sbc $00,x	                sbc 0,x
.8a43	95 04		sta $04,x	                sta 4,x
.8a45	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a47	f5 01		sbc $01,x	                sbc 1,x
.8a49	95 05		sta $05,x	                sta 5,x
.8a4b	e8		inx		                inx
.8a4c	e8		inx		                inx
.8a4d	e8		inx		                inx
.8a4e	e8		inx		                inx
.8a4f	60		rts		z_d_minus:      rts
.8a50					xt_d_plus:
.8a50	20 1b d9	jsr $d91b	                jsr underflow_4 ; two double numbers
.8a53	18		clc		                clc
.8a54	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a56	75 06		adc $06,x	                adc 6,x
.8a58	95 06		sta $06,x	                sta 6,x
.8a5a	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a5c	75 07		adc $07,x	                adc 7,x
.8a5e	95 07		sta $07,x	                sta 7,x
.8a60	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a62	75 04		adc $04,x	                adc 4,x
.8a64	95 04		sta $04,x	                sta 4,x
.8a66	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a68	75 05		adc $05,x	                adc 5,x
.8a6a	95 05		sta $05,x	                sta 5,x
.8a6c	e8		inx		                inx
.8a6d	e8		inx		                inx
.8a6e	e8		inx		                inx
.8a6f	e8		inx		                inx
.8a70	60		rts		z_d_plus:       rts
.8a71					xt_d_to_s:
.8a71	20 11 d9	jsr $d911	                jsr underflow_2
.8a74	e8		inx		                inx
.8a75	e8		inx		                inx
.8a76	60		rts		z_d_to_s:       rts
.8a77					xt_dabs:
.8a77	20 11 d9	jsr $d911	                jsr underflow_2 ; double number
.8a7a	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a7c	10 17		bpl $8a95	                bpl _done       ; positive, we get off light
.8a7e	a0 00		ldy #$00	                ldy #0
.8a80	38		sec		                sec
.8a81	98		tya		                tya
.8a82	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a84	95 02		sta $02,x	                sta 2,x
.8a86	98		tya		                tya
.8a87	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a89	95 03		sta $03,x	                sta 3,x
.8a8b	98		tya		                tya
.8a8c	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a8e	95 00		sta $00,x	                sta 0,x
.8a90	98		tya		                tya
.8a91	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a93	95 01		sta $01,x	                sta 1,x
.8a95					_done:
.8a95	60		rts		z_dabs:         rts
.8a96					xt_decimal:
.8a96	a9 0a		lda #$0a	                lda #10
.8a98	85 18		sta $18		                sta base
.8a9a	64 19		stz $19		                stz base+1              ; paranoid
.8a9c	60		rts		z_decimal:      rts
.8a9d					xt_defer:
.8a9d	20 5a 89	jsr $895a	                jsr xt_create
.8aa0	a5 00		lda $00		                lda cp          ; LSB
.8aa2	38		sec		                sec
.8aa3	e9 02		sbc #$02	                sbc #2
.8aa5	85 24		sta $24		                sta tmp1
.8aa7	a5 01		lda $01		                lda cp+1        ; MSB
.8aa9	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8aab	85 25		sta $25		                sta tmp1+1
.8aad	a0 00		ldy #$00	                ldy #0
.8aaf	a9 dc		lda #$dc	                lda #<dodefer   ; LSB
.8ab1	91 24		sta ($24),y	                sta (tmp1),y
.8ab3	c8		iny		                iny
.8ab4	a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8ab6	91 24		sta ($24),y	                sta (tmp1),y
.8ab8	a9 f0		lda #$f0	                lda #<defer_error
.8aba	92 00		sta ($00)	                sta (cp)
.8abc	e6 00		inc $00		                inc cp
.8abe	d0 02		bne $8ac2	                bne +
.8ac0	e6 01		inc $01		                inc cp+1
.8ac2					+
.8ac2	a9 d7		lda #$d7	                lda #>defer_error
.8ac4	92 00		sta ($00)	                sta (cp)
.8ac6	e6 00		inc $00		                inc cp
.8ac8	d0 02		bne $8acc	                bne +
.8aca	e6 01		inc $01		                inc cp+1
.8acc					+
.8acc	20 22 89	jsr $8922	                jsr adjust_z    ; adjust header to correct length
.8acf	60		rts		z_defer:        rts
.8ad0					xt_defer_fetch:
.8ad0	20 7e a2	jsr $a27e	                jsr xt_to_body
.8ad3	20 71 8f	jsr $8f71	                jsr xt_fetch
.8ad6	60		rts		z_defer_fetch:  rts
.8ad7					xt_defer_store:
.8ad7	20 7e a2	jsr $a27e	                jsr xt_to_body
.8ada	20 7e a1	jsr $a17e	                jsr xt_store
.8add	60		rts		z_defer_store:  rts
.8ade					xt_definitions:
.8ade	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8ae0	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8ae2	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8ae4	91 1e		sta ($1e),y	                sta (up),y
.8ae6	60		rts		z_definitions:  rts
.8ae7					xt_depth:
.8ae7	a9 78		lda #$78	                lda #dsp0
.8ae9	86 2a		stx $2a		                stx tmpdsp
.8aeb	38		sec		                sec
.8aec	e5 2a		sbc $2a		                sbc tmpdsp
.8aee	4a		lsr a		                lsr
.8aef	ca		dex		                dex
.8af0	ca		dex		                dex
.8af1	95 00		sta $00,x	                sta 0,x
.8af3	74 01		stz $01,x	                stz 1,x
.8af5	60		rts		z_depth:        rts
.8af6					xt_digit_question:
.8af6	20 0c d9	jsr $d90c	                jsr underflow_1
.8af9	ca		dex		                dex
.8afa	ca		dex		                dex
.8afb	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8afd	74 01		stz $01,x	                stz 1,x
.8aff	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8b01	b5 02		lda $02,x	                lda 2,x
.8b03	c9 30		cmp #$30	                cmp #'0'
.8b05	90 23		bcc $8b2a	                bcc _done               ; failure flag already set
.8b07	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8b09	90 12		bcc $8b1d	                bcc _checkbase
.8b0b	c9 41		cmp #$41	                cmp #'A'
.8b0d	90 1b		bcc $8b2a	                bcc _done               ; failure flag is already set
.8b0f	c9 61		cmp #$61	                cmp #'a'
.8b11	90 07		bcc $8b1a	                bcc _case_done          ; not lower case, too low
.8b13	c9 7b		cmp #$7b	                cmp #'z'+1
.8b15	b0 03		bcs $8b1a	                bcs _case_done          ; not lower case, too high
.8b17	18		clc		                clc                     ; just right
.8b18	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b1a					_case_done:
.8b1a	38		sec		                sec
.8b1b	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b1d					_checkbase:
.8b1d	38		sec		                sec
.8b1e	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b20	c5 18		cmp $18		                cmp base
.8b22	b0 06		bcs $8b2a	                bcs _done               ; already have false flag
.8b24	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b26	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b28	d6 01		dec $01,x	                dec 1,x
.8b2a					_done:
.8b2a					z_digit_question:
.8b2a	60		rts		                rts
.8b2b					xt_disasm:
.8b2b	20 11 d9	jsr $d911	                jsr underflow_2
.8b2e	20 c8 ac	jsr $acc8	                jsr disassembler
.8b31	60		rts		z_disasm:       rts
.8b32					xt_dnegate:
.8b32	20 11 d9	jsr $d911	                jsr underflow_2 ; double number
.8b35	a0 00		ldy #$00	     		ldy #0
.8b37	38		sec		                sec
.8b38	98		tya		                tya
.8b39	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b3b	95 02		sta $02,x	                sta 2,x
.8b3d	98		tya		                tya
.8b3e	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b40	95 03		sta $03,x	                sta 3,x
.8b42	98		tya		                tya
.8b43	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b45	95 00		sta $00,x	                sta 0,x
.8b47	98		tya		                tya
.8b48	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b4a	95 01		sta $01,x	                sta 1,x
.8b4c	60		rts		z_dnegate:      rts
.8b4d					xt_question_do:
.8b4d	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b4f	85 24		sta $24		                sta tmp1
.8b51	80 02		bra $8b55	                bra do_common           ; skip flag for DO
.8b53					xt_do:
.8b53	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b55					do_common:
.8b55	ca		dex		                dex
.8b56	ca		dex		                dex
.8b57	a5 00		lda $00		                lda cp
.8b59	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b5b	a5 01		lda $01		                lda cp+1
.8b5d	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b5f	a9 05		lda #$05	                lda #5                  ; we don't really care about the value,
.8b61	a8		tay		                tay                     ; so we use 5 to be tricky
.8b62					_loop:
.8b62	91 00		sta ($00),y	                sta (CP),y
.8b64	88		dey		                dey
.8b65	10 fb		bpl $8b62	                bpl _loop
.8b67	1a		inc a		                ina             ; we used 5 as a dummy value, this is why
.8b68	18		clc		                clc
.8b69	65 00		adc $00		                adc CP
.8b6b	85 00		sta $00		                sta CP
.8b6d	90 02		bcc $8b71	                bcc +
.8b6f	e6 01		inc $01		                inc CP+1
.8b71					+
.8b71	a5 24		lda $24		                lda tmp1
.8b73	f0 17		beq $8b8c	                beq _compile_do
.8b75	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b77	5a		phy		                phy             ; save counter to calculate new CP
.8b78					-
.8b78	b9 d2 8b	lda $8bd2,y	                lda question_do_runtime,y
.8b7b	91 00		sta ($00),y	                sta (cp),y
.8b7d	88		dey		                dey
.8b7e	10 f8		bpl $8b78	                bpl -
.8b80	68		pla		                pla             ; retrieve counter
.8b81	18		clc		                clc
.8b82	65 00		adc $00		                adc cp
.8b84	85 00		sta $00		                sta cp
.8b86	a5 01		lda $01		                lda cp+1
.8b88	69 00		adc #$00	                adc #0          ; only care about carry
.8b8a	85 01		sta $01		                sta cp+1        ; fall through to _compile_do
.8b8c					_compile_do:
.8b8c	a0 24		ldy #$24	                ldy #do_runtime_end-do_runtime  ; counter
.8b8e	5a		phy		                phy             ; save counter to calculate new CP
.8b8f					-
.8b8f	b9 ae 8b	lda $8bae,y	                lda do_runtime,y
.8b92	91 00		sta ($00),y	                sta (cp),y
.8b94	88		dey		                dey
.8b95	10 f8		bpl $8b8f	                bpl -
.8b97	68		pla		                pla             ; retrieve counter
.8b98	18		clc		                clc
.8b99	65 00		adc $00		                adc cp
.8b9b	85 00		sta $00		                sta cp
.8b9d	a5 01		lda $01		                lda cp+1
.8b9f	69 00		adc #$00	                adc #0          ; only care about carry
.8ba1	85 01		sta $01		                sta cp+1
.8ba3	ca		dex		                dex
.8ba4	ca		dex		                dex
.8ba5	a5 00		lda $00		                lda CP          ; LSB
.8ba7	95 00		sta $00,x	                sta 0,x
.8ba9	a5 01		lda $01		                lda CP+1        ; MSB
.8bab	95 01		sta $01,x	                sta 1,x
.8bad					z_question_do:
.8bad	60		rts		z_do:           rts
.8bae					do_runtime:
.8bae	38		sec		                sec
.8baf	a9 00		lda #$00	                lda #0
.8bb1	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8bb3	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8bb5	a9 80		lda #$80	                lda #$80
.8bb7	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8bb9	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8bbb	48		pha		                pha             ; FUFA replaces limit on R stack
.8bbc	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8bbe	48		pha		                pha
.8bbf	18		clc		                clc
.8bc0	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bc2	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bc4	95 00		sta $00,x	                sta 0,x
.8bc6	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8bc8	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8bca	48		pha		                pha
.8bcb	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8bcd	48		pha		                pha
.8bce	e8		inx		                inx
.8bcf	e8		inx		                inx
.8bd0	e8		inx		                inx
.8bd1	e8		inx		                inx             ; no RTS because this is copied into code
.8bd2					do_runtime_end:
.8bd2					question_do_runtime:
.8bd2	20 a9 a3	jsr $a3a9	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8bd5	20 bf 8e	jsr $8ebf	                jsr xt_equal            ; ( -- n1 n2 f )
.8bd8	b5 00		lda $00,x	                lda 0,x
.8bda	15 01		ora $01,x	                ora 1,x
.8bdc	f0 06		beq $8be4	                beq _do_do
.8bde	8a		txa		                txa
.8bdf	18		clc		                clc
.8be0	69 06		adc #$06	                adc #6
.8be2	aa		tax		                tax
.8be3	60		rts		                rts
.8be4					_do_do:
.8be4	e8		inx		                inx             ; clear flag from EQUAL off stack
.8be5	e8		inx		                inx             ; no RTS because this is copied into code
.8be6					question_do_runtime_end:
.8be6					xt_does:
.8be6	a0 8b		ldy #$8b	                ldy #>does_runtime
.8be8	a9 f5		lda #$f5	                lda #<does_runtime
.8bea	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.8bed	a0 d7		ldy #$d7	                ldy #>dodoes
.8bef	a9 f5		lda #$f5	                lda #<dodoes
.8bf1	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.8bf4	60		rts		z_does:         rts
.8bf5					does_runtime:
.8bf5	7a		ply		                ply             ; LSB
.8bf6	68		pla		                pla             ; MSB
.8bf7	c8		iny		                iny
.8bf8	d0 01		bne $8bfb	                bne +
.8bfa	1a		inc a		                ina
.8bfb					+
.8bfb	84 24		sty $24		                sty tmp1
.8bfd	85 25		sta $25		                sta tmp1+1
.8bff	20 4e d8	jsr $d84e	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8c02	a5 02		lda $02		                lda dp
.8c04	18		clc		                clc
.8c05	69 04		adc #$04	                adc #4
.8c07	85 26		sta $26		                sta tmp2
.8c09	a5 03		lda $03		                lda dp+1
.8c0b	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c0d	85 27		sta $27		                sta tmp2+1
.8c0f	b2 26		lda ($26)	                lda (tmp2)
.8c11	18		clc		                clc
.8c12	69 01		adc #$01	                adc #1
.8c14	85 28		sta $28		                sta tmp3
.8c16	a0 01		ldy #$01	                ldy #1
.8c18	b1 26		lda ($26),y	                lda (tmp2),y
.8c1a	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c1c	85 29		sta $29		                sta tmp3+1
.8c1e	a5 24		lda $24		                lda tmp1        ; LSB
.8c20	92 28		sta ($28)	                sta (tmp3)
.8c22	a5 25		lda $25		                lda tmp1+1
.8c24	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c26	60		rts		                rts
.8c27					xt_dot:
.8c27	20 0c d9	jsr $d90c	                jsr underflow_1
.8c2a	20 a0 8d	jsr $8da0	                jsr xt_dup                      ; ( n n )
.8c2d	20 2a 81	jsr $812a	                jsr xt_abs                      ; ( n u )
.8c30	20 99 a7	jsr $a799	                jsr xt_zero                     ; ( n u 0 )
.8c33	20 4b 93	jsr $934b	                jsr xt_less_number_sign         ; ( n u 0 )
.8c36	20 cf 97	jsr $97cf	                jsr xt_number_sign_s            ; ( n ud )
.8c39	20 48 9b	jsr $9b48	                jsr xt_rot                      ; ( ud n )
.8c3c	20 d8 9f	jsr $9fd8	                jsr xt_sign                     ; ( ud )
.8c3f	20 ad 97	jsr $97ad	                jsr xt_number_sign_greater      ; ( addr u )
.8c42	20 f4 a4	jsr $a4f4	                jsr xt_type
.8c45	20 0f a1	jsr $a10f	                jsr xt_space
.8c48	60		rts		z_dot:          rts
.8c49					xt_dot_paren:
.8c49	ca		dex		                dex
.8c4a	ca		dex		                dex
.8c4b	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c4d	95 00		sta $00,x	                sta 0,x
.8c4f	74 01		stz $01,x	                stz 1,x
.8c51	20 2b 99	jsr $992b	                jsr xt_parse
.8c54	20 f4 a4	jsr $a4f4	                jsr xt_type
.8c57	60		rts		z_dot_paren:    rts
.8c58					xt_dot_quote:
.8c58	20 40 9d	jsr $9d40	                jsr xt_s_quote
.8c5b	a0 a4		ldy #$a4	                ldy #>xt_type
.8c5d	a9 f4		lda #$f4	                lda #<xt_type
.8c5f	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.8c62	60		rts		z_dot_quote:    rts
.8c63					xt_dot_r:
.8c63	20 11 d9	jsr $d911	                jsr underflow_2
.8c66	20 61 a3	jsr $a361	                jsr xt_to_r
.8c69	20 a0 8d	jsr $8da0	                jsr xt_dup
.8c6c	20 2a 81	jsr $812a	                jsr xt_abs
.8c6f	20 99 a7	jsr $a799	                jsr xt_zero
.8c72	20 4b 93	jsr $934b	                jsr xt_less_number_sign
.8c75	20 cf 97	jsr $97cf	                jsr xt_number_sign_s
.8c78	20 48 9b	jsr $9b48	                jsr xt_rot
.8c7b	20 d8 9f	jsr $9fd8	                jsr xt_sign
.8c7e	20 ad 97	jsr $97ad	                jsr xt_number_sign_greater
.8c81	20 83 9a	jsr $9a83	                jsr xt_r_from
.8c84	20 84 98	jsr $9884	                jsr xt_over
.8c87	20 41 95	jsr $9541	                jsr xt_minus
.8c8a	20 15 a1	jsr $a115	                jsr xt_spaces
.8c8d	20 f4 a4	jsr $a4f4	                jsr xt_type
.8c90	60		rts		z_dot_r:        rts
.8c91					xt_dot_s:
.8c91	20 e7 8a	jsr $8ae7	                jsr xt_depth    ; ( -- u )
.8c94	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c96	20 e7 8d	jsr $8de7	                jsr emit_a
.8c99	b5 00		lda $00,x	                lda 0,x
.8c9b	48		pha		                pha
.8c9c	ca		dex		                dex             ; DUP
.8c9d	ca		dex		                dex
.8c9e	95 00		sta $00,x	                sta 0,x
.8ca0	74 01		stz $01,x	                stz 1,x
.8ca2	20 79 d9	jsr $d979	                jsr print_u
.8ca5	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8ca7	20 e7 8d	jsr $8de7	                jsr emit_a
.8caa	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8cac	20 e7 8d	jsr $8de7	                jsr emit_a
.8caf	e8		inx		                inx
.8cb0	e8		inx		                inx
.8cb1	e0 78		cpx #$78	                cpx #dsp0
.8cb3	f0 1e		beq $8cd3	                beq _done
.8cb5					_have_stack:
.8cb5	7a		ply		                ply
.8cb6	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8cb8	85 28		sta $28		                sta tmp3
.8cba	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8cbc					_loop:
.8cbc	ca		dex		                dex
.8cbd	ca		dex		                dex
.8cbe	b2 28		lda ($28)	                lda (tmp3)
.8cc0	95 01		sta $01,x	                sta 1,x
.8cc2	c6 28		dec $28		                dec tmp3
.8cc4	b2 28		lda ($28)	                lda (tmp3)
.8cc6	95 00		sta $00,x	                sta 0,x
.8cc8	c6 28		dec $28		                dec tmp3
.8cca	5a		phy		                phy
.8ccb	20 27 8c	jsr $8c27	                jsr xt_dot
.8cce	7a		ply		                ply
.8ccf	88		dey		                dey
.8cd0	d0 ea		bne $8cbc	                bne _loop
.8cd2	48		pha		                pha             ; dummy to balance stack
.8cd3					_done:
.8cd3	68		pla		                pla
.8cd4	60		rts		z_dot_s:        rts
.8cd5					xt_d_dot:
.8cd5	20 11 d9	jsr $d911	                jsr underflow_2
.8cd8	20 7e a3	jsr $a37e	                jsr xt_tuck
.8cdb	20 77 8a	jsr $8a77	                jsr xt_dabs
.8cde	20 4b 93	jsr $934b	                jsr xt_less_number_sign
.8ce1	20 cf 97	jsr $97cf	                jsr xt_number_sign_s
.8ce4	20 48 9b	jsr $9b48	                jsr xt_rot
.8ce7	20 d8 9f	jsr $9fd8	                jsr xt_sign
.8cea	20 ad 97	jsr $97ad	                jsr xt_number_sign_greater
.8ced	20 f4 a4	jsr $a4f4	                jsr xt_type
.8cf0	20 0f a1	jsr $a10f	                jsr xt_space
.8cf3	60		rts		z_d_dot:        rts
.8cf4					xt_d_dot_r:
.8cf4	20 16 d9	jsr $d916	                jsr underflow_3
.8cf7	20 61 a3	jsr $a361	                jsr xt_to_r
.8cfa	20 7e a3	jsr $a37e	                jsr xt_tuck
.8cfd	20 77 8a	jsr $8a77	                jsr xt_dabs
.8d00	20 4b 93	jsr $934b	                jsr xt_less_number_sign
.8d03	20 cf 97	jsr $97cf	                jsr xt_number_sign_s
.8d06	20 48 9b	jsr $9b48	                jsr xt_rot
.8d09	20 d8 9f	jsr $9fd8	                jsr xt_sign
.8d0c	20 ad 97	jsr $97ad	                jsr xt_number_sign_greater
.8d0f	20 83 9a	jsr $9a83	                jsr xt_r_from
.8d12	20 84 98	jsr $9884	                jsr xt_over
.8d15	20 41 95	jsr $9541	                jsr xt_minus
.8d18	20 15 a1	jsr $a115	                jsr xt_spaces
.8d1b	20 f4 a4	jsr $a4f4	                jsr xt_type
.8d1e	60		rts		z_d_dot_r:      rts
.8d1f					xt_drop:
.8d1f	20 0c d9	jsr $d90c	                jsr underflow_1
.8d22	e8		inx		                inx
.8d23	e8		inx		                inx
.8d24	60		rts		z_drop:         rts
.8d25					xt_dump:
.8d25	20 11 d9	jsr $d911	                jsr underflow_2
.8d28					_row:
.8d28	a0 10		ldy #$10	                ldy #16
.8d2a	64 26		stz $26		                stz tmp2
.8d2c	20 54 89	jsr $8954	                jsr xt_cr
.8d2f	b5 03		lda $03,x	                lda 3,x
.8d31	20 1c d8	jsr $d81c	                jsr byte_to_ascii
.8d34	b5 02		lda $02,x	                lda 2,x
.8d36	20 1c d8	jsr $d81c	                jsr byte_to_ascii
.8d39	20 0f a1	jsr $a10f	                jsr xt_space
.8d3c	20 0f a1	jsr $a10f	                jsr xt_space
.8d3f					_loop:
.8d3f	b5 00		lda $00,x	                lda 0,x
.8d41	15 01		ora $01,x	                ora 1,x
.8d43	f0 39		beq $8d7e	                beq _all_printed
.8d45	a1 02		lda ($02,x)	                lda (2,x)
.8d47	48		pha		                pha                     ; byte_to_ascii destroys A
.8d48	20 1c d8	jsr $d81c	                jsr byte_to_ascii
.8d4b	20 0f a1	jsr $a10f	                jsr xt_space
.8d4e	68		pla		                pla
.8d4f	20 f2 d8	jsr $d8f2	                jsr is_printable
.8d52	b0 02		bcs $8d56	                bcs _printable
.8d54	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d56					_printable:
.8d56	5a		phy		                phy                     ; save counter
.8d57	a4 26		ldy $26		                ldy tmp2
.8d59	91 00		sta ($00),y	                sta (cp),y
.8d5b	e6 26		inc $26		                inc tmp2
.8d5d	7a		ply		                ply
.8d5e	c0 09		cpy #$09	                cpy #9
.8d60	d0 03		bne $8d65	                bne _next_char
.8d62	20 0f a1	jsr $a10f	                jsr xt_space
.8d65					_next_char:
.8d65	f6 02		inc $02,x	                inc 2,x
.8d67	d0 02		bne $8d6b	                bne _counter
.8d69	f6 03		inc $03,x	                inc 3,x
.8d6b					_counter:
.8d6b	b5 00		lda $00,x	                lda 0,x
.8d6d	d0 02		bne $8d71	                bne +
.8d6f	d6 01		dec $01,x	                dec 1,x
.8d71					+
.8d71	d6 00		dec $00,x	                dec 0,x
.8d73	88		dey		                dey
.8d74	d0 c9		bne $8d3f	                bne _loop               ; next byte
.8d76	20 0f a1	jsr $a10f	                jsr xt_space
.8d79	20 8c 8d	jsr $8d8c	                jsr dump_print_ascii
.8d7c	80 aa		bra $8d28	                bra _row                ; new row
.8d7e					_all_printed:
.8d7e	a5 26		lda $26		                lda tmp2
.8d80	f0 06		beq $8d88	                beq _done
.8d82	20 0f a1	jsr $a10f	                jsr xt_space
.8d85	20 8c 8d	jsr $8d8c	                jsr dump_print_ascii
.8d88					_done:
.8d88	20 a1 a3	jsr $a3a1	                jsr xt_two_drop         ; one byte less than 4x INX
.8d8b	60		rts		z_dump:         rts
.8d8c					dump_print_ascii:
.8d8c	a0 00		ldy #$00	                ldy #0
.8d8e					_ascii_loop:
.8d8e	b1 00		lda ($00),y	                lda (cp),y
.8d90	20 e7 8d	jsr $8de7	                jsr emit_a
.8d93	c8		iny		                iny
.8d94	c0 08		cpy #$08	                cpy #8
.8d96	d0 03		bne $8d9b	                bne +
.8d98	20 0f a1	jsr $a10f	                jsr xt_space
.8d9b					+
.8d9b	c6 26		dec $26		                dec tmp2
.8d9d	d0 ef		bne $8d8e	                bne _ascii_loop
.8d9f	60		rts		                rts
.8da0					xt_dup:
.8da0	20 0c d9	jsr $d90c	                jsr underflow_1
.8da3	ca		dex		                dex
.8da4	ca		dex		                dex
.8da5	b5 02		lda $02,x	                lda 2,x         ; LSB
.8da7	95 00		sta $00,x	                sta 0,x
.8da9	b5 03		lda $03,x	                lda 3,x         ; MSB
.8dab	95 01		sta $01,x	                sta 1,x
.8dad	60		rts		z_dup:          rts
.8dae					xt_ed:
.8dae	20 73 b5	jsr $b573	                jsr ed6502      ; kept in separate file
.8db1	60		rts		z_ed:           rts
.8db2					xt_else:
.8db2					xt_endof:
.8db2	a0 8d		ldy #$8d	                ldy #>branch_runtime
.8db4	a9 cc		lda #$cc	                lda #<branch_runtime
.8db6	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.8db9	20 63 91	jsr $9163	                jsr xt_here
.8dbc	20 99 a7	jsr $a799	                jsr xt_zero
.8dbf	20 5f 87	jsr $875f	                jsr xt_comma
.8dc2	20 63 91	jsr $9163	                jsr xt_here
.8dc5	20 48 9b	jsr $9b48	                jsr xt_rot
.8dc8	20 7e a1	jsr $a17e	                jsr xt_store
.8dcb					z_else:
.8dcb					z_endof:
.8dcb	60		rts		                rts
.8dcc					branch_runtime:
.8dcc	68		pla		                pla
.8dcd	85 22		sta $22		                sta tmpbranch
.8dcf	68		pla		                pla
.8dd0	85 23		sta $23		                sta tmpbranch+1
.8dd2	a0 01		ldy #$01	                ldy #1
.8dd4	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8dd6	85 24		sta $24		                sta tmp1
.8dd8	c8		iny		                iny
.8dd9	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8ddb	85 25		sta $25		                sta tmp1+1
.8ddd	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8de0					xt_emit:
.8de0	20 0c d9	jsr $d90c	                jsr underflow_1
.8de3	b5 00		lda $00,x	                lda 0,x
.8de5	e8		inx		                inx
.8de6	e8		inx		                inx
.8de7					emit_a:
.8de7	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8dea					z_emit:
.8dea					xt_empty_buffers:
.8dea	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8dec	a9 00		lda #$00	                lda #0
.8dee	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8df0					z_empty_buffers:
.8df0	60		rts		                rts
.8df1					xt_endcase:
.8df1	a0 8d		ldy #$8d	                ldy #>xt_drop
.8df3	a9 1f		lda #$1f	                lda #<xt_drop
.8df5	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.8df8					_endcase_loop:
.8df8	b5 00		lda $00,x	                lda 0,x
.8dfa	15 01		ora $01,x	                ora 1,x
.8dfc	f0 05		beq $8e03	                beq _done
.8dfe	20 b3 a1	jsr $a1b3	                jsr xt_then
.8e01	80 f5		bra $8df8	                bra _endcase_loop
.8e03					_done:
.8e03	e8		inx		                inx
.8e04	e8		inx		                inx
.8e05	60		rts		z_endcase:      rts
.8e06					xt_environment_q:
.8e06	20 0c d9	jsr $d90c	                jsr underflow_1
.8e09	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8e0b	5a		phy		                phy
.8e0c					_table_loop:
.8e0c	20 a9 a3	jsr $a3a9	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e0f	ca		dex		                dex
.8e10	ca		dex		                dex                     ; ( addr u addr u ? )
.8e11	b9 83 8e	lda $8e83,y	                lda env_table_single,y
.8e14	95 00		sta $00,x	                sta 0,x
.8e16	c8		iny		                iny
.8e17	b9 83 8e	lda $8e83,y	                lda env_table_single,y
.8e1a	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e1c	c8		iny		                iny
.8e1d	15 00		ora $00,x	                ora 0,x
.8e1f	f0 4d		beq $8e6e	                beq _table_done
.8e21	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e22	20 40 89	jsr $8940	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e25	20 79 87	jsr $8779	                jsr xt_compare          ; ( addr u f )
.8e28	7a		ply		                ply
.8e29	b5 00		lda $00,x	                lda 0,x
.8e2b	15 01		ora $01,x	                ora 1,x
.8e2d	f0 04		beq $8e33	                beq _got_result
.8e2f	e8		inx		                inx                     ; DROP, now ( addr u )
.8e30	e8		inx		                inx
.8e31	80 d9		bra $8e0c	                bra _table_loop
.8e33					_got_result:
.8e33	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e34	e8		inx		                inx
.8e35	88		dey		                dey                     ; go back to index we had
.8e36	88		dey		                dey
.8e37	68		pla		                pla
.8e38	d0 0d		bne $8e47	                bne _double_result
.8e3a	b9 a1 8e	lda $8ea1,y	                lda env_results_single,y
.8e3d	95 02		sta $02,x	                sta 2,x
.8e3f	c8		iny		                iny
.8e40	b9 a1 8e	lda $8ea1,y	                lda env_results_single,y
.8e43	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e45	80 1f		bra $8e66	                bra _set_flag
.8e47					_double_result:
.8e47	ca		dex		                dex                     ; ( addr u ? )
.8e48	ca		dex		                dex
.8e49	98		tya		                tya
.8e4a	38		sec		                sec
.8e4b	e9 18		sbc #$18	                sbc #24
.8e4d	0a		asl a		                asl
.8e4e	a8		tay		                tay
.8e4f	b9 b7 8e	lda $8eb7,y	                lda env_results_double,y
.8e52	95 02		sta $02,x	                sta 2,x
.8e54	c8		iny		                iny
.8e55	b9 b7 8e	lda $8eb7,y	                lda env_results_double,y
.8e58	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e5a	c8		iny		                iny
.8e5b	b9 b7 8e	lda $8eb7,y	                lda env_results_double,y
.8e5e	95 04		sta $04,x	                sta 4,x
.8e60	c8		iny		                iny
.8e61	b9 b7 8e	lda $8eb7,y	                lda env_results_double,y
.8e64	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e66					_set_flag:
.8e66	a9 ff		lda #$ff	                lda #$ff
.8e68	95 00		sta $00,x	                sta 0,x
.8e6a	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e6c	80 14		bra $8e82	                bra _done
.8e6e					_table_done:
.8e6e	68		pla		                pla
.8e6f	d0 09		bne $8e7a	                bne _no_match
.8e71	1a		inc a		                ina
.8e72	48		pha		                pha
.8e73	8a		txa		                txa
.8e74	18		clc		                clc
.8e75	69 06		adc #$06	                adc #6                  ; skip six bytes
.8e77	aa		tax		                tax                     ; ( addr u )
.8e78	80 92		bra $8e0c	                bra _table_loop
.8e7a					_no_match:
.8e7a	8a		txa		                txa
.8e7b	18		clc		                clc
.8e7c	69 0a		adc #$0a	                adc #10
.8e7e	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e7f	20 6a 8f	jsr $8f6a	                jsr xt_false
.8e82					_done:
.8e82					z_environment_q:
.8e82	60		rts		                rts
.8e83					env_table_single:
>8e83	2f d7 3f d7 45 d7 4a d7		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e8b	5c d7
>8e8d	64 d7 6d d7 73 d7 79 d7		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e95	8c d7 98 d7 00 00		        .word envs_sc, envs_wl, 0000
.8e9b					env_table_double:
>8e9b	a2 d7 a8 d7 00 00		        .word envs_max_d, envs_max_ud, 0000
.8ea1					env_results_single:
>8ea1	ff 7f				        .word $7FFF     ; /COUNTED-STRING
>8ea3	ff 00				        .word $00FF     ; /HOLD
>8ea5	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8ea7	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8ea9	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8eab	ff 00				        .word $00FF     ; MAX-CHAR
>8ead	ff 7f				        .word $7FFF     ; MAX-N
>8eaf	ff ff				        .word $FFFF     ; MAX-U
>8eb1	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8eb3	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8eb5	09 00				        .word $0009     ; WORDLISTS
.8eb7					env_results_double:
>8eb7	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8ebb	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8ebf					xt_equal:
.8ebf	20 11 d9	jsr $d911	                jsr underflow_2
.8ec2	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8ec4	d5 02		cmp $02,x	                cmp 2,x
.8ec6	d0 0a		bne $8ed2	                bne _false
.8ec8	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8eca	d5 03		cmp $03,x	                cmp 3,x
.8ecc	d0 04		bne $8ed2	                bne _false
.8ece	a9 ff		lda #$ff	                lda #$ff
.8ed0	80 02		bra $8ed4	                bra _done
.8ed2	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8ed4	95 02		sta $02,x	_done:          sta 2,x
.8ed6	95 03		sta $03,x	                sta 3,x
.8ed8	e8		inx		                inx
.8ed9	e8		inx		                inx
.8eda	60		rts		z_equal:        rts
.8edb					xt_blank:
.8edb	ca		dex		                dex
.8edc	ca		dex		                dex
.8edd	a9 20		lda #$20	                lda #AscSP
.8edf	95 00		sta $00,x	                sta 0,x
.8ee1	74 01		stz $01,x	                stz 1,x
.8ee3	80 06		bra $8eeb	                bra xt_fill     ; skip over code for ERASE
.8ee5					xt_erase:
.8ee5	ca		dex		                dex
.8ee6	ca		dex		                dex
.8ee7	74 00		stz $00,x	                stz 0,x
.8ee9	74 01		stz $01,x	                stz 1,x
.8eeb					xt_fill:
.8eeb	20 16 d9	jsr $d916	                jsr underflow_3
.8eee	b5 04		lda $04,x	                lda 4,x         ; LSB
.8ef0	85 24		sta $24		                sta tmp1
.8ef2	b5 05		lda $05,x	                lda 5,x
.8ef4	85 25		sta $25		                sta tmp1+1
.8ef6	b5 02		lda $02,x	                lda 2,x
.8ef8	85 26		sta $26		                sta tmp2
.8efa	b5 03		lda $03,x	                lda 3,x
.8efc	85 27		sta $27		                sta tmp2+1
.8efe	b5 00		lda $00,x	                lda 0,x
.8f00	a8		tay		                tay
.8f01					_loop:
.8f01	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8f03	c5 25		cmp $25		                cmp tmp1+1
.8f05	90 21		bcc $8f28	                bcc _done               ; RAM_END < TMP1, so leave
.8f07	d0 06		bne $8f0f	                bne _check_counter      ; RAM_END is not smaller and not equal
.8f09	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8f0b	c5 24		cmp $24		                cmp tmp1
.8f0d	90 19		bcc $8f28	                bcc _done               ; RAM_END < TMP1, so leave
.8f0f					_check_counter:
.8f0f	a5 26		lda $26		                lda tmp2
.8f11	05 27		ora $27		                ora tmp2+1
.8f13	f0 13		beq $8f28	                beq _done
.8f15	98		tya		                tya
.8f16	92 24		sta ($24)	                sta (tmp1)
.8f18	a5 26		lda $26		                lda tmp2
.8f1a	d0 02		bne $8f1e	                bne +
.8f1c	c6 27		dec $27		                dec tmp2+1
.8f1e	c6 26		dec $26		+               dec tmp2
.8f20	e6 24		inc $24		                inc tmp1
.8f22	d0 dd		bne $8f01	                bne _loop
.8f24	e6 25		inc $25		                inc tmp1+1
.8f26	80 d9		bra $8f01	                bra _loop
.8f28					_done:
.8f28	8a		txa		                txa
.8f29	18		clc		                clc
.8f2a	69 06		adc #$06	                adc #6
.8f2c	aa		tax		                tax
.8f2d					z_blank:
.8f2d					z_erase:
.8f2d	60		rts		z_fill:         rts
.8f2e					xt_execute:
.8f2e	20 0c d9	jsr $d90c	                jsr underflow_1
.8f31	20 35 8f	jsr $8f35	                jsr doexecute   ; do not combine to JMP (native coding)
.8f34	60		rts		z_execute:      rts
.8f35					doexecute:
.8f35	b5 00		lda $00,x	                lda 0,x
.8f37	85 0e		sta $0e		                sta ip
.8f39	b5 01		lda $01,x	                lda 1,x
.8f3b	85 0f		sta $0f		                sta ip+1
.8f3d	e8		inx		                inx
.8f3e	e8		inx		                inx
.8f3f	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f42					xt_execute_parsing:
.8f42	20 16 d9	jsr $d916	                jsr underflow_3
.8f45	20 53 92	jsr $9253	                jsr xt_input_to_r       ; save normal input for later
.8f48	20 5f 96	jsr $965f	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f4b	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f4d	85 0a		sta $0a		                sta ciblen
.8f4f	b5 01		lda $01,x	                lda 1,x
.8f51	85 0b		sta $0b		                sta ciblen+1
.8f53	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f55	85 08		sta $08		                sta cib
.8f57	b5 03		lda $03,x	                lda 3,x
.8f59	85 09		sta $09		                sta cib+1
.8f5b	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f5d	64 0d		stz $0d		                stz toin+1
.8f5f	20 a1 a3	jsr $a3a1	                jsr xt_two_drop         ; 2DROP ( xt )
.8f62	20 2e 8f	jsr $8f2e	                jsr xt_execute
.8f65	20 94 9a	jsr $9a94	                jsr xt_r_to_input
.8f68					z_execute_parsing:
.8f68	60		rts		                rts
.8f69					xt_exit:
.8f69	60		rts		                rts             ; keep before z_exit
.8f6a					z_exit:
.8f6a					xt_false:
.8f6a	ca		dex		                dex
.8f6b	ca		dex		                dex
.8f6c	74 00		stz $00,x	                stz 0,x
.8f6e	74 01		stz $01,x	                stz 1,x
.8f70	60		rts		z_false:        rts
.8f71					xt_fetch:
.8f71	20 0c d9	jsr $d90c	                jsr underflow_1
.8f74	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f76	a8		tay		                tay
.8f77	f6 00		inc $00,x	                inc 0,x
.8f79	d0 02		bne $8f7d	                bne +
.8f7b	f6 01		inc $01,x	                inc 1,x
.8f7d					+
.8f7d	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f7f	95 01		sta $01,x	                sta 1,x
.8f81	94 00		sty $00,x	                sty 0,x
.8f83	60		rts		z_fetch:        rts
.8f84					xt_find:
.8f84	20 0c d9	jsr $d90c	                jsr underflow_1
.8f87	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f89	48		pha		                pha
.8f8a	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f8c	48		pha		                pha
.8f8d	20 40 89	jsr $8940	                jsr xt_count            ; ( caddr -- addr u )
.8f90	20 cc 8f	jsr $8fcc	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f93	b5 00		lda $00,x	                lda 0,x
.8f95	15 01		ora $01,x	                ora 1,x
.8f97	d0 0b		bne $8fa4	                bne _found_word
.8f99	20 6a 8f	jsr $8f6a	                jsr xt_false            ; ( 0 0 )
.8f9c	68		pla		                pla                     ; LSB of address
.8f9d	95 02		sta $02,x	                sta 2,x
.8f9f	68		pla		                pla
.8fa0	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8fa2	80 27		bra $8fcb	                bra _done               ; ( addr 0 )
.8fa4					_found_word:
.8fa4	68		pla		                pla
.8fa5	68		pla		                pla
.8fa6	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( nt nt )
.8fa9	20 d2 95	jsr $95d2	                jsr xt_name_to_int      ; ( nt xt )
.8fac	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( xt nt )
.8faf	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fb1	f6 00		inc $00,x	                inc 0,x
.8fb3	d0 02		bne $8fb7	                bne +
.8fb5	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fb7					+
.8fb7	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fb9	29 04		and #$04	                and #IM
.8fbb	d0 08		bne $8fc5	                bne _immediate          ; bit set, we're immediate
.8fbd	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fbf	95 00		sta $00,x	                sta 0,x
.8fc1	95 01		sta $01,x	                sta 1,x
.8fc3	80 06		bra $8fcb	                bra _done
.8fc5					_immediate:
.8fc5	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fc7	95 00		sta $00,x	                sta 0,x
.8fc9	74 01		stz $01,x	                stz 1,x
.8fcb					_done:
.8fcb	60		rts		z_find:         rts
.8fcc					xt_find_name:
.8fcc	20 11 d9	jsr $d911	                jsr underflow_2
.8fcf	b5 00		lda $00,x	                lda 0,x
.8fd1	15 01		ora $01,x	                ora 1,x
.8fd3	d0 03		bne $8fd8	                bne _nonempty
.8fd5	4c 71 90	jmp $9071	                jmp _fail_done
.8fd8					_nonempty:
.8fd8	64 28		stz $28		                stz tmp3                ; Start at the beginning
.8fda					_wordlist_loop:
.8fda	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8fdc	a5 28		lda $28		                lda tmp3
.8fde	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fe0	d0 03		bne $8fe5	                bne _have_string
.8fe2	4c 71 90	jmp $9071	                jmp _fail_done
.8fe5					_have_string:
.8fe5	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fe6	69 1f		adc #$1f	                adc #search_order_offset
.8fe8	a8		tay		                tay
.8fe9	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8feb	0a		asl a		                asl                     ; Turn offset into cells offset.
.8fec	18		clc		                clc
.8fed	69 06		adc #$06	                adc #wordlists_offset
.8fef	a8		tay		                tay
.8ff0	b1 1e		lda ($1e),y	                lda (up),y
.8ff2	85 24		sta $24		                sta tmp1
.8ff4	c8		iny		                iny
.8ff5	b1 1e		lda ($1e),y	                lda (up),y
.8ff7	85 25		sta $25		                sta tmp1+1
.8ff9	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.8ffb	85 26		sta $26		                sta tmp2
.8ffd	b5 03		lda $03,x	                lda 3,x
.8fff	85 27		sta $27		                sta tmp2+1
.9001					_loop:
.9001	b2 24		lda ($24)	                lda (tmp1)
.9003	d5 00		cmp $00,x	                cmp 0,x
.9005	d0 54		bne $905b	                bne _next_entry
.9007					_compare_string:
.9007	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9009	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.900b	b0 07		bcs $9014	                bcs _compare_first
.900d	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.900f	90 03		bcc $9014	                bcc _compare_first
.9011	18		clc		                clc
.9012	69 20		adc #$20	                adc #$20
.9014					_compare_first:
.9014	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9016	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9018	d0 41		bne $905b	                bne _next_entry
.901a	b5 00		lda $00,x	                lda 0,x
.901c	3a		dec a		                dea
.901d	f0 2c		beq $904b	                beq _success
.901f	a5 24		lda $24		                lda tmp1
.9021	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9022	18		clc		                clc
.9023	69 08		adc #$08	                adc #8
.9025	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9027	a5 25		lda $25		                lda tmp1+1
.9029	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.902a	69 00		adc #$00	                adc #0          ; we only need the carry
.902c	85 25		sta $25		                sta tmp1+1
.902e	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9030	88		dey		                dey
.9031					_string_loop:
.9031	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9033	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9035	b0 07		bcs $903e	                bcs _check_char
.9037	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9039	90 03		bcc $903e	                bcc _check_char
.903b	18		clc		                clc
.903c	69 20		adc #$20	                adc #$20
.903e					_check_char:
.903e	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9040	d0 13		bne $9055	                bne _next_entry_tmp1
.9042	88		dey		                dey
.9043	d0 ec		bne $9031	                bne _string_loop
.9045					_success_tmp1:
.9045	68		pla		                pla             ; Restore tmp1 from the return stack.
.9046	85 25		sta $25		                sta tmp1+1
.9048	68		pla		                pla
.9049	85 24		sta $24		                sta tmp1
.904b					_success:
.904b	a5 24		lda $24		                lda tmp1
.904d	95 02		sta $02,x	                sta 2,x
.904f	a5 25		lda $25		                lda tmp1+1
.9051	95 03		sta $03,x	                sta 3,x
.9053	80 20		bra $9075	                bra _done
.9055					_next_entry_tmp1:
.9055	68		pla		                pla             ; Restore tmp1 from the return stack.
.9056	85 25		sta $25		                sta tmp1+1
.9058	68		pla		                pla
.9059	85 24		sta $24		                sta tmp1
.905b					_next_entry:
.905b	a0 02		ldy #$02	                ldy #2
.905d	b1 24		lda ($24),y	                lda (tmp1),y
.905f	48		pha		                pha
.9060	c8		iny		                iny
.9061	b1 24		lda ($24),y	                lda (tmp1),y
.9063	85 25		sta $25		                sta tmp1+1
.9065	68		pla		                pla
.9066	85 24		sta $24		                sta tmp1
.9068	05 25		ora $25		                ora tmp1+1
.906a	d0 95		bne $9001	                bne _loop
.906c	e6 28		inc $28		                inc tmp3
.906e	4c da 8f	jmp $8fda	                jmp _wordlist_loop
.9071					_fail_done:
.9071	74 02		stz $02,x	                stz 2,x         ; failure flag
.9073	74 03		stz $03,x	                stz 3,x
.9075					_done:
.9075	e8		inx		                inx
.9076	e8		inx		                inx
.9077	60		rts		z_find_name:    rts
.9078					xt_flush:
.9078	20 af 9e	jsr $9eaf	                jsr xt_save_buffers
.907b	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.907d	a9 00		lda #$00	                lda #0
.907f	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9081					z_flush:
.9081	60		rts		                rts
.9082					xt_fm_slash_mod:
.9082	20 16 d9	jsr $d916	                jsr underflow_3
.9085	64 26		stz $26		                stz tmp2        ; default: n is positive
.9087	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9089	10 0e		bpl $9099	                bpl _check_d
.908b	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.908d	20 14 96	jsr $9614	                jsr xt_negate   ; NEGATE
.9090	20 61 a3	jsr $a361	                jsr xt_to_r     ; >R
.9093	20 32 8b	jsr $8b32	                jsr xt_dnegate  ; DNEGATE
.9096	20 83 9a	jsr $9a83	                jsr xt_r_from   ; R>
.9099					_check_d:
.9099	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.909b	10 0d		bpl $90aa	                bpl _multiply
.909d	18		clc		                clc
.909e	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.90a0	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.90a2	95 02		sta $02,x	                sta 2,x
.90a4	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90a6	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.90a8	95 03		sta $03,x	                sta 3,x
.90aa					_multiply:
.90aa	20 ab a5	jsr $a5ab	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90ad	a5 26		lda $26		                lda tmp2
.90af	f0 07		beq $90b8	                beq _done
.90b1	e8		inx		                inx             ; pretend that we SWAP
.90b2	e8		inx		                inx
.90b3	20 14 96	jsr $9614	                jsr xt_negate
.90b6	ca		dex		                dex
.90b7	ca		dex		                dex
.90b8					_done:
.90b8	60		rts		z_fm_slash_mod: rts
.90b9					xt_forth:
.90b9	a0 1f		ldy #$1f	                ldy #search_order_offset
.90bb	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90bd	91 1e		sta ($1e),y	                sta (up),y
.90bf					z_forth:
.90bf	60		rts		                rts
.90c0					load_evaluate:
.90c0	a9 ff		lda #$ff	                lda #$FF
.90c2	85 24		sta $24		                sta tmp1
.90c4	80 11		bra $90d7	                bra load_evaluate_start
.90c6					xt_evaluate:
.90c6	20 11 d9	jsr $d911	                jsr underflow_2
.90c9	64 24		stz $24		                stz tmp1
.90cb	b5 00		lda $00,x	                lda 0,x
.90cd	15 01		ora $01,x	                ora 1,x
.90cf	d0 06		bne $90d7	                bne evaluate_got_work
.90d1	e8		inx		                inx
.90d2	e8		inx		                inx
.90d3	e8		inx		                inx
.90d4	e8		inx		                inx
.90d5	80 42		bra $9119	                bra evaluate_done
.90d7					load_evaluate_start:
.90d7					evaluate_got_work:
.90d7	a0 01		ldy #$01	                ldy #blk_offset+1
.90d9	b1 1e		lda ($1e),y	                lda (up),y
.90db	48		pha		                pha
.90dc	88		dey		                dey
.90dd	b1 1e		lda ($1e),y	                lda (up),y
.90df	48		pha		                pha
.90e0	a5 24		lda $24		                lda tmp1
.90e2	d0 05		bne $90e9	                bne _nozero
.90e4	91 1e		sta ($1e),y	                sta (up),y
.90e6	c8		iny		                iny
.90e7	91 1e		sta ($1e),y	                sta (up),y
.90e9					_nozero:
.90e9	20 53 92	jsr $9253	                jsr xt_input_to_r
.90ec	a9 ff		lda #$ff	                lda #$ff
.90ee	85 06		sta $06		                sta insrc
.90f0	85 07		sta $07		                sta insrc+1
.90f2	64 0c		stz $0c		                stz toin
.90f4	64 0d		stz $0d		                stz toin+1
.90f6	b5 00		lda $00,x	                lda 0,x
.90f8	85 0a		sta $0a		                sta ciblen
.90fa	b5 01		lda $01,x	                lda 1,x
.90fc	85 0b		sta $0b		                sta ciblen+1
.90fe	b5 02		lda $02,x	                lda 2,x
.9100	85 08		sta $08		                sta cib
.9102	b5 03		lda $03,x	                lda 3,x
.9104	85 09		sta $09		                sta cib+1
.9106	e8		inx		                inx             ; A clean stack is a clean mind
.9107	e8		inx		                inx
.9108	e8		inx		                inx
.9109	e8		inx		                inx
.910a	20 74 d8	jsr $d874	                jsr interpret   ; ( -- )
.910d	20 94 9a	jsr $9a94	                jsr xt_r_to_input
.9110	a0 00		ldy #$00	                ldy #blk_offset
.9112	68		pla		                pla
.9113	91 1e		sta ($1e),y	                sta (up),y
.9115	c8		iny		                iny
.9116	68		pla		                pla
.9117	91 1e		sta ($1e),y	                sta (up),y
.9119					evaluate_done:
.9119	60		rts		z_evaluate:     rts
.911a					xt_get_current:
.911a	ca		dex		                dex
.911b	ca		dex		                dex
.911c	a0 04		ldy #$04	                ldy #current_offset
.911e	b1 1e		lda ($1e),y	                lda (up),y
.9120	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.9122	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.9124	60		rts		z_get_current:  rts
.9125					xt_get_order:
.9125	a0 1e		ldy #$1e	                ldy #num_order_offset
.9127	b1 1e		lda ($1e),y	                lda (up),y
.9129	85 24		sta $24		                sta tmp1
.912b	f0 16		beq $9143	                beq _done       ; If zero, there are no wordlists.
.912d					_loop:
.912d	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.912f	a9 1f		lda #$1f	                lda #search_order_offset
.9131	18		clc		                clc
.9132	65 24		adc $24		                adc tmp1
.9134	a8		tay		                tay
.9135	ca		dex		                dex
.9136	ca		dex		                dex
.9137	b1 1e		lda ($1e),y	                lda (up),y
.9139	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.913b	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.913d	a9 00		lda #$00	                lda #0
.913f	c5 24		cmp $24		                cmp tmp1
.9141	d0 ea		bne $912d	                bne _loop
.9143					_done:
.9143	ca		dex		                dex
.9144	ca		dex		                dex
.9145	a0 1e		ldy #$1e	                ldy #num_order_offset
.9147	b1 1e		lda ($1e),y	                lda (up),y
.9149	95 00		sta $00,x	                sta 0,x
.914b	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.914d	60		rts		z_get_order:    rts
.914e					xt_greater_than:
.914e	20 11 d9	jsr $d911	                jsr underflow_2
.9151	a0 00		ldy #$00	                ldy #0          ; default false
.9153	20 33 d8	jsr $d833	                jsr compare_16bit
.9156	f0 03		beq $915b	                beq _false
.9158	10 01		bpl $915b	                bpl _false
.915a	88		dey		                dey
.915b					_false:
.915b	98		tya		                tya
.915c	e8		inx		                inx
.915d	e8		inx		                inx
.915e	95 00		sta $00,x	                sta 0,x
.9160	95 01		sta $01,x	                sta 1,x
.9162	60		rts		z_greater_than: rts
.9163					xt_here:
.9163					xt_asm_arrow:
.9163	ca		dex		                dex
.9164	ca		dex		                dex
.9165	a5 00		lda $00		                lda cp
.9167	95 00		sta $00,x	                sta 0,x
.9169	a5 01		lda $01		                lda cp+1
.916b	95 01		sta $01,x	                sta 1,x
.916d					z_asm_arrow:
.916d	60		rts		z_here:         rts
.916e					xt_hex:
.916e	a9 10		lda #$10	                lda #16
.9170	85 18		sta $18		                sta base
.9172	64 19		stz $19		                stz base+1              ; paranoid
.9174	60		rts		z_hex:          rts
.9175					xt_hexstore:
.9175	20 16 d9	jsr $d916	                jsr underflow_3
.9178	20 a0 8d	jsr $8da0	                jsr xt_dup              ; Save copy of original address
.917b	20 93 a4	jsr $a493	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.917e					_loop:
.917e	b5 00		lda $00,x	                lda 0,x
.9180	15 01		ora $01,x	                ora 1,x
.9182	f0 36		beq $91ba	                beq _done
.9184	20 3d 86	jsr $863d	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9187	20 93 a4	jsr $a493	                jsr xt_two_to_r
.918a	20 99 a7	jsr $a799	                jsr xt_zero
.918d	20 99 a7	jsr $a799	                jsr xt_zero
.9190	20 19 a4	jsr $a419	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9193	20 ae a2	jsr $a2ae	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9196	b5 00		lda $00,x	                lda 0,x
.9198	15 01		ora $01,x	                ora 1,x
.919a	d0 17		bne $91b3	                bne _have_chars_left
.919c	20 a1 a3	jsr $a3a1	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.919f	20 71 8a	jsr $8a71	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.91a2	20 6e 9a	jsr $9a6e	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.91a5	20 06 86	jsr $8606	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.91a8	20 83 9a	jsr $9a83	                jsr xt_r_from           ; R>
.91ab	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+
.91ae	20 61 a3	jsr $a361	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91b1	80 cb		bra $917e	                bra _loop
.91b3					_have_chars_left:
.91b3	8a		txa		                txa
.91b4	18		clc		                clc
.91b5	69 08		adc #$08	                adc #8
.91b7	aa		tax		                tax
.91b8	80 c4		bra $917e	                bra _loop
.91ba					_done:
.91ba	e8		inx		                inx
.91bb	e8		inx		                inx
.91bc	e8		inx		                inx
.91bd	e8		inx		                inx                     ; 2DROP
.91be	20 19 a4	jsr $a419	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91c1	20 9f a1	jsr $a19f	                jsr xt_swap
.91c4	20 41 95	jsr $9541	                jsr xt_minus            ; ( n )
.91c7	60		rts		z_hexstore:     rts
.91c8					xt_hold:
.91c8	20 0c d9	jsr $d90c	                jsr underflow_1
.91cb	a5 34		lda $34		                lda tohold
.91cd	d0 02		bne $91d1	                bne +
.91cf	c6 35		dec $35		                dec tohold+1
.91d1					+
.91d1	c6 34		dec $34		                dec tohold
.91d3	b5 00		lda $00,x	                lda 0,x
.91d5	92 34		sta ($34)	                sta (tohold)
.91d7	e8		inx		                inx
.91d8	e8		inx		                inx
.91d9	60		rts		z_hold:         rts
.91da					xt_i:
.91da	ca		dex		                dex
.91db	ca		dex		                dex
.91dc	86 2a		stx $2a		                stx tmpdsp
.91de	ba		tsx		                tsx
.91df	38		sec		                sec
.91e0	bd 01 01	lda $0101,x	                lda $0101,x     ; LSB
.91e3	fd 03 01	sbc $0103,x	                sbc $0103,x
.91e6	a8		tay		                tay
.91e7	bd 02 01	lda $0102,x	                lda $0102,x     ; MSB
.91ea	fd 04 01	sbc $0104,x	                sbc $0104,x
.91ed	a6 2a		ldx $2a		                ldx tmpdsp
.91ef	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.91f1	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.91f3	60		rts		z_i:            rts
.91f4					xt_if:
.91f4	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.91f6	a9 05		lda #$05	                lda #<zero_branch_runtime
.91f8	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.91fb	20 63 91	jsr $9163	                jsr xt_here
.91fe	20 99 a7	jsr $a799	                jsr xt_zero
.9201	20 5f 87	jsr $875f	                jsr xt_comma
.9204	60		rts		z_if:           rts
.9205					zero_branch_runtime:
.9205	68		pla		                pla
.9206	85 22		sta $22		                sta tmpbranch
.9208	68		pla		                pla
.9209	85 23		sta $23		                sta tmpbranch+1
.920b	b5 00		lda $00,x	                lda 0,x
.920d	15 01		ora $01,x	                ora 1,x
.920f	f0 0f		beq $9220	                beq _zero
.9211	a5 22		lda $22		                lda tmpbranch   ; LSB
.9213	18		clc		                clc
.9214	69 02		adc #$02	                adc #2
.9216	85 24		sta $24		                sta tmp1
.9218	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.921a	69 00		adc #$00	                adc #0          ; For carry
.921c	85 25		sta $25		                sta tmp1+1
.921e	80 13		bra $9233	                bra _done
.9220					_zero:
.9220	a0 01		ldy #$01	                ldy #1
.9222	b1 22		lda ($22),y	                lda (tmpbranch),y
.9224	85 24		sta $24		                sta tmp1
.9226	c8		iny		                iny
.9227	b1 22		lda ($22),y	                lda (tmpbranch),y
.9229	85 25		sta $25		                sta tmp1+1
.922b	a5 24		lda $24		                lda tmp1
.922d	d0 02		bne $9231	                bne +
.922f	c6 25		dec $25		                dec tmp1+1
.9231					+
.9231	c6 24		dec $24		                dec tmp1
.9233					_done:
.9233	a5 25		lda $25		                lda tmp1+1
.9235	48		pha		                pha             ; MSB first
.9236	a5 24		lda $24		                lda tmp1
.9238	48		pha		                pha
.9239	e8		inx		                inx
.923a	e8		inx		                inx
.923b	60		rts		                rts
.923c					xt_immediate:
.923c	20 4e d8	jsr $d84e	                jsr current_to_dp
.923f	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9241	b1 02		lda ($02),y	                lda (dp),y
.9243	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9245	91 02		sta ($02),y	                sta (dp),y
.9247	60		rts		z_immediate:    rts
.9248					xt_input:
.9248	ca		dex		                dex
.9249	ca		dex		                dex
.924a	a9 12		lda #$12	                lda #<input
.924c	95 00		sta $00,x	                sta 0,x
.924e	a9 00		lda #$00	                lda #>input
.9250	95 01		sta $01,x	                sta 1,x
.9252	60		rts		z_input:        rts
.9253					xt_input_to_r:
.9253	68		pla		                pla
.9254	85 24		sta $24		                sta tmp1
.9256	68		pla		                pla
.9257	85 25		sta $25		                sta tmp1+1
.9259	a0 07		ldy #$07	                ldy #7
.925b					_loop:
.925b	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.925e	48		pha		                pha
.925f	88		dey		                dey
.9260	10 f9		bpl $925b	                bpl _loop
.9262	a5 25		lda $25		                lda tmp1+1
.9264	48		pha		                pha
.9265	a5 24		lda $24		                lda tmp1
.9267	48		pha		                pha
.9268	60		rts		z_input_to_r: 	rts
.9269					xt_int_to_name:
.9269	20 0c d9	jsr $d90c	                jsr underflow_1
.926c	ca		dex		                dex
.926d	ca		dex		                dex
.926e	74 00		stz $00,x	                stz 0,x
.9270	74 01		stz $01,x	                stz 1,x
.9272					_wordlist_loop:
.9272	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9274	0a		asl a		                asl                     ; Turn offset into cells offset.
.9275	18		clc		                clc
.9276	69 06		adc #$06	                adc #wordlists_offset
.9278	a8		tay		                tay
.9279	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.927b	85 26		sta $26		                sta tmp2                ; into tmp2
.927d	c8		iny		                iny
.927e	b1 1e		lda ($1e),y	                lda (up),y
.9280	85 27		sta $27		                sta tmp2+1
.9282	a5 26		lda $26		                lda tmp2
.9284	05 27		ora $27		                ora tmp2+1
.9286	f0 38		beq $92c0	                beq _next_wordlist
.9288	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.928a	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.928c	b5 03		lda $03,x	                lda 3,x
.928e	85 29		sta $29		                sta tmp3+1
.9290					_loop:
.9290	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9292	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.9294	c5 28		cmp $28		                cmp tmp3
.9296	d0 07		bne $929f	                bne _no_match
.9298	c8		iny		                iny
.9299	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.929b	c5 29		cmp $29		                cmp tmp3+1
.929d	f0 32		beq $92d1	                beq _match
.929f					_no_match:
.929f	18		clc		                clc
.92a0	a5 26		lda $26		                lda tmp2
.92a2	69 02		adc #$02	                adc #2
.92a4	85 26		sta $26		                sta tmp2
.92a6	a5 27		lda $27		                lda tmp2+1
.92a8	69 00		adc #$00	                adc #0          ; only care about carry
.92aa	85 27		sta $27		                sta tmp2+1
.92ac	a0 00		ldy #$00	                ldy #0
.92ae	b1 26		lda ($26),y	                lda (tmp2),y
.92b0	48		pha		                pha
.92b1	c8		iny		                iny
.92b2	11 26		ora ($26),y	                ora (tmp2),y
.92b4	f0 09		beq $92bf	                beq _zero
.92b6	b1 26		lda ($26),y	                lda (tmp2),y
.92b8	85 27		sta $27		                sta tmp2+1
.92ba	68		pla		                pla
.92bb	85 26		sta $26		                sta tmp2
.92bd	80 d1		bra $9290	                bra _loop
.92bf					_zero:
.92bf	68		pla		                pla             ; Leftover from above loop
.92c0					_next_wordlist:
.92c0	b5 00		lda $00,x	                lda 0,x
.92c2	1a		inc a		                ina
.92c3	95 00		sta $00,x	                sta 0,x
.92c5	c9 0c		cmp #$0c	                cmp #max_wordlists
.92c7	d0 a9		bne $9272	                bne _wordlist_loop
.92c9	e8		inx		                inx
.92ca	e8		inx		                inx
.92cb	74 00		stz $00,x	                stz 0,x
.92cd	74 01		stz $01,x	                stz 1,x
.92cf	80 0a		bra $92db	                bra z_int_to_name
.92d1					_match:
.92d1	e8		inx		                inx
.92d2	e8		inx		                inx
.92d3	a5 26		lda $26		                lda tmp2
.92d5	95 00		sta $00,x	                sta 0,x
.92d7	a5 27		lda $27		                lda tmp2+1
.92d9	95 01		sta $01,x	                sta 1,x
.92db	60		rts		z_int_to_name:  rts
.92dc					xt_invert:
.92dc	20 0c d9	jsr $d90c	                jsr underflow_1
.92df	a9 ff		lda #$ff	                lda #$FF
.92e1	55 00		eor $00,x	                eor 0,x         ; LSB
.92e3	95 00		sta $00,x	                sta 0,x
.92e5	a9 ff		lda #$ff	                lda #$FF
.92e7	55 01		eor $01,x	                eor 1,x         ; MSB
.92e9	95 01		sta $01,x	                sta 1,x
.92eb	60		rts		z_invert:       rts
.92ec					xt_is:
.92ec	a5 16		lda $16		                lda state
.92ee	05 17		ora $17		                ora state+1
.92f0	f0 0c		beq $92fe	                beq _interpreting
.92f2					_compiling:
.92f2	20 8f 85	jsr $858f	                jsr xt_bracket_tick
.92f5	a0 8a		ldy #$8a	                ldy #>xt_defer_store
.92f7	a9 d7		lda #$d7	                lda #<xt_defer_store
.92f9	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.92fc	80 06		bra $9304	                bra _done
.92fe					_interpreting:
.92fe	20 02 a2	jsr $a202	                jsr xt_tick
.9301	20 d7 8a	jsr $8ad7	                jsr xt_defer_store
.9304					_done:
.9304	60		rts		z_is:           rts
.9305					xt_j:
.9305	ca		dex		                dex
.9306	ca		dex		                dex
.9307	86 2a		stx $2a		                stx tmpdsp
.9309	ba		tsx		                tsx
.930a	38		sec		                sec
.930b	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.930e	fd 09 01	sbc $0109,x	                sbc $0109,x
.9311	a8		tay		                tay
.9312	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.9315	fd 0a 01	sbc $010a,x	                sbc $010A,x
.9318	a6 2a		ldx $2a		                ldx tmpdsp
.931a	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.931c	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.931e	60		rts		z_j:            rts
.931f					xt_key:
.931f	20 29 93	jsr $9329	                jsr key_a               ; returns char in A
.9322	ca		dex		                dex
.9323	ca		dex		                dex
.9324	95 00		sta $00,x	                sta 0,x
.9326	74 01		stz $01,x	                stz 1,x
.9328	60		rts		z_key:          rts
.9329					key_a:
.9329	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.932c					xt_latestnt:
.932c	ca		dex		                dex
.932d	ca		dex		                dex
.932e	20 4e d8	jsr $d84e	                jsr current_to_dp
.9331	a5 02		lda $02		                lda dp
.9333	95 00		sta $00,x	                sta 0,x
.9335	a5 03		lda $03		                lda dp+1
.9337	95 01		sta $01,x	                sta 1,x
.9339	60		rts		z_latestnt:     rts
.933a					xt_latestxt:
.933a	20 2c 93	jsr $932c	                jsr xt_latestnt         ; ( nt )
.933d	20 d2 95	jsr $95d2	                jsr xt_name_to_int      ; ( xt )
.9340	60		rts		z_latestxt:     rts
.9341					xt_leave:
.9341	68		pla		                pla
.9342	68		pla		                pla
.9343	68		pla		                pla
.9344	68		pla		                pla
.9345	60		rts		                rts             ; this must be compiled, so keep before z_leave
.9346					z_leave:
.9346					xt_left_bracket:
.9346	64 16		stz $16		                stz state
.9348	64 17		stz $17		                stz state+1
.934a	60		rts		z_left_bracket: rts
.934b					xt_less_number_sign:
.934b	20 92 98	jsr $9892	                jsr xt_pad      ; ( addr )
.934e	b5 00		lda $00,x	                lda 0,x
.9350	85 34		sta $34		                sta tohold
.9352	b5 01		lda $01,x	                lda 1,x
.9354	85 35		sta $35		                sta tohold+1
.9356	e8		inx		                inx
.9357	e8		inx		                inx
.9358					z_less_number_sign:
.9358	60		rts		                rts
.9359					xt_less_than:
.9359	20 11 d9	jsr $d911	                jsr underflow_2
.935c	a0 00		ldy #$00	                ldy #0          ; default false
.935e	20 33 d8	jsr $d833	                jsr compare_16bit
.9361	f0 03		beq $9366	                beq _false
.9363	30 01		bmi $9366	                bmi _false
.9365	88		dey		                dey
.9366					_false:
.9366	98		tya		                tya
.9367	e8		inx		                inx
.9368	e8		inx		                inx
.9369	95 00		sta $00,x	                sta 0,x
.936b	95 01		sta $01,x	                sta 1,x
.936d	60		rts		z_less_than:    rts
.936e					xt_list:
.936e	20 0c d9	jsr $d90c	                jsr underflow_1
.9371	20 ca 9e	jsr $9eca	                jsr xt_scr
.9374	20 7e a1	jsr $a17e	                jsr xt_store
.9377	20 37 a8	jsr $a837	                jsr xt_editor_l
.937a	60		rts		z_list:         rts
.937b					xt_literal:
.937b	20 0c d9	jsr $d90c	                jsr underflow_1
.937e	a0 93		ldy #$93	                ldy #>literal_runtime
.9380	a9 89		lda #$89	                lda #<literal_runtime
.9382	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.9385	20 5f 87	jsr $875f	                jsr xt_comma
.9388	60		rts		z_literal:      rts
.9389					literal_runtime:
.9389	ca		dex		                dex
.938a	ca		dex		                dex
.938b	68		pla		                pla             ; LSB
.938c	85 24		sta $24		                sta tmp1
.938e	68		pla		                pla             ; MSB
.938f	85 25		sta $25		                sta tmp1+1
.9391	a0 01		ldy #$01	                ldy #1
.9393	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.9395	95 00		sta $00,x	                sta 0,x
.9397	c8		iny		                iny
.9398	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.939a	95 01		sta $01,x	                sta 1,x
.939c	98		tya		                tya
.939d	18		clc		                clc
.939e	65 24		adc $24		                adc tmp1
.93a0	a8		tay		                tay
.93a1	a5 25		lda $25		                lda tmp1+1
.93a3	69 00		adc #$00	                adc #0
.93a5	48		pha		                pha
.93a6	5a		phy		                phy
.93a7	60		rts		                rts
.93a8					xt_load:
.93a8	20 0c d9	jsr $d90c	                jsr underflow_1
.93ab	a0 01		ldy #$01	                ldy #blk_offset+1
.93ad	b1 1e		lda ($1e),y	                lda (up),y
.93af	48		pha		                pha
.93b0	88		dey		                dey
.93b1	b1 1e		lda ($1e),y	                lda (up),y
.93b3	48		pha		                pha
.93b4	b5 00		lda $00,x	                lda 0,x
.93b6	91 1e		sta ($1e),y	                sta (up),y
.93b8	c8		iny		                iny
.93b9	b5 01		lda $01,x	                lda 1,x
.93bb	91 1e		sta ($1e),y	                sta (up),y
.93bd	20 b2 83	jsr $83b2	                jsr xt_block
.93c0	ca		dex		                dex
.93c1	ca		dex		                dex
.93c2	a9 04		lda #$04	                lda #4
.93c4	95 01		sta $01,x	                sta 1,x
.93c6	74 00		stz $00,x	                stz 0,x
.93c8	20 c0 90	jsr $90c0	                jsr load_evaluate
.93cb	a0 00		ldy #$00	                ldy #blk_offset
.93cd	68		pla		                pla
.93ce	91 1e		sta ($1e),y	                sta (up),y
.93d0	c8		iny		                iny
.93d1	68		pla		                pla
.93d2	91 1e		sta ($1e),y	                sta (up),y
.93d4	88		dey		                dey
.93d5	11 1e		ora ($1e),y	                ora (up),y
.93d7	f0 12		beq $93eb	                beq _done
.93d9	ca		dex		                dex
.93da	ca		dex		                dex
.93db	a0 00		ldy #$00	                ldy #blk_offset
.93dd	b1 1e		lda ($1e),y	                lda (up),y
.93df	95 00		sta $00,x	                sta 0,x
.93e1	c8		iny		                iny
.93e2	b1 1e		lda ($1e),y	                lda (up),y
.93e4	95 01		sta $01,x	                sta 1,x
.93e6	20 b2 83	jsr $83b2	                jsr xt_block
.93e9	e8		inx		                inx
.93ea	e8		inx		                inx
.93eb					_done:
.93eb	60		rts		z_load:         rts
.93ec					xt_loop:
.93ec	a0 97		ldy #$97	                ldy #>xt_one
.93ee	a9 f9		lda #$f9	                lda #<xt_one
.93f0	20 af d7	jsr $d7af	                jsr cmpl_subroutine     ; drop through to +LOOP
.93f3					xt_plus_loop:
.93f3	a0 11		ldy #$11	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93f5	5a		phy		                phy             ; save counter to adjust CP
.93f6					-
.93f6	b9 5a 94	lda $945a,y	                lda plus_loop_runtime,y
.93f9	91 00		sta ($00),y	                sta (cp),y
.93fb	88		dey		                dey
.93fc	10 f8		bpl $93f6	                bpl -
.93fe	68		pla		                pla
.93ff	18		clc		                clc
.9400	65 00		adc $00		                adc cp
.9402	85 00		sta $00		                sta cp
.9404	a5 01		lda $01		                lda cp+1
.9406	69 00		adc #$00	                adc #0          ; only need carry
.9408	85 01		sta $01		                sta cp+1
.940a	20 5f 87	jsr $875f	                jsr xt_comma
.940d	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.940f	a0 06		ldy #$06	                ldy #6
.9411					-
.9411	91 00		sta ($00),y	                sta (cp),y
.9413	88		dey		                dey
.9414	10 fb		bpl $9411	                bpl -
.9416	a9 06		lda #$06	                lda #6
.9418	18		clc		                clc
.9419	65 00		adc $00		                adc cp
.941b	85 00		sta $00		                sta cp
.941d	a5 01		lda $01		                lda cp+1
.941f	69 00		adc #$00	                adc #0                  ; only need carry
.9421	85 01		sta $01		                sta cp+1
.9423	b5 00		lda $00,x	                lda 0,x
.9425	85 24		sta $24		                sta tmp1
.9427	b5 01		lda $01,x	                lda 1,x
.9429	85 25		sta $25		                sta tmp1+1
.942b	e8		inx		                inx
.942c	e8		inx		                inx
.942d	a5 00		lda $00		                lda cp
.942f	38		sec		                sec
.9430	e9 01		sbc #$01	                sbc #1
.9432	85 26		sta $26		                sta tmp2
.9434	a5 01		lda $01		                lda cp+1
.9436	e9 00		sbc #$00	                sbc #0
.9438	85 27		sta $27		                sta tmp2+1
.943a	a0 00		ldy #$00	                ldy #0
.943c	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.943e	91 24		sta ($24),y	                sta (tmp1),y
.9440	c8		iny		                iny
.9441	a5 27		lda $27		                lda tmp2+1      ; MSB
.9443	91 24		sta ($24),y	                sta (tmp1),y
.9445	c8		iny		                iny
.9446	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9448	91 24		sta ($24),y	                sta (tmp1),y
.944a	c8		iny		                iny
.944b	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.944d	91 24		sta ($24),y	                sta (tmp1),y
.944f	c8		iny		                iny
.9450	a5 26		lda $26		                lda tmp2        ; LSB
.9452	91 24		sta ($24),y	                sta (tmp1),y
.9454	c8		iny		                iny
.9455	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9457	91 24		sta ($24),y	                sta (tmp1),y
.9459					z_loop:
.9459	60		rts		z_plus_loop:    rts
.945a					plus_loop_runtime:
.945a	18		clc		                clc
.945b	68		pla		                pla             ; LSB of index
.945c	75 00		adc $00,x	                adc 0,x         ; LSB of step
.945e	a8		tay		                tay             ; temporary storage of LSB
.945f	b8		clv		                clv
.9460	68		pla		                pla             ; MSB of index
.9461	75 01		adc $01,x	                adc 1,x         ; MSB of step
.9463	48		pha		                pha             ; put MSB of index back on stack
.9464	98		tya		                tya             ; put LSB of index back on stack
.9465	48		pha		                pha
.9466	e8		inx		                inx             ; dump step from TOS
.9467	e8		inx		                inx
.9468	70 03		bvs $946d	                bvs _hack+3     ; skip over JMP instruction
.946a					_hack:
>946a	4c				                .byte $4C
.946b					plus_loop_runtime_end:
.946b					xt_lshift:
.946b	20 11 d9	jsr $d911	                jsr underflow_2
.946e	b5 00		lda $00,x	                lda 0,x
.9470	29 0f		and #$0f	                and #%00001111
.9472	f0 08		beq $947c	                beq _done
.9474	a8		tay		                tay
.9475					_loop:
.9475	16 02		asl $02,x	                asl 2,x
.9477	36 03		rol $03,x	                rol 3,x
.9479	88		dey		                dey
.947a	d0 f9		bne $9475	                bne _loop
.947c					_done:
.947c	e8		inx		                inx
.947d	e8		inx		                inx
.947e	60		rts		z_lshift:       rts
.947f					xt_m_star:
.947f	20 11 d9	jsr $d911	                jsr underflow_2
.9482	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9484	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.9486	48		pha		                pha
.9487	20 2a 81	jsr $812a	                jsr xt_abs
.948a	20 9f a1	jsr $a19f	                jsr xt_swap
.948d	20 2a 81	jsr $812a	                jsr xt_abs
.9490	20 ed a5	jsr $a5ed	                jsr xt_um_star          ; ( d )
.9493	68		pla		                pla
.9494	10 03		bpl $9499	                bpl _done
.9496	20 32 8b	jsr $8b32	                jsr xt_dnegate
.9499					_done:
.9499	60		rts		z_m_star:       rts
.949a					xt_marker:
.949a	20 4e d8	jsr $d84e	                jsr current_to_dp
.949d	a5 02		lda $02		                lda dp
.949f	48		pha		                pha
.94a0	a5 03		lda $03		                lda dp+1
.94a2	48		pha		                pha
.94a3	a5 00		lda $00		                lda cp
.94a5	48		pha		                pha
.94a6	a5 01		lda $01		                lda cp+1
.94a8	48		pha		                pha
.94a9	20 5a 89	jsr $895a	                jsr xt_create
.94ac	a5 00		lda $00		                lda cp          ; LSB
.94ae	38		sec		                sec
.94af	e9 02		sbc #$02	                sbc #2
.94b1	85 00		sta $00		                sta cp
.94b3	a5 01		lda $01		                lda cp+1        ; MSB
.94b5	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94b7	85 01		sta $01		                sta cp+1
.94b9	a0 94		ldy #$94	                ldy #>marker_runtime
.94bb	a9 d8		lda #$d8	                lda #<marker_runtime
.94bd	20 bb d7	jsr $d7bb	                jsr cmpl_word
.94c0	7a		ply		                ply                     ; MSB
.94c1	68		pla		                pla                     ; LSB
.94c2	20 bb d7	jsr $d7bb	                jsr cmpl_word
.94c5	7a		ply		                ply                     ; MSB
.94c6	68		pla		                pla                     ; LSB
.94c7	20 bb d7	jsr $d7bb	                jsr cmpl_word
.94ca	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94cc					_marker_loop:
.94cc	b1 1e		lda ($1e),y	                lda (up),y
.94ce	20 bf d7	jsr $d7bf	                jsr cmpl_a
.94d1	c8		iny		                iny
.94d2	98		tya		                tya
.94d3	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94d5	d0 f5		bne $94cc	                bne _marker_loop
.94d7	60		rts		z_marker:       rts
.94d8					marker_runtime:
.94d8	68		pla		                pla
.94d9	85 24		sta $24		                sta tmp1        ; LSB of address
.94db	68		pla		                pla
.94dc	85 25		sta $25		                sta tmp1+1      ; MSB of address
.94de	e6 24		inc $24		                inc tmp1
.94e0	d0 02		bne $94e4	                bne +
.94e2	e6 25		inc $25		                inc tmp1+1
.94e4					+
.94e4	a0 00		ldy #$00	                ldy #0
.94e6	b1 24		lda ($24),y	                lda (tmp1),y
.94e8	85 00		sta $00		                sta cp
.94ea	c8		iny		                iny
.94eb	b1 24		lda ($24),y	                lda (tmp1),y
.94ed	85 01		sta $01		                sta cp+1
.94ef	c8		iny		                iny
.94f0	b1 24		lda ($24),y	                lda (tmp1),y
.94f2	85 02		sta $02		                sta dp
.94f4	c8		iny		                iny
.94f5	b1 24		lda ($24),y	                lda (tmp1),y
.94f7	85 03		sta $03		                sta dp+1
.94f9	a0 04		ldy #$04	                ldy #4
.94fb					_marker_restore_loop:
.94fb	b1 24		lda ($24),y	                lda (tmp1), y
.94fd	91 1e		sta ($1e),y	                sta (up), y
.94ff	c8		iny		                iny
.9500	98		tya		                tya
.9501	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.9503	d0 f6		bne $94fb	                bne _marker_restore_loop
.9505	20 61 d8	jsr $d861	                jsr dp_to_current       ; Move the CURRENT DP back.
.9508	60		rts		                rts
.9509					xt_max:
.9509	20 11 d9	jsr $d911	                jsr underflow_2
.950c	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.950e	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.9510	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9512	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9514	50 02		bvc $9518	                bvc _no_overflow
.9516	49 80		eor #$80	                eor #$80        ; complement negative flag
.9518					_no_overflow:
.9518	30 08		bmi $9522	                bmi _keep_nos
.951a	b5 00		lda $00,x	                lda 0,x
.951c	95 02		sta $02,x	                sta 2,x
.951e	b5 01		lda $01,x	                lda 1,x
.9520	95 03		sta $03,x	                sta 3,x
.9522					_keep_nos:
.9522	e8		inx		                inx
.9523	e8		inx		                inx
.9524	60		rts		z_max:          rts
.9525					xt_min:
.9525	20 11 d9	jsr $d911	                jsr underflow_2
.9528	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.952a	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.952c	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.952e	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9530	50 02		bvc $9534	                bvc _no_overflow
.9532	49 80		eor #$80	                eor #$80
.9534					_no_overflow:
.9534	10 08		bpl $953e	                bpl _keep_nos
.9536	b5 00		lda $00,x	                lda 0,x
.9538	95 02		sta $02,x	                sta 2,x
.953a	b5 01		lda $01,x	                lda 1,x
.953c	95 03		sta $03,x	                sta 3,x
.953e					_keep_nos:
.953e	e8		inx		                inx
.953f	e8		inx		                inx
.9540	60		rts		z_min:          rts
.9541					xt_minus:
.9541	20 11 d9	jsr $d911	                jsr underflow_2
.9544	38		sec		                sec
.9545	b5 02		lda $02,x	                lda 2,x         ; LSB
.9547	f5 00		sbc $00,x	                sbc 0,x
.9549	95 02		sta $02,x	                sta 2,x
.954b	b5 03		lda $03,x	                lda 3,x         ; MSB
.954d	f5 01		sbc $01,x	                sbc 1,x
.954f	95 03		sta $03,x	                sta 3,x
.9551	e8		inx		                inx
.9552	e8		inx		                inx
.9553	60		rts		z_minus:        rts
.9554					xt_minus_leading:
.9554	20 11 d9	jsr $d911	                jsr underflow_2
.9557					_loop:
.9557	b5 00		lda $00,x	                lda 0,x
.9559	15 01		ora $01,x	                ora 1,x
.955b	f0 0f		beq $956c	                beq _done
.955d	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.955f	20 ff d8	jsr $d8ff	                jsr is_whitespace
.9562	90 08		bcc $956c	                bcc _done
.9564	20 f9 97	jsr $97f9	                jsr xt_one              ; ( addr u 1 )
.9567	20 0a a0	jsr $a00a	                jsr xt_slash_string     ; ( addr+ u-1 )
.956a	80 eb		bra $9557	                bra _loop
.956c					_done:
.956c					z_minus_leading:
.956c	60		rts		                rts
.956d					xt_minus_trailing:
.956d	20 11 d9	jsr $d911	                jsr underflow_2
.9570	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9572	15 01		ora $01,x	                ora 1,x         ; MSB of n
.9574	f0 33		beq $95a9	                beq _done
.9576	18		clc		                clc
.9577	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9579	75 00		adc $00,x	                adc 0,x
.957b	85 24		sta $24		                sta tmp1
.957d	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.957f	75 01		adc $01,x	                adc 1,x
.9581	85 25		sta $25		                sta tmp1+1
.9583	a5 24		lda $24		                lda tmp1
.9585	d0 02		bne $9589	                bne +
.9587	c6 25		dec $25		                dec tmp1+1
.9589					+
.9589	c6 24		dec $24		                dec tmp1
.958b					_loop:
.958b	b2 24		lda ($24)	                lda (tmp1)
.958d	c9 20		cmp #$20	                cmp #AscSP
.958f	d0 18		bne $95a9	                bne _done
.9591	a5 24		lda $24		                lda tmp1
.9593	d0 02		bne $9597	                bne +
.9595	c6 25		dec $25		                dec tmp1+1
.9597					+
.9597	c6 24		dec $24		                dec tmp1
.9599	b5 00		lda $00,x	                lda 0,x
.959b	d0 02		bne $959f	                bne +
.959d	d6 01		dec $01,x	                dec 1,x
.959f					+
.959f	d6 00		dec $00,x	                dec 0,x
.95a1	b5 00		lda $00,x	                lda 0,x
.95a3	15 01		ora $01,x	                ora 1,x
.95a5	f0 02		beq $95a9	                beq _done       ; Count has reached zero - we're done!
.95a7	80 e2		bra $958b	                bra _loop
.95a9					_done:
.95a9					z_minus_trailing:
.95a9	60		rts		                rts
.95aa					xt_mod:
.95aa	20 11 d9	jsr $d911	                jsr underflow_2
.95ad	20 f2 9f	jsr $9ff2	                jsr xt_slash_mod
.95b0	e8		inx		                inx             ; DROP
.95b1	e8		inx		                inx
.95b2					z_mod:
.95b2	60		rts		                rts
.95b3					xt_move:
.95b3	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95b5	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95b7	f0 05		beq $95be	                beq _lsb                ; wasn't helpful, move to LSB
.95b9	b0 0e		bcs $95c9	                bcs _to_move_up         ; we want CMOVE>
.95bb	4c 8a 86	jmp $868a	                jmp xt_cmove            ; JSR/RTS
.95be					_lsb:
.95be	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95c0	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95c2	f0 08		beq $95cc	                beq _equal              ; LSB is equal as well
.95c4	b0 03		bcs $95c9	                bcs _to_move_up         ; we want CMOVE>
.95c6	4c 8a 86	jmp $868a	                jmp xt_cmove            ; JSR/RTS
.95c9					_to_move_up:
.95c9	4c c5 86	jmp $86c5	                jmp xt_cmove_up         ; JSR/RTS
.95cc					_equal:
.95cc	8a		txa		                txa
.95cd	18		clc		                clc
.95ce	69 06		adc #$06	                adc #6
.95d0	aa		tax		                tax
.95d1	60		rts		z_move:         rts
.95d2					xt_name_to_int:
.95d2	20 0c d9	jsr $d90c	                jsr underflow_1
.95d5	b5 00		lda $00,x	                lda 0,x
.95d7	18		clc		                clc
.95d8	69 04		adc #$04	                adc #4
.95da	85 28		sta $28		                sta tmp3
.95dc	b5 01		lda $01,x	                lda 1,x
.95de	90 01		bcc $95e1	                bcc _done
.95e0	1a		inc a		                ina
.95e1					_done:
.95e1	85 29		sta $29		                sta tmp3+1
.95e3	a0 00		ldy #$00	                ldy #0
.95e5	b1 28		lda ($28),y	                lda (tmp3),y
.95e7	95 00		sta $00,x	                sta 0,x
.95e9	c8		iny		                iny
.95ea	b1 28		lda ($28),y	                lda (tmp3),y
.95ec	95 01		sta $01,x	                sta 1,x
.95ee	60		rts		z_name_to_int:  rts
.95ef					xt_name_to_string:
.95ef	20 0c d9	jsr $d90c	                jsr underflow_1
.95f2	ca		dex		                dex
.95f3	ca		dex		                dex
.95f4	a1 02		lda ($02,x)	                lda (2,x)
.95f6	95 00		sta $00,x	                sta 0,x
.95f8	74 01		stz $01,x	                stz 1,x
.95fa	b5 02		lda $02,x	                lda 2,x         ; LSB
.95fc	18		clc		                clc
.95fd	69 08		adc #$08	                adc #8
.95ff	a8		tay		                tay
.9600	b5 03		lda $03,x	                lda 3,x         ; MSB
.9602	69 00		adc #$00	                adc #0          ; just need carry
.9604	95 03		sta $03,x	                sta 3,x
.9606	94 02		sty $02,x	                sty 2,x
.9608					z_name_to_string:
.9608	60		rts		                rts
.9609					xt_nc_limit:
.9609	ca		dex		                dex
.960a	ca		dex		                dex
.960b	a9 1a		lda #$1a	                lda #<nc_limit
.960d	95 00		sta $00,x	                sta 0,x
.960f	a9 00		lda #$00	                lda #>nc_limit
.9611	95 01		sta $01,x	                sta 1,x
.9613	60		rts		z_nc_limit:     rts
.9614					xt_negate:
.9614	20 0c d9	jsr $d90c	                jsr underflow_1
.9617	a9 00		lda #$00	        	lda #0
.9619	38		sec		                sec
.961a	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.961c	95 00		sta $00,x	                sta 0,x
.961e	a9 00		lda #$00	                lda #0
.9620	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9622	95 01		sta $01,x	                sta 1,x
.9624	60		rts		z_negate:       rts
.9625					xt_never_native:
.9625	20 4e d8	jsr $d84e	                jsr current_to_dp
.9628	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.962a	b1 02		lda ($02),y	                lda (dp),y
.962c	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.962e	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.9630	91 02		sta ($02),y	                sta (dp),y
.9632					z_never_native:
.9632	60		rts		                rts
.9633					xt_nip:
.9633	20 11 d9	jsr $d911	                jsr underflow_2
.9636	b5 00		lda $00,x	                lda 0,x         ; LSB
.9638	95 02		sta $02,x	                sta 2,x
.963a	b5 01		lda $01,x	                lda 1,x         ; MSB
.963c	95 03		sta $03,x	                sta 3,x
.963e	e8		inx		                inx
.963f	e8		inx		                inx
.9640	60		rts		z_nip:          rts
.9641					xt_not_equals:
.9641	20 11 d9	jsr $d911	                jsr underflow_2
.9644	a0 00		ldy #$00	                ldy #0                  ; default is true
.9646	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9648	d5 02		cmp $02,x	                cmp 2,x
.964a	d0 0a		bne $9656	                bne _not_equal
.964c	b5 01		lda $01,x	                lda 1,x                 ; MSB
.964e	d5 03		cmp $03,x	                cmp 3,x
.9650	d0 04		bne $9656	                bne _not_equal
.9652	a9 ff		lda #$ff	                lda #$FF
.9654	80 01		bra $9657	                bra _done
.9656					_not_equal:
.9656	88		dey		                dey                     ; drop thru to done
.9657					_done:
.9657	98		tya		                tya
.9658	e8		inx		                inx
.9659	e8		inx		                inx
.965a	95 00		sta $00,x	                sta 0,x
.965c	95 01		sta $01,x	                sta 1,x
.965e	60		rts		z_not_equals:   rts
.965f					xt_not_rote:
.965f	20 16 d9	jsr $d916	                jsr underflow_3
.9662	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9664	b5 03		lda $03,x	                lda 3,x
.9666	95 01		sta $01,x	                sta 1,x
.9668	b5 05		lda $05,x	                lda 5,x
.966a	95 03		sta $03,x	                sta 3,x
.966c	94 05		sty $05,x	                sty 5,x
.966e	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9670	b5 02		lda $02,x	                lda 2,x
.9672	95 00		sta $00,x	                sta 0,x
.9674	b5 04		lda $04,x	                lda 4,x
.9676	95 02		sta $02,x	                sta 2,x
.9678	94 04		sty $04,x	                sty 4,x
.967a	60		rts		z_not_rote:     rts
.967b					xt_number:
.967b	20 11 d9	jsr $d911	                jsr underflow_2
.967e	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.9680	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.9682	a5 18		lda $18		                lda base
.9684	48		pha		                pha
.9685	20 a9 a3	jsr $a3a9	                jsr xt_two_dup
.9688	a1 02		lda ($02,x)	                lda (2,x)
.968a					_check_dec:
.968a	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.968c	d0 04		bne $9692	                bne _check_hex
.968e	a9 0a		lda #$0a	                lda #$0A
.9690	80 42		bra $96d4	                bra _base_changed
.9692					_check_hex:
.9692	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.9694	d0 04		bne $969a	                bne _check_binary
.9696	a9 10		lda #$10	                lda #$10
.9698	80 3a		bra $96d4	                bra _base_changed
.969a					_check_binary:
.969a	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.969c	d0 04		bne $96a2	                bne _check_char
.969e	a9 02		lda #$02	                lda #$02
.96a0	80 32		bra $96d4	                bra _base_changed
.96a2					_check_char:
.96a2	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96a4	d0 3a		bne $96e0	                bne _check_minus
.96a6	b5 00		lda $00,x	                lda 0,x         ; Get the length
.96a8	c9 03		cmp #$03	                cmp #$03
.96aa	d0 26		bne $96d2	                bne _not_a_char
.96ac	b5 01		lda $01,x	                lda 1,x
.96ae	d0 22		bne $96d2	                bne _not_a_char ; No compare needed to check for non-zero.
.96b0	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96b2	18		clc		                clc
.96b3	69 02		adc #$02	                adc #2          ; length of string
.96b5	85 2c		sta $2c		                sta tmptos
.96b7	b5 03		lda $03,x	                lda 3,x
.96b9	69 00		adc #$00	                adc #0          ; only need carry
.96bb	85 2d		sta $2d		                sta tmptos+1
.96bd	b2 2c		lda ($2c)	                lda (tmptos)
.96bf	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96c1	d0 0f		bne $96d2	                bne _not_a_char
.96c3	f6 02		inc $02,x	                inc 2,x
.96c5	d0 02		bne $96c9	                bne +
.96c7	f6 03		inc $03,x	                inc 3,x
.96c9					+
.96c9	a1 02		lda ($02,x)	                lda (2,x)
.96cb	95 02		sta $02,x	                sta 2,x
.96cd	74 03		stz $03,x	                stz 3,x
.96cf	4c 50 97	jmp $9750	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96d2					_not_a_char:
.96d2	80 5a		bra $972e	                bra _number_error
.96d4					_base_changed:
.96d4	85 18		sta $18		                sta base        ; Switch to the new base
.96d6	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96d8	d0 02		bne $96dc	                bne +
.96da	f6 03		inc $03,x	                inc 3,x
.96dc					+
.96dc	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96de	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96e0					_check_minus:
.96e0	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96e2	d0 0a		bne $96ee	                bne _check_dot
.96e4	c6 2b		dec $2b		                dec tmpdsp+1
.96e6	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96e8	d0 02		bne $96ec	                bne +
.96ea	f6 03		inc $03,x	                inc 3,x
.96ec					+
.96ec	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96ee					_check_dot:
.96ee	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96f0	18		clc		                clc
.96f1	75 00		adc $00,x	                adc 0,x         ; length of string
.96f3	85 2c		sta $2c		                sta tmptos
.96f5	b5 03		lda $03,x	                lda 3,x
.96f7	69 00		adc #$00	                adc #0          ; only need carry
.96f9	85 2d		sta $2d		                sta tmptos+1
.96fb	a5 2c		lda $2c		                lda tmptos
.96fd	d0 02		bne $9701	                bne +
.96ff	c6 2d		dec $2d		                dec tmptos+1
.9701					+
.9701	c6 2c		dec $2c		                dec tmptos
.9703	b2 2c		lda ($2c)	                lda (tmptos)
.9705	c9 2e		cmp #$2e	                cmp #'.'
.9707	d0 04		bne $970d	                bne _main
.9709	c6 2a		dec $2a		                dec tmpdsp
.970b	d6 00		dec $00,x	                dec 0,x
.970d					_main:
.970d	ca		dex		                dex
.970e	ca		dex		                dex
.970f	ca		dex		                dex
.9710	ca		dex		                dex
.9711	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9713	95 00		sta $00,x	                sta 0,x
.9715	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9717	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9719	95 02		sta $02,x	                sta 2,x
.971b	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.971d	95 03		sta $03,x	                sta 3,x
.971f	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9721	74 05		stz $05,x	                stz 5,x
.9723	74 06		stz $06,x	                stz 6,x
.9725	74 07		stz $07,x	                stz 7,x
.9727	20 ae a2	jsr $a2ae	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.972a	b5 00		lda $00,x	                lda 0,x
.972c	f0 1e		beq $974c	                beq _all_converted
.972e					_number_error:
.972e	20 a1 a3	jsr $a3a1	                jsr xt_two_drop ; >NUMBER modified addr u
.9731	20 a1 a3	jsr $a3a1	                jsr xt_two_drop ; ud   (partially converted number)
.9734	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9736	20 e7 8d	jsr $8de7	                jsr emit_a
.9739	20 f4 a4	jsr $a4f4	                jsr xt_type
.973c	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.973e	20 e7 8d	jsr $8de7	                jsr emit_a
.9741	20 0f a1	jsr $a10f	                jsr xt_space
.9744	68		pla		                pla
.9745	85 18		sta $18		                sta base
.9747	a9 08		lda #$08	                lda #err_syntax
.9749	4c 22 d9	jmp $d922	                jmp error
.974c					_all_converted:
.974c	e8		inx		                inx ; Drop the current addr u
.974d	e8		inx		                inx
.974e	e8		inx		                inx
.974f	e8		inx		                inx
.9750					_drop_original_string:
.9750	20 6f a4	jsr $a46f	                jsr xt_two_swap  ; Drop the original addr u
.9753	20 a1 a3	jsr $a3a1	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9756	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9758	f0 0d		beq $9767	                beq _single
.975a	a9 20		lda #$20	                lda #%00100000
.975c	04 20		tsb $20		                tsb status
.975e	a5 2b		lda $2b		                lda tmpdsp+1
.9760	f0 12		beq $9774	                beq _done       ; no minus, all done
.9762	20 32 8b	jsr $8b32	                jsr xt_dnegate
.9765	80 0d		bra $9774	                bra _done
.9767					_single:
.9767	e8		inx		                inx
.9768	e8		inx		                inx
.9769	a9 20		lda #$20	                lda #%00100000
.976b	14 20		trb $20		                trb status
.976d	a5 2b		lda $2b		                lda tmpdsp+1
.976f	f0 03		beq $9774	                beq _done       ; no minus, all done
.9771	20 14 96	jsr $9614	                jsr xt_negate
.9774					_done:
.9774	68		pla		                pla
.9775	85 18		sta $18		                sta base
.9777	60		rts		z_number:       rts
.9778					xt_number_sign:
.9778	20 11 d9	jsr $d911	                jsr underflow_2         ; double number
.977b	20 78 83	jsr $8378	                jsr xt_base
.977e	20 71 8f	jsr $8f71	                jsr xt_fetch            ; ( ud1 base )
.9781	20 61 a3	jsr $a361	                jsr xt_to_r             ; >r
.9784	20 99 a7	jsr $a799	                jsr xt_zero             ; 0
.9787	20 6e 9a	jsr $9a6e	                jsr xt_r_fetch          ; r@
.978a	20 ab a5	jsr $a5ab	                jsr xt_um_slash_mod     ; um/mod
.978d	20 48 9b	jsr $9b48	                jsr xt_rot              ; rot
.9790	20 48 9b	jsr $9b48	                jsr xt_rot              ; rot
.9793	20 83 9a	jsr $9a83	                jsr xt_r_from           ; r>
.9796	20 ab a5	jsr $a5ab	                jsr xt_um_slash_mod     ; um/mod
.9799	20 48 9b	jsr $9b48	                jsr xt_rot              ; rot
.979c	20 48 9b	jsr $9b48	                jsr xt_rot              ; ( ud rem )
.979f	b5 00		lda $00,x	                lda 0,x
.97a1	a8		tay		                tay
.97a2	b9 eb d4	lda $d4eb,y	                lda s_abc_upper,y
.97a5	95 00		sta $00,x	                sta 0,x
.97a7	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.97a9	20 c8 91	jsr $91c8	                jsr xt_hold
.97ac					z_number_sign:
.97ac	60		rts		                rts
.97ad					xt_number_sign_greater:
.97ad	20 11 d9	jsr $d911	                jsr underflow_2         ; double number
.97b0	a5 34		lda $34		                lda tohold
.97b2	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97b4	95 02		sta $02,x	                sta 2,x
.97b6	a5 35		lda $35		                lda tohold+1
.97b8	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97ba	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97bc	20 92 98	jsr $9892	                jsr xt_pad      ; ( addr addr pad )
.97bf	38		sec		                sec
.97c0	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97c2	f5 02		sbc $02,x	                sbc 2,x
.97c4	95 02		sta $02,x	                sta 2,x
.97c6	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97c8	f5 03		sbc $03,x	                sbc 3,x
.97ca	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97cc	e8		inx		                inx
.97cd	e8		inx		                inx
.97ce					z_number_sign_greater:
.97ce	60		rts		                rts
.97cf					xt_number_sign_s:
.97cf	20 11 d9	jsr $d911	                jsr underflow_2
.97d2					_loop:
.97d2	20 78 97	jsr $9778	                jsr xt_number_sign
.97d5	b5 00		lda $00,x	                lda 0,x
.97d7	15 01		ora $01,x	                ora 1,x
.97d9	15 02		ora $02,x	                ora 2,x
.97db	15 03		ora $03,x	                ora 3,x
.97dd	d0 f3		bne $97d2	                bne _loop
.97df					z_number_sign_s:
.97df	60		rts		                rts
.97e0					xt_of:
.97e0	a0 98		ldy #$98	                ldy #>xt_over
.97e2	a9 84		lda #$84	                lda #<xt_over
.97e4	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.97e7	a0 8e		ldy #$8e	                ldy #>xt_equal
.97e9	a9 bf		lda #$bf	                lda #<xt_equal
.97eb	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.97ee	20 f4 91	jsr $91f4	                jsr xt_if
.97f1	a0 8d		ldy #$8d	                ldy #>xt_drop
.97f3	a9 1f		lda #$1f	                lda #<xt_drop
.97f5	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.97f8	60		rts		z_of:           rts
.97f9					xt_editor_wordlist:
.97f9					xt_one:
.97f9	ca		dex		                dex
.97fa	ca		dex		                dex
.97fb	a9 01		lda #$01	                lda #1
.97fd	95 00		sta $00,x	                sta 0,x
.97ff	74 01		stz $01,x	                stz 1,x
.9801					z_editor_wordlist:
.9801					z_one:
.9801	60		rts		                rts
.9802					xt_one_minus:
.9802	20 0c d9	jsr $d90c	                jsr underflow_1
.9805	b5 00		lda $00,x	                lda 0,x
.9807	d0 02		bne $980b	                bne +
.9809	d6 01		dec $01,x	                dec 1,x
.980b					+
.980b	d6 00		dec $00,x	                dec 0,x
.980d	60		rts		z_one_minus:    rts
.980e					xt_char_plus:
.980e					xt_one_plus:
.980e	20 0c d9	jsr $d90c	                jsr underflow_1
.9811	f6 00		inc $00,x	                inc 0,x
.9813	d0 02		bne $9817	                bne _done
.9815	f6 01		inc $01,x	                inc 1,x
.9817					_done:
.9817					z_char_plus:
.9817	60		rts		z_one_plus:     rts
.9818					xt_only:
.9818	ca		dex		                dex
.9819	ca		dex		                dex
.981a	a9 ff		lda #$ff	                lda #$FF
.981c	95 00		sta $00,x	                sta 0,x
.981e	95 01		sta $01,x	                sta 1,x
.9820	20 0c 9d	jsr $9d0c	                jsr xt_set_order
.9823	60		rts		z_only:         rts
.9824					xt_or:
.9824	20 11 d9	jsr $d911	                jsr underflow_2
.9827	b5 00		lda $00,x	                lda 0,x
.9829	15 02		ora $02,x	                ora 2,x
.982b	95 02		sta $02,x	                sta 2,x
.982d	b5 01		lda $01,x	                lda 1,x
.982f	15 03		ora $03,x	                ora 3,x
.9831	95 03		sta $03,x	                sta 3,x
.9833	e8		inx		                inx
.9834	e8		inx		                inx
.9835	60		rts		z_or:           rts
.9836					xt_order:
.9836	20 54 89	jsr $8954	                jsr xt_cr
.9839	20 25 91	jsr $9125	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.983c	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.983e	f0 1e		beq $985e	                beq _drop_done
.9840					_have_wordlists:
.9840	a8		tay		                tay
.9841					_loop:
.9841	e8		inx		                inx
.9842	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9843	b5 00		lda $00,x	                lda 0,x
.9845	5a		phy		                phy
.9846	20 61 98	jsr $9861	                jsr order_print_wid_string   ; internal helper function
.9849	7a		ply		                ply
.984a	88		dey		                dey
.984b	d0 f4		bne $9841	                bne _loop
.984d	20 0f a1	jsr $a10f	                jsr xt_space
.9850	20 0f a1	jsr $a10f	                jsr xt_space
.9853	20 1a 91	jsr $911a	                jsr xt_get_current      ; ( wid )
.9856	b5 00		lda $00,x	                lda 0,x
.9858	20 61 98	jsr $9861	                jsr order_print_wid_string
.985b	20 54 89	jsr $8954	                jsr xt_cr
.985e					_drop_done:
.985e	e8		inx		                inx
.985f	e8		inx		                inx
.9860					z_order:
.9860	60		rts		                rts
.9861					order_print_wid_string:
.9861	c9 04		cmp #$04	                cmp #4
.9863	90 09		bcc $986e	                bcc _output_string      ; less than 4, print a real string
.9865	ca		dex		                dex
.9866	ca		dex		                dex
.9867	95 00		sta $00,x	                sta 0,x
.9869	74 01		stz $01,x	                stz 1,x
.986b	4c 1f a5	jmp $a51f	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.986e					_output_string:
.986e	a8		tay		                tay
.986f	b9 75 98	lda $9875,y	                lda _wid_data,y
.9872	4c 48 d9	jmp $d948	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9875					_wid_data:
>9875	03				        .byte str_wid_forth            ; WID 0: "Forth"
>9876	06				        .byte str_wid_editor           ; WID 1: "Editor"
>9877	07				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9878	08				        .byte str_wid_root             ; WID 3: "Root"
.9879					xt_output:
.9879	ca		dex		                dex
.987a	ca		dex		                dex
.987b	a9 10		lda #$10	                lda #<output
.987d	95 00		sta $00,x	                sta 0,x
.987f	a9 00		lda #$00	                lda #>output
.9881	95 01		sta $01,x	                sta 1,x
.9883	60		rts		z_output:       rts
.9884					xt_over:
.9884	20 11 d9	jsr $d911	                jsr underflow_2
.9887	ca		dex		                dex
.9888	ca		dex		                dex
.9889	b5 04		lda $04,x	                lda 4,x         ; LSB
.988b	95 00		sta $00,x	                sta 0,x
.988d	b5 05		lda $05,x	                lda 5,x         ; MSB
.988f	95 01		sta $01,x	                sta 1,x
.9891	60		rts		z_over:         rts
.9892					xt_pad:
.9892	ca		dex		                dex
.9893	ca		dex		                dex
.9894	a5 00		lda $00		                lda cp
.9896	18		clc		                clc
.9897	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.9899	95 00		sta $00,x	                sta 0,x
.989b	a5 01		lda $01		                lda cp+1
.989d	69 00		adc #$00	                adc #0          ; only need carry
.989f	95 01		sta $01,x	                sta 1,x
.98a1	60		rts		z_pad:          rts
.98a2					xt_page:
.98a2	a9 1b		lda #$1b	                lda #AscESC
.98a4	20 e7 8d	jsr $8de7	                jsr emit_a
.98a7	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.98a9	20 e7 8d	jsr $8de7	                jsr emit_a
.98ac	a9 32		lda #$32	                lda #'2'
.98ae	20 e7 8d	jsr $8de7	                jsr emit_a
.98b1	a9 4a		lda #$4a	                lda #'J'
.98b3	20 e7 8d	jsr $8de7	                jsr emit_a
.98b6	20 99 a7	jsr $a799	                jsr xt_zero
.98b9	20 99 a7	jsr $a799	                jsr xt_zero
.98bc	20 41 83	jsr $8341	                jsr xt_at_xy
.98bf	60		rts		z_page:         rts
.98c0					xt_paren:
.98c0	ca		dex		                dex
.98c1	ca		dex		                dex
.98c2	a9 29		lda #$29	                lda #41     ; Right parenthesis
.98c4	95 00		sta $00,x	                sta 0,x
.98c6	74 01		stz $01,x	                stz 1,x
.98c8	20 2b 99	jsr $992b	                jsr xt_parse
.98cb	e8		inx		                inx
.98cc	e8		inx		                inx
.98cd	e8		inx		                inx
.98ce	e8		inx		                inx
.98cf	60		rts		z_paren:        rts
.98d0					xt_parse_name:
.98d0	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98d2	38		sec		                sec
.98d3	e5 0c		sbc $0c		                sbc toin
.98d5	85 24		sta $24		                sta tmp1
.98d7	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98d9	e5 0d		sbc $0d		                sbc toin+1
.98db	85 25		sta $25		                sta tmp1+1
.98dd	a5 24		lda $24		                lda tmp1
.98df	05 25		ora $25		                ora tmp1+1
.98e1	f0 28		beq $990b	                beq _empty_line
.98e3	a5 08		lda $08		                lda cib
.98e5	18		clc		                clc
.98e6	65 0c		adc $0c		                adc toin
.98e8	85 26		sta $26		                sta tmp2                ; LSB of first character
.98ea	a5 09		lda $09		                lda cib+1
.98ec	65 0d		adc $0d		                adc toin+1
.98ee	85 27		sta $27		                sta tmp2+1              ; MSB
.98f0					_skip_loop:
.98f0	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.98f2	20 ff d8	jsr $d8ff	                jsr is_whitespace
.98f5	90 1f		bcc $9916	                bcc _char_found
.98f7	e6 26		inc $26		                inc tmp2
.98f9	d0 02		bne $98fd	                bne +
.98fb	e6 27		inc $27		                inc tmp2+1
.98fd					+
.98fd	a5 24		lda $24		                lda tmp1
.98ff	d0 02		bne $9903	                bne +
.9901	c6 25		dec $25		                dec tmp1+1
.9903	c6 24		dec $24		+               dec tmp1
.9905	a5 24		lda $24		                lda tmp1
.9907	05 25		ora $25		                ora tmp1+1
.9909	d0 e5		bne $98f0	                bne _skip_loop          ; fall through if empty line
.990b					_empty_line:
.990b	ca		dex		                dex
.990c	ca		dex		                dex
.990d	ca		dex		                dex
.990e	ca		dex		                dex
.990f	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.9911	74 01		stz $01,x	                stz 1,x
.9913	4c c2 99	jmp $99c2	                jmp z_parse_name        ; skip over PARSE
.9916					_char_found:
.9916	a5 26		lda $26		                lda tmp2
.9918	38		sec		                sec
.9919	e5 08		sbc $08		                sbc cib
.991b	85 0c		sta $0c		                sta toin
.991d	a5 27		lda $27		                lda tmp2+1
.991f	e5 09		sbc $09		                sbc cib+1
.9921	85 0d		sta $0d		                sta toin+1
.9923	ca		dex		                dex
.9924	ca		dex		                dex
.9925	a9 20		lda #$20	                lda #AscSP
.9927	95 00		sta $00,x	                sta 0,x
.9929	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.992b					xt_parse:
.992b	20 0c d9	jsr $d90c	                jsr underflow_1
.992e	a5 0a		lda $0a		                lda ciblen
.9930	05 0b		ora $0b		                ora ciblen+1
.9932	f0 0c		beq $9940	                beq _abort_parse
.9934	a5 0d		lda $0d		                lda toin+1              ; MSB
.9936	c5 0b		cmp $0b		                cmp ciblen+1
.9938	90 0e		bcc $9948	                bcc _go_parse           ; unsigned comparison
.993a	a5 0c		lda $0c		                lda toin                ; LSB
.993c	c5 0a		cmp $0a		                cmp ciblen
.993e	90 08		bcc $9948	                bcc _go_parse
.9940					_abort_parse:
.9940	ca		dex		                dex
.9941	ca		dex		                dex
.9942	74 00		stz $00,x	                stz 0,x
.9944	74 01		stz $01,x	                stz 1,x
.9946	80 7a		bra $99c2	                bra _done
.9948					_go_parse:
.9948	b5 00		lda $00,x	                lda 0,x
.994a	85 2c		sta $2c		                sta tmptos
.994c	ca		dex		                dex
.994d	ca		dex		                dex
.994e	a5 08		lda $08		                lda cib
.9950	18		clc		                clc
.9951	65 0c		adc $0c		                adc toin        ; LSB
.9953	85 24		sta $24		                sta tmp1
.9955	85 26		sta $26		                sta tmp2
.9957	95 02		sta $02,x	                sta 2,x
.9959	a5 09		lda $09		                lda cib+1
.995b	65 0d		adc $0d		                adc toin+1      ; MSB
.995d	85 25		sta $25		                sta tmp1+1
.995f	85 27		sta $27		                sta tmp2+1
.9961	95 03		sta $03,x	                sta 3,x
.9963	a5 08		lda $08		                lda cib
.9965	18		clc		                clc
.9966	65 0a		adc $0a		                adc ciblen
.9968	85 28		sta $28		                sta tmp3
.996a	a5 09		lda $09		                lda cib+1
.996c	65 0b		adc $0b		                adc ciblen+1
.996e	85 29		sta $29		                sta tmp3+1
.9970	64 2d		stz $2d		                stz tmptos+1
.9972					_loop:
.9972	a5 26		lda $26		                lda tmp2
.9974	c5 28		cmp $28		                cmp tmp3
.9976	d0 06		bne $997e	                bne _not_empty
.9978	a5 27		lda $27		                lda tmp2+1
.997a	c5 29		cmp $29		                cmp tmp3+1
.997c	f0 1d		beq $999b	                beq _eol
.997e					_not_empty:
.997e	b2 26		lda ($26)	                lda (tmp2)
.9980	a4 2c		ldy $2c		                ldy tmptos
.9982	c0 20		cpy #$20	                cpy #AscSP
.9984	d0 07		bne $998d	                bne _not_whitespace
.9986	20 ff d8	jsr $d8ff	                jsr is_whitespace
.9989	90 02		bcc $998d	                bcc _not_whitespace
.998b	80 0c		bra $9999	                bra _found_delimiter
.998d					_not_whitespace:
.998d	c5 2c		cmp $2c		                cmp tmptos
.998f	f0 08		beq $9999	                beq _found_delimiter
.9991	e6 26		inc $26		                inc tmp2
.9993	d0 dd		bne $9972	                bne _loop
.9995	e6 27		inc $27		                inc tmp2+1
.9997	80 d9		bra $9972	                bra _loop
.9999					_found_delimiter:
.9999	e6 2d		inc $2d		                inc tmptos+1
.999b					_eol:
.999b	a5 26		lda $26		                lda tmp2
.999d	38		sec		                sec
.999e	e5 24		sbc $24		                sbc tmp1
.99a0	95 00		sta $00,x	                sta 0,x
.99a2	a5 27		lda $27		                lda tmp2+1
.99a4	e5 25		sbc $25		                sbc tmp1+1
.99a6	95 01		sta $01,x	                sta 1,x
.99a8	a5 26		lda $26		                lda tmp2
.99aa	38		sec		                sec
.99ab	e5 08		sbc $08		                sbc cib
.99ad	85 0c		sta $0c		                sta toin
.99af	a5 27		lda $27		                lda tmp2+1
.99b1	e5 09		sbc $09		                sbc cib+1
.99b3	85 0d		sta $0d		                sta toin+1
.99b5	a5 0c		lda $0c		                lda toin
.99b7	18		clc		                clc
.99b8	65 2d		adc $2d		                adc tmptos+1
.99ba	85 0c		sta $0c		                sta toin
.99bc	a5 0d		lda $0d		                lda toin+1
.99be	69 00		adc #$00	                adc #0          ; we only need the carry
.99c0	85 0d		sta $0d		                sta toin+1
.99c2					_done:
.99c2					z_parse_name:
.99c2	60		rts		z_parse:        rts
.99c3					xt_pick:
.99c3	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99c5	8a		txa		                txa
.99c6	75 00		adc $00,x	                adc 0,x
.99c8	a8		tay		                tay
.99c9	b9 02 00	lda $0002,y	                lda 0002,y
.99cc	95 00		sta $00,x	                sta 0,x
.99ce	b9 03 00	lda $0003,y	                lda 0003,y
.99d1	95 01		sta $01,x	                sta 1,x
.99d3	60		rts		z_pick:         rts
.99d4					xt_plus:
.99d4	20 11 d9	jsr $d911	                jsr underflow_2
.99d7	18		clc		                clc
.99d8	b5 00		lda $00,x	                lda 0,x         ; LSB
.99da	75 02		adc $02,x	                adc 2,x
.99dc	95 02		sta $02,x	                sta 2,x
.99de	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99e0	75 03		adc $03,x	                adc 3,x
.99e2	95 03		sta $03,x	                sta 3,x
.99e4	e8		inx		                inx
.99e5	e8		inx		                inx
.99e6	60		rts		z_plus:         rts
.99e7					xt_plus_store:
.99e7	20 11 d9	jsr $d911	                jsr underflow_2
.99ea	b5 00		lda $00,x	                lda 0,x
.99ec	85 24		sta $24		                sta tmp1
.99ee	b5 01		lda $01,x	                lda 1,x
.99f0	85 25		sta $25		                sta tmp1+1
.99f2	a0 00		ldy #$00	                ldy #0          ; LSB
.99f4	b1 24		lda ($24),y	                lda (tmp1),y
.99f6	18		clc		                clc
.99f7	75 02		adc $02,x	                adc 2,x
.99f9	91 24		sta ($24),y	                sta (tmp1),y
.99fb	c8		iny		                iny             ; MSB
.99fc	b1 24		lda ($24),y	                lda (tmp1),y
.99fe	75 03		adc $03,x	                adc 3,x
.9a00	91 24		sta ($24),y	                sta (tmp1),y
.9a02	e8		inx		                inx
.9a03	e8		inx		                inx
.9a04	e8		inx		                inx
.9a05	e8		inx		                inx
.9a06	60		rts		z_plus_store:   rts
.9a07					xt_postpone:
.9a07	20 d0 98	jsr $98d0	                jsr xt_parse_name               ; ( -- addr n )
.9a0a	b5 00		lda $00,x	                lda 0,x
.9a0c	15 01		ora $01,x	                ora 1,x
.9a0e	d0 05		bne $9a15	                bne +
.9a10	a9 05		lda #$05	                lda #err_noname
.9a12	4c 22 d9	jmp $d922	                jmp error
.9a15					+
.9a15	20 cc 8f	jsr $8fcc	                jsr xt_find_name                ; ( -- nt | 0 )
.9a18	d0 05		bne $9a1f	                bne +
.9a1a	a9 05		lda #$05	                lda #err_noname
.9a1c	4c 22 d9	jmp $d922	                jmp error
.9a1f					+
.9a1f	b5 00		lda $00,x	                lda 0,x
.9a21	85 24		sta $24		                sta tmp1
.9a23	b5 01		lda $01,x	                lda 1,x
.9a25	85 25		sta $25		                sta tmp1+1
.9a27	20 d2 95	jsr $95d2	                jsr xt_name_to_int              ; ( nt -- xt )
.9a2a	e6 24		inc $24		                inc tmp1
.9a2c	d0 02		bne $9a30	                bne +
.9a2e	e6 25		inc $25		                inc tmp1+1
.9a30					+
.9a30	b2 24		lda ($24)	                lda (tmp1)
.9a32	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a34	f0 05		beq $9a3b	                beq _not_immediate
.9a36	20 de 87	jsr $87de	                jsr xt_compile_comma
.9a39	80 0a		bra $9a45	                bra _done
.9a3b					_not_immediate:
.9a3b	20 7b 93	jsr $937b	                jsr xt_literal
.9a3e	a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a40	a9 de		lda #$de	                lda #<xt_compile_comma
.9a42	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.9a45					_done:
.9a45	60		rts		z_postpone:     rts
.9a46					xt_previous:
.9a46	20 25 91	jsr $9125	                jsr xt_get_order
.9a49	20 33 96	jsr $9633	                jsr xt_nip
.9a4c	20 02 98	jsr $9802	                jsr xt_one_minus
.9a4f	20 0c 9d	jsr $9d0c	                jsr xt_set_order
.9a52	60		rts		z_previous:     rts
.9a53					xt_question:
.9a53	20 71 8f	jsr $8f71	                jsr xt_fetch
.9a56	20 27 8c	jsr $8c27	                jsr xt_dot
.9a59	60		rts		z_question:     rts
.9a5a					xt_question_dup:
.9a5a	20 0c d9	jsr $d90c	                jsr underflow_1
.9a5d	b5 00		lda $00,x	                lda 0,x
.9a5f	15 01		ora $01,x	                ora 1,x
.9a61	f0 0a		beq $9a6d	                beq _done
.9a63	ca		dex		                dex
.9a64	ca		dex		                dex
.9a65	b5 02		lda $02,x	                lda 2,x
.9a67	95 00		sta $00,x	                sta 0,x
.9a69	b5 03		lda $03,x	                lda 3,x
.9a6b	95 01		sta $01,x	                sta 1,x
.9a6d					_done:
.9a6d	60		rts		z_question_dup: rts
.9a6e					xt_r_fetch:
.9a6e	7a		ply		                ply             ; LSB
.9a6f	84 24		sty $24		                sty tmp1
.9a71	7a		ply		                ply             ; MSB
.9a72	ca		dex		                dex
.9a73	ca		dex		                dex
.9a74	68		pla		                pla             ; LSB
.9a75	95 00		sta $00,x	                sta 0,x
.9a77	68		pla		                pla             ; MSB
.9a78	95 01		sta $01,x	                sta 1,x
.9a7a	48		pha		                pha
.9a7b	b5 00		lda $00,x	                lda 0,x
.9a7d	48		pha		                pha
.9a7e	5a		phy		                phy             ; MSB
.9a7f	a4 24		ldy $24		                ldy tmp1
.9a81	5a		phy		                phy             ; LSB
.9a82	60		rts		z_r_fetch:      rts
.9a83					xt_r_from:
.9a83	68		pla		                pla             ; LSB
.9a84	85 2c		sta $2c		                sta tmptos
.9a86	7a		ply		                ply             ; MSB
.9a87	ca		dex		                dex
.9a88	ca		dex		                dex
.9a89	68		pla		                pla             ; LSB
.9a8a	95 00		sta $00,x	                sta 0,x
.9a8c	68		pla		                pla             ; MSB
.9a8d	95 01		sta $01,x	                sta 1,x
.9a8f	5a		phy		                phy             ; MSB
.9a90	a5 2c		lda $2c		                lda tmptos
.9a92	48		pha		                pha             ; LSB
.9a93	60		rts		z_r_from:       rts
.9a94					xt_r_to_input:
.9a94	68		pla		                pla
.9a95	85 24		sta $24		                sta tmp1
.9a97	68		pla		                pla
.9a98	85 25		sta $25		                sta tmp1+1
.9a9a	a0 00		ldy #$00	                ldy #0
.9a9c					_loop:
.9a9c	68		pla		                pla
.9a9d	99 06 00	sta $0006,y	                sta insrc,y
.9aa0	c8		iny		                iny
.9aa1	c0 08		cpy #$08	                cpy #8
.9aa3	d0 f7		bne $9a9c	                bne _loop
.9aa5	a5 25		lda $25		                lda tmp1+1
.9aa7	48		pha		                pha
.9aa8	a5 24		lda $24		                lda tmp1
.9aaa	48		pha		                pha
.9aab	60		rts		z_r_to_input: 	rts
.9aac					xt_recurse:
.9aac	a0 00		ldy #$00	                ldy #0
.9aae	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9ab0	91 00		sta ($00),y	                sta (cp),y
.9ab2	c8		iny		                iny
.9ab3	24 20		bit $20		                bit status
.9ab5	70 0c		bvs $9ac3	                bvs _nt_in_workword
.9ab7	a5 04		lda $04		                lda workword
.9ab9	91 00		sta ($00),y	                sta (cp),y
.9abb	c8		iny		                iny
.9abc	a5 05		lda $05		                lda workword+1
.9abe	91 00		sta ($00),y	                sta (cp),y
.9ac0	c8		iny		                iny
.9ac1	80 1b		bra $9ade	                bra _update_cp
.9ac3					_nt_in_workword:
.9ac3	a5 04		lda $04		                lda workword            ; LSB
.9ac5	18		clc		                clc
.9ac6	69 04		adc #$04	                adc #4
.9ac8	85 24		sta $24		                sta tmp1
.9aca	a5 05		lda $05		                lda workword+1          ; MSB
.9acc	69 00		adc #$00	                adc #0
.9ace	85 25		sta $25		                sta tmp1+1
.9ad0	b2 24		lda ($24)	                lda (tmp1)
.9ad2	91 00		sta ($00),y	                sta (cp),y
.9ad4	5a		phy		                phy
.9ad5	a0 01		ldy #$01	                ldy #1
.9ad7	b1 24		lda ($24),y	                lda (tmp1),y
.9ad9	7a		ply		                ply
.9ada	c8		iny		                iny
.9adb	91 00		sta ($00),y	                sta (cp),y
.9add	c8		iny		                iny
.9ade					_update_cp:
.9ade	98		tya		                tya
.9adf	18		clc		                clc
.9ae0	65 00		adc $00		                adc cp
.9ae2	85 00		sta $00		                sta cp
.9ae4	90 02		bcc $9ae8	                bcc _done
.9ae6	e6 01		inc $01		                inc cp+1
.9ae8					_done:
.9ae8	60		rts		z_recurse:      rts
.9ae9					xt_refill:
.9ae9	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9aeb	d0 2d		bne $9b1a	                bne _src_not_kbd
.9aed	ca		dex		                dex
.9aee	ca		dex		                dex
.9aef	ca		dex		                dex
.9af0	ca		dex		                dex
.9af1	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9af3	95 02		sta $02,x	                sta 2,x
.9af5	a5 09		lda $09		                lda cib+1
.9af7	95 03		sta $03,x	                sta 3,x
.9af9	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9afb	64 0b		stz $0b		                stz ciblen+1
.9afd	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9aff	95 00		sta $00,x	                sta 0,x
.9b01	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9b03	20 3f 81	jsr $813f	                jsr xt_accept           ; ( addr n1 -- n2)
.9b06	b5 00		lda $00,x	                lda 0,x
.9b08	85 0a		sta $0a		                sta ciblen
.9b0a	b5 01		lda $01,x	                lda 1,x
.9b0c	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b0e	64 0c		stz $0c		                stz toin
.9b10	64 0d		stz $0d		                stz toin+1
.9b12	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b14	95 00		sta $00,x	                sta 0,x
.9b16	95 01		sta $01,x	                sta 1,x
.9b18	80 10		bra $9b2a	                bra _done
.9b1a					_src_not_kbd:
.9b1a	1a		inc a		                ina
.9b1b	d0 08		bne $9b25	                bne _src_not_string
.9b1d	ca		dex		                dex
.9b1e	ca		dex		                dex
.9b1f	74 00		stz $00,x	                stz 0,x
.9b21	74 01		stz $01,x	                stz 1,x
.9b23	80 05		bra $9b2a	                bra z_refill
.9b25					_src_not_string:
.9b25	a9 01		lda #$01	                lda #err_badsource
.9b27	4c 22 d9	jmp $d922	                jmp error
.9b2a					_done:
.9b2a	60		rts		z_refill:       rts
.9b2b					xt_repeat:
.9b2b	20 7a 82	jsr $827a	                jsr xt_again
.9b2e	20 63 91	jsr $9163	                jsr xt_here
.9b31	20 9f a1	jsr $a19f	                jsr xt_swap
.9b34	20 7e a1	jsr $a17e	                jsr xt_store
.9b37	60		rts		z_repeat:       rts
.9b38					xt_right_bracket:
.9b38	a9 ff		lda #$ff	                lda #$FF
.9b3a	85 16		sta $16		                sta state
.9b3c	85 17		sta $17		                sta state+1
.9b3e					z_right_bracket:
.9b3e	60		rts		                rts
.9b3f					xt_root_wordlist:
.9b3f	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b40	ca		dex		                dex
.9b41	a9 03		lda #$03	                lda #3
.9b43	95 00		sta $00,x	                sta 0,x
.9b45	74 01		stz $01,x	                stz 1,x
.9b47					z_root_wordlist:
.9b47	60		rts		                rts
.9b48					xt_rot:
.9b48	20 16 d9	jsr $d916	                jsr underflow_3
.9b4b	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b4d	b5 03		lda $03,x	                lda 3,x
.9b4f	95 05		sta $05,x	                sta 5,x
.9b51	b5 01		lda $01,x	                lda 1,x
.9b53	95 03		sta $03,x	                sta 3,x
.9b55	94 01		sty $01,x	                sty 1,x
.9b57	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b59	b5 02		lda $02,x	                lda 2,x
.9b5b	95 04		sta $04,x	                sta 4,x
.9b5d	b5 00		lda $00,x	                lda 0,x
.9b5f	95 02		sta $02,x	                sta 2,x
.9b61	94 00		sty $00,x	                sty 0,x
.9b63	60		rts		z_rot:          rts
.9b64					xt_rshift:
.9b64	20 11 d9	jsr $d911	                jsr underflow_2
.9b67	b5 00		lda $00,x	                lda 0,x
.9b69	29 0f		and #$0f	                and #%00001111
.9b6b	f0 08		beq $9b75	                beq _done               ; if 0 shifts, quit
.9b6d	a8		tay		                tay
.9b6e					_loop:
.9b6e	56 03		lsr $03,x	                lsr 3,x
.9b70	76 02		ror $02,x	                ror 2,x
.9b72	88		dey		                dey
.9b73	d0 f9		bne $9b6e	                bne _loop
.9b75					_done:
.9b75	e8		inx		                inx
.9b76	e8		inx		                inx
.9b77	60		rts		z_rshift:       rts
.9b78					xt_s_backslash_quote:
.9b78	a9 ff		lda #$ff	                lda #$FF
.9b7a	85 26		sta $26		                sta tmp2
.9b7c	64 27		stz $27		                stz tmp2+1
.9b7e	20 44 9d	jsr $9d44	                jsr s_quote_start
.9b81					_done:
.9b81					z_s_backslash_quote:
.9b81	60		rts		                rts
.9b82					convert_hex_value:
.9b82	c9 41		cmp #$41	        cmp #'A'
.9b84	90 07		bcc $9b8d	        bcc _digit
.9b86	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b88	38		sec		        sec
.9b89	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b8b	80 03		bra $9b90	        bra _done
.9b8d					_digit:
.9b8d	38		sec		        sec
.9b8e	e9 30		sbc #$30	        sbc #'0'
.9b90					_done:
.9b90	60		rts		        rts
.9b91					xt_search_wordlist:
.9b91	20 16 d9	jsr $d916	                jsr underflow_3
.9b94	a5 1e		lda $1e		                lda up
.9b96	18		clc		                clc
.9b97	69 06		adc #$06	                adc #wordlists_offset
.9b99	85 26		sta $26		                sta tmp2
.9b9b	a5 1f		lda $1f		                lda up+1
.9b9d	69 00		adc #$00	                adc #0          ; Adding carry
.9b9f	85 27		sta $27		                sta tmp2+1
.9ba1	b5 00		lda $00,x	                lda 0,x
.9ba3	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9ba4	65 26		adc $26		                adc tmp2
.9ba6	85 26		sta $26		                sta tmp2
.9ba8	90 02		bcc $9bac	                bcc +
.9baa	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9bac					+
.9bac	e8		inx		                inx
.9bad	e8		inx		                inx
.9bae	b5 00		lda $00,x	                lda 0,x
.9bb0	15 01		ora $01,x	                ora 1,x
.9bb2	d0 03		bne $9bb7	                bne _check_wordlist
.9bb4	4c 6f 9c	jmp $9c6f	                jmp _done
.9bb7					_check_wordlist:
.9bb7	a5 26		lda $26		                lda tmp2
.9bb9	05 27		ora $27		                ora tmp2+1
.9bbb	d0 03		bne $9bc0	                bne _have_string
.9bbd	4c 6f 9c	jmp $9c6f	                jmp _done
.9bc0					_have_string:
.9bc0	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bc2	85 24		sta $24		                sta tmp1
.9bc4	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9bc6	d0 02		bne $9bca	                bne +
.9bc8	e6 27		inc $27		                inc tmp2+1
.9bca					+
.9bca	b2 26		lda ($26)	                lda (tmp2)
.9bcc	85 25		sta $25		                sta tmp1+1
.9bce	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9bd0	85 26		sta $26		                sta tmp2
.9bd2	b5 03		lda $03,x	                lda 3,x
.9bd4	85 27		sta $27		                sta tmp2+1
.9bd6					_loop:
.9bd6	b2 24		lda ($24)	                lda (tmp1)
.9bd8	d5 00		cmp $00,x	                cmp 0,x
.9bda	d0 7b		bne $9c57	                bne _next_entry
.9bdc					_compare_string:
.9bdc	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bde	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9be0	b0 07		bcs $9be9	                bcs _compare_first
.9be2	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9be4	90 03		bcc $9be9	                bcc _compare_first
.9be6	18		clc		                clc
.9be7	69 20		adc #$20	                adc #$20
.9be9					_compare_first:
.9be9	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9beb	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9bed	d0 68		bne $9c57	                bne _next_entry
.9bef	b5 00		lda $00,x	                lda 0,x
.9bf1	3a		dec a		                dea
.9bf2	f0 2c		beq $9c20	                beq _success
.9bf4	a5 24		lda $24		                lda tmp1
.9bf6	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9bf7	18		clc		                clc
.9bf8	69 08		adc #$08	                adc #8
.9bfa	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9bfc	a5 25		lda $25		                lda tmp1+1
.9bfe	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9bff	69 00		adc #$00	                adc #0          ; we only need the carry
.9c01	85 25		sta $25		                sta tmp1+1
.9c03	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9c05	88		dey		                dey
.9c06					_string_loop:
.9c06	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9c08	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9c0a	b0 07		bcs $9c13	                bcs _check_char
.9c0c	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c0e	90 03		bcc $9c13	                bcc _check_char
.9c10	18		clc		                clc
.9c11	69 20		adc #$20	                adc #$20
.9c13					_check_char:
.9c13	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c15	d0 3a		bne $9c51	                bne _next_entry_tmp1
.9c17	88		dey		                dey
.9c18	d0 ec		bne $9c06	                bne _string_loop
.9c1a					_success_tmp1:
.9c1a	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c1b	85 25		sta $25		                sta tmp1+1
.9c1d	68		pla		                pla
.9c1e	85 24		sta $24		                sta tmp1
.9c20					_success:
.9c20	e8		inx		                inx
.9c21	e8		inx		                inx
.9c22	a5 24		lda $24		                lda tmp1
.9c24	95 00		sta $00,x	                sta 0,x
.9c26	a5 25		lda $25		                lda tmp1+1
.9c28	95 01		sta $01,x	                sta 1,x
.9c2a	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( nt nt )
.9c2d	20 d2 95	jsr $95d2	                jsr xt_name_to_int      ; ( nt xt )
.9c30	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( xt nt )
.9c33	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c35	f6 00		inc $00,x	                inc 0,x
.9c37	d0 02		bne $9c3b	                bne +
.9c39	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c3b					+
.9c3b	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c3d	29 04		and #$04	                and #IM
.9c3f	d0 08		bne $9c49	                bne _immediate          ; bit set, we're immediate
.9c41	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c43	95 00		sta $00,x	                sta 0,x
.9c45	95 01		sta $01,x	                sta 1,x
.9c47	80 28		bra $9c71	                bra _done_nodrop
.9c49					_immediate:
.9c49	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c4b	95 00		sta $00,x	                sta 0,x
.9c4d	74 01		stz $01,x	                stz 1,x
.9c4f	80 20		bra $9c71	                bra _done_nodrop
.9c51					_next_entry_tmp1:
.9c51	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c52	85 25		sta $25		                sta tmp1+1
.9c54	68		pla		                pla
.9c55	85 24		sta $24		                sta tmp1
.9c57					_next_entry:
.9c57	a0 02		ldy #$02	                ldy #2
.9c59	b1 24		lda ($24),y	                lda (tmp1),y
.9c5b	48		pha		                pha
.9c5c	c8		iny		                iny
.9c5d	b1 24		lda ($24),y	                lda (tmp1),y
.9c5f	85 25		sta $25		                sta tmp1+1
.9c61	68		pla		                pla
.9c62	85 24		sta $24		                sta tmp1
.9c64	05 25		ora $25		                ora tmp1+1
.9c66	f0 03		beq $9c6b	                beq _fail_done
.9c68	4c d6 9b	jmp $9bd6	                jmp _loop
.9c6b					_fail_done:
.9c6b	74 02		stz $02,x	                stz 2,x         ; failure flag
.9c6d	74 03		stz $03,x	                stz 3,x
.9c6f					_done:
.9c6f	e8		inx		                inx
.9c70	e8		inx		                inx
.9c71					_done_nodrop:
.9c71					z_search_wordlist:
.9c71	60		rts		                rts
.9c72					xt_see:
.9c72	20 d0 98	jsr $98d0	                jsr xt_parse_name       ; ( addr u )
.9c75	20 cc 8f	jsr $8fcc	                jsr xt_find_name        ; ( nt | 0 )
.9c78	b5 00		lda $00,x	                lda 0,x
.9c7a	15 01		ora $01,x	                ora 1,x
.9c7c	d0 05		bne $9c83	                bne +
.9c7e	a9 05		lda #$05	                lda #err_noname
.9c80	4c 22 d9	jmp $d922	                jmp error
.9c83					+
.9c83	20 54 89	jsr $8954	                jsr xt_cr
.9c86	a5 18		lda $18		                lda base
.9c88	48		pha		                pha
.9c89	20 6e 91	jsr $916e	                jsr xt_hex
.9c8c	a9 0a		lda #$0a	                lda #str_see_nt
.9c8e	20 48 d9	jsr $d948	                jsr print_string_no_lf
.9c91	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( nt nt )
.9c94	20 1f a5	jsr $a51f	                jsr xt_u_dot
.9c97	20 0f a1	jsr $a10f	                jsr xt_space            ; ( nt )
.9c9a	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( nt nt )
.9c9d	20 d2 95	jsr $95d2	                jsr xt_name_to_int      ; ( nt xt )
.9ca0	a9 0b		lda #$0b	                lda #str_see_xt
.9ca2	20 48 d9	jsr $d948	                jsr print_string_no_lf
.9ca5	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( nt xt xt )
.9ca8	20 1f a5	jsr $a51f	                jsr xt_u_dot
.9cab	20 54 89	jsr $8954	                jsr xt_cr               ; ( nt xt )
.9cae	a9 09		lda #$09	                lda #str_see_flags
.9cb0	20 48 d9	jsr $d948	                jsr print_string_no_lf
.9cb3	20 84 98	jsr $9884	                jsr xt_over             ; ( nt xt nt )
.9cb6	20 0e 98	jsr $980e	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9cb9	20 71 8f	jsr $8f71	                jsr xt_fetch            ; ( nt xt flags )
.9cbc	b5 00		lda $00,x	                lda 0,x
.9cbe	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cc0					_flag_loop:
.9cc0	48		pha		                pha
.9cc1	29 01		and #$01	                and #%00000001
.9cc3	18		clc		                clc
.9cc4	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cc6	20 e7 8d	jsr $8de7	                jsr emit_a
.9cc9	20 0f a1	jsr $a10f	                jsr xt_space
.9ccc	68		pla		                pla
.9ccd	6a		ror a		                ror                     ; Next flag
.9cce	88		dey		                dey
.9ccf	d0 ef		bne $9cc0	                bne _flag_loop
.9cd1	20 54 89	jsr $8954	                jsr xt_cr
.9cd4	e8		inx		                inx
.9cd5	e8		inx		                inx                     ; ( nt xt )
.9cd6	a9 0c		lda #$0c	                lda #str_see_size
.9cd8	20 48 d9	jsr $d948	                jsr print_string_no_lf
.9cdb	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( xt nt )
.9cde	20 66 a7	jsr $a766	                jsr xt_wordsize         ; ( xt u )
.9ce1	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9ce4	20 96 8a	jsr $8a96	                jsr xt_decimal
.9ce7	20 1f a5	jsr $a51f	                jsr xt_u_dot            ; ( xt u )
.9cea	20 6e 91	jsr $916e	                jsr xt_hex
.9ced	20 54 89	jsr $8954	                jsr xt_cr
.9cf0	20 a9 a3	jsr $a3a9	                jsr xt_two_dup          ; ( xt u xt u )
.9cf3	20 25 8d	jsr $8d25	                jsr xt_dump
.9cf6	20 54 89	jsr $8954	                jsr xt_cr
.9cf9	20 2b 8b	jsr $8b2b	                jsr xt_disasm
.9cfc	68		pla		                pla
.9cfd	85 18		sta $18		                sta base
.9cff	60		rts		z_see:          rts
.9d00					xt_set_current:
.9d00	20 0c d9	jsr $d90c	                jsr underflow_1
.9d03	a0 04		ldy #$04	                ldy #current_offset
.9d05	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9d07	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9d09	e8		inx		                inx
.9d0a	e8		inx		                inx
.9d0b	60		rts		z_set_current:  rts
.9d0c					xt_set_order:
.9d0c	a9 ff		lda #$ff	                lda #$FF
.9d0e	d5 01		cmp $01,x	                cmp 1,x
.9d10	d0 12		bne $9d24	                bne _start
.9d12	d5 00		cmp $00,x	                cmp 0,x
.9d14	d0 0e		bne $9d24	                bne _start
.9d16	ca		dex		                dex             ; Make room for the count.
.9d17	ca		dex		                dex
.9d18	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d1a	a9 03		lda #$03	                lda #3
.9d1c	95 02		sta $02,x	                sta 2,x
.9d1e	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d20	a9 01		lda #$01	                lda #1
.9d22	95 00		sta $00,x	                sta 0,x
.9d24					_start:
.9d24	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d26	b5 00		lda $00,x	                lda 0,x
.9d28	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d2a	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d2c	e8		inx		                inx             ; Drop the count off the data stack.
.9d2d	e8		inx		                inx
.9d2e	a5 24		lda $24		                lda tmp1
.9d30	f0 0d		beq $9d3f	                beq _done       ; If zero, there are no wordlists.
.9d32	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d34					_loop:
.9d34	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d36	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d38	c8		iny		                iny
.9d39	e8		inx		                inx
.9d3a	e8		inx		                inx
.9d3b	c6 24		dec $24		                dec tmp1
.9d3d	d0 f5		bne $9d34	                bne _loop
.9d3f					_done:
.9d3f	60		rts		z_set_order:    rts
.9d40					xt_s_quote:
.9d40	64 26		stz $26		                stz tmp2
.9d42	64 27		stz $27		                stz tmp2+1
.9d44					s_quote_start:
.9d44	ca		dex		                dex
.9d45	ca		dex		                dex
.9d46	ca		dex		                dex
.9d47	ca		dex		                dex
.9d48	a9 4c		lda #$4c	                lda #$4C
.9d4a	20 bf d7	jsr $d7bf	                jsr cmpl_a
.9d4d	20 bf d7	jsr $d7bf	                jsr cmpl_a
.9d50	20 bf d7	jsr $d7bf	                jsr cmpl_a
.9d53	a5 00		lda $00		                lda cp
.9d55	95 02		sta $02,x	                sta 2,x
.9d57	a5 01		lda $01		                lda cp+1
.9d59	95 03		sta $03,x	                sta 3,x
.9d5b					_savechars_loop:
.9d5b	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d5d	c5 0b		cmp $0b		                cmp ciblen+1
.9d5f	90 2a		bcc $9d8b	                bcc _input_fine         ; unsigned comparison
.9d61	a5 0c		lda $0c		                lda toin                ; LSB
.9d63	c5 0a		cmp $0a		                cmp ciblen
.9d65	90 24		bcc $9d8b	                bcc _input_fine
.9d67	a5 26		lda $26		                lda tmp2
.9d69	48		pha		                pha
.9d6a	a5 27		lda $27		                lda tmp2+1
.9d6c	48		pha		                pha
.9d6d	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d6f	48		pha		                pha
.9d70	20 e9 9a	jsr $9ae9	                jsr xt_refill           ; ( -- f )
.9d73	68		pla		                pla
.9d74	85 28		sta $28		                sta tmp3
.9d76	68		pla		                pla
.9d77	85 27		sta $27		                sta tmp2+1
.9d79	68		pla		                pla
.9d7a	85 26		sta $26		                sta tmp2
.9d7c	b5 00		lda $00,x	                lda 0,x
.9d7e	15 01		ora $01,x	                ora 1,x
.9d80	d0 05		bne $9d87	                bne _refill_ok
.9d82	a9 06		lda #$06	                lda #err_refill
.9d84	4c 22 d9	jmp $d922	                jmp error
.9d87					_refill_ok:
.9d87	e8		inx		                inx
.9d88	e8		inx		                inx
.9d89	80 d0		bra $9d5b	                bra _savechars_loop
.9d8b					_input_fine:
.9d8b	a5 08		lda $08		                lda cib
.9d8d	18		clc		                clc
.9d8e	65 0c		adc $0c		                adc toin        ; LSB
.9d90	85 24		sta $24		                sta tmp1
.9d92	a5 09		lda $09		                lda cib+1
.9d94	65 0d		adc $0d		                adc toin+1      ; MSB
.9d96	85 25		sta $25		                sta tmp1+1
.9d98	b2 24		lda ($24)	                lda (tmp1)
.9d9a	24 26		bit $26		                bit tmp2
.9d9c	30 03		bmi $9da1	                bmi _handle_escapes    ; Only checking bit 7
.9d9e	4c 59 9e	jmp $9e59	                jmp _regular_char
.9da1					_handle_escapes:
.9da1	24 27		bit $27		                bit tmp2+1
.9da3	30 03		bmi $9da8	                bmi _escaped
.9da5	4c 4f 9e	jmp $9e4f	                jmp _not_escaped
.9da8					_escaped:
.9da8	70 22		bvs $9dcc	                bvs _check_esc_chars
.9daa	a9 01		lda #$01	                lda #1
.9dac	24 27		bit $27		                bit tmp2+1
.9dae	d0 10		bne $9dc0	                bne _esc_x_second_digit
.9db0	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9db2	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9db4	20 82 9b	jsr $9b82	                jsr convert_hex_value
.9db7	0a		asl a		                asl
.9db8	0a		asl a		                asl
.9db9	0a		asl a		                asl
.9dba	0a		asl a		                asl
.9dbb	85 28		sta $28		                sta tmp3    ; Save it for later.
.9dbd	4c 60 9e	jmp $9e60	                jmp _next_character
.9dc0					_esc_x_second_digit:
.9dc0	64 27		stz $27		                stz tmp2+1
.9dc2	b2 24		lda ($24)	                lda (tmp1)
.9dc4	20 82 9b	jsr $9b82	                jsr convert_hex_value
.9dc7	05 28		ora $28		                ora tmp3
.9dc9	4c 5d 9e	jmp $9e5d	                jmp _save_character
.9dcc					_check_esc_chars:
.9dcc	64 27		stz $27		                stz tmp2+1
.9dce					_check_esc_a:
.9dce	c9 61		cmp #$61	                cmp #'a'
.9dd0	d0 05		bne $9dd7	                bne _check_esc_b
.9dd2	a9 07		lda #$07	                lda #7
.9dd4	4c 5d 9e	jmp $9e5d	                jmp _save_character
.9dd7					_check_esc_b:
.9dd7	c9 62		cmp #$62	                cmp #'b'
.9dd9	d0 05		bne $9de0	                bne _check_esc_e
.9ddb	a9 08		lda #$08	                lda #8
.9ddd	4c 5d 9e	jmp $9e5d	                jmp _save_character
.9de0					_check_esc_e:
.9de0	c9 65		cmp #$65	                cmp #'e'
.9de2	d0 04		bne $9de8	                bne _check_esc_f
.9de4	a9 1b		lda #$1b	                lda #27
.9de6	80 75		bra $9e5d	                bra _save_character
.9de8					_check_esc_f:
.9de8	c9 66		cmp #$66	                cmp #'f'
.9dea	d0 04		bne $9df0	                bne _check_esc_l
.9dec	a9 0c		lda #$0c	                lda #12
.9dee	80 6d		bra $9e5d	                bra _save_character
.9df0					_check_esc_l:
.9df0	c9 6c		cmp #$6c	                cmp #'l'
.9df2	d0 04		bne $9df8	                bne _check_esc_m
.9df4	a9 0a		lda #$0a	                lda #10
.9df6	80 65		bra $9e5d	                bra _save_character
.9df8					_check_esc_m:
.9df8	c9 6d		cmp #$6d	                cmp #'m'
.9dfa	d0 09		bne $9e05	                bne _check_esc_n
.9dfc	a9 0d		lda #$0d	                lda #13
.9dfe	20 bf d7	jsr $d7bf	                jsr cmpl_a
.9e01	a9 0a		lda #$0a	                lda #10
.9e03	80 58		bra $9e5d	                bra _save_character
.9e05					_check_esc_n:
.9e05	c9 6e		cmp #$6e	                cmp #'n'
.9e07	d0 04		bne $9e0d	                bne _check_esc_q
.9e09	a9 0a		lda #$0a	                lda #10
.9e0b	80 50		bra $9e5d	                bra _save_character
.9e0d					_check_esc_q:
.9e0d	c9 71		cmp #$71	                cmp #'q'
.9e0f	d0 04		bne $9e15	                bne _check_esc_r
.9e11	a9 22		lda #$22	                lda #34
.9e13	80 48		bra $9e5d	                bra _save_character
.9e15					_check_esc_r:
.9e15	c9 72		cmp #$72	                cmp #'r'
.9e17	d0 04		bne $9e1d	                bne _check_esc_t
.9e19	a9 0d		lda #$0d	                lda #13
.9e1b	80 40		bra $9e5d	                bra _save_character
.9e1d					_check_esc_t:
.9e1d	c9 74		cmp #$74	                cmp #'t'
.9e1f	d0 04		bne $9e25	                bne _check_esc_v
.9e21	a9 09		lda #$09	                lda #9
.9e23	80 38		bra $9e5d	                bra _save_character
.9e25					_check_esc_v:
.9e25	c9 76		cmp #$76	                cmp #'v'
.9e27	d0 04		bne $9e2d	                bne _check_esc_z
.9e29	a9 0b		lda #$0b	                lda #11
.9e2b	80 30		bra $9e5d	                bra _save_character
.9e2d					_check_esc_z:
.9e2d	c9 7a		cmp #$7a	                cmp #'z'
.9e2f	d0 04		bne $9e35	                bne _check_esc_quote
.9e31	a9 00		lda #$00	                lda #0
.9e33	80 28		bra $9e5d	                bra _save_character
.9e35					_check_esc_quote:
.9e35	c9 22		cmp #$22	                cmp #$22
.9e37	d0 04		bne $9e3d	                bne _check_esc_x
.9e39	a9 22		lda #$22	                lda #34
.9e3b	80 20		bra $9e5d	                bra _save_character
.9e3d					_check_esc_x:
.9e3d	c9 78		cmp #$78	                cmp #'x'
.9e3f	d0 06		bne $9e47	                bne _check_esc_backslash
.9e41	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e43	85 27		sta $27		                sta tmp2+1
.9e45	80 19		bra $9e60	                bra _next_character
.9e47					_check_esc_backslash:
.9e47	c9 5c		cmp #$5c	                cmp #$5C
.9e49	d0 04		bne $9e4f	                bne _not_escaped
.9e4b	a9 5c		lda #$5c	                lda #92
.9e4d	80 0e		bra $9e5d	                bra _save_character
.9e4f					_not_escaped:
.9e4f	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e51	d0 06		bne $9e59	                bne _regular_char
.9e53	a9 ff		lda #$ff	                lda #$FF
.9e55	85 27		sta $27		                sta tmp2+1
.9e57	80 07		bra $9e60	                bra _next_character
.9e59					_regular_char:
.9e59	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e5b	f0 0c		beq $9e69	                beq _found_string_end
.9e5d					_save_character:
.9e5d	20 bf d7	jsr $d7bf	                jsr cmpl_a
.9e60					_next_character:
.9e60	e6 0c		inc $0c		                inc toin
.9e62	d0 02		bne $9e66	                bne _savechars_loop_longjump
.9e64	e6 0d		inc $0d		                inc toin+1
.9e66					_savechars_loop_longjump:
.9e66	4c 5b 9d	jmp $9d5b	                jmp _savechars_loop
.9e69					_found_string_end:
.9e69	e6 0c		inc $0c		                inc toin
.9e6b	d0 02		bne $9e6f	                bne +
.9e6d	e6 0d		inc $0d		                inc toin+1
.9e6f					+
.9e6f	a5 00		lda $00		                lda cp
.9e71	38		sec		                sec
.9e72	f5 02		sbc $02,x	                sbc 2,x
.9e74	95 00		sta $00,x	                sta 0,x         ; LSB
.9e76	a5 01		lda $01		                lda cp+1
.9e78	f5 03		sbc $03,x	                sbc 3,x
.9e7a	95 01		sta $01,x	                sta 1,x         ; MSB
.9e7c	b5 02		lda $02,x	                lda 2,x
.9e7e	38		sec		                sec
.9e7f	e9 02		sbc #$02	                sbc #2
.9e81	85 24		sta $24		                sta tmp1
.9e83	b5 03		lda $03,x	                lda 3,x
.9e85	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e87	85 25		sta $25		                sta tmp1+1
.9e89	a5 00		lda $00		                lda cp
.9e8b	92 24		sta ($24)	                sta (tmp1)
.9e8d	a0 01		ldy #$01	                ldy #1
.9e8f	a5 01		lda $01		                lda cp+1
.9e91	91 24		sta ($24),y	                sta (tmp1),y
.9e93	a5 16		lda $16		                lda state
.9e95	05 17		ora $17		                ora state+1             ; paranoid
.9e97	f0 03		beq $9e9c	                beq _done
.9e99	20 80 a0	jsr $a080	                jsr sliteral_const_str         ; ( addr u -- )
.9e9c					_done:
.9e9c	60		rts		z_s_quote:      rts
.9e9d					xt_s_to_d:
.9e9d	20 0c d9	jsr $d90c	                jsr underflow_1
.9ea0	ca		dex		                dex
.9ea1	ca		dex		                dex
.9ea2	74 00		stz $00,x	                stz 0,x
.9ea4	74 01		stz $01,x	                stz 1,x
.9ea6	b5 03		lda $03,x	                lda 3,x
.9ea8	10 04		bpl $9eae	                bpl _done
.9eaa	d6 00		dec $00,x	                dec 0,x
.9eac	d6 01		dec $01,x	                dec 1,x
.9eae					_done:
.9eae	60		rts		z_s_to_d:       rts
.9eaf					xt_save_buffers:
.9eaf	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9eb1	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9eb3	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9eb5	d0 12		bne $9ec9	                bne _done       ; Either not used or not dirty = done!
.9eb7	20 a4 83	jsr $83a4	                jsr xt_blkbuffer
.9eba	20 96 85	jsr $8596	                jsr xt_buffblocknum
.9ebd	20 71 8f	jsr $8f71	                jsr xt_fetch
.9ec0	20 51 85	jsr $8551	                jsr xt_block_write
.9ec3	a9 01		lda #$01	                lda #1
.9ec5	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ec7	91 1e		sta ($1e),y	                sta (up),y
.9ec9					_done:
.9ec9	60		rts		z_save_buffers: rts
.9eca					xt_scr:
.9eca	ca		dex		                dex
.9ecb	ca		dex		                dex
.9ecc	18		clc		                clc
.9ecd	a5 1e		lda $1e		                lda up
.9ecf	69 02		adc #$02	                adc #scr_offset ; Add offset
.9ed1	95 00		sta $00,x	                sta 0,x
.9ed3	a5 1f		lda $1f		                lda up+1
.9ed5	69 00		adc #$00	                adc #0          ; Adding carry
.9ed7	95 01		sta $01,x	                sta 1,x
.9ed9	60		rts		z_scr:          rts
.9eda					xt_search:
.9eda	20 1b d9	jsr $d91b	                jsr underflow_4
.9edd	b5 00		lda $00,x	                lda 0,x
.9edf	15 01		ora $01,x	                ora 1,x
.9ee1	d0 0b		bne $9eee	                bne _start_search
.9ee3	e8		inx		                inx             ; Remove u2
.9ee4	e8		inx		                inx
.9ee5	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ee7	95 00		sta $00,x	                sta 0,x
.9ee9	95 01		sta $01,x	                sta 1,x
.9eeb	4c 78 9f	jmp $9f78	                jmp z_search
.9eee					_start_search:
.9eee	20 99 a7	jsr $a799	                jsr xt_zero
.9ef1					_search_loop:
.9ef1	18		clc		                clc
.9ef2	b5 00		lda $00,x	                lda 0,x
.9ef4	75 02		adc $02,x	                adc 2,x
.9ef6	85 24		sta $24		                sta tmp1
.9ef8	b5 01		lda $01,x	                lda 1,x
.9efa	75 03		adc $03,x	                adc 3,x
.9efc	d5 07		cmp $07,x	                cmp 7,x
.9efe	90 12		bcc $9f12	                bcc _init_comparison ; Obviously less
.9f00	d0 06		bne $9f08	                bne _not_found
.9f02	b5 06		lda $06,x	                lda 6,x
.9f04	c5 24		cmp $24		                cmp tmp1
.9f06	b0 0a		bcs $9f12	                bcs _init_comparison
.9f08					_not_found:
.9f08	e8		inx		                inx             ; Remove offset
.9f09	e8		inx		                inx
.9f0a	e8		inx		                inx             ; Remove u2
.9f0b	e8		inx		                inx
.9f0c	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9f0e	74 01		stz $01,x	                stz 1,x
.9f10	80 66		bra $9f78	                bra z_search
.9f12					_init_comparison:
.9f12	18		clc		                clc
.9f13	b5 08		lda $08,x	                lda 8,x
.9f15	75 00		adc $00,x	                adc 0,x
.9f17	85 24		sta $24		                sta tmp1
.9f19	b5 09		lda $09,x	                lda 9,x
.9f1b	75 01		adc $01,x	                adc 1,x
.9f1d	85 25		sta $25		                sta tmp1+1
.9f1f	b5 04		lda $04,x	                lda 4,x
.9f21	85 26		sta $26		                sta tmp2
.9f23	b5 05		lda $05,x	                lda 5,x
.9f25	85 27		sta $27		                sta tmp2+1
.9f27	b5 02		lda $02,x	                lda 2,x
.9f29	85 28		sta $28		                sta tmp3
.9f2b	b5 03		lda $03,x	                lda 3,x
.9f2d	85 29		sta $29		                sta tmp3+1
.9f2f					_comparison_loop:
.9f2f	b2 24		lda ($24)	                lda (tmp1)
.9f31	d2 26		cmp ($26)	                cmp (tmp2)
.9f33	f0 05		beq $9f3a	                beq _letters_match
.9f35	20 0e 98	jsr $980e	                jsr xt_one_plus
.9f38	80 b7		bra $9ef1	                bra _search_loop
.9f3a					_letters_match:
.9f3a	e6 24		inc $24		                inc tmp1
.9f3c	d0 02		bne $9f40	                bne +
.9f3e	e6 25		inc $25		                inc tmp1+1
.9f40					+
.9f40	e6 26		inc $26		                inc tmp2
.9f42	d0 02		bne $9f46	                bne +
.9f44	e6 27		inc $27		                inc tmp2+1
.9f46					+
.9f46	a5 28		lda $28		                lda tmp3
.9f48	d0 02		bne $9f4c	                bne +
.9f4a	c6 29		dec $29		                dec tmp3+1
.9f4c					+
.9f4c	c6 28		dec $28		                dec tmp3
.9f4e	a5 28		lda $28		                lda tmp3
.9f50	05 29		ora $29		                ora tmp3+1
.9f52	d0 db		bne $9f2f	                bne _comparison_loop ; Check the next letter
.9f54	18		clc		                clc
.9f55	b5 00		lda $00,x	                lda 0,x
.9f57	75 08		adc $08,x	                adc 8,x
.9f59	95 08		sta $08,x	                sta 8,x
.9f5b	b5 01		lda $01,x	                lda 1,x
.9f5d	75 09		adc $09,x	                adc 9,x
.9f5f	95 09		sta $09,x	                sta 9,x
.9f61	38		sec		                sec
.9f62	b5 06		lda $06,x	                lda 6,x
.9f64	f5 00		sbc $00,x	                sbc 0,x
.9f66	95 06		sta $06,x	                sta 6,x
.9f68	b5 07		lda $07,x	                lda 7,x
.9f6a	f5 01		sbc $01,x	                sbc 1,x
.9f6c	95 07		sta $07,x	                sta 7,x
.9f6e	e8		inx		                inx             ; drop offset
.9f6f	e8		inx		                inx
.9f70	e8		inx		                inx             ; drop u2
.9f71	e8		inx		                inx
.9f72	a9 ff		lda #$ff	                lda #$FF
.9f74	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f76	95 01		sta $01,x	                sta 1,x
.9f78	60		rts		z_search:       rts
.9f79					xt_semicolon:
.9f79	24 20		bit $20		                bit status
.9f7b	70 11		bvs $9f8e	                bvs _colonword
.9f7d	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f7f	20 bf d7	jsr $d7bf	                jsr cmpl_a
.9f82	ca		dex		                dex
.9f83	ca		dex		                dex
.9f84	a5 04		lda $04		                lda workword
.9f86	95 00		sta $00,x	                sta 0,x
.9f88	a5 05		lda $05		                lda workword+1
.9f8a	95 01		sta $01,x	                sta 1,x
.9f8c	80 45		bra $9fd3	                bra _semicolon_done
.9f8e					_colonword:
.9f8e	a0 06		ldy #$06	                ldy #6
.9f90	a5 00		lda $00		                lda cp
.9f92	91 04		sta ($04),y	                sta (workword),y
.9f94	c8		iny		                iny
.9f95	a5 01		lda $01		                lda cp+1
.9f97	91 04		sta ($04),y	                sta (workword),y
.9f99	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f9b	20 bf d7	jsr $d7bf	                jsr cmpl_a
.9f9e	24 20		bit $20		                bit status
.9fa0	10 26		bpl $9fc8	                bpl _new_word   ; Bit 7 is clear = new word
.9fa2	ca		dex		                dex
.9fa3	ca		dex		                dex
.9fa4	ca		dex		                dex
.9fa5	ca		dex		                dex
.9fa6	b2 04		lda ($04)	                lda (workword)
.9fa8	95 00		sta $00,x	                sta 0,x
.9faa	74 01		stz $01,x	                stz 1,x
.9fac	a5 04		lda $04		                lda workword
.9fae	18		clc		                clc
.9faf	69 08		adc #$08	                adc #8
.9fb1	95 02		sta $02,x	                sta 2,x
.9fb3	a5 05		lda $05		                lda workword+1
.9fb5	69 00		adc #$00	                adc #0                  ; only want carry
.9fb7	95 03		sta $03,x	                sta 3,x
.9fb9	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9fbb	20 48 d9	jsr $d948	                jsr print_string_no_lf
.9fbe	20 f4 a4	jsr $a4f4	                jsr xt_type
.9fc1	20 0f a1	jsr $a10f	                jsr xt_space
.9fc4	a9 80		lda #$80	                lda #%10000000
.9fc6	14 20		trb $20		                trb status
.9fc8					_new_word:
.9fc8	a5 04		lda $04		                lda workword
.9fca	85 02		sta $02		                sta dp
.9fcc	a5 05		lda $05		                lda workword+1
.9fce	85 03		sta $03		                sta dp+1
.9fd0	20 61 d8	jsr $d861	                jsr dp_to_current       ; Save the updated DP to the
.9fd3					_semicolon_done:
.9fd3	64 16		stz $16		                stz state
.9fd5	64 17		stz $17		                stz state+1
.9fd7	60		rts		z_semicolon:    rts
.9fd8					xt_sign:
.9fd8	20 0c d9	jsr $d90c	                jsr underflow_1
.9fdb	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9fdd	30 04		bmi $9fe3	                bmi _minus
.9fdf	e8		inx		                inx
.9fe0	e8		inx		                inx
.9fe1	80 09		bra $9fec	                bra _done
.9fe3					_minus:
.9fe3	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9fe5	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9fe7	74 01		stz $01,x	                stz 1,x         ; paranoid
.9fe9	20 c8 91	jsr $91c8	                jsr xt_hold
.9fec					_done:
.9fec	60		rts		z_sign:         rts
.9fed					xt_slash:
.9fed	a9 00		lda #$00	                lda #0
.9fef	48		pha		                pha
.9ff0	80 03		bra $9ff5	                bra slashmod_common
.9ff2					xt_slash_mod:
.9ff2	a9 ff		lda #$ff	                lda #$FF
.9ff4	48		pha		                pha             ; falls through to _common
.9ff5					slashmod_common:
.9ff5	20 61 a3	jsr $a361	                jsr xt_to_r             ; >R
.9ff8	20 9d 9e	jsr $9e9d	                jsr xt_s_to_d           ; S>D
.9ffb	20 83 9a	jsr $9a83	                jsr xt_r_from           ; R>
.9ffe	20 c6 a0	jsr $a0c6	                jsr xt_sm_slash_rem     ; SM/REM
.a001	68		pla		                pla
.a002	d0 05		bne $a009	                bne _done
.a004	20 9f a1	jsr $a19f	                jsr xt_swap
.a007	e8		inx		                inx             ; DROP
.a008	e8		inx		                inx
.a009					_done:
.a009					z_slash_mod:
.a009	60		rts		z_slash:        rts
.a00a					xt_slash_string:
.a00a	20 16 d9	jsr $d916	                jsr underflow_3
.a00d	18		clc		                clc             ; 3OS+TOS
.a00e	b5 00		lda $00,x	                lda 0,x
.a010	75 04		adc $04,x	                adc 4,x
.a012	95 04		sta $04,x	                sta 4,x
.a014	b5 01		lda $01,x	                lda 1,x
.a016	75 05		adc $05,x	                adc 5,x
.a018	95 05		sta $05,x	                sta 5,x
.a01a	38		sec		                sec             ; NOS-TOS
.a01b	b5 02		lda $02,x	                lda 2,x
.a01d	f5 00		sbc $00,x	                sbc 0,x
.a01f	95 02		sta $02,x	                sta 2,x
.a021	b5 03		lda $03,x	                lda 3,x
.a023	f5 01		sbc $01,x	                sbc 1,x
.a025	95 03		sta $03,x	                sta 3,x
.a027	e8		inx		                inx
.a028	e8		inx		                inx
.a029	60		rts		z_slash_string: rts
.a02a					xt_sliteral:
.a02a	20 11 d9	jsr $d911	                jsr underflow_2
.a02d	a9 4c		lda #$4c	                lda #$4C
.a02f	20 bf d7	jsr $d7bf	                jsr cmpl_a
.a032	20 bf d7	jsr $d7bf	                jsr cmpl_a
.a035	20 bf d7	jsr $d7bf	                jsr cmpl_a
.a038	8a		txa		                txa
.a039	38		sec		                sec
.a03a	e9 06		sbc #$06	                sbc #6
.a03c	aa		tax		                tax
.a03d	b5 08		lda $08,x	                lda 8,x
.a03f	95 04		sta $04,x	                sta 4,x
.a041	b5 09		lda $09,x	                lda 9,x
.a043	95 05		sta $05,x	                sta 5,x
.a045	b5 06		lda $06,x	                lda 6,x
.a047	95 00		sta $00,x	                sta 0,x
.a049	b5 07		lda $07,x	                lda 7,x
.a04b	95 01		sta $01,x	                sta 1,x
.a04d	a5 00		lda $00		                lda cp
.a04f	95 08		sta $08,x	                sta 8,x
.a051	95 02		sta $02,x	                sta 2,x
.a053	a5 01		lda $01		                lda cp+1
.a055	95 09		sta $09,x	                sta 9,x
.a057	95 03		sta $03,x	                sta 3,x
.a059	20 b3 95	jsr $95b3	                jsr xt_move
.a05c	18		clc		                clc
.a05d	a5 00		lda $00		                lda cp
.a05f	75 00		adc $00,x	                adc 0,x
.a061	85 00		sta $00		                sta cp
.a063	a5 01		lda $01		                lda cp+1
.a065	75 01		adc $01,x	                adc 1,x
.a067	85 01		sta $01		                sta cp+1
.a069	b5 02		lda $02,x	                lda 2,x
.a06b	38		sec		                sec
.a06c	e9 02		sbc #$02	                sbc #2
.a06e	85 24		sta $24		                sta tmp1
.a070	b5 03		lda $03,x	                lda 3,x
.a072	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a074	85 25		sta $25		                sta tmp1+1
.a076	a5 00		lda $00		                lda cp
.a078	92 24		sta ($24)	                sta (tmp1)
.a07a	a0 01		ldy #$01	                ldy #1
.a07c	a5 01		lda $01		                lda cp+1
.a07e	91 24		sta ($24),y	                sta (tmp1),y
.a080					sliteral_const_str:
.a080	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a082	a9 9a		lda #$9a	                lda #<sliteral_runtime
.a084	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.a087	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a089	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a08b	20 bb d7	jsr $d7bb	                jsr cmpl_word
.a08e	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a090	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a092	20 bb d7	jsr $d7bb	                jsr cmpl_word
.a095	e8		inx		                inx
.a096	e8		inx		                inx
.a097	e8		inx		                inx
.a098	e8		inx		                inx
.a099	60		rts		z_sliteral:     rts
.a09a					sliteral_runtime:
.a09a	ca		dex		                dex
.a09b	ca		dex		                dex
.a09c	ca		dex		                dex
.a09d	ca		dex		                dex
.a09e	68		pla		                pla
.a09f	85 24		sta $24		                sta tmp1        ; LSB of address
.a0a1	68		pla		                pla
.a0a2	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a0a4	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a0a6	b1 24		lda ($24),y	                lda (tmp1),y
.a0a8	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a0aa	c8		iny		                iny
.a0ab	b1 24		lda ($24),y	                lda (tmp1),y
.a0ad	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a0af	c8		iny		                iny
.a0b0	b1 24		lda ($24),y	                lda (tmp1),y
.a0b2	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a0b4	c8		iny		                iny
.a0b5	b1 24		lda ($24),y	                lda (tmp1),y
.a0b7	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a0b9	18		clc		                clc
.a0ba	a5 24		lda $24		                lda tmp1
.a0bc	69 04		adc #$04	                adc #4
.a0be	a8		tay		                tay             ; LSB
.a0bf	a5 25		lda $25		                lda tmp1+1
.a0c1	69 00		adc #$00	                adc #0          ; we only need carry
.a0c3	48		pha		                pha             ; MSB
.a0c4	5a		phy		                phy
.a0c5	60		rts		                rts
.a0c6					xt_sm_slash_rem:
.a0c6	20 16 d9	jsr $d916	                jsr underflow_3 ; contains double number
.a0c9	b5 03		lda $03,x	                lda 3,x
.a0cb	48		pha		                pha
.a0cc	b5 01		lda $01,x	                lda 1,x
.a0ce	55 03		eor $03,x	                eor 3,x
.a0d0	48		pha		                pha
.a0d1	20 2a 81	jsr $812a	                jsr xt_abs
.a0d4	e8		inx		                inx             ; pretend we pushed n1 to R
.a0d5	e8		inx		                inx
.a0d6	20 77 8a	jsr $8a77	                jsr xt_dabs
.a0d9	ca		dex		                dex
.a0da	ca		dex		                dex
.a0db	20 ab a5	jsr $a5ab	                jsr xt_um_slash_mod     ; UM/MOD
.a0de	68		pla		                pla
.a0df	10 03		bpl $a0e4	                bpl +
.a0e1	20 14 96	jsr $9614	                jsr xt_negate
.a0e4					+
.a0e4	68		pla		                pla
.a0e5	10 07		bpl $a0ee	                bpl _done
.a0e7	e8		inx		                inx             ; pretend we pushed quotient to R
.a0e8	e8		inx		                inx
.a0e9	20 14 96	jsr $9614	                jsr xt_negate
.a0ec	ca		dex		                dex
.a0ed	ca		dex		                dex
.a0ee					_done:
.a0ee	60		rts		z_sm_slash_rem: rts
.a0ef					xt_source:
.a0ef	ca		dex		                dex
.a0f0	ca		dex		                dex
.a0f1	a5 08		lda $08		                lda cib
.a0f3	95 00		sta $00,x	                sta 0,x
.a0f5	a5 09		lda $09		                lda cib+1
.a0f7	95 01		sta $01,x	                sta 1,x
.a0f9	ca		dex		                dex
.a0fa	ca		dex		                dex
.a0fb	a5 0a		lda $0a		                lda ciblen
.a0fd	95 00		sta $00,x	                sta 0,x
.a0ff	a5 0b		lda $0b		                lda ciblen+1
.a101	95 01		sta $01,x	                sta 1,x
.a103	60		rts		z_source:       rts
.a104					xt_source_id:
.a104	ca		dex		                dex
.a105	ca		dex		                dex
.a106	a5 06		lda $06		                lda insrc
.a108	95 00		sta $00,x	                sta 0,x
.a10a	a5 07		lda $07		                lda insrc+1
.a10c	95 01		sta $01,x	                sta 1,x
.a10e	60		rts		z_source_id:    rts
.a10f					xt_space:
.a10f	a9 20		lda #$20	                lda #AscSP
.a111	20 e7 8d	jsr $8de7	                jsr emit_a
.a114	60		rts		z_space:        rts
.a115					xt_spaces:
.a115	20 0c d9	jsr $d90c	                jsr underflow_1
.a118	20 99 a7	jsr $a799	                jsr xt_zero
.a11b	20 09 95	jsr $9509	                jsr xt_max
.a11e	b5 00		lda $00,x	                lda 0,x
.a120	15 01		ora $01,x	                ora 1,x
.a122	f0 2a		beq $a14e	                beq _done
.a124	b4 01		ldy $01,x	                ldy 1,x
.a126	d0 0c		bne $a134	                bne _lots_of_spaces
.a128	b4 00		ldy $00,x	                ldy 0,x
.a12a					_quick_loop:
.a12a	a9 20		lda #$20	                lda #AscSP
.a12c	20 e7 8d	jsr $8de7	                jsr emit_a
.a12f	88		dey		                dey
.a130	f0 1c		beq $a14e	                beq _done
.a132	80 f6		bra $a12a	                bra _quick_loop
.a134					_lots_of_spaces:
.a134	b4 00		ldy $00,x	                ldy 0,x
.a136					_first_slow_loop:
.a136	f0 08		beq $a140	                beq _slow_outer_loop
.a138	a9 20		lda #$20	                lda #AscSP
.a13a	20 e7 8d	jsr $8de7	                jsr emit_a
.a13d	88		dey		                dey
.a13e	80 f6		bra $a136	                bra _first_slow_loop
.a140					_slow_outer_loop:
.a140	a0 00		ldy #$00	                ldy #00
.a142					_slow_inner_loop:
.a142	a9 20		lda #$20	                lda #AscSP
.a144	20 e7 8d	jsr $8de7	                jsr emit_a
.a147	88		dey		                dey
.a148	d0 f8		bne $a142	                bne _slow_inner_loop
.a14a	d6 01		dec $01,x	                dec 1,x
.a14c	d0 f2		bne $a140	                bne _slow_outer_loop
.a14e					_done:
.a14e	e8		inx		                inx             ; drop
.a14f	e8		inx		                inx
.a150	60		rts		z_spaces:       rts
.a151					xt_star:
.a151	20 11 d9	jsr $d911	                jsr underflow_2
.a154	20 ed a5	jsr $a5ed	                jsr xt_um_star
.a157	e8		inx		                inx
.a158	e8		inx		                inx
.a159	60		rts		z_star:         rts
.a15a					xt_star_slash:
.a15a	20 63 a1	jsr $a163	                jsr xt_star_slash_mod
.a15d	20 9f a1	jsr $a19f	                jsr xt_swap
.a160	e8		inx		                inx
.a161	e8		inx		                inx
.a162					z_star_slash:
.a162	60		rts		                rts
.a163					xt_star_slash_mod:
.a163	20 16 d9	jsr $d916	                jsr underflow_3
.a166	20 61 a3	jsr $a361	                jsr xt_to_r
.a169	20 7f 94	jsr $947f	                jsr xt_m_star
.a16c	20 83 9a	jsr $9a83	                jsr xt_r_from
.a16f	20 c6 a0	jsr $a0c6	                jsr xt_sm_slash_rem
.a172					z_star_slash_mod:
.a172	60		rts		                rts
.a173					xt_state:
.a173	ca		dex		                dex
.a174	ca		dex		                dex
.a175	a9 16		lda #$16	                lda #<state
.a177	95 00		sta $00,x	                sta 0,x
.a179	a9 00		lda #$00	                lda #>state
.a17b	95 01		sta $01,x	                sta 1,x
.a17d	60		rts		z_state:        rts
.a17e					xt_store:
.a17e	20 11 d9	jsr $d911	                jsr underflow_2
.a181	b5 02		lda $02,x	                lda 2,x         ; LSB
.a183	81 00		sta ($00,x)	                sta (0,x)
.a185	f6 00		inc $00,x	                inc 0,x
.a187	d0 02		bne $a18b	                bne +
.a189	f6 01		inc $01,x	                inc 1,x
.a18b					+
.a18b	b5 03		lda $03,x	                lda 3,x         ; MSB
.a18d	81 00		sta ($00,x)	                sta (0,x)
.a18f	e8		inx		                inx             ; 2DROP
.a190	e8		inx		                inx
.a191	e8		inx		                inx
.a192	e8		inx		                inx
.a193	60		rts		z_store:        rts
.a194					xt_strip_underflow:
.a194	ca		dex		                dex
.a195	ca		dex		                dex
.a196	a9 1c		lda #$1c	                lda #<uf_strip
.a198	95 00		sta $00,x	                sta 0,x
.a19a	a9 00		lda #$00	                lda #>uf_strip
.a19c	95 01		sta $01,x	                sta 1,x
.a19e					z_strip_underflow:
.a19e	60		rts		                rts
.a19f					xt_swap:
.a19f	20 11 d9	jsr $d911	                jsr underflow_2
.a1a2	b5 00		lda $00,x	                lda 0,x         ; LSB
.a1a4	b4 02		ldy $02,x	                ldy 2,x
.a1a6	95 02		sta $02,x	                sta 2,x
.a1a8	94 00		sty $00,x	                sty 0,x
.a1aa	b5 01		lda $01,x	                lda 1,x         ; MSB
.a1ac	b4 03		ldy $03,x	                ldy 3,x
.a1ae	95 03		sta $03,x	                sta 3,x
.a1b0	94 01		sty $01,x	                sty 1,x
.a1b2	60		rts		z_swap:         rts
.a1b3					xt_then:
.a1b3	20 63 91	jsr $9163	                jsr xt_here
.a1b6	20 9f a1	jsr $a19f	                jsr xt_swap
.a1b9	20 7e a1	jsr $a17e	                jsr xt_store
.a1bc	60		rts		z_then:         rts
.a1bd					xt_thru:
.a1bd	20 11 d9	jsr $d911	                jsr underflow_2
.a1c0	b5 01		lda $01,x	                lda 1,x
.a1c2	48		pha		                pha
.a1c3	b5 00		lda $00,x	                lda 0,x
.a1c5	48		pha		                pha
.a1c6	e8		inx		                inx
.a1c7	e8		inx		                inx
.a1c8					_thru_loop:
.a1c8	b5 01		lda $01,x	                lda 1,x
.a1ca	48		pha		                pha
.a1cb	b5 00		lda $00,x	                lda 0,x
.a1cd	48		pha		                pha
.a1ce	20 a8 93	jsr $93a8	                jsr xt_load
.a1d1	68		pla		                pla
.a1d2	85 24		sta $24		                sta tmp1
.a1d4	68		pla		                pla
.a1d5	85 25		sta $25		                sta tmp1+1
.a1d7	68		pla		                pla
.a1d8	85 26		sta $26		                sta tmp2
.a1da	68		pla		                pla
.a1db	85 27		sta $27		                sta tmp2+1
.a1dd	c5 25		cmp $25		                cmp tmp1+1
.a1df	d0 08		bne $a1e9	                bne _next_screen
.a1e1	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a1e3	c5 24		cmp $24		                cmp tmp1
.a1e5	d0 02		bne $a1e9	                bne _next_screen
.a1e7	80 18		bra $a201	                bra _done       ; We just did the last screen.
.a1e9					_next_screen:
.a1e9	a5 27		lda $27		                lda tmp2+1
.a1eb	48		pha		                pha
.a1ec	a5 26		lda $26		                lda tmp2
.a1ee	48		pha		                pha
.a1ef	e6 24		inc $24		                inc tmp1
.a1f1	d0 02		bne $a1f5	                bne +
.a1f3	e6 25		inc $25		                inc tmp1+1
.a1f5					+
.a1f5	ca		dex		                dex
.a1f6	ca		dex		                dex
.a1f7	a5 24		lda $24		                lda tmp1
.a1f9	95 00		sta $00,x	                sta 0,x
.a1fb	a5 25		lda $25		                lda tmp1+1
.a1fd	95 01		sta $01,x	                sta 1,x
.a1ff	80 c7		bra $a1c8	                bra _thru_loop
.a201					_done:
.a201	60		rts		z_thru:         rts
.a202					xt_tick:
.a202	20 d0 98	jsr $98d0	                jsr xt_parse_name       ; ( -- addr u )
.a205	b5 00		lda $00,x	                lda 0,x
.a207	15 01		ora $01,x	                ora 1,x
.a209	d0 05		bne $a210	                bne +
.a20b	a9 05		lda #$05	                lda #err_noname
.a20d	4c 22 d9	jmp $d922	                jmp error
.a210					+
.a210	20 cc 8f	jsr $8fcc	                jsr xt_find_name        ; ( addr u -- nt )
.a213	b5 00		lda $00,x	                lda 0,x
.a215	15 01		ora $01,x	                ora 1,x
.a217	d0 05		bne $a21e	                bne +
.a219	a9 08		lda #$08	                lda #err_syntax
.a21b	4c 22 d9	jmp $d922	                jmp error
.a21e					+
.a21e	20 d2 95	jsr $95d2	                jsr xt_name_to_int      ; ( nt -- xt )
.a221	60		rts		z_tick:         rts
.a222					xt_to:
.a222	20 02 a2	jsr $a202	                jsr xt_tick             ; ( [n] xt )
.a225	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a227	18		clc		                clc
.a228	69 03		adc #$03	                adc #3
.a22a	85 24		sta $24		                sta tmp1
.a22c	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a22e	69 00		adc #$00	                adc #0                  ; we just want the carry
.a230	85 25		sta $25		                sta tmp1+1
.a232	e8		inx		                inx
.a233	e8		inx		                inx                     ; ( [n] )
.a234	a5 16		lda $16		                lda state
.a236	05 17		ora $17		                ora state+1
.a238	f0 34		beq $a26e	                beq _interpret
.a23a	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a23c	a9 b5		lda #$b5	                lda #$B5
.a23e	20 bb d7	jsr $d7bb	                jsr cmpl_word
.a241	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a243	20 bf d7	jsr $d7bf	                jsr cmpl_a
.a246	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a248	a5 24		lda $24		                lda tmp1
.a24a	20 bb d7	jsr $d7bb	                jsr cmpl_word
.a24d	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a24f	a9 b5		lda #$b5	                lda #$B5
.a251	20 bb d7	jsr $d7bb	                jsr cmpl_word
.a254	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a256	20 bf d7	jsr $d7bf	                jsr cmpl_a
.a259	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a25b	d0 02		bne $a25f	                bne +
.a25d	e6 25		inc $25		                inc tmp1+1
.a25f					+
.a25f	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a261	a5 24		lda $24		                lda tmp1
.a263	20 bb d7	jsr $d7bb	                jsr cmpl_word
.a266	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a268	98		tya		                tya
.a269	20 bb d7	jsr $d7bb	                jsr cmpl_word
.a26c	80 0f		bra $a27d	                bra _done
.a26e					_interpret:
.a26e	20 0c d9	jsr $d90c	                jsr underflow_1
.a271	b5 00		lda $00,x	                lda 0,x
.a273	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a275	a0 01		ldy #$01	                ldy #1
.a277	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a279	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a27b	e8		inx		                inx                     ; DROP
.a27c	e8		inx		                inx
.a27d					_done:
.a27d	60		rts		z_to:           rts
.a27e					xt_to_body:
.a27e	20 0c d9	jsr $d90c	                jsr underflow_1
.a281	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( xt xt )
.a284	20 69 92	jsr $9269	                jsr xt_int_to_name      ; ( xt nt )
.a287	f6 00		inc $00,x	                inc 0,x
.a289	d0 02		bne $a28d	                bne +
.a28b	f6 01		inc $01,x	                inc 1,x
.a28d					+
.a28d	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a28f	29 20		and #$20	                and #HC
.a291	f0 0d		beq $a2a0	                beq _no_cfa
.a293	18		clc		                clc
.a294	b5 02		lda $02,x	                lda 2,x         ; LSB
.a296	69 03		adc #$03	                adc #3
.a298	95 02		sta $02,x	                sta 2,x
.a29a	b5 03		lda $03,x	                lda 3,x         ; MSB
.a29c	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a29e	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a2a0					_no_cfa:
.a2a0	e8		inx		                inx             ; get rid of the nt
.a2a1	e8		inx		                inx
.a2a2					_done:
.a2a2	60		rts		z_to_body:      rts
.a2a3					xt_to_in:
.a2a3	ca		dex		                dex
.a2a4	ca		dex		                dex
.a2a5	a9 0c		lda #$0c	                lda #<toin
.a2a7	95 00		sta $00,x	                sta 0,x
.a2a9	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a2ab	95 01		sta $01,x	                sta 1,x
.a2ad	60		rts		z_to_in:        rts
.a2ae					xt_to_number:
.a2ae	20 1b d9	jsr $d91b	                jsr underflow_4
.a2b1	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a2b3	85 36		sta $36		                sta scratch
.a2b5	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a2b7	85 37		sta $37		                sta scratch+1
.a2b9	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a2bb	85 38		sta $38		                sta scratch+2
.a2bd	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a2bf	85 39		sta $39		                sta scratch+3
.a2c1	ca		dex		                dex
.a2c2	ca		dex		                dex
.a2c3					_loop:
.a2c3	a1 04		lda ($04,x)	                lda (4,x)
.a2c5	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a2c7	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2c9	20 f6 8a	jsr $8af6	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a2cc	b5 00		lda $00,x	                lda 0,x
.a2ce	d0 04		bne $a2d4	                bne _digit_ok
.a2d0	e8		inx		                inx
.a2d1	e8		inx		                inx
.a2d2	80 67		bra $a33b	                bra _done       ; ( ud-lo ud-hi addr u char )
.a2d4					_digit_ok:
.a2d4	b5 02		lda $02,x	                lda 2,x
.a2d6	85 3a		sta $3a		                sta scratch+4
.a2d8	b5 03		lda $03,x	                lda 3,x
.a2da	85 3b		sta $3b		                sta scratch+5
.a2dc	a5 38		lda $38		                lda scratch+2
.a2de	95 02		sta $02,x	                sta 2,x         ; NOS
.a2e0	a5 39		lda $39		                lda scratch+3
.a2e2	95 03		sta $03,x	                sta 3,x
.a2e4	a5 18		lda $18		                lda base
.a2e6	95 00		sta $00,x	                sta 0,x         ; TOS
.a2e8	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a2ea	20 ed a5	jsr $a5ed	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2ed	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2ef	85 3c		sta $3c		                sta scratch+6
.a2f1	b5 03		lda $03,x	                lda 3,x
.a2f3	85 3d		sta $3d		                sta scratch+7
.a2f5	a5 36		lda $36		                lda scratch
.a2f7	95 02		sta $02,x	                sta 2,x
.a2f9	a5 37		lda $37		                lda scratch+1
.a2fb	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a2fd	a5 18		lda $18		                lda base
.a2ff	95 00		sta $00,x	                sta 0,x
.a301	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a303	20 ed a5	jsr $a5ed	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a306	b5 00		lda $00,x	                lda 0,x
.a308	85 38		sta $38		                sta scratch+2
.a30a	b5 01		lda $01,x	                lda 1,x
.a30c	85 39		sta $39		                sta scratch+3
.a30e	b5 02		lda $02,x	                lda 2,x
.a310	85 36		sta $36		                sta scratch
.a312	b5 03		lda $03,x	                lda 3,x
.a314	85 37		sta $37		                sta scratch+1
.a316	18		clc		                clc
.a317	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a319	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a31b	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a31d	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a31f	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a321	85 37		sta $37		                sta scratch+1
.a323	a5 38		lda $38		                lda scratch+2   ; LSB
.a325	65 3c		adc $3c		                adc scratch+6
.a327	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a329	a5 39		lda $39		                lda scratch+3   ; MSB
.a32b	65 3d		adc $3d		                adc scratch+7
.a32d	85 39		sta $39		                sta scratch+3
.a32f	e8		inx		                inx
.a330	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a331	f6 04		inc $04,x	                inc 4,x
.a333	d0 02		bne $a337	                bne +
.a335	f6 05		inc $05,x	                inc 5,x
.a337					+
.a337	d6 02		dec $02,x	                dec 2,x
.a339	d0 88		bne $a2c3	                bne _loop
.a33b					_done:
.a33b	e8		inx		                inx
.a33c	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a33d	a5 36		lda $36		                lda scratch     ; new ud-lo
.a33f	95 06		sta $06,x	                sta 6,x
.a341	a5 37		lda $37		                lda scratch+1
.a343	95 07		sta $07,x	                sta 7,x
.a345	a5 38		lda $38		                lda scratch+2
.a347	95 04		sta $04,x	                sta 4,x
.a349	a5 39		lda $39		                lda scratch+3
.a34b	95 05		sta $05,x	                sta 5,x
.a34d	60		rts		z_to_number:    rts
.a34e					xt_to_order:
.a34e	20 61 a3	jsr $a361	                jsr xt_to_r
.a351	20 25 91	jsr $9125	                jsr xt_get_order
.a354	20 83 9a	jsr $9a83	                jsr xt_r_from
.a357	20 9f a1	jsr $a19f	                jsr xt_swap
.a35a	20 0e 98	jsr $980e	                jsr xt_one_plus
.a35d	20 0c 9d	jsr $9d0c	                jsr xt_set_order
.a360	60		rts		z_to_order:     rts
.a361					xt_to_r:
.a361	68		pla		                pla             ; LSB
.a362	85 2c		sta $2c		                sta tmptos
.a364	7a		ply		                ply             ; MSB
.a365	20 0c d9	jsr $d90c	                jsr underflow_1
.a368	b5 01		lda $01,x	                lda 1,x         ; MSB
.a36a	48		pha		                pha
.a36b	b5 00		lda $00,x	                lda 0,x         ; LSB
.a36d	48		pha		                pha
.a36e	e8		inx		                inx
.a36f	e8		inx		                inx
.a370	5a		phy		                phy             ; MSB
.a371	a5 2c		lda $2c		                lda tmptos
.a373	48		pha		                pha             ; LSB
.a374	60		rts		z_to_r:         rts
.a375					xt_true:
.a375	ca		dex		                dex
.a376	ca		dex		                dex
.a377	a9 ff		lda #$ff	                lda #$FF
.a379	95 00		sta $00,x	                sta 0,x
.a37b	95 01		sta $01,x	                sta 1,x
.a37d	60		rts		z_true:         rts
.a37e					xt_tuck:
.a37e	20 11 d9	jsr $d911	                jsr underflow_2
.a381	ca		dex		                dex
.a382	ca		dex		                dex
.a383	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a385	b5 02		lda $02,x	                lda 2,x
.a387	95 04		sta $04,x	                sta 4,x
.a389	94 02		sty $02,x	                sty 2,x
.a38b	95 00		sta $00,x	                sta 0,x
.a38d	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a38f	b5 03		lda $03,x	                lda 3,x
.a391	95 05		sta $05,x	                sta 5,x
.a393	94 03		sty $03,x	                sty 3,x         ; bba
.a395	95 01		sta $01,x	                sta 1,x         ; baa
.a397	60		rts		z_tuck:         rts
.a398					xt_assembler_wordlist:
.a398					xt_two:
.a398	ca		dex		                dex
.a399	ca		dex		                dex
.a39a	a9 02		lda #$02	                lda #2
.a39c	95 00		sta $00,x	                sta 0,x
.a39e	74 01		stz $01,x	                stz 1,x
.a3a0					z_assembler_wordlist:
.a3a0	60		rts		z_two:          rts
.a3a1					xt_two_drop:
.a3a1	20 11 d9	jsr $d911	                jsr underflow_2
.a3a4	e8		inx		                inx
.a3a5	e8		inx		                inx
.a3a6	e8		inx		                inx
.a3a7	e8		inx		                inx
.a3a8	60		rts		z_two_drop:     rts
.a3a9					xt_two_dup:
.a3a9	20 11 d9	jsr $d911	                jsr underflow_2
.a3ac	ca		dex		                dex
.a3ad	ca		dex		                dex
.a3ae	ca		dex		                dex
.a3af	ca		dex		                dex
.a3b0	b5 04		lda $04,x	                lda 4,x         ; TOS
.a3b2	95 00		sta $00,x	                sta 0,x
.a3b4	b5 05		lda $05,x	                lda 5,x
.a3b6	95 01		sta $01,x	                sta 1,x
.a3b8	b5 06		lda $06,x	                lda 6,x         ; NOS
.a3ba	95 02		sta $02,x	                sta 2,x
.a3bc	b5 07		lda $07,x	                lda 7,x
.a3be	95 03		sta $03,x	                sta 3,x
.a3c0	60		rts		z_two_dup:      rts
.a3c1					xt_two_fetch:
.a3c1	20 0c d9	jsr $d90c	                jsr underflow_1
.a3c4	b5 00		lda $00,x	                lda 0,x
.a3c6	85 24		sta $24		                sta tmp1
.a3c8	b4 01		ldy $01,x	                ldy 1,x
.a3ca	84 25		sty $25		                sty tmp1+1
.a3cc	ca		dex		                dex             ; reuse one stack element
.a3cd	ca		dex		                dex
.a3ce	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a3d0	95 00		sta $00,x	                sta 0,x
.a3d2	a0 01		ldy #$01	                ldy #1          ; copy next
.a3d4	b1 24		lda ($24),y	                lda (tmp1),y
.a3d6	95 01		sta $01,x	                sta 1,x
.a3d8	c8		iny		                iny             ; copy next
.a3d9	b1 24		lda ($24),y	                lda (tmp1),y
.a3db	95 02		sta $02,x	                sta 2,x
.a3dd	c8		iny		                iny             ; copy next
.a3de	b1 24		lda ($24),y	                lda (tmp1),y
.a3e0	95 03		sta $03,x	                sta 3,x
.a3e2	60		rts		z_two_fetch:    rts
.a3e3					xt_two_over:
.a3e3	20 1b d9	jsr $d91b	                jsr underflow_4
.a3e6	ca		dex		                dex
.a3e7	ca		dex		                dex
.a3e8	ca		dex		                dex
.a3e9	ca		dex		                dex
.a3ea	b5 08		lda $08,x	                lda 8,x
.a3ec	95 00		sta $00,x	                sta 0,x
.a3ee	b5 09		lda $09,x	                lda 9,x
.a3f0	95 01		sta $01,x	                sta 1,x
.a3f2	b5 0a		lda $0a,x	                lda 10,x
.a3f4	95 02		sta $02,x	                sta 2,x
.a3f6	b5 0b		lda $0b,x	                lda 11,x
.a3f8	95 03		sta $03,x	                sta 3,x
.a3fa	60		rts		z_two_over:     rts
.a3fb					xt_two_r_fetch:
.a3fb	ca		dex		                dex
.a3fc	ca		dex		                dex
.a3fd	ca		dex		                dex
.a3fe	ca		dex		                dex
.a3ff	8a		txa		                txa
.a400	ba		tsx		                tsx
.a401	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a402	7a		ply		                ply
.a403	aa		tax		                tax
.a404	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a407	95 00		sta $00,x	                sta 0,x
.a409	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a40c	95 01		sta $01,x	                sta 1,x
.a40e	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a411	95 02		sta $02,x	                sta 2,x
.a413	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a416	95 03		sta $03,x	                sta 3,x
.a418	60		rts		z_two_r_fetch:  rts
.a419					xt_two_r_from:
.a419	68		pla		                pla                     ; LSB
.a41a	85 24		sta $24		                sta tmp1
.a41c	68		pla		                pla                     ; MSB
.a41d	85 25		sta $25		                sta tmp1+1
.a41f	ca		dex		                dex
.a420	ca		dex		                dex
.a421	ca		dex		                dex
.a422	ca		dex		                dex
.a423	68		pla		                pla                     ; LSB
.a424	95 00		sta $00,x	                sta 0,x
.a426	68		pla		                pla                     ; MSB
.a427	95 01		sta $01,x	                sta 1,x
.a429	68		pla		                pla                     ; LSB
.a42a	95 02		sta $02,x	                sta 2,x
.a42c	68		pla		                pla                     ; MSB
.a42d	95 03		sta $03,x	                sta 3,x
.a42f	a5 25		lda $25		                lda tmp1+1              ; MSB
.a431	48		pha		                pha
.a432	a5 24		lda $24		                lda tmp1                ; LSB
.a434	48		pha		                pha
.a435	60		rts		z_two_r_from:   rts
.a436					xt_two_slash:
.a436	20 0c d9	jsr $d90c	                jsr underflow_1
.a439	b5 01		lda $01,x	                lda 1,x
.a43b	0a		asl a		                asl                     ; save the sign
.a43c	76 01		ror $01,x	                ror 1,x
.a43e	76 00		ror $00,x	                ror 0,x
.a440	60		rts		z_two_slash:    rts
.a441					xt_two_star:
.a441					xt_cells:
.a441	20 0c d9	jsr $d90c	                jsr underflow_1
.a444	16 00		asl $00,x	                asl 0,x
.a446	36 01		rol $01,x	                rol 1,x
.a448					z_cells:
.a448	60		rts		z_two_star:     rts
.a449					xt_two_store:
.a449	20 16 d9	jsr $d916	                jsr underflow_3
.a44c	b5 00		lda $00,x	                lda 0,x
.a44e	85 24		sta $24		                sta tmp1
.a450	b4 01		ldy $01,x	                ldy 1,x
.a452	84 25		sty $25		                sty tmp1+1
.a454	e8		inx		                inx
.a455	e8		inx		                inx
.a456	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a458	92 24		sta ($24)	                sta (tmp1)
.a45a	b5 01		lda $01,x	                lda 1,x         ; copy next
.a45c	a0 01		ldy #$01	                ldy #1
.a45e	91 24		sta ($24),y	                sta (tmp1),y
.a460	b5 02		lda $02,x	                lda 2,x         ; copy next
.a462	c8		iny		                iny
.a463	91 24		sta ($24),y	                sta (tmp1),y
.a465	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a467	c8		iny		                iny
.a468	91 24		sta ($24),y	                sta (tmp1),y
.a46a	e8		inx		                inx             ; 2DROP
.a46b	e8		inx		                inx
.a46c	e8		inx		                inx
.a46d	e8		inx		                inx
.a46e	60		rts		z_two_store:    rts
.a46f					xt_two_swap:
.a46f	20 1b d9	jsr $d91b	                jsr underflow_4
.a472	b5 00		lda $00,x	                lda 0,x
.a474	b4 04		ldy $04,x	                ldy 4,x
.a476	95 04		sta $04,x	                sta 4,x
.a478	94 00		sty $00,x	                sty 0,x
.a47a	b5 01		lda $01,x	                lda 1,x
.a47c	b4 05		ldy $05,x	                ldy 5,x
.a47e	95 05		sta $05,x	                sta 5,x
.a480	94 01		sty $01,x	                sty 1,x
.a482	b5 02		lda $02,x	                lda 2,x
.a484	b4 06		ldy $06,x	                ldy 6,x
.a486	95 06		sta $06,x	                sta 6,x
.a488	94 02		sty $02,x	                sty 2,x
.a48a	b5 03		lda $03,x	                lda 3,x
.a48c	b4 07		ldy $07,x	                ldy 7,x
.a48e	95 07		sta $07,x	                sta 7,x
.a490	94 03		sty $03,x	                sty 3,x
.a492	60		rts		z_two_swap:     rts
.a493					xt_two_to_r:
.a493	68		pla		                pla             ; LSB
.a494	85 24		sta $24		                sta tmp1
.a496	68		pla		                pla             ; MSB
.a497	85 25		sta $25		                sta tmp1+1
.a499	20 11 d9	jsr $d911	                jsr underflow_2
.a49c	b5 03		lda $03,x	                lda 3,x         ; MSB
.a49e	48		pha		                pha
.a49f	b5 02		lda $02,x	                lda 2,x         ; LSB
.a4a1	48		pha		                pha
.a4a2	b5 01		lda $01,x	                lda 1,x         ; MSB
.a4a4	48		pha		                pha
.a4a5	b5 00		lda $00,x	                lda 0,x         ; LSB
.a4a7	48		pha		                pha
.a4a8	e8		inx		                inx
.a4a9	e8		inx		                inx
.a4aa	e8		inx		                inx
.a4ab	e8		inx		                inx
.a4ac	a5 25		lda $25		                lda tmp1+1      ; MSB
.a4ae	48		pha		                pha
.a4af	a5 24		lda $24		                lda tmp1        ; LSB
.a4b1	48		pha		                pha
.a4b2	60		rts		z_two_to_r:     rts
.a4b3					xt_two_constant:
.a4b3	20 11 d9	jsr $d911	                jsr underflow_2
.a4b6	20 5a 89	jsr $895a	                jsr xt_create
.a4b9	20 9f a1	jsr $a19f	                jsr xt_swap
.a4bc	20 5f 87	jsr $875f	                jsr xt_comma
.a4bf	20 5f 87	jsr $875f	                jsr xt_comma
.a4c2	20 f5 8b	jsr $8bf5	                jsr does_runtime    ; does> turns into these two routines.
.a4c5	20 f5 d7	jsr $d7f5	                jsr dodoes
.a4c8	20 a0 8d	jsr $8da0	                jsr xt_dup
.a4cb	20 71 8f	jsr $8f71	                jsr xt_fetch
.a4ce	20 9f a1	jsr $a19f	                jsr xt_swap
.a4d1	20 12 86	jsr $8612	                jsr xt_cell_plus
.a4d4	20 71 8f	jsr $8f71	                jsr xt_fetch
.a4d7	60		rts		z_two_constant: rts
.a4d8					xt_two_literal:
.a4d8	20 11 d9	jsr $d911	                jsr underflow_2 ; double number
.a4db	20 9f a1	jsr $a19f	                jsr xt_swap
.a4de	20 7b 93	jsr $937b	                jsr xt_literal
.a4e1	20 7b 93	jsr $937b	                jsr xt_literal
.a4e4	60		rts		z_two_literal:  rts
.a4e5					xt_two_variable:
.a4e5	20 5a 89	jsr $895a	                jsr xt_create
.a4e8	ca		dex		                dex
.a4e9	ca		dex		                dex
.a4ea	a9 04		lda #$04	                lda #4
.a4ec	95 00		sta $00,x	                sta 0,x
.a4ee	74 01		stz $01,x	                stz 1,x
.a4f0	20 9c 82	jsr $829c	                jsr xt_allot
.a4f3	60		rts		z_two_variable: rts
.a4f4					xt_type:
.a4f4	20 11 d9	jsr $d911	                jsr underflow_2
.a4f7	b5 02		lda $02,x	                lda 2,x
.a4f9	85 24		sta $24		                sta tmp1
.a4fb	b5 03		lda $03,x	                lda 3,x
.a4fd	85 25		sta $25		                sta tmp1+1
.a4ff					_loop:
.a4ff	b5 00		lda $00,x	                lda 0,x
.a501	15 01		ora $01,x	                ora 1,x
.a503	f0 15		beq $a51a	                beq _done
.a505	b2 24		lda ($24)	                lda (tmp1)
.a507	20 e7 8d	jsr $8de7	                jsr emit_a      ; avoids stack foolery
.a50a	e6 24		inc $24		                inc tmp1
.a50c	d0 02		bne $a510	                bne +
.a50e	e6 25		inc $25		                inc tmp1+1
.a510					+
.a510	b5 00		lda $00,x	                lda 0,x
.a512	d0 02		bne $a516	                bne +
.a514	d6 01		dec $01,x	                dec 1,x
.a516					+
.a516	d6 00		dec $00,x	                dec 0,x
.a518	80 e5		bra $a4ff	                bra _loop
.a51a					_done:
.a51a	e8		inx		                inx
.a51b	e8		inx		                inx
.a51c	e8		inx		                inx
.a51d	e8		inx		                inx
.a51e	60		rts		z_type:         rts
.a51f					xt_u_dot:
.a51f	20 0c d9	jsr $d90c	                jsr underflow_1
.a522	20 79 d9	jsr $d979	                jsr print_u
.a525	a9 20		lda #$20	                lda #AscSP
.a527	20 e7 8d	jsr $8de7	                jsr emit_a
.a52a	60		rts		z_u_dot:        rts
.a52b					xt_u_dot_r:
.a52b	20 11 d9	jsr $d911	                jsr underflow_2
.a52e	20 61 a3	jsr $a361	                jsr xt_to_r
.a531	20 99 a7	jsr $a799	                jsr xt_zero
.a534	20 4b 93	jsr $934b	                jsr xt_less_number_sign
.a537	20 cf 97	jsr $97cf	                jsr xt_number_sign_s
.a53a	20 ad 97	jsr $97ad	                jsr xt_number_sign_greater
.a53d	20 83 9a	jsr $9a83	                jsr xt_r_from
.a540	20 84 98	jsr $9884	                jsr xt_over
.a543	20 41 95	jsr $9541	                jsr xt_minus
.a546	20 15 a1	jsr $a115	                jsr xt_spaces
.a549	20 f4 a4	jsr $a4f4	                jsr xt_type
.a54c	60		rts		z_u_dot_r:      rts
.a54d					xt_u_greater_than:
.a54d	20 11 d9	jsr $d911	                jsr underflow_2
.a550	b5 00		lda $00,x	                lda 0,x
.a552	d5 02		cmp $02,x	                cmp 2,x
.a554	b5 01		lda $01,x	                lda 1,x
.a556	f5 03		sbc $03,x	                sbc 3,x
.a558	e8		inx		                inx
.a559	e8		inx		                inx
.a55a	a9 00		lda #$00	                lda #0
.a55c	69 ff		adc #$ff	                adc #$ff
.a55e	95 00		sta $00,x	                sta 0,x         ; store flag
.a560	95 01		sta $01,x	                sta 1,x
.a562	60		rts		z_u_greater_than:    rts
.a563					xt_u_less_than:
.a563	20 11 d9	jsr $d911	                jsr underflow_2
.a566	b5 02		lda $02,x	                lda 2,x
.a568	d5 00		cmp $00,x	                cmp 0,x
.a56a	b5 03		lda $03,x	                lda 3,x
.a56c	f5 01		sbc $01,x	                sbc 1,x
.a56e	e8		inx		                inx
.a56f	e8		inx		                inx
.a570	a9 00		lda #$00	                lda #0
.a572	69 ff		adc #$ff	                adc #$ff
.a574	95 00		sta $00,x	                sta 0,x         ; store flag
.a576	95 01		sta $01,x	                sta 1,x
.a578	60		rts		z_u_less_than:    rts
.a579					xt_ud_dot:
.a579	20 11 d9	jsr $d911	                jsr underflow_2 ; double number
.a57c	20 4b 93	jsr $934b	                jsr xt_less_number_sign
.a57f	20 cf 97	jsr $97cf	                jsr xt_number_sign_s
.a582	20 ad 97	jsr $97ad	                jsr xt_number_sign_greater
.a585	20 f4 a4	jsr $a4f4	                jsr xt_type
.a588	20 0f a1	jsr $a10f	                jsr xt_space
.a58b	60		rts		z_ud_dot:        rts
.a58c					xt_ud_dot_r:
.a58c	20 16 d9	jsr $d916	                jsr underflow_3
.a58f	20 61 a3	jsr $a361	                jsr xt_to_r
.a592	20 4b 93	jsr $934b	                jsr xt_less_number_sign
.a595	20 cf 97	jsr $97cf	                jsr xt_number_sign_s
.a598	20 ad 97	jsr $97ad	                jsr xt_number_sign_greater
.a59b	20 83 9a	jsr $9a83	                jsr xt_r_from
.a59e	20 84 98	jsr $9884	                jsr xt_over
.a5a1	20 41 95	jsr $9541	                jsr xt_minus
.a5a4	20 15 a1	jsr $a115	                jsr xt_spaces
.a5a7	20 f4 a4	jsr $a4f4	                jsr xt_type
.a5aa	60		rts		z_ud_dot_r:      rts
.a5ab					xt_um_slash_mod:
.a5ab	20 16 d9	jsr $d916	                jsr underflow_3
.a5ae	b5 00		lda $00,x	                lda 0,x
.a5b0	15 01		ora $01,x	                ora 1,x
.a5b2	d0 05		bne $a5b9	                bne _not_zero
.a5b4	a9 04		lda #$04	                lda #err_divzero
.a5b6	4c 22 d9	jmp $d922	                jmp error
.a5b9					_not_zero:
.a5b9	a9 11		lda #$11	                lda #17
.a5bb	85 2c		sta $2c		                sta tmptos
.a5bd					_loop:
.a5bd	36 04		rol $04,x	                rol 4,x
.a5bf	36 05		rol $05,x	                rol 5,x
.a5c1	c6 2c		dec $2c		                dec tmptos
.a5c3	f0 22		beq $a5e7	                beq _done
.a5c5	36 02		rol $02,x	                rol 2,x
.a5c7	36 03		rol $03,x	                rol 3,x
.a5c9	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a5cb	26 24		rol $24		                rol tmp1
.a5cd	38		sec		                sec
.a5ce	b5 02		lda $02,x	                lda 2,x
.a5d0	f5 00		sbc $00,x	                sbc 0,x
.a5d2	85 25		sta $25		                sta tmp1+1
.a5d4	b5 03		lda $03,x	                lda 3,x
.a5d6	f5 01		sbc $01,x	                sbc 1,x
.a5d8	a8		tay		                tay
.a5d9	a5 24		lda $24		                lda tmp1
.a5db	e9 00		sbc #$00	                sbc #0
.a5dd	90 de		bcc $a5bd	                bcc _loop
.a5df	a5 25		lda $25		                lda tmp1+1
.a5e1	95 02		sta $02,x	                sta 2,x
.a5e3	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a5e5	80 d6		bra $a5bd	                bra _loop
.a5e7					_done:
.a5e7	e8		inx		                inx
.a5e8	e8		inx		                inx
.a5e9	20 9f a1	jsr $a19f	                jsr xt_swap
.a5ec	60		rts		z_um_slash_mod: rts
.a5ed					xt_um_star:
.a5ed	20 11 d9	jsr $d911	                jsr underflow_2
.a5f0	18		clc		                clc
.a5f1	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a5f3	e9 00		sbc #$00	                sbc #0
.a5f5	85 26		sta $26		                sta tmp2
.a5f7	b5 01		lda $01,x	                lda 1,x
.a5f9	e9 00		sbc #$00	                sbc #0
.a5fb	90 31		bcc $a62e	                bcc _zero       ; is TOS zero?
.a5fd	85 27		sta $27		                sta tmp2+1
.a5ff	a9 00		lda #$00	                lda #0
.a601	85 24		sta $24		                sta tmp1
.a603	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a605	ca		dex		                dex
.a606	ca		dex		                dex
.a607					_outer_loop:
.a607	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a609	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a60b					_inner_loop:
.a60b	90 0c		bcc $a619	                bcc _no_add
.a60d	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a60f	a5 24		lda $24		                lda tmp1
.a611	65 26		adc $26		                adc tmp2
.a613	85 24		sta $24		                sta tmp1
.a615	a5 25		lda $25		                lda tmp1+1
.a617	65 27		adc $27		                adc tmp2+1
.a619					_no_add:
.a619	6a		ror a		                ror
.a61a	66 24		ror $24		                ror tmp1
.a61c	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a61e	88		dey		                dey
.a61f	d0 ea		bne $a60b	                bne _inner_loop ; go back for one more shift?
.a621	e8		inx		                inx
.a622	e4 28		cpx $28		                cpx tmp3
.a624	d0 e1		bne $a607	                bne _outer_loop ; go back for eight more shifts?
.a626	95 01		sta $01,x	                sta 1,x
.a628	a5 24		lda $24		                lda tmp1
.a62a	95 00		sta $00,x	                sta 0,x
.a62c	80 04		bra $a632	                bra _done
.a62e					_zero:
.a62e	74 02		stz $02,x	                stz 2,x
.a630	74 03		stz $03,x	                stz 3,x
.a632					_done:
.a632	60		rts		z_um_star:      rts
.a633					xt_unloop:
.a633	68		pla		                pla
.a634	68		pla		                pla
.a635	68		pla		                pla
.a636	68		pla		                pla
.a637	68		pla		                pla
.a638	68		pla		                pla
.a639	60		rts		z_unloop:       rts
.a63a					xt_until:
.a63a	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a63c	a9 05		lda #$05	                lda #<zero_branch_runtime
.a63e	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.a641	20 5f 87	jsr $875f	                jsr xt_comma
.a644	60		rts		z_until:        rts
.a645					xt_unused:
.a645	ca		dex		                dex
.a646	ca		dex		                dex
.a647	a9 00		lda #$00	                lda #<cp_end
.a649	38		sec		                sec
.a64a	e5 00		sbc $00		                sbc cp
.a64c	95 00		sta $00,x	                sta 0,x
.a64e	a9 7c		lda #$7c	                lda #>cp_end
.a650	e5 01		sbc $01		                sbc cp+1
.a652	95 01		sta $01,x	                sta 1,x
.a654	60		rts		z_unused:       rts
.a655					xt_update:
.a655	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a657	b1 1e		lda ($1e),y	                lda (up),y
.a659	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a65b	91 1e		sta ($1e),y	                sta (up),y
.a65d	60		rts		z_update:       rts
.a65e					xt_useraddr:
.a65e	ca		dex		                dex
.a65f	ca		dex		                dex
.a660	a9 1e		lda #$1e	                lda #<up
.a662	95 00		sta $00,x	                sta 0,x
.a664	a9 00		lda #$00	                lda #>up
.a666	95 01		sta $01,x	                sta 1,x
.a668	60		rts		z_useraddr:     rts
.a669					xt_variable:
.a669	20 5a 89	jsr $895a	                jsr xt_create
.a66c	a9 00		lda #$00	                lda #0
.a66e	92 00		sta ($00)	                sta (cp)
.a670	e6 00		inc $00		                inc cp
.a672	d0 02		bne $a676	                bne +
.a674	e6 01		inc $01		                inc cp+1
.a676					+
.a676	92 00		sta ($00)	                sta (cp)
.a678	e6 00		inc $00		                inc cp
.a67a	d0 02		bne $a67e	                bne +
.a67c	e6 01		inc $01		                inc cp+1
.a67e					+
.a67e	20 22 89	jsr $8922	                jsr adjust_z
.a681	60		rts		z_variable:     rts
.a682					xt_while:
.a682	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a684	a9 05		lda #$05	                lda #<zero_branch_runtime
.a686	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.a689	20 63 91	jsr $9163	                jsr xt_here
.a68c	20 99 a7	jsr $a799	                jsr xt_zero
.a68f	20 5f 87	jsr $875f	                jsr xt_comma
.a692	20 9f a1	jsr $a19f	                jsr xt_swap
.a695	60		rts		z_while:        rts
.a696					xt_within:
.a696	20 16 d9	jsr $d916	                jsr underflow_3
.a699	20 84 98	jsr $9884	                jsr xt_over
.a69c	20 41 95	jsr $9541	                jsr xt_minus
.a69f	20 61 a3	jsr $a361	                jsr xt_to_r
.a6a2	20 41 95	jsr $9541	                jsr xt_minus
.a6a5	20 83 9a	jsr $9a83	                jsr xt_r_from
.a6a8	20 63 a5	jsr $a563	                jsr xt_u_less_than
.a6ab	60		rts		z_within:       rts
.a6ac					xt_word:
.a6ac	20 0c d9	jsr $d90c	                jsr underflow_1
.a6af	a4 0c		ldy $0c		                ldy toin                ; >IN
.a6b1					_loop:
.a6b1	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a6b3	f0 09		beq $a6be	                beq _found_char
.a6b5	b1 08		lda ($08),y	                lda (cib),y
.a6b7	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a6b9	d0 03		bne $a6be	                bne _found_char
.a6bb	c8		iny		                iny
.a6bc	80 f3		bra $a6b1	                bra _loop
.a6be					_found_char:
.a6be	84 0c		sty $0c		                sty toin
.a6c0	20 2b 99	jsr $992b	                jsr xt_parse            ; Returns ( addr u )
.a6c3	b5 00		lda $00,x	                lda 0,x
.a6c5	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a6c7	48		pha		                pha                     ; Keep copy of length for later
.a6c8	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( addr u u )
.a6cb	a5 00		lda $00		                lda cp
.a6cd	18		clc		                clc
.a6ce	69 01		adc #$01	                adc #1
.a6d0	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a6d2	a5 01		lda $01		                lda cp+1
.a6d4	69 00		adc #$00	                adc #0
.a6d6	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a6d8	20 b3 95	jsr $95b3	                jsr xt_move
.a6db	ca		dex		                dex
.a6dc	ca		dex		                dex
.a6dd	a5 00		lda $00		                lda cp
.a6df	95 00		sta $00,x	                sta 0,x
.a6e1	a5 01		lda $01		                lda cp+1
.a6e3	95 01		sta $01,x	                sta 1,x
.a6e5	68		pla		                pla                     ; length of string
.a6e6	18		clc		                clc
.a6e7	65 00		adc $00		                adc cp
.a6e9	85 00		sta $00		                sta cp
.a6eb	a5 01		lda $01		                lda cp+1
.a6ed	69 00		adc #$00	                adc #0                  ; we only need the carry
.a6ef	85 01		sta $01		                sta cp+1
.a6f1	60		rts		z_word:         rts
.a6f2					xt_wordlist:
.a6f2	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a6f4	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a6f6	c9 0c		cmp #$0c	                cmp #max_wordlists
.a6f8	d0 05		bne $a6ff	                bne _ok
.a6fa	a9 0b		lda #$0b	                lda #err_wordlist
.a6fc	4c 22 d9	jmp $d922	                jmp error
.a6ff					_ok:
.a6ff	1a		inc a		                ina             ; Increment the wordlist#
.a700	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a702	ca		dex		                dex             ; and put it on the stack.
.a703	ca		dex		                dex
.a704	95 00		sta $00,x	                sta 0,x
.a706	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a708	60		rts		z_wordlist:     rts
.a709					xt_words:
.a709	20 54 89	jsr $8954	                jsr xt_cr
.a70c	a9 00		lda #$00	                lda #0
.a70e	48		pha		                pha
.a70f	ca		dex		                dex                     ; Make room on the stack for
.a710	ca		dex		                dex                     ; a dictionary pointer.
.a711	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a713					_wordlist_loop:
.a713	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a715	a5 28		lda $28		                lda tmp3
.a717	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a719	d0 02		bne $a71d	                bne _have_wordlist
.a71b	80 45		bra $a762	                bra _words_done
.a71d					_have_wordlist:
.a71d	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a71e	69 1f		adc #$1f	                adc #search_order_offset
.a720	a8		tay		                tay
.a721	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a723	0a		asl a		                asl                     ; Turn offset into cells offset.
.a724	18		clc		                clc
.a725	69 06		adc #$06	                adc #wordlists_offset
.a727	a8		tay		                tay
.a728	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a72a	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a72c	c8		iny		                iny
.a72d	b1 1e		lda ($1e),y	                lda (up),y
.a72f	95 01		sta $01,x	                sta 1,x
.a731					_loop:
.a731	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( nt nt )
.a734	20 ef 95	jsr $95ef	                jsr xt_name_to_string   ; ( nt addr u )
.a737	68		pla		                pla
.a738	18		clc		                clc
.a739	75 00		adc $00,x	                adc 0,x
.a73b	1a		inc a		                ina                     ; don't forget the space between words
.a73c	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a73e	90 06		bcc $a746	                bcc +
.a740	20 54 89	jsr $8954	                jsr xt_cr
.a743	b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a745	1a		inc a		                ina                     ; with length of this word.
.a746					+
.a746	48		pha		                pha
.a747	20 f4 a4	jsr $a4f4	                jsr xt_type             ; ( nt )
.a74a	a9 20		lda #$20	                lda #AscSP
.a74c	20 e7 8d	jsr $8de7	                jsr emit_a
.a74f	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+
.a752	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+
.a755	20 71 8f	jsr $8f71	                jsr xt_fetch            ; @ ( nt+1 )
.a758	b5 00		lda $00,x	                lda 0,x
.a75a	15 01		ora $01,x	                ora 1,x
.a75c	d0 d3		bne $a731	                bne _loop
.a75e	e6 28		inc $28		                inc tmp3
.a760	80 b1		bra $a713	                bra _wordlist_loop
.a762					_words_done:
.a762	68		pla		                pla                     ; dump counter
.a763	e8		inx		                inx
.a764	e8		inx		                inx
.a765	60		rts		z_words:        rts
.a766					xt_wordsize:
.a766	20 0c d9	jsr $d90c	                jsr underflow_1
.a769	b5 00		lda $00,x	                lda 0,x
.a76b	85 24		sta $24		                sta tmp1
.a76d	b5 01		lda $01,x	                lda 1,x
.a76f	85 25		sta $25		                sta tmp1+1
.a771	a0 06		ldy #$06	                ldy #6
.a773	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a775	88		dey		                dey
.a776	88		dey		                dey
.a777	38		sec		                sec
.a778	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a77a	95 00		sta $00,x	                sta 0,x
.a77c	a0 07		ldy #$07	                ldy #7
.a77e	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a780	88		dey		                dey
.a781	88		dey		                dey
.a782	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a784	95 01		sta $01,x	                sta 1,x
.a786	60		rts		z_wordsize:     rts
.a787					xt_xor:
.a787	20 11 d9	jsr $d911	                jsr underflow_2
.a78a	b5 00		lda $00,x	                lda 0,x
.a78c	55 02		eor $02,x	                eor 2,x
.a78e	95 02		sta $02,x	                sta 2,x
.a790	b5 01		lda $01,x	                lda 1,x
.a792	55 03		eor $03,x	                eor 3,x
.a794	95 03		sta $03,x	                sta 3,x
.a796	e8		inx		                inx
.a797	e8		inx		                inx
.a798	60		rts		z_xor:          rts
.a799					xt_case:
.a799					xt_forth_wordlist:
.a799					xt_zero:
.a799	ca		dex		                dex             ; push
.a79a	ca		dex		                dex
.a79b	74 00		stz $00,x	                stz 0,x
.a79d	74 01		stz $01,x	                stz 1,x
.a79f					z_case:
.a79f					z_forth_wordlist:
.a79f					z_zero:
.a79f	60		rts		                rts
.a7a0					xt_zero_equal:
.a7a0	20 0c d9	jsr $d90c	                jsr underflow_1
.a7a3	b5 00		lda $00,x	                lda 0,x
.a7a5	15 01		ora $01,x	                ora 1,x
.a7a7	f0 04		beq $a7ad	                beq _zero
.a7a9	a9 00		lda #$00	                lda #0
.a7ab	80 02		bra $a7af	                bra _store
.a7ad					_zero:
.a7ad	a9 ff		lda #$ff	                lda #$ff
.a7af					_store:
.a7af	95 00		sta $00,x	                sta 0,x
.a7b1	95 01		sta $01,x	                sta 1,x
.a7b3	60		rts		z_zero_equal:   rts
.a7b4					xt_zero_greater:
.a7b4	20 0c d9	jsr $d90c	                jsr underflow_1
.a7b7	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a7b9	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7bb	30 05		bmi $a7c2	                bmi _done       ; TOS is negative, keep FLASE
.a7bd	15 00		ora $00,x	                ora 0,x
.a7bf	f0 01		beq $a7c2	                beq _done       ; TOS is zero, keep FALSE
.a7c1	88		dey		                dey             ; TOS is postive, make true
.a7c2					_done:
.a7c2	98		tya		                tya
.a7c3	95 00		sta $00,x	                sta 0,x
.a7c5	95 01		sta $01,x	                sta 1,x
.a7c7	60		rts		z_zero_greater: rts
.a7c8					xt_zero_less:
.a7c8	20 0c d9	jsr $d90c	                jsr underflow_1
.a7cb	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a7cd	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7cf	10 01		bpl $a7d2	                bpl _done       ; TOS is positive, so keep FALSE
.a7d1	88		dey		                dey             ; TOS is negative, make TRUE
.a7d2					_done:
.a7d2	98		tya		                tya
.a7d3	95 00		sta $00,x	                sta 0,x
.a7d5	95 01		sta $01,x	                sta 1,x
.a7d7	60		rts		z_zero_less:    rts
.a7d8					xt_zero_unequal:
.a7d8	20 0c d9	jsr $d90c	                jsr underflow_1
.a7db	a0 00		ldy #$00	                ldy #0          ; default false
.a7dd	b5 00		lda $00,x	                lda 0,x
.a7df	15 01		ora $01,x	                ora 1,x
.a7e1	f0 01		beq $a7e4	                beq _got_zero
.a7e3	88		dey		                dey
.a7e4					_got_zero:
.a7e4	98		tya		                tya
.a7e5	95 00		sta $00,x	                sta 0,x
.a7e7	95 01		sta $01,x	                sta 1,x
.a7e9	60		rts		z_zero_unequal: rts
.a7ea					xt_editor_screen_helper:
.a7ea	20 a0 8d	jsr $8da0	                jsr xt_dup
.a7ed	20 ca 9e	jsr $9eca	                jsr xt_scr
.a7f0	20 7e a1	jsr $a17e	                jsr xt_store
.a7f3	20 a6 85	jsr $85a6	                jsr xt_buffer
.a7f6					z_editor_screen_helper:
.a7f6	60		rts		                rts
.a7f7					xt_editor_enter_screen:
.a7f7	20 ea a7	jsr $a7ea	                jsr xt_editor_screen_helper
.a7fa	20 1f 8d	jsr $8d1f	                jsr xt_drop
.a7fd	64 2e		stz $2e		                stz editor1
.a7ff					_prompt_loop:
.a7ff	ca		dex		                dex
.a800	ca		dex		                dex
.a801	a5 2e		lda $2e		                lda editor1
.a803	95 00		sta $00,x	                sta 0,x
.a805	74 01		stz $01,x	                stz 1,x
.a807	20 cc a8	jsr $a8cc	                jsr xt_editor_o
.a80a	e6 2e		inc $2e		                inc editor1
.a80c	a9 10		lda #$10	                lda #16
.a80e	c5 2e		cmp $2e		                cmp editor1
.a810	d0 ed		bne $a7ff	                bne _prompt_loop
.a812					z_editor_enter_screen:
.a812	60		rts		                rts
.a813					xt_editor_erase_screen:
.a813	20 ea a7	jsr $a7ea	                jsr xt_editor_screen_helper
.a816	ca		dex		                dex
.a817	ca		dex		                dex
.a818	74 00		stz $00,x	                stz 0,x
.a81a	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a81c	95 01		sta $01,x	                sta 1,x
.a81e	20 db 8e	jsr $8edb	                jsr xt_blank
.a821	20 55 a6	jsr $a655	                jsr xt_update
.a824					z_editor_erase_screen:
.a824	60		rts		                rts
.a825					xt_editor_el:
.a825	20 b3 a8	jsr $a8b3	                jsr xt_editor_line
.a828	ca		dex		                dex
.a829	ca		dex		                dex
.a82a	a9 40		lda #$40	                lda #64
.a82c	95 00		sta $00,x	                sta 0,x
.a82e	74 01		stz $01,x	                stz 1,x
.a830	20 db 8e	jsr $8edb	                jsr xt_blank
.a833	20 55 a6	jsr $a655	                jsr xt_update
.a836	60		rts		z_editor_el:    rts
.a837					xt_editor_l:
.a837	ca		dex		                dex             ; Put SCR on the stack.
.a838	ca		dex		                dex
.a839	a0 02		ldy #$02	                ldy #scr_offset
.a83b	b1 1e		lda ($1e),y	                lda (up),y
.a83d	95 00		sta $00,x	                sta 0,x
.a83f	c8		iny		                iny
.a840	b1 1e		lda ($1e),y	                lda (up),y
.a842	95 01		sta $01,x	                sta 1,x
.a844	20 b2 83	jsr $83b2	                jsr xt_block    ; Get the current screen.
.a847	20 54 89	jsr $8954	                jsr xt_cr
.a84a	80 08		bra $a854	                bra _after_screen_msg
.a84c					_screen_msg:
>a84c	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a854					_after_screen_msg:
.a854	20 9a a0	jsr $a09a	                jsr sliteral_runtime
>a857	4c a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a85b	20 f4 a4	jsr $a4f4	                jsr xt_type
.a85e	20 ca 9e	jsr $9eca	                jsr xt_scr
.a861	20 71 8f	jsr $8f71	                jsr xt_fetch
.a864	ca		dex		                dex
.a865	ca		dex		                dex
.a866	a9 04		lda #$04	                lda #4          ; four spaces
.a868	95 00		sta $00,x	                sta 0,x
.a86a	74 01		stz $01,x	                stz 1,x
.a86c	20 2b a5	jsr $a52b	                jsr xt_u_dot_r
.a86f	64 28		stz $28		                stz tmp3
.a871					_line_loop:
.a871	20 54 89	jsr $8954	                jsr xt_cr
.a874	ca		dex		                dex
.a875	ca		dex		                dex
.a876	ca		dex		                dex
.a877	ca		dex		                dex
.a878	74 03		stz $03,x	                stz 3,x
.a87a	a5 28		lda $28		                lda tmp3
.a87c	95 02		sta $02,x	                sta 2,x
.a87e	74 01		stz $01,x	                stz 1,x
.a880	a9 02		lda #$02	                lda #2
.a882	95 00		sta $00,x	                sta 0,x
.a884	20 2b a5	jsr $a52b	                jsr xt_u_dot_r
.a887	20 0f a1	jsr $a10f	                jsr xt_space
.a88a	20 a0 8d	jsr $8da0	                jsr xt_dup
.a88d	ca		dex		                dex
.a88e	ca		dex		                dex
.a88f	a9 40		lda #$40	                lda #64
.a891	95 00		sta $00,x	                sta 0,x
.a893	74 01		stz $01,x	                stz 1,x
.a895	20 f4 a4	jsr $a4f4	                jsr xt_type
.a898	18		clc		                clc
.a899	a9 40		lda #$40	                lda #64
.a89b	75 00		adc $00,x	                adc 0,x
.a89d	95 00		sta $00,x	                sta 0,x
.a89f	b5 01		lda $01,x	                lda 1,x
.a8a1	69 00		adc #$00	                adc #0      ; Add carry
.a8a3	95 01		sta $01,x	                sta 1,x
.a8a5	e6 28		inc $28		                inc tmp3
.a8a7	a5 28		lda $28		                lda tmp3
.a8a9	c9 10		cmp #$10	                cmp #16
.a8ab	d0 c4		bne $a871	                bne _line_loop
.a8ad	20 54 89	jsr $8954	                jsr xt_cr
.a8b0	e8		inx		                inx
.a8b1	e8		inx		                inx
.a8b2	60		rts		z_editor_l:            rts
.a8b3					xt_editor_line:
.a8b3	20 0c d9	jsr $d90c	                jsr underflow_1
.a8b6	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a8b8					_shift_tos_left:
.a8b8	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a8ba	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a8bc	88		dey		                dey
.a8bd	d0 f9		bne $a8b8	                bne _shift_tos_left
.a8bf	20 ca 9e	jsr $9eca	                jsr xt_scr
.a8c2	20 71 8f	jsr $8f71	                jsr xt_fetch
.a8c5	20 b2 83	jsr $83b2	                jsr xt_block
.a8c8	20 d4 99	jsr $99d4	                jsr xt_plus
.a8cb	60		rts		z_editor_line:  rts
.a8cc					xt_editor_o:
.a8cc	20 54 89	jsr $8954	                jsr xt_cr
.a8cf	20 a0 8d	jsr $8da0	                jsr xt_dup
.a8d2	20 98 a3	jsr $a398	                jsr xt_two
.a8d5	20 2b a5	jsr $a52b	                jsr xt_u_dot_r
.a8d8	20 0f a1	jsr $a10f	                jsr xt_space
.a8db	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a8dd	20 e7 8d	jsr $8de7	                jsr emit_a
.a8e0	20 0f a1	jsr $a10f	                jsr xt_space
.a8e3	20 b3 a8	jsr $a8b3	                jsr xt_editor_line
.a8e6	20 a0 8d	jsr $8da0	                jsr xt_dup      ; Save a copy of the line address for later.
.a8e9	ca		dex		                dex
.a8ea	ca		dex		                dex
.a8eb	a9 40		lda #$40	                lda #64         ; chars/line
.a8ed	95 00		sta $00,x	                sta 0,x
.a8ef	74 01		stz $01,x	                stz 1,x
.a8f1	20 3f 81	jsr $813f	                jsr xt_accept
.a8f4	20 a0 8d	jsr $8da0	                jsr xt_dup
.a8f7	20 5f 96	jsr $965f	                jsr xt_not_rote ; -rot
.a8fa	20 d4 99	jsr $99d4	                jsr xt_plus
.a8fd	ca		dex		                dex
.a8fe	ca		dex		                dex
.a8ff	a9 40		lda #$40	                lda #64         ; chars/line
.a901	95 00		sta $00,x	                sta 0,x
.a903	74 01		stz $01,x	                stz 1,x
.a905	20 48 9b	jsr $9b48	                jsr xt_rot
.a908	20 41 95	jsr $9541	                jsr xt_minus
.a90b	20 db 8e	jsr $8edb	                jsr xt_blank
.a90e	20 55 a6	jsr $a655	                jsr xt_update
.a911	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a912					assembler:
.a912					xt_asm_adc_h:
.a912	a9 69		lda #$69	                lda #$69
.a914	4c 6d ac	jmp $ac6d	                jmp asm_common
.a917					z_asm_adc_h:
.a917					xt_asm_adc_x:
.a917	a9 7d		lda #$7d	                lda #$7D
.a919	4c 6d ac	jmp $ac6d	                jmp asm_common
.a91c					z_asm_adc_x:
.a91c					xt_asm_adc_y:
.a91c	a9 79		lda #$79	                lda #$79
.a91e	4c 6d ac	jmp $ac6d	                jmp asm_common
.a921					z_asm_adc_y:
.a921					xt_asm_adc_z:
.a921	a9 65		lda #$65	                lda #$65
.a923	4c 6d ac	jmp $ac6d	                jmp asm_common
.a926					z_asm_adc_z:
.a926					xt_asm_adc_zi:
.a926	a9 72		lda #$72	                lda #$72
.a928	4c 6d ac	jmp $ac6d	                jmp asm_common
.a92b					z_asm_adc_zi:
.a92b					xt_asm_adc_ziy:
.a92b	a9 71		lda #$71	                lda #$71
.a92d	4c 6d ac	jmp $ac6d	                jmp asm_common
.a930					z_asm_adc_ziy:
.a930					xt_asm_adc_zx:
.a930	a9 75		lda #$75	                lda #$75
.a932	4c 6d ac	jmp $ac6d	                jmp asm_common
.a935					z_asm_adc_zx:
.a935					xt_asm_adc_zxi:
.a935	a9 61		lda #$61	                lda #$61
.a937	4c 6d ac	jmp $ac6d	                jmp asm_common
.a93a					z_asm_adc_zxi:
.a93a					xt_asm_and:
.a93a	a9 2d		lda #$2d	                lda #$2D
.a93c	4c 6d ac	jmp $ac6d	                jmp asm_common
.a93f					z_asm_and:
.a93f					xt_asm_and_h:
.a93f	a9 29		lda #$29	                lda #$29
.a941	4c 6d ac	jmp $ac6d	                jmp asm_common
.a944					z_asm_and_h:
.a944					xt_asm_and_x:
.a944	a9 3d		lda #$3d	                lda #$3D
.a946	4c 6d ac	jmp $ac6d	                jmp asm_common
.a949					z_asm_and_x:
.a949					xt_asm_and_y:
.a949	a9 39		lda #$39	                lda #$39
.a94b	4c 6d ac	jmp $ac6d	                jmp asm_common
.a94e					z_asm_and_y:
.a94e					xt_asm_and_z:
.a94e	a9 25		lda #$25	                lda #$25
.a950	4c 6d ac	jmp $ac6d	                jmp asm_common
.a953					z_asm_and_z:
.a953					xt_asm_and_zi:
.a953	a9 32		lda #$32	                lda #$32
.a955	4c 6d ac	jmp $ac6d	                jmp asm_common
.a958					z_asm_and_zi:
.a958					xt_asm_and_ziy:
.a958	a9 31		lda #$31	                lda #$31
.a95a	4c 6d ac	jmp $ac6d	                jmp asm_common
.a95d					z_asm_and_ziy:
.a95d					xt_asm_and_zx:
.a95d	a9 35		lda #$35	                lda #$35
.a95f	4c 6d ac	jmp $ac6d	                jmp asm_common
.a962					z_asm_and_zx:
.a962					xt_asm_and_zxi:
.a962	a9 21		lda #$21	                lda #$21
.a964	4c 6d ac	jmp $ac6d	                jmp asm_common
.a967					z_asm_and_zxi:
.a967					xt_asm_asl:
.a967	a9 0e		lda #$0e	                lda #$0E
.a969	4c 6d ac	jmp $ac6d	                jmp asm_common
.a96c					z_asm_asl:
.a96c					xt_asm_asl_a:
.a96c	a9 0a		lda #$0a	                lda #$0A
.a96e	4c 6d ac	jmp $ac6d	                jmp asm_common
.a971					z_asm_asl_a:
.a971					xt_asm_asl_x:
.a971	a9 1e		lda #$1e	                lda #$1E
.a973	4c 6d ac	jmp $ac6d	                jmp asm_common
.a976					z_asm_asl_x:
.a976					xt_asm_asl_z:
.a976	a9 06		lda #$06	                lda #$06
.a978	4c 6d ac	jmp $ac6d	                jmp asm_common
.a97b					z_asm_asl_z:
.a97b					xt_asm_asl_zx:
.a97b	a9 16		lda #$16	                lda #$16
.a97d	4c 6d ac	jmp $ac6d	                jmp asm_common
.a980					z_asm_asl_zx:
.a980					xt_asm_bcc:
.a980	a9 90		lda #$90	                lda #$90
.a982	4c 6d ac	jmp $ac6d	                jmp asm_common
.a985					z_asm_bcc:
.a985					xt_asm_bcs:
.a985	a9 b0		lda #$b0	                lda #$B0
.a987	a0 02		ldy #$02	                ldy #2
.a989	4c 6d ac	jmp $ac6d	                jmp asm_common
.a98c					z_asm_bcs:
.a98c					xt_asm_beq:
.a98c	a9 f0		lda #$f0	                lda #$F0
.a98e	4c 6d ac	jmp $ac6d	                jmp asm_common
.a991					z_asm_beq:
.a991					xt_asm_bit:
.a991	a9 2c		lda #$2c	                lda #$2C
.a993	4c 6d ac	jmp $ac6d	                jmp asm_common
.a996					z_asm_bit:
.a996					xt_asm_bit_h:
.a996	a9 89		lda #$89	                lda #$89
.a998	4c 6d ac	jmp $ac6d	                jmp asm_common
.a99b					z_asm_bit_h:
.a99b					xt_asm_bit_x:
.a99b	a9 3c		lda #$3c	                lda #$3C
.a99d	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9a0					z_asm_bit_x:
.a9a0					xt_asm_bit_z:
.a9a0	a9 24		lda #$24	                lda #$24
.a9a2	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9a5					z_asm_bit_z:
.a9a5					xt_asm_bit_zx:
.a9a5	a9 34		lda #$34	                lda #$34
.a9a7	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9aa					z_asm_bit_zx:
.a9aa					xt_asm_bmi:
.a9aa	a9 30		lda #$30	                lda #$30
.a9ac	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9af					z_asm_bmi:
.a9af					xt_asm_bne:
.a9af	a9 d0		lda #$d0	                lda #$D0
.a9b1	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9b4					z_asm_bne:
.a9b4					xt_asm_bpl:
.a9b4	a9 10		lda #$10	                lda #$10
.a9b6	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9b9					z_asm_bpl:
.a9b9					xt_asm_bra:
.a9b9	a9 80		lda #$80	                lda #$80
.a9bb	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9be					z_asm_bra:
.a9be					xt_asm_brk:
.a9be	a9 00		lda #$00	                lda #$00
.a9c0	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9c3					z_asm_brk:
.a9c3					xt_asm_bvc:
.a9c3	a9 50		lda #$50	                lda #$50
.a9c5	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9c8					z_asm_bvc:
.a9c8					xt_asm_bvs:
.a9c8	a9 70		lda #$70	                lda #$70
.a9ca	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9cd					z_asm_bvs:
.a9cd					xt_asm_clc:
.a9cd	a9 18		lda #$18	                lda #$18
.a9cf	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9d2					z_asm_clc:
.a9d2					xt_asm_cld:
.a9d2	a9 d8		lda #$d8	                lda #$D8
.a9d4	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9d7					z_asm_cld:
.a9d7					xt_asm_cli:
.a9d7	a9 58		lda #$58	                lda #$58
.a9d9	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9dc					z_asm_cli:
.a9dc					xt_asm_clv:
.a9dc	a9 b8		lda #$b8	                lda #$B8
.a9de	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9e1					z_asm_clv:
.a9e1					xt_asm_cmp:
.a9e1	a9 cd		lda #$cd	                lda #$CD
.a9e3	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9e6					z_asm_cmp:
.a9e6					xt_asm_cmp_h:
.a9e6	a9 c9		lda #$c9	                lda #$C9
.a9e8	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9eb					z_asm_cmp_h:
.a9eb					xt_asm_cmp_x:
.a9eb	a9 dd		lda #$dd	                lda #$DD
.a9ed	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9f0					z_asm_cmp_x:
.a9f0					xt_asm_cmp_y:
.a9f0	a9 d9		lda #$d9	                lda #$D9
.a9f2	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9f5					z_asm_cmp_y:
.a9f5					xt_asm_cmp_z:
.a9f5	a9 c5		lda #$c5	                lda #$C5
.a9f7	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9fa					z_asm_cmp_z:
.a9fa					xt_asm_cmp_zi:
.a9fa	a9 d2		lda #$d2	                lda #$D2
.a9fc	4c 6d ac	jmp $ac6d	                jmp asm_common
.a9ff					z_asm_cmp_zi:
.a9ff					xt_asm_cmp_ziy:
.a9ff	a9 d1		lda #$d1	                lda #$D1
.aa01	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa04					z_asm_cmp_ziy:
.aa04					xt_asm_cmp_zx:
.aa04	a9 d5		lda #$d5	                lda #$D5
.aa06	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa09					z_asm_cmp_zx:
.aa09					xt_asm_cmp_zxi:
.aa09	a9 c1		lda #$c1	                lda #$C1
.aa0b	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa0e					z_asm_cmp_zxi:
.aa0e					xt_asm_cpx:
.aa0e	a9 ec		lda #$ec	                lda #$EC
.aa10	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa13					z_asm_cpx:
.aa13					xt_asm_cpx_h:
.aa13	a9 e0		lda #$e0	                lda #$E0
.aa15	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa18					z_asm_cpx_h:
.aa18					xt_asm_cpx_z:
.aa18	a9 e4		lda #$e4	                lda #$E4
.aa1a	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa1d					z_asm_cpx_z:
.aa1d					xt_asm_cpy:
.aa1d	a9 cc		lda #$cc	                lda #$CC
.aa1f	a0 03		ldy #$03	                ldy #3
.aa21	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa24					z_asm_cpy:
.aa24					xt_asm_cpy_h:
.aa24	a9 c0		lda #$c0	                lda #$C0
.aa26	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa29					z_asm_cpy_h:
.aa29					xt_asm_cpy_z:
.aa29	a9 c4		lda #$c4	                lda #$C4
.aa2b	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa2e					z_asm_cpy_z:
.aa2e					xt_asm_dec:
.aa2e	a9 ce		lda #$ce	                lda #$CE
.aa30	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa33					z_asm_dec:
.aa33					xt_asm_dec_a:
.aa33	a9 3a		lda #$3a	                lda #$3A
.aa35	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa38					z_asm_dec_a:
.aa38					xt_asm_dec_x:
.aa38	a9 de		lda #$de	                lda #$DE
.aa3a	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa3d					z_asm_dec_x:
.aa3d					xt_asm_dec_z:
.aa3d	a9 c6		lda #$c6	                lda #$C6
.aa3f	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa42					z_asm_dec_z:
.aa42					xt_asm_dec_zx:
.aa42	a9 d6		lda #$d6	                lda #$D6
.aa44	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa47					z_asm_dec_zx:
.aa47					xt_asm_dex:
.aa47	a9 ca		lda #$ca	                lda #$CA
.aa49	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa4c					z_asm_dex:
.aa4c					xt_asm_dey:
.aa4c	a9 88		lda #$88	                lda #$88
.aa4e	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa51					z_asm_dey:
.aa51					xt_asm_eor:
.aa51	a9 4d		lda #$4d	                lda #$4D
.aa53	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa56					z_asm_eor:
.aa56					xt_asm_eor_h:
.aa56	a9 49		lda #$49	                lda #$49
.aa58	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa5b					z_asm_eor_h:
.aa5b					xt_asm_eor_x:
.aa5b	a9 5d		lda #$5d	                lda #$5D
.aa5d	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa60					z_asm_eor_x:
.aa60					xt_asm_eor_y:
.aa60	a9 59		lda #$59	                lda #$59
.aa62	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa65					z_asm_eor_y:
.aa65					xt_asm_eor_z:
.aa65	a9 45		lda #$45	                lda #$45
.aa67	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa6a					z_asm_eor_z:
.aa6a					xt_asm_eor_zi:
.aa6a	a9 52		lda #$52	                lda #$52
.aa6c	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa6f					z_asm_eor_zi:
.aa6f					xt_asm_eor_ziy:
.aa6f	a9 51		lda #$51	                lda #$51
.aa71	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa74					z_asm_eor_ziy:
.aa74					xt_asm_eor_zx:
.aa74	a9 55		lda #$55	                lda #$55
.aa76	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa79					z_asm_eor_zx:
.aa79					xt_asm_eor_zxi:
.aa79	a9 41		lda #$41	                lda #$41
.aa7b	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa7e					z_asm_eor_zxi:
.aa7e					xt_asm_inc:
.aa7e	a9 ee		lda #$ee	                lda #$EE
.aa80	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa83					z_asm_inc:
.aa83					xt_asm_inc_a:
.aa83	a9 1a		lda #$1a	                lda #$1A
.aa85	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa88					z_asm_inc_a:
.aa88					xt_asm_inc_x:
.aa88	a9 fe		lda #$fe	                lda #$FE
.aa8a	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa8d					z_asm_inc_x:
.aa8d					xt_asm_inc_z:
.aa8d	a9 e6		lda #$e6	                lda #$E6
.aa8f	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa92					z_asm_inc_z:
.aa92					xt_asm_inc_zx:
.aa92	a9 f6		lda #$f6	                lda #$F6
.aa94	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa97					z_asm_inc_zx:
.aa97					xt_asm_inx:
.aa97	a9 e8		lda #$e8	                lda #$E8
.aa99	4c 6d ac	jmp $ac6d	                jmp asm_common
.aa9c					z_asm_inx:
.aa9c					xt_asm_iny:
.aa9c	a9 c8		lda #$c8	                lda #$C8
.aa9e	4c 6d ac	jmp $ac6d	                jmp asm_common
.aaa1					z_asm_iny:
.aaa1					xt_asm_jmp:
.aaa1	a9 4c		lda #$4c	                lda #$4C
.aaa3	4c 6d ac	jmp $ac6d	                jmp asm_common
.aaa6					z_asm_jmp:
.aaa6					xt_asm_jmp_i:
.aaa6	a9 6c		lda #$6c	                lda #$6C
.aaa8	4c 6d ac	jmp $ac6d	                jmp asm_common
.aaab					z_asm_jmp_i:
.aaab					xt_asm_jmp_xi:
.aaab	a9 7c		lda #$7c	                lda #$7C
.aaad	4c 6d ac	jmp $ac6d	                jmp asm_common
.aab0					z_asm_jmp_xi:
.aab0					xt_asm_jsr:
.aab0	a9 20		lda #$20	                lda #$20
.aab2	4c 6d ac	jmp $ac6d	                jmp asm_common
.aab5					z_asm_jsr:
.aab5					xt_asm_lda:
.aab5	a9 ad		lda #$ad	                lda #$AD
.aab7	4c 6d ac	jmp $ac6d	                jmp asm_common
.aaba					z_asm_lda:
.aaba					xt_asm_lda_h:
.aaba	a9 a9		lda #$a9	                lda #$A9
.aabc	4c 6d ac	jmp $ac6d	                jmp asm_common
.aabf					z_asm_lda_h:
.aabf					xt_asm_lda_x:
.aabf	a9 bd		lda #$bd	                lda #$BD
.aac1	4c 6d ac	jmp $ac6d	                jmp asm_common
.aac4					z_asm_lda_x:
.aac4					xt_asm_lda_y:
.aac4	a9 b9		lda #$b9	                lda #$B9
.aac6	4c 6d ac	jmp $ac6d	                jmp asm_common
.aac9					z_asm_lda_y:
.aac9					xt_asm_lda_z:
.aac9	a9 a5		lda #$a5	                lda #$A5
.aacb	4c 6d ac	jmp $ac6d	                jmp asm_common
.aace					z_asm_lda_z:
.aace					xt_asm_lda_zi:
.aace	a9 b2		lda #$b2	                lda #$B2
.aad0	4c 6d ac	jmp $ac6d	                jmp asm_common
.aad3					z_asm_lda_zi:
.aad3					xt_asm_lda_ziy:
.aad3	a9 b1		lda #$b1	                lda #$B1
.aad5	4c 6d ac	jmp $ac6d	                jmp asm_common
.aad8					z_asm_lda_ziy:
.aad8					xt_asm_lda_zx:
.aad8	a9 b5		lda #$b5	                lda #$B5
.aada	4c 6d ac	jmp $ac6d	                jmp asm_common
.aadd					z_asm_lda_zx:
.aadd					xt_asm_lda_zxi:
.aadd	a9 a1		lda #$a1	                lda #$A1
.aadf	4c 6d ac	jmp $ac6d	                jmp asm_common
.aae2					z_asm_lda_zxi:
.aae2					xt_asm_ldx:
.aae2	a9 ae		lda #$ae	                lda #$AE
.aae4	4c 6d ac	jmp $ac6d	                jmp asm_common
.aae7					z_asm_ldx:
.aae7					xt_asm_ldx_h:
.aae7	a9 a2		lda #$a2	                lda #$A2
.aae9	4c 6d ac	jmp $ac6d	                jmp asm_common
.aaec					z_asm_ldx_h:
.aaec					xt_asm_ldx_y:
.aaec	a9 be		lda #$be	                lda #$BE
.aaee	4c 6d ac	jmp $ac6d	                jmp asm_common
.aaf1					z_asm_ldx_y:
.aaf1					xt_asm_ldx_z:
.aaf1	a9 a6		lda #$a6	                lda #$A6
.aaf3	4c 6d ac	jmp $ac6d	                jmp asm_common
.aaf6					z_asm_ldx_z:
.aaf6					xt_asm_ldx_zy:
.aaf6	a9 b6		lda #$b6	                lda #$B6
.aaf8	4c 6d ac	jmp $ac6d	                jmp asm_common
.aafb					z_asm_ldx_zy:
.aafb					xt_asm_ldy:
.aafb	a9 ac		lda #$ac	                lda #$AC
.aafd	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab00					z_asm_ldy:
.ab00					xt_asm_ldy_h:
.ab00	a9 a0		lda #$a0	                lda #$A0
.ab02	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab05					z_asm_ldy_h:
.ab05					xt_asm_ldy_x:
.ab05	a9 bc		lda #$bc	                lda #$BC
.ab07	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab0a					z_asm_ldy_x:
.ab0a					xt_asm_ldy_z:
.ab0a	a9 a4		lda #$a4	                lda #$A4
.ab0c	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab0f					z_asm_ldy_z:
.ab0f					xt_asm_ldy_zx:
.ab0f	a9 b4		lda #$b4	                lda #$B4
.ab11	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab14					z_asm_ldy_zx:
.ab14					xt_asm_lsr:
.ab14	a9 4e		lda #$4e	                lda #$4E
.ab16	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab19					z_asm_lsr:
.ab19					xt_asm_lsr_a:
.ab19	a9 4a		lda #$4a	                lda #$4A
.ab1b	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab1e					z_asm_lsr_a:
.ab1e					xt_asm_lsr_x:
.ab1e	a9 5e		lda #$5e	                lda #$5E
.ab20	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab23					z_asm_lsr_x:
.ab23					xt_asm_lsr_z:
.ab23	a9 46		lda #$46	                lda #$46
.ab25	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab28					z_asm_lsr_z:
.ab28					xt_asm_lsr_zx:
.ab28	a9 56		lda #$56	                lda #$56
.ab2a	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab2d					z_asm_lsr_zx:
.ab2d					xt_asm_nop:
.ab2d	a9 ea		lda #$ea	                lda #$EA
.ab2f	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab32					z_asm_nop:
.ab32					xt_asm_ora:
.ab32	a9 0d		lda #$0d	                lda #$0D
.ab34	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab37					z_asm_ora:
.ab37					xt_asm_ora_h:
.ab37	a9 09		lda #$09	                lda #$09
.ab39	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab3c					z_asm_ora_h:
.ab3c					xt_asm_ora_x:
.ab3c	a9 1d		lda #$1d	                lda #$1D
.ab3e	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab41					z_asm_ora_x:
.ab41					xt_asm_ora_y:
.ab41	a9 19		lda #$19	                lda #$19
.ab43	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab46					z_asm_ora_y:
.ab46					xt_asm_ora_z:
.ab46	a9 05		lda #$05	                lda #$05
.ab48	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab4b					z_asm_ora_z:
.ab4b					xt_asm_ora_zi:
.ab4b	a9 12		lda #$12	                lda #$12
.ab4d	a0 02		ldy #$02	                ldy #2
.ab4f	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab52					z_asm_ora_zi:
.ab52					xt_asm_ora_ziy:
.ab52	a9 11		lda #$11	                lda #$11
.ab54	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab57					z_asm_ora_ziy:
.ab57					xt_asm_ora_zx:
.ab57	a9 15		lda #$15	                lda #$15
.ab59	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab5c					z_asm_ora_zx:
.ab5c					xt_asm_ora_zxi:
.ab5c	a9 01		lda #$01	                lda #$01
.ab5e	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab61					z_asm_ora_zxi:
.ab61					xt_asm_pha:
.ab61	a9 48		lda #$48	                lda #$48
.ab63	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab66					z_asm_pha:
.ab66					xt_asm_php:
.ab66	a9 08		lda #$08	                lda #$08
.ab68	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab6b					z_asm_php:
.ab6b					xt_asm_phx:
.ab6b	a9 da		lda #$da	                lda #$DA
.ab6d	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab70					z_asm_phx:
.ab70					xt_asm_phy:
.ab70	a9 5a		lda #$5a	                lda #$5A
.ab72	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab75					z_asm_phy:
.ab75					xt_asm_pla:
.ab75	a9 68		lda #$68	                lda #$68
.ab77	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab7a					z_asm_pla:
.ab7a					xt_asm_plp:
.ab7a	a9 28		lda #$28	                lda #$28
.ab7c	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab7f					z_asm_plp:
.ab7f					xt_asm_plx:
.ab7f	a9 fa		lda #$fa	                lda #$FA
.ab81	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab84					z_asm_plx:
.ab84					xt_asm_ply:
.ab84	a9 7a		lda #$7a	                lda #$7A
.ab86	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab89					z_asm_ply:
.ab89					xt_asm_rol:
.ab89	a9 2e		lda #$2e	                lda #$2E
.ab8b	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab8e					z_asm_rol:
.ab8e					xt_asm_rol_a:
.ab8e	a9 2a		lda #$2a	                lda #$2A
.ab90	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab93					z_asm_rol_a:
.ab93					xt_asm_rol_x:
.ab93	a9 3e		lda #$3e	                lda #$3E
.ab95	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab98					z_asm_rol_x:
.ab98					xt_asm_rol_z:
.ab98	a9 26		lda #$26	                lda #$26
.ab9a	4c 6d ac	jmp $ac6d	                jmp asm_common
.ab9d					z_asm_rol_z:
.ab9d					xt_asm_rol_zx:
.ab9d	a9 36		lda #$36	                lda #$36
.ab9f	4c 6d ac	jmp $ac6d	                jmp asm_common
.aba2					z_asm_rol_zx:
.aba2					xt_asm_ror:
.aba2	a9 6e		lda #$6e	                lda #$6E
.aba4	4c 6d ac	jmp $ac6d	                jmp asm_common
.aba7					z_asm_ror:
.aba7					xt_asm_ror_a:
.aba7	a9 6a		lda #$6a	                lda #$6A
.aba9	4c 6d ac	jmp $ac6d	                jmp asm_common
.abac					z_asm_ror_a:
.abac					xt_asm_ror_x:
.abac	a9 7e		lda #$7e	                lda #$7E
.abae	4c 6d ac	jmp $ac6d	                jmp asm_common
.abb1					z_asm_ror_x:
.abb1					xt_asm_ror_z:
.abb1	a9 66		lda #$66	                lda #$66
.abb3	4c 6d ac	jmp $ac6d	                jmp asm_common
.abb6					z_asm_ror_z:
.abb6					xt_asm_ror_zx:
.abb6	a9 76		lda #$76	                lda #$76
.abb8	4c 6d ac	jmp $ac6d	                jmp asm_common
.abbb					z_asm_ror_zx:
.abbb					xt_asm_rti:
.abbb	a9 40		lda #$40	                lda #$40
.abbd	4c 6d ac	jmp $ac6d	                jmp asm_common
.abc0					z_asm_rti:
.abc0					xt_asm_rts:
.abc0	a9 60		lda #$60	                lda #$60
.abc2	4c 6d ac	jmp $ac6d	                jmp asm_common
.abc5					z_asm_rts:
.abc5					xt_asm_sbc:
.abc5	a9 ed		lda #$ed	                lda #$ED
.abc7	4c 6d ac	jmp $ac6d	                jmp asm_common
.abca					z_asm_sbc:
.abca					xt_asm_sbc_h:
.abca	a9 e9		lda #$e9	                lda #$E9
.abcc	4c 6d ac	jmp $ac6d	                jmp asm_common
.abcf					z_asm_sbc_h:
.abcf					xt_asm_sbc_x:
.abcf	a9 fd		lda #$fd	                lda #$FD
.abd1	4c 6d ac	jmp $ac6d	                jmp asm_common
.abd4					z_asm_sbc_x:
.abd4					xt_asm_sbc_y:
.abd4	a9 f9		lda #$f9	                lda #$F9
.abd6	4c 6d ac	jmp $ac6d	                jmp asm_common
.abd9					z_asm_sbc_y:
.abd9					xt_asm_sbc_z:
.abd9	a9 e5		lda #$e5	                lda #$E5
.abdb	4c 6d ac	jmp $ac6d	                jmp asm_common
.abde					z_asm_sbc_z:
.abde					xt_asm_sbc_zi:
.abde	a9 f2		lda #$f2	                lda #$F2
.abe0	4c 6d ac	jmp $ac6d	                jmp asm_common
.abe3					z_asm_sbc_zi:
.abe3					xt_asm_sbc_ziy:
.abe3	a9 f1		lda #$f1	                lda #$F1
.abe5	4c 6d ac	jmp $ac6d	                jmp asm_common
.abe8					z_asm_sbc_ziy:
.abe8					xt_asm_sbc_zx:
.abe8	a9 f5		lda #$f5	                lda #$F5
.abea	4c 6d ac	jmp $ac6d	                jmp asm_common
.abed					z_asm_sbc_zx:
.abed					xt_asm_sbc_zxi:
.abed	a9 e1		lda #$e1	                lda #$E1
.abef	80 7c		bra $ac6d	                bra asm_common  ; <-- limit for BRA instead of JMP
.abf1					z_asm_sbc_zxi:
.abf1					xt_asm_sec:
.abf1	a9 38		lda #$38	                lda #$38
.abf3	80 78		bra $ac6d	                bra asm_common
.abf5					z_asm_sec:
.abf5					xt_asm_sed:
.abf5	a9 f8		lda #$f8	                lda #$F8
.abf7	80 74		bra $ac6d	                bra asm_common
.abf9					z_asm_sed:
.abf9					xt_asm_sei:
.abf9	a9 78		lda #$78	                lda #$78
.abfb	80 70		bra $ac6d	                bra asm_common
.abfd					z_asm_sei:
.abfd					xt_asm_sta:
.abfd	a9 8d		lda #$8d	                lda #$8D
.abff	80 6c		bra $ac6d	                bra asm_common
.ac01					z_asm_sta:
.ac01					xt_asm_sta_x:
.ac01	a9 9d		lda #$9d	                lda #$9D
.ac03	80 68		bra $ac6d	                bra asm_common
.ac05					z_asm_sta_x:
.ac05					xt_asm_sta_y:
.ac05	a9 99		lda #$99	                lda #$99
.ac07	80 64		bra $ac6d	                bra asm_common
.ac09					z_asm_sta_y:
.ac09					xt_asm_sta_z:
.ac09	a9 85		lda #$85	                lda #$85
.ac0b	80 60		bra $ac6d	                bra asm_common
.ac0d					z_asm_sta_z:
.ac0d					xt_asm_sta_zi:
.ac0d	a9 92		lda #$92	                lda #$92
.ac0f	80 5c		bra $ac6d	                bra asm_common
.ac11					z_asm_sta_zi:
.ac11					xt_asm_sta_ziy:
.ac11	a9 91		lda #$91	                lda #$91
.ac13	80 58		bra $ac6d	                bra asm_common
.ac15					z_asm_sta_ziy:
.ac15					xt_asm_sta_zx:
.ac15	a9 95		lda #$95	                lda #$95
.ac17	80 54		bra $ac6d	                bra asm_common
.ac19					z_asm_sta_zx:
.ac19					xt_asm_sta_zxi:
.ac19	a9 81		lda #$81	                lda #$81
.ac1b	80 50		bra $ac6d	                bra asm_common
.ac1d					z_asm_sta_zxi:
.ac1d					xt_asm_stx:
.ac1d	a9 8e		lda #$8e	                lda #$8E
.ac1f	80 4c		bra $ac6d	                bra asm_common
.ac21					z_asm_stx:
.ac21					xt_asm_stx_z:
.ac21	a9 86		lda #$86	                lda #$86
.ac23	80 48		bra $ac6d	                bra asm_common
.ac25					z_asm_stx_z:
.ac25					xt_asm_stx_zy:
.ac25	a9 96		lda #$96	                lda #$96
.ac27	80 44		bra $ac6d	                bra asm_common
.ac29					z_asm_stx_zy:
.ac29					xt_asm_sty:
.ac29	a9 8c		lda #$8c	                lda #$8C
.ac2b	80 40		bra $ac6d	                bra asm_common
.ac2d					z_asm_sty:
.ac2d					xt_asm_sty_z:
.ac2d	a9 84		lda #$84	                lda #$84
.ac2f	80 3c		bra $ac6d	                bra asm_common
.ac31					z_asm_sty_z:
.ac31					xt_asm_sty_zx:
.ac31	a9 94		lda #$94	                lda #$94
.ac33	80 38		bra $ac6d	                bra asm_common
.ac35					z_asm_sty_zx:
.ac35					xt_asm_stz:
.ac35	a9 9c		lda #$9c	                lda #$9C
.ac37	80 34		bra $ac6d	                bra asm_common
.ac39					z_asm_stz:
.ac39					xt_asm_stz_x:
.ac39	a9 9e		lda #$9e	                lda #$9E
.ac3b	80 30		bra $ac6d	                bra asm_common
.ac3d					z_asm_stz_x:
.ac3d					xt_asm_stz_z:
.ac3d	a9 64		lda #$64	                lda #$64
.ac3f	80 2c		bra $ac6d	                bra asm_common
.ac41					z_asm_stz_z:
.ac41					xt_asm_stz_zx:
.ac41	a9 74		lda #$74	                lda #$74
.ac43	80 28		bra $ac6d	                bra asm_common
.ac45					z_asm_stz_zx:
.ac45					xt_asm_tax:
.ac45	a9 aa		lda #$aa	                lda #$AA
.ac47	80 24		bra $ac6d	                bra asm_common
.ac49					z_asm_tax:
.ac49					xt_asm_tay:
.ac49	a9 a8		lda #$a8	                lda #$A8
.ac4b	80 20		bra $ac6d	                bra asm_common
.ac4d					z_asm_tay:
.ac4d					xt_asm_trb:
.ac4d	a9 1c		lda #$1c	                lda #$1C
.ac4f	80 1c		bra $ac6d	                bra asm_common
.ac51					z_asm_trb:
.ac51					xt_asm_trb_z:
.ac51	a9 14		lda #$14	                lda #$14
.ac53	80 18		bra $ac6d	                bra asm_common
.ac55					z_asm_trb_z:
.ac55					xt_asm_tsb:
.ac55	a9 0c		lda #$0c	                lda #$0C
.ac57	80 14		bra $ac6d	                bra asm_common
.ac59					z_asm_tsb:
.ac59					xt_asm_tsb_z:
.ac59	a9 04		lda #$04	                lda #$04
.ac5b	80 10		bra $ac6d	                bra asm_common
.ac5d					z_asm_tsb_z:
.ac5d					xt_asm_tsx:
.ac5d	a9 ba		lda #$ba	                lda #$BA
.ac5f	80 0c		bra $ac6d	                bra asm_common
.ac61					z_asm_tsx:
.ac61					xt_asm_txa:
.ac61	a9 8a		lda #$8a	                lda #$8A
.ac63	80 08		bra $ac6d	                bra asm_common
.ac65					z_asm_txa:
.ac65					xt_asm_txs:
.ac65	a9 9a		lda #$9a	                lda #$9A
.ac67	80 04		bra $ac6d	                bra asm_common
.ac69					z_asm_txs:
.ac69					xt_asm_tya:
.ac69	a9 98		lda #$98	                lda #$98
.ac6b	80 00		bra $ac6d	                bra asm_common
.ac6d					z_asm_tya:
.ac6d					asm_common:
.ac6d	a8		tay		                tay
.ac6e	20 bf d7	jsr $d7bf	                jsr cmpl_a
.ac71	a9 d9		lda #$d9	                lda #<oc_index_table
.ac73	85 26		sta $26		                sta tmp2
.ac75	a9 ae		lda #$ae	                lda #>oc_index_table
.ac77	85 27		sta $27		                sta tmp2+1
.ac79	98		tya		                tya             ; retrieve opcode
.ac7a	0a		asl a		                asl             ; times two for offset
.ac7b	90 02		bcc $ac7f	                bcc +
.ac7d	e6 27		inc $27		                inc tmp2+1
.ac7f					+
.ac7f	a8		tay		                tay             ; use Y as the index
.ac80	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac82	85 28		sta $28		                sta tmp3
.ac84	c8		iny		                iny
.ac85	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac87	85 29		sta $29		                sta tmp3+1
.ac89	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac8b	2a		rol a		                rol
.ac8c	2a		rol a		                rol
.ac8d	2a		rol a		                rol             ; Three times because we go through Carry
.ac8e	29 03		and #$03	                and #%00000011
.ac90	a8		tay		                tay
.ac91	88		dey		                dey
.ac92	f0 12		beq $aca6	                beq _done
.ac94	20 0c d9	jsr $d90c	                jsr underflow_1
.ac97	b5 00		lda $00,x	                lda 0,x
.ac99	20 bf d7	jsr $d7bf	                jsr cmpl_a      ; does not use Y
.ac9c	88		dey		                dey
.ac9d	f0 05		beq $aca4	                beq _done_drop
.ac9f	b5 01		lda $01,x	                lda 1,x
.aca1	20 bf d7	jsr $d7bf	                jsr cmpl_a      ; Fall through to _done_drop
.aca4					_done_drop:
.aca4	e8		inx		                inx
.aca5	e8		inx		                inx             ; Fall through to _done
.aca6					_done:
.aca6	60		rts		                rts             ; Returns to original caller
.aca7					xt_asm_push_a:
.aca7	a0 00		ldy #$00	                ldy #0
.aca9					_loop:
.aca9	b9 b7 ac	lda $acb7,y	                lda asm_push_a_data,y
.acac	c9 ff		cmp #$ff	                cmp #$FF
.acae	f0 06		beq $acb6	                beq _done
.acb0	20 bf d7	jsr $d7bf	                jsr cmpl_a      ; does not change Y
.acb3	c8		iny		                iny
.acb4	80 f3		bra $aca9	                bra _loop
.acb6					_done:
.acb6					z_asm_push_a:
.acb6	60		rts		                rts
.acb7					asm_push_a_data:
>acb7	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acbd	ff				        .byte $FF               ; terminator
.acbe					xt_asm_back_jump:
.acbe					z_asm_back_jump:
.acbe	60		rts		                rts
.acbf					xt_asm_back_branch:
.acbf	20 63 91	jsr $9163	                jsr xt_here             ; ( addr-l addr-h )
.acc2	20 41 95	jsr $9541	                jsr xt_minus            ; ( offset )
.acc5	3a		dec a		                dea
.acc6	3a		dec a		                dea
.acc7					z_asm_back_branch:
.acc7	60		rts		                rts
.acc8					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acc8					disassembler:
.acc8	20 54 89	jsr $8954	                jsr xt_cr       ; ( addr u )
.accb					_byte_loop:
.accb	20 84 98	jsr $9884	                jsr xt_over     ; ( addr u addr )
.acce	20 1f a5	jsr $a51f	                jsr xt_u_dot    ; ( addr u )
.acd1	20 0f a1	jsr $a10f	                jsr xt_space
.acd4	a9 d9		lda #$d9	                lda #<oc_index_table
.acd6	85 26		sta $26		                sta tmp2
.acd8	a9 ae		lda #$ae	                lda #>oc_index_table
.acda	85 27		sta $27		                sta tmp2+1
.acdc	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.acde	85 36		sta $36		                sta scratch     ; Save opcode
.ace0	0a		asl a		                asl             ; multiply by two for offset
.ace1	90 02		bcc $ace5	                bcc +
.ace3	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.ace5					+
.ace5	a8		tay		                tay             ; use Y as the index
.ace6	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ace8	85 28		sta $28		                sta tmp3
.acea	48		pha		                pha
.aceb	c8		iny		                iny
.acec	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acee	85 29		sta $29		                sta tmp3+1
.acf0	48		pha		                pha
.acf1	b2 28		lda ($28)	                lda (tmp3)
.acf3	a8		tay		                tay                     ; save copy of lengths byte
.acf4	10 3c		bpl $ad32	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.acf6	20 99 a7	jsr $a799	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.acf9	f6 04		inc $04,x	                inc 4,x
.acfb	d0 02		bne $acff	                bne +
.acfd	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.acff					+
.acff	b5 02		lda $02,x	                lda 2,x
.ad01	d0 02		bne $ad05	                bne +
.ad03	d6 03		dec $03,x	                dec 3,x
.ad05					+
.ad05	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.ad07	a1 04		lda ($04,x)	                lda (4,x)
.ad09	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.ad0b	85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.ad0d	98		tya		                tya                     ; retrieve copy of lengths byte
.ad0e	2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad0f	10 14		bpl $ad25	                bpl _print_operand
.ad11	f6 04		inc $04,x	                inc 4,x
.ad13	d0 02		bne $ad17	                bne +
.ad15	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad17					+
.ad17	b5 02		lda $02,x	                lda 2,x
.ad19	d0 02		bne $ad1d	                bne +
.ad1b	d6 03		dec $03,x	                dec 3,x
.ad1d					+
.ad1d	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad1f	a1 04		lda ($04,x)	                lda (4,x)
.ad21	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad23	85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad25					_print_operand:
.ad25	ca		dex		                dex
.ad26	ca		dex		                dex
.ad27	a9 05		lda #$05	                lda #5
.ad29	95 00		sta $00,x	                sta 0,x
.ad2b	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad2d	20 2b a5	jsr $a52b	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad30	80 0b		bra $ad3d	                bra _print_mnemonic
.ad32					_no_operand:
.ad32	ca		dex		                dex
.ad33	ca		dex		                dex
.ad34	a9 05		lda #$05	                lda #5
.ad36	95 00		sta $00,x	                sta 0,x
.ad38	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad3a	20 15 a1	jsr $a115	                jsr xt_spaces           ; ( addr u )
.ad3d					_print_mnemonic:
.ad3d	20 0f a1	jsr $a10f	                jsr xt_space
.ad40	ca		dex		                dex
.ad41	ca		dex		                dex                     ; ( addr u ? )
.ad42	68		pla		                pla                     ; MSB
.ad43	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad45	68		pla		                pla                     ; LSB
.ad46	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad48	20 40 89	jsr $8940	                jsr xt_count            ; ( addr u addr-o u-o )
.ad4b	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad4d	b5 00		lda $00,x	                lda 0,x
.ad4f	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad51	95 00		sta $00,x	                sta 0,x
.ad53	20 f4 a4	jsr $a4f4	                jsr xt_type             ; ( addr u )
.ad56	a5 36		lda $36		                lda scratch
.ad58	c9 20		cmp #$20	                cmp #$20
.ad5a	d0 59		bne $adb5	                bne _not_jsr
.ad5c	ca		dex		                dex
.ad5d	ca		dex		                dex
.ad5e	a9 05		lda #$05	                lda #5
.ad60	95 00		sta $00,x	                sta 0,x
.ad62	74 01		stz $01,x	                stz 1,x
.ad64	20 15 a1	jsr $a115	                jsr xt_spaces
.ad67	a9 89		lda #$89	                lda #<literal_runtime
.ad69	c5 37		cmp $37		                cmp scratch+1
.ad6b	d0 0c		bne $ad79	                bne _not_literal
.ad6d	a9 93		lda #$93	                lda #>literal_runtime
.ad6f	c5 38		cmp $38		                cmp scratch+2
.ad71	d0 06		bne $ad79	                bne _not_literal
.ad73	20 6b ae	jsr $ae6b	                jsr disasm_literal
.ad76	4c e2 ad	jmp $ade2	                jmp _printing_done
.ad79					_not_literal:
.ad79	a9 9a		lda #$9a	                lda #<sliteral_runtime
.ad7b	c5 37		cmp $37		                cmp scratch+1
.ad7d	d0 0c		bne $ad8b	                bne _not_sliteral
.ad7f	a9 a0		lda #$a0	                lda #>sliteral_runtime
.ad81	c5 38		cmp $38		                cmp scratch+2
.ad83	d0 06		bne $ad8b	                bne _not_sliteral
.ad85	20 28 ae	jsr $ae28	                jsr disasm_sliteral
.ad88	4c e2 ad	jmp $ade2	                jmp _printing_done
.ad8b					_not_sliteral:
.ad8b	a9 05		lda #$05	                lda #<zero_branch_runtime
.ad8d	c5 37		cmp $37		                cmp scratch+1
.ad8f	d0 0c		bne $ad9d	                bne _not_0branch
.ad91	a9 92		lda #$92	                lda #>zero_branch_runtime
.ad93	c5 38		cmp $38		                cmp scratch+2
.ad95	d0 06		bne $ad9d	                bne _not_0branch
.ad97	20 5f ae	jsr $ae5f	                jsr disasm_0branch
.ad9a	4c e2 ad	jmp $ade2	                jmp _printing_done
.ad9d					_not_0branch
.ad9d	a9 cc		lda #$cc	                lda #<branch_runtime
.ad9f	c5 37		cmp $37		                cmp scratch+1
.ada1	d0 0c		bne $adaf	                bne _not_branch
.ada3	a9 8d		lda #$8d	                lda #>branch_runtime
.ada5	c5 38		cmp $38		                cmp scratch+2
.ada7	d0 06		bne $adaf	                bne _not_branch
.ada9	20 64 ae	jsr $ae64	                jsr disasm_branch
.adac	4c e2 ad	jmp $ade2	                jmp _printing_done
.adaf					_not_branch
.adaf	20 89 ae	jsr $ae89	                jsr disasm_jsr
.adb2	4c e2 ad	jmp $ade2	                jmp _printing_done
.adb5					_not_jsr:
.adb5	c9 4c		cmp #$4c	                cmp #$4C
.adb7	d0 29		bne $ade2	                bne _printing_done
.adb9	a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.adbb	85 39		sta $39		                sta scratch+3
.adbd	a5 38		lda $38		                lda scratch+2
.adbf	85 3a		sta $3a		                sta scratch+4
.adc1	b2 39		lda ($39)	                lda (scratch+3)
.adc3	c9 20		cmp #$20	                cmp #$20 ; check for JSR
.adc5	d0 1b		bne $ade2	                bne _printing_done
.adc7	e6 39		inc $39		                inc scratch+3
.adc9	d0 02		bne $adcd	                bne +
.adcb	e6 3a		inc $3a		                inc scratch+4
.adcd					+
.adcd	b2 39		lda ($39)	                lda (scratch+3)
.adcf	c9 9a		cmp #$9a	                cmp #<sliteral_runtime
.add1	d0 0f		bne $ade2	                bne _printing_done
.add3	e6 39		inc $39		                inc scratch+3
.add5	d0 02		bne $add9	                bne +
.add7	e6 3a		inc $3a		                inc scratch+4
.add9					+
.add9	b2 39		lda ($39)	                lda (scratch+3)
.addb	c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.addd	d0 03		bne $ade2	                bne _printing_done
.addf	20 fe ad	jsr $adfe	                jsr disasm_sliteral_jump
.ade2					_printing_done:
.ade2	20 54 89	jsr $8954	                jsr xt_cr
.ade5	f6 02		inc $02,x	                inc 2,x
.ade7	d0 02		bne $adeb	                bne +
.ade9	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.adeb					+
.adeb	20 02 98	jsr $9802	                jsr xt_one_minus        ; ( addr+1 u-1 )
.adee	b5 00		lda $00,x	                lda 0,x                 ; All done?
.adf0	15 01		ora $01,x	                ora 1,x
.adf2	f0 07		beq $adfb	                beq _done
.adf4	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.adf6	30 03		bmi $adfb	                bmi _done
.adf8	4c cb ac	jmp $accb	                jmp _byte_loop          ; out of range for BRA
.adfb					_done:
.adfb	4c a1 a3	jmp $a3a1	                jmp xt_two_drop         ; JSR/RTS
.adfe					disasm_sliteral_jump:
.adfe	20 9f a1	jsr $a19f	                jsr xt_swap
.ae01	ca		dex		                dex
.ae02	ca		dex		                dex
.ae03	a5 37		lda $37		                lda scratch+1
.ae05	95 00		sta $00,x	                sta 0,x
.ae07	a5 38		lda $38		                lda scratch+2
.ae09	95 01		sta $01,x	                sta 1,x
.ae0b	20 9f a1	jsr $a19f	                jsr xt_swap
.ae0e	20 41 95	jsr $9541	                jsr xt_minus
.ae11	20 02 98	jsr $9802	                jsr xt_one_minus
.ae14	20 41 95	jsr $9541	                jsr xt_minus
.ae17	ca		dex		                dex
.ae18	ca		dex		                dex
.ae19	a5 37		lda $37		                lda scratch+1
.ae1b	95 00		sta $00,x	                sta 0,x
.ae1d	a5 38		lda $38		                lda scratch+2
.ae1f	95 01		sta $01,x	                sta 1,x
.ae21	20 02 98	jsr $9802	                jsr xt_one_minus
.ae24	20 9f a1	jsr $a19f	                jsr xt_swap ; ( new_addr new_n )
.ae27	60		rts		                rts
.ae28					disasm_sliteral:
.ae28	a9 53		lda #$53	                lda #'S'
.ae2a	20 e7 8d	jsr $8de7	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae2d	a9 0d		lda #$0d	                lda #str_disasm_lit     ; "LITERAL "
.ae2f	20 48 d9	jsr $d948	                jsr print_string_no_lf
.ae32	20 9f a1	jsr $a19f	                jsr xt_swap             ; switch to (u addr)
.ae35	20 0e 98	jsr $980e	                jsr xt_one_plus
.ae38	20 a0 8d	jsr $8da0	                jsr xt_dup
.ae3b	20 71 8f	jsr $8f71	                jsr xt_fetch
.ae3e	20 1f a5	jsr $a51f	                jsr xt_u_dot            ; Print the address of the string
.ae41	20 98 a3	jsr $a398	                jsr xt_two
.ae44	20 d4 99	jsr $99d4	                jsr xt_plus
.ae47	20 a0 8d	jsr $8da0	                jsr xt_dup
.ae4a	20 53 9a	jsr $9a53	                jsr xt_question         ; Print the length of the string
.ae4d	20 0e 98	jsr $980e	                jsr xt_one_plus
.ae50	20 9f a1	jsr $a19f	                jsr xt_swap            ; ( addr+4 u )
.ae53	ca		dex		                dex
.ae54	ca		dex		                dex
.ae55	a9 04		lda #$04	                lda #4
.ae57	95 00		sta $00,x	                sta 0,x
.ae59	74 01		stz $01,x	                stz 1,x
.ae5b	20 41 95	jsr $9541	                jsr xt_minus            ; ( addr+4 u-4 )
.ae5e	60		rts		                rts
.ae5f					disasm_0branch:
.ae5f	a9 30		lda #$30	                lda #'0'
.ae61	20 e7 8d	jsr $8de7	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae64					disasm_branch:
.ae64	a9 0f		lda #$0f	                lda #str_disasm_bra
.ae66	20 48 d9	jsr $d948	                jsr print_string_no_lf ; "BRANCH "
.ae69	80 05		bra $ae70	                bra disasm_print_literal
.ae6b					disasm_literal:
.ae6b	a9 0d		lda #$0d	                lda #str_disasm_lit
.ae6d	20 48 d9	jsr $d948	                jsr print_string_no_lf ; "LITERAL "
.ae70					disasm_print_literal:
.ae70	20 9f a1	jsr $a19f	                jsr xt_swap ; switch to (u addr)
.ae73	20 0e 98	jsr $980e	                jsr xt_one_plus
.ae76	20 a0 8d	jsr $8da0	                jsr xt_dup
.ae79	20 53 9a	jsr $9a53	                jsr xt_question ; Print the value at the adress
.ae7c	20 0e 98	jsr $980e	                jsr xt_one_plus
.ae7f	20 9f a1	jsr $a19f	                jsr xt_swap ; (addr+2 u)
.ae82	20 02 98	jsr $9802	                jsr xt_one_minus
.ae85	20 02 98	jsr $9802	                jsr xt_one_minus ; (addr+2 u-2)
.ae88	60		rts		                rts
.ae89					disasm_jsr:
.ae89	ca		dex		                dex
.ae8a	ca		dex		                dex
.ae8b	a5 37		lda $37		                lda scratch+1
.ae8d	95 00		sta $00,x	                sta 0,x
.ae8f	a5 38		lda $38		                lda scratch+2
.ae91	95 01		sta $01,x	                sta 1,x
.ae93	20 69 92	jsr $9269	                jsr xt_int_to_name
.ae96	b5 00		lda $00,x	                lda 0,x
.ae98	15 01		ora $01,x	                ora 1,x
.ae9a	f0 07		beq $aea3	                beq _disasm_no_nt
.ae9c	20 ef 95	jsr $95ef	                jsr xt_name_to_string
.ae9f	20 f4 a4	jsr $a4f4	                jsr xt_type
.aea2	60		rts		                rts
.aea3					_disasm_no_nt:
.aea3	20 1f 8d	jsr $8d1f	                jsr xt_drop ; the 0 indicating no name token
.aea6	ca		dex		                dex
.aea7	ca		dex		                dex
.aea8	a5 37		lda $37		                lda scratch+1
.aeaa	95 00		sta $00,x	                sta 0,x
.aeac	a5 38		lda $38		                lda scratch+2
.aeae	95 01		sta $01,x	                sta 1,x
.aeb0	ca		dex		                dex
.aeb1	ca		dex		                dex
.aeb2	a9 0c		lda #$0c	                lda #<underflow_1
.aeb4	95 00		sta $00,x	                sta 0,x
.aeb6	a9 d9		lda #$d9	                lda #>underflow_1
.aeb8	95 01		sta $01,x	                sta 1,x
.aeba	20 33 d8	jsr $d833	                jsr compare_16bit
.aebd	f0 02		beq $aec1	                beq _disasm_jsr_uflow_check_upper
.aebf	b0 14		bcs $aed5	                bcs _disasm_jsr_unknown
.aec1					_disasm_jsr_uflow_check_upper:
.aec1	a9 1b		lda #$1b	                lda #<underflow_4
.aec3	95 00		sta $00,x	                sta 0,x
.aec5	a9 d9		lda #$d9	                lda #>underflow_4
.aec7	95 01		sta $01,x	                sta 1,x
.aec9	20 33 d8	jsr $d833	                jsr compare_16bit
.aecc	f0 02		beq $aed0	                beq _disasm_jsr_soc
.aece	90 05		bcc $aed5	                bcc _disasm_jsr_unknown
.aed0					_disasm_jsr_soc:
.aed0	a9 0e		lda #$0e	                lda #str_disasm_sdc
.aed2	20 48 d9	jsr $d948	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.aed5					_disasm_jsr_unknown:
.aed5	20 a1 a3	jsr $a3a1	                jsr xt_two_drop
.aed8	60		rts		                rts
.aed9					oc_index_table:
>aed9	d9 b0 dd b0 71 b5 71 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>aee1	e5 b0 eb b0 f1 b0 71 b5
>aee9	f7 b0 fb b0 01 b1 71 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>aef1	07 b1 0b b1 0f b1 13 b1
>aef9	18 b1 1c b1 24 b1 71 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af01	2b b1 31 b1 38 b1 3f b1
>af09	46 b1 4a b1 50 b1 71 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af11	56 b1 5a b1 71 b5 60 b1
>af19	66 b1 6a b1 71 b5 71 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af21	72 b1 78 b1 7e b1 84 b1
>af29	8b b1 8f b1 95 b1 71 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af31	9b b1 9f b1 a4 b1 a8 b1
>af39	ad b1 b1 b1 b9 b1 71 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af41	c0 b1 c8 b1 cf b1 d6 b1
>af49	dd b1 e1 b1 e7 b1 71 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af51	ed b1 f3 b1 f9 b1 13 b1
>af59	04 b2 08 b2 71 b5 71 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af61	71 b5 10 b2 16 b2 1c b2
>af69	23 b2 27 b2 2d b2 71 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>af71	33 b2 37 b2 3b b2 3f b2
>af79	44 b2 48 b2 50 b2 71 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>af81	71 b5 57 b2 5e b2 65 b2
>af89	6c b2 70 b2 76 b2 71 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>af91	71 b5 71 b5 80 b2 86 b2
>af99	8b b2 8f b2 71 b5 71 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>afa1	97 b2 9d b2 a3 b2 a9 b2
>afa9	b0 b2 b4 b2 ba b2 71 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afb1	c0 b2 c6 b2 ca b2 ce b2
>afb9	d3 b2 d7 b2 df b2 71 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>afc1	e6 b2 ed b2 f4 b2 fb b2
>afc9	02 b3 06 b3 0c b3 71 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>afd1	10 b3 17 b3 1d b3 23 b3
>afd9	28 b3 2c b3 71 b5 71 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>afe1	34 b3 3a b3 40 b3 71 b5
>afe9	46 b3 4a b3 50 b3 71 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>aff1	54 b3 58 b3 5c b3 60 b3
>aff9	65 b3 69 b3 71 b3 71 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b001	78 b3 7f b3 86 b3 8d b3
>b009	94 b3 98 b3 9e b3 71 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b011	a2 b3 a6 b3 ac b3 b2 b3
>b019	b7 b3 bd b3 c5 b3 71 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b021	cb b3 d1 b3 d7 b3 dd b3
>b029	e4 b3 e8 b3 ee b3 71 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b031	f2 b3 f6 b3 fa b3 fe b3
>b039	03 b4 07 b4 0f b4 71 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b041	16 b4 1d b4 24 b4 2b b4
>b049	32 b4 36 b4 3c b4 71 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b051	40 b4 46 b4 4c b4 52 b4
>b059	57 b4 5d b4 71 b5 71 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b061	65 b4 6b b4 71 b4 77 b4
>b069	7e b4 82 b4 88 b4 71 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b071	8c b4 90 b4 94 b4 98 b4
>b079	9d b4 a1 b4 a9 b4 71 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b081	71 b5 b0 b4 b7 b4 be b4
>b089	c5 b4 c9 b4 cf b4 71 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b091	71 b5 d3 b4 d9 b4 df b4
>b099	e4 b4 ea b4 71 b5 71 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0a1	f2 b4 f8 b4 fe b4 04 b5
>b0a9	0b b5 0f b5 15 b5 71 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0b1	19 b5 1d b5 21 b5 25 b5
>b0b9	2a b5 2e b5 36 b5 71 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b0c1	71 b5 3d b5 44 b5 4b b5
>b0c9	52 b5 56 b5 5c b5 71 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b0d1	71 b5 60 b5 66 b5 6c b5
.b0d9					oc_table:
>b0d9	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b0dd	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b0e5	85 74 73 62 2e 7a		        oc04:   .text 2*64+5, "tsb.z"
>b0eb	85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b0f1	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b0f7	43 70 68 70				oc08:	.text 1*64+3, "php"
>b0fb	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b101	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b107	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b10b	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b10f	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b113	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b118	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b11c	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b124	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b12b	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b131	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b138	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b13f	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b146	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b14a	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b150	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b156	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b15a	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b160	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b166	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b16a	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b172	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b178	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b17e	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b184	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b18b	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b18f	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b195	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b19b	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b19f	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1a4	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1a8	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1ad	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1b1	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b1b9	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b1c0	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b1c8	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b1cf	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b1d6	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b1dd	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b1e1	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b1e7	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b1ed	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b1f3	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b1f9	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b1ff	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b204	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b208	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b210	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b216	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b21c	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b223	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b227	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b22d	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b233	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b237	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b23b	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b23f	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b244	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b248	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b250	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b257	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b25e	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b265	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b26c	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b270	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b276	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b27a	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b280	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b286	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b28b	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b28f	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b297	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b29d	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2a3	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2a9	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2b0	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b2b4	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b2ba	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b2c0	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b2c6	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b2ca	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b2ce	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b2d3	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b2d7	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b2df	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b2e6	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b2ed	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b2f4	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b2fb	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b302	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b306	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b30c	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b310	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b317	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b31d	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b323	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b328	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b32c	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b334	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b33a	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b340	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b346	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b34a	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b350	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b354	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b358	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b35c	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b360	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b365	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b369	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b371	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b378	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b37f	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b386	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b38d	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b394	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b398	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b39e	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3a2	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3a6	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3ac	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b3b2	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b3b7	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b3bd	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b3c5	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b3cb	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b3d1	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b3d7	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b3dd	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b3e4	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b3e8	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b3ee	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b3f2	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b3f6	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b3fa	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b3fe	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b403	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b407	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b40f	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b416	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b41d	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b424	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b42b	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b432	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b436	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b43c	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b440	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b446	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b44c	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b452	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b457	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b45d	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b465	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b46b	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b471	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b477	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b47e	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b482	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b488	43 64 65 78				occa:	.text 1*64+3, "dex"
>b48c	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b490	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b494	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b498	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b49d	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4a1	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4a9	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4b0	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b4b7	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b4be	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b4c5	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b4c9	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b4cf	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b4d3	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b4d9	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b4df	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b4e4	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b4ea	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b4f2	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b4f8	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b4fe	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b504	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b50b	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b50f	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b515	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b519	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b51d	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b521	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b525	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b52a	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b52e	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b536	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b53d	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b544	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b54b	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b552	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b556	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b55c	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b560	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b566	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b56c	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b571	01 3f					oc__:	.text 1, "?"
.b573					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b573					ed6502:
.b573	a5 18		lda $18		                lda base
.b575	85 33		sta $33		                sta editor3+1
.b577	a9 0a		lda #$0a	                lda #10
.b579	85 18		sta $18		                sta base
.b57b	64 2e		stz $2e		                stz ed_head
.b57d	64 2f		stz $2f		                stz ed_head+1
.b57f	64 30		stz $30		                stz ed_cur
.b581	64 31		stz $31		                stz ed_cur+1
.b583	64 32		stz $32		                stz ed_flags
.b585	20 99 a7	jsr $a799	                jsr xt_zero
.b588	20 99 a7	jsr $a799	                jsr xt_zero             ; ( addr-t u-t )
.b58b	20 54 89	jsr $8954	                jsr xt_cr
.b58e					ed_input_loop:
.b58e	a9 81		lda #$81	                lda #%10000001
.b590	14 32		trb $32		                trb ed_flags
.b592	20 6d ba	jsr $ba6d	                jsr ed_get_input
.b595	a5 0a		lda $0a		                lda ciblen
.b597	d0 1f		bne $b5b8	                bne _command_mode
.b599	ca		dex		                dex
.b59a	ca		dex		                dex                     ; ( addr-t u-t ? )
.b59b	a5 30		lda $30		                lda ed_cur
.b59d	95 00		sta $00,x	                sta 0,x
.b59f	a5 31		lda $31		                lda ed_cur+1
.b5a1	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5a3	a9 80		lda #$80	                lda #%10000000
.b5a5	04 32		tsb $32		                tsb ed_flags
.b5a7	20 0e 98	jsr $980e	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5aa	20 89 ba	jsr $ba89	                jsr ed_is_valid_line
.b5ad	b0 03		bcs $b5b2	                bcs +
.b5af	4c 5d ba	jmp $ba5d	                jmp ed_error_1drop
.b5b2					+
.b5b2	20 99 a7	jsr $a799	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b5b5	4c 83 b6	jmp $b683	                jmp _line_number_only_from_external
.b5b8					_command_mode:
.b5b8	20 99 a7	jsr $a799	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b5bb	20 99 a7	jsr $a799	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b5be					_prefix_dot:
.b5be	b2 08		lda ($08)	                lda (cib)
.b5c0	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b5c2	d0 3a		bne $b5fe	                bne _prefix_dollar
.b5c4	20 7e ba	jsr $ba7e	                jsr ed_have_text
.b5c7	a5 30		lda $30		                lda ed_cur
.b5c9	95 02		sta $02,x	                sta 2,x
.b5cb	a5 31		lda $31		                lda ed_cur+1
.b5cd	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b5cf	a9 80		lda #$80	                lda #%10000000
.b5d1	04 32		tsb $32		                tsb ed_flags
.b5d3	a5 0a		lda $0a		                lda ciblen
.b5d5	3a		dec a		                dea                     ; sets Z if A was 1
.b5d6	d0 03		bne $b5db	                bne +
.b5d8	4c 83 b6	jmp $b683	                jmp _line_number_only_from_external
.b5db					+
.b5db	ca		dex		                dex
.b5dc	ca		dex		                dex
.b5dd	ca		dex		                dex
.b5de	ca		dex		                dex
.b5df	a5 08		lda $08		                lda cib
.b5e1	95 02		sta $02,x	                sta 2,x
.b5e3	a5 09		lda $09		                lda cib+1
.b5e5	95 03		sta $03,x	                sta 3,x
.b5e7	a5 0a		lda $0a		                lda ciblen
.b5e9	95 00		sta $00,x	                sta 0,x
.b5eb	a5 0b		lda $0b		                lda ciblen+1
.b5ed	95 01		sta $01,x	                sta 1,x
.b5ef	20 02 98	jsr $9802	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b5f2	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b5f5	20 0e 98	jsr $980e	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b5f8	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b5fb	4c db b6	jmp $b6db	                jmp _check_for_para2
.b5fe					_prefix_dollar:
.b5fe	b2 08		lda ($08)	                lda (cib)
.b600	c9 24		cmp #$24	                cmp #'$'
.b602	d0 1c		bne $b620	                bne _prefix_percent
.b604	20 7e ba	jsr $ba7e	                jsr ed_have_text
.b607	e8		inx		                inx
.b608	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b609	20 ab ba	jsr $baab	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b60c	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b60f	a9 80		lda #$80	                lda #%10000000
.b611	04 32		tsb $32		                tsb ed_flags
.b613	a5 0a		lda $0a		                lda ciblen
.b615	3a		dec a		                dea                     ; sets Z if A was 1
.b616	d0 03		bne $b61b	                bne +
.b618	4c 83 b6	jmp $b683	                jmp _line_number_only_from_external
.b61b					+
.b61b	a0 01		ldy #$01	                ldy #01
.b61d	4c 57 b7	jmp $b757	                jmp _check_command
.b620					_prefix_percent:
.b620	b2 08		lda ($08)	                lda (cib)
.b622	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b624	f0 04		beq $b62a	                beq _whole_text
.b626	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b628	d0 17		bne $b641	                bne _prefix_semicolon
.b62a					_whole_text:
.b62a	20 7e ba	jsr $ba7e	                jsr ed_have_text
.b62d	a9 01		lda #$01	                lda #01
.b62f	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b631	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b633					_semicolon_entry:
.b633	e8		inx		                inx
.b634	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b635	20 ab ba	jsr $baab	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b638	a9 80		lda #$80	                lda #%10000000
.b63a	04 32		tsb $32		                tsb ed_flags
.b63c	a0 01		ldy #$01	                ldy #01
.b63e	4c 57 b7	jmp $b757	                jmp _check_command
.b641					_prefix_semicolon:
.b641	b2 08		lda ($08)	                lda (cib)
.b643	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b645	d0 0d		bne $b654	                bne _prefix_number
.b647	20 7e ba	jsr $ba7e	                jsr ed_have_text
.b64a	a5 30		lda $30		                lda ed_cur
.b64c	95 02		sta $02,x	                sta 2,x
.b64e	a5 31		lda $31		                lda ed_cur+1
.b650	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b652	80 df		bra $b633	                bra _semicolon_entry
.b654					_prefix_number:
.b654	20 99 a7	jsr $a799	                jsr xt_zero
.b657	20 99 a7	jsr $a799	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b65a	ca		dex		                dex
.b65b	ca		dex		                dex
.b65c	ca		dex		                dex
.b65d	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b65e	a5 08		lda $08		                lda cib
.b660	95 02		sta $02,x	                sta 2,x
.b662	a5 09		lda $09		                lda cib+1
.b664	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b666	a5 0a		lda $0a		                lda ciblen
.b668	95 00		sta $00,x	                sta 0,x
.b66a	a5 0b		lda $0b		                lda ciblen+1
.b66c	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b66e	20 ae a2	jsr $a2ae	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b671	b5 00		lda $00,x	                lda 0,x
.b673	15 01		ora $01,x	                ora 1,x
.b675	d0 24		bne $b69b	                bne _have_unconverted_chars
.b677	e8		inx		                inx
.b678	e8		inx		                inx
.b679	e8		inx		                inx
.b67a	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b67b	20 71 8a	jsr $8a71	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b67e	20 5f 96	jsr $965f	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b681	e8		inx		                inx
.b682	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b683					_line_number_only_from_external:
.b683	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b686	20 89 ba	jsr $ba89	                jsr ed_is_valid_line
.b689	b0 03		bcs $b68e	                bcs +
.b68b	4c 5b ba	jmp $ba5b	                jmp ed_error_2drop
.b68e					+
.b68e	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b691	20 18 bb	jsr $bb18	                jsr ed_para1_to_cur
.b694	a9 80		lda #$80	                lda #%10000000
.b696	04 32		tsb $32		                tsb ed_flags
.b698	4c 36 b9	jmp $b936	                jmp ed_cmd_p_from_external
.b69b					_have_unconverted_chars:
.b69b	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b69e	ca		dex		                dex
.b69f	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6a0	a5 0a		lda $0a		                lda ciblen
.b6a2	95 00		sta $00,x	                sta 0,x
.b6a4	a5 0b		lda $0b		                lda ciblen+1
.b6a6	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6a8	20 bf 8e	jsr $8ebf	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6ab	b5 00		lda $00,x	                lda 0,x
.b6ad	15 01		ora $01,x	                ora 1,x
.b6af	f0 0e		beq $b6bf	                beq _no_command_yet
.b6b1	8a		txa		                txa
.b6b2	18		clc		                clc
.b6b3	69 0a		adc #$0a	                adc #10
.b6b5	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b6b6	a9 80		lda #$80	                lda #%10000000
.b6b8	14 32		trb $32		                trb ed_flags
.b6ba	a0 00		ldy #$00	                ldy #00
.b6bc	4c 57 b7	jmp $b757	                jmp _check_command
.b6bf					_no_command_yet:
.b6bf	e8		inx		                inx
.b6c0	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b6c1	20 61 a3	jsr $a361	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b6c4	20 5f 96	jsr $965f	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b6c7	20 71 8a	jsr $8a71	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b6ca	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b6cc	95 06		sta $06,x	                sta 6,x
.b6ce	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b6d0	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b6d2	e8		inx		                inx
.b6d3	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b6d4	20 83 9a	jsr $9a83	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b6d7	a9 80		lda #$80	                lda #%10000000
.b6d9	04 32		tsb $32		                tsb ed_flags
.b6db					_check_for_para2:
.b6db	a1 02		lda ($02,x)	                lda (2,x)
.b6dd	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b6df	f0 0d		beq $b6ee	                beq _got_comma
.b6e1	38		sec		                sec
.b6e2	a5 0a		lda $0a		                lda ciblen
.b6e4	f5 00		sbc $00,x	                sbc 0,x
.b6e6	a8		tay		                tay
.b6e7	e8		inx		                inx
.b6e8	e8		inx		                inx
.b6e9	e8		inx		                inx
.b6ea	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b6eb	4c 57 b7	jmp $b757	                jmp _check_command
.b6ee					_got_comma:
.b6ee	f6 02		inc $02,x	                inc 2,x
.b6f0	d0 02		bne $b6f4	                bne +
.b6f2	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b6f4					+
.b6f4	b5 01		lda $01,x	                lda 1,x
.b6f6	f0 02		beq $b6fa	                beq +
.b6f8	d6 01		dec $01,x	                dec 1,x
.b6fa					+
.b6fa	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b6fc	a1 02		lda ($02,x)	                lda (2,x)
.b6fe	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b700	d0 14		bne $b716	                bne _para2_not_dollar
.b702	38		sec		                sec
.b703	a5 0a		lda $0a		                lda ciblen
.b705	f5 02		sbc $02,x	                sbc 2,x
.b707	a8		tay		                tay
.b708	c8		iny		                iny
.b709	5a		phy		                phy
.b70a	8a		txa		                txa
.b70b	18		clc		                clc
.b70c	69 06		adc #$06	                adc #06
.b70e	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b70f	20 ab ba	jsr $baab	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b712	7a		ply		                ply
.b713	4c 57 b7	jmp $b757	                jmp _check_command
.b716					_para2_not_dollar:
.b716	20 61 a3	jsr $a361	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b719	20 99 a7	jsr $a799	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b71c	20 99 a7	jsr $a799	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b71f	20 48 9b	jsr $9b48	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b722	20 83 9a	jsr $9a83	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b725	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b728	20 61 a3	jsr $a361	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b72b	20 ae a2	jsr $a2ae	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b72e	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b731	20 83 9a	jsr $9a83	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b734	20 bf 8e	jsr $8ebf	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b737	b5 00		lda $00,x	                lda 0,x
.b739	15 01		ora $01,x	                ora 1,x
.b73b	f0 08		beq $b745	                beq _second_number
.b73d	8a		txa		                txa
.b73e	18		clc		                clc
.b73f	69 0c		adc #$0c	                adc #12
.b741	aa		tax		                tax                     ; back to ( addr-t u-t )
.b742	4c 5f ba	jmp $ba5f	                jmp ed_error
.b745					_second_number:
.b745	e8		inx		                inx
.b746	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b747	38		sec		                sec
.b748	a5 0a		lda $0a		                lda ciblen
.b74a	f5 00		sbc $00,x	                sbc 0,x
.b74c	48		pha		                pha
.b74d	20 a1 a3	jsr $a3a1	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b750	20 71 8a	jsr $8a71	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b753	20 33 96	jsr $9633	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b756	7a		ply		                ply
.b757					_check_command:
.b757	24 32		bit $32		                bit ed_flags
.b759	30 08		bmi $b763	                bmi _check_command_have_arg
.b75b	a5 30		lda $30		                lda ed_cur
.b75d	95 02		sta $02,x	                sta 2,x
.b75f	a5 31		lda $31		                lda ed_cur+1
.b761	95 03		sta $03,x	                sta 3,x
.b763					_check_command_have_arg:
.b763	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b765	85 24		sta $24		                sta tmp1
.b767	da		phx		                phx
.b768	a2 00		ldx #$00	                ldx #00
.b76a					_cmd_loop:
.b76a	bd 43 bb	lda $bb43,x	                lda ed_cmd_list,x
.b76d	f0 07		beq $b776	                beq _illegal_command    ; zero marks end of list
.b76f	c5 24		cmp $24		                cmp tmp1
.b771	f0 07		beq $b77a	                beq _found_cmd
.b773	e8		inx		                inx
.b774	80 f4		bra $b76a	                bra _cmd_loop
.b776					_illegal_command:
.b776	fa		plx		                plx
.b777	4c 5b ba	jmp $ba5b	                jmp ed_error_2drop
.b77a					_found_cmd:
.b77a	8a		txa		                txa
.b77b	0a		asl a		                asl
.b77c	aa		tax		                tax                     ; X * 2 for table
.b77d	7c 4e bb	jmp ($bb4e,x)	                jmp (ed_cmd_table,x)
.b780					ed_next_command:
.b780	e8		inx		                inx
.b781	e8		inx		                inx
.b782	e8		inx		                inx
.b783	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b784					_next_command_empty:
.b784	4c 8e b5	jmp $b58e	                jmp ed_input_loop
.b787					ed_all_done:
.b787	64 0a		stz $0a		                stz ciblen
.b789	64 0b		stz $0b		                stz ciblen+1
.b78b	20 a1 a3	jsr $a3a1	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b78e	a5 33		lda $33		                lda editor3+1
.b790	85 18		sta $18		                sta base
.b792	60		rts		                rts
.b793					ed_cmd_a:
.b793	fa		plx		                plx
.b794	e8		inx		                inx
.b795	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b796					ed_entry_cmd_i:
.b796					ed_cmd_a_have_para:
.b796	20 e1 ba	jsr $bae1	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b799	20 54 89	jsr $8954	                jsr xt_cr
.b79c					_next_string_loop:
.b79c	20 6d ba	jsr $ba6d	                jsr ed_get_input
.b79f	b2 08		lda ($08)	                lda (cib)
.b7a1	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7a3	d0 16		bne $b7bb	                bne _add_line
.b7a5	a4 0a		ldy $0a		                ldy ciblen
.b7a7	c0 01		cpy #$01	                cpy #01
.b7a9	d0 10		bne $b7bb	                bne _add_line
.b7ab	a4 0b		ldy $0b		                ldy ciblen+1
.b7ad	d0 0c		bne $b7bb	                bne _add_line
.b7af	e8		inx		                inx
.b7b0	e8		inx		                inx
.b7b1	a9 40		lda #$40	                lda #%01000000
.b7b3	04 32		tsb $32		                tsb ed_flags
.b7b5	20 54 89	jsr $8954	                jsr xt_cr
.b7b8	4c 8e b5	jmp $b58e	                jmp ed_input_loop
.b7bb					_add_line:
.b7bb	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b7be	20 63 91	jsr $9163	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b7c1	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b7c4	20 71 8f	jsr $8f71	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b7c7	20 5f 87	jsr $875f	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b7ca	20 7e a3	jsr $a37e	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b7cd	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b7d0	20 7e a1	jsr $a17e	                jsr xt_store            ; ! ( addr-t u-t here )
.b7d3	20 63 91	jsr $9163	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b7d6	a5 00		lda $00		                lda cp
.b7d8	18		clc		                clc
.b7d9	69 04		adc #$04	                adc #04
.b7db	85 00		sta $00		                sta cp
.b7dd	90 02		bcc $b7e1	                bcc +
.b7df	e6 01		inc $01		                inc cp+1
.b7e1					+
.b7e1	e6 30		inc $30		                inc ed_cur
.b7e3	d0 02		bne $b7e7	                bne +
.b7e5	e6 31		inc $31		                inc ed_cur+1
.b7e7					+
.b7e7	20 63 91	jsr $9163	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b7ea	20 a0 8d	jsr $8da0	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b7ed	ca		dex		                dex
.b7ee	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b7ef	a5 08		lda $08		                lda cib
.b7f1	95 00		sta $00,x	                sta 0,x
.b7f3	a5 09		lda $09		                lda cib+1
.b7f5	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b7f7	20 9f a1	jsr $a19f	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b7fa	ca		dex		                dex
.b7fb	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b7fc	a5 0a		lda $0a		                lda ciblen
.b7fe	95 00		sta $00,x	                sta 0,x
.b800	a5 0b		lda $0b		                lda ciblen+1
.b802	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b804	20 b3 95	jsr $95b3	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b807	18		clc		                clc
.b808	a5 00		lda $00		                lda cp
.b80a	65 0a		adc $0a		                adc ciblen
.b80c	85 00		sta $00		                sta cp
.b80e	90 06		bcc $b816	                bcc +
.b810	a5 01		lda $01		                lda cp+1
.b812	65 0b		adc $0b		                adc ciblen+1
.b814	85 01		sta $01		                sta cp+1
.b816					+
.b816	20 84 98	jsr $9884	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b819	20 7e a1	jsr $a17e	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b81c	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+
.b81f	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b822	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b825	a5 0a		lda $0a		                lda ciblen
.b827	95 02		sta $02,x	                sta 2,x
.b829	a5 0b		lda $0b		                lda ciblen+1
.b82b	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b82d	20 7e a1	jsr $a17e	                jsr xt_store            ; ! ( addr-t u-t here )
.b830	20 54 89	jsr $8954	                jsr xt_cr
.b833	4c 9c b7	jmp $b79c	                jmp _next_string_loop
.b836					ed_cmd_d:
.b836	fa		plx		                plx
.b837	20 7e ba	jsr $ba7e	                jsr ed_have_text
.b83a	20 d3 ba	jsr $bad3	                jsr ed_no_line_zero
.b83d	b5 00		lda $00,x	                lda 0,x
.b83f	15 01		ora $01,x	                ora 1,x
.b841	d0 08		bne $b84b	                bne +
.b843	20 84 98	jsr $9884	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b846	20 88 b8	jsr $b888	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b849	80 33		bra $b87e	                bra _cmd_d_done
.b84b					+
.b84b	20 89 ba	jsr $ba89	                jsr ed_is_valid_line      ; result is in C flag
.b84e	b0 03		bcs $b853	                bcs _cmd_d_loop
.b850	4c 5b ba	jmp $ba5b	                jmp ed_error_2drop
.b853					_cmd_d_loop:
.b853	20 a9 a3	jsr $a3a9	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b856	20 4e 91	jsr $914e	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b859	b5 00		lda $00,x	                lda 0,x
.b85b	15 01		ora $01,x	                ora 1,x
.b85d	d0 0d		bne $b86c	                bne _cmd_d_done_with_flag
.b85f	e8		inx		                inx
.b860	e8		inx		                inx                     ; Get rid of the flag from >
.b861	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b864	20 88 b8	jsr $b888	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b867	20 02 98	jsr $9802	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b86a	80 e7		bra $b853	                bra _cmd_d_loop
.b86c					_cmd_d_done_with_flag:
.b86c	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b86d	e8		inx		                inx
.b86e	b5 02		lda $02,x	                lda 2,x
.b870	d0 02		bne $b874	                bne +
.b872	d6 03		dec $03,x	                dec 3,x
.b874					+
.b874	d6 02		dec $02,x	                dec 2,x
.b876	b5 02		lda $02,x	                lda 2,x
.b878	85 30		sta $30		                sta ed_cur
.b87a	b5 03		lda $03,x	                lda 3,x
.b87c	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b87e					_cmd_d_done:
.b87e	a9 40		lda #$40	                lda #%01000000
.b880	04 32		tsb $32		                tsb ed_flags
.b882	20 54 89	jsr $8954	                jsr xt_cr
.b885	4c 80 b7	jmp $b780	                jmp ed_next_command
.b888					_cmd_d_common:
.b888	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b88b	20 e1 ba	jsr $bae1	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b88e	20 71 8f	jsr $8f71	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b891	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b894	20 02 98	jsr $9802	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b897	20 e1 ba	jsr $bae1	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b89a	20 7e a1	jsr $a17e	                jsr xt_store            ; ! ( addr-t u-t )
.b89d	60		rts		                rts
.b89e					ed_cmd_equ:
.b89e	fa		plx		                plx
.b89f	a5 2e		lda $2e		                lda ed_head
.b8a1	05 2f		ora $2f		                ora ed_head+1
.b8a3	d0 08		bne $b8ad	                bne _cmd_equ_have_text
.b8a5	ca		dex		                dex
.b8a6	ca		dex		                dex
.b8a7	74 00		stz $00,x	                stz 0,x
.b8a9	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8ab	80 21		bra $b8ce	                bra _cmd_equ_done
.b8ad					_cmd_equ_have_text:
.b8ad	20 d3 ba	jsr $bad3	                jsr ed_no_line_zero
.b8b0	24 32		bit $32		                bit ed_flags
.b8b2	30 0c		bmi $b8c0	                bmi _cmd_equ_have_para
.b8b4	ca		dex		                dex
.b8b5	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b8b6	a5 30		lda $30		                lda ed_cur
.b8b8	95 00		sta $00,x	                sta 0,x
.b8ba	a5 31		lda $31		                lda ed_cur+1
.b8bc	95 01		sta $01,x	                sta 1,x
.b8be	80 0e		bra $b8ce	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b8c0					_cmd_equ_have_para:
.b8c0	b5 00		lda $00,x	                lda 0,x
.b8c2	15 01		ora $01,x	                ora 1,x
.b8c4	d0 05		bne $b8cb	                bne _cmd_equ_two_paras
.b8c6	20 84 98	jsr $9884	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b8c9	80 03		bra $b8ce	                bra _cmd_equ_done
.b8cb					_cmd_equ_two_paras:
.b8cb	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b8ce					_cmd_equ_done:
.b8ce	20 54 89	jsr $8954	                jsr xt_cr               ; number goes on new line
.b8d1	20 1f a5	jsr $a51f	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b8d4	20 54 89	jsr $8954	                jsr xt_cr
.b8d7	4c 80 b7	jmp $b780	                jmp ed_next_command
.b8da					ed_cmd_f:
.b8da	fa		plx		                plx
.b8db	24 32		bit $32		                bit ed_flags
.b8dd	30 17		bmi $b8f6	                bmi _cmd_f_have_para
.b8df	20 54 89	jsr $8954	                jsr xt_cr
.b8e2	20 61 a3	jsr $a361	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b8e5	20 48 9b	jsr $9b48	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b8e8	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b8eb	20 1f a5	jsr $a51f	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b8ee	20 5f 96	jsr $965f	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b8f1	20 83 9a	jsr $9a83	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b8f4	80 11		bra $b907	                bra _cmd_f_done
.b8f6					_cmd_f_have_para:
.b8f6	20 84 98	jsr $9884	                jsr xt_over
.b8f9	20 54 89	jsr $8954	                jsr xt_cr
.b8fc	20 1f a5	jsr $a51f	                jsr xt_u_dot
.b8ff	b5 02		lda $02,x	                lda 2,x
.b901	95 06		sta $06,x	                sta 6,x
.b903	b5 03		lda $03,x	                lda 3,x
.b905	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b907					_cmd_f_done:
.b907	20 54 89	jsr $8954	                jsr xt_cr
.b90a	4c 80 b7	jmp $b780	                jmp ed_next_command
.b90d					ed_cmd_i:
.b90d	fa		plx		                plx
.b90e	e8		inx		                inx
.b90f	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b910	24 32		bit $32		                bit ed_flags
.b912	30 08		bmi $b91c	                bmi _cmd_i_have_para
.b914	a5 30		lda $30		                lda ed_cur
.b916	95 00		sta $00,x	                sta 0,x
.b918	a5 31		lda $31		                lda ed_cur+1
.b91a	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b91c					_cmd_i_have_para:
.b91c	b5 00		lda $00,x	                lda 0,x
.b91e	15 01		ora $01,x	                ora 1,x
.b920	f0 09		beq $b92b	                beq _cmd_i_done
.b922	20 02 98	jsr $9802	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b925	20 99 a7	jsr $a799	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b928	20 09 95	jsr $9509	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b92b					_cmd_i_done:
.b92b	4c 96 b7	jmp $b796	                jmp ed_entry_cmd_i
.b92e					ed_cmd_n:
.b92e	fa		plx		                plx
.b92f	a9 01		lda #$01	                lda #%00000001
.b931	04 32		tsb $32		                tsb ed_flags
.b933	80 05		bra $b93a	                bra ed_cmd_p_entry_for_cmd_n
.b935					ed_cmd_p:
.b935	fa		plx		                plx
.b936					ed_cmd_p_from_external:
.b936	a9 01		lda #$01	                lda #%00000001
.b938	14 32		trb $32		                trb ed_flags
.b93a					ed_cmd_p_entry_for_cmd_n:
.b93a	20 7e ba	jsr $ba7e	                jsr ed_have_text
.b93d	20 d3 ba	jsr $bad3	                jsr ed_no_line_zero
.b940	20 54 89	jsr $8954	                jsr xt_cr
.b943	b5 00		lda $00,x	                lda 0,x
.b945	15 01		ora $01,x	                ora 1,x
.b947	d0 10		bne $b959	                bne _cmd_p_loop
.b949	b5 02		lda $02,x	                lda 2,x
.b94b	85 30		sta $30		                sta ed_cur
.b94d	b5 03		lda $03,x	                lda 3,x
.b94f	85 31		sta $31		                sta ed_cur+1
.b951	20 84 98	jsr $9884	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b954	20 82 b9	jsr $b982	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b957	80 26		bra $b97f	                bra _cmd_p_all_done
.b959					_cmd_p_loop:
.b959	20 a9 a3	jsr $a3a9	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b95c	20 4e 91	jsr $914e	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b95f	b5 00		lda $00,x	                lda 0,x
.b961	15 01		ora $01,x	                ora 1,x
.b963	d0 10		bne $b975	                bne _cmd_p_done
.b965	e8		inx		                inx
.b966	e8		inx		                inx                     ; Get rid of the flag from >
.b967	20 84 98	jsr $9884	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b96a	20 82 b9	jsr $b982	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b96d	f6 02		inc $02,x	                inc 2,x
.b96f	d0 02		bne $b973	                bne +
.b971	f6 03		inc $03,x	                inc 3,x
.b973					+
.b973	80 e4		bra $b959	                bra _cmd_p_loop
.b975					_cmd_p_done:
.b975	e8		inx		                inx
.b976	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b977	b5 00		lda $00,x	                lda 0,x
.b979	85 30		sta $30		                sta ed_cur
.b97b	b5 01		lda $01,x	                lda 1,x
.b97d	85 31		sta $31		                sta ed_cur+1
.b97f					_cmd_p_all_done:
.b97f	4c 80 b7	jmp $b780	                jmp ed_next_command
.b982					_cmd_p_common:
.b982	a5 32		lda $32		                lda ed_flags
.b984	4a		lsr a		                lsr                     ; bit 0 now in carry
.b985	90 0b		bcc $b992	                bcc _cmd_p_common_no_num
.b987	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b98a	20 1f a5	jsr $a51f	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b98d	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b98f	20 e7 8d	jsr $8de7	                jsr emit_a
.b992					_cmd_p_common_no_num:
.b992	20 e1 ba	jsr $bae1	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b995	20 21 bb	jsr $bb21	                jsr ed_print_addr
.b998	60		rts		                rts
.b999					ed_cmd_q:
.b999	fa		plx		                plx
.b99a	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b99c	50 03		bvc $b9a1	                bvc +
.b99e	4c 5b ba	jmp $ba5b	                jmp ed_error_2drop
.b9a1					+
.b9a1	4c 87 b7	jmp $b787	                jmp ed_all_done            ; can't fall thru because of PLX
.b9a4					ed_cmd_qq:
.b9a4	fa		plx		                plx
.b9a5	4c 87 b7	jmp $b787	                jmp ed_all_done
.b9a8					ed_cmd_w:
.b9a8	fa		plx		                plx
.b9a9	20 7e ba	jsr $ba7e	                jsr ed_have_text
.b9ac	24 32		bit $32		                bit ed_flags
.b9ae	30 13		bmi $b9c3	                bmi _cmd_w_have_para
.b9b0	b5 06		lda $06,x	                lda 6,x
.b9b2	15 07		ora $07,x	                ora 7,x
.b9b4	d0 03		bne $b9b9	                bne +
.b9b6	4c 5b ba	jmp $ba5b	                jmp ed_error_2drop
.b9b9					+
.b9b9	b5 06		lda $06,x	                lda 6,x
.b9bb	95 02		sta $02,x	                sta 2,x
.b9bd	b5 07		lda $07,x	                lda 7,x
.b9bf	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b9c1	80 08		bra $b9cb	                bra _cmd_w_para_ready
.b9c3					_cmd_w_have_para:
.b9c3	b5 02		lda $02,x	                lda 2,x
.b9c5	95 06		sta $06,x	                sta 6,x
.b9c7	b5 03		lda $03,x	                lda 3,x
.b9c9	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b9cb					_cmd_w_para_ready:
.b9cb	a9 2e		lda #$2e	                lda #<ed_head
.b9cd	95 00		sta $00,x	                sta 0,x
.b9cf	a9 00		lda #$00	                lda #>ed_head
.b9d1	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b9d3	20 84 98	jsr $9884	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b9d6	20 61 a3	jsr $a361	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b9d9					_cmd_w_loop:
.b9d9	20 71 8f	jsr $8f71	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b9dc	b5 00		lda $00,x	                lda 0,x
.b9de	15 01		ora $01,x	                ora 1,x
.b9e0	f0 55		beq $ba37	                beq _cmd_w_eol
.b9e2	20 a9 a3	jsr $a3a9	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.b9e5	20 93 a4	jsr $a493	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.b9e8	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.b9eb	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.b9ee	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.b9f1	20 71 8f	jsr $8f71	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.b9f4	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.b9f7	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.b9fa	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.b9fd	20 71 8f	jsr $8f71	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba00	20 5f 96	jsr $965f	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba03	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba06	20 48 9b	jsr $9b48	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba09	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba0c	20 61 a3	jsr $a361	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba0f	20 b3 95	jsr $95b3	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba12	20 83 9a	jsr $9a83	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba15	20 19 a4	jsr $a419	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba18	20 5f 96	jsr $965f	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba1b	20 d4 99	jsr $99d4	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba1e	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba21	ca		dex		                dex
.ba22	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba23	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba25	95 00		sta $00,x	                sta 0,x
.ba27	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba29	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba2c	20 7e a1	jsr $a17e	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba2f	20 0e 98	jsr $980e	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba32	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba35	80 a2		bra $b9d9	                bra _cmd_w_loop
.ba37					_cmd_w_eol:
.ba37	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba3a	20 83 9a	jsr $9a83	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba3d	20 41 95	jsr $9541	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba40	b5 00		lda $00,x	                lda 0,x
.ba42	95 04		sta $04,x	                sta 4,x
.ba44	b5 01		lda $01,x	                lda 1,x
.ba46	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba48	20 54 89	jsr $8954	                jsr xt_cr
.ba4b	20 a0 8d	jsr $8da0	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba4e	20 1f a5	jsr $a51f	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba51	20 54 89	jsr $8954	                jsr xt_cr
.ba54	a9 40		lda #$40	                lda #%01000000
.ba56	14 32		trb $32		                trb ed_flags
.ba58	4c 80 b7	jmp $b780	                jmp ed_next_command
.ba5b					ed_error_2drop:
.ba5b	e8		inx		                inx
.ba5c	e8		inx		                inx                     ; drop through to _error_1drop
.ba5d					ed_error_1drop:
.ba5d	e8		inx		                inx
.ba5e	e8		inx		                inx                     ; drop through to _error
.ba5f					ed_error:
.ba5f	20 54 89	jsr $8954	                jsr xt_cr
.ba62	a9 3f		lda #$3f	                lda #'?'
.ba64	20 e7 8d	jsr $8de7	                jsr emit_a
.ba67	20 54 89	jsr $8954	                jsr xt_cr
.ba6a	4c 8e b5	jmp $b58e	                jmp ed_input_loop
.ba6d					ed_get_input:
.ba6d	20 e9 9a	jsr $9ae9	                jsr xt_refill           ;  ( addr-t u-t f )
.ba70	b5 00		lda $00,x	                lda 0,x
.ba72	15 01		ora $01,x	                ora 1,x
.ba74	d0 05		bne $ba7b	                bne +
.ba76	7a		ply		                ply
.ba77	7a		ply		                ply
.ba78	4c 5d ba	jmp $ba5d	                jmp ed_error_1drop
.ba7b					+
.ba7b	e8		inx		                inx
.ba7c	e8		inx		                inx
.ba7d	60		rts		                rts
.ba7e					ed_have_text:
.ba7e	a5 2e		lda $2e		                lda ed_head
.ba80	05 2f		ora $2f		                ora ed_head+1
.ba82	d0 04		bne $ba88	                bne +
.ba84	7a		ply		                ply
.ba85	7a		ply		                ply
.ba86	80 d7		bra $ba5f	                bra ed_error
.ba88					+
.ba88	60		rts		                rts
.ba89					ed_is_valid_line:
.ba89	38		sec		                sec                             ; default is legal line number
.ba8a	b5 00		lda $00,x	                lda 0,x
.ba8c	15 01		ora $01,x	                ora 1,x
.ba8e	f0 19		beq $baa9	                beq _is_valid_line_nope_zero    ; ( n )
.ba90	20 a0 8d	jsr $8da0	                jsr xt_dup                      ; DUP ( n n )
.ba93	20 ab ba	jsr $baab	                jsr ed_last_line                  ; ( n n last )
.ba96	20 9f a1	jsr $a19f	                jsr xt_swap                     ; SWAP ( n last n )
.ba99	20 59 93	jsr $9359	                jsr xt_less_than                ; < ( n f )
.ba9c	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ba9e	15 01		ora $01,x	                ora 1,x
.baa0	d0 05		bne $baa7	                bne _is_valid_line_too_small
.baa2	e8		inx		                inx
.baa3	e8		inx		                inx                     ; DROP flag ( n )
.baa4	38		sec		                sec                     ; Who knows what's happened to C by now
.baa5	80 03		bra $baaa	                bra _is_valid_line_done ; only one exit from this routine
.baa7					_is_valid_line_too_small:
.baa7	e8		inx		                inx
.baa8	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.baa9					_is_valid_line_nope_zero:
.baa9	18		clc		                clc                     ; drop through to _is_valid_line_done
.baaa					_is_valid_line_done:
.baaa	60		rts		                rts
.baab					ed_last_line:
.baab	64 24		stz $24		                stz tmp1
.baad	64 25		stz $25		                stz tmp1+1
.baaf	ca		dex		                dex
.bab0	ca		dex		                dex                     ; ( ? )
.bab1	a9 2e		lda #$2e	                lda #<ed_head
.bab3	95 00		sta $00,x	                sta 0,x
.bab5	a9 00		lda #$00	                lda #>ed_head
.bab7	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.bab9					_last_line_loop:
.bab9	20 71 8f	jsr $8f71	                jsr xt_fetch            ; ( addr | 0 )
.babc	b5 00		lda $00,x	                lda 0,x
.babe	15 01		ora $01,x	                ora 1,x
.bac0	f0 08		beq $baca	                beq _last_line_done
.bac2	e6 24		inc $24		                inc tmp1
.bac4	d0 02		bne $bac8	                bne +
.bac6	e6 25		inc $25		                inc tmp1+1
.bac8					+
.bac8	80 ef		bra $bab9	                bra _last_line_loop
.baca					_last_line_done:
.baca	a5 24		lda $24		                lda tmp1
.bacc	95 00		sta $00,x	                sta 0,x
.bace	a5 25		lda $25		                lda tmp1+1
.bad0	95 01		sta $01,x	                sta 1,x                 ; ( u )
.bad2	60		rts		                rts
.bad3					ed_no_line_zero:
.bad3	b5 02		lda $02,x	                lda 2,x
.bad5	15 03		ora $03,x	                ora 3,x
.bad7	d0 07		bne $bae0	                bne _no_line_zero_done
.bad9	24 32		bit $32		                bit ed_flags
.badb	10 03		bpl $bae0	                bpl _no_line_zero_done
.badd	4c 5b ba	jmp $ba5b	                jmp ed_error_2drop
.bae0					_no_line_zero_done:
.bae0	60		rts		                rts
.bae1					ed_num_to_addr:
.bae1	ca		dex		                dex
.bae2	ca		dex		                dex                     ; ( u ? )
.bae3	a9 2e		lda #$2e	                lda #<ed_head
.bae5	95 00		sta $00,x	                sta 0,x
.bae7	a9 00		lda #$00	                lda #>ed_head
.bae9	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.baeb	b5 02		lda $02,x	                lda 2,x
.baed	15 03		ora $03,x	                ora 3,x
.baef	d0 05		bne $baf6	                bne _num_to_addr_loop
.baf1	20 33 96	jsr $9633	                jsr xt_nip              ; ( addr-h )
.baf4	80 21		bra $bb17	                bra _num_to_addr_done
.baf6					_num_to_addr_loop:
.baf6	20 71 8f	jsr $8f71	                jsr xt_fetch            ; @ ( u addr1 )
.baf9	b5 00		lda $00,x	                lda 0,x
.bafb	15 01		ora $01,x	                ora 1,x
.bafd	d0 05		bne $bb04	                bne +
.baff	20 33 96	jsr $9633	                jsr xt_nip              ; NIP ( addr1 )
.bb02	80 13		bra $bb17	                bra _num_to_addr_done
.bb04					+
.bb04	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( addr1 u )
.bb07	20 02 98	jsr $9802	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb0a	b5 00		lda $00,x	                lda 0,x
.bb0c	15 01		ora $01,x	                ora 1,x
.bb0e	f0 05		beq $bb15	                beq _num_to_addr_finished
.bb10	20 9f a1	jsr $a19f	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb13	80 e1		bra $baf6	                bra _num_to_addr_loop
.bb15					_num_to_addr_finished:
.bb15	e8		inx		                inx
.bb16	e8		inx		                inx                     ; ( addr )
.bb17					_num_to_addr_done:
.bb17	60		rts		                rts
.bb18					ed_para1_to_cur:
.bb18	b5 02		lda $02,x	                lda 2,x
.bb1a	85 30		sta $30		                sta ed_cur
.bb1c	b5 03		lda $03,x	                lda 3,x
.bb1e	85 31		sta $31		                sta ed_cur+1
.bb20	60		rts		                rts
.bb21					ed_print_addr:
.bb21	20 0e 98	jsr $980e	                jsr xt_one_plus
.bb24	20 0e 98	jsr $980e	                jsr xt_one_plus         ; ( addr+2 )
.bb27	20 a0 8d	jsr $8da0	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb2a	20 0e 98	jsr $980e	                jsr xt_one_plus
.bb2d	20 0e 98	jsr $980e	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb30	20 71 8f	jsr $8f71	                jsr xt_fetch            ; ( addr+2 u-s )
.bb33	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( u-s addr+2 )
.bb36	20 71 8f	jsr $8f71	                jsr xt_fetch            ; ( u-s addr-s )
.bb39	20 9f a1	jsr $a19f	                jsr xt_swap             ; ( addr-s u-s )
.bb3c	20 f4 a4	jsr $a4f4	                jsr xt_type
.bb3f	20 54 89	jsr $8954	                jsr xt_cr
.bb42	60		rts		                rts
>bb43	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb4b	71 51 00
.bb4e					ed_cmd_table:
>bb4e	93 b7 da b8 0d b9 36 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb56	35 b9 2e b9
>bb5a	9e b8 a8 b9 99 b9 a4 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb62					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb62					forth_words_start:
>bb62	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb6a	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb7a	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bb8a	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bb9a	20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bbaa	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bbba	2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bbca	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bbda	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bbea	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bbfa	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc0a	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc1a	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc2a	65 78 69 74 29 20 63 72 20
.bc33					forth_words_end:
.bc33					user_words_start:
>bc33	20 3a 20 62 6c 6b 72 77		.binary "user_words.asc"
>bc3b	20 2d 72 6f 74 20 24 63 30 31 34 20 21 20 24 63
>bc4b	30 31 32 20 21 20 24 63 30 31 30 20 63 21 20 3b
>bc5b	20 3a 6e 6f 6e 61 6d 65 20 2d 31 20 24 63 30 31
>bc6b	31 20 63 21 20 30 20 24 63 30 31 30 20 63 21 20
>bc7b	24 63 30 31 31 20 63 40 20 30 3d 20 69 66 20 30
>bc8b	20 24 34 30 30 20 31 20 62 6c 6b 72 77 20 24 34
>bc9b	30 30 20 40 20 24 34 36 35 34 20 3d 20 69 66 20
>bcab	24 34 30 32 20 61 73 63 69 69 7a 3e 20 65 76 61
>bcbb	6c 75 61 74 65 20 65 6c 73 65 20 2e 22 20 62 61
>bccb	64 20 62 6f 6f 74 20 62 6c 6f 63 6b 22 20 43 52
>bcdb	20 74 68 65 6e 20 65 6c 73 65 20 2e 22 20 6e 6f
>bceb	20 62 6c 6f 63 6b 20 64 65 76 69 63 65 22 20 43
>bcfb	52 20 74 68 65 6e 20 3b 20 65 78 65 63 75 74 65
>bd0b	20
.bd0c					user_words_end:

;******  Processing file: platform/../headers.asm

.bd0c					dictionary_start:
.bd0c					nt_drop:
>bd0c	04 10				        .byte 4, UF
>bd0e	18 bd 1f 8d 24 8d		        .word nt_dup, xt_drop, z_drop
>bd14	64 72 6f 70			        .text "drop"
.bd18					nt_dup:
>bd18	03 10				        .byte 3, UF
>bd1a	23 bd a0 8d ad 8d		        .word nt_swap, xt_dup, z_dup
>bd20	64 75 70			        .text "dup"
.bd23					nt_swap:
>bd23	04 10				        .byte 4, UF
>bd25	2f bd 9f a1 b2 a1		        .word nt_store, xt_swap, z_swap
>bd2b	73 77 61 70			        .text "swap"
.bd2f					nt_store:
>bd2f	01 10				        .byte 1, UF
>bd31	38 bd 7e a1 93 a1		        .word nt_fetch, xt_store, z_store
>bd37	21				        .text "!"
.bd38					nt_fetch:
>bd38	01 10				        .byte 1, UF
>bd3a	41 bd 71 8f 83 8f		        .word nt_over, xt_fetch, z_fetch
>bd40	40				        .text "@"
.bd41					nt_over:
>bd41	04 10				        .byte 4, UF
>bd43	4d bd 84 98 91 98		        .word nt_to_r, xt_over, z_over
>bd49	6f 76 65 72			        .text "over"
.bd4d					nt_to_r:
>bd4d	02 11				        .byte 2, CO+UF ; native is special case
>bd4f	57 bd 61 a3 74 a3		        .word nt_r_from, xt_to_r, z_to_r
>bd55	3e 72				        .text ">r"
.bd57					nt_r_from:
>bd57	02 01				        .byte 2, CO    ; native is special case
>bd59	61 bd 83 9a 93 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bd5f	72 3e				        .text "r>"
.bd61					nt_r_fetch:
>bd61	02 01				        .byte 2, CO    ; native is special case
>bd63	6b bd 6e 9a 82 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bd69	72 40				        .text "r@"
.bd6b					nt_nip:
>bd6b	03 10				        .byte 3, UF
>bd6d	76 bd 33 96 40 96		        .word nt_rot, xt_nip, z_nip
>bd73	6e 69 70			        .text "nip"
.bd76					nt_rot:
>bd76	03 10				        .byte 3, UF
>bd78	81 bd 48 9b 63 9b		        .word nt_not_rote, xt_rot, z_rot
>bd7e	72 6f 74			        .text "rot"
.bd81					nt_not_rote:
>bd81	04 10				        .byte 4, UF
>bd83	8d bd 5f 96 7a 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bd89	2d 72 6f 74			        .text "-rot"
.bd8d					nt_tuck:
>bd8d	04 10				        .byte 4, UF
>bd8f	99 bd 7e a3 97 a3		        .word nt_comma, xt_tuck, z_tuck
>bd95	74 75 63 6b			        .text "tuck"
.bd99					nt_comma:
>bd99	01 10				        .byte 1, UF
>bd9b	a2 bd 5f 87 78 87		        .word nt_c_fetch, xt_comma, z_comma
>bda1	2c				        .text ","
.bda2					nt_c_fetch:
>bda2	02 10				        .byte 2, UF
>bda4	ac bd fc 85 05 86		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bdaa	63 40				        .text "c@"
.bdac					nt_c_store:
>bdac	02 10				        .byte 2, UF
>bdae	b6 bd 06 86 11 86		        .word nt_plus_store, xt_c_store, z_c_store
>bdb4	63 21				        .text "c!"
.bdb6					nt_plus_store:
>bdb6	02 10				        .byte 2, UF
>bdb8	c0 bd e7 99 06 9a		        .word nt_execute, xt_plus_store, z_plus_store
>bdbe	2b 21				        .text "+!"
.bdc0					nt_execute:
>bdc0	07 10				        .byte 7, UF
>bdc2	cf bd 2e 8f 34 8f		        .word nt_emit, xt_execute, z_execute
>bdc8	65 78 65 63 75 74 65		        .text "execute"
.bdcf					nt_emit:
>bdcf	04 18				        .byte 4, NN+UF
>bdd1	db bd e0 8d ea 8d		        .word nt_type, xt_emit, z_emit
>bdd7	65 6d 69 74			        .text "emit"
.bddb					nt_type:
>bddb	04 10				        .byte 4, UF
>bddd	e7 bd f4 a4 1e a5		        .word nt_dot, xt_type, z_type
>bde3	74 79 70 65			        .text "type"
.bde7					nt_dot:
>bde7	01 10				        .byte 1, UF
>bde9	f0 bd 27 8c 48 8c		        .word nt_u_dot, xt_dot, z_dot
>bdef	2e				        .text "."
.bdf0					nt_u_dot:
>bdf0	02 10				        .byte 2, UF
>bdf2	fa bd 1f a5 2a a5		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bdf8	75 2e				        .text "u."
.bdfa					nt_u_dot_r:
>bdfa	03 10				        .byte 3, UF
>bdfc	05 be 2b a5 4c a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>be02	75 2e 72			        .text "u.r"
.be05					nt_dot_r:
>be05	02 10				        .byte 2, UF
>be07	0f be 63 8c 90 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>be0d	2e 72				        .text ".r"
.be0f					nt_d_dot:
>be0f	02 10				        .byte 2, UF
>be11	19 be d5 8c f3 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>be17	64 2e				        .text "d."
.be19					nt_d_dot_r:
>be19	03 10				        .byte 3, UF
>be1b	24 be f4 8c 1e 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>be21	64 2e 72			        .text "d.r"
.be24					nt_ud_dot:
>be24	03 10				        .byte 3, UF
>be26	2f be 79 a5 8b a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>be2c	75 64 2e			        .text "ud."
.be2f					nt_ud_dot_r:
>be2f	04 10				        .byte 4, UF
>be31	3b be 8c a5 aa a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>be37	75 64 2e 72			        .text "ud.r"
.be3b					nt_question:
>be3b	01 00				        .byte 1, 0
>be3d	44 be 53 9a 59 9a		        .word nt_false, xt_question, z_question
>be43	3f				        .text "?"
.be44					nt_false:
>be44	05 00				        .byte 5, 0
>be46	51 be 6a 8f 70 8f		        .word nt_true, xt_false, z_false
>be4c	66 61 6c 73 65			        .text "false"
.be51					nt_true:
>be51	04 00				        .byte 4, 0
>be53	5d be 75 a3 7d a3		        .word nt_space, xt_true, z_true
>be59	74 72 75 65			        .text "true"
.be5d					nt_space:
>be5d	05 00				        .byte 5, 0
>be5f	6a be 0f a1 14 a1		        .word nt_zero, xt_space, z_space
>be65	73 70 61 63 65			        .text "space"
.be6a					nt_zero:
>be6a	01 00				        .byte 1, 0
>be6c	73 be 99 a7 9f a7		        .word nt_one, xt_zero, z_zero
>be72	30				        .text "0"
.be73					nt_one:
>be73	01 00				        .byte 1, 0
>be75	7c be f9 97 01 98		        .word nt_two, xt_one, z_one
>be7b	31				        .text "1"
.be7c					nt_two:
>be7c	01 00				        .byte 1, 0
>be7e	85 be 98 a3 a0 a3		        .word nt_two_dup, xt_two, z_two
>be84	32				        .text "2"
.be85					nt_two_dup:
>be85	04 10				        .byte 4, UF
>be87	91 be a9 a3 c0 a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>be8d	32 64 75 70			        .text "2dup"
.be91					nt_question_dup:
>be91	04 10				        .byte 4, UF
>be93	9d be 5a 9a 6d 9a		        .word nt_plus, xt_question_dup, z_question_dup
>be99	3f 64 75 70			        .text "?dup"
.be9d					nt_plus:
>be9d	01 10				        .byte 1, UF
>be9f	a6 be d4 99 e6 99		        .word nt_minus, xt_plus, z_plus
>bea5	2b				        .text "+"
.bea6					nt_minus:
>bea6	01 10				        .byte 1, UF
>bea8	af be 41 95 53 95		        .word nt_one_minus, xt_minus, z_minus
>beae	2d				        .text "-"
.beaf					nt_one_minus:
>beaf	02 10				        .byte 2, UF
>beb1	b9 be 02 98 0d 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>beb7	31 2d				        .text "1-"
.beb9					nt_one_plus:
>beb9	02 10				        .byte 2, UF
>bebb	c3 be 0e 98 17 98		        .word nt_two_star, xt_one_plus, z_one_plus
>bec1	31 2b				        .text "1+"
.bec3					nt_two_star:
>bec3	02 10				        .byte 2, UF
>bec5	cd be 41 a4 48 a4		        .word nt_two_slash, xt_two_star, z_two_star
>becb	32 2a				        .text "2*"
.becd					nt_two_slash:
>becd	02 10				        .byte 2, UF
>becf	d7 be 36 a4 40 a4		        .word nt_abs, xt_two_slash, z_two_slash
>bed5	32 2f				        .text "2/"
.bed7					nt_abs:
>bed7	03 10				        .byte 3, UF
>bed9	e2 be 2a 81 3e 81		        .word nt_dabs, xt_abs, z_abs
>bedf	61 62 73			        .text "abs"
.bee2					nt_dabs:
>bee2	04 10				        .byte 4, UF
>bee4	ee be 77 8a 95 8a		        .word nt_and, xt_dabs, z_dabs
>beea	64 61 62 73			        .text "dabs"
.beee					nt_and:
>beee	03 10				        .byte 3, UF
>bef0	f9 be 2f 83 40 83		        .word nt_or, xt_and, z_and
>bef6	61 6e 64			        .text "and"
.bef9					nt_or:
>bef9	02 10				        .byte 2, UF
>befb	03 bf 24 98 35 98		        .word nt_xor, xt_or, z_or
>bf01	6f 72				        .text "or"
.bf03					nt_xor:
>bf03	03 10				        .byte 3, UF
>bf05	0e bf 87 a7 98 a7		        .word nt_rshift, xt_xor, z_xor
>bf0b	78 6f 72			        .text "xor"
.bf0e					nt_rshift:
>bf0e	06 10				        .byte 6, UF
>bf10	1c bf 64 9b 77 9b		        .word nt_lshift, xt_rshift, z_rshift
>bf16	72 73 68 69 66 74		        .text "rshift"
.bf1c					nt_lshift:
>bf1c	06 10				        .byte 6, UF
>bf1e	2a bf 6b 94 7e 94		        .word nt_pick, xt_lshift, z_lshift
>bf24	6c 73 68 69 66 74		        .text "lshift"
.bf2a					nt_pick:
>bf2a	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bf2c	36 bf c3 99 d3 99		        .word nt_char, xt_pick, z_pick
>bf32	70 69 63 6b			        .text "pick"
.bf36					nt_char:
>bf36	04 00				        .byte 4, 0
>bf38	42 bf 22 86 38 86		        .word nt_bracket_char, xt_char, z_char
>bf3e	63 68 61 72			        .text "char"
.bf42					nt_bracket_char:
>bf42	06 05				        .byte 6, CO+IM
>bf44	50 bf 88 85 8e 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bf4a	5b 63 68 61 72 5d		        .text "[char]"
.bf50					nt_char_plus:
>bf50	05 00				        .byte 5, 0
>bf52	5d bf 0e 98 17 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bf58	63 68 61 72 2b			        .text "char+"
.bf5d					nt_chars:
>bf5d	05 12				        .byte 5, AN+UF   ; deleted during compile
>bf5f	6a bf 39 86 3c 86		        .word nt_cells, xt_chars, z_chars
>bf65	63 68 61 72 73			        .text "chars"
.bf6a					nt_cells:
>bf6a	05 00				        .byte 5, 0
>bf6c	77 bf 41 a4 48 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bf72	63 65 6c 6c 73			        .text "cells"
.bf77					nt_cell_plus:
>bf77	05 10				        .byte 5, UF
>bf79	84 bf 12 86 21 86		        .word nt_here, xt_cell_plus, z_cell_plus
>bf7f	63 65 6c 6c 2b			        .text "cell+"
.bf84					nt_here:
>bf84	04 00				        .byte 4, 0
>bf86	90 bf 63 91 6d 91		        .word nt_equal, xt_here, z_here
>bf8c	68 65 72 65			        .text "here"
.bf90					nt_equal:
>bf90	01 10				        .byte 1, UF
>bf92	99 bf bf 8e da 8e		        .word nt_not_equals, xt_equal, z_equal
>bf98	3d				        .text "="
.bf99					nt_not_equals:
>bf99	02 10				        .byte 2, UF
>bf9b	a3 bf 41 96 5e 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bfa1	3c 3e				        .text "<>"
.bfa3					nt_less_than:
>bfa3	01 10				        .byte 1, UF
>bfa5	ac bf 59 93 6d 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bfab	3c				        .text "<"
.bfac					nt_u_less_than:
>bfac	02 10				        .byte 2, UF
>bfae	b6 bf 63 a5 78 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bfb4	75 3c				        .text "u<"
.bfb6					nt_u_greater_than:
>bfb6	02 10				        .byte 2, UF
>bfb8	c0 bf 4d a5 62 a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bfbe	75 3e				        .text "u>"
.bfc0					nt_greater_than:
>bfc0	01 10				        .byte 1, UF
>bfc2	c9 bf 4e 91 62 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bfc8	3e				        .text ">"
.bfc9					nt_zero_equal:
>bfc9	02 10				        .byte 2, UF
>bfcb	d3 bf a0 a7 b3 a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bfd1	30 3d				        .text "0="
.bfd3					nt_zero_unequal:
>bfd3	03 10				        .byte 3, UF
>bfd5	de bf d8 a7 e9 a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bfdb	30 3c 3e			        .text "0<>"
.bfde					nt_zero_greater:
>bfde	02 10				        .byte 2, UF
>bfe0	e8 bf b4 a7 c7 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bfe6	30 3e				        .text "0>"
.bfe8					nt_zero_less:
>bfe8	02 10				        .byte 2, UF
>bfea	f2 bf c8 a7 d7 a7		        .word nt_min, xt_zero_less, z_zero_less
>bff0	30 3c				        .text "0<"
.bff2					nt_min:
>bff2	03 10				        .byte 3, UF
>bff4	fd bf 25 95 40 95		        .word nt_max, xt_min, z_min
>bffa	6d 69 6e			        .text "min"
.bffd					nt_max:
>bffd	03 10				        .byte 3, UF
>bfff	08 c0 09 95 24 95		        .word nt_two_drop, xt_max, z_max
>c005	6d 61 78			        .text "max"
.c008					nt_two_drop:
>c008	05 10				        .byte 5, UF
>c00a	15 c0 a1 a3 a8 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>c010	32 64 72 6f 70			        .text "2drop"
.c015					nt_two_swap:
>c015	05 10				        .byte 5, UF
>c017	22 c0 6f a4 92 a4		        .word nt_two_over, xt_two_swap, z_two_swap
>c01d	32 73 77 61 70			        .text "2swap"
.c022					nt_two_over:
>c022	05 10				        .byte 5, UF
>c024	2f c0 e3 a3 fa a3		        .word nt_two_store, xt_two_over, z_two_over
>c02a	32 6f 76 65 72			        .text "2over"
.c02f					nt_two_store:
>c02f	02 10				        .byte 2, UF
>c031	39 c0 49 a4 6e a4		        .word nt_two_fetch, xt_two_store, z_two_store
>c037	32 21				        .text "2!"
.c039					nt_two_fetch:
>c039	02 10				        .byte 2, UF
>c03b	43 c0 c1 a3 e2 a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>c041	32 40				        .text "2@"
.c043					nt_two_variable:
>c043	09 00				        .byte 9, 0
>c045	54 c0 e5 a4 f3 a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>c04b	32 76 61 72 69 61 62 6c		        .text "2variable"
>c053	65
.c054					nt_two_constant:
>c054	09 10				        .byte 9, UF
>c056	65 c0 b3 a4 d7 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>c05c	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>c064	74
.c065					nt_two_literal:
>c065	08 14				        .byte 8, UF+IM
>c067	75 c0 d8 a4 e4 a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>c06d	32 6c 69 74 65 72 61 6c		        .text "2literal"
.c075					nt_two_r_fetch:
>c075	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>c077	80 c0 fb a3 18 a4		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>c07d	32 72 40			        .text "2r@"
.c080					nt_two_r_from:
>c080	03 01				        .byte 3, CO             ; native is special case
>c082	8b c0 19 a4 35 a4		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>c088	32 72 3e			        .text "2r>"
.c08b					nt_two_to_r:
>c08b	03 11				        .byte 3, CO+UF          ; native is special case
>c08d	96 c0 93 a4 b2 a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>c093	32 3e 72			        .text "2>r"
.c096					nt_invert:
>c096	06 10				        .byte 6, UF
>c098	a4 c0 dc 92 eb 92		        .word nt_negate, xt_invert, z_invert
>c09e	69 6e 76 65 72 74		        .text "invert"
.c0a4					nt_negate:
>c0a4	06 10				        .byte 6, UF
>c0a6	b2 c0 14 96 24 96		        .word nt_dnegate, xt_negate, z_negate
>c0ac	6e 65 67 61 74 65		        .text "negate"
.c0b2					nt_dnegate:
>c0b2	07 10				        .byte 7, UF
>c0b4	c1 c0 32 8b 4c 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>c0ba	64 6e 65 67 61 74 65		        .text "dnegate"
.c0c1					nt_c_comma:
>c0c1	02 10				        .byte 2, UF
>c0c3	cb c0 f1 85 fb 85		        .word nt_bounds, xt_c_comma, z_c_comma
>c0c9	63 2c				        .text "c,"
.c0cb					nt_bounds:
>c0cb	06 10				        .byte 6, UF
>c0cd	d9 c0 6f 85 87 85		        .word nt_spaces, xt_bounds, z_bounds
>c0d3	62 6f 75 6e 64 73		        .text "bounds"
.c0d9					nt_spaces:
>c0d9	06 10				        .byte 6, UF
>c0db	e7 c0 15 a1 50 a1		        .word nt_bl, xt_spaces, z_spaces
>c0e1	73 70 61 63 65 73		        .text "spaces"
.c0e7					nt_bl:
>c0e7	02 00				        .byte 2, 0
>c0e9	f1 c0 8b 83 93 83		        .word nt_minus_trailing, xt_bl, z_bl
>c0ef	62 6c				        .text "bl"
.c0f1					nt_minus_trailing:
>c0f1	09 10				        .byte 9, UF
>c0f3	02 c1 6d 95 a9 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c0f9	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c101	67
.c102					nt_minus_leading:
>c102	08 10				        .byte 8, UF
>c104	12 c1 54 95 6c 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c10a	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c112					nt_slash_string:
>c112	07 10				        .byte 7, UF
>c114	21 c1 0a a0 29 a0		        .word nt_refill, xt_slash_string, z_slash_string
>c11a	2f 73 74 72 69 6e 67		        .text "/string"
.c121					nt_refill:
>c121	06 00				        .byte 6, 0
>c123	2f c1 e9 9a 2a 9b		        .word nt_accept, xt_refill, z_refill
>c129	72 65 66 69 6c 6c		        .text "refill"
.c12f					nt_accept:
>c12f	06 18				        .byte 6, UF+NN
>c131	3d c1 3f 81 37 82		        .word nt_input_to_r, xt_accept, z_accept
>c137	61 63 63 65 70 74		        .text "accept"
.c13d					nt_input_to_r:
>c13d	07 08				        .byte 7, NN
>c13f	4c c1 53 92 68 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c145	69 6e 70 75 74 3e 72		        .text "input>r"
.c14c					nt_r_to_input:
>c14c	07 08				        .byte 7, NN
>c14e	5b c1 94 9a ab 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c154	72 3e 69 6e 70 75 74		        .text "r>input"
.c15b					nt_unused:
>c15b	06 00				        .byte 6, 0
>c15d	69 c1 45 a6 54 a6		        .word nt_depth, xt_unused, z_unused
>c163	75 6e 75 73 65 64		        .text "unused"
.c169					nt_depth:
>c169	05 00				        .byte 5, 0
>c16b	76 c1 e7 8a f5 8a		        .word nt_key, xt_depth, z_depth
>c171	64 65 70 74 68			        .text "depth"
.c176					nt_key:
>c176	03 00				        .byte 3, 0
>c178	81 c1 1f 93 28 93		        .word nt_allot, xt_key, z_key
>c17e	6b 65 79			        .text "key"
.c181					nt_allot:
>c181	05 10				        .byte 5, UF
>c183	8e c1 9c 82 04 83		        .word nt_create, xt_allot, z_allot
>c189	61 6c 6c 6f 74			        .text "allot"
.c18e					nt_create:
>c18e	06 00				        .byte 6, 0
>c190	9c c1 5a 89 2e 8a		        .word nt_does, xt_create, z_create
>c196	63 72 65 61 74 65		        .text "create"
.c19c					nt_does:
>c19c	05 05				        .byte 5, CO+IM
>c19e	a9 c1 e6 8b f4 8b		        .word nt_variable, xt_does, z_does
>c1a4	64 6f 65 73 3e			        .text "does>"
.c1a9					nt_variable:
>c1a9	08 00				        .byte 8, 0
>c1ab	b9 c1 69 a6 81 a6		        .word nt_constant, xt_variable, z_variable
>c1b1	76 61 72 69 61 62 6c 65		        .text "variable"
.c1b9					nt_constant:
>c1b9	08 10				        .byte 8, UF
>c1bb	c9 c1 02 89 3f 89		        .word nt_value, xt_constant, z_constant
>c1c1	63 6f 6e 73 74 61 6e 74		        .text "constant"
.c1c9					nt_value:
>c1c9	05 10				        .byte 5, UF
>c1cb	d6 c1 02 89 3f 89		        .word nt_to, xt_constant, z_constant
>c1d1	76 61 6c 75 65			        .text "value"
.c1d6					nt_to:
>c1d6	02 0c				        .byte 2, NN+IM
>c1d8	e0 c1 22 a2 7d a2		        .word nt_s_to_d, xt_to, z_to
>c1de	74 6f				        .text "to"
.c1e0					nt_s_to_d:
>c1e0	03 10				        .byte 3, UF
>c1e2	eb c1 9d 9e ae 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c1e8	73 3e 64			        .text "s>d"
.c1eb					nt_d_to_s:
>c1eb	03 10				        .byte 3, UF
>c1ed	f6 c1 71 8a 76 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c1f3	64 3e 73			        .text "d>s"
.c1f6					nt_d_minus:
>c1f6	02 10				        .byte 2, UF
>c1f8	00 c2 2f 8a 4f 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c1fe	64 2d				        .text "d-"
.c200					nt_d_plus:
>c200	02 10				        .byte 2, UF
>c202	0a c2 50 8a 70 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c208	64 2b				        .text "d+"
.c20a					nt_erase:
>c20a	05 00				        .byte 5, 0      ; underflow checked by FILL
>c20c	17 c2 e5 8e 2d 8f		        .word nt_blank, xt_erase, z_erase
>c212	65 72 61 73 65			        .text "erase"
.c217					nt_blank:
>c217	05 00				        .byte 5, 0     ; underflow checked by FILL
>c219	24 c2 db 8e 2d 8f		        .word nt_fill, xt_blank, z_blank
>c21f	62 6c 61 6e 6b			        .text "blank"
.c224					nt_fill:
>c224	04 10				        .byte 4, UF
>c226	30 c2 eb 8e 2d 8f		        .word nt_find_name, xt_fill, z_fill
>c22c	66 69 6c 6c			        .text "fill"
.c230					nt_find_name:
>c230	09 10				        .byte 9, UF
>c232	41 c2 cc 8f 77 90		        .word nt_tick, xt_find_name, z_find_name
>c238	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c240	65
.c241					nt_tick:
>c241	01 00				        .byte 1, 0
>c243	4a c2 02 a2 21 a2		        .word nt_bracket_tick, xt_tick, z_tick
>c249	27				        .text "'"
.c24a					nt_bracket_tick:
>c24a	03 05				        .byte 3, CO+IM
>c24c	55 c2 8f 85 95 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c252	5b 27 5d			        .text "[']"
.c255					nt_name_to_int:
>c255	08 10				        .byte 8, UF
>c257	65 c2 d2 95 ee 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c25d	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c265					nt_int_to_name:
>c265	08 10				        .byte 8, UF
>c267	75 c2 69 92 db 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c26d	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c275					nt_name_to_string:
>c275	0b 10				        .byte 11, UF
>c277	88 c2 ef 95 08 96		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c27d	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c285	69 6e 67
.c288					nt_to_body:
>c288	05 10				        .byte 5, UF
>c28a	95 c2 7e a2 a2 a2		        .word nt_defer, xt_to_body, z_to_body
>c290	3e 62 6f 64 79			        .text ">body"
.c295					nt_defer:
>c295	05 00				        .byte 5, 0
>c297	a2 c2 9d 8a cf 8a		        .word nt_latestxt, xt_defer, z_defer
>c29d	64 65 66 65 72			        .text "defer"
.c2a2					nt_latestxt:
>c2a2	08 00				        .byte 8, 0
>c2a4	b2 c2 3a 93 40 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c2aa	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c2b2					nt_latestnt:
>c2b2	08 00				        .byte 8, 0
>c2b4	c2 c2 2c 93 39 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c2ba	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c2c2					nt_parse_name:
>c2c2	0a 08				        .byte 10, NN
>c2c4	d4 c2 d0 98 c2 99		        .word nt_parse, xt_parse_name, z_parse_name
>c2ca	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c2d2	6d 65
.c2d4					nt_parse:
>c2d4	05 10				        .byte 5, UF
>c2d6	e1 c2 2b 99 c2 99		        .word nt_execute_parsing, xt_parse, z_parse
>c2dc	70 61 72 73 65			        .text "parse"
.c2e1					nt_execute_parsing:
>c2e1	0f 10				        .byte 15, UF
>c2e3	f8 c2 42 8f 68 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c2e9	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c2f1	70 61 72 73 69 6e 67
.c2f8					nt_source:
>c2f8	06 00				        .byte 6, 0
>c2fa	06 c3 ef a0 03 a1		        .word nt_source_id, xt_source, z_source
>c300	73 6f 75 72 63 65		        .text "source"
.c306					nt_source_id:
>c306	09 00				        .byte 9, 0
>c308	17 c3 04 a1 0e a1		        .word nt_colon, xt_source_id, z_source_id
>c30e	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c316	64
.c317					nt_colon:
>c317	01 00				        .byte 1, 0
>c319	20 c3 00 87 42 87		        .word nt_semicolon, xt_colon, z_colon
>c31f	3a				        .text ":"
.c320					nt_semicolon:
>c320	01 05				        .byte 1, CO+IM
>c322	29 c3 79 9f d7 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c328	3b				        .text ";"
.c329					nt_colon_noname:
>c329	07 00				        .byte 7, 0
>c32b	38 c3 43 87 5e 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c331	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c338					nt_compile_comma:
>c338	08 18				        .byte 8, UF+NN
>c33a	48 c3 de 87 f5 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c340	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c348					nt_left_bracket:
>c348	01 05				        .byte 1, IM+CO
>c34a	51 c3 46 93 4a 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c350	5b				        .text "["
.c351					nt_right_bracket:
>c351	01 04				        .byte 1, IM
>c353	5a c3 38 9b 3e 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c359	5d				        .text "]"
.c35a					nt_literal:
>c35a	07 15				        .byte 7, IM+CO+UF
>c35c	69 c3 7b 93 88 93		        .word nt_sliteral, xt_literal, z_literal
>c362	6c 69 74 65 72 61 6c		        .text "literal"
.c369					nt_sliteral:
>c369	08 15				        .byte 8, CO+IM+UF
>c36b	79 c3 2a a0 99 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c371	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c379					nt_dot_quote:
>c379	02 05				        .byte 2, CO+IM
>c37b	83 c3 58 8c 62 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c381	2e 22				        .text ".", $22
.c383					nt_s_quote:
>c383	02 0c				        .byte 2, IM+NN
>c385	8d c3 40 9d 9c 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c38b	73 22				        .text "s", $22
.c38d					nt_s_backslash_quote:
>c38d	03 04				        .byte 3, IM
>c38f	98 c3 78 9b 81 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c395	73 5c 22			        .text "s", $5C, $22
.c398					nt_postpone:
>c398	08 05				        .byte 8, IM+CO
>c39a	a8 c3 07 9a 45 9a		        .word nt_immediate, xt_postpone, z_postpone
>c3a0	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c3a8					nt_immediate:
>c3a8	09 00				        .byte 9, 0
>c3aa	b9 c3 3c 92 47 92		        .word nt_compile_only, xt_immediate, z_immediate
>c3b0	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c3b8	65
.c3b9					nt_compile_only:
>c3b9	0c 00				        .byte 12, 0
>c3bb	cd c3 f6 88 01 89		        .word nt_never_native, xt_compile_only, z_compile_only
>c3c1	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c3c9	6f 6e 6c 79
.c3cd					nt_never_native:
>c3cd	0c 00				        .byte 12, 0
>c3cf	e1 c3 25 96 32 96		        .word nt_always_native, xt_never_native, z_never_native
>c3d5	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c3dd	74 69 76 65
.c3e1					nt_always_native:
>c3e1	0d 00				        .byte 13, 0
>c3e3	f6 c3 21 83 2e 83		        .word nt_allow_native, xt_always_native, z_always_native
>c3e9	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c3f1	61 74 69 76 65
.c3f6					nt_allow_native:
>c3f6	0c 00				        .byte 12, 0
>c3f8	0a c4 05 83 10 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c3fe	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c406	74 69 76 65
.c40a					nt_nc_limit:
>c40a	08 00				        .byte 8, 0
>c40c	1a c4 09 96 13 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c412	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c41a					nt_strip_underflow:
>c41a	0f 00				        .byte 15, 0
>c41c	31 c4 94 a1 9e a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c422	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c42a	64 65 72 66 6c 6f 77
.c431					nt_abort:
>c431	05 00				        .byte 5, 0
>c433	3e c4 70 80 b4 80		        .word nt_abort_quote, xt_abort, z_abort
>c439	61 62 6f 72 74			        .text "abort"
.c43e					nt_abort_quote:
>c43e	06 0d				        .byte 6, CO+IM+NN
>c440	4c c4 0a 81 14 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c446	61 62 6f 72 74 22		        .text "abort", $22
.c44c					nt_do:
>c44c	02 0d				        .byte 2, CO+IM+NN
>c44e	56 c4 53 8b ad 8b		        .word nt_question_do, xt_do, z_do
>c454	64 6f				        .text "do"
.c456					nt_question_do:
>c456	03 0d				        .byte 3, CO+IM+NN
>c458	61 c4 4d 8b ad 8b		        .word nt_i, xt_question_do, z_question_do
>c45e	3f 64 6f			        .text "?do"
.c461					nt_i:
>c461	01 03				        .byte 1, AN+CO
>c463	6a c4 da 91 f3 91		        .word nt_j, xt_i, z_i
>c469	69				        .text "i"
.c46a					nt_j:
>c46a	01 03				        .byte 1, AN+CO
>c46c	73 c4 05 93 1e 93		        .word nt_loop, xt_j, z_j
>c472	6a				        .text "j"
.c473					nt_loop:
>c473	04 05				        .byte 4, CO+IM
>c475	7f c4 ec 93 59 94		        .word nt_plus_loop, xt_loop, z_loop
>c47b	6c 6f 6f 70			        .text "loop"
.c47f					nt_plus_loop:
>c47f	05 05				        .byte 5, CO+IM
>c481	8c c4 f3 93 59 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c487	2b 6c 6f 6f 70			        .text "+loop"
.c48c					nt_exit:
>c48c	04 03				        .byte 4, AN+CO
>c48e	98 c4 69 8f 6a 8f		        .word nt_unloop, xt_exit, z_exit
>c494	65 78 69 74			        .text "exit"
.c498					nt_unloop:
>c498	06 03				        .byte 6, AN+CO
>c49a	a6 c4 33 a6 39 a6		        .word nt_leave, xt_unloop, z_unloop
>c4a0	75 6e 6c 6f 6f 70		        .text "unloop"
.c4a6					nt_leave:
>c4a6	05 03				        .byte 5, AN+CO
>c4a8	b3 c4 41 93 46 93		        .word nt_recurse, xt_leave, z_leave
>c4ae	6c 65 61 76 65			        .text "leave"
.c4b3					nt_recurse:
>c4b3	07 0d				        .byte 7, CO+IM+NN
>c4b5	c2 c4 ac 9a e8 9a		        .word nt_quit, xt_recurse, z_recurse
>c4bb	72 65 63 75 72 73 65		        .text "recurse"
.c4c2					nt_quit:
>c4c2	04 00				        .byte 4, 0
>c4c4	ce c4 72 80 b4 80		        .word nt_begin, xt_quit, z_quit
>c4ca	71 75 69 74			        .text "quit"
.c4ce					nt_begin:
>c4ce	05 07				        .byte 5, AN+CO+IM
>c4d0	db c4 81 83 84 83		        .word nt_again, xt_begin, z_begin
>c4d6	62 65 67 69 6e			        .text "begin"
.c4db					nt_again:
>c4db	05 17				        .byte 5, AN+CO+IM+UF
>c4dd	e8 c4 7a 82 9a 82		        .word nt_state, xt_again, z_again
>c4e3	61 67 61 69 6e			        .text "again"
.c4e8					nt_state:
>c4e8	05 00				        .byte 5, 0
>c4ea	f5 c4 73 a1 7d a1		        .word nt_evaluate, xt_state, z_state
>c4f0	73 74 61 74 65			        .text "state"
.c4f5					nt_evaluate:
>c4f5	08 10				        .byte 8, UF
>c4f7	05 c5 c6 90 19 91		        .word nt_base, xt_evaluate, z_evaluate
>c4fd	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c505					nt_base:
>c505	04 00				        .byte 4, 0
>c507	11 c5 78 83 80 83		        .word nt_digit_question, xt_base, z_base
>c50d	62 61 73 65			        .text "base"
.c511					nt_digit_question:
>c511	06 10				        .byte 6, UF
>c513	1f c5 f6 8a 2a 8b		        .word nt_number, xt_digit_question, z_digit_question
>c519	64 69 67 69 74 3f		        .text "digit?"
.c51f					nt_number:
>c51f	06 10				        .byte 6, UF
>c521	2d c5 7b 96 77 97		        .word nt_to_number, xt_number, z_number
>c527	6e 75 6d 62 65 72		        .text "number"
.c52d					nt_to_number:
>c52d	07 10				        .byte 7, UF
>c52f	3c c5 ae a2 4d a3		        .word nt_hex, xt_to_number, z_to_number
>c535	3e 6e 75 6d 62 65 72		        .text ">number"
.c53c					nt_hex:
>c53c	03 00				        .byte 3, 0
>c53e	47 c5 6e 91 74 91		        .word nt_decimal, xt_hex, z_hex
>c544	68 65 78			        .text "hex"
.c547					nt_decimal:
>c547	07 00				        .byte 7, 0
>c549	56 c5 96 8a 9c 8a		        .word nt_count, xt_decimal, z_decimal
>c54f	64 65 63 69 6d 61 6c		        .text "decimal"
.c556					nt_count:
>c556	05 10				        .byte 5, UF
>c558	63 c5 40 89 53 89		        .word nt_m_star, xt_count, z_count
>c55e	63 6f 75 6e 74			        .text "count"
.c563					nt_m_star:
>c563	02 10				        .byte 2, UF
>c565	6d c5 7f 94 99 94		        .word nt_um_star, xt_m_star, z_m_star
>c56b	6d 2a				        .text "m*"
.c56d					nt_um_star:
>c56d	03 10				        .byte 3, UF
>c56f	78 c5 ed a5 32 a6		        .word nt_star, xt_um_star, z_um_star
>c575	75 6d 2a			        .text "um*"
.c578					nt_star:
>c578	01 10				        .byte 1, UF
>c57a	81 c5 51 a1 59 a1		        .word nt_um_slash_mod, xt_star, z_star
>c580	2a				        .text "*"
.c581					nt_um_slash_mod:
>c581	06 10				        .byte 6, UF
>c583	8f c5 ab a5 ec a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c589	75 6d 2f 6d 6f 64		        .text "um/mod"
.c58f					nt_sm_slash_rem:
>c58f	06 10				        .byte 6, UF
>c591	9d c5 c6 a0 ee a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c597	73 6d 2f 72 65 6d		        .text "sm/rem"
.c59d					nt_fm_slash_mod:
>c59d	06 10				        .byte 6, UF
>c59f	ab c5 82 90 b8 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c5a5	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c5ab					nt_slash:
>c5ab	01 10				        .byte 1, UF
>c5ad	b4 c5 ed 9f 09 a0		        .word nt_slash_mod, xt_slash, z_slash
>c5b3	2f				        .text "/"
.c5b4					nt_slash_mod:
>c5b4	04 10				        .byte 4, UF
>c5b6	c0 c5 f2 9f 09 a0		        .word nt_mod, xt_slash_mod, z_slash_mod
>c5bc	2f 6d 6f 64			        .text "/mod"
.c5c0					nt_mod:
>c5c0	03 10				        .byte 3, UF
>c5c2	cb c5 aa 95 b2 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c5c8	6d 6f 64			        .text "mod"
.c5cb					nt_star_slash_mod:
>c5cb	05 10				        .byte 5, UF
>c5cd	d8 c5 63 a1 72 a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c5d3	2a 2f 6d 6f 64			        .text "*/mod"
.c5d8					nt_star_slash:
>c5d8	02 10				        .byte 2, UF
>c5da	e2 c5 5a a1 62 a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c5e0	2a 2f				        .text "*/"
.c5e2					nt_backslash:
>c5e2	01 04				        .byte 1, IM
>c5e4	eb c5 6f 83 77 83		        .word nt_move, xt_backslash, z_backslash
>c5ea	5c				        .byte $5c
.c5eb					nt_move:
>c5eb	04 18				        .byte 4, NN+UF
>c5ed	f7 c5 b3 95 d1 95		        .word nt_cmove_up, xt_move, z_move
>c5f3	6d 6f 76 65			        .text "move"
.c5f7					nt_cmove_up:
>c5f7	06 10				        .byte 6, UF
>c5f9	05 c6 c5 86 ff 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c5ff	63 6d 6f 76 65 3e		        .text "cmove>"
.c605					nt_cmove:
>c605	05 10				        .byte 5, UF
>c607	12 c6 8a 86 c4 86		        .word nt_pad, xt_cmove, z_cmove
>c60d	63 6d 6f 76 65			        .text "cmove"
.c612					nt_pad:
>c612	03 00				        .byte 3, 0
>c614	1d c6 92 98 a1 98		        .word nt_cleave, xt_pad, z_pad
>c61a	70 61 64			        .text "pad"
.c61d					nt_cleave:
>c61d	06 10				        .byte 6, UF
>c61f	2b c6 3d 86 89 86		        .word nt_hexstore, xt_cleave, z_cleave
>c625	63 6c 65 61 76 65		        .text "cleave"
.c62b					nt_hexstore:
>c62b	08 10				        .byte 8, UF
>c62d	3b c6 75 91 c7 91		        .word nt_within, xt_hexstore, z_hexstore
>c633	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c63b					nt_within:
>c63b	06 10				        .byte 6, UF
>c63d	49 c6 96 a6 ab a6		        .word nt_to_in, xt_within, z_within
>c643	77 69 74 68 69 6e		        .text "within"
.c649					nt_to_in:
>c649	03 00				        .byte 3, 0
>c64b	54 c6 a3 a2 ad a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c651	3e 69 6e			        .text ">in"
.c654					nt_less_number_sign:
>c654	02 00				        .byte 2, 0
>c656	5e c6 4b 93 58 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c65c	3c 23				        .text "<#"
.c65e					nt_number_sign:
>c65e	01 10				        .byte 1, UF
>c660	67 c6 78 97 ac 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c666	23				        .text "#"
.c667					nt_number_sign_s:
>c667	02 10				        .byte 2, UF
>c669	71 c6 cf 97 df 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c66f	23 73				        .text "#s"
.c671					nt_number_sign_greater:
>c671	02 10				        .byte 2, UF
>c673	7b c6 ad 97 ce 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c679	23 3e				        .text "#>"
.c67b					nt_hold:
>c67b	04 10				        .byte 4, UF
>c67d	87 c6 c8 91 d9 91		        .word nt_sign, xt_hold, z_hold
>c683	68 6f 6c 64			        .text "hold"
.c687					nt_sign:
>c687	04 10				        .byte 4, UF
>c689	93 c6 d8 9f ec 9f		        .word nt_output, xt_sign, z_sign
>c68f	73 69 67 6e			        .text "sign"
.c693					nt_output:
>c693	06 00				        .byte 6, 0
>c695	a1 c6 79 98 83 98		        .word nt_input, xt_output, z_output
>c69b	6f 75 74 70 75 74		        .text "output"
.c6a1					nt_input:
>c6a1	05 00				        .byte 5, 0
>c6a3	ae c6 48 92 52 92		        .word nt_cr, xt_input, z_input
>c6a9	69 6e 70 75 74			        .text "input"
.c6ae					nt_cr:
>c6ae	02 00				        .byte 2, 0
>c6b0	b8 c6 54 89 59 89		        .word nt_page, xt_cr, z_cr
>c6b6	63 72				        .text "cr"
.c6b8					nt_page:
>c6b8	04 00				        .byte 4, 0
>c6ba	c4 c6 a2 98 bf 98		        .word nt_at_xy, xt_page, z_page
>c6c0	70 61 67 65			        .text "page"
.c6c4					nt_at_xy:
>c6c4	05 10				        .byte 5, UF
>c6c6	d1 c6 41 83 6e 83		        .word nt_marker, xt_at_xy, z_at_xy
>c6cc	61 74 2d 78 79			        .text "at-xy"
.c6d1					nt_marker:
>c6d1	06 04				        .byte 6, IM
>c6d3	df c6 9a 94 d7 94		        .word nt_words, xt_marker, z_marker
>c6d9	6d 61 72 6b 65 72		        .text "marker"
.c6df					nt_words:
>c6df	05 00				        .byte 5, 0
>c6e1	ec c6 09 a7 65 a7		        .word nt_wordsize, xt_words, z_words
>c6e7	77 6f 72 64 73			        .text "words"
.c6ec					nt_wordsize:
>c6ec	08 10				        .byte 8, UF
>c6ee	fc c6 66 a7 86 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c6f4	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c6fc					nt_aligned:
>c6fc	07 00				        .byte 7, 0
>c6fe	0b c7 9b 82 9b 82		        .word nt_align, xt_align, z_align
>c704	61 6c 69 67 6e 65 64		        .text "aligned"
.c70b					nt_align:
>c70b	05 00				        .byte 5, 0
>c70d	18 c7 9b 82 9b 82		        .word nt_bell, xt_align, z_align
>c713	61 6c 69 67 6e			        .text "align"
.c718					nt_bell:
>c718	04 00				        .byte 4, 0
>c71a	24 c7 85 83 8a 83		        .word nt_dump, xt_bell, z_bell
>c720	62 65 6c 6c			        .text "bell"
.c724					nt_dump:
>c724	04 10				        .byte 4, UF
>c726	30 c7 25 8d 8b 8d		        .word nt_dot_s, xt_dump, z_dump
>c72c	64 75 6d 70			        .text "dump"
.c730					nt_dot_s:
>c730	02 00				        .byte 2, 0
>c732	3a c7 91 8c d4 8c		        .word +, xt_dot_s, z_dot_s
>c738	2e 73				        .text ".s"
.c73a					+
.c73a					nt_disasm:
>c73a	06 10				        .byte 6, UF
>c73c	48 c7 2b 8b 31 8b		        .word +, xt_disasm, z_disasm
>c742	64 69 73 61 73 6d		        .text "disasm"
.c748					+
.c748					nt_compare:
>c748	07 10				        .byte 7, UF
>c74a	57 c7 79 87 dd 87		        .word nt_search, xt_compare, z_compare
>c750	63 6f 6d 70 61 72 65		        .text "compare"
.c757					nt_search:
>c757	06 18				        .byte 6, UF+NN
>c759	65 c7 da 9e 78 9f		        .word +, xt_search, z_search
>c75f	73 65 61 72 63 68		        .text "search"
.c765					+
.c765					nt_environment_q:
>c765	0c 10				        .byte 12, UF
>c767	79 c7 06 8e 82 8e		        .word +, xt_environment_q, z_environment_q
>c76d	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c775	65 6e 74 3f
.c779					+
.c779					nt_find:
>c779	04 10				        .byte 4, UF
>c77b	85 c7 84 8f cb 8f		        .word nt_word, xt_find, z_find
>c781	66 69 6e 64			        .text "find"
.c785					nt_word:
>c785	04 10				        .byte 4, UF
>c787	91 c7 ac a6 f1 a6		        .word nt_paren, xt_word, z_word
>c78d	77 6f 72 64			        .text "word"
.c791					nt_paren:
>c791	01 04				        .byte 1, IM
>c793	9a c7 c0 98 cf 98		        .word nt_dot_paren, xt_paren, z_paren
>c799	28				        .text "("
.c79a					nt_dot_paren:
>c79a	02 04				        .byte 2, IM
>c79c	a4 c7 49 8c 57 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c7a2	2e 28				        .text ".("
.c7a4					nt_if:
>c7a4	02 0d				        .byte 2, IM+CO+NN
>c7a6	ae c7 f4 91 04 92		        .word nt_then, xt_if, z_if
>c7ac	69 66				        .text "if"
.c7ae					nt_then:
>c7ae	04 0d				        .byte 4, IM+CO+NN
>c7b0	ba c7 b3 a1 bc a1		        .word nt_else, xt_then, z_then
>c7b6	74 68 65 6e			        .text "then"
.c7ba					nt_else:
>c7ba	04 0d				        .byte 4, IM+CO+NN
>c7bc	c6 c7 b2 8d cb 8d		        .word nt_repeat, xt_else, z_else
>c7c2	65 6c 73 65			        .text "else"
.c7c6					nt_repeat:
>c7c6	06 0d				        .byte 6, IM+CO+NN
>c7c8	d4 c7 2b 9b 37 9b		        .word nt_until, xt_repeat, z_repeat
>c7ce	72 65 70 65 61 74		        .text "repeat"
.c7d4					nt_until:
>c7d4	05 0d				        .byte 5, IM+CO+NN
>c7d6	e1 c7 3a a6 44 a6		        .word nt_while, xt_until, z_until
>c7dc	75 6e 74 69 6c			        .text "until"
.c7e1					nt_while:
>c7e1	05 0d				        .byte 5, IM+CO+NN
>c7e3	ee c7 82 a6 95 a6		        .word nt_case, xt_while, z_while
>c7e9	77 68 69 6c 65			        .text "while"
.c7ee					nt_case:
>c7ee	04 0d				        .byte 4, IM+CO+NN
>c7f0	fa c7 99 a7 9f a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c7f6	63 61 73 65			        .text "case"
.c7fa					nt_of:
>c7fa	02 0d				        .byte 2, IM+CO+NN
>c7fc	04 c8 e0 97 f8 97		        .word nt_endof, xt_of, z_of
>c802	6f 66				        .text "of"
.c804					nt_endof:
>c804	05 0d				        .byte 5, IM+CO+NN
>c806	11 c8 b2 8d cb 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c80c	65 6e 64 6f 66			        .text "endof"
.c811					nt_endcase:
>c811	07 0d				        .byte 7, IM+CO+NN
>c813	20 c8 f1 8d 05 8e		        .word nt_defer_fetch, xt_endcase, z_endcase
>c819	65 6e 64 63 61 73 65		        .text "endcase"
.c820					nt_defer_fetch:
>c820	06 00				        .byte 6, 0
>c822	2e c8 d0 8a d6 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c828	64 65 66 65 72 40		        .text "defer@"
.c82e					nt_defer_store:
>c82e	06 00				        .byte 6, 0
>c830	3c c8 d7 8a dd 8a		        .word nt_is, xt_defer_store, z_defer_store
>c836	64 65 66 65 72 21		        .text "defer!"
.c83c					nt_is:
>c83c	02 04				        .byte 2, IM
>c83e	46 c8 ec 92 04 93		        .word nt_action_of, xt_is, z_is
>c844	69 73				        .text "is"
.c846					nt_action_of:
>c846	09 04				        .byte 9, IM
>c848	57 c8 61 82 79 82		        .word nt_useraddr, xt_action_of, z_action_of
>c84e	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c856	66
.c857					nt_useraddr:
>c857	08 00				        .byte 8, 0
>c859	67 c8 5e a6 68 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c85f	75 73 65 72 61 64 64 72		        .text "useraddr"
.c867					nt_buffer_colon:
>c867	07 00				        .byte 7, 0
>c869	76 c8 d7 85 dd 85		        .word +, xt_buffer_colon, z_buffer_colon
>c86f	62 75 66 66 65 72 3a		        .text "buffer:"
.c876					+
.c876					nt_buffstatus:
>c876	0a 00				        .byte 10, 0
>c878	88 c8 de 85 ed 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c87e	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c886	75 73
.c888					nt_buffblocknum:
>c888	0c 00				        .byte 12, 0
>c88a	9c c8 96 85 a5 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c890	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c898	6b 6e 75 6d
.c89c					nt_blkbuffer:
>c89c	09 00				        .byte 9, 0
>c89e	ad c8 a4 83 b1 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c8a4	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c8ac	72
.c8ad					nt_scr:
>c8ad	03 00				        .byte 3, 0
>c8af	b8 c8 ca 9e d9 9e		        .word nt_blk, xt_scr, z_scr
>c8b5	73 63 72			        .text "scr"
.c8b8					nt_blk:
>c8b8	03 00				        .byte 3, 0
>c8ba	c3 c8 94 83 a3 83		        .word nt_block_write, xt_blk, z_blk
>c8c0	62 6c 6b			        .text "blk"
.c8c3					nt_block_write:
>c8c3	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c8c5	d6 c8 51 85 5f 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c8cb	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c8d3	69 74 65
.c8d6					nt_block_write_vector:
>c8d6	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c8d8	f0 c8 5f 85 6e 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c8de	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c8e6	69 74 65 2d 76 65 63 74 6f 72
.c8f0					nt_block_read:
>c8f0	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c8f2	02 c9 2e 85 3c 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c8f8	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c900	61 64
.c902					nt_block_read_vector:
>c902	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c904	1b c9 3c 85 4b 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c90a	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c912	61 64 2d 76 65 63 74 6f 72
.c91b					nt_save_buffers:
>c91b	0c 00				        .byte 12, 0
>c91d	2f c9 af 9e c9 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c923	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c92b	66 65 72 73
.c92f					nt_block:
>c92f	05 00				        .byte 5, 0
>c931	3c c9 b2 83 04 84		        .word nt_update, xt_block, z_block
>c937	62 6c 6f 63 6b			        .text "block"
.c93c					nt_update:
>c93c	06 00				        .byte 6, 0
>c93e	4a c9 55 a6 5d a6		        .word nt_buffer, xt_update, z_update
>c944	75 70 64 61 74 65		        .text "update"
.c94a					nt_buffer:
>c94a	06 00				        .byte 6, 0
>c94c	58 c9 a6 85 d6 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c952	62 75 66 66 65 72		        .text "buffer"
.c958					nt_empty_buffers:
>c958	0d 00				        .byte 13, 0
>c95a	6d c9 ea 8d f0 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c960	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c968	66 66 65 72 73
.c96d					nt_flush:
>c96d	05 00				        .byte 5, 0
>c96f	7a c9 78 90 81 90		        .word nt_load, xt_flush, z_flush
>c975	66 6c 75 73 68			        .text "flush"
.c97a					nt_load:
>c97a	04 10				        .byte 4, UF
>c97c	86 c9 a8 93 eb 93		        .word nt_thru, xt_load, z_load
>c982	6c 6f 61 64			        .text "load"
.c986					nt_thru:
>c986	04 10				        .byte 4, UF
>c988	92 c9 bd a1 01 a2		        .word nt_list, xt_thru, z_thru
>c98e	74 68 72 75			        .text "thru"
.c992					nt_list:
>c992	04 10				        .byte 4, UF
>c994	9e c9 6e 93 7a 93		        .word +, xt_list, z_list
>c99a	6c 69 73 74			        .text "list"
.c99e					+
.c99e					nt_block_ramdrive_init:
>c99e	13 10				        .byte 19, UF
>c9a0	b9 c9 05 84 2d 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c9a6	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c9ae	6d 64 72 69 76 65 2d 69 6e 69 74
.c9b9					+
.c9b9					nt_definitions:
>c9b9	0b 00				        .byte 11, 0
>c9bb	cc c9 de 8a e6 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c9c1	64 65 66 69 6e 69 74 69		        .text "definitions"
>c9c9	6f 6e 73
.c9cc					nt_wordlist:
>c9cc	08 00				        .byte 8, 0
>c9ce	dc c9 f2 a6 08 a7		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c9d4	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c9dc					nt_search_wordlist:
>c9dc	0f 10				        .byte 15, UF
>c9de	f3 c9 91 9b 71 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c9e4	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c9ec	6f 72 64 6c 69 73 74
.c9f3					nt_set_current:
>c9f3	0b 10				        .byte 11, UF
>c9f5	06 ca 00 9d 0b 9d		        .word nt_get_current, xt_set_current, z_set_current
>c9fb	73 65 74 2d 63 75 72 72		        .text "set-current"
>ca03	65 6e 74
.ca06					nt_get_current:
>ca06	0b 00				        .byte 11, 0
>ca08	19 ca 1a 91 24 91		        .word nt_set_order, xt_get_current, z_get_current
>ca0e	67 65 74 2d 63 75 72 72		        .text "get-current"
>ca16	65 6e 74
.ca19					nt_set_order:
>ca19	09 00				        .byte 9, 0
>ca1b	2a ca 0c 9d 3f 9d		        .word nt_get_order, xt_set_order, z_set_order
>ca21	73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca29	72
.ca2a					nt_get_order:
>ca2a	09 00				        .byte 9, 0
>ca2c	3b ca 25 91 4d 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>ca32	67 65 74 2d 6f 72 64 65		        .text "get-order"
>ca3a	72
.ca3b					nt_root_wordlist:
>ca3b	0d 00				        .byte 13, 0
>ca3d	50 ca 3f 9b 47 9b		        .word +, xt_root_wordlist, z_root_wordlist
>ca43	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>ca4b	64 6c 69 73 74
.ca50					+
.ca50					nt_assembler_wordlist:
>ca50	12 00				        .byte 18, 0
>ca52	6a ca 98 a3 a0 a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>ca58	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>ca60	72 2d 77 6f 72 64 6c 69 73 74
.ca6a					+
.ca6a					nt_editor_wordlist:
>ca6a	0f 00				        .byte 15, 0
>ca6c	81 ca f9 97 01 98		        .word +, xt_editor_wordlist, z_editor_wordlist
>ca72	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>ca7a	6f 72 64 6c 69 73 74
.ca81					+
.ca81					nt_forth_wordlist:
>ca81	0e 00				        .byte 14, 0
>ca83	97 ca 99 a7 9f a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>ca89	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca91	72 64 6c 69 73 74
.ca97					nt_only:
>ca97	04 00				        .byte 4, 0
>ca99	a3 ca 18 98 23 98		        .word nt_also, xt_only, z_only
>ca9f	6f 6e 6c 79			        .text "only"
.caa3					nt_also:
>caa3	04 00				        .byte 4, 0
>caa5	af ca 11 83 20 83		        .word nt_previous, xt_also, z_also
>caab	61 6c 73 6f			        .text "also"
.caaf					nt_previous:
>caaf	08 00				        .byte 8, 0
>cab1	bf ca 46 9a 52 9a		        .word nt_to_order, xt_previous, z_previous
>cab7	70 72 65 76 69 6f 75 73		        .text "previous"
.cabf					nt_to_order:
>cabf	06 00				        .byte 6, 0
>cac1	cd ca 4e a3 60 a3		        .word nt_order, xt_to_order, z_to_order
>cac7	3e 6f 72 64 65 72		        .text ">order"
.cacd					nt_order:
>cacd	05 00				        .byte 5, 0
>cacf	da ca 36 98 60 98		        .word nt_forth, xt_order, z_order
>cad5	6f 72 64 65 72			        .text "order"
.cada					nt_forth:
>cada	05 00				        .byte 5, 0
>cadc	e7 ca b9 90 bf 90		        .word +, xt_forth, z_forth
>cae2	66 6f 72 74 68			        .text "forth"
.cae7					+
>cae7	03 08				nt_see: .byte 3, NN
>cae9	f2 ca 72 9c ff 9c		        .word +, xt_see, z_see
>caef	73 65 65			        .text "see"
.caf2					+
.caf2					nt_ed:
>caf2	02 08				        .byte 2, NN
>caf4	fc ca ae 8d b1 8d		        .word +, xt_ed, z_ed
>cafa	65 64				        .text "ed"
.cafc					+
.cafc					nt_cold:
>cafc	04 00				        .byte 4, 0
>cafe	08 cb 00 80 b4 80		        .word nt_bye, xt_cold, z_cold
>cb04	63 6f 6c 64			        .text "cold"
.cb08					nt_bye:
>cb08	03				        .byte 3         ; length of word strings
>cb09	00				        .byte 0         ; status byte
>cb0a	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>cb0c	ee 85				        .word xt_bye    ; start of code block (xt of this word)
>cb0e	f1 85				        .word z_bye     ; end of code (RTS)
>cb10	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.cb13					root_dictionary_start:
.cb13					nt_root_set_order:
>cb13	09 00				        .byte 9, 0
>cb15	24 cb 0c 9d 3f 9d		        .word nt_root_forth, xt_set_order, z_set_order
>cb1b	73 65 74 2d 6f 72 64 65		        .text "set-order"
>cb23	72
.cb24					nt_root_forth:
>cb24	05 00				        .byte 5, 0
>cb26	31 cb b9 90 bf 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>cb2c	66 6f 72 74 68			        .text "forth"
.cb31					nt_root_forth_wordlist:
>cb31	0e 00				        .byte 14, 0
>cb33	47 cb 99 a7 9f a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>cb39	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>cb41	72 64 6c 69 73 74
.cb47					nt_root_words:
>cb47	05 00				        .byte 5, 0
>cb49	00 00 09 a7 65 a7		        .word 0000, xt_words, z_words
>cb4f	77 6f 72 64 73			        .text "words"
.cb54					editor_dictionary_start:
.cb54					nt_editor_o:
>cb54	01 00				        .byte 1, 0
>cb56	5d cb cc a8 11 a9		        .word nt_editor_line, xt_editor_o, z_editor_o
>cb5c	6f				        .text "o"
.cb5d					nt_editor_line:
>cb5d	04 10				        .byte 4, UF
>cb5f	69 cb b3 a8 cb a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>cb65	6c 69 6e 65			        .text "line"
.cb69					nt_editor_l:
>cb69	01 00				        .byte 1, 0
>cb6b	72 cb 37 a8 b2 a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cb71	6c				        .text "l"
.cb72					nt_editor_el:
>cb72	02 00				        .byte 2, 0
>cb74	7c cb 25 a8 36 a8		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cb7a	65 6c				        .text "el"
.cb7c					nt_editor_erase_screen:
>cb7c	0c 00				        .byte 12, 0
>cb7e	90 cb 13 a8 24 a8		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cb84	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cb8c	72 65 65 6e
.cb90					nt_editor_enter_screen:
>cb90	0c 00				        .byte 12, 0
>cb92	00 00 f7 a7 12 a8		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cb98	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cba0	72 65 65 6e
.cba4					assembler_dictionary_start:
.cba4					nt_asm_adc_h:
>cba4	05 0c						.byte 5, IM+NN
>cba6	b1 cb				                .word nt_asm_adc_x
>cba8	12 a9 17 a9					.word xt_asm_adc_h, z_asm_adc_h
>cbac	61 64 63 2e 23					.text "adc.#"
.cbb1					nt_asm_adc_x:
>cbb1	05 0c						.byte 5, IM+NN
>cbb3	be cb				                .word nt_asm_adc_y
>cbb5	17 a9 1c a9					.word xt_asm_adc_x, z_asm_adc_x
>cbb9	61 64 63 2e 78					.text "adc.x"
.cbbe					nt_asm_adc_y:
>cbbe	05 0c						.byte 5, IM+NN
>cbc0	cb cb				                .word nt_asm_adc_z
>cbc2	1c a9 21 a9					.word xt_asm_adc_y, z_asm_adc_y
>cbc6	61 64 63 2e 79					.text "adc.y"
.cbcb					nt_asm_adc_z:
>cbcb	05 0c						.byte 5, IM+NN
>cbcd	d8 cb				                .word nt_asm_adc_zi
>cbcf	21 a9 26 a9					.word xt_asm_adc_z, z_asm_adc_z
>cbd3	61 64 63 2e 7a					.text "adc.z"
.cbd8					nt_asm_adc_zi:
>cbd8	06 0c						.byte 6, IM+NN
>cbda	e6 cb				                .word nt_asm_adc_ziy
>cbdc	26 a9 2b a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cbe0	61 64 63 2e 7a 69				.text "adc.zi"
.cbe6					nt_asm_adc_ziy:
>cbe6	07 0c						.byte 7, IM+NN
>cbe8	f5 cb				                .word nt_asm_adc_zx
>cbea	2b a9 30 a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cbee	61 64 63 2e 7a 69 79				.text "adc.ziy"
.cbf5					nt_asm_adc_zx:
>cbf5	06 0c						.byte 6, IM+NN
>cbf7	03 cc				                .word nt_asm_adc_zxi
>cbf9	30 a9 35 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cbfd	61 64 63 2e 7a 78				.text "adc.zx"
.cc03					nt_asm_adc_zxi:
>cc03	07 0c						.byte 7, IM+NN
>cc05	12 cc				                .word nt_asm_and
>cc07	35 a9 3a a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cc0b	61 64 63 2e 7a 78 69				.text "adc.zxi"
.cc12					nt_asm_and:
>cc12	04 0c						.byte 4, IM+NN
>cc14	1e cc				                .word nt_asm_and_h
>cc16	3a a9 3f a9					.word xt_asm_and, z_asm_and
>cc1a	61 6e 64 2e					.text "and."
.cc1e					nt_asm_and_h:
>cc1e	05 0c						.byte 5, IM+NN
>cc20	2b cc				                .word nt_asm_and_x
>cc22	3f a9 44 a9					.word xt_asm_and_h, z_asm_and_h
>cc26	61 6e 64 2e 23					.text "and.#"
.cc2b					nt_asm_and_x:
>cc2b	05 0c						.byte 5, IM+NN
>cc2d	38 cc				                .word nt_asm_and_y
>cc2f	44 a9 49 a9					.word xt_asm_and_x, z_asm_and_x
>cc33	61 6e 64 2e 78					.text "and.x"
.cc38					nt_asm_and_y:
>cc38	05 0c						.byte 5, IM+NN
>cc3a	45 cc				                .word nt_asm_and_z
>cc3c	49 a9 4e a9					.word xt_asm_and_y, z_asm_and_y
>cc40	61 6e 64 2e 79					.text "and.y"
.cc45					nt_asm_and_z:
>cc45	05 0c						.byte 5, IM+NN
>cc47	52 cc				                .word nt_asm_and_zi
>cc49	4e a9 53 a9					.word xt_asm_and_z, z_asm_and_z
>cc4d	61 6e 64 2e 7a					.text "and.z"
.cc52					nt_asm_and_zi:
>cc52	06 0c						.byte 6, IM+NN
>cc54	60 cc				                .word nt_asm_and_ziy
>cc56	53 a9 58 a9					.word xt_asm_and_zi, z_asm_and_zi
>cc5a	61 6e 64 2e 7a 69				.text "and.zi"
.cc60					nt_asm_and_ziy:
>cc60	07 0c						.byte 7, IM+NN
>cc62	6f cc				                .word nt_asm_and_zx
>cc64	58 a9 5d a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cc68	61 6e 64 2e 7a 69 79				.text "and.ziy"
.cc6f					nt_asm_and_zx:
>cc6f	06 0c						.byte 6, IM+NN
>cc71	7d cc				                .word nt_asm_and_zxi
>cc73	5d a9 62 a9					.word xt_asm_and_zx, z_asm_and_zx
>cc77	61 6e 64 2e 7a 78				.text "and.zx"
.cc7d					nt_asm_and_zxi:
>cc7d	07 0c						.byte 7, IM+NN
>cc7f	8c cc				                .word nt_asm_asl
>cc81	62 a9 67 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cc85	61 6e 64 2e 7a 78 69				.text "and.zxi"
.cc8c					nt_asm_asl:
>cc8c	03 0c						.byte 3, IM+NN
>cc8e	97 cc				                .word nt_asm_asl_a
>cc90	67 a9 6c a9					.word xt_asm_asl, z_asm_asl
>cc94	61 73 6c					.text "asl"
.cc97					nt_asm_asl_a:
>cc97	05 0c						.byte 5, IM+NN
>cc99	a4 cc				                .word nt_asm_asl_x
>cc9b	6c a9 71 a9					.word xt_asm_asl_a, z_asm_asl_a
>cc9f	61 73 6c 2e 61					.text "asl.a"
.cca4					nt_asm_asl_x:
>cca4	05 0c						.byte 5, IM+NN
>cca6	b1 cc				                .word nt_asm_asl_z
>cca8	71 a9 76 a9					.word xt_asm_asl_x, z_asm_asl_x
>ccac	61 73 6c 2e 78					.text "asl.x"
.ccb1					nt_asm_asl_z:
>ccb1	05 0c						.byte 5, IM+NN
>ccb3	be cc				                .word nt_asm_asl_zx
>ccb5	76 a9 7b a9					.word xt_asm_asl_z, z_asm_asl_z
>ccb9	61 73 6c 2e 7a					.text "asl.z"
.ccbe					nt_asm_asl_zx:
>ccbe	06 0c						.byte 6, IM+NN
>ccc0	cc cc				                .word nt_asm_bcc
>ccc2	7b a9 80 a9					.word xt_asm_asl_zx, z_asm_asl_zx
>ccc6	61 73 6c 2e 7a 78				.text "asl.zx"
.cccc					nt_asm_bcc:
>cccc	03 0c						.byte 3, IM+NN
>ccce	d7 cc				                .word nt_asm_bcs
>ccd0	80 a9 85 a9					.word xt_asm_bcc, z_asm_bcc
>ccd4	62 63 63					.text "bcc"
.ccd7					nt_asm_bcs:
>ccd7	03 0c						.byte 3, IM+NN
>ccd9	e2 cc				                .word nt_asm_beq
>ccdb	85 a9 8c a9					.word xt_asm_bcs, z_asm_bcs
>ccdf	62 63 73					.text "bcs"
.cce2					nt_asm_beq:
>cce2	03 0c						.byte 3, IM+NN
>cce4	ed cc				                .word nt_asm_bit
>cce6	8c a9 91 a9					.word xt_asm_beq, z_asm_beq
>ccea	62 65 71					.text "beq"
.cced					nt_asm_bit:
>cced	03 0c						.byte 3, IM+NN
>ccef	f8 cc				                .word nt_asm_bit_h
>ccf1	91 a9 96 a9					.word xt_asm_bit, z_asm_bit
>ccf5	62 69 74					.text "bit"
.ccf8					nt_asm_bit_h:
>ccf8	05 0c						.byte 5, IM+NN
>ccfa	05 cd				                .word nt_asm_bit_x
>ccfc	96 a9 9b a9					.word xt_asm_bit_h, z_asm_bit_h
>cd00	62 69 74 2e 23					.text "bit.#"
.cd05					nt_asm_bit_x:
>cd05	05 0c						.byte 5, IM+NN
>cd07	12 cd				                .word nt_asm_bit_z
>cd09	9b a9 a0 a9					.word xt_asm_bit_x, z_asm_bit_x
>cd0d	62 69 74 2e 78					.text "bit.x"
.cd12					nt_asm_bit_z:
>cd12	05 0c						.byte 5, IM+NN
>cd14	1f cd				                .word nt_asm_bit_zx
>cd16	a0 a9 a5 a9					.word xt_asm_bit_z, z_asm_bit_z
>cd1a	62 69 74 2e 7a					.text "bit.z"
.cd1f					nt_asm_bit_zx:
>cd1f	06 0c						.byte 6, IM+NN
>cd21	2d cd				                .word nt_asm_bmi
>cd23	a5 a9 aa a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cd27	62 69 74 2e 7a 78				.text "bit.zx"
.cd2d					nt_asm_bmi:
>cd2d	03 0c						.byte 3, IM+NN
>cd2f	38 cd				                .word nt_asm_bne
>cd31	aa a9 af a9					.word xt_asm_bmi, z_asm_bmi
>cd35	62 6d 69					.text "bmi"
.cd38					nt_asm_bne:
>cd38	03 0c						.byte 3, IM+NN
>cd3a	43 cd				                .word nt_asm_bpl
>cd3c	af a9 b4 a9					.word xt_asm_bne, z_asm_bne
>cd40	62 6e 65					.text "bne"
.cd43					nt_asm_bpl:
>cd43	03 0c						.byte 3, IM+NN
>cd45	4e cd				                .word nt_asm_bra
>cd47	b4 a9 b9 a9					.word xt_asm_bpl, z_asm_bpl
>cd4b	62 70 6c					.text "bpl"
.cd4e					nt_asm_bra:
>cd4e	03 0c						.byte 3, IM+NN
>cd50	59 cd				                .word nt_asm_brk
>cd52	b9 a9 be a9					.word xt_asm_bra, z_asm_bra
>cd56	62 72 61					.text "bra"
.cd59					nt_asm_brk:
>cd59	03 0c						.byte 3, IM+NN
>cd5b	64 cd				                .word nt_asm_bvc
>cd5d	be a9 c3 a9					.word xt_asm_brk, z_asm_brk
>cd61	62 72 6b					.text "brk"
.cd64					nt_asm_bvc:
>cd64	03 0c						.byte 3, IM+NN
>cd66	6f cd				                .word nt_asm_bvs
>cd68	c3 a9 c8 a9					.word xt_asm_bvc, z_asm_bvc
>cd6c	62 76 63					.text "bvc"
.cd6f					nt_asm_bvs:
>cd6f	03 0c						.byte 3, IM+NN
>cd71	7a cd				                .word nt_asm_clc
>cd73	c8 a9 cd a9					.word xt_asm_bvs, z_asm_bvs
>cd77	62 76 73					.text "bvs"
.cd7a					nt_asm_clc:
>cd7a	03 0c						.byte 3, IM+NN
>cd7c	85 cd				                .word nt_asm_cld
>cd7e	cd a9 d2 a9					.word xt_asm_clc, z_asm_clc
>cd82	63 6c 63					.text "clc"
.cd85					nt_asm_cld:
>cd85	03 0c						.byte 3, IM+NN
>cd87	90 cd				                .word nt_asm_cli
>cd89	d2 a9 d7 a9					.word xt_asm_cld, z_asm_cld
>cd8d	63 6c 64					.text "cld"
.cd90					nt_asm_cli:
>cd90	03 0c						.byte 3, IM+NN
>cd92	9b cd				                .word nt_asm_clv
>cd94	d7 a9 dc a9					.word xt_asm_cli, z_asm_cli
>cd98	63 6c 69					.text "cli"
.cd9b					nt_asm_clv:
>cd9b	03 0c						.byte 3, IM+NN
>cd9d	a6 cd				                .word nt_asm_cmp
>cd9f	dc a9 e1 a9					.word xt_asm_clv, z_asm_clv
>cda3	63 6c 76					.text "clv"
.cda6					nt_asm_cmp:
>cda6	03 0c						.byte 3, IM+NN
>cda8	b1 cd				                .word nt_asm_cmp_h
>cdaa	e1 a9 e6 a9					.word xt_asm_cmp, z_asm_cmp
>cdae	63 6d 70					.text "cmp"
.cdb1					nt_asm_cmp_h:
>cdb1	05 0c						.byte 5, IM+NN
>cdb3	be cd				                .word nt_asm_cmp_x
>cdb5	e6 a9 eb a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cdb9	63 6d 70 2e 23					.text "cmp.#"
.cdbe					nt_asm_cmp_x:
>cdbe	05 0c						.byte 5, IM+NN
>cdc0	cb cd				                .word nt_asm_cmp_y
>cdc2	eb a9 f0 a9					.word xt_asm_cmp_x, z_asm_cmp_x
>cdc6	63 6d 70 2e 78					.text "cmp.x"
.cdcb					nt_asm_cmp_y:
>cdcb	05 0c						.byte 5, IM+NN
>cdcd	d8 cd				                .word nt_asm_cmp_z
>cdcf	f0 a9 f5 a9					.word xt_asm_cmp_y, z_asm_cmp_y
>cdd3	63 6d 70 2e 79					.text "cmp.y"
.cdd8					nt_asm_cmp_z:
>cdd8	05 0c						.byte 5, IM+NN
>cdda	e5 cd				                .word nt_asm_cmp_zi
>cddc	f5 a9 fa a9					.word xt_asm_cmp_z, z_asm_cmp_z
>cde0	63 6d 70 2e 7a					.text "cmp.z"
.cde5					nt_asm_cmp_zi:
>cde5	06 0c						.byte 6, IM+NN
>cde7	f3 cd				                .word nt_asm_cmp_ziy
>cde9	fa a9 ff a9					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cded	63 6d 70 2e 7a 69				.text "cmp.zi"
.cdf3					nt_asm_cmp_ziy:
>cdf3	07 0c						.byte 7, IM+NN
>cdf5	02 ce				                .word nt_asm_cmp_zx
>cdf7	ff a9 04 aa					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cdfb	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.ce02					nt_asm_cmp_zx:
>ce02	06 0c						.byte 6, IM+NN
>ce04	10 ce				                .word nt_asm_cmp_zxi
>ce06	04 aa 09 aa					.word xt_asm_cmp_zx, z_asm_cmp_zx
>ce0a	63 6d 70 2e 7a 78				.text "cmp.zx"
.ce10					nt_asm_cmp_zxi:
>ce10	07 0c						.byte 7, IM+NN
>ce12	1f ce				                .word nt_asm_cpx
>ce14	09 aa 0e aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>ce18	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.ce1f					nt_asm_cpx:
>ce1f	03 0c						.byte 3, IM+NN
>ce21	2a ce				                .word nt_asm_cpx_h
>ce23	0e aa 13 aa					.word xt_asm_cpx, z_asm_cpx
>ce27	63 70 78					.text "cpx"
.ce2a					nt_asm_cpx_h:
>ce2a	05 0c						.byte 5, IM+NN
>ce2c	37 ce				                .word nt_asm_cpx_z
>ce2e	13 aa 18 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>ce32	63 70 78 2e 23					.text "cpx.#"
.ce37					nt_asm_cpx_z:
>ce37	05 0c						.byte 5, IM+NN
>ce39	44 ce				                .word nt_asm_cpy
>ce3b	18 aa 1d aa					.word xt_asm_cpx_z, z_asm_cpx_z
>ce3f	63 70 78 2e 7a					.text "cpx.z"
.ce44					nt_asm_cpy:
>ce44	03 0c						.byte 3, IM+NN
>ce46	4f ce				                .word nt_asm_cpy_h
>ce48	1d aa 24 aa					.word xt_asm_cpy, z_asm_cpy
>ce4c	63 70 79					.text "cpy"
.ce4f					nt_asm_cpy_h:
>ce4f	05 0c						.byte 5, IM+NN
>ce51	5c ce				                .word nt_asm_cpy_z
>ce53	24 aa 29 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>ce57	63 70 79 2e 23					.text "cpy.#"
.ce5c					nt_asm_cpy_z:
>ce5c	05 0c						.byte 5, IM+NN
>ce5e	69 ce				                .word nt_asm_dec
>ce60	29 aa 2e aa					.word xt_asm_cpy_z, z_asm_cpy_z
>ce64	63 70 79 2e 7a					.text "cpy.z"
.ce69					nt_asm_dec:
>ce69	03 0c						.byte 3, IM+NN
>ce6b	74 ce				                .word nt_asm_dec_a
>ce6d	2e aa 33 aa					.word xt_asm_dec, z_asm_dec
>ce71	64 65 63					.text "dec"
.ce74					nt_asm_dec_a:
>ce74	05 0c						.byte 5, IM+NN
>ce76	81 ce				                .word nt_asm_dec_x
>ce78	33 aa 38 aa					.word xt_asm_dec_a, z_asm_dec_a
>ce7c	64 65 63 2e 61					.text "dec.a"
.ce81					nt_asm_dec_x:
>ce81	05 0c						.byte 5, IM+NN
>ce83	8e ce				                .word nt_asm_dec_z
>ce85	38 aa 3d aa					.word xt_asm_dec_x, z_asm_dec_x
>ce89	64 65 63 2e 78					.text "dec.x"
.ce8e					nt_asm_dec_z:
>ce8e	05 0c						.byte 5, IM+NN
>ce90	9b ce				                .word nt_asm_dec_zx
>ce92	3d aa 42 aa					.word xt_asm_dec_z, z_asm_dec_z
>ce96	64 65 63 2e 7a					.text "dec.z"
.ce9b					nt_asm_dec_zx:
>ce9b	06 0c						.byte 6, IM+NN
>ce9d	a9 ce				                .word nt_asm_dex
>ce9f	42 aa 47 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cea3	64 65 63 2e 7a 78				.text "dec.zx"
.cea9					nt_asm_dex:
>cea9	03 0c						.byte 3, IM+NN
>ceab	b4 ce				                .word nt_asm_dey
>cead	47 aa 4c aa					.word xt_asm_dex, z_asm_dex
>ceb1	64 65 78					.text "dex"
.ceb4					nt_asm_dey:
>ceb4	03 0c						.byte 3, IM+NN
>ceb6	bf ce				                .word nt_asm_eor
>ceb8	4c aa 51 aa					.word xt_asm_dey, z_asm_dey
>cebc	64 65 79					.text "dey"
.cebf					nt_asm_eor:
>cebf	03 0c						.byte 3, IM+NN
>cec1	ca ce				                .word nt_asm_eor_h
>cec3	51 aa 56 aa					.word xt_asm_eor, z_asm_eor
>cec7	65 6f 72					.text "eor"
.ceca					nt_asm_eor_h:
>ceca	05 0c						.byte 5, IM+NN
>cecc	d7 ce				                .word nt_asm_eor_x
>cece	56 aa 5b aa					.word xt_asm_eor_h, z_asm_eor_h
>ced2	65 6f 72 2e 23					.text "eor.#"
.ced7					nt_asm_eor_x:
>ced7	05 0c						.byte 5, IM+NN
>ced9	e4 ce				                .word nt_asm_eor_y
>cedb	5b aa 60 aa					.word xt_asm_eor_x, z_asm_eor_x
>cedf	65 6f 72 2e 78					.text "eor.x"
.cee4					nt_asm_eor_y:
>cee4	05 0c						.byte 5, IM+NN
>cee6	f1 ce				                .word nt_asm_eor_z
>cee8	60 aa 65 aa					.word xt_asm_eor_y, z_asm_eor_y
>ceec	65 6f 72 2e 79					.text "eor.y"
.cef1					nt_asm_eor_z:
>cef1	05 0c						.byte 5, IM+NN
>cef3	fe ce				                .word nt_asm_eor_zi
>cef5	65 aa 6a aa					.word xt_asm_eor_z, z_asm_eor_z
>cef9	65 6f 72 2e 7a					.text "eor.z"
.cefe					nt_asm_eor_zi:
>cefe	06 0c						.byte 6, IM+NN
>cf00	0c cf				                .word nt_asm_eor_ziy
>cf02	6a aa 6f aa					.word xt_asm_eor_zi, z_asm_eor_zi
>cf06	65 6f 72 2e 7a 69				.text "eor.zi"
.cf0c					nt_asm_eor_ziy:
>cf0c	07 0c						.byte 7, IM+NN
>cf0e	1b cf				                .word nt_asm_eor_zx
>cf10	6f aa 74 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cf14	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cf1b					nt_asm_eor_zx:
>cf1b	06 0c						.byte 6, IM+NN
>cf1d	29 cf				                .word nt_asm_eor_zxi
>cf1f	74 aa 79 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>cf23	65 6f 72 2e 7a 78				.text "eor.zx"
.cf29					nt_asm_eor_zxi:
>cf29	07 0c						.byte 7, IM+NN
>cf2b	38 cf				                .word nt_asm_inc
>cf2d	79 aa 7e aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cf31	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cf38					nt_asm_inc:
>cf38	03 0c						.byte 3, IM+NN
>cf3a	43 cf				                .word nt_asm_inc_a
>cf3c	7e aa 83 aa					.word xt_asm_inc, z_asm_inc
>cf40	69 6e 63					.text "inc"
.cf43					nt_asm_inc_a:
>cf43	05 0c						.byte 5, IM+NN
>cf45	50 cf				                .word nt_asm_inc_x
>cf47	83 aa 88 aa					.word xt_asm_inc_a, z_asm_inc_a
>cf4b	69 6e 63 2e 61					.text "inc.a"
.cf50					nt_asm_inc_x:
>cf50	05 0c						.byte 5, IM+NN
>cf52	5d cf				                .word nt_asm_inc_z
>cf54	88 aa 8d aa					.word xt_asm_inc_x, z_asm_inc_x
>cf58	69 6e 63 2e 78					.text "inc.x"
.cf5d					nt_asm_inc_z:
>cf5d	05 0c						.byte 5, IM+NN
>cf5f	6a cf				                .word nt_asm_inc_zx
>cf61	8d aa 92 aa					.word xt_asm_inc_z, z_asm_inc_z
>cf65	69 6e 63 2e 7a					.text "inc.z"
.cf6a					nt_asm_inc_zx:
>cf6a	06 0c						.byte 6, IM+NN
>cf6c	78 cf				                .word nt_asm_inx
>cf6e	92 aa 97 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>cf72	69 6e 63 2e 7a 78				.text "inc.zx"
.cf78					nt_asm_inx:
>cf78	03 0c						.byte 3, IM+NN
>cf7a	83 cf				                .word nt_asm_iny
>cf7c	97 aa 9c aa					.word xt_asm_inx, z_asm_inx
>cf80	69 6e 78					.text "inx"
.cf83					nt_asm_iny:
>cf83	03 0c						.byte 3, IM+NN
>cf85	8e cf				                .word nt_asm_jmp
>cf87	9c aa a1 aa					.word xt_asm_iny, z_asm_iny
>cf8b	69 6e 79					.text "iny"
.cf8e					nt_asm_jmp:
>cf8e	03 0c						.byte 3, IM+NN
>cf90	99 cf				                .word nt_asm_jmp_i
>cf92	a1 aa a6 aa					.word xt_asm_jmp, z_asm_jmp
>cf96	6a 6d 70					.text "jmp"
.cf99					nt_asm_jmp_i:
>cf99	05 0c						.byte 5, IM+NN
>cf9b	a6 cf				                .word nt_asm_jmp_xi
>cf9d	a6 aa ab aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cfa1	6a 6d 70 2e 69					.text "jmp.i"
.cfa6					nt_asm_jmp_xi:
>cfa6	06 0c						.byte 6, IM+NN
>cfa8	b4 cf				                .word nt_asm_jsr
>cfaa	ab aa b0 aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cfae	6a 6d 70 2e 78 69				.text "jmp.xi"
.cfb4					nt_asm_jsr:
>cfb4	03 0c						.byte 3, IM+NN
>cfb6	bf cf				                .word nt_asm_lda
>cfb8	b0 aa b5 aa					.word xt_asm_jsr, z_asm_jsr
>cfbc	6a 73 72					.text "jsr"
.cfbf					nt_asm_lda:
>cfbf	03 0c						.byte 3, IM+NN
>cfc1	ca cf				                .word nt_asm_lda_h
>cfc3	b5 aa ba aa					.word xt_asm_lda, z_asm_lda
>cfc7	6c 64 61					.text "lda"
.cfca					nt_asm_lda_h:
>cfca	05 0c						.byte 5, IM+NN
>cfcc	d7 cf				                .word nt_asm_lda_x
>cfce	ba aa bf aa					.word xt_asm_lda_h, z_asm_lda_h
>cfd2	6c 64 61 2e 23					.text "lda.#"
.cfd7					nt_asm_lda_x:
>cfd7	05 0c						.byte 5, IM+NN
>cfd9	e4 cf				                .word nt_asm_lda_y
>cfdb	bf aa c4 aa					.word xt_asm_lda_x, z_asm_lda_x
>cfdf	6c 64 61 2e 78					.text "lda.x"
.cfe4					nt_asm_lda_y:
>cfe4	05 0c						.byte 5, IM+NN
>cfe6	f1 cf				                .word nt_asm_lda_z
>cfe8	c4 aa c9 aa					.word xt_asm_lda_y, z_asm_lda_y
>cfec	6c 64 61 2e 79					.text "lda.y"
.cff1					nt_asm_lda_z:
>cff1	05 0c						.byte 5, IM+NN
>cff3	fe cf				                .word nt_asm_lda_zi
>cff5	c9 aa ce aa					.word xt_asm_lda_z, z_asm_lda_z
>cff9	6c 64 61 2e 7a					.text "lda.z"
.cffe					nt_asm_lda_zi:
>cffe	06 0c						.byte 6, IM+NN
>d000	0c d0				                .word nt_asm_lda_ziy
>d002	ce aa d3 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>d006	6c 64 61 2e 7a 69				.text "lda.zi"
.d00c					nt_asm_lda_ziy:
>d00c	07 0c						.byte 7, IM+NN
>d00e	1b d0				                .word nt_asm_lda_zx
>d010	d3 aa d8 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>d014	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.d01b					nt_asm_lda_zx:
>d01b	06 0c						.byte 6, IM+NN
>d01d	29 d0				                .word nt_asm_lda_zxi
>d01f	d8 aa dd aa					.word xt_asm_lda_zx, z_asm_lda_zx
>d023	6c 64 61 2e 7a 78				.text "lda.zx"
.d029					nt_asm_lda_zxi:
>d029	07 0c						.byte 7, IM+NN
>d02b	38 d0				                .word nt_asm_ldx
>d02d	dd aa e2 aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>d031	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.d038					nt_asm_ldx:
>d038	03 0c						.byte 3, IM+NN
>d03a	43 d0				                .word nt_asm_ldx_h
>d03c	e2 aa e7 aa					.word xt_asm_ldx, z_asm_ldx
>d040	6c 64 78					.text "ldx"
.d043					nt_asm_ldx_h:
>d043	05 0c						.byte 5, IM+NN
>d045	50 d0				                .word nt_asm_ldx_y
>d047	e7 aa ec aa					.word xt_asm_ldx_h, z_asm_ldx_h
>d04b	6c 64 78 2e 23					.text "ldx.#"
.d050					nt_asm_ldx_y:
>d050	05 0c						.byte 5, IM+NN
>d052	5d d0				                .word nt_asm_ldx_z
>d054	ec aa f1 aa					.word xt_asm_ldx_y, z_asm_ldx_y
>d058	6c 64 78 2e 79					.text "ldx.y"
.d05d					nt_asm_ldx_z:
>d05d	05 0c						.byte 5, IM+NN
>d05f	6a d0				                .word nt_asm_ldx_zy
>d061	f1 aa f6 aa					.word xt_asm_ldx_z, z_asm_ldx_z
>d065	6c 64 78 2e 7a					.text "ldx.z"
.d06a					nt_asm_ldx_zy:
>d06a	06 0c						.byte 6, IM+NN
>d06c	78 d0				                .word nt_asm_ldy
>d06e	f6 aa fb aa					.word xt_asm_ldx_zy, z_asm_ldx_zy
>d072	6c 64 78 2e 7a 79				.text "ldx.zy"
.d078					nt_asm_ldy:
>d078	03 0c						.byte 3, IM+NN
>d07a	83 d0				                .word nt_asm_ldy_h
>d07c	fb aa 00 ab					.word xt_asm_ldy, z_asm_ldy
>d080	6c 64 79					.text "ldy"
.d083					nt_asm_ldy_h:
>d083	05 0c						.byte 5, IM+NN
>d085	90 d0				                .word nt_asm_ldy_x
>d087	00 ab 05 ab					.word xt_asm_ldy_h, z_asm_ldy_h
>d08b	6c 64 79 2e 23					.text "ldy.#"
.d090					nt_asm_ldy_x:
>d090	05 0c						.byte 5, IM+NN
>d092	9d d0				                .word nt_asm_ldy_z
>d094	05 ab 0a ab					.word xt_asm_ldy_x, z_asm_ldy_x
>d098	6c 64 79 2e 78					.text "ldy.x"
.d09d					nt_asm_ldy_z:
>d09d	05 0c						.byte 5, IM+NN
>d09f	aa d0				                .word nt_asm_ldy_zx
>d0a1	0a ab 0f ab					.word xt_asm_ldy_z, z_asm_ldy_z
>d0a5	6c 64 79 2e 7a					.text "ldy.z"
.d0aa					nt_asm_ldy_zx:
>d0aa	06 0c						.byte 6, IM+NN
>d0ac	b8 d0				                .word nt_asm_lsr
>d0ae	0f ab 14 ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>d0b2	6c 64 79 2e 7a 78				.text "ldy.zx"
.d0b8					nt_asm_lsr:
>d0b8	03 0c						.byte 3, IM+NN
>d0ba	c3 d0				                .word nt_asm_lsr_a
>d0bc	14 ab 19 ab					.word xt_asm_lsr, z_asm_lsr
>d0c0	6c 73 72					.text "lsr"
.d0c3					nt_asm_lsr_a:
>d0c3	05 0c						.byte 5, IM+NN
>d0c5	d0 d0				                .word nt_asm_lsr_x
>d0c7	19 ab 1e ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d0cb	6c 73 72 2e 61					.text "lsr.a"
.d0d0					nt_asm_lsr_x:
>d0d0	05 0c						.byte 5, IM+NN
>d0d2	dd d0				                .word nt_asm_lsr_z
>d0d4	1e ab 23 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d0d8	6c 73 72 2e 78					.text "lsr.x"
.d0dd					nt_asm_lsr_z:
>d0dd	05 0c						.byte 5, IM+NN
>d0df	ea d0				                .word nt_asm_lsr_zx
>d0e1	23 ab 28 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d0e5	6c 73 72 2e 7a					.text "lsr.z"
.d0ea					nt_asm_lsr_zx:
>d0ea	06 0c						.byte 6, IM+NN
>d0ec	f8 d0				                .word nt_asm_nop
>d0ee	28 ab 2d ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d0f2	6c 73 72 2e 7a 78				.text "lsr.zx"
.d0f8					nt_asm_nop:
>d0f8	03 0c						.byte 3, IM+NN
>d0fa	03 d1				                .word nt_asm_ora
>d0fc	2d ab 32 ab					.word xt_asm_nop, z_asm_nop
>d100	6e 6f 70					.text "nop"
.d103					nt_asm_ora:
>d103	03 0c						.byte 3, IM+NN
>d105	0e d1				                .word nt_asm_ora_h
>d107	32 ab 37 ab					.word xt_asm_ora, z_asm_ora
>d10b	6f 72 61					.text "ora"
.d10e					nt_asm_ora_h:
>d10e	05 0c						.byte 5, IM+NN
>d110	1b d1				                .word nt_asm_ora_x
>d112	37 ab 3c ab					.word xt_asm_ora_h, z_asm_ora_h
>d116	6f 72 61 2e 23					.text "ora.#"
.d11b					nt_asm_ora_x:
>d11b	05 0c						.byte 5, IM+NN
>d11d	28 d1				                .word nt_asm_ora_y
>d11f	3c ab 41 ab					.word xt_asm_ora_x, z_asm_ora_x
>d123	6f 72 61 2e 78					.text "ora.x"
.d128					nt_asm_ora_y:
>d128	05 0c						.byte 5, IM+NN
>d12a	35 d1				                .word nt_asm_ora_z
>d12c	41 ab 46 ab					.word xt_asm_ora_y, z_asm_ora_y
>d130	6f 72 61 2e 79					.text "ora.y"
.d135					nt_asm_ora_z:
>d135	05 0c						.byte 5, IM+NN
>d137	42 d1				                .word nt_asm_ora_zi
>d139	46 ab 4b ab					.word xt_asm_ora_z, z_asm_ora_z
>d13d	6f 72 61 2e 7a					.text "ora.z"
.d142					nt_asm_ora_zi:
>d142	06 0c						.byte 6, IM+NN
>d144	50 d1				                .word nt_asm_ora_ziy
>d146	4b ab 52 ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d14a	6f 72 61 2e 7a 69				.text "ora.zi"
.d150					nt_asm_ora_ziy:
>d150	07 0c						.byte 7, IM+NN
>d152	5f d1				                .word nt_asm_ora_zx
>d154	52 ab 57 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d158	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d15f					nt_asm_ora_zx:
>d15f	06 0c						.byte 6, IM+NN
>d161	6d d1				                .word nt_asm_ora_zxi
>d163	57 ab 5c ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d167	6f 72 61 2e 7a 78				.text "ora.zx"
.d16d					nt_asm_ora_zxi:
>d16d	07 0c						.byte 7, IM+NN
>d16f	7c d1				                .word nt_asm_pha
>d171	5c ab 61 ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d175	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d17c					nt_asm_pha:
>d17c	03 0c						.byte 3, IM+NN
>d17e	87 d1				                .word nt_asm_php
>d180	61 ab 66 ab					.word xt_asm_pha, z_asm_pha
>d184	70 68 61					.text "pha"
.d187					nt_asm_php:
>d187	03 0c						.byte 3, IM+NN
>d189	92 d1				                .word nt_asm_phx
>d18b	66 ab 6b ab					.word xt_asm_php, z_asm_php
>d18f	70 68 70					.text "php"
.d192					nt_asm_phx:
>d192	03 0c						.byte 3, IM+NN
>d194	9d d1				                .word nt_asm_phy
>d196	6b ab 70 ab					.word xt_asm_phx, z_asm_phx
>d19a	70 68 78					.text "phx"
.d19d					nt_asm_phy:
>d19d	03 0c						.byte 3, IM+NN
>d19f	a8 d1				                .word nt_asm_pla
>d1a1	70 ab 75 ab					.word xt_asm_phy, z_asm_phy
>d1a5	70 68 79					.text "phy"
.d1a8					nt_asm_pla:
>d1a8	03 0c						.byte 3, IM+NN
>d1aa	b3 d1				                .word nt_asm_plp
>d1ac	75 ab 7a ab					.word xt_asm_pla, z_asm_pla
>d1b0	70 6c 61					.text "pla"
.d1b3					nt_asm_plp:
>d1b3	03 0c						.byte 3, IM+NN
>d1b5	be d1				                .word nt_asm_plx
>d1b7	7a ab 7f ab					.word xt_asm_plp, z_asm_plp
>d1bb	70 6c 70					.text "plp"
.d1be					nt_asm_plx:
>d1be	03 0c						.byte 3, IM+NN
>d1c0	c9 d1				                .word nt_asm_ply
>d1c2	7f ab 84 ab					.word xt_asm_plx, z_asm_plx
>d1c6	70 6c 78					.text "plx"
.d1c9					nt_asm_ply:
>d1c9	03 0c						.byte 3, IM+NN
>d1cb	d4 d1				                .word nt_asm_rol
>d1cd	84 ab 89 ab					.word xt_asm_ply, z_asm_ply
>d1d1	70 6c 79					.text "ply"
.d1d4					nt_asm_rol:
>d1d4	03 0c						.byte 3, IM+NN
>d1d6	df d1				                .word nt_asm_rol_a
>d1d8	89 ab 8e ab					.word xt_asm_rol, z_asm_rol
>d1dc	72 6f 6c					.text "rol"
.d1df					nt_asm_rol_a:
>d1df	05 0c						.byte 5, IM+NN
>d1e1	ec d1				                .word nt_asm_rol_x
>d1e3	8e ab 93 ab					.word xt_asm_rol_a, z_asm_rol_a
>d1e7	72 6f 6c 2e 61					.text "rol.a"
.d1ec					nt_asm_rol_x:
>d1ec	05 0c						.byte 5, IM+NN
>d1ee	f9 d1				                .word nt_asm_rol_z
>d1f0	93 ab 98 ab					.word xt_asm_rol_x, z_asm_rol_x
>d1f4	72 6f 6c 2e 78					.text "rol.x"
.d1f9					nt_asm_rol_z:
>d1f9	05 0c						.byte 5, IM+NN
>d1fb	06 d2				                .word nt_asm_rol_zx
>d1fd	98 ab 9d ab					.word xt_asm_rol_z, z_asm_rol_z
>d201	72 6f 6c 2e 7a					.text "rol.z"
.d206					nt_asm_rol_zx:
>d206	06 0c						.byte 6, IM+NN
>d208	14 d2				                .word nt_asm_ror
>d20a	9d ab a2 ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d20e	72 6f 6c 2e 7a 78				.text "rol.zx"
.d214					nt_asm_ror:
>d214	03 0c						.byte 3, IM+NN
>d216	1f d2				                .word nt_asm_ror_a
>d218	a2 ab a7 ab					.word xt_asm_ror, z_asm_ror
>d21c	72 6f 72					.text "ror"
.d21f					nt_asm_ror_a:
>d21f	05 0c						.byte 5, IM+NN
>d221	2c d2				                .word nt_asm_ror_x
>d223	a7 ab ac ab					.word xt_asm_ror_a, z_asm_ror_a
>d227	72 6f 72 2e 61					.text "ror.a"
.d22c					nt_asm_ror_x:
>d22c	05 0c						.byte 5, IM+NN
>d22e	39 d2				                .word nt_asm_ror_z
>d230	ac ab b1 ab					.word xt_asm_ror_x, z_asm_ror_x
>d234	72 6f 72 2e 78					.text "ror.x"
.d239					nt_asm_ror_z:
>d239	05 0c						.byte 5, IM+NN
>d23b	46 d2				                .word nt_asm_ror_zx
>d23d	b1 ab b6 ab					.word xt_asm_ror_z, z_asm_ror_z
>d241	72 6f 72 2e 7a					.text "ror.z"
.d246					nt_asm_ror_zx:
>d246	06 0c						.byte 6, IM+NN
>d248	54 d2				                .word nt_asm_rti
>d24a	b6 ab bb ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d24e	72 6f 72 2e 7a 78				.text "ror.zx"
.d254					nt_asm_rti:
>d254	03 0c						.byte 3, IM+NN
>d256	5f d2				                .word nt_asm_rts
>d258	bb ab c0 ab					.word xt_asm_rti, z_asm_rti
>d25c	72 74 69					.text "rti"
.d25f					nt_asm_rts:
>d25f	03 0c						.byte 3, IM+NN
>d261	6a d2				                .word nt_asm_sbc
>d263	c0 ab c5 ab					.word xt_asm_rts, z_asm_rts
>d267	72 74 73					.text "rts"
.d26a					nt_asm_sbc:
>d26a	03 0c						.byte 3, IM+NN
>d26c	75 d2				                .word nt_asm_sbc_h
>d26e	c5 ab ca ab					.word xt_asm_sbc, z_asm_sbc
>d272	73 62 63					.text "sbc"
.d275					nt_asm_sbc_h:
>d275	05 0c						.byte 5, IM+NN
>d277	82 d2				                .word nt_asm_sbc_x
>d279	ca ab cf ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d27d	73 62 63 2e 23					.text "sbc.#"
.d282					nt_asm_sbc_x:
>d282	05 0c						.byte 5, IM+NN
>d284	8f d2				                .word nt_asm_sbc_y
>d286	cf ab d4 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d28a	73 62 63 2e 78					.text "sbc.x"
.d28f					nt_asm_sbc_y:
>d28f	05 0c						.byte 5, IM+NN
>d291	9c d2				                .word nt_asm_sbc_z
>d293	d4 ab d9 ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d297	73 62 63 2e 79					.text "sbc.y"
.d29c					nt_asm_sbc_z:
>d29c	05 0c						.byte 5, IM+NN
>d29e	a9 d2				                .word nt_asm_sbc_zi
>d2a0	d9 ab de ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d2a4	73 62 63 2e 7a					.text "sbc.z"
.d2a9					nt_asm_sbc_zi:
>d2a9	06 0c						.byte 6, IM+NN
>d2ab	b7 d2				                .word nt_asm_sbc_ziy
>d2ad	de ab e3 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d2b1	73 62 63 2e 7a 69				.text "sbc.zi"
.d2b7					nt_asm_sbc_ziy:
>d2b7	07 0c						.byte 7, IM+NN
>d2b9	c6 d2				                .word nt_asm_sbc_zx
>d2bb	e3 ab e8 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d2bf	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d2c6					nt_asm_sbc_zx:
>d2c6	06 0c						.byte 6, IM+NN
>d2c8	d4 d2				                .word nt_asm_sbc_zxi
>d2ca	e8 ab ed ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d2ce	73 62 63 2e 7a 78				.text "sbc.zx"
.d2d4					nt_asm_sbc_zxi:
>d2d4	07 0c						.byte 7, IM+NN
>d2d6	e3 d2				                .word nt_asm_sec
>d2d8	ed ab f1 ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d2dc	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d2e3					nt_asm_sec:
>d2e3	03 0c						.byte 3, IM+NN
>d2e5	ee d2				                .word nt_asm_sed
>d2e7	f1 ab f5 ab					.word xt_asm_sec, z_asm_sec
>d2eb	73 65 63					.text "sec"
.d2ee					nt_asm_sed:
>d2ee	03 0c						.byte 3, IM+NN
>d2f0	f9 d2				                .word nt_asm_sei
>d2f2	f5 ab f9 ab					.word xt_asm_sed, z_asm_sed
>d2f6	73 65 64					.text "sed"
.d2f9					nt_asm_sei:
>d2f9	03 0c						.byte 3, IM+NN
>d2fb	04 d3				                .word nt_asm_sta
>d2fd	f9 ab fd ab					.word xt_asm_sei, z_asm_sei
>d301	73 65 69					.text "sei"
.d304					nt_asm_sta:
>d304	03 0c						.byte 3, IM+NN
>d306	0f d3				                .word nt_asm_sta_x
>d308	fd ab 01 ac					.word xt_asm_sta, z_asm_sta
>d30c	73 74 61					.text "sta"
.d30f					nt_asm_sta_x:
>d30f	05 0c						.byte 5, IM+NN
>d311	1c d3				                .word nt_asm_sta_y
>d313	01 ac 05 ac					.word xt_asm_sta_x, z_asm_sta_x
>d317	73 74 61 2e 78					.text "sta.x"
.d31c					nt_asm_sta_y:
>d31c	05 0c						.byte 5, IM+NN
>d31e	29 d3				                .word nt_asm_sta_z
>d320	05 ac 09 ac					.word xt_asm_sta_y, z_asm_sta_y
>d324	73 74 61 2e 79					.text "sta.y"
.d329					nt_asm_sta_z:
>d329	05 0c						.byte 5, IM+NN
>d32b	36 d3				                .word nt_asm_sta_zi
>d32d	09 ac 0d ac					.word xt_asm_sta_z, z_asm_sta_z
>d331	73 74 61 2e 7a					.text "sta.z"
.d336					nt_asm_sta_zi:
>d336	06 0c						.byte 6, IM+NN
>d338	44 d3				                .word nt_asm_sta_ziy
>d33a	0d ac 11 ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d33e	73 74 61 2e 7a 69				.text "sta.zi"
.d344					nt_asm_sta_ziy:
>d344	07 0c						.byte 7, IM+NN
>d346	53 d3				                .word nt_asm_sta_zx
>d348	11 ac 15 ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d34c	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d353					nt_asm_sta_zx:
>d353	06 0c						.byte 6, IM+NN
>d355	61 d3				                .word nt_asm_sta_zxi
>d357	15 ac 19 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d35b	73 74 61 2e 7a 78				.text "sta.zx"
.d361					nt_asm_sta_zxi:
>d361	07 0c						.byte 7, IM+NN
>d363	70 d3				                .word nt_asm_stx
>d365	19 ac 1d ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d369	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d370					nt_asm_stx:
>d370	03 0c						.byte 3, IM+NN
>d372	7b d3				                .word nt_asm_stx_z
>d374	1d ac 21 ac					.word xt_asm_stx, z_asm_stx
>d378	73 74 78					.text "stx"
.d37b					nt_asm_stx_z:
>d37b	05 0c						.byte 5, IM+NN
>d37d	88 d3				                .word nt_asm_stx_zy
>d37f	21 ac 25 ac					.word xt_asm_stx_z, z_asm_stx_z
>d383	73 74 78 2e 7a					.text "stx.z"
.d388					nt_asm_stx_zy:
>d388	06 0c						.byte 6, IM+NN
>d38a	96 d3				                .word nt_asm_sty
>d38c	25 ac 29 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d390	73 74 78 2e 7a 79				.text "stx.zy"
.d396					nt_asm_sty:
>d396	03 0c						.byte 3, IM+NN
>d398	a1 d3				                .word nt_asm_sty_z
>d39a	29 ac 2d ac					.word xt_asm_sty, z_asm_sty
>d39e	73 74 79					.text "sty"
.d3a1					nt_asm_sty_z:
>d3a1	05 0c						.byte 5, IM+NN
>d3a3	ae d3				                .word nt_asm_sty_zx
>d3a5	2d ac 31 ac					.word xt_asm_sty_z, z_asm_sty_z
>d3a9	73 74 79 2e 7a					.text "sty.z"
.d3ae					nt_asm_sty_zx:
>d3ae	06 0c						.byte 6, IM+NN
>d3b0	bc d3				                .word nt_asm_stz
>d3b2	31 ac 35 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d3b6	73 74 79 2e 7a 78				.text "sty.zx"
.d3bc					nt_asm_stz:
>d3bc	03 0c						.byte 3, IM+NN
>d3be	c7 d3				                .word nt_asm_stz_x
>d3c0	35 ac 39 ac					.word xt_asm_stz, z_asm_stz
>d3c4	73 74 7a					.text "stz"
.d3c7					nt_asm_stz_x:
>d3c7	05 0c						.byte 5, IM+NN
>d3c9	d4 d3				                .word nt_asm_stz_z
>d3cb	39 ac 3d ac					.word xt_asm_stz_x, z_asm_stz_x
>d3cf	73 74 7a 2e 78					.text "stz.x"
.d3d4					nt_asm_stz_z:
>d3d4	05 0c						.byte 5, IM+NN
>d3d6	e1 d3				                .word nt_asm_stz_zx
>d3d8	3d ac 41 ac					.word xt_asm_stz_z, z_asm_stz_z
>d3dc	73 74 7a 2e 7a					.text "stz.z"
.d3e1					nt_asm_stz_zx:
>d3e1	06 0c						.byte 6, IM+NN
>d3e3	ef d3				                .word nt_asm_tax
>d3e5	41 ac 45 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d3e9	73 74 7a 2e 7a 78				.text "stz.zx"
.d3ef					nt_asm_tax:
>d3ef	03 0c						.byte 3, IM+NN
>d3f1	fa d3				                .word nt_asm_tay
>d3f3	45 ac 49 ac					.word xt_asm_tax, z_asm_tax
>d3f7	74 61 78					.text "tax"
.d3fa					nt_asm_tay:
>d3fa	03 0c						.byte 3, IM+NN
>d3fc	05 d4				                .word nt_asm_trb
>d3fe	49 ac 4d ac					.word xt_asm_tay, z_asm_tay
>d402	74 61 79					.text "tay"
.d405					nt_asm_trb:
>d405	03 0c						.byte 3, IM+NN
>d407	10 d4				                .word nt_asm_trb_z
>d409	4d ac 51 ac					.word xt_asm_trb, z_asm_trb
>d40d	74 72 62					.text "trb"
.d410					nt_asm_trb_z:
>d410	05 0c						.byte 5, IM+NN
>d412	1d d4				                .word nt_asm_tsb
>d414	51 ac 55 ac					.word xt_asm_trb_z, z_asm_trb_z
>d418	74 72 62 2e 7a					.text "trb.z"
.d41d					nt_asm_tsb:
>d41d	03 0c						.byte 3, IM+NN
>d41f	28 d4				                .word nt_asm_tsb_z
>d421	55 ac 59 ac					.word xt_asm_tsb, z_asm_tsb
>d425	74 73 62					.text "tsb"
.d428					nt_asm_tsb_z:
>d428	05 0c						.byte 5, IM+NN
>d42a	35 d4				                .word nt_asm_tsx
>d42c	59 ac 5d ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d430	74 73 62 2e 7a					.text "tsb.z"
.d435					nt_asm_tsx:
>d435	03 0c						.byte 3, IM+NN
>d437	40 d4				                .word nt_asm_txa
>d439	5d ac 61 ac					.word xt_asm_tsx, z_asm_tsx
>d43d	74 73 78					.text "tsx"
.d440					nt_asm_txa:
>d440	03 0c						.byte 3, IM+NN
>d442	4b d4				                .word nt_asm_txs
>d444	61 ac 65 ac					.word xt_asm_txa, z_asm_txa
>d448	74 78 61					.text "txa"
.d44b					nt_asm_txs:
>d44b	03 0c						.byte 3, IM+NN
>d44d	56 d4				                .word nt_asm_tya
>d44f	65 ac 69 ac					.word xt_asm_txs, z_asm_txs
>d453	74 78 73					.text "txs"
.d456					nt_asm_tya:
>d456	03 0c						.byte 3, IM+NN
>d458	61 d4				                .word nt_asm_arrow
>d45a	69 ac 6d ac					.word xt_asm_tya, z_asm_tya
>d45e	74 79 61					.text "tya"
.d461					nt_asm_arrow:
>d461	03 04				                .byte 3, IM
>d463	6c d4				                .word nt_asm_back_jump
>d465	63 91 6d 91			                .word xt_asm_arrow, z_asm_arrow
>d469	2d 2d 3e			                .text "-->"
.d46c					nt_asm_back_jump:
>d46c	02 04				                .byte 2, IM
>d46e	76 d4				                .word nt_asm_back_branch
>d470	be ac be ac			                .word xt_asm_back_jump, z_asm_back_jump
>d474	3c 6a				                .text "<j"
.d476					nt_asm_back_branch:
>d476	02 04				                .byte 2, IM
>d478	80 d4				                .word nt_asm_push_a
>d47a	bf ac c7 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d47e	3c 62				                .text "<b"
.d480					nt_asm_push_a:
>d480	06 0c				                .byte 6, IM+NN
>d482	00 00				                .word 0000
>d484	a7 ac b6 ac			                .word xt_asm_push_a, z_asm_push_a
>d488	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					str_ok             =  0
=1					str_compile        =  1
=2					str_redefined      =  2
=3					str_wid_forth      =  3
=4					str_abc_lower      =  4
=5					str_abc_upper      =  5
=6					str_wid_editor     =  6
=7					str_wid_assembler  =  7
=8					str_wid_root       =  8
=9					str_see_flags      =  9
=10					str_see_nt         = 10
=11					str_see_xt         = 11
=12					str_see_size       = 12
=13					str_disasm_lit     = 13
=14					str_disasm_sdc     = 14
=15					str_disasm_bra     = 15
.d48e					string_table:
>d48e	ae d4 b2 d4 bc d4 22 d5		        .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
>d496	c7 d4
>d498	eb d4 1a d5 0f d5 29 d5		        .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
>d4a0	2f d5 4b d5 50 d5 55 d5		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
>d4a8	66 d5 6f d5 81 d5		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 13-15
>d4ae	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d4b2	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d4ba	64 00
>d4bc	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d4c4	64 20 00
>d4c7	30 31 32 33 34 35 36 37		s_abc_lower:  .text "0123456789abcdefghijklmnopqrstuvwxyz"
>d4cf	38 39 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e
>d4df	6f 70 71 72 73 74 75 76 77 78 79 7a
>d4eb	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d4f3	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d503	4f 50 51 52 53 54 55 56 57 58 59 5a
>d50f	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d517	72 20 00
>d51a	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d522	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d529	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d52f	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d537	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d547	29 3a 20 00
>d54b	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d550	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d555	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d55d	63 69 6d 61 6c 29 3a 20 00
>d566	4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d56e	00
>d56f	53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d577	50 54 48 20 43 48 45 43 4b 00
>d581	42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
=13					err_returnstack  = 13
.d589					error_table:
>d589	a5 d5 c6 d5 e6 d5 07 d6		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d591	24 d6 35 d6 45 d6 73 d6		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d599	8b d6 9a d6 af d6 cb d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d5a1	e2 d6 21 d7			        .word es_blockwords, es_returnstack                     ; 12-13
>d5a5	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d5ad	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d5bd	65 20 6d 65 6d 6f 72 79 00
>d5c6	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d5ce	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d5de	20 52 45 46 49 4c 4c 00
>d5e6	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d5ee	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d5fe	6e 6c 79 20 77 6f 72 64 00
>d607	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d60f	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d61f	20 79 65 74 00
>d624	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d62c	20 62 79 20 7a 65 72 6f 00
>d635	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d63d	66 61 69 6c 75 72 65 00
>d645	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d64d	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d65d	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d66d	64 20 2d 31 29 00
>d673	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d67b	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d68b	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word", 0
>d693	64 20 77 6f 72 64 00
>d69a	44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d6a2	63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d6af	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d6b7	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d6c7	4c 4f 54 00
>d6cb	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d6d3	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d6e2	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d6ea	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d6fa	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d70a	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d71a	56 45 43 54 4f 52 00
>d721	52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d729	74 61 63 6b 3a 00
>d72f	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d737	44 2d 53 54 52 49 4e 47
>d73f	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d745	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d74a	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d752	2d 55 4e 49 54 2d 42 49 54 53
>d75c	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d764	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d76c	52
>d76d	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d773	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d779	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d781	53 54 41 43 4b 2d 43 45 4c 4c 53
>d78c	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d794	45 4c 4c 53
>d798	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d7a0	54 53
>d7a2	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d7a8	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d7af					cmpl_subroutine:
.d7af	48		pha		                pha             ; save LSB of address
.d7b0	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d7b2	80 03		bra $d7b7	                bra cmpl_common
.d7b4					cmpl_jump:
.d7b4	48		pha		                pha             ; save LSB of address
.d7b5	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d7b7					cmpl_common:
.d7b7	20 bf d7	jsr $d7bf	                jsr cmpl_a      ; compile opcode
.d7ba	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d7bb					cmpl_word:
.d7bb	20 bf d7	jsr $d7bf	                jsr cmpl_a      ; compile LSB of address
.d7be	98		tya		                tya             ; fall thru for MSB
.d7bf					cmpl_a:
.d7bf	92 00		sta ($00)	                sta (cp)
.d7c1	e6 00		inc $00		                inc cp
.d7c3	d0 02		bne $d7c7	                bne _done
.d7c5	e6 01		inc $01		                inc cp+1
.d7c7					_done:
.d7c7	60		rts		                rts
.d7c8					doconst:
.d7c8	ca		dex		                dex             ; make room for constant
.d7c9	ca		dex		                dex
.d7ca	68		pla		                pla             ; LSB of return address
.d7cb	85 24		sta $24		                sta tmp1
.d7cd	68		pla		                pla             ; MSB of return address
.d7ce	85 25		sta $25		                sta tmp1+1
.d7d0	a0 01		ldy #$01	                ldy #1
.d7d2	b1 24		lda ($24),y	                lda (tmp1),y
.d7d4	95 00		sta $00,x	                sta 0,x
.d7d6	c8		iny		                iny
.d7d7	b1 24		lda ($24),y	                lda (tmp1),y
.d7d9	95 01		sta $01,x	                sta 1,x
.d7db	60		rts		                rts
.d7dc					dodefer:
.d7dc	68		pla		                pla             ; LSB
.d7dd	85 24		sta $24		                sta tmp1
.d7df	68		pla		                pla             ; MSB
.d7e0	85 25		sta $25		                sta tmp1+1
.d7e2	a0 01		ldy #$01	                ldy #1
.d7e4	b1 24		lda ($24),y	                lda (tmp1),y
.d7e6	85 26		sta $26		                sta tmp2
.d7e8	c8		iny		                iny
.d7e9	b1 24		lda ($24),y	                lda (tmp1),y
.d7eb	85 27		sta $27		                sta tmp2+1
.d7ed	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d7f0					defer_error:
.d7f0	a9 03		lda #$03	                lda #err_defer
.d7f2	4c 22 d9	jmp $d922	                jmp error
.d7f5					dodoes:
.d7f5	7a		ply		                ply             ; LSB
.d7f6	68		pla		                pla             ; MSB
.d7f7	c8		iny		                iny
.d7f8	d0 01		bne $d7fb	                bne +
.d7fa	1a		inc a		                ina
.d7fb					+
.d7fb	84 26		sty $26		                sty tmp2
.d7fd	85 27		sta $27		                sta tmp2+1
.d7ff	ca		dex		                dex
.d800	ca		dex		                dex
.d801	7a		ply		                ply
.d802	68		pla		                pla
.d803	c8		iny		                iny
.d804	d0 01		bne $d807	                bne +
.d806	1a		inc a		                ina
.d807					+
.d807	94 00		sty $00,x	                sty 0,x         ; LSB
.d809	95 01		sta $01,x	                sta 1,x         ; MSB
.d80b	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d80e					dovar:
.d80e	7a		ply		                ply             ; LSB
.d80f	68		pla		                pla             ; MSB
.d810	c8		iny		                iny
.d811	d0 01		bne $d814	                bne +
.d813	1a		inc a		                ina
.d814					+
.d814	ca		dex		                dex
.d815	ca		dex		                dex
.d816	95 01		sta $01,x	                sta 1,x
.d818	98		tya		                tya
.d819	95 00		sta $00,x	                sta 0,x
.d81b	60		rts		                rts
.d81c					byte_to_ascii:
.d81c	48		pha		                pha
.d81d	4a		lsr a		                lsr             ; convert high nibble first
.d81e	4a		lsr a		                lsr
.d81f	4a		lsr a		                lsr
.d820	4a		lsr a		                lsr
.d821	20 25 d8	jsr $d825	                jsr _nibble_to_ascii
.d824	68		pla		                pla
.d825					_nibble_to_ascii:
.d825	29 0f		and #$0f	                and #$0F
.d827	09 30		ora #$30	                ora #'0'
.d829	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d82b	90 02		bcc $d82f	                bcc +
.d82d	69 06		adc #$06	                adc #$06
.d82f	4c e7 8d	jmp $8de7	+               jmp emit_a
.d832	60		rts		                rts
.d833					compare_16bit:
.d833	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d835	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d837	f0 0a		beq $d843	                beq _equal
.d839	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d83b	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d83d	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d83f	70 08		bvs $d849	                bvs _overflow
.d841	80 08		bra $d84b	                bra _not_equal
.d843					_equal:
.d843	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d845	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d847	50 04		bvc $d84d	                bvc _done
.d849					_overflow:
.d849	49 80		eor #$80	                eor #$80                ; complement negative flag
.d84b					_not_equal:
.d84b	09 01		ora #$01	                ora #1                  ; if overflow, we can't be eqal
.d84d					_done:
.d84d	60		rts		                rts
.d84e					current_to_dp:
.d84e	a0 04		ldy #$04	                ldy #current_offset
.d850	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d852	0a		asl a		                asl             ; turn it into an offset (in cells)
.d853	18		clc		                clc
.d854	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d856	a8		tay		                tay
.d857	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d859	85 02		sta $02		                sta dp
.d85b	c8		iny		                iny
.d85c	b1 1e		lda ($1e),y	                lda (up),y
.d85e	85 03		sta $03		                sta dp+1
.d860	60		rts		                rts
.d861					dp_to_current:
.d861	a0 04		ldy #$04	                ldy #current_offset
.d863	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d865	0a		asl a		                asl             ; turn it into an offset (in cells)
.d866	18		clc		                clc
.d867	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d869	a8		tay		                tay
.d86a	a5 02		lda $02		                lda dp
.d86c	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d86e	c8		iny		                iny
.d86f	a5 03		lda $03		                lda dp+1
.d871	91 1e		sta ($1e),y	                sta (up),y
.d873	60		rts		                rts
.d874					interpret:
.d874					_loop:
.d874	20 d0 98	jsr $98d0	                jsr xt_parse_name       ; ( "string" -- addr u )
.d877	b5 00		lda $00,x	                lda 0,x
.d879	15 01		ora $01,x	                ora 1,x
.d87b	f0 70		beq $d8ed	                beq _line_done
.d87d	20 a9 a3	jsr $a3a9	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d880	20 cc 8f	jsr $8fcc	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d883	b5 00		lda $00,x	                lda 0,x
.d885	15 01		ora $01,x	                ora 1,x
.d887	d0 28		bne $d8b1	                bne _got_name_token
.d889	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d88a	e8		inx		                inx
.d88b	20 7b 96	jsr $967b	                jsr xt_number           ; ( addr u -- u|d )
.d88e	a5 16		lda $16		                lda state
.d890	f0 e2		beq $d874	                beq _loop
.d892	a9 20		lda #$20	                lda #$20
.d894	24 20		bit $20		                bit status
.d896	f0 0d		beq $d8a5	                beq _single_number
.d898	20 9f a1	jsr $a19f	                jsr xt_swap
.d89b	a0 93		ldy #$93	                ldy #>literal_runtime
.d89d	a9 89		lda #$89	                lda #<literal_runtime
.d89f	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.d8a2	20 5f 87	jsr $875f	                jsr xt_comma
.d8a5					_single_number:
.d8a5	a0 93		ldy #$93	                ldy #>literal_runtime
.d8a7	a9 89		lda #$89	                lda #<literal_runtime
.d8a9	20 af d7	jsr $d7af	                jsr cmpl_subroutine
.d8ac	20 5f 87	jsr $875f	                jsr xt_comma
.d8af	80 c3		bra $d874	                bra _loop
.d8b1					_got_name_token:
.d8b1	b5 00		lda $00,x	                lda 0,x
.d8b3	95 04		sta $04,x	                sta 4,x
.d8b5	b5 01		lda $01,x	                lda 1,x
.d8b7	95 05		sta $05,x	                sta 5,x
.d8b9	e8		inx		                inx
.d8ba	e8		inx		                inx
.d8bb	e8		inx		                inx
.d8bc	e8		inx		                inx                     ; ( nt )
.d8bd	b5 00		lda $00,x	                lda 0,x
.d8bf	85 22		sta $22		                sta tmpbranch
.d8c1	b5 01		lda $01,x	                lda 1,x
.d8c3	85 23		sta $23		                sta tmpbranch+1
.d8c5	20 d2 95	jsr $95d2	                jsr xt_name_to_int      ; ( nt - xt )
.d8c8	a5 16		lda $16		                lda state
.d8ca	d0 13		bne $d8df	                bne _compile
.d8cc	a0 01		ldy #$01	                ldy #1
.d8ce	b1 22		lda ($22),y	                lda (tmpbranch),y
.d8d0	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d8d2	f0 05		beq $d8d9	                beq _interpret
.d8d4	a9 02		lda #$02	                lda #err_compileonly
.d8d6	4c 22 d9	jmp $d922	                jmp error
.d8d9					_interpret:
.d8d9	20 2e 8f	jsr $8f2e	                jsr xt_execute
.d8dc	4c 74 d8	jmp $d874	                jmp _loop
.d8df					_compile:
.d8df	a0 01		ldy #$01	                ldy #1
.d8e1	b1 22		lda ($22),y	                lda (tmpbranch),y
.d8e3	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d8e5	d0 f2		bne $d8d9	                bne _interpret          ; IMMEDIATE word, execute right now
.d8e7	20 de 87	jsr $87de	                jsr xt_compile_comma
.d8ea	4c 74 d8	jmp $d874	                jmp _loop
.d8ed					_line_done:
.d8ed	e8		inx		                inx
.d8ee	e8		inx		                inx
.d8ef	e8		inx		                inx
.d8f0	e8		inx		                inx
.d8f1	60		rts		                rts
.d8f2					is_printable:
.d8f2	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d8f4	90 08		bcc $d8fe	                bcc _done
.d8f6	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d8f8	b0 03		bcs $d8fd	                bcs _failed
.d8fa	38		sec		                sec
.d8fb	80 01		bra $d8fe	                bra _done
.d8fd					_failed:
.d8fd	18		clc		                clc
.d8fe					_done:
.d8fe	60		rts		                rts
.d8ff					is_whitespace:
.d8ff	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d901	90 08		bcc $d90b	                bcc _done
.d903	c9 21		cmp #$21	                cmp #AscSP+1
.d905	b0 03		bcs $d90a	                bcs _failed
.d907	38		sec		                sec
.d908	80 01		bra $d90b	                bra _done
.d90a					_failed:
.d90a	18		clc		                clc
.d90b					_done:
.d90b	60		rts		                rts
.d90c					underflow_1:
.d90c	e0 77		cpx #$77	                cpx #dsp0-1
.d90e	10 10		bpl $d920	                bpl underflow_error
.d910	60		rts		                rts
.d911					underflow_2:
.d911	e0 75		cpx #$75	                cpx #dsp0-3
.d913	10 0b		bpl $d920	                bpl underflow_error
.d915	60		rts		                rts
.d916					underflow_3:
.d916	e0 73		cpx #$73	                cpx #dsp0-5
.d918	10 06		bpl $d920	                bpl underflow_error
.d91a	60		rts		                rts
.d91b					underflow_4:
.d91b	e0 71		cpx #$71	                cpx #dsp0-7
.d91d	10 01		bpl $d920	                bpl underflow_error
.d91f	60		rts		                rts
.d920					underflow_error:
.d920	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d922					error:
.d922	48		pha		                pha                     ; save error
.d923	20 62 d9	jsr $d962	                jsr print_error
.d926	20 54 89	jsr $8954	                jsr xt_cr
.d929	68		pla		                pla
.d92a	c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d92c	d0 17		bne $d945	                bne _no_underflow
.d92e	a9 0d		lda #$0d	                lda #err_returnstack
.d930	20 62 d9	jsr $d962	                jsr print_error
.d933	ba		tsx		                tsx
.d934					-
.d934	e8		inx		                inx
.d935	f0 0b		beq $d942	                beq +
.d937	20 0f a1	jsr $a10f	                jsr xt_space
.d93a	bd 00 01	lda $0100,x	                lda $100,x
.d93d	20 1c d8	jsr $d81c	                jsr byte_to_ascii
.d940	80 f2		bra $d934	                bra -
.d942					+
.d942	20 54 89	jsr $8954	                jsr xt_cr
.d945					_no_underflow:
.d945	4c 70 80	jmp $8070	                jmp xt_abort            ; no jsr, as we clobber return stack
.d948					print_string_no_lf:
.d948	0a		asl a		                asl
.d949	a8		tay		                tay
.d94a	b9 8e d4	lda $d48e,y	                lda string_table,y
.d94d	85 28		sta $28		                sta tmp3                ; LSB
.d94f	c8		iny		                iny
.d950	b9 8e d4	lda $d48e,y	                lda string_table,y
.d953	85 29		sta $29		                sta tmp3+1              ; MSB
.d955					print_common:
.d955	a0 00		ldy #$00	                ldy #0
.d957					_loop:
.d957	b1 28		lda ($28),y	                lda (tmp3),y
.d959	f0 06		beq $d961	                beq _done               ; strings are zero-terminated
.d95b	20 e7 8d	jsr $8de7	                jsr emit_a              ; allows vectoring via output
.d95e	c8		iny		                iny
.d95f	80 f6		bra $d957	                bra _loop
.d961					_done:
.d961	60		rts		                rts
.d962					print_error:
.d962	0a		asl a		                asl
.d963	a8		tay		                tay
.d964	b9 89 d5	lda $d589,y	                lda error_table,y
.d967	85 28		sta $28		                sta tmp3                ; LSB
.d969	c8		iny		                iny
.d96a	b9 89 d5	lda $d589,y	                lda error_table,y
.d96d	85 29		sta $29		                sta tmp3+1              ; MSB
.d96f	20 55 d9	jsr $d955	                jsr print_common
.d972	60		rts		                rts
.d973					print_string:
.d973	20 48 d9	jsr $d948	                jsr print_string_no_lf
.d976	4c 54 89	jmp $8954	                jmp xt_cr               ; JSR/RTS because never compiled
.d979					print_u:
.d979	20 99 a7	jsr $a799	                jsr xt_zero                     ; 0
.d97c	20 4b 93	jsr $934b	                jsr xt_less_number_sign         ; <#
.d97f	20 cf 97	jsr $97cf	                jsr xt_number_sign_s            ; #S
.d982	20 ad 97	jsr $97ad	                jsr xt_number_sign_greater      ; #>
.d985	4c f4 a4	jmp $a4f4	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
