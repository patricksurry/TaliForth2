
; 64tass Turbo Assembler Macro V1.56.2625 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Wed Mar 27 11:33:20 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../native_words.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 10		sta $10		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 11		sta $11		                sta output+1
.8009		a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd cb a8	lda $a8cb,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad cb a8	lda $a8cb	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 31		ldy #$31	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 ed a8	lda $a8ed,y	                lda cold_user_table,y
.8024		91 1e		sta ($1e),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad ed a8	lda $a8ed	                lda cold_user_table
.802c		92 1e		sta ($1e)	                sta (up)
.802e		20 2a 89	jsr $892a	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 b3		lda #$b3	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 bb		lda #$bb	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 d3		lda #$d3	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 ba 90	jsr $90ba	                jsr xt_evaluate
.8048		9c 00 7c	stz $7c00	                stz hist_buff
.804b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057		9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060						xt_abort:
.8060		a2 78		ldx #$78	                ldx #dsp0
.8062						xt_quit:
.8062		8a		txa		                txa             ; Save the DSP that we just defined
.8063		a2 ff		ldx #$ff	                ldx #rsp0
.8065		9a		txs		                txs
.8066		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067		64 0e		stz $0e		                stz ip
.8069		64 0f		stz $0f		                stz ip+1
.806b		64 06		stz $06		                stz insrc
.806d		64 07		stz $07		                stz insrc+1
.806f		a9 00		lda #$00	                lda #0
.8071		a0 00		ldy #$00	                ldy #blk_offset
.8073		91 1e		sta ($1e),y	                sta (up),y
.8075		c8		iny		                iny
.8076		91 1e		sta ($1e),y	                sta (up),y
.8078		64 16		stz $16		                stz state
.807a		64 17		stz $17		                stz state+1
.807c						_get_line:
.807c		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.807e		85 08		sta $08		                sta cib
.8080		a9 02		lda #$02	                lda #>buffer0
.8082		85 09		sta $09		                sta cib+1
.8084		64 0a		stz $0a		                stz ciblen
.8086		64 0b		stz $0b		                stz ciblen+1
.8088		20 dc 9a	jsr $9adc	                jsr xt_refill           ; ( -- f )
.808b		b5 00		lda $00,x	                lda 0,x
.808d		d0 05		bne $8094	                bne _success
.808f		a9 06		lda #$06	                lda #err_refill
.8091		4c 8b d8	jmp $d88b	                jmp error
.8094						_success:
.8094		e8		inx		                inx                     ; drop
.8095		e8		inx		                inx
.8096		20 e2 d7	jsr $d7e2	                jsr interpret
.8099		e0 78		cpx #$78	                cpx #dsp0
.809b		f0 05		beq $80a2	                beq _stack_ok
.809d		90 03		bcc $80a2	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.809f		4c 89 d8	jmp $d889	                jmp underflow_error
.80a2						_stack_ok:
.80a2		a5 16		lda $16		                lda state
.80a4		f0 02		beq $80a8	                beq _print
.80a6		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80a8						_print:
.80a8		20 dc d8	jsr $d8dc	                jsr print_string
.80ab		80 cf		bra $807c	                bra _get_line
.80ad						z_cold:
.80ad						z_abort:
.80ad						z_quit:
.80ad						xt_abort_quote:
.80ad		20 2c 9d	jsr $9d2c	                jsr xt_s_quote          ; S"
.80b0		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b2		a9 b8		lda #$b8	                lda #<abort_quote_runtime
.80b4		20 1d d7	jsr $d71d	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b7		60		rts		z_abort_quote:  rts
.80b8						abort_quote_runtime:
.80b8		b5 04		lda $04,x	                lda 4,x
.80ba		15 05		ora $05,x	                ora 5,x
.80bc		f0 09		beq $80c7	                beq _done       ; if FALSE, we're done
.80be		20 a7 a4	jsr $a4a7	                jsr xt_type
.80c1		20 2a 89	jsr $892a	                jsr xt_cr
.80c4		4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.80c7						_done:
.80c7		8a		txa		                txa
.80c8		18		clc		                clc
.80c9		69 06		adc #$06	                adc #6
.80cb		aa		tax		                tax
.80cc		60		rts		                rts
.80cd						xt_abs:
.80cd		20 75 d8	jsr $d875	                jsr underflow_1
.80d0		b5 01		lda $01,x	                lda 1,x
.80d2		10 0d		bpl $80e1	                bpl _done       ; positive number, easy money!
.80d4		38		sec		                sec
.80d5		a9 00		lda #$00	                lda #0
.80d7		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80d9		95 00		sta $00,x	                sta 0,x
.80db		a9 00		lda #$00	                lda #0          ; MSB
.80dd		f5 01		sbc $01,x	                sbc 1,x
.80df		95 01		sta $01,x	                sta 1,x
.80e1						_done:
.80e1		60		rts		z_abs:          rts
.80e2						xt_accept:
.80e2		20 7a d8	jsr $d87a	                jsr underflow_2
.80e5		b5 00		lda $00,x	                lda 0,x
.80e7		15 01		ora $01,x	                ora 1,x
.80e9		d0 09		bne $80f4	                bne _not_zero
.80eb		e8		inx		                inx
.80ec		e8		inx		                inx
.80ed		74 00		stz $00,x	                stz 0,x
.80ef		74 01		stz $01,x	                stz 1,x
.80f1		4c c0 81	jmp $81c0	                jmp accept_done
.80f4						_not_zero:
.80f4		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f6		85 24		sta $24		                sta tmp2
.80f8		64 25		stz $25		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fa		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fc		85 22		sta $22		                sta tmp1
.80fe		b5 03		lda $03,x	                lda 3,x
.8100		85 23		sta $23		                sta tmp1+1
.8102		e8		inx		                inx
.8103		e8		inx		                inx
.8104		a0 00		ldy #$00	                ldy #0
.8106		a5 20		lda $20		                lda status
.8108		29 f7		and #$f7	                and #$f7
.810a		1a		inc a		               ina
.810b		09 08		ora #$08	                ora #$08
.810d		85 20		sta $20		                sta status
.810f						accept_loop:
.810f		20 19 93	jsr $9319	                jsr key_a
.8112		c9 0a		cmp #$0a	                cmp #AscLF
.8114		f0 20		beq $8136	                beq _eol
.8116		c9 0d		cmp #$0d	                cmp #AscCR
.8118		f0 1c		beq $8136	                beq _eol
.811a		c9 08		cmp #$08	                cmp #AscBS
.811c		f0 22		beq $8140	                beq _backspace
.811e		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8120		f0 1e		beq $8140	                beq _backspace
.8122		c9 10		cmp #$10	                cmp #AscCP
.8124		f0 36		beq $815c	                beq _ctrl_p
.8126		c9 0e		cmp #$0e	                cmp #AscCN
.8128		f0 44		beq $816e	                beq _ctrl_n
.812a		91 22		sta ($22),y	                sta (tmp1),y
.812c		c8		iny		                iny
.812d		20 db 8d	jsr $8ddb	                jsr emit_a
.8130		c4 24		cpy $24		                cpy tmp2        ; reached character limit?
.8132		d0 db		bne $810f	                bne accept_loop       ; fall through if buffer limit reached
.8134		80 03		bra $8139	                bra _buffer_full
.8136						_eol:
.8136		20 cc a0	jsr $a0cc	                jsr xt_space    ; print final space
.8139						_buffer_full:
.8139		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813b		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813d		4c c0 81	jmp $81c0	                jmp accept_done
.8140						_backspace:
.8140		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8142		d0 06		bne $814a	                bne +
.8144		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8146		20 db 8d	jsr $8ddb	                jsr emit_a
.8149		c8		iny		                iny
.814a						+
.814a		88		dey		                dey
.814b		a9 08		lda #$08	                lda #AscBS      ; move back one
.814d		20 db 8d	jsr $8ddb	                jsr emit_a
.8150		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8152		20 db 8d	jsr $8ddb	                jsr emit_a
.8155		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8157		20 db 8d	jsr $8ddb	                jsr emit_a
.815a		80 b3		bra $810f	                bra accept_loop
.815c						_ctrl_p:
.815c		a5 20		lda $20		                lda status
.815e		29 07		and #$07	                and #7
.8160		d0 08		bne $816a	                bne _ctrl_p_dec
.8162		a5 20		lda $20		                lda status
.8164		09 07		ora #$07	                ora #7
.8166		85 20		sta $20		                sta status
.8168		80 11		bra $817b	                bra _recall_history
.816a						_ctrl_p_dec:
.816a		c6 20		dec $20		                dec status
.816c		80 0d		bra $817b	                bra _recall_history
.816e						_ctrl_n:
.816e		a9 08		lda #$08	                lda #$8
.8170		24 20		bit $20		                bit status
.8172		d0 07		bne $817b	                bne _recall_history
.8174		a5 20		lda $20		                lda status
.8176		29 f7		and #$f7	                and #$f7
.8178		1a		inc a		               ina
.8179		85 20		sta $20		                sta status
.817b						_recall_history:
.817b		a9 08		lda #$08	                lda #%00001000
.817d		14 20		trb $20		                trb status
.817f		20 db 81	jsr $81db	                jsr accept_total_recall
.8182		a9 0d		lda #$0d	                lda #AscCR
.8184		20 db 8d	jsr $8ddb	                jsr emit_a
.8187						input_clear:
.8187		c0 00		cpy #$00	                cpy #0
.8189		f0 08		beq $8193	                beq input_cleared
.818b		a9 20		lda #$20	                lda #AscSP
.818d		20 db 8d	jsr $8ddb	                jsr emit_a
.8190		88		dey		                dey
.8191		80 f4		bra $8187	                bra input_clear
.8193						input_cleared:
.8193		a9 0d		lda #$0d	                lda #AscCR
.8195		20 db 8d	jsr $8ddb	                jsr emit_a
.8198		b1 26		lda ($26),y	                lda (tmp3),y
.819a		85 21		sta $21		                sta status+1
.819c		e6 26		inc $26		                inc tmp3
.819e		d0 02		bne $81a2	                bne +           ; Increment the upper byte on carry.
.81a0		e6 27		inc $27		                inc tmp3+1
.81a2						+
.81a2		a9 0d		lda #$0d	                lda #AscCR
.81a4		20 db 8d	jsr $8ddb	                jsr emit_a
.81a7						_history_loop:
.81a7		c4 21		cpy $21		                cpy status+1
.81a9		d0 03		bne $81ae	                bne +
.81ab		4c 0f 81	jmp $810f	                jmp accept_loop       ; Needs a long jump
.81ae						+
.81ae		c4 24		cpy $24		                cpy tmp2
.81b0		f0 0a		beq $81bc	                beq _hist_filled_buffer
.81b2		b1 26		lda ($26),y	                lda (tmp3),y
.81b4		91 22		sta ($22),y	                sta (tmp1),y
.81b6		20 db 8d	jsr $8ddb	                jsr emit_a
.81b9		c8		iny		                iny
.81ba		80 eb		bra $81a7	                bra _history_loop
.81bc						_hist_filled_buffer:
.81bc		88		dey		                dey
.81bd		4c 0f 81	jmp $810f	                jmp accept_loop
.81c0						accept_done:
.81c0		20 db 81	jsr $81db	                jsr accept_total_recall
.81c3		85 21		sta $21		                sta status+1
.81c5		a0 00		ldy #$00	                ldy #0
.81c7		91 26		sta ($26),y	                sta (tmp3),y
.81c9		e6 26		inc $26		                inc tmp3
.81cb		d0 02		bne $81cf	                bne +           ; Increment the upper byte on carry.
.81cd		e6 27		inc $27		                inc tmp3+1
.81cf						+
.81cf						_save_history_loop:
.81cf		c4 21		cpy $21		                cpy status+1
.81d1		f0 07		beq $81da	                beq _save_history_done
.81d3		b1 22		lda ($22),y	                lda (tmp1),y
.81d5		91 26		sta ($26),y	                sta (tmp3),y
.81d7		c8		iny		                iny
.81d8		80 f5		bra $81cf	                bra _save_history_loop
.81da						_save_history_done:
.81da						z_accept:
.81da		60		rts		                rts
.81db						accept_total_recall:
.81db		a9 00		lda #$00	                lda #<hist_buff
.81dd		85 26		sta $26		                sta tmp3
.81df		a9 7c		lda #$7c	                lda #>hist_buff
.81e1		85 27		sta $27		                sta tmp3+1
.81e3		a5 20		lda $20		                lda status
.81e5		6a		ror a		                ror
.81e6		29 03		and #$03	                and #3
.81e8		18		clc		                clc
.81e9		65 27		adc $27		                adc tmp3+1
.81eb		85 27		sta $27		                sta tmp3+1
.81ed		a5 20		lda $20		                lda status
.81ef		6a		ror a		                ror             ; Rotate through carry into msb.
.81f0		6a		ror a		                ror
.81f1		29 80		and #$80	                and #$80
.81f3		18		clc		                clc
.81f4		65 26		adc $26		                adc tmp3
.81f6		85 26		sta $26		                sta tmp3
.81f8		90 02		bcc $81fc	                bcc +           ; Increment the upper byte on carry.
.81fa		e6 27		inc $27		                inc tmp3+1
.81fc						+
.81fc		98		tya		                tya
.81fd		c9 80		cmp #$80	                cmp #$80
.81ff		90 02		bcc $8203	                bcc +
.8201		a9 7f		lda #$7f	                lda #$7F
.8203						+
.8203		60		rts		                rts
.8204						xt_action_of:
.8204		a5 16		lda $16		                lda state
.8206		05 17		ora $17		                ora state+1
.8208		f0 0c		beq $8216	                beq _interpreting
.820a						_compiling:
.820a		20 54 85	jsr $8554	                jsr xt_bracket_tick
.820d		a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.820f		a9 a6		lda #$a6	                lda #<xt_defer_fetch
.8211		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.8214		80 06		bra $821c	                bra _done
.8216						_interpreting:
.8216		20 b5 a1	jsr $a1b5	                jsr xt_tick
.8219		20 a6 8a	jsr $8aa6	                jsr xt_defer_fetch
.821c						_done:
.821c		60		rts		z_action_of:           rts
.821d						xt_again:
.821d		20 75 d8	jsr $d875	                jsr underflow_1
.8220		a0 00		ldy #$00	                ldy #0
.8222		a9 4c		lda #$4c	                lda #$4C        ; JMP
.8224		91 00		sta ($00),y	                sta (cp),y
.8226		c8		iny		                iny
.8227		b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8229		91 00		sta ($00),y	                sta (cp),y
.822b		c8		iny		                iny
.822c		b5 01		lda $01,x	                lda 1,x         ; MSB of address
.822e		91 00		sta ($00),y	                sta (cp),y
.8230		c8		iny		                iny
.8231		98		tya		                tya
.8232		18		clc		                clc
.8233		65 00		adc $00		                adc cp
.8235		85 00		sta $00		                sta cp
.8237		90 02		bcc $823b	                bcc _done
.8239		e6 01		inc $01		                inc cp+1
.823b						_done:
.823b		e8		inx		                inx
.823c		e8		inx		                inx
.823d		60		rts		z_again:        rts
.823e						xt_align:
.823e						xt_aligned:
.823e						z_align:
.823e		60		rts		z_aligned:      rts             ; stripped out during native compile
.823f						xt_allot:
.823f		20 75 d8	jsr $d875	                jsr underflow_1
.8242		b5 01		lda $01,x	                lda 1,x
.8244		30 22		bmi $8268	                bmi _release
.8246		18		clc		                clc
.8247		a5 00		lda $00		                lda cp
.8249		75 00		adc $00,x	                adc 0,x
.824b		85 00		sta $00		                sta cp
.824d		a5 01		lda $01		                lda cp+1
.824f		75 01		adc $01,x	                adc 1,x
.8251		85 01		sta $01		                sta cp+1
.8253		a0 00		ldy #$00	                ldy #<cp_end
.8255		c4 00		cpy $00		                cpy cp
.8257		a9 7c		lda #$7c	                lda #>cp_end
.8259		e5 01		sbc $01		                sbc cp+1
.825b		b0 48		bcs $82a5	                bcs _done               ; we're fine.
.825d		84 00		sty $00		                sty cp                  ; still #<cp_end
.825f		a9 7c		lda #$7c	                lda #>cp_end
.8261		85 01		sta $01		                sta cp+1
.8263		a9 00		lda #$00	                lda #err_allot
.8265		4c 8b d8	jmp $d88b	                jmp error
.8268						_release:
.8268		ca		dex		                dex
.8269		ca		dex		                dex
.826a		a5 00		lda $00		                lda cp
.826c		95 00		sta $00,x	                sta 0,x
.826e		a5 01		lda $01		                lda cp+1
.8270		95 01		sta $01,x	                sta 1,x
.8272		20 c7 99	jsr $99c7	                jsr xt_plus                     ; new CP is now TOS
.8275		ca		dex		                dex
.8276		ca		dex		                dex                             ; new CP now NOS
.8277		a9 00		lda #$00	                lda #<cp0
.8279		95 00		sta $00,x	                sta 0,x
.827b		a9 03		lda #$03	                lda #>cp0
.827d		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.827f		20 a1 d7	jsr $d7a1	                jsr compare_16bit               ; still ( CP CP0 )
.8282		f0 17		beq $829b	                beq _nega_done
.8284		30 15		bmi $829b	                bmi _nega_done
.8286		a9 00		lda #$00	                lda #<cp0
.8288		85 00		sta $00		                sta cp
.828a		a9 03		lda #$03	                lda #>cp0
.828c		85 01		sta $01		                sta cp+1
.828e		a9 86		lda #$86	                lda #<dictionary_start
.8290		85 02		sta $02		                sta dp
.8292		a9 bc		lda #$bc	                lda #>dictionary_start
.8294		85 03		sta $03		                sta dp+1
.8296		a9 0a		lda #$0a	                lda #err_negallot
.8298		4c 8b d8	jmp $d88b	                jmp error
.829b						_nega_done:
.829b		b5 02		lda $02,x	                lda 2,x
.829d		85 00		sta $00		                sta cp
.829f		b5 03		lda $03,x	                lda 3,x
.82a1		85 01		sta $01		                sta cp+1
.82a3		e8		inx		                inx
.82a4		e8		inx		                inx                     ; drop through to _done
.82a5						_done:
.82a5		e8		inx		                inx
.82a6		e8		inx		                inx
.82a7						z_allot:
.82a7		60		rts		                rts
.82a8						xt_allow_native:
.82a8		20 bc d7	jsr $d7bc	                jsr current_to_dp
.82ab		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82ad		b1 02		lda ($02),y	                lda (dp),y
.82af		29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.82b1		91 02		sta ($02),y	                sta (dp),y
.82b3						z_allow_native:
.82b3		60		rts		                rts
.82b4						xt_also:
.82b4		20 19 91	jsr $9119	                jsr xt_get_order
.82b7		20 77 98	jsr $9877	                jsr xt_over
.82ba		20 5c a1	jsr $a15c	                jsr xt_swap
.82bd		20 01 98	jsr $9801	                jsr xt_one_plus
.82c0		20 f8 9c	jsr $9cf8	                jsr xt_set_order
.82c3		60		rts		z_also:         rts
.82c4						xt_always_native:
.82c4		20 bc d7	jsr $d7bc	                jsr current_to_dp
.82c7		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82c9		b1 02		lda ($02),y	                lda (dp),y
.82cb		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.82cd		29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.82cf		91 02		sta ($02),y	                sta (dp),y
.82d1						z_always_native:
.82d1		60		rts		                rts
.82d2						xt_and:
.82d2		20 7a d8	jsr $d87a	                jsr underflow_2
.82d5		b5 00		lda $00,x	                lda 0,x
.82d7		35 02		and $02,x	                and 2,x
.82d9		95 02		sta $02,x	                sta 2,x
.82db		b5 01		lda $01,x	                lda 1,x
.82dd		35 03		and $03,x	                and 3,x
.82df		95 03		sta $03,x	                sta 3,x
.82e1		e8		inx		                inx
.82e2		e8		inx		                inx
.82e3		60		rts		z_and:          rts
.82e4						xt_at_xy:
.82e4		20 7a d8	jsr $d87a	                jsr underflow_2
.82e7		a5 18		lda $18		                lda base
.82e9		48		pha		                pha
.82ea		a9 0a		lda #$0a	                lda #10
.82ec		85 18		sta $18		                sta base
.82ee		a9 1b		lda #$1b	                lda #AscESC
.82f0		20 db 8d	jsr $8ddb	                jsr emit_a
.82f3		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.82f5		20 db 8d	jsr $8ddb	                jsr emit_a
.82f8		20 01 98	jsr $9801	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82fb		20 e2 d8	jsr $d8e2	                jsr print_u
.82fe		a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8300		20 db 8d	jsr $8ddb	                jsr emit_a
.8303		20 01 98	jsr $9801	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8306		20 e2 d8	jsr $d8e2	                jsr print_u
.8309		a9 48		lda #$48	                lda #'H'
.830b		20 db 8d	jsr $8ddb	                jsr emit_a
.830e		68		pla		                pla
.830f		85 18		sta $18		                sta base
.8311		60		rts		z_at_xy:        rts
.8312						xt_backslash:
.8312		a0 00		ldy #$00	                ldy #blk_offset
.8314		b1 1e		lda ($1e),y	                lda (up),y
.8316		c8		iny		                iny
.8317		11 1e		ora ($1e),y	                ora (up),y
.8319		f0 19		beq $8334	                beq backslash_not_block
.831b		a5 0c		lda $0c		                lda toin
.831d		29 3f		and #$3f	                and #$3F
.831f		f0 1b		beq $833c	                beq z_backslash
.8321		c9 01		cmp #$01	                cmp #$01
.8323		f0 17		beq $833c	                beq z_backslash
.8325		a5 0c		lda $0c		                lda toin
.8327		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.8329		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.832a		69 40		adc #$40	                adc #$40
.832c		85 0c		sta $0c		                sta toin
.832e		90 0c		bcc $833c	                bcc z_backslash
.8330		e6 0d		inc $0d		                inc toin+1
.8332		80 08		bra $833c	                bra z_backslash
.8334						backslash_not_block:
.8334		a5 0a		lda $0a		                lda ciblen
.8336		85 0c		sta $0c		                sta toin
.8338		a5 0b		lda $0b		                lda ciblen+1
.833a		85 0d		sta $0d		                sta toin+1
.833c		60		rts		z_backslash:    rts
.833d						xt_base:
.833d		ca		dex		                dex
.833e		ca		dex		                dex
.833f		a9 18		lda #$18	                lda #<base
.8341		95 00		sta $00,x	                sta 0,x         ; LSB
.8343		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8345		60		rts		z_base:         rts
.8346						xt_begin:
.8346		20 57 91	jsr $9157	                jsr xt_here
.8349		60		rts		z_begin:        rts
.834a						xt_bell:
.834a		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.834c		20 db 8d	jsr $8ddb	                jsr emit_a
.834f		60		rts		z_bell:         rts
.8350						xt_bl:
.8350		ca		dex		                dex
.8351		ca		dex		                dex
.8352		a9 20		lda #$20	                lda #AscSP
.8354		95 00		sta $00,x	                sta 0,x
.8356		74 01		stz $01,x	                stz 1,x
.8358		60		rts		z_bl:           rts
.8359						xt_blk:
.8359		ca		dex		                dex
.835a		ca		dex		                dex
.835b		18		clc		                clc
.835c		a5 1e		lda $1e		                lda up
.835e		69 00		adc #$00	                adc #blk_offset ; Add offset
.8360		95 00		sta $00,x	                sta 0,x
.8362		a5 1f		lda $1f		                lda up+1
.8364		69 00		adc #$00	                adc #0          ; Adding carry
.8366		95 01		sta $01,x	                sta 1,x
.8368		60		rts		z_blk:          rts
.8369						xt_blkbuffer:
.8369		ca		dex		                dex
.836a		ca		dex		                dex
.836b		a0 28		ldy #$28	                ldy #blkbuffer_offset
.836d		b1 1e		lda ($1e),y	                lda (up),y
.836f		95 00		sta $00,x	                sta 0,x
.8371		c8		iny		                iny             ; Move along to the next byte
.8372		b1 1e		lda ($1e),y	                lda (up),y
.8374		95 01		sta $01,x	                sta 1,x
.8376		60		rts		z_blkbuffer:    rts
.8377						xt_block:
.8377		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8379		b1 1e		lda ($1e),y	                lda (up),y
.837b		d5 00		cmp $00,x	                cmp 0,x
.837d		d0 0f		bne $838e	                bne _not_in_buffer
.837f		c8		iny		                iny
.8380		b1 1e		lda ($1e),y	                lda (up),y
.8382		d5 01		cmp $01,x	                cmp 1,x
.8384		d0 08		bne $838e	                bne _not_in_buffer
.8386		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8388		b1 1e		lda ($1e),y	                lda (up),y
.838a		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.838c		d0 30		bne $83be	                bne _done       ; It's already in the buffer and in use.
.838e						_not_in_buffer:
.838e		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8390		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.8392		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8394		d0 0c		bne $83a2	                bne _buffer_available ; Unused or not dirty = available
.8396		20 69 83	jsr $8369	                jsr xt_blkbuffer
.8399		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.839c		20 65 8f	jsr $8f65	                jsr xt_fetch
.839f		20 16 85	jsr $8516	                jsr xt_block_write
.83a2						_buffer_available:
.83a2		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83a4		b5 00		lda $00,x	                lda 0,x
.83a6		91 1e		sta ($1e),y	                sta (up),y
.83a8		c8		iny		                iny
.83a9		b5 01		lda $01,x	                lda 1,x
.83ab		91 1e		sta ($1e),y	                sta (up),y
.83ad		20 69 83	jsr $8369	                jsr xt_blkbuffer
.83b0		20 5c a1	jsr $a15c	                jsr xt_swap
.83b3		20 f3 84	jsr $84f3	                jsr xt_block_read
.83b6		a9 01		lda #$01	                lda #1
.83b8		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83ba		91 1e		sta ($1e),y	                sta (up),y
.83bc		ca		dex		                dex
.83bd		ca		dex		                dex
.83be						_done:
.83be		a0 28		ldy #$28	                ldy #blkbuffer_offset
.83c0		b1 1e		lda ($1e),y	                lda (up),y
.83c2		95 00		sta $00,x	                sta 0,x
.83c4		c8		iny		                iny
.83c5		b1 1e		lda ($1e),y	                lda (up),y
.83c7		95 01		sta $01,x	                sta 1,x
.83c9		60		rts		z_block:        rts
.83ca						xt_block_ramdrive_init:
.83ca		20 75 d8	jsr $d875	                jsr underflow_1
.83cd		4c e8 84	jmp $84e8	                jmp _after_ramdrive_code
.83d0						_ramdrive_code:
>83d0		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>83d8		77 61 70 20 64 65 63 69 6d 61 6c
>83e3		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>83ea		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>83ee		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>83f6		20 72 61 6d 64 72 69 76 65
>83ff		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8407		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>8415		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>841d		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>842d		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>843d		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>8445		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>8454		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>845c		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>846c		31 30 32 34 20 6d 6f 76 65 20 3b
>8477		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>847f		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>848f		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>849f		20 21
>84a1		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84a9		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84b9		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>84c9		6f 72 20 21
>84cd		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>84d5		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>84e5		65 20 21
.84e8						_after_ramdrive_code:
.84e8		20 57 a0	jsr $a057	                jsr sliteral_runtime
>84eb		d0 83 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.84ef		20 ba 90	jsr $90ba	                jsr xt_evaluate
.84f2						z_block_ramdrive_init:
.84f2		60		rts		                rts
.84f3						xt_block_read:
.84f3		a0 2e		ldy #$2e	                ldy #blockread_offset
.84f5		b1 1e		lda ($1e),y	                lda (up),y
.84f7		85 22		sta $22		                sta tmp1
.84f9		c8		iny		                iny
.84fa		b1 1e		lda ($1e),y	                lda (up),y
.84fc		85 23		sta $23		                sta tmp1+1
.84fe		6c 22 00	jmp ($0022)	                jmp (tmp1)
.8501						z_block_read:
.8501						xt_block_read_vector:
.8501		ca		dex		                dex
.8502		ca		dex		                dex
.8503		18		clc		                clc
.8504		a5 1e		lda $1e		                lda up
.8506		69 2e		adc #$2e	                adc #blockread_offset
.8508		95 00		sta $00,x	                sta 0,x
.850a		a5 1f		lda $1f		                lda up+1
.850c		69 00		adc #$00	                adc #0          ; Add carry
.850e		95 01		sta $01,x	                sta 1,x
.8510						z_block_read_vector:
.8510		60		rts		                rts
.8511						xt_block_word_error:
.8511		a9 0c		lda #$0c	                lda #err_blockwords
.8513		4c 8b d8	jmp $d88b	                jmp error       ; no RTS needed
.8516						z_block_word_error:
.8516						xt_block_write:
.8516		a0 30		ldy #$30	                ldy #blockwrite_offset
.8518		b1 1e		lda ($1e),y	                lda (up),y
.851a		85 22		sta $22		                sta tmp1
.851c		c8		iny		                iny
.851d		b1 1e		lda ($1e),y	                lda (up),y
.851f		85 23		sta $23		                sta tmp1+1
.8521		6c 22 00	jmp ($0022)	                jmp (tmp1)
.8524						z_block_write:
.8524						xt_block_write_vector:
.8524		ca		dex		                dex
.8525		ca		dex		                dex
.8526		18		clc		                clc
.8527		a5 1e		lda $1e		                lda up
.8529		69 30		adc #$30	                adc #blockwrite_offset
.852b		95 00		sta $00,x	                sta 0,x
.852d		a5 1f		lda $1f		                lda up+1
.852f		69 00		adc #$00	                adc #0          ; Add carry
.8531		95 01		sta $01,x	                sta 1,x
.8533						z_block_write_vector:
.8533		60		rts		                rts
.8534						xt_bounds:
.8534		20 7a d8	jsr $d87a	                jsr underflow_2
.8537		18		clc		                clc
.8538		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.853a		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.853c		75 02		adc $02,x	                adc 2,x
.853e		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8540		94 00		sty $00,x	                sty 0,x
.8542		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.8544		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8546		75 03		adc $03,x	                adc 3,x
.8548		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.854a		94 01		sty $01,x	                sty 1,x
.854c		60		rts		z_bounds:       rts
.854d						xt_bracket_char:
.854d		20 e7 85	jsr $85e7	                jsr xt_char
.8550		20 6b 93	jsr $936b	                jsr xt_literal
.8553		60		rts		z_bracket_char: rts
.8554						xt_bracket_tick:
.8554		20 b5 a1	jsr $a1b5	                jsr xt_tick
.8557		20 6b 93	jsr $936b	                jsr xt_literal
.855a		60		rts		z_bracket_tick: rts
.855b						xt_buffblocknum:
.855b		ca		dex		                dex
.855c		ca		dex		                dex
.855d		18		clc		                clc
.855e		a5 1e		lda $1e		                lda up
.8560		69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.8562		95 00		sta $00,x	                sta 0,x
.8564		a5 1f		lda $1f		                lda up+1
.8566		69 00		adc #$00	                adc #0                          ; Adding carry
.8568		95 01		sta $01,x	                sta 1,x
.856a		60		rts		z_buffblocknum: rts
.856b						xt_buffer:
.856b		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.856d		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.856f		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8571		d0 0c		bne $857f	                bne _buffer_available ; Unused or not dirty = available
.8573		20 69 83	jsr $8369	                jsr xt_blkbuffer
.8576		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.8579		20 65 8f	jsr $8f65	                jsr xt_fetch
.857c		20 16 85	jsr $8516	                jsr xt_block_write
.857f						_buffer_available:
.857f		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8581		b5 00		lda $00,x	                lda 0,x
.8583		91 1e		sta ($1e),y	                sta (up),y
.8585		c8		iny		                iny
.8586		b5 01		lda $01,x	                lda 1,x
.8588		91 1e		sta ($1e),y	                sta (up),y
.858a		a9 01		lda #$01	                lda #1
.858c		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.858e		91 1e		sta ($1e),y	                sta (up),y
.8590						_done:
.8590		a0 28		ldy #$28	                ldy #blkbuffer_offset
.8592		b1 1e		lda ($1e),y	                lda (up),y
.8594		95 00		sta $00,x	                sta 0,x
.8596		c8		iny		                iny
.8597		b1 1e		lda ($1e),y	                lda (up),y
.8599		95 01		sta $01,x	                sta 1,x
.859b		60		rts		z_buffer:       rts
.859c						xt_buffer_colon:
.859c		20 30 89	jsr $8930	                jsr xt_create
.859f		20 3f 82	jsr $823f	                jsr xt_allot
.85a2		60		rts		z_buffer_colon: rts
.85a3						xt_buffstatus:
.85a3		ca		dex		                dex
.85a4		ca		dex		                dex
.85a5		18		clc		                clc
.85a6		a5 1e		lda $1e		                lda up
.85a8		69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85aa		95 00		sta $00,x	                sta 0,x
.85ac		a5 1f		lda $1f		                lda up+1
.85ae		69 00		adc #$00	                adc #0                  ; Adding carry
.85b0		95 01		sta $01,x	                sta 1,x
.85b2		60		rts		z_buffstatus:   rts
.85b3						xt_bye:
.85b3		4c 2b f0	jmp $f02b	                jmp platform_bye
.85b6						z_bye:
.85b6						xt_c_comma:
.85b6		20 75 d8	jsr $d875	                jsr underflow_1
.85b9		b5 00		lda $00,x	                lda 0,x
.85bb		20 2d d7	jsr $d72d	                jsr cmpl_a
.85be		e8		inx		                inx
.85bf		e8		inx		                inx
.85c0		60		rts		z_c_comma:      rts
.85c1						xt_c_fetch:
.85c1		20 75 d8	jsr $d875	                jsr underflow_1
.85c4		a1 00		lda ($00,x)	                lda (0,x)
.85c6		95 00		sta $00,x	                sta 0,x
.85c8		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.85ca		60		rts		z_c_fetch:      rts
.85cb						xt_c_store:
.85cb		20 7a d8	jsr $d87a	                jsr underflow_2
.85ce		b5 02		lda $02,x	                lda 2,x
.85d0		81 00		sta ($00,x)	                sta (0,x)
.85d2		e8		inx		                inx
.85d3		e8		inx		                inx
.85d4		e8		inx		                inx
.85d5		e8		inx		                inx
.85d6		60		rts		z_c_store:      rts
.85d7						xt_cell_plus:
.85d7		20 75 d8	jsr $d875	                jsr underflow_1
.85da		f6 00		inc $00,x	                inc 0,x
.85dc		d0 02		bne $85e0	                bne +
.85de		f6 01		inc $01,x	                inc 1,x
.85e0						+
.85e0		f6 00		inc $00,x	                inc 0,x
.85e2		d0 02		bne $85e6	                bne _done
.85e4		f6 01		inc $01,x	                inc 1,x
.85e6						_done:
.85e6		60		rts		z_cell_plus:    rts
.85e7						xt_char:
.85e7		20 c3 98	jsr $98c3	                jsr xt_parse_name
.85ea		b5 00		lda $00,x	                lda 0,x
.85ec		15 01		ora $01,x	                ora 1,x
.85ee		d0 05		bne $85f5	                bne _not_empty
.85f0		a9 05		lda #$05	                lda #err_noname
.85f2		4c 8b d8	jmp $d88b	                jmp error
.85f5						_not_empty:
.85f5		e8		inx		                inx             ; drop number of characters, leave addr
.85f6		e8		inx		                inx
.85f7		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.85f9		95 00		sta $00,x	                sta 0,x
.85fb		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.85fd		60		rts		z_char:         rts
.85fe						xt_chars:
.85fe		20 75 d8	jsr $d875	                jsr underflow_1
.8601		60		rts		z_chars:        rts
.8602						xt_cleave:
.8602		20 7a d8	jsr $d87a	                jsr underflow_2
.8605		20 47 95	jsr $9547	                jsr xt_minus_leading    ; -LEADING ( addr u )
.8608		20 43 92	jsr $9243	                jsr xt_input_to_r       ; save old imput state
.860b		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.860d		85 0a		sta $0a		                sta ciblen
.860f		b5 01		lda $01,x	                lda 1,x
.8611		85 0b		sta $0b		                sta ciblen+1
.8613		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.8615		85 08		sta $08		                sta cib
.8617		b5 03		lda $03,x	                lda 3,x
.8619		85 09		sta $09		                sta cib+1
.861b		64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.861d		64 0d		stz $0d		                stz toin+1
.861f		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8622		b5 00		lda $00,x	                lda 0,x
.8624		15 01		ora $01,x	                ora 1,x
.8626		f0 23		beq $864b	                beq _done
.8628		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.862a		38		sec		                sec
.862b		f5 00		sbc $00,x	                sbc 0,x
.862d		95 04		sta $04,x	                sta 4,x
.862f		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.8631		f5 01		sbc $01,x	                sbc 1,x
.8633		95 05		sta $05,x	                sta 5,x
.8635		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8637		18		clc		                clc
.8638		75 00		adc $00,x	                adc 0,x
.863a		95 06		sta $06,x	                sta 6,x
.863c		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.863e		75 01		adc $01,x	                adc 1,x
.8640		95 07		sta $07,x	                sta 7,x
.8642		20 22 a4	jsr $a422	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.8645		20 47 95	jsr $9547	                jsr xt_minus_leading
.8648		20 22 a4	jsr $a422	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.864b						_done:
.864b		20 87 9a	jsr $9a87	                jsr xt_r_to_input
.864e		60		rts		z_cleave:       rts
.864f						xt_cmove:
.864f		20 7f d8	jsr $d87f	                jsr underflow_3
.8652		b5 02		lda $02,x	                lda 2,x
.8654		85 24		sta $24		                sta tmp2        ; use tmp2 because easier to remember
.8656		b5 03		lda $03,x	                lda 3,x
.8658		85 25		sta $25		                sta tmp2+1
.865a		b5 04		lda $04,x	                lda 4,x
.865c		85 22		sta $22		                sta tmp1        ; use tmp1 because easier to remember
.865e		b5 05		lda $05,x	                lda 5,x
.8660		85 23		sta $23		                sta tmp1+1
.8662		a0 00		ldy #$00	                ldy #0
.8664		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.8666		f0 0f		beq $8677	                beq _dopartial
.8668						_page:
.8668		b1 22		lda ($22),y	                lda (tmp1),y
.866a		91 24		sta ($24),y	                sta (tmp2),y
.866c		c8		iny		                iny
.866d		d0 f9		bne $8668	                bne _page
.866f		e6 23		inc $23		                inc tmp1+1
.8671		e6 25		inc $25		                inc tmp2+1
.8673		d6 01		dec $01,x	                dec 1,x
.8675		d0 f1		bne $8668	                bne _page
.8677						_dopartial:
.8677		b5 00		lda $00,x	                lda 0,x         ; length of last page
.8679		f0 09		beq $8684	                beq _done
.867b						_partial:
.867b		b1 22		lda ($22),y	                lda (tmp1),y
.867d		91 24		sta ($24),y	                sta (tmp2),y
.867f		c8		iny		                iny
.8680		d6 00		dec $00,x	                dec 0,x
.8682		d0 f7		bne $867b	                bne _partial
.8684						_done:
.8684		8a		txa		                txa
.8685		18		clc		                clc
.8686		69 06		adc #$06	                adc #6
.8688		aa		tax		                tax
.8689		60		rts		z_cmove:        rts
.868a						xt_cmove_up:
.868a		20 7f d8	jsr $d87f	                jsr underflow_3
.868d		b5 02		lda $02,x	                lda 2,x
.868f		85 24		sta $24		                sta tmp2        ; use tmp2 because easier to remember
.8691		b5 03		lda $03,x	                lda 3,x
.8693		18		clc		                clc
.8694		75 01		adc $01,x	                adc 1,x
.8696		85 25		sta $25		                sta tmp2+1      ; point to last page of destination
.8698		b5 04		lda $04,x	                lda 4,x
.869a		85 22		sta $22		                sta tmp1        ; use tmp1 because easier to remember
.869c		b5 05		lda $05,x	                lda 5,x
.869e		18		clc		                clc
.869f		75 01		adc $01,x	                adc 1,x
.86a1		85 23		sta $23		                sta tmp1+1      ; point to last page of source
.86a3		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86a5		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86a7		f0 0e		beq $86b7	                beq _nopartial
.86a9						_outerloop:
.86a9		88		dey		                dey
.86aa		f0 07		beq $86b3	                beq _finishpage
.86ac						_innerloop:
.86ac		b1 22		lda ($22),y	                lda (tmp1),y
.86ae		91 24		sta ($24),y	                sta (tmp2),y
.86b0		88		dey		                dey
.86b1		d0 f9		bne $86ac	                bne _innerloop
.86b3						_finishpage:
.86b3		b2 22		lda ($22)	                lda (tmp1)      ; handle y = 0 separately
.86b5		92 24		sta ($24)	                sta (tmp2)
.86b7						_nopartial:
.86b7		c6 23		dec $23		                dec tmp1+1      ; back up to previous pages
.86b9		c6 25		dec $25		                dec tmp2+1
.86bb		d6 01		dec $01,x	                dec 1,x
.86bd		d0 ea		bne $86a9	                bne _outerloop
.86bf						_done:
.86bf		8a		txa		                txa
.86c0		18		clc		                clc
.86c1		69 06		adc #$06	                adc #6
.86c3		aa		tax		                tax
.86c4		60		rts		z_cmove_up:     rts
.86c5						xt_colon:
.86c5		a5 16		lda $16		                lda state
.86c7		05 17		ora $17		                ora state+1
.86c9		f0 05		beq $86d0	                beq +
.86cb		a9 07		lda #$07	                lda #err_state
.86cd		4c 8b d8	jmp $d88b	                jmp error
.86d0						+
.86d0		c6 16		dec $16		                dec state
.86d2		c6 17		dec $17		                dec state+1
.86d4		a9 40		lda #$40	                lda #%01000000
.86d6		04 20		tsb $20		                tsb status
.86d8		20 bc d7	jsr $d7bc	                jsr current_to_dp
.86db		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.86dd		48		pha		                pha
.86de		a5 02		lda $02		                lda dp
.86e0		48		pha		                pha
.86e1		a9 80		lda #$80	                lda #%10000000
.86e3		04 20		tsb $20		                tsb status
.86e5		20 30 89	jsr $8930	                jsr xt_create
.86e8		20 bc d7	jsr $d7bc	                jsr current_to_dp   ; This might be able to be omitted
.86eb		a5 02		lda $02		                lda dp
.86ed		85 04		sta $04		                sta workword
.86ef		a5 03		lda $03		                lda dp+1
.86f1		85 05		sta $05		                sta workword+1
.86f3		68		pla		                pla
.86f4		85 02		sta $02		                sta dp
.86f6		68		pla		                pla
.86f7		85 03		sta $03		                sta dp+1
.86f9		20 cf d7	jsr $d7cf	                jsr dp_to_current
.86fc		a5 00		lda $00		                lda cp
.86fe		38		sec		                sec
.86ff		e9 03		sbc #$03	                sbc #3
.8701		85 00		sta $00		                sta cp
.8703		b0 02		bcs $8707	                bcs _done
.8705		c6 01		dec $01		                dec cp+1
.8707						_done:
.8707		60		rts		z_colon:        rts
.8708						xt_colon_noname:
.8708		a5 16		lda $16		                lda state
.870a		05 17		ora $17		                ora state+1
.870c		f0 05		beq $8713	                beq +
.870e		a9 07		lda #$07	                lda #err_state
.8710		4c 8b d8	jmp $d88b	                jmp error
.8713						+
.8713		c6 16		dec $16		                dec state
.8715		c6 17		dec $17		                dec state+1
.8717		a9 40		lda #$40	                lda #%01000000
.8719		14 20		trb $20		                trb status
.871b		a5 00		lda $00		                lda cp
.871d		85 04		sta $04		                sta workword
.871f		a5 01		lda $01		                lda cp+1
.8721		85 05		sta $05		                sta workword+1
.8723						_done:
.8723		60		rts		z_colon_noname:        rts
.8724						xt_comma:
.8724		20 75 d8	jsr $d875	                jsr underflow_1
.8727		b5 00		lda $00,x	                lda 0,x
.8729		92 00		sta ($00)	                sta (cp)
.872b		e6 00		inc $00		                inc cp
.872d		d0 02		bne $8731	                bne +
.872f		e6 01		inc $01		                inc cp+1
.8731						+
.8731		b5 01		lda $01,x	                lda 1,x
.8733		92 00		sta ($00)	                sta (cp)
.8735		e6 00		inc $00		                inc cp
.8737		d0 02		bne $873b	                bne _done
.8739		e6 01		inc $01		                inc cp+1
.873b						_done:
.873b		e8		inx		                inx
.873c		e8		inx		                inx
.873d		60		rts		z_comma:        rts
.873e						xt_compare:
.873e		20 84 d8	jsr $d884	                jsr underflow_4
.8741		b5 02		lda $02,x	                lda 2,x
.8743		85 24		sta $24		                sta tmp2
.8745		b5 03		lda $03,x	                lda 3,x
.8747		85 25		sta $25		                sta tmp2+1
.8749		b5 06		lda $06,x	                lda 6,x
.874b		85 22		sta $22		                sta tmp1
.874d		b5 07		lda $07,x	                lda 7,x
.874f		85 23		sta $23		                sta tmp1+1
.8751						_compare_loop:
.8751		b5 04		lda $04,x	                lda 4,x
.8753		15 05		ora $05,x	                ora 5,x
.8755		f0 2c		beq $8783	                beq _str1_done
.8757		b5 00		lda $00,x	                lda 0,x
.8759		15 01		ora $01,x	                ora 1,x
.875b		f0 3a		beq $8797	                beq _greater    ; Str2 empty first
.875d						_check_letter:
.875d		b2 22		lda ($22)	                lda (tmp1)
.875f		d2 24		cmp ($24)	                cmp (tmp2)
.8761		90 26		bcc $8789	                bcc _less
.8763		d0 32		bne $8797	                bne _greater
.8765						_next_letter:
.8765		e6 22		inc $22		                inc tmp1
.8767		d0 02		bne $876b	                bne +
.8769		e6 23		inc $23		                inc tmp1+1
.876b						+
.876b		e6 24		inc $24		                inc tmp2
.876d		d0 02		bne $8771	                bne +
.876f		e6 25		inc $25		                inc tmp2+1
.8771						+
.8771		b5 04		lda $04,x	                lda 4,x
.8773		d0 02		bne $8777	                bne +
.8775		d6 05		dec $05,x	                dec 5,x
.8777						+
.8777		d6 04		dec $04,x	                dec 4,x
.8779		b5 00		lda $00,x	                lda 0,x
.877b		d0 02		bne $877f	                bne +
.877d		d6 01		dec $01,x	                dec 1,x
.877f						+
.877f		d6 00		dec $00,x	                dec 0,x
.8781		80 ce		bra $8751	                bra _compare_loop
.8783						_str1_done:
.8783		b5 00		lda $00,x	                lda 0,x
.8785		15 01		ora $01,x	                ora 1,x
.8787		f0 08		beq $8791	                beq _equal      ; Both out of letters
.8789						_less:
.8789		a9 ff		lda #$ff	                lda #$FF
.878b		95 06		sta $06,x	                sta 6,x
.878d		95 07		sta $07,x	                sta 7,x
.878f		80 0c		bra $879d	                bra _done
.8791						_equal:
.8791		74 06		stz $06,x	                stz 6,x
.8793		74 07		stz $07,x	                stz 7,x
.8795		80 06		bra $879d	                bra _done
.8797						_greater:
.8797		a9 01		lda #$01	                lda #1
.8799		95 06		sta $06,x	                sta 6,x
.879b		74 07		stz $07,x	                stz 7,x
.879d						_done:
.879d		8a		txa		                txa
.879e		18		clc		                clc
.879f		69 06		adc #$06	                adc #6
.87a1		aa		tax		                tax
.87a2		60		rts		z_compare:      rts
.87a3						xt_compile_comma:
.87a3		20 75 d8	jsr $d875	                jsr underflow_1
.87a6		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87a8		48		pha		                pha
.87a9		b5 00		lda $00,x	                lda 0,x
.87ab		48		pha		                pha                     ; LSB
.87ac		20 59 92	jsr $9259	                jsr xt_int_to_name      ; ( xt -- nt )
.87af		b5 00		lda $00,x	                lda 0,x
.87b1		15 01		ora $01,x	                ora 1,x
.87b3		d0 03		bne $87b8	                bne _check_nt
.87b5		4c b1 88	jmp $88b1	                jmp compile_as_jump
.87b8						_check_nt:
.87b8		b5 00		lda $00,x	                lda 0,x
.87ba		85 2a		sta $2a		                sta tmptos
.87bc		b5 01		lda $01,x	                lda 1,x
.87be		85 2b		sta $2b		                sta tmptos+1
.87c0		f6 00		inc $00,x	                inc 0,x
.87c2		d0 02		bne $87c6	                bne +
.87c4		f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.87c6						+
.87c6		a1 00		lda ($00,x)	                lda (0,x)
.87c8		85 26		sta $26		                sta tmp3                ; keep copy of status byte for NN
.87ca		29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.87cc		f0 0d		beq $87db	                beq _compile_check
.87ce		a5 2a		lda $2a		                lda tmptos
.87d0		95 00		sta $00,x	                sta 0,x
.87d2		a5 2b		lda $2b		                lda tmptos+1
.87d4		95 01		sta $01,x	                sta 1,x
.87d6		20 23 a7	jsr $a723	                jsr xt_wordsize         ; ( nt -- u )
.87d9		80 27		bra $8802	                bra _compile_as_code
.87db						_compile_check:
.87db		a5 26		lda $26		                lda tmp3
.87dd		29 08		and #$08	                and #NN
.87df		f0 03		beq $87e4	                beq _check_size_limit
.87e1		4c b1 88	jmp $88b1	                jmp compile_as_jump    ; too far for BRA
.87e4						_check_size_limit:
.87e4		a5 2a		lda $2a		                lda tmptos
.87e6		95 00		sta $00,x	                sta 0,x
.87e8		a5 2b		lda $2b		                lda tmptos+1
.87ea		95 01		sta $01,x	                sta 1,x
.87ec		20 23 a7	jsr $a723	                jsr xt_wordsize         ; ( nt -- u )
.87ef		b5 01		lda $01,x	                lda 1,x
.87f1		c5 1b		cmp $1b		                cmp nc_limit+1
.87f3		90 0d		bcc $8802	                bcc _compile_as_code    ; user-defined limit MSB
.87f5		d0 08		bne $87ff	                bne _jumpto_compile_as_jump
.87f7		b5 00		lda $00,x	                lda 0,x
.87f9		c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.87fb		90 05		bcc $8802	                bcc _compile_as_code    ; Allow native compiling for less
.87fd		f0 03		beq $8802	                beq _compile_as_code    ; than or equal to the limit.
.87ff						_jumpto_compile_as_jump:
.87ff		4c b1 88	jmp $88b1	                jmp compile_as_jump    ; too far for BRA
.8802						_compile_as_code:
.8802		ca		dex		                dex
.8803		ca		dex		                dex                     ; ( -- u ? )
.8804		ca		dex		                dex
.8805		ca		dex		                dex                     ; ( -- u ? ? )
.8806		b5 04		lda $04,x	                lda 4,x
.8808		95 00		sta $00,x	                sta 0,x                 ; LSB of u
.880a		b5 05		lda $05,x	                lda 5,x
.880c		95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.880e		68		pla		                pla
.880f		95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8811		68		pla		                pla
.8812		95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.8814		a5 00		lda $00		                lda cp                  ; LSB of cp
.8816		95 02		sta $02,x	                sta 2,x
.8818		a5 01		lda $01		                lda cp+1
.881a		95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.881c		a0 00		ldy #$00	                ldy #0
.881e						_strip_loop:
.881e		b9 9f 88	lda $889f,y	                lda strip_table,y      ; LSB of first word
.8821		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8823		d0 07		bne $882c	                bne _next_entry
.8825		b9 a0 88	lda $88a0,y	                lda strip_table+1,y
.8828		d5 05		cmp $05,x	                cmp 5,x
.882a		f0 0c		beq $8838	                beq _found_entry
.882c						_next_entry:
.882c		b9 9f 88	lda $889f,y	                lda strip_table,y      ; pointing to LSB
.882f		19 a0 88	ora $88a0,y	                ora strip_table+1,y    ; get MSB
.8832		f0 22		beq $8856	                beq _underflow_strip    ; table done, let's get out of here
.8834		c8		iny		                iny
.8835		c8		iny		                iny
.8836		80 e6		bra $881e	                bra _strip_loop
.8838						_found_entry:
.8838		98		tya		                tya
.8839		4a		lsr a		                lsr
.883a		a8		tay		                tay
.883b		b9 ab 88	lda $88ab,y	                lda strip_size,y
.883e		85 2a		sta $2a		                sta tmptos              ; save a copy
.8840		18		clc		                clc
.8841		75 04		adc $04,x	                adc 4,x
.8843		95 04		sta $04,x	                sta 4,x
.8845		90 02		bcc $8849	                bcc+
.8847		f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8849						+
.8849		06 2a		asl $2a		                asl tmptos
.884b		38		sec		                sec
.884c		b5 00		lda $00,x	                lda 0,x
.884e		e5 2a		sbc $2a		                sbc tmptos
.8850		95 00		sta $00,x	                sta 0,x
.8852		b0 02		bcs $8856	                bcs +
.8854		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8856						+
.8856						_underflow_strip:
.8856		a5 1c		lda $1c		                lda uf_strip
.8858		05 1d		ora $1d		                ora uf_strip+1
.885a		f0 1c		beq $8878	                beq cmpl_inline
.885c		a5 26		lda $26		                lda tmp3
.885e		29 10		and #$10	                and #UF
.8860		f0 16		beq $8878	                beq cmpl_inline
.8862		18		clc		                clc
.8863		b5 04		lda $04,x	                lda 4,x
.8865		69 03		adc #$03	                adc #3
.8867		95 04		sta $04,x	                sta 4,x
.8869		90 02		bcc $886d	                bcc +
.886b		f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.886d						+
.886d		38		sec		                sec
.886e		b5 00		lda $00,x	                lda 0,x
.8870		e9 03		sbc #$03	                sbc #3
.8872		95 00		sta $00,x	                sta 0,x
.8874		b0 02		bcs $8878	                bcs +
.8876		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.8878						+
.8878						cmpl_inline:
.8878		b5 01		lda $01,x	                lda 1,x                 ; MSB
.887a		48		pha		                pha
.887b		b5 00		lda $00,x	                lda 0,x                 ; LSB
.887d		48		pha		                pha
.887e		20 a6 95	jsr $95a6	                jsr xt_move
.8881		18		clc		                clc
.8882		68		pla		                pla                     ; LSB
.8883		65 00		adc $00		                adc cp
.8885		85 00		sta $00		                sta cp
.8887		68		pla		                pla                     ; MSB
.8888		65 01		adc $01		                adc cp+1
.888a		85 01		sta $01		                sta cp+1
.888c		60		rts		                rts
.888d						cmpl_inline_y:
.888d		ca		dex		                dex             ; set up stack as ( src dst n -- )
.888e		ca		dex		                dex
.888f		ca		dex		                dex
.8890		ca		dex		                dex
.8891		94 00		sty $00,x	                sty 0,x
.8893		74 01		stz $01,x	                stz 1,x             ; assume < 256 bytes
.8895		a5 00		lda $00		                lda cp
.8897		95 02		sta $02,x	                sta 2,x
.8899		a5 01		lda $01		                lda cp+1
.889b		95 03		sta $03,x	                sta 3,x
.889d		80 d9		bra $8878	                bra cmpl_inline
.889f						strip_table:
>889f		76 9a 61 9a 14 a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88a5		46 a4 cc a3 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88ab						strip_size:
>88ab		04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88b1						compile_as_jump:
.88b1		a9 20		lda #$20	                lda #$20
.88b3		92 00		sta ($00)	                sta (cp)
.88b5		a0 01		ldy #$01	                ldy #1
.88b7		68		pla		                pla             ; LSB
.88b8		91 00		sta ($00),y	                sta (cp),y
.88ba		c8		iny		                iny
.88bb		68		pla		                pla             ; MSB
.88bc		91 00		sta ($00),y	                sta (cp),y
.88be		a9 03		lda #$03	                lda #3
.88c0		18		clc		                clc
.88c1		65 00		adc $00		                adc cp
.88c3		85 00		sta $00		                sta cp
.88c5		90 02		bcc $88c9	                bcc +
.88c7		e6 01		inc $01		                inc cp+1
.88c9						+
.88c9		e8		inx		                inx             ; drop xt
.88ca		e8		inx		                inx
.88cb						z_compile_comma:
.88cb		60		rts		                rts
.88cc						xt_compile_only:
.88cc		20 bc d7	jsr $d7bc	                jsr current_to_dp
.88cf		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.88d1		b1 02		lda ($02),y	                lda (dp),y
.88d3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.88d5		91 02		sta ($02),y	                sta (dp),y
.88d7		60		rts		z_compile_only: rts
.88d8						xt_value:
.88d8						xt_constant:
.88d8		20 75 d8	jsr $d875	                jsr underflow_1
.88db		20 30 89	jsr $8930	                jsr xt_create
.88de		38		sec		                sec
.88df		a5 00		lda $00		                lda cp
.88e1		e9 02		sbc #$02	                sbc #2
.88e3		85 22		sta $22		                sta tmp1
.88e5		a5 01		lda $01		                lda cp+1
.88e7		e9 00		sbc #$00	                sbc #0
.88e9		85 23		sta $23		                sta tmp1+1
.88eb		a9 36		lda #$36	                lda #<doconst           ; LSB of DOCONST
.88ed		92 22		sta ($22)	                sta (tmp1)
.88ef		a0 01		ldy #$01	                ldy #1
.88f1		a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.88f3		91 22		sta ($22),y	                sta (tmp1),y
.88f5		20 24 87	jsr $8724	                jsr xt_comma            ; drop through to adjust_z
.88f8						adjust_z:
.88f8		20 1c 93	jsr $931c	                jsr xt_latestnt         ; gives us ( -- nt )
.88fb		b5 00		lda $00,x	                lda 0,x
.88fd		85 22		sta $22		                sta tmp1
.88ff		b5 01		lda $01,x	                lda 1,x
.8901		85 23		sta $23		                sta tmp1+1
.8903		a0 06		ldy #$06	                ldy #6
.8905		b1 22		lda ($22),y	                lda (tmp1),y
.8907		18		clc		                clc
.8908		69 02		adc #$02	                adc #2
.890a		91 22		sta ($22),y	                sta (tmp1),y
.890c		c8		iny		                iny
.890d		b1 22		lda ($22),y	                lda (tmp1),y
.890f		69 00		adc #$00	                adc #0                  ; only need carry
.8911		91 22		sta ($22),y	                sta (tmp1),y
.8913		e8		inx		                inx
.8914		e8		inx		                inx
.8915						z_value:
.8915		60		rts		z_constant:     rts
.8916						xt_count:
.8916		20 75 d8	jsr $d875	                jsr underflow_1
.8919		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.891b		a8		tay		                tay
.891c		f6 00		inc $00,x	                inc 0,x         ; LSB
.891e		d0 02		bne $8922	                bne +
.8920		f6 01		inc $01,x	                inc 1,x         ; MSB
.8922		98		tya		+               tya
.8923		ca		dex		                dex
.8924		ca		dex		                dex
.8925		95 00		sta $00,x	                sta 0,x         ; LSB
.8927		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8929		60		rts		z_count:        rts
.892a						xt_cr:
.892a		a9 0a		lda #$0a	                lda #AscLF
.892c		20 db 8d	jsr $8ddb	                jsr emit_a
.892f		60		rts		z_cr:           rts
.8930						xt_create:
.8930		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( addr u )
.8933		b5 00		lda $00,x	                lda 0,x
.8935		15 01		ora $01,x	                ora 1,x
.8937		d0 05		bne $893e	                bne _got_name
.8939		a9 05		lda #$05	                lda #err_noname
.893b		4c 8b d8	jmp $d88b	                jmp error
.893e						_got_name:
.893e		74 01		stz $01,x	                stz 1,x
.8940		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( addr u addr u )
.8943		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8946		b5 00		lda $00,x	                lda 0,x
.8948		15 01		ora $01,x	                ora 1,x
.894a		f0 1e		beq $896a	                beq _new_name           ; We haven't seen this one before.
.894c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.894d		e8		inx		                inx
.894e		24 20		bit $20		                bit status
.8950		10 08		bpl $895a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8952		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8954		05 20		ora $20		                ora status
.8956		85 20		sta $20		                sta status
.8958		80 18		bra $8972	                bra _process_name
.895a						_redefined_name:
.895a		a9 02		lda #$02	                lda #str_redefined
.895c		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.895f		20 5c a3	jsr $a35c	                jsr xt_two_dup           ; ( addr u addr u )
.8962		20 a7 a4	jsr $a4a7	                jsr xt_type
.8965		20 cc a0	jsr $a0cc	                jsr xt_space
.8968		80 08		bra $8972	                bra _process_name
.896a						_new_name:
.896a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.896b		e8		inx		                inx
.896c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.896e		25 20		and $20		                and status
.8970		85 20		sta $20		                sta status
.8972						_process_name:
.8972		b5 00		lda $00,x	                lda 0,x
.8974		85 24		sta $24		                sta tmp2                ; store length of string in tmp2
.8976		a5 00		lda $00		                lda cp
.8978		85 22		sta $22		                sta tmp1
.897a		a5 01		lda $01		                lda cp+1
.897c		85 23		sta $23		                sta tmp1+1
.897e		b5 00		lda $00,x	                lda 0,x
.8980		18		clc		                clc
.8981		69 08		adc #$08	                adc #8
.8983		85 26		sta $26		                sta tmp3                ; total header length
.8985		18		clc		                clc
.8986		69 03		adc #$03	                adc #3
.8988		95 00		sta $00,x	                sta 0,x
.898a		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.898c		20 3f 82	jsr $823f	                jsr xt_allot    ; ( addr )
.898f		20 bc d7	jsr $d7bc	                jsr current_to_dp
.8992		a0 00		ldy #$00	                ldy #0
.8994		a5 24		lda $24		                lda tmp2
.8996		91 22		sta ($22),y	                sta (tmp1),y
.8998		a9 08		lda #$08	                lda #NN
.899a		09 20		ora #$20	                ora #HC
.899c		c8		iny		                iny
.899d		91 22		sta ($22),y	                sta (tmp1),y
.899f		c8		iny		                iny
.89a0		a5 02		lda $02		                lda dp
.89a2		91 22		sta ($22),y	                sta (tmp1),y
.89a4		c8		iny		                iny
.89a5		a5 03		lda $03		                lda dp+1
.89a7		91 22		sta ($22),y	                sta (tmp1),y
.89a9		c8		iny		                iny
.89aa		a5 23		lda $23		                lda tmp1+1
.89ac		85 03		sta $03		                sta dp+1
.89ae		a5 22		lda $22		                lda tmp1
.89b0		85 02		sta $02		                sta dp
.89b2		18		clc		                clc
.89b3		65 26		adc $26		                adc tmp3        ; add total header length
.89b5		91 22		sta ($22),y	                sta (tmp1),y
.89b7		48		pha		                pha             ; we need this in the next step
.89b8		c8		iny		                iny
.89b9		a5 23		lda $23		                lda tmp1+1
.89bb		69 00		adc #$00	                adc #0          ; only need the carry
.89bd		91 22		sta ($22),y	                sta (tmp1),y
.89bf		c8		iny		                iny
.89c0		68		pla		                pla             ; LSB of "z_" address
.89c1		18		clc		                clc
.89c2		69 03		adc #$03	                adc #3
.89c4		91 22		sta ($22),y	                sta (tmp1),y
.89c6		88		dey		                dey             ; get the MSB of xt back
.89c7		b1 22		lda ($22),y	                lda (tmp1),y
.89c9		69 00		adc #$00	                adc #0          ; only need the carry
.89cb		c8		iny		                iny
.89cc		c8		iny		                iny
.89cd		91 22		sta ($22),y	                sta (tmp1),y
.89cf		c8		iny		                iny
.89d0		b5 00		lda $00,x	                lda 0,x
.89d2		38		sec		                sec
.89d3		e9 08		sbc #$08	                sbc #8
.89d5		85 2a		sta $2a		                sta tmptos
.89d7		b5 01		lda $01,x	                lda 1,x
.89d9		e9 00		sbc #$00	                sbc #0          ; only need carry
.89db		85 2b		sta $2b		                sta tmptos+1
.89dd						_name_loop:
.89dd		b1 2a		lda ($2a),y	                lda (tmptos),y
.89df		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.89e1		b0 07		bcs $89ea	                bcs _store_name
.89e3		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.89e5		90 03		bcc $89ea	                bcc _store_name
.89e7		18		clc		                clc
.89e8		69 20		adc #$20	                adc #$20
.89ea						_store_name:
.89ea		91 22		sta ($22),y	                sta (tmp1),y
.89ec		c8		iny		                iny
.89ed		c6 24		dec $24		                dec tmp2
.89ef		d0 ec		bne $89dd	                bne _name_loop
.89f1		a9 20		lda #$20	                lda #$20        ; opcode of JSR
.89f3		91 22		sta ($22),y	                sta (tmp1),y
.89f5		c8		iny		                iny
.89f6		a9 7c		lda #$7c	                lda #<dovar
.89f8		91 22		sta ($22),y	                sta (tmp1),y
.89fa		c8		iny		                iny
.89fb		a9 d7		lda #$d7	                lda #>dovar
.89fd		91 22		sta ($22),y	                sta (tmp1),y
.89ff		20 cf d7	jsr $d7cf	                jsr dp_to_current
.8a02		e8		inx		                inx
.8a03		e8		inx		                inx
.8a04		60		rts		z_create:       rts
.8a05						xt_d_minus:
.8a05		20 84 d8	jsr $d884	                jsr underflow_4 ; two double numbers
.8a08		38		sec		                sec
.8a09		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a0b		f5 02		sbc $02,x	                sbc 2,x
.8a0d		95 06		sta $06,x	                sta 6,x
.8a0f		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a11		f5 03		sbc $03,x	                sbc 3,x
.8a13		95 07		sta $07,x	                sta 7,x
.8a15		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a17		f5 00		sbc $00,x	                sbc 0,x
.8a19		95 04		sta $04,x	                sta 4,x
.8a1b		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a1d		f5 01		sbc $01,x	                sbc 1,x
.8a1f		95 05		sta $05,x	                sta 5,x
.8a21		e8		inx		                inx
.8a22		e8		inx		                inx
.8a23		e8		inx		                inx
.8a24		e8		inx		                inx
.8a25		60		rts		z_d_minus:      rts
.8a26						xt_d_plus:
.8a26		20 84 d8	jsr $d884	                jsr underflow_4 ; two double numbers
.8a29		18		clc		                clc
.8a2a		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a2c		75 06		adc $06,x	                adc 6,x
.8a2e		95 06		sta $06,x	                sta 6,x
.8a30		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a32		75 07		adc $07,x	                adc 7,x
.8a34		95 07		sta $07,x	                sta 7,x
.8a36		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a38		75 04		adc $04,x	                adc 4,x
.8a3a		95 04		sta $04,x	                sta 4,x
.8a3c		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a3e		75 05		adc $05,x	                adc 5,x
.8a40		95 05		sta $05,x	                sta 5,x
.8a42		e8		inx		                inx
.8a43		e8		inx		                inx
.8a44		e8		inx		                inx
.8a45		e8		inx		                inx
.8a46		60		rts		z_d_plus:       rts
.8a47						xt_d_to_s:
.8a47		20 7a d8	jsr $d87a	                jsr underflow_2
.8a4a		e8		inx		                inx
.8a4b		e8		inx		                inx
.8a4c		60		rts		z_d_to_s:       rts
.8a4d						xt_dabs:
.8a4d		20 7a d8	jsr $d87a	                jsr underflow_2 ; double number
.8a50		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a52		10 17		bpl $8a6b	                bpl _done       ; positive, we get off light
.8a54		a0 00		ldy #$00	                ldy #0
.8a56		38		sec		                sec
.8a57		98		tya		                tya
.8a58		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a5a		95 02		sta $02,x	                sta 2,x
.8a5c		98		tya		                tya
.8a5d		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a5f		95 03		sta $03,x	                sta 3,x
.8a61		98		tya		                tya
.8a62		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a64		95 00		sta $00,x	                sta 0,x
.8a66		98		tya		                tya
.8a67		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a69		95 01		sta $01,x	                sta 1,x
.8a6b						_done:
.8a6b		60		rts		z_dabs:         rts
.8a6c						xt_decimal:
.8a6c		a9 0a		lda #$0a	                lda #10
.8a6e		85 18		sta $18		                sta base
.8a70		64 19		stz $19		                stz base+1              ; paranoid
.8a72		60		rts		z_decimal:      rts
.8a73						xt_defer:
.8a73		20 30 89	jsr $8930	                jsr xt_create
.8a76		a5 00		lda $00		                lda cp          ; LSB
.8a78		38		sec		                sec
.8a79		e9 02		sbc #$02	                sbc #2
.8a7b		85 22		sta $22		                sta tmp1
.8a7d		a5 01		lda $01		                lda cp+1        ; MSB
.8a7f		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8a81		85 23		sta $23		                sta tmp1+1
.8a83		a0 00		ldy #$00	                ldy #0
.8a85		a9 4a		lda #$4a	                lda #<dodefer   ; LSB
.8a87		91 22		sta ($22),y	                sta (tmp1),y
.8a89		c8		iny		                iny
.8a8a		a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8a8c		91 22		sta ($22),y	                sta (tmp1),y
.8a8e		a9 5e		lda #$5e	                lda #<defer_error
.8a90		92 00		sta ($00)	                sta (cp)
.8a92		e6 00		inc $00		                inc cp
.8a94		d0 02		bne $8a98	                bne +
.8a96		e6 01		inc $01		                inc cp+1
.8a98						+
.8a98		a9 d7		lda #$d7	                lda #>defer_error
.8a9a		92 00		sta ($00)	                sta (cp)
.8a9c		e6 00		inc $00		                inc cp
.8a9e		d0 02		bne $8aa2	                bne +
.8aa0		e6 01		inc $01		                inc cp+1
.8aa2						+
.8aa2		20 f8 88	jsr $88f8	                jsr adjust_z    ; adjust header to correct length
.8aa5		60		rts		z_defer:        rts
.8aa6						xt_defer_fetch:
.8aa6		20 31 a2	jsr $a231	                jsr xt_to_body
.8aa9		20 65 8f	jsr $8f65	                jsr xt_fetch
.8aac		60		rts		z_defer_fetch:  rts
.8aad						xt_defer_store:
.8aad		20 31 a2	jsr $a231	                jsr xt_to_body
.8ab0		20 3b a1	jsr $a13b	                jsr xt_store
.8ab3		60		rts		z_defer_store:  rts
.8ab4						xt_definitions:
.8ab4		a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8ab6		b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8ab8		a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8aba		91 1e		sta ($1e),y	                sta (up),y
.8abc		60		rts		z_definitions:  rts
.8abd						xt_depth:
.8abd		a9 78		lda #$78	                lda #dsp0
.8abf		86 28		stx $28		                stx tmpdsp
.8ac1		38		sec		                sec
.8ac2		e5 28		sbc $28		                sbc tmpdsp
.8ac4		4a		lsr a		                lsr
.8ac5		ca		dex		                dex
.8ac6		ca		dex		                dex
.8ac7		95 00		sta $00,x	                sta 0,x
.8ac9		74 01		stz $01,x	                stz 1,x
.8acb		60		rts		z_depth:        rts
.8acc						xt_digit_question:
.8acc		20 75 d8	jsr $d875	                jsr underflow_1
.8acf		ca		dex		                dex
.8ad0		ca		dex		                dex
.8ad1		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8ad3		74 01		stz $01,x	                stz 1,x
.8ad5		74 03		stz $03,x	                stz 3,x                 ; paranoid
.8ad7		b5 02		lda $02,x	                lda 2,x
.8ad9		c9 30		cmp #$30	                cmp #'0'
.8adb		90 23		bcc $8b00	                bcc _done               ; failure flag already set
.8add		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8adf		90 12		bcc $8af3	                bcc _checkbase
.8ae1		c9 41		cmp #$41	                cmp #'A'
.8ae3		90 1b		bcc $8b00	                bcc _done               ; failure flag is already set
.8ae5		c9 61		cmp #$61	                cmp #'a'
.8ae7		90 07		bcc $8af0	                bcc _case_done          ; not lower case, too low
.8ae9		c9 7b		cmp #$7b	                cmp #'z'+1
.8aeb		b0 03		bcs $8af0	                bcs _case_done          ; not lower case, too high
.8aed		18		clc		                clc                     ; just right
.8aee		69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8af0						_case_done:
.8af0		38		sec		                sec
.8af1		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8af3						_checkbase:
.8af3		38		sec		                sec
.8af4		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8af6		c5 18		cmp $18		                cmp base
.8af8		b0 06		bcs $8b00	                bcs _done               ; already have false flag
.8afa		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8afc		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8afe		d6 01		dec $01,x	                dec 1,x
.8b00						_done:
.8b00						z_digit_question:
.8b00		60		rts		                rts
.8b01						xt_disasm:
.8b01		20 7a d8	jsr $d87a	                jsr underflow_2
.8b04		20 d5 ac	jsr $acd5	                jsr disassembler
.8b07		60		rts		z_disasm:       rts
.8b08						xt_dnegate:
.8b08		20 7a d8	jsr $d87a	                jsr underflow_2 ; double number
.8b0b		a0 00		ldy #$00	     		ldy #0
.8b0d		38		sec		                sec
.8b0e		98		tya		                tya
.8b0f		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b11		95 02		sta $02,x	                sta 2,x
.8b13		98		tya		                tya
.8b14		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b16		95 03		sta $03,x	                sta 3,x
.8b18		98		tya		                tya
.8b19		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b1b		95 00		sta $00,x	                sta 0,x
.8b1d		98		tya		                tya
.8b1e		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b20		95 01		sta $01,x	                sta 1,x
.8b22		60		rts		z_dnegate:      rts
.8b23						xt_question_do:
.8b23		a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b25		85 22		sta $22		                sta tmp1
.8b27		80 02		bra $8b2b	                bra do_common           ; skip flag for DO
.8b29						xt_do:
.8b29		64 22		stz $22		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b2b						do_common:
.8b2b		ca		dex		                dex
.8b2c		ca		dex		                dex
.8b2d		a5 01		lda $01		                lda cp+1
.8b2f		95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b31		a5 00		lda $00		                lda cp
.8b33		95 00		sta $00,x	                sta 0,x                 ; LSB
.8b35		18		clc		                clc
.8b36		69 06		adc #$06	                adc #6
.8b38		85 00		sta $00		                sta cp
.8b3a		90 02		bcc $8b3e	                bcc +
.8b3c		e6 01		inc $01		                inc cp+1
.8b3e						+
.8b3e		a5 22		lda $22		                lda tmp1
.8b40		f0 0f		beq $8b51	                beq _compile_do
.8b42		ca		dex		                dex
.8b43		ca		dex		                dex
.8b44		a9 94		lda #$94	                lda #<question_do_runtime
.8b46		95 00		sta $00,x	                sta 0,x
.8b48		a9 8b		lda #$8b	                lda #>question_do_runtime
.8b4a		95 01		sta $01,x	                sta 1,x
.8b4c		a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b4e		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.8b51						_compile_do:
.8b51		a0 8b		ldy #$8b	                ldy #>do_runtime
.8b53		a9 63		lda #$63	                lda #<do_runtime
.8b55		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.8b58		ca		dex		                dex
.8b59		ca		dex		                dex
.8b5a		a5 00		lda $00		                lda CP          ; LSB
.8b5c		95 00		sta $00,x	                sta 0,x
.8b5e		a5 01		lda $01		                lda CP+1        ; MSB
.8b60		95 01		sta $01,x	                sta 1,x
.8b62						z_question_do:
.8b62		60		rts		z_do:           rts
.8b63						do_runtime:
.8b63		68		pla		                pla
.8b64		85 22		sta $22		                sta tmp1
.8b66		68		pla		                pla
.8b67		85 23		sta $23		                sta tmp1+1
.8b69		38		sec		                sec
.8b6a		a9 00		lda #$00	                lda #0
.8b6c		f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8b6e		95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8b70		a9 80		lda #$80	                lda #$80
.8b72		f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8b74		95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8b76		48		pha		                pha             ; FUFA replaces limit on R stack
.8b77		b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8b79		48		pha		                pha
.8b7a		18		clc		                clc
.8b7b		b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8b7d		75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8b7f		95 00		sta $00,x	                sta 0,x
.8b81		b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8b83		75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8b85		48		pha		                pha
.8b86		b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8b88		48		pha		                pha
.8b89		e8		inx		                inx
.8b8a		e8		inx		                inx
.8b8b		e8		inx		                inx
.8b8c		e8		inx		                inx
.8b8d		a5 23		lda $23		                lda tmp1+1
.8b8f		48		pha		                pha
.8b90		a5 22		lda $22		                lda tmp1
.8b92		48		pha		                pha
.8b93		60		rts		                rts
.8b94						question_do_runtime:
.8b94		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8b97		20 b3 8e	jsr $8eb3	                jsr xt_equal            ; ( -- n1 n2 f )
.8b9a		b5 00		lda $00,x	                lda 0,x
.8b9c		15 01		ora $01,x	                ora 1,x
.8b9e		f0 06		beq $8ba6	                beq _do_do
.8ba0		8a		txa		                txa
.8ba1		18		clc		                clc
.8ba2		69 06		adc #$06	                adc #6
.8ba4		aa		tax		                tax
.8ba5		60		rts		                rts
.8ba6						_do_do:
.8ba6		e8		inx		                inx             ; clear flag from EQUAL off stack
.8ba7		e8		inx		                inx             ; no RTS because this is copied into code
.8ba8						question_do_runtime_end:
.8ba8						xt_does:
.8ba8		a0 8b		ldy #$8b	                ldy #>does_runtime
.8baa		a9 b7		lda #$b7	                lda #<does_runtime
.8bac		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.8baf		a0 d7		ldy #$d7	                ldy #>dodoes
.8bb1		a9 63		lda #$63	                lda #<dodoes
.8bb3		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.8bb6		60		rts		z_does:         rts
.8bb7						does_runtime:
.8bb7		7a		ply		                ply             ; LSB
.8bb8		68		pla		                pla             ; MSB
.8bb9		c8		iny		                iny
.8bba		d0 01		bne $8bbd	                bne +
.8bbc		1a		inc a		                ina
.8bbd						+
.8bbd		84 22		sty $22		                sty tmp1
.8bbf		85 23		sta $23		                sta tmp1+1
.8bc1		20 bc d7	jsr $d7bc	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8bc4		a5 02		lda $02		                lda dp
.8bc6		18		clc		                clc
.8bc7		69 04		adc #$04	                adc #4
.8bc9		85 24		sta $24		                sta tmp2
.8bcb		a5 03		lda $03		                lda dp+1
.8bcd		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bcf		85 25		sta $25		                sta tmp2+1
.8bd1		b2 24		lda ($24)	                lda (tmp2)
.8bd3		18		clc		                clc
.8bd4		69 01		adc #$01	                adc #1
.8bd6		85 26		sta $26		                sta tmp3
.8bd8		a0 01		ldy #$01	                ldy #1
.8bda		b1 24		lda ($24),y	                lda (tmp2),y
.8bdc		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bde		85 27		sta $27		                sta tmp3+1
.8be0		a5 22		lda $22		                lda tmp1        ; LSB
.8be2		92 26		sta ($26)	                sta (tmp3)
.8be4		a5 23		lda $23		                lda tmp1+1
.8be6		91 26		sta ($26),y	                sta (tmp3),y    ; Y is still 1
.8be8		60		rts		                rts
.8be9						xt_dot:
.8be9		20 75 d8	jsr $d875	                jsr underflow_1
.8bec		20 62 8d	jsr $8d62	                jsr xt_dup                      ; ( n n )
.8bef		20 cd 80	jsr $80cd	                jsr xt_abs                      ; ( n u )
.8bf2		20 56 a7	jsr $a756	                jsr xt_zero                     ; ( n u 0 )
.8bf5		20 3b 93	jsr $933b	                jsr xt_less_number_sign         ; ( n u 0 )
.8bf8		20 c2 97	jsr $97c2	                jsr xt_number_sign_s            ; ( n ud )
.8bfb		20 34 9b	jsr $9b34	                jsr xt_rot                      ; ( ud n )
.8bfe		20 95 9f	jsr $9f95	                jsr xt_sign                     ; ( ud )
.8c01		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater      ; ( addr u )
.8c04		20 a7 a4	jsr $a4a7	                jsr xt_type
.8c07		20 cc a0	jsr $a0cc	                jsr xt_space
.8c0a		60		rts		z_dot:          rts
.8c0b						xt_dot_paren:
.8c0b		ca		dex		                dex
.8c0c		ca		dex		                dex
.8c0d		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c0f		95 00		sta $00,x	                sta 0,x
.8c11		74 01		stz $01,x	                stz 1,x
.8c13		20 1e 99	jsr $991e	                jsr xt_parse
.8c16		20 a7 a4	jsr $a4a7	                jsr xt_type
.8c19		60		rts		z_dot_paren:    rts
.8c1a						xt_dot_quote:
.8c1a		20 2c 9d	jsr $9d2c	                jsr xt_s_quote
.8c1d		a0 a4		ldy #$a4	                ldy #>xt_type
.8c1f		a9 a7		lda #$a7	                lda #<xt_type
.8c21		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.8c24		60		rts		z_dot_quote:    rts
.8c25						xt_dot_r:
.8c25		20 7a d8	jsr $d87a	                jsr underflow_2
.8c28		20 14 a3	jsr $a314	                jsr xt_to_r
.8c2b		20 62 8d	jsr $8d62	                jsr xt_dup
.8c2e		20 cd 80	jsr $80cd	                jsr xt_abs
.8c31		20 56 a7	jsr $a756	                jsr xt_zero
.8c34		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8c37		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.8c3a		20 34 9b	jsr $9b34	                jsr xt_rot
.8c3d		20 95 9f	jsr $9f95	                jsr xt_sign
.8c40		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.8c43		20 76 9a	jsr $9a76	                jsr xt_r_from
.8c46		20 77 98	jsr $9877	                jsr xt_over
.8c49		20 34 95	jsr $9534	                jsr xt_minus
.8c4c		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.8c4f		20 a7 a4	jsr $a4a7	                jsr xt_type
.8c52		60		rts		z_dot_r:        rts
.8c53						xt_dot_s:
.8c53		20 bd 8a	jsr $8abd	                jsr xt_depth    ; ( -- u )
.8c56		a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c58		20 db 8d	jsr $8ddb	                jsr emit_a
.8c5b		b5 00		lda $00,x	                lda 0,x
.8c5d		48		pha		                pha
.8c5e		ca		dex		                dex             ; DUP
.8c5f		ca		dex		                dex
.8c60		95 00		sta $00,x	                sta 0,x
.8c62		74 01		stz $01,x	                stz 1,x
.8c64		20 e2 d8	jsr $d8e2	                jsr print_u
.8c67		a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8c69		20 db 8d	jsr $8ddb	                jsr emit_a
.8c6c		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8c6e		20 db 8d	jsr $8ddb	                jsr emit_a
.8c71		e8		inx		                inx
.8c72		e8		inx		                inx
.8c73		e0 78		cpx #$78	                cpx #dsp0
.8c75		f0 1e		beq $8c95	                beq _done
.8c77						_have_stack:
.8c77		7a		ply		                ply
.8c78		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8c7a		85 26		sta $26		                sta tmp3
.8c7c		64 27		stz $27		                stz tmp3+1      ; must be zero page on the 65c02
.8c7e						_loop:
.8c7e		ca		dex		                dex
.8c7f		ca		dex		                dex
.8c80		b2 26		lda ($26)	                lda (tmp3)
.8c82		95 01		sta $01,x	                sta 1,x
.8c84		c6 26		dec $26		                dec tmp3
.8c86		b2 26		lda ($26)	                lda (tmp3)
.8c88		95 00		sta $00,x	                sta 0,x
.8c8a		c6 26		dec $26		                dec tmp3
.8c8c		5a		phy		                phy
.8c8d		20 e9 8b	jsr $8be9	                jsr xt_dot
.8c90		7a		ply		                ply
.8c91		88		dey		                dey
.8c92		d0 ea		bne $8c7e	                bne _loop
.8c94		48		pha		                pha             ; dummy to balance stack
.8c95						_done:
.8c95		68		pla		                pla
.8c96		60		rts		z_dot_s:        rts
.8c97						xt_d_dot:
.8c97		20 7a d8	jsr $d87a	                jsr underflow_2
.8c9a		20 31 a3	jsr $a331	                jsr xt_tuck
.8c9d		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.8ca0		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8ca3		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.8ca6		20 34 9b	jsr $9b34	                jsr xt_rot
.8ca9		20 95 9f	jsr $9f95	                jsr xt_sign
.8cac		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.8caf		20 a7 a4	jsr $a4a7	                jsr xt_type
.8cb2		20 cc a0	jsr $a0cc	                jsr xt_space
.8cb5		60		rts		z_d_dot:        rts
.8cb6						xt_d_dot_r:
.8cb6		20 7f d8	jsr $d87f	                jsr underflow_3
.8cb9		20 14 a3	jsr $a314	                jsr xt_to_r
.8cbc		20 31 a3	jsr $a331	                jsr xt_tuck
.8cbf		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.8cc2		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8cc5		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.8cc8		20 34 9b	jsr $9b34	                jsr xt_rot
.8ccb		20 95 9f	jsr $9f95	                jsr xt_sign
.8cce		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.8cd1		20 76 9a	jsr $9a76	                jsr xt_r_from
.8cd4		20 77 98	jsr $9877	                jsr xt_over
.8cd7		20 34 95	jsr $9534	                jsr xt_minus
.8cda		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.8cdd		20 a7 a4	jsr $a4a7	                jsr xt_type
.8ce0		60		rts		z_d_dot_r:      rts
.8ce1						xt_drop:
.8ce1		20 75 d8	jsr $d875	                jsr underflow_1
.8ce4		e8		inx		                inx
.8ce5		e8		inx		                inx
.8ce6		60		rts		z_drop:         rts
.8ce7						xt_dump:
.8ce7		20 7a d8	jsr $d87a	                jsr underflow_2
.8cea						_row:
.8cea		a0 10		ldy #$10	                ldy #16
.8cec		64 24		stz $24		                stz tmp2
.8cee		20 2a 89	jsr $892a	                jsr xt_cr
.8cf1		b5 03		lda $03,x	                lda 3,x
.8cf3		20 8a d7	jsr $d78a	                jsr byte_to_ascii
.8cf6		b5 02		lda $02,x	                lda 2,x
.8cf8		20 8a d7	jsr $d78a	                jsr byte_to_ascii
.8cfb		20 cc a0	jsr $a0cc	                jsr xt_space
.8cfe		20 cc a0	jsr $a0cc	                jsr xt_space
.8d01						_loop:
.8d01		b5 00		lda $00,x	                lda 0,x
.8d03		15 01		ora $01,x	                ora 1,x
.8d05		f0 39		beq $8d40	                beq _all_printed
.8d07		a1 02		lda ($02,x)	                lda (2,x)
.8d09		48		pha		                pha                     ; byte_to_ascii destroys A
.8d0a		20 8a d7	jsr $d78a	                jsr byte_to_ascii
.8d0d		20 cc a0	jsr $a0cc	                jsr xt_space
.8d10		68		pla		                pla
.8d11		20 5b d8	jsr $d85b	                jsr is_printable
.8d14		b0 02		bcs $8d18	                bcs _printable
.8d16		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d18						_printable:
.8d18		5a		phy		                phy                     ; save counter
.8d19		a4 24		ldy $24		                ldy tmp2
.8d1b		91 00		sta ($00),y	                sta (cp),y
.8d1d		e6 24		inc $24		                inc tmp2
.8d1f		7a		ply		                ply
.8d20		c0 09		cpy #$09	                cpy #9
.8d22		d0 03		bne $8d27	                bne _next_char
.8d24		20 cc a0	jsr $a0cc	                jsr xt_space
.8d27						_next_char:
.8d27		f6 02		inc $02,x	                inc 2,x
.8d29		d0 02		bne $8d2d	                bne _counter
.8d2b		f6 03		inc $03,x	                inc 3,x
.8d2d						_counter:
.8d2d		b5 00		lda $00,x	                lda 0,x
.8d2f		d0 02		bne $8d33	                bne +
.8d31		d6 01		dec $01,x	                dec 1,x
.8d33						+
.8d33		d6 00		dec $00,x	                dec 0,x
.8d35		88		dey		                dey
.8d36		d0 c9		bne $8d01	                bne _loop               ; next byte
.8d38		20 cc a0	jsr $a0cc	                jsr xt_space
.8d3b		20 4e 8d	jsr $8d4e	                jsr dump_print_ascii
.8d3e		80 aa		bra $8cea	                bra _row                ; new row
.8d40						_all_printed:
.8d40		a5 24		lda $24		                lda tmp2
.8d42		f0 06		beq $8d4a	                beq _done
.8d44		20 cc a0	jsr $a0cc	                jsr xt_space
.8d47		20 4e 8d	jsr $8d4e	                jsr dump_print_ascii
.8d4a						_done:
.8d4a		20 54 a3	jsr $a354	                jsr xt_two_drop         ; one byte less than 4x INX
.8d4d		60		rts		z_dump:         rts
.8d4e						dump_print_ascii:
.8d4e		a0 00		ldy #$00	                ldy #0
.8d50						_ascii_loop:
.8d50		b1 00		lda ($00),y	                lda (cp),y
.8d52		20 db 8d	jsr $8ddb	                jsr emit_a
.8d55		c8		iny		                iny
.8d56		c0 08		cpy #$08	                cpy #8
.8d58		d0 03		bne $8d5d	                bne +
.8d5a		20 cc a0	jsr $a0cc	                jsr xt_space
.8d5d						+
.8d5d		c6 24		dec $24		                dec tmp2
.8d5f		d0 ef		bne $8d50	                bne _ascii_loop
.8d61		60		rts		                rts
.8d62						xt_dup:
.8d62		20 75 d8	jsr $d875	                jsr underflow_1
.8d65		ca		dex		                dex
.8d66		ca		dex		                dex
.8d67		b5 02		lda $02,x	                lda 2,x         ; LSB
.8d69		95 00		sta $00,x	                sta 0,x
.8d6b		b5 03		lda $03,x	                lda 3,x         ; MSB
.8d6d		95 01		sta $01,x	                sta 1,x
.8d6f		60		rts		z_dup:          rts
.8d70						xt_ed:
.8d70		20 c4 b5	jsr $b5c4	                jsr ed6502      ; kept in separate file
.8d73		60		rts		z_ed:           rts
.8d74						xt_else:
.8d74						xt_endof:
.8d74		a9 4c		lda #$4c	                lda #$4c        ; jmp opcode
.8d76		20 2d d7	jsr $d72d	                jsr cmpl_a
.8d79		20 57 91	jsr $9157	                jsr xt_here
.8d7c		20 56 a7	jsr $a756	                jsr xt_zero
.8d7f		20 24 87	jsr $8724	                jsr xt_comma
.8d82		20 5c a1	jsr $a15c	                jsr xt_swap         ; ( target orig )
.8d85						xt_then:
.8d85		20 57 91	jsr $9157	                jsr xt_here
.8d88		a1 02		lda ($02,x)	                lda (2,x)           ; get LSB at orig
.8d8a		1a		inc a		                ina                 ; was LSB $ff?  (only check for $xxff)
.8d8b		d0 3b		bne $8dc8	                bne _no_opt
.8d8d		20 5c a3	jsr $a35c	                jsr xt_two_dup
.8d90		20 5c a1	jsr $a15c	                jsr xt_swap
.8d93		20 34 95	jsr $9534	                jsr xt_minus        ; ( C: orig here offset )
.8d96		b5 01		lda $01,x	                lda 1,x
.8d98		d0 2c		bne $8dc6	                bne _too_far        ; MSB must be zero
.8d9a		b5 00		lda $00,x	                lda 0,x
.8d9c		3a		dec a		                dea                 ; we want here - orig - 2
.8d9d		3a		dec a		                dea                 ; don't care about carry
.8d9e		30 26		bmi $8dc6	                bmi _too_far        ; up to 127 is ok
.8da0		95 00		sta $00,x	                sta 0,x             ; stash offset - 2
.8da2		38		sec		                sec                 ; put orig - 2 in tmp1
.8da3		b5 04		lda $04,x	                lda 4,x
.8da5		e9 02		sbc #$02	                sbc #2
.8da7		85 22		sta $22		                sta tmp1
.8da9		b5 05		lda $05,x	                lda 5,x
.8dab		e9 00		sbc #$00	                sbc #0
.8dad		85 23		sta $23		                sta tmp1+1
.8daf		a0 00		ldy #$00	                ldy #0
.8db1						-
.8db1		b9 d0 8d	lda $8dd0,y	                lda beq_opt+1,y               ; skip the jsr
.8db4		91 22		sta ($22),y	                sta (tmp1),y
.8db6		c8		iny		                iny
.8db7		c0 03		cpy #$03	                cpy #(beq_opt_end-beq_opt-2)  ; three bytes, skip jsr and offset
.8db9		d0 f6		bne $8db1	                bne -
.8dbb		b5 00		lda $00,x	                lda 0,x             ; write the offset
.8dbd		91 22		sta ($22),y	                sta (tmp1),y
.8dbf		e8		inx		                inx                 ; clear the stack
.8dc0		e8		inx		                inx
.8dc1		e8		inx		                inx
.8dc2		e8		inx		                inx
.8dc3		e8		inx		                inx
.8dc4		e8		inx		                inx
.8dc5		60		rts		                rts                 ; all done
.8dc6						_too_far:
.8dc6		e8		inx		                inx                 ; discard the offset we calculated
.8dc7		e8		inx		                inx
.8dc8						_no_opt:
.8dc8		20 5c a1	jsr $a15c	                jsr xt_swap
.8dcb		20 3b a1	jsr $a13b	                jsr xt_store
.8dce						z_else:
.8dce						z_endof:
.8dce		60		rts		z_then:         rts
.8dcf						beq_opt:
.8dcf		20 f7 91	jsr $91f7	                jsr zero_test_runtime       ; replaces jsr zero_branch_runtime
.8dd2		f0 00		beq $8dd4	                beq beq_opt_end             ; the beq overwrites the placeholder
.8dd4						beq_opt_end:
.8dd4						xt_emit:
.8dd4		20 75 d8	jsr $d875	                jsr underflow_1
.8dd7		b5 00		lda $00,x	                lda 0,x
.8dd9		e8		inx		                inx
.8dda		e8		inx		                inx
.8ddb						emit_a:
.8ddb		6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8dde						z_emit:
.8dde						xt_empty_buffers:
.8dde		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8de0		a9 00		lda #$00	                lda #0
.8de2		91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8de4						z_empty_buffers:
.8de4		60		rts		                rts
.8de5						xt_endcase:
.8de5		a0 8c		ldy #$8c	                ldy #>xt_drop
.8de7		a9 e1		lda #$e1	                lda #<xt_drop
.8de9		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.8dec						_endcase_loop:
.8dec		b5 00		lda $00,x	                lda 0,x
.8dee		15 01		ora $01,x	                ora 1,x
.8df0		f0 05		beq $8df7	                beq _done
.8df2		20 85 8d	jsr $8d85	                jsr xt_then
.8df5		80 f5		bra $8dec	                bra _endcase_loop
.8df7						_done:
.8df7		e8		inx		                inx
.8df8		e8		inx		                inx
.8df9		60		rts		z_endcase:      rts
.8dfa						xt_environment_q:
.8dfa		20 75 d8	jsr $d875	                jsr underflow_1
.8dfd		a0 00		ldy #$00	                ldy #00                 ; counter for table
.8dff		5a		phy		                phy
.8e00						_table_loop:
.8e00		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e03		ca		dex		                dex
.8e04		ca		dex		                dex                     ; ( addr u addr u ? )
.8e05		b9 77 8e	lda $8e77,y	                lda env_table_single,y
.8e08		95 00		sta $00,x	                sta 0,x
.8e0a		c8		iny		                iny
.8e0b		b9 77 8e	lda $8e77,y	                lda env_table_single,y
.8e0e		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e10		c8		iny		                iny
.8e11		15 00		ora $00,x	                ora 0,x
.8e13		f0 4d		beq $8e62	                beq _table_done
.8e15		5a		phy		                phy                     ; save Y, which is used by COUNT
.8e16		20 16 89	jsr $8916	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e19		20 3e 87	jsr $873e	                jsr xt_compare          ; ( addr u f )
.8e1c		7a		ply		                ply
.8e1d		b5 00		lda $00,x	                lda 0,x
.8e1f		15 01		ora $01,x	                ora 1,x
.8e21		f0 04		beq $8e27	                beq _got_result
.8e23		e8		inx		                inx                     ; DROP, now ( addr u )
.8e24		e8		inx		                inx
.8e25		80 d9		bra $8e00	                bra _table_loop
.8e27						_got_result:
.8e27		e8		inx		                inx                     ; drop flag, now ( addr u )
.8e28		e8		inx		                inx
.8e29		88		dey		                dey                     ; go back to index we had
.8e2a		88		dey		                dey
.8e2b		68		pla		                pla
.8e2c		d0 0d		bne $8e3b	                bne _double_result
.8e2e		b9 95 8e	lda $8e95,y	                lda env_results_single,y
.8e31		95 02		sta $02,x	                sta 2,x
.8e33		c8		iny		                iny
.8e34		b9 95 8e	lda $8e95,y	                lda env_results_single,y
.8e37		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e39		80 1f		bra $8e5a	                bra _set_flag
.8e3b						_double_result:
.8e3b		ca		dex		                dex                     ; ( addr u ? )
.8e3c		ca		dex		                dex
.8e3d		98		tya		                tya
.8e3e		38		sec		                sec
.8e3f		e9 18		sbc #$18	                sbc #24
.8e41		0a		asl a		                asl
.8e42		a8		tay		                tay
.8e43		b9 ab 8e	lda $8eab,y	                lda env_results_double,y
.8e46		95 02		sta $02,x	                sta 2,x
.8e48		c8		iny		                iny
.8e49		b9 ab 8e	lda $8eab,y	                lda env_results_double,y
.8e4c		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e4e		c8		iny		                iny
.8e4f		b9 ab 8e	lda $8eab,y	                lda env_results_double,y
.8e52		95 04		sta $04,x	                sta 4,x
.8e54		c8		iny		                iny
.8e55		b9 ab 8e	lda $8eab,y	                lda env_results_double,y
.8e58		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e5a						_set_flag:
.8e5a		a9 ff		lda #$ff	                lda #$ff
.8e5c		95 00		sta $00,x	                sta 0,x
.8e5e		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e60		80 14		bra $8e76	                bra _done
.8e62						_table_done:
.8e62		68		pla		                pla
.8e63		d0 09		bne $8e6e	                bne _no_match
.8e65		1a		inc a		                ina
.8e66		48		pha		                pha
.8e67		8a		txa		                txa
.8e68		18		clc		                clc
.8e69		69 06		adc #$06	                adc #6                  ; skip six bytes
.8e6b		aa		tax		                tax                     ; ( addr u )
.8e6c		80 92		bra $8e00	                bra _table_loop
.8e6e						_no_match:
.8e6e		8a		txa		                txa
.8e6f		18		clc		                clc
.8e70		69 0a		adc #$0a	                adc #10
.8e72		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e73		20 5e 8f	jsr $8f5e	                jsr xt_false
.8e76						_done:
.8e76						z_environment_q:
.8e76		60		rts		                rts
.8e77						env_table_single:
>8e77		9d d6 ad d6 b3 d6 b8 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e7f		ca d6
>8e81		d2 d6 db d6 e1 d6 e7 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e89		fa d6 06 d7 00 00		        .word envs_sc, envs_wl, 0000
.8e8f						env_table_double:
>8e8f		10 d7 16 d7 00 00		        .word envs_max_d, envs_max_ud, 0000
.8e95						env_results_single:
>8e95		ff 00				        .word $00FF     ; /COUNTED-STRING
>8e97		ff 00				        .word $00FF     ; /HOLD
>8e99		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8e9b		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8e9d		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8e9f		ff 00				        .word $00FF     ; MAX-CHAR
>8ea1		ff 7f				        .word $7FFF     ; MAX-N
>8ea3		ff ff				        .word $FFFF     ; MAX-U
>8ea5		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8ea7		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8ea9		09 00				        .word $0009     ; WORDLISTS
.8eab						env_results_double:
>8eab		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8eaf		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8eb3						xt_equal:
.8eb3		20 7a d8	jsr $d87a	                jsr underflow_2
.8eb6		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8eb8		d5 02		cmp $02,x	                cmp 2,x
.8eba		d0 0a		bne $8ec6	                bne _false
.8ebc		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8ebe		d5 03		cmp $03,x	                cmp 3,x
.8ec0		d0 04		bne $8ec6	                bne _false
.8ec2		a9 ff		lda #$ff	                lda #$ff
.8ec4		80 02		bra $8ec8	                bra _done
.8ec6		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8ec8		95 02		sta $02,x	_done:          sta 2,x
.8eca		95 03		sta $03,x	                sta 3,x
.8ecc		e8		inx		                inx
.8ecd		e8		inx		                inx
.8ece		60		rts		z_equal:        rts
.8ecf						xt_blank:
.8ecf		ca		dex		                dex
.8ed0		ca		dex		                dex
.8ed1		a9 20		lda #$20	                lda #AscSP
.8ed3		95 00		sta $00,x	                sta 0,x
.8ed5		74 01		stz $01,x	                stz 1,x
.8ed7		80 06		bra $8edf	                bra xt_fill     ; skip over code for ERASE
.8ed9						xt_erase:
.8ed9		ca		dex		                dex
.8eda		ca		dex		                dex
.8edb		74 00		stz $00,x	                stz 0,x
.8edd		74 01		stz $01,x	                stz 1,x
.8edf						xt_fill:
.8edf		20 7f d8	jsr $d87f	                jsr underflow_3
.8ee2		b5 04		lda $04,x	                lda 4,x         ; LSB
.8ee4		85 22		sta $22		                sta tmp1
.8ee6		b5 05		lda $05,x	                lda 5,x
.8ee8		85 23		sta $23		                sta tmp1+1
.8eea		b5 02		lda $02,x	                lda 2,x
.8eec		85 24		sta $24		                sta tmp2
.8eee		b5 03		lda $03,x	                lda 3,x
.8ef0		85 25		sta $25		                sta tmp2+1
.8ef2		b5 00		lda $00,x	                lda 0,x
.8ef4		a8		tay		                tay
.8ef5						_loop:
.8ef5		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8ef7		c5 23		cmp $23		                cmp tmp1+1
.8ef9		90 21		bcc $8f1c	                bcc _done               ; RAM_END < TMP1, so leave
.8efb		d0 06		bne $8f03	                bne _check_counter      ; RAM_END is not smaller and not equal
.8efd		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8eff		c5 22		cmp $22		                cmp tmp1
.8f01		90 19		bcc $8f1c	                bcc _done               ; RAM_END < TMP1, so leave
.8f03						_check_counter:
.8f03		a5 24		lda $24		                lda tmp2
.8f05		05 25		ora $25		                ora tmp2+1
.8f07		f0 13		beq $8f1c	                beq _done
.8f09		98		tya		                tya
.8f0a		92 22		sta ($22)	                sta (tmp1)
.8f0c		a5 24		lda $24		                lda tmp2
.8f0e		d0 02		bne $8f12	                bne +
.8f10		c6 25		dec $25		                dec tmp2+1
.8f12		c6 24		dec $24		+               dec tmp2
.8f14		e6 22		inc $22		                inc tmp1
.8f16		d0 dd		bne $8ef5	                bne _loop
.8f18		e6 23		inc $23		                inc tmp1+1
.8f1a		80 d9		bra $8ef5	                bra _loop
.8f1c						_done:
.8f1c		8a		txa		                txa
.8f1d		18		clc		                clc
.8f1e		69 06		adc #$06	                adc #6
.8f20		aa		tax		                tax
.8f21						z_blank:
.8f21						z_erase:
.8f21		60		rts		z_fill:         rts
.8f22						xt_execute:
.8f22		20 75 d8	jsr $d875	                jsr underflow_1
.8f25		20 29 8f	jsr $8f29	                jsr doexecute   ; do not combine to JMP (native coding)
.8f28		60		rts		z_execute:      rts
.8f29						doexecute:
.8f29		b5 00		lda $00,x	                lda 0,x
.8f2b		85 0e		sta $0e		                sta ip
.8f2d		b5 01		lda $01,x	                lda 1,x
.8f2f		85 0f		sta $0f		                sta ip+1
.8f31		e8		inx		                inx
.8f32		e8		inx		                inx
.8f33		6c 0e 00	jmp ($000e)	                jmp (ip)
.8f36						xt_execute_parsing:
.8f36		20 7f d8	jsr $d87f	                jsr underflow_3
.8f39		20 43 92	jsr $9243	                jsr xt_input_to_r       ; save normal input for later
.8f3c		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f3f		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f41		85 0a		sta $0a		                sta ciblen
.8f43		b5 01		lda $01,x	                lda 1,x
.8f45		85 0b		sta $0b		                sta ciblen+1
.8f47		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f49		85 08		sta $08		                sta cib
.8f4b		b5 03		lda $03,x	                lda 3,x
.8f4d		85 09		sta $09		                sta cib+1
.8f4f		64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f51		64 0d		stz $0d		                stz toin+1
.8f53		20 54 a3	jsr $a354	                jsr xt_two_drop         ; 2DROP ( xt )
.8f56		20 22 8f	jsr $8f22	                jsr xt_execute
.8f59		20 87 9a	jsr $9a87	                jsr xt_r_to_input
.8f5c						z_execute_parsing:
.8f5c		60		rts		                rts
.8f5d						xt_exit:
.8f5d		60		rts		                rts             ; keep before z_exit
.8f5e						z_exit:
.8f5e						xt_false:
.8f5e		ca		dex		                dex
.8f5f		ca		dex		                dex
.8f60		74 00		stz $00,x	                stz 0,x
.8f62		74 01		stz $01,x	                stz 1,x
.8f64		60		rts		z_false:        rts
.8f65						xt_fetch:
.8f65		20 75 d8	jsr $d875	                jsr underflow_1
.8f68		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f6a		a8		tay		                tay
.8f6b		f6 00		inc $00,x	                inc 0,x
.8f6d		d0 02		bne $8f71	                bne +
.8f6f		f6 01		inc $01,x	                inc 1,x
.8f71						+
.8f71		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f73		95 01		sta $01,x	                sta 1,x
.8f75		94 00		sty $00,x	                sty 0,x
.8f77		60		rts		z_fetch:        rts
.8f78						xt_find:
.8f78		20 75 d8	jsr $d875	                jsr underflow_1
.8f7b		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f7d		48		pha		                pha
.8f7e		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f80		48		pha		                pha
.8f81		20 16 89	jsr $8916	                jsr xt_count            ; ( caddr -- addr u )
.8f84		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f87		b5 00		lda $00,x	                lda 0,x
.8f89		15 01		ora $01,x	                ora 1,x
.8f8b		d0 0b		bne $8f98	                bne _found_word
.8f8d		20 5e 8f	jsr $8f5e	                jsr xt_false            ; ( 0 0 )
.8f90		68		pla		                pla                     ; LSB of address
.8f91		95 02		sta $02,x	                sta 2,x
.8f93		68		pla		                pla
.8f94		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8f96		80 27		bra $8fbf	                bra _done               ; ( addr 0 )
.8f98						_found_word:
.8f98		68		pla		                pla
.8f99		68		pla		                pla
.8f9a		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.8f9d		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt xt )
.8fa0		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( xt nt )
.8fa3		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fa5		f6 00		inc $00,x	                inc 0,x
.8fa7		d0 02		bne $8fab	                bne +
.8fa9		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fab						+
.8fab		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fad		29 04		and #$04	                and #IM
.8faf		d0 08		bne $8fb9	                bne _immediate          ; bit set, we're immediate
.8fb1		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fb3		95 00		sta $00,x	                sta 0,x
.8fb5		95 01		sta $01,x	                sta 1,x
.8fb7		80 06		bra $8fbf	                bra _done
.8fb9						_immediate:
.8fb9		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fbb		95 00		sta $00,x	                sta 0,x
.8fbd		74 01		stz $01,x	                stz 1,x
.8fbf						_done:
.8fbf		60		rts		z_find:         rts
.8fc0						xt_find_name:
.8fc0		20 7a d8	jsr $d87a	                jsr underflow_2
.8fc3		b5 00		lda $00,x	                lda 0,x
.8fc5		15 01		ora $01,x	                ora 1,x
.8fc7		d0 03		bne $8fcc	                bne _nonempty
.8fc9		4c 65 90	jmp $9065	                jmp _fail_done
.8fcc						_nonempty:
.8fcc		64 26		stz $26		                stz tmp3                ; Start at the beginning
.8fce						_wordlist_loop:
.8fce		a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8fd0		a5 26		lda $26		                lda tmp3
.8fd2		d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fd4		d0 03		bne $8fd9	                bne _have_string
.8fd6		4c 65 90	jmp $9065	                jmp _fail_done
.8fd9						_have_string:
.8fd9		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fda		69 1f		adc #$1f	                adc #search_order_offset
.8fdc		a8		tay		                tay
.8fdd		b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8fdf		0a		asl a		                asl                     ; Turn offset into cells offset.
.8fe0		18		clc		                clc
.8fe1		69 06		adc #$06	                adc #wordlists_offset
.8fe3		a8		tay		                tay
.8fe4		b1 1e		lda ($1e),y	                lda (up),y
.8fe6		85 22		sta $22		                sta tmp1
.8fe8		c8		iny		                iny
.8fe9		b1 1e		lda ($1e),y	                lda (up),y
.8feb		85 23		sta $23		                sta tmp1+1
.8fed		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.8fef		85 24		sta $24		                sta tmp2
.8ff1		b5 03		lda $03,x	                lda 3,x
.8ff3		85 25		sta $25		                sta tmp2+1
.8ff5						_loop:
.8ff5		b2 22		lda ($22)	                lda (tmp1)
.8ff7		d5 00		cmp $00,x	                cmp 0,x
.8ff9		d0 54		bne $904f	                bne _next_entry
.8ffb						_compare_string:
.8ffb		b2 24		lda ($24)	                lda (tmp2)      ; first character of mystery string
.8ffd		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.8fff		b0 07		bcs $9008	                bcs _compare_first
.9001		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9003		90 03		bcc $9008	                bcc _compare_first
.9005		18		clc		                clc
.9006		69 20		adc #$20	                adc #$20
.9008						_compare_first:
.9008		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.900a		d1 22		cmp ($22),y	                cmp (tmp1),y    ; first character of current word
.900c		d0 41		bne $904f	                bne _next_entry
.900e		b5 00		lda $00,x	                lda 0,x
.9010		3a		dec a		                dea
.9011		f0 2c		beq $903f	                beq _success
.9013		a5 22		lda $22		                lda tmp1
.9015		48		pha		                pha             ; Preserve tmp1 on the return stack.
.9016		18		clc		                clc
.9017		69 08		adc #$08	                adc #8
.9019		85 22		sta $22		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.901b		a5 23		lda $23		                lda tmp1+1
.901d		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.901e		69 00		adc #$00	                adc #0          ; we only need the carry
.9020		85 23		sta $23		                sta tmp1+1
.9022		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9024		88		dey		                dey
.9025						_string_loop:
.9025		b1 24		lda ($24),y	                lda (tmp2),y    ; last char of mystery string
.9027		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9029		b0 07		bcs $9032	                bcs _check_char
.902b		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.902d		90 03		bcc $9032	                bcc _check_char
.902f		18		clc		                clc
.9030		69 20		adc #$20	                adc #$20
.9032						_check_char:
.9032		d1 22		cmp ($22),y	                cmp (tmp1),y    ; last char of word we're testing against
.9034		d0 13		bne $9049	                bne _next_entry_tmp1
.9036		88		dey		                dey
.9037		d0 ec		bne $9025	                bne _string_loop
.9039						_success_tmp1:
.9039		68		pla		                pla             ; Restore tmp1 from the return stack.
.903a		85 23		sta $23		                sta tmp1+1
.903c		68		pla		                pla
.903d		85 22		sta $22		                sta tmp1
.903f						_success:
.903f		a5 22		lda $22		                lda tmp1
.9041		95 02		sta $02,x	                sta 2,x
.9043		a5 23		lda $23		                lda tmp1+1
.9045		95 03		sta $03,x	                sta 3,x
.9047		80 20		bra $9069	                bra _done
.9049						_next_entry_tmp1:
.9049		68		pla		                pla             ; Restore tmp1 from the return stack.
.904a		85 23		sta $23		                sta tmp1+1
.904c		68		pla		                pla
.904d		85 22		sta $22		                sta tmp1
.904f						_next_entry:
.904f		a0 02		ldy #$02	                ldy #2
.9051		b1 22		lda ($22),y	                lda (tmp1),y
.9053		48		pha		                pha
.9054		c8		iny		                iny
.9055		b1 22		lda ($22),y	                lda (tmp1),y
.9057		85 23		sta $23		                sta tmp1+1
.9059		68		pla		                pla
.905a		85 22		sta $22		                sta tmp1
.905c		05 23		ora $23		                ora tmp1+1
.905e		d0 95		bne $8ff5	                bne _loop
.9060		e6 26		inc $26		                inc tmp3
.9062		4c ce 8f	jmp $8fce	                jmp _wordlist_loop
.9065						_fail_done:
.9065		74 02		stz $02,x	                stz 2,x         ; failure flag
.9067		74 03		stz $03,x	                stz 3,x
.9069						_done:
.9069		e8		inx		                inx
.906a		e8		inx		                inx
.906b		60		rts		z_find_name:    rts
.906c						xt_flush:
.906c		20 6c 9e	jsr $9e6c	                jsr xt_save_buffers
.906f		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9071		a9 00		lda #$00	                lda #0
.9073		91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9075						z_flush:
.9075		60		rts		                rts
.9076						xt_fm_slash_mod:
.9076		20 7f d8	jsr $d87f	                jsr underflow_3
.9079		64 24		stz $24		                stz tmp2        ; default: n is positive
.907b		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.907d		10 0e		bpl $908d	                bpl _check_d
.907f		e6 24		inc $24		                inc tmp2        ; set flag to negative for n1
.9081		20 07 96	jsr $9607	                jsr xt_negate   ; NEGATE
.9084		20 14 a3	jsr $a314	                jsr xt_to_r     ; >R
.9087		20 08 8b	jsr $8b08	                jsr xt_dnegate  ; DNEGATE
.908a		20 76 9a	jsr $9a76	                jsr xt_r_from   ; R>
.908d						_check_d:
.908d		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.908f		10 0d		bpl $909e	                bpl _multiply
.9091		18		clc		                clc
.9092		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.9094		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.9096		95 02		sta $02,x	                sta 2,x
.9098		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.909a		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.909c		95 03		sta $03,x	                sta 3,x
.909e						_multiply:
.909e		20 5e a5	jsr $a55e	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90a1		a5 24		lda $24		                lda tmp2
.90a3		f0 07		beq $90ac	                beq _done
.90a5		e8		inx		                inx             ; pretend that we SWAP
.90a6		e8		inx		                inx
.90a7		20 07 96	jsr $9607	                jsr xt_negate
.90aa		ca		dex		                dex
.90ab		ca		dex		                dex
.90ac						_done:
.90ac		60		rts		z_fm_slash_mod: rts
.90ad						xt_forth:
.90ad		a0 1f		ldy #$1f	                ldy #search_order_offset
.90af		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90b1		91 1e		sta ($1e),y	                sta (up),y
.90b3						z_forth:
.90b3		60		rts		                rts
.90b4						load_evaluate:
.90b4		a9 ff		lda #$ff	                lda #$FF
.90b6		85 22		sta $22		                sta tmp1
.90b8		80 11		bra $90cb	                bra load_evaluate_start
.90ba						xt_evaluate:
.90ba		20 7a d8	jsr $d87a	                jsr underflow_2
.90bd		64 22		stz $22		                stz tmp1
.90bf		b5 00		lda $00,x	                lda 0,x
.90c1		15 01		ora $01,x	                ora 1,x
.90c3		d0 06		bne $90cb	                bne evaluate_got_work
.90c5		e8		inx		                inx
.90c6		e8		inx		                inx
.90c7		e8		inx		                inx
.90c8		e8		inx		                inx
.90c9		80 42		bra $910d	                bra evaluate_done
.90cb						load_evaluate_start:
.90cb						evaluate_got_work:
.90cb		a0 01		ldy #$01	                ldy #blk_offset+1
.90cd		b1 1e		lda ($1e),y	                lda (up),y
.90cf		48		pha		                pha
.90d0		88		dey		                dey
.90d1		b1 1e		lda ($1e),y	                lda (up),y
.90d3		48		pha		                pha
.90d4		a5 22		lda $22		                lda tmp1
.90d6		d0 05		bne $90dd	                bne _nozero
.90d8		91 1e		sta ($1e),y	                sta (up),y
.90da		c8		iny		                iny
.90db		91 1e		sta ($1e),y	                sta (up),y
.90dd						_nozero:
.90dd		20 43 92	jsr $9243	                jsr xt_input_to_r
.90e0		a9 ff		lda #$ff	                lda #$ff
.90e2		85 06		sta $06		                sta insrc
.90e4		85 07		sta $07		                sta insrc+1
.90e6		64 0c		stz $0c		                stz toin
.90e8		64 0d		stz $0d		                stz toin+1
.90ea		b5 00		lda $00,x	                lda 0,x
.90ec		85 0a		sta $0a		                sta ciblen
.90ee		b5 01		lda $01,x	                lda 1,x
.90f0		85 0b		sta $0b		                sta ciblen+1
.90f2		b5 02		lda $02,x	                lda 2,x
.90f4		85 08		sta $08		                sta cib
.90f6		b5 03		lda $03,x	                lda 3,x
.90f8		85 09		sta $09		                sta cib+1
.90fa		e8		inx		                inx             ; A clean stack is a clean mind
.90fb		e8		inx		                inx
.90fc		e8		inx		                inx
.90fd		e8		inx		                inx
.90fe		20 e2 d7	jsr $d7e2	                jsr interpret   ; ( -- )
.9101		20 87 9a	jsr $9a87	                jsr xt_r_to_input
.9104		a0 00		ldy #$00	                ldy #blk_offset
.9106		68		pla		                pla
.9107		91 1e		sta ($1e),y	                sta (up),y
.9109		c8		iny		                iny
.910a		68		pla		                pla
.910b		91 1e		sta ($1e),y	                sta (up),y
.910d						evaluate_done:
.910d		60		rts		z_evaluate:     rts
.910e						xt_get_current:
.910e		ca		dex		                dex
.910f		ca		dex		                dex
.9110		a0 04		ldy #$04	                ldy #current_offset
.9112		b1 1e		lda ($1e),y	                lda (up),y
.9114		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.9116		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.9118		60		rts		z_get_current:  rts
.9119						xt_get_order:
.9119		a0 1e		ldy #$1e	                ldy #num_order_offset
.911b		b1 1e		lda ($1e),y	                lda (up),y
.911d		85 22		sta $22		                sta tmp1
.911f		f0 16		beq $9137	                beq _done       ; If zero, there are no wordlists.
.9121						_loop:
.9121		c6 22		dec $22		                dec tmp1        ; Count down by bytes.
.9123		a9 1f		lda #$1f	                lda #search_order_offset
.9125		18		clc		                clc
.9126		65 22		adc $22		                adc tmp1
.9128		a8		tay		                tay
.9129		ca		dex		                dex
.912a		ca		dex		                dex
.912b		b1 1e		lda ($1e),y	                lda (up),y
.912d		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.912f		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.9131		a9 00		lda #$00	                lda #0
.9133		c5 22		cmp $22		                cmp tmp1
.9135		d0 ea		bne $9121	                bne _loop
.9137						_done:
.9137		ca		dex		                dex
.9138		ca		dex		                dex
.9139		a0 1e		ldy #$1e	                ldy #num_order_offset
.913b		b1 1e		lda ($1e),y	                lda (up),y
.913d		95 00		sta $00,x	                sta 0,x
.913f		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.9141		60		rts		z_get_order:    rts
.9142						xt_greater_than:
.9142		20 7a d8	jsr $d87a	                jsr underflow_2
.9145		a0 00		ldy #$00	                ldy #0          ; default false
.9147		20 a1 d7	jsr $d7a1	                jsr compare_16bit
.914a		f0 03		beq $914f	                beq _false
.914c		10 01		bpl $914f	                bpl _false
.914e		88		dey		                dey
.914f						_false:
.914f		98		tya		                tya
.9150		e8		inx		                inx
.9151		e8		inx		                inx
.9152		95 00		sta $00,x	                sta 0,x
.9154		95 01		sta $01,x	                sta 1,x
.9156		60		rts		z_greater_than: rts
.9157						xt_here:
.9157						xt_asm_arrow:
.9157		ca		dex		                dex
.9158		ca		dex		                dex
.9159		a5 00		lda $00		                lda cp
.915b		95 00		sta $00,x	                sta 0,x
.915d		a5 01		lda $01		                lda cp+1
.915f		95 01		sta $01,x	                sta 1,x
.9161						z_asm_arrow:
.9161		60		rts		z_here:         rts
.9162						xt_hex:
.9162		a9 10		lda #$10	                lda #16
.9164		85 18		sta $18		                sta base
.9166		64 19		stz $19		                stz base+1              ; paranoid
.9168		60		rts		z_hex:          rts
.9169						xt_hexstore:
.9169		20 7f d8	jsr $d87f	                jsr underflow_3
.916c		20 62 8d	jsr $8d62	                jsr xt_dup              ; Save copy of original address
.916f		20 46 a4	jsr $a446	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9172						_loop:
.9172		b5 00		lda $00,x	                lda 0,x
.9174		15 01		ora $01,x	                ora 1,x
.9176		f0 36		beq $91ae	                beq _done
.9178		20 02 86	jsr $8602	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.917b		20 46 a4	jsr $a446	                jsr xt_two_to_r
.917e		20 56 a7	jsr $a756	                jsr xt_zero
.9181		20 56 a7	jsr $a756	                jsr xt_zero
.9184		20 cc a3	jsr $a3cc	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9187		20 61 a2	jsr $a261	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.918a		b5 00		lda $00,x	                lda 0,x
.918c		15 01		ora $01,x	                ora 1,x
.918e		d0 17		bne $91a7	                bne _have_chars_left
.9190		20 54 a3	jsr $a354	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9193		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9196		20 61 9a	jsr $9a61	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9199		20 cb 85	jsr $85cb	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.919c		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R>
.919f		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+
.91a2		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91a5		80 cb		bra $9172	                bra _loop
.91a7						_have_chars_left:
.91a7		8a		txa		                txa
.91a8		18		clc		                clc
.91a9		69 08		adc #$08	                adc #8
.91ab		aa		tax		                tax
.91ac		80 c4		bra $9172	                bra _loop
.91ae						_done:
.91ae		e8		inx		                inx
.91af		e8		inx		                inx
.91b0		e8		inx		                inx
.91b1		e8		inx		                inx                     ; 2DROP
.91b2		20 cc a3	jsr $a3cc	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91b5		20 5c a1	jsr $a15c	                jsr xt_swap
.91b8		20 34 95	jsr $9534	                jsr xt_minus            ; ( n )
.91bb		60		rts		z_hexstore:     rts
.91bc						xt_hold:
.91bc		20 75 d8	jsr $d875	                jsr underflow_1
.91bf		a5 32		lda $32		                lda tohold
.91c1		d0 02		bne $91c5	                bne +
.91c3		c6 33		dec $33		                dec tohold+1
.91c5						+
.91c5		c6 32		dec $32		                dec tohold
.91c7		b5 00		lda $00,x	                lda 0,x
.91c9		92 32		sta ($32)	                sta (tohold)
.91cb		e8		inx		                inx
.91cc		e8		inx		                inx
.91cd		60		rts		z_hold:         rts
.91ce						xt_i:
.91ce		ca		dex		                dex
.91cf		ca		dex		                dex
.91d0		da		phx		                phx
.91d1		ba		tsx		                tsx
.91d2		38		sec		                sec
.91d3		bd 02 01	lda $0102,x	                lda $0102,x     ; LSB
.91d6		fd 04 01	sbc $0104,x	                sbc $0104,x
.91d9		a8		tay		                tay
.91da		bd 03 01	lda $0103,x	                lda $0103,x     ; MSB
.91dd		fd 05 01	sbc $0105,x	                sbc $0105,x
.91e0		fa		plx		                plx
.91e1		95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.91e3		94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.91e5		60		rts		z_i:            rts
.91e6						xt_if:
.91e6		a0 92		ldy #$92	                ldy #>zero_branch_runtime
.91e8		a9 01		lda #$01	                lda #<zero_branch_runtime
.91ea		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.91ed		20 57 91	jsr $9157	                jsr xt_here
.91f0		20 28 a3	jsr $a328	                jsr xt_true
.91f3		20 24 87	jsr $8724	                jsr xt_comma
.91f6		60		rts		z_if:           rts
.91f7						zero_test_runtime:
.91f7		e8		inx		                inx
.91f8		e8		inx		                inx
.91f9		b5 fe		lda $fe,x	                lda $fe,x           ; wraparound so inx doesn't wreck Z status
.91fb		15 ff		ora $ff,x	                ora $ff,x
.91fd		60		rts		                rts
.91fe		d0 03		bne $9203	                bne zero_test_footer_end+2  ; branch fwd if non-zero
>9200		4c				                .byte $4c                   ; else JMP back
.9201						zero_test_footer_end:
.9201						zero_branch_runtime:
.9201		68		pla		                pla
.9202		85 22		sta $22		                sta tmp1
.9204		68		pla		                pla
.9205		85 23		sta $23		                sta tmp1+1
.9207		b5 00		lda $00,x	                lda 0,x
.9209		15 01		ora $01,x	                ora 1,x
.920b		f0 0d		beq $921a	                beq _zero
.920d		a5 22		lda $22		                lda tmp1        ; LSB
.920f		18		clc		                clc
.9210		69 03		adc #$03	                adc #3          ; add one to RTS address plus two address bytes
.9212		85 22		sta $22		                sta tmp1
.9214		90 11		bcc $9227	                bcc _jump
.9216		e6 23		inc $23		                inc tmp1+1      ; MSB
.9218		80 0d		bra $9227	                bra _jump
.921a						_zero:
.921a		a0 01		ldy #$01	                ldy #1
.921c		b1 22		lda ($22),y	                lda (tmp1),y
.921e		48		pha		                pha
.921f		c8		iny		                iny
.9220		b1 22		lda ($22),y	                lda (tmp1),y
.9222		85 23		sta $23		                sta tmp1+1
.9224		68		pla		                pla
.9225		85 22		sta $22		                sta tmp1
.9227						_jump:
.9227		e8		inx		                inx
.9228		e8		inx		                inx
.9229		6c 22 00	jmp ($0022)	                jmp (tmp1)
.922c						xt_immediate:
.922c		20 bc d7	jsr $d7bc	                jsr current_to_dp
.922f		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9231		b1 02		lda ($02),y	                lda (dp),y
.9233		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9235		91 02		sta ($02),y	                sta (dp),y
.9237		60		rts		z_immediate:    rts
.9238						xt_input:
.9238		ca		dex		                dex
.9239		ca		dex		                dex
.923a		a9 12		lda #$12	                lda #<input
.923c		95 00		sta $00,x	                sta 0,x
.923e		a9 00		lda #$00	                lda #>input
.9240		95 01		sta $01,x	                sta 1,x
.9242		60		rts		z_input:        rts
.9243						xt_input_to_r:
.9243		68		pla		                pla
.9244		85 22		sta $22		                sta tmp1
.9246		68		pla		                pla
.9247		85 23		sta $23		                sta tmp1+1
.9249		a0 07		ldy #$07	                ldy #7
.924b						_loop:
.924b		b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.924e		48		pha		                pha
.924f		88		dey		                dey
.9250		10 f9		bpl $924b	                bpl _loop
.9252		a5 23		lda $23		                lda tmp1+1
.9254		48		pha		                pha
.9255		a5 22		lda $22		                lda tmp1
.9257		48		pha		                pha
.9258		60		rts		z_input_to_r: 	rts
.9259						xt_int_to_name:
.9259		20 75 d8	jsr $d875	                jsr underflow_1
.925c		ca		dex		                dex
.925d		ca		dex		                dex
.925e		74 00		stz $00,x	                stz 0,x
.9260		74 01		stz $01,x	                stz 1,x
.9262						_wordlist_loop:
.9262		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9264		0a		asl a		                asl                     ; Turn offset into cells offset.
.9265		18		clc		                clc
.9266		69 06		adc #$06	                adc #wordlists_offset
.9268		a8		tay		                tay
.9269		b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.926b		85 24		sta $24		                sta tmp2                ; into tmp2
.926d		c8		iny		                iny
.926e		b1 1e		lda ($1e),y	                lda (up),y
.9270		85 25		sta $25		                sta tmp2+1
.9272		a5 24		lda $24		                lda tmp2
.9274		05 25		ora $25		                ora tmp2+1
.9276		f0 38		beq $92b0	                beq _next_wordlist
.9278		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.927a		85 26		sta $26		                sta tmp3        ; Save target xt in tmp3
.927c		b5 03		lda $03,x	                lda 3,x
.927e		85 27		sta $27		                sta tmp3+1
.9280						_loop:
.9280		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9282		b1 24		lda ($24),y	                lda (tmp2),y    ; LSB of xt of current nt
.9284		c5 26		cmp $26		                cmp tmp3
.9286		d0 07		bne $928f	                bne _no_match
.9288		c8		iny		                iny
.9289		b1 24		lda ($24),y	                lda (tmp2),y    ; MSB of xt of current nt
.928b		c5 27		cmp $27		                cmp tmp3+1
.928d		f0 32		beq $92c1	                beq _match
.928f						_no_match:
.928f		18		clc		                clc
.9290		a5 24		lda $24		                lda tmp2
.9292		69 02		adc #$02	                adc #2
.9294		85 24		sta $24		                sta tmp2
.9296		a5 25		lda $25		                lda tmp2+1
.9298		69 00		adc #$00	                adc #0          ; only care about carry
.929a		85 25		sta $25		                sta tmp2+1
.929c		a0 00		ldy #$00	                ldy #0
.929e		b1 24		lda ($24),y	                lda (tmp2),y
.92a0		48		pha		                pha
.92a1		c8		iny		                iny
.92a2		11 24		ora ($24),y	                ora (tmp2),y
.92a4		f0 09		beq $92af	                beq _zero
.92a6		b1 24		lda ($24),y	                lda (tmp2),y
.92a8		85 25		sta $25		                sta tmp2+1
.92aa		68		pla		                pla
.92ab		85 24		sta $24		                sta tmp2
.92ad		80 d1		bra $9280	                bra _loop
.92af						_zero:
.92af		68		pla		                pla             ; Leftover from above loop
.92b0						_next_wordlist:
.92b0		b5 00		lda $00,x	                lda 0,x
.92b2		1a		inc a		                ina
.92b3		95 00		sta $00,x	                sta 0,x
.92b5		c9 0c		cmp #$0c	                cmp #max_wordlists
.92b7		d0 a9		bne $9262	                bne _wordlist_loop
.92b9		e8		inx		                inx
.92ba		e8		inx		                inx
.92bb		74 00		stz $00,x	                stz 0,x
.92bd		74 01		stz $01,x	                stz 1,x
.92bf		80 0a		bra $92cb	                bra z_int_to_name
.92c1						_match:
.92c1		e8		inx		                inx
.92c2		e8		inx		                inx
.92c3		a5 24		lda $24		                lda tmp2
.92c5		95 00		sta $00,x	                sta 0,x
.92c7		a5 25		lda $25		                lda tmp2+1
.92c9		95 01		sta $01,x	                sta 1,x
.92cb		60		rts		z_int_to_name:  rts
.92cc						xt_invert:
.92cc		20 75 d8	jsr $d875	                jsr underflow_1
.92cf		a9 ff		lda #$ff	                lda #$FF
.92d1		55 00		eor $00,x	                eor 0,x         ; LSB
.92d3		95 00		sta $00,x	                sta 0,x
.92d5		a9 ff		lda #$ff	                lda #$FF
.92d7		55 01		eor $01,x	                eor 1,x         ; MSB
.92d9		95 01		sta $01,x	                sta 1,x
.92db		60		rts		z_invert:       rts
.92dc						xt_is:
.92dc		a5 16		lda $16		                lda state
.92de		05 17		ora $17		                ora state+1
.92e0		f0 0c		beq $92ee	                beq _interpreting
.92e2						_compiling:
.92e2		20 54 85	jsr $8554	                jsr xt_bracket_tick
.92e5		a0 8a		ldy #$8a	                ldy #>xt_defer_store
.92e7		a9 ad		lda #$ad	                lda #<xt_defer_store
.92e9		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.92ec		80 06		bra $92f4	                bra _done
.92ee						_interpreting:
.92ee		20 b5 a1	jsr $a1b5	                jsr xt_tick
.92f1		20 ad 8a	jsr $8aad	                jsr xt_defer_store
.92f4						_done:
.92f4		60		rts		z_is:           rts
.92f5						xt_j:
.92f5		ca		dex		                dex
.92f6		ca		dex		                dex
.92f7		86 28		stx $28		                stx tmpdsp
.92f9		ba		tsx		                tsx
.92fa		38		sec		                sec
.92fb		bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.92fe		fd 09 01	sbc $0109,x	                sbc $0109,x
.9301		a8		tay		                tay
.9302		bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.9305		fd 0a 01	sbc $010a,x	                sbc $010A,x
.9308		a6 28		ldx $28		                ldx tmpdsp
.930a		95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.930c		94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.930e		60		rts		z_j:            rts
.930f						xt_key:
.930f		20 19 93	jsr $9319	                jsr key_a               ; returns char in A
.9312		ca		dex		                dex
.9313		ca		dex		                dex
.9314		95 00		sta $00,x	                sta 0,x
.9316		74 01		stz $01,x	                stz 1,x
.9318		60		rts		z_key:          rts
.9319						key_a:
.9319		6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.931c						xt_latestnt:
.931c		ca		dex		                dex
.931d		ca		dex		                dex
.931e		20 bc d7	jsr $d7bc	                jsr current_to_dp
.9321		a5 02		lda $02		                lda dp
.9323		95 00		sta $00,x	                sta 0,x
.9325		a5 03		lda $03		                lda dp+1
.9327		95 01		sta $01,x	                sta 1,x
.9329		60		rts		z_latestnt:     rts
.932a						xt_latestxt:
.932a		20 1c 93	jsr $931c	                jsr xt_latestnt         ; ( nt )
.932d		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( xt )
.9330		60		rts		z_latestxt:     rts
.9331						xt_leave:
.9331		68		pla		                pla
.9332		68		pla		                pla
.9333		68		pla		                pla
.9334		68		pla		                pla
.9335		60		rts		                rts             ; this must be compiled, so keep before z_leave
.9336						z_leave:
.9336						xt_left_bracket:
.9336		64 16		stz $16		                stz state
.9338		64 17		stz $17		                stz state+1
.933a		60		rts		z_left_bracket: rts
.933b						xt_less_number_sign:
.933b		20 85 98	jsr $9885	                jsr xt_pad      ; ( addr )
.933e		b5 00		lda $00,x	                lda 0,x
.9340		85 32		sta $32		                sta tohold
.9342		b5 01		lda $01,x	                lda 1,x
.9344		85 33		sta $33		                sta tohold+1
.9346		e8		inx		                inx
.9347		e8		inx		                inx
.9348						z_less_number_sign:
.9348		60		rts		                rts
.9349						xt_less_than:
.9349		20 7a d8	jsr $d87a	                jsr underflow_2
.934c		a0 00		ldy #$00	                ldy #0          ; default false
.934e		20 a1 d7	jsr $d7a1	                jsr compare_16bit
.9351		f0 03		beq $9356	                beq _false
.9353		30 01		bmi $9356	                bmi _false
.9355		88		dey		                dey
.9356						_false:
.9356		98		tya		                tya
.9357		e8		inx		                inx
.9358		e8		inx		                inx
.9359		95 00		sta $00,x	                sta 0,x
.935b		95 01		sta $01,x	                sta 1,x
.935d		60		rts		z_less_than:    rts
.935e						xt_list:
.935e		20 75 d8	jsr $d875	                jsr underflow_1
.9361		20 87 9e	jsr $9e87	                jsr xt_scr
.9364		20 3b a1	jsr $a13b	                jsr xt_store
.9367		20 f0 a7	jsr $a7f0	                jsr xt_editor_l
.936a		60		rts		z_list:         rts
.936b						xt_literal:
.936b		20 75 d8	jsr $d875	                jsr underflow_1
.936e		a0 93		ldy #$93	                ldy #>literal_runtime
.9370		a9 79		lda #$79	                lda #<literal_runtime
.9372		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.9375		20 24 87	jsr $8724	                jsr xt_comma
.9378		60		rts		z_literal:      rts
.9379						literal_runtime:
.9379		ca		dex		                dex
.937a		ca		dex		                dex
.937b		68		pla		                pla             ; LSB
.937c		85 22		sta $22		                sta tmp1
.937e		68		pla		                pla             ; MSB
.937f		85 23		sta $23		                sta tmp1+1
.9381		a0 01		ldy #$01	                ldy #1
.9383		b1 22		lda ($22),y	                lda (tmp1),y    ; LSB
.9385		95 00		sta $00,x	                sta 0,x
.9387		c8		iny		                iny
.9388		b1 22		lda ($22),y	                lda (tmp1),y    ; MSB
.938a		95 01		sta $01,x	                sta 1,x
.938c		98		tya		                tya
.938d		18		clc		                clc
.938e		65 22		adc $22		                adc tmp1
.9390		a8		tay		                tay
.9391		a5 23		lda $23		                lda tmp1+1
.9393		69 00		adc #$00	                adc #0
.9395		48		pha		                pha
.9396		5a		phy		                phy
.9397		60		rts		                rts
.9398						xt_load:
.9398		20 75 d8	jsr $d875	                jsr underflow_1
.939b		a0 01		ldy #$01	                ldy #blk_offset+1
.939d		b1 1e		lda ($1e),y	                lda (up),y
.939f		48		pha		                pha
.93a0		88		dey		                dey
.93a1		b1 1e		lda ($1e),y	                lda (up),y
.93a3		48		pha		                pha
.93a4		b5 00		lda $00,x	                lda 0,x
.93a6		91 1e		sta ($1e),y	                sta (up),y
.93a8		c8		iny		                iny
.93a9		b5 01		lda $01,x	                lda 1,x
.93ab		91 1e		sta ($1e),y	                sta (up),y
.93ad		20 77 83	jsr $8377	                jsr xt_block
.93b0		ca		dex		                dex
.93b1		ca		dex		                dex
.93b2		a9 04		lda #$04	                lda #4
.93b4		95 01		sta $01,x	                sta 1,x
.93b6		74 00		stz $00,x	                stz 0,x
.93b8		20 b4 90	jsr $90b4	                jsr load_evaluate
.93bb		a0 00		ldy #$00	                ldy #blk_offset
.93bd		68		pla		                pla
.93be		91 1e		sta ($1e),y	                sta (up),y
.93c0		c8		iny		                iny
.93c1		68		pla		                pla
.93c2		91 1e		sta ($1e),y	                sta (up),y
.93c4		88		dey		                dey
.93c5		11 1e		ora ($1e),y	                ora (up),y
.93c7		f0 12		beq $93db	                beq _done
.93c9		ca		dex		                dex
.93ca		ca		dex		                dex
.93cb		a0 00		ldy #$00	                ldy #blk_offset
.93cd		b1 1e		lda ($1e),y	                lda (up),y
.93cf		95 00		sta $00,x	                sta 0,x
.93d1		c8		iny		                iny
.93d2		b1 1e		lda ($1e),y	                lda (up),y
.93d4		95 01		sta $01,x	                sta 1,x
.93d6		20 77 83	jsr $8377	                jsr xt_block
.93d9		e8		inx		                inx
.93da		e8		inx		                inx
.93db						_done:
.93db		60		rts		z_load:         rts
.93dc						xt_loop:
.93dc		ca		dex		                dex
.93dd		ca		dex		                dex
.93de		a0 0e		ldy #$0e	                ldy #loop_runtime_end-loop_runtime
.93e0		a9 50		lda #$50	                lda #<loop_runtime
.93e2		95 00		sta $00,x	                sta 0,x
.93e4		a9 94		lda #$94	                lda #>loop_runtime
.93e6		95 01		sta $01,x	                sta 1,x
.93e8		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.93eb		80 0f		bra $93fc	                bra xt_loop_common
.93ed						xt_plus_loop:
.93ed		ca		dex		                dex
.93ee		ca		dex		                dex
.93ef		a0 10		ldy #$10	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93f1		a9 40		lda #$40	                lda #<plus_loop_runtime
.93f3		95 00		sta $00,x	                sta 0,x
.93f5		a9 94		lda #$94	                lda #>plus_loop_runtime
.93f7		95 01		sta $01,x	                sta 1,x
.93f9		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.93fc						xt_loop_common:
.93fc		20 24 87	jsr $8724	                jsr xt_comma
.93ff		a9 68		lda #$68	                lda #$68                ; opcode for PLA
.9401		a0 06		ldy #$06	                ldy #6
.9403						-
.9403		91 00		sta ($00),y	                sta (cp),y
.9405		88		dey		                dey
.9406		10 fb		bpl $9403	                bpl -
.9408		a9 06		lda #$06	                lda #6
.940a		18		clc		                clc
.940b		65 00		adc $00		                adc cp
.940d		85 00		sta $00		                sta cp
.940f		a5 01		lda $01		                lda cp+1
.9411		69 00		adc #$00	                adc #0                  ; only need carry
.9413		85 01		sta $01		                sta cp+1
.9415		b5 00		lda $00,x	                lda 0,x
.9417		85 22		sta $22		                sta tmp1
.9419		b5 01		lda $01,x	                lda 1,x
.941b		85 23		sta $23		                sta tmp1+1
.941d		e8		inx		                inx
.941e		e8		inx		                inx
.941f		a5 00		lda $00		                lda cp
.9421		38		sec		                sec
.9422		e9 01		sbc #$01	                sbc #1
.9424		48		pha		                pha             ; lsb
.9425		a5 01		lda $01		                lda cp+1
.9427		e9 00		sbc #$00	                sbc #0
.9429		48		pha		                pha             ; msb
.942a		a0 00		ldy #$00	                ldy #0
.942c						-
.942c		b9 3a 94	lda $943a,y	                lda loop_epilogue,y
.942f		d0 01		bne $9432	                bne +
.9431		68		pla		                pla
.9432						+
.9432		91 22		sta ($22),y	                sta (tmp1),y
.9434		c8		iny		                iny
.9435		c0 06		cpy #$06	                cpy #(loop_epilogue_end-loop_epilogue)
.9437		d0 f3		bne $942c	                bne -
.9439						z_loop:
.9439		60		rts		z_plus_loop:    rts
.943a						loop_epilogue:
.943a		a9 00		lda #$00	                lda #0
.943c		48		pha		                pha
.943d		a9 00		lda #$00	                lda #0
.943f		48		pha		                pha
.9440						loop_epilogue_end:
.9440						plus_loop_runtime:
.9440		18		clc		                clc
.9441		68		pla		                pla             ; LSB of index
.9442		75 00		adc $00,x	                adc 0,x         ; LSB of step
.9444		a8		tay		                tay             ; temporary storage of LSB
.9445		b8		clv		                clv
.9446		68		pla		                pla             ; MSB of index
.9447		75 01		adc $01,x	                adc 1,x         ; MSB of step
.9449		48		pha		                pha             ; put MSB of index back on stack
.944a		5a		phy		                phy             ; put LSB of index back on stack
.944b		e8		inx		                inx             ; dump step from TOS
.944c		e8		inx		                inx
.944d		70 03		bvs $9452	                bvs _hack+3     ; skip over JMP instruction
.944f						_hack:
>944f		4c				                .byte $4C
.9450						plus_loop_runtime_end:
.9450						loop_runtime:
.9450		b8		clv		                clv             ; note inc doesn't affect V
.9451		7a		ply		                ply             ; LSB of index
.9452		c8		iny		                iny             ; add one
.9453		d0 05		bne $945a	                bne _skip_msb   ; definitely not done
.9455		68		pla		                pla             ; MSB of index
.9456		18		clc		                clc
.9457		69 01		adc #$01	                adc #1          ; use adc to get V flag
.9459		48		pha		                pha             ; put MSB of index back on stack
.945a		5a		phy		_skip_msb:      phy             ; put LSB of index back on stack
.945b		70 03		bvs $9460	                bvs _hack+3     ; skip over JMP instruction
.945d						_hack:
>945d		4c				                .byte $4C
.945e						loop_runtime_end:
.945e						xt_lshift:
.945e		20 7a d8	jsr $d87a	                jsr underflow_2
.9461		b5 00		lda $00,x	                lda 0,x
.9463		29 0f		and #$0f	                and #%00001111
.9465		f0 08		beq $946f	                beq _done
.9467		a8		tay		                tay
.9468						_loop:
.9468		16 02		asl $02,x	                asl 2,x
.946a		36 03		rol $03,x	                rol 3,x
.946c		88		dey		                dey
.946d		d0 f9		bne $9468	                bne _loop
.946f						_done:
.946f		e8		inx		                inx
.9470		e8		inx		                inx
.9471		60		rts		z_lshift:       rts
.9472						xt_m_star:
.9472		20 7a d8	jsr $d87a	                jsr underflow_2
.9475		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9477		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.9479		48		pha		                pha
.947a		20 cd 80	jsr $80cd	                jsr xt_abs
.947d		20 5c a1	jsr $a15c	                jsr xt_swap
.9480		20 cd 80	jsr $80cd	                jsr xt_abs
.9483		20 a0 a5	jsr $a5a0	                jsr xt_um_star          ; ( d )
.9486		68		pla		                pla
.9487		10 03		bpl $948c	                bpl _done
.9489		20 08 8b	jsr $8b08	                jsr xt_dnegate
.948c						_done:
.948c		60		rts		z_m_star:       rts
.948d						xt_marker:
.948d		20 bc d7	jsr $d7bc	                jsr current_to_dp
.9490		a5 02		lda $02		                lda dp
.9492		48		pha		                pha
.9493		a5 03		lda $03		                lda dp+1
.9495		48		pha		                pha
.9496		a5 00		lda $00		                lda cp
.9498		48		pha		                pha
.9499		a5 01		lda $01		                lda cp+1
.949b		48		pha		                pha
.949c		20 30 89	jsr $8930	                jsr xt_create
.949f		a5 00		lda $00		                lda cp          ; LSB
.94a1		38		sec		                sec
.94a2		e9 02		sbc #$02	                sbc #2
.94a4		85 00		sta $00		                sta cp
.94a6		a5 01		lda $01		                lda cp+1        ; MSB
.94a8		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94aa		85 01		sta $01		                sta cp+1
.94ac		a0 94		ldy #$94	                ldy #>marker_runtime
.94ae		a9 cb		lda #$cb	                lda #<marker_runtime
.94b0		20 29 d7	jsr $d729	                jsr cmpl_word
.94b3		7a		ply		                ply                     ; MSB
.94b4		68		pla		                pla                     ; LSB
.94b5		20 29 d7	jsr $d729	                jsr cmpl_word
.94b8		7a		ply		                ply                     ; MSB
.94b9		68		pla		                pla                     ; LSB
.94ba		20 29 d7	jsr $d729	                jsr cmpl_word
.94bd		a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94bf						_marker_loop:
.94bf		b1 1e		lda ($1e),y	                lda (up),y
.94c1		20 2d d7	jsr $d72d	                jsr cmpl_a
.94c4		c8		iny		                iny
.94c5		98		tya		                tya
.94c6		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94c8		d0 f5		bne $94bf	                bne _marker_loop
.94ca		60		rts		z_marker:       rts
.94cb						marker_runtime:
.94cb		68		pla		                pla
.94cc		85 22		sta $22		                sta tmp1        ; LSB of address
.94ce		68		pla		                pla
.94cf		85 23		sta $23		                sta tmp1+1      ; MSB of address
.94d1		e6 22		inc $22		                inc tmp1
.94d3		d0 02		bne $94d7	                bne +
.94d5		e6 23		inc $23		                inc tmp1+1
.94d7						+
.94d7		a0 00		ldy #$00	                ldy #0
.94d9		b1 22		lda ($22),y	                lda (tmp1),y
.94db		85 00		sta $00		                sta cp
.94dd		c8		iny		                iny
.94de		b1 22		lda ($22),y	                lda (tmp1),y
.94e0		85 01		sta $01		                sta cp+1
.94e2		c8		iny		                iny
.94e3		b1 22		lda ($22),y	                lda (tmp1),y
.94e5		85 02		sta $02		                sta dp
.94e7		c8		iny		                iny
.94e8		b1 22		lda ($22),y	                lda (tmp1),y
.94ea		85 03		sta $03		                sta dp+1
.94ec		a0 04		ldy #$04	                ldy #4
.94ee						_marker_restore_loop:
.94ee		b1 22		lda ($22),y	                lda (tmp1), y
.94f0		91 1e		sta ($1e),y	                sta (up), y
.94f2		c8		iny		                iny
.94f3		98		tya		                tya
.94f4		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94f6		d0 f6		bne $94ee	                bne _marker_restore_loop
.94f8		20 cf d7	jsr $d7cf	                jsr dp_to_current       ; Move the CURRENT DP back.
.94fb		60		rts		                rts
.94fc						xt_max:
.94fc		20 7a d8	jsr $d87a	                jsr underflow_2
.94ff		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9501		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.9503		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9505		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9507		50 02		bvc $950b	                bvc _no_overflow
.9509		49 80		eor #$80	                eor #$80        ; complement negative flag
.950b						_no_overflow:
.950b		30 08		bmi $9515	                bmi _keep_nos
.950d		b5 00		lda $00,x	                lda 0,x
.950f		95 02		sta $02,x	                sta 2,x
.9511		b5 01		lda $01,x	                lda 1,x
.9513		95 03		sta $03,x	                sta 3,x
.9515						_keep_nos:
.9515		e8		inx		                inx
.9516		e8		inx		                inx
.9517		60		rts		z_max:          rts
.9518						xt_min:
.9518		20 7a d8	jsr $d87a	                jsr underflow_2
.951b		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.951d		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.951f		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9521		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9523		50 02		bvc $9527	                bvc _no_overflow
.9525		49 80		eor #$80	                eor #$80
.9527						_no_overflow:
.9527		10 08		bpl $9531	                bpl _keep_nos
.9529		b5 00		lda $00,x	                lda 0,x
.952b		95 02		sta $02,x	                sta 2,x
.952d		b5 01		lda $01,x	                lda 1,x
.952f		95 03		sta $03,x	                sta 3,x
.9531						_keep_nos:
.9531		e8		inx		                inx
.9532		e8		inx		                inx
.9533		60		rts		z_min:          rts
.9534						xt_minus:
.9534		20 7a d8	jsr $d87a	                jsr underflow_2
.9537		38		sec		                sec
.9538		b5 02		lda $02,x	                lda 2,x         ; LSB
.953a		f5 00		sbc $00,x	                sbc 0,x
.953c		95 02		sta $02,x	                sta 2,x
.953e		b5 03		lda $03,x	                lda 3,x         ; MSB
.9540		f5 01		sbc $01,x	                sbc 1,x
.9542		95 03		sta $03,x	                sta 3,x
.9544		e8		inx		                inx
.9545		e8		inx		                inx
.9546		60		rts		z_minus:        rts
.9547						xt_minus_leading:
.9547		20 7a d8	jsr $d87a	                jsr underflow_2
.954a						_loop:
.954a		b5 00		lda $00,x	                lda 0,x
.954c		15 01		ora $01,x	                ora 1,x
.954e		f0 0f		beq $955f	                beq _done
.9550		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9552		20 68 d8	jsr $d868	                jsr is_whitespace
.9555		90 08		bcc $955f	                bcc _done
.9557		20 ec 97	jsr $97ec	                jsr xt_one              ; ( addr u 1 )
.955a		20 c7 9f	jsr $9fc7	                jsr xt_slash_string     ; ( addr+ u-1 )
.955d		80 eb		bra $954a	                bra _loop
.955f						_done:
.955f						z_minus_leading:
.955f		60		rts		                rts
.9560						xt_minus_trailing:
.9560		20 7a d8	jsr $d87a	                jsr underflow_2
.9563		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9565		15 01		ora $01,x	                ora 1,x         ; MSB of n
.9567		f0 33		beq $959c	                beq _done
.9569		18		clc		                clc
.956a		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.956c		75 00		adc $00,x	                adc 0,x
.956e		85 22		sta $22		                sta tmp1
.9570		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.9572		75 01		adc $01,x	                adc 1,x
.9574		85 23		sta $23		                sta tmp1+1
.9576		a5 22		lda $22		                lda tmp1
.9578		d0 02		bne $957c	                bne +
.957a		c6 23		dec $23		                dec tmp1+1
.957c						+
.957c		c6 22		dec $22		                dec tmp1
.957e						_loop:
.957e		b2 22		lda ($22)	                lda (tmp1)
.9580		c9 20		cmp #$20	                cmp #AscSP
.9582		d0 18		bne $959c	                bne _done
.9584		a5 22		lda $22		                lda tmp1
.9586		d0 02		bne $958a	                bne +
.9588		c6 23		dec $23		                dec tmp1+1
.958a						+
.958a		c6 22		dec $22		                dec tmp1
.958c		b5 00		lda $00,x	                lda 0,x
.958e		d0 02		bne $9592	                bne +
.9590		d6 01		dec $01,x	                dec 1,x
.9592						+
.9592		d6 00		dec $00,x	                dec 0,x
.9594		b5 00		lda $00,x	                lda 0,x
.9596		15 01		ora $01,x	                ora 1,x
.9598		f0 02		beq $959c	                beq _done       ; Count has reached zero - we're done!
.959a		80 e2		bra $957e	                bra _loop
.959c						_done:
.959c						z_minus_trailing:
.959c		60		rts		                rts
.959d						xt_mod:
.959d		20 7a d8	jsr $d87a	                jsr underflow_2
.95a0		20 af 9f	jsr $9faf	                jsr xt_slash_mod
.95a3		e8		inx		                inx             ; DROP
.95a4		e8		inx		                inx
.95a5						z_mod:
.95a5		60		rts		                rts
.95a6						xt_move:
.95a6		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95a8		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95aa		f0 05		beq $95b1	                beq _lsb                ; wasn't helpful, move to LSB
.95ac		b0 0e		bcs $95bc	                bcs _to_move_up         ; we want CMOVE>
.95ae		4c 4f 86	jmp $864f	                jmp xt_cmove            ; JSR/RTS
.95b1						_lsb:
.95b1		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95b3		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95b5		f0 08		beq $95bf	                beq _equal              ; LSB is equal as well
.95b7		b0 03		bcs $95bc	                bcs _to_move_up         ; we want CMOVE>
.95b9		4c 4f 86	jmp $864f	                jmp xt_cmove            ; JSR/RTS
.95bc						_to_move_up:
.95bc		4c 8a 86	jmp $868a	                jmp xt_cmove_up         ; JSR/RTS
.95bf						_equal:
.95bf		8a		txa		                txa
.95c0		18		clc		                clc
.95c1		69 06		adc #$06	                adc #6
.95c3		aa		tax		                tax
.95c4		60		rts		z_move:         rts
.95c5						xt_name_to_int:
.95c5		20 75 d8	jsr $d875	                jsr underflow_1
.95c8		b5 00		lda $00,x	                lda 0,x
.95ca		18		clc		                clc
.95cb		69 04		adc #$04	                adc #4
.95cd		85 26		sta $26		                sta tmp3
.95cf		b5 01		lda $01,x	                lda 1,x
.95d1		90 01		bcc $95d4	                bcc _done
.95d3		1a		inc a		                ina
.95d4						_done:
.95d4		85 27		sta $27		                sta tmp3+1
.95d6		a0 00		ldy #$00	                ldy #0
.95d8		b1 26		lda ($26),y	                lda (tmp3),y
.95da		95 00		sta $00,x	                sta 0,x
.95dc		c8		iny		                iny
.95dd		b1 26		lda ($26),y	                lda (tmp3),y
.95df		95 01		sta $01,x	                sta 1,x
.95e1		60		rts		z_name_to_int:  rts
.95e2						xt_name_to_string:
.95e2		20 75 d8	jsr $d875	                jsr underflow_1
.95e5		ca		dex		                dex
.95e6		ca		dex		                dex
.95e7		a1 02		lda ($02,x)	                lda (2,x)
.95e9		95 00		sta $00,x	                sta 0,x
.95eb		74 01		stz $01,x	                stz 1,x
.95ed		b5 02		lda $02,x	                lda 2,x         ; LSB
.95ef		18		clc		                clc
.95f0		69 08		adc #$08	                adc #8
.95f2		a8		tay		                tay
.95f3		b5 03		lda $03,x	                lda 3,x         ; MSB
.95f5		69 00		adc #$00	                adc #0          ; just need carry
.95f7		95 03		sta $03,x	                sta 3,x
.95f9		94 02		sty $02,x	                sty 2,x
.95fb						z_name_to_string:
.95fb		60		rts		                rts
.95fc						xt_nc_limit:
.95fc		ca		dex		                dex
.95fd		ca		dex		                dex
.95fe		a9 1a		lda #$1a	                lda #<nc_limit
.9600		95 00		sta $00,x	                sta 0,x
.9602		a9 00		lda #$00	                lda #>nc_limit
.9604		95 01		sta $01,x	                sta 1,x
.9606		60		rts		z_nc_limit:     rts
.9607						xt_negate:
.9607		20 75 d8	jsr $d875	                jsr underflow_1
.960a		a9 00		lda #$00	        	lda #0
.960c		38		sec		                sec
.960d		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.960f		95 00		sta $00,x	                sta 0,x
.9611		a9 00		lda #$00	                lda #0
.9613		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9615		95 01		sta $01,x	                sta 1,x
.9617		60		rts		z_negate:       rts
.9618						xt_never_native:
.9618		20 bc d7	jsr $d7bc	                jsr current_to_dp
.961b		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.961d		b1 02		lda ($02),y	                lda (dp),y
.961f		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9621		29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.9623		91 02		sta ($02),y	                sta (dp),y
.9625						z_never_native:
.9625		60		rts		                rts
.9626						xt_nip:
.9626		20 7a d8	jsr $d87a	                jsr underflow_2
.9629		b5 00		lda $00,x	                lda 0,x         ; LSB
.962b		95 02		sta $02,x	                sta 2,x
.962d		b5 01		lda $01,x	                lda 1,x         ; MSB
.962f		95 03		sta $03,x	                sta 3,x
.9631		e8		inx		                inx
.9632		e8		inx		                inx
.9633		60		rts		z_nip:          rts
.9634						xt_not_equals:
.9634		20 7a d8	jsr $d87a	                jsr underflow_2
.9637		a0 00		ldy #$00	                ldy #0                  ; default is true
.9639		b5 00		lda $00,x	                lda 0,x                 ; LSB
.963b		d5 02		cmp $02,x	                cmp 2,x
.963d		d0 0a		bne $9649	                bne _not_equal
.963f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9641		d5 03		cmp $03,x	                cmp 3,x
.9643		d0 04		bne $9649	                bne _not_equal
.9645		a9 ff		lda #$ff	                lda #$FF
.9647		80 01		bra $964a	                bra _done
.9649						_not_equal:
.9649		88		dey		                dey                     ; drop thru to done
.964a						_done:
.964a		98		tya		                tya
.964b		e8		inx		                inx
.964c		e8		inx		                inx
.964d		95 00		sta $00,x	                sta 0,x
.964f		95 01		sta $01,x	                sta 1,x
.9651		60		rts		z_not_equals:   rts
.9652						xt_not_rote:
.9652		20 7f d8	jsr $d87f	                jsr underflow_3
.9655		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9657		b5 03		lda $03,x	                lda 3,x
.9659		95 01		sta $01,x	                sta 1,x
.965b		b5 05		lda $05,x	                lda 5,x
.965d		95 03		sta $03,x	                sta 3,x
.965f		94 05		sty $05,x	                sty 5,x
.9661		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9663		b5 02		lda $02,x	                lda 2,x
.9665		95 00		sta $00,x	                sta 0,x
.9667		b5 04		lda $04,x	                lda 4,x
.9669		95 02		sta $02,x	                sta 2,x
.966b		94 04		sty $04,x	                sty 4,x
.966d		60		rts		z_not_rote:     rts
.966e						xt_number:
.966e		20 7a d8	jsr $d87a	                jsr underflow_2
.9671		64 28		stz $28		                stz tmpdsp      ; flag for double
.9673		64 29		stz $29		                stz tmpdsp+1    ; flag for minus
.9675		a5 18		lda $18		                lda base
.9677		48		pha		                pha
.9678		20 5c a3	jsr $a35c	                jsr xt_two_dup
.967b		a1 02		lda ($02,x)	                lda (2,x)
.967d						_check_dec:
.967d		c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.967f		d0 04		bne $9685	                bne _check_hex
.9681		a9 0a		lda #$0a	                lda #$0A
.9683		80 42		bra $96c7	                bra _base_changed
.9685						_check_hex:
.9685		c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.9687		d0 04		bne $968d	                bne _check_binary
.9689		a9 10		lda #$10	                lda #$10
.968b		80 3a		bra $96c7	                bra _base_changed
.968d						_check_binary:
.968d		c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.968f		d0 04		bne $9695	                bne _check_char
.9691		a9 02		lda #$02	                lda #$02
.9693		80 32		bra $96c7	                bra _base_changed
.9695						_check_char:
.9695		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.9697		d0 3a		bne $96d3	                bne _check_minus
.9699		b5 00		lda $00,x	                lda 0,x         ; Get the length
.969b		c9 03		cmp #$03	                cmp #$03
.969d		d0 26		bne $96c5	                bne _not_a_char
.969f		b5 01		lda $01,x	                lda 1,x
.96a1		d0 22		bne $96c5	                bne _not_a_char ; No compare needed to check for non-zero.
.96a3		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96a5		18		clc		                clc
.96a6		69 02		adc #$02	                adc #2          ; length of string
.96a8		85 2a		sta $2a		                sta tmptos
.96aa		b5 03		lda $03,x	                lda 3,x
.96ac		69 00		adc #$00	                adc #0          ; only need carry
.96ae		85 2b		sta $2b		                sta tmptos+1
.96b0		b2 2a		lda ($2a)	                lda (tmptos)
.96b2		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96b4		d0 0f		bne $96c5	                bne _not_a_char
.96b6		f6 02		inc $02,x	                inc 2,x
.96b8		d0 02		bne $96bc	                bne +
.96ba		f6 03		inc $03,x	                inc 3,x
.96bc						+
.96bc		a1 02		lda ($02,x)	                lda (2,x)
.96be		95 02		sta $02,x	                sta 2,x
.96c0		74 03		stz $03,x	                stz 3,x
.96c2		4c 43 97	jmp $9743	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96c5						_not_a_char:
.96c5		80 5a		bra $9721	                bra _number_error
.96c7						_base_changed:
.96c7		85 18		sta $18		                sta base        ; Switch to the new base
.96c9		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96cb		d0 02		bne $96cf	                bne +
.96cd		f6 03		inc $03,x	                inc 3,x
.96cf						+
.96cf		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96d1		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96d3						_check_minus:
.96d3		c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96d5		d0 0a		bne $96e1	                bne _check_dot
.96d7		c6 29		dec $29		                dec tmpdsp+1
.96d9		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96db		d0 02		bne $96df	                bne +
.96dd		f6 03		inc $03,x	                inc 3,x
.96df						+
.96df		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96e1						_check_dot:
.96e1		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96e3		18		clc		                clc
.96e4		75 00		adc $00,x	                adc 0,x         ; length of string
.96e6		85 2a		sta $2a		                sta tmptos
.96e8		b5 03		lda $03,x	                lda 3,x
.96ea		69 00		adc #$00	                adc #0          ; only need carry
.96ec		85 2b		sta $2b		                sta tmptos+1
.96ee		a5 2a		lda $2a		                lda tmptos
.96f0		d0 02		bne $96f4	                bne +
.96f2		c6 2b		dec $2b		                dec tmptos+1
.96f4						+
.96f4		c6 2a		dec $2a		                dec tmptos
.96f6		b2 2a		lda ($2a)	                lda (tmptos)
.96f8		c9 2e		cmp #$2e	                cmp #'.'
.96fa		d0 04		bne $9700	                bne _main
.96fc		c6 28		dec $28		                dec tmpdsp
.96fe		d6 00		dec $00,x	                dec 0,x
.9700						_main:
.9700		ca		dex		                dex
.9701		ca		dex		                dex
.9702		ca		dex		                dex
.9703		ca		dex		                dex
.9704		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9706		95 00		sta $00,x	                sta 0,x
.9708		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.970a		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.970c		95 02		sta $02,x	                sta 2,x
.970e		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9710		95 03		sta $03,x	                sta 3,x
.9712		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9714		74 05		stz $05,x	                stz 5,x
.9716		74 06		stz $06,x	                stz 6,x
.9718		74 07		stz $07,x	                stz 7,x
.971a		20 61 a2	jsr $a261	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.971d		b5 00		lda $00,x	                lda 0,x
.971f		f0 1e		beq $973f	                beq _all_converted
.9721						_number_error:
.9721		20 54 a3	jsr $a354	                jsr xt_two_drop ; >NUMBER modified addr u
.9724		20 54 a3	jsr $a354	                jsr xt_two_drop ; ud   (partially converted number)
.9727		a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9729		20 db 8d	jsr $8ddb	                jsr emit_a
.972c		20 a7 a4	jsr $a4a7	                jsr xt_type
.972f		a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.9731		20 db 8d	jsr $8ddb	                jsr emit_a
.9734		20 cc a0	jsr $a0cc	                jsr xt_space
.9737		68		pla		                pla
.9738		85 18		sta $18		                sta base
.973a		a9 08		lda #$08	                lda #err_syntax
.973c		4c 8b d8	jmp $d88b	                jmp error
.973f						_all_converted:
.973f		e8		inx		                inx ; Drop the current addr u
.9740		e8		inx		                inx
.9741		e8		inx		                inx
.9742		e8		inx		                inx
.9743						_drop_original_string:
.9743		20 22 a4	jsr $a422	                jsr xt_two_swap  ; Drop the original addr u
.9746		20 54 a3	jsr $a354	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9749		a5 28		lda $28		                lda tmpdsp      ; flag for double
.974b		f0 0d		beq $975a	                beq _single
.974d		a9 20		lda #$20	                lda #%00100000
.974f		04 20		tsb $20		                tsb status
.9751		a5 29		lda $29		                lda tmpdsp+1
.9753		f0 12		beq $9767	                beq _done       ; no minus, all done
.9755		20 08 8b	jsr $8b08	                jsr xt_dnegate
.9758		80 0d		bra $9767	                bra _done
.975a						_single:
.975a		e8		inx		                inx
.975b		e8		inx		                inx
.975c		a9 20		lda #$20	                lda #%00100000
.975e		14 20		trb $20		                trb status
.9760		a5 29		lda $29		                lda tmpdsp+1
.9762		f0 03		beq $9767	                beq _done       ; no minus, all done
.9764		20 07 96	jsr $9607	                jsr xt_negate
.9767						_done:
.9767		68		pla		                pla
.9768		85 18		sta $18		                sta base
.976a		60		rts		z_number:       rts
.976b						xt_number_sign:
.976b		20 7a d8	jsr $d87a	                jsr underflow_2         ; double number
.976e		20 3d 83	jsr $833d	                jsr xt_base
.9771		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( ud1 base )
.9774		20 14 a3	jsr $a314	                jsr xt_to_r             ; >r
.9777		20 56 a7	jsr $a756	                jsr xt_zero             ; 0
.977a		20 61 9a	jsr $9a61	                jsr xt_r_fetch          ; r@
.977d		20 5e a5	jsr $a55e	                jsr xt_um_slash_mod     ; um/mod
.9780		20 34 9b	jsr $9b34	                jsr xt_rot              ; rot
.9783		20 34 9b	jsr $9b34	                jsr xt_rot              ; rot
.9786		20 76 9a	jsr $9a76	                jsr xt_r_from           ; r>
.9789		20 5e a5	jsr $a55e	                jsr xt_um_slash_mod     ; um/mod
.978c		20 34 9b	jsr $9b34	                jsr xt_rot              ; rot
.978f		20 34 9b	jsr $9b34	                jsr xt_rot              ; ( ud rem )
.9792		b5 00		lda $00,x	                lda 0,x
.9794		a8		tay		                tay
.9795		b9 41 d4	lda $d441,y	                lda s_abc_upper,y
.9798		95 00		sta $00,x	                sta 0,x
.979a		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.979c		20 bc 91	jsr $91bc	                jsr xt_hold
.979f						z_number_sign:
.979f		60		rts		                rts
.97a0						xt_number_sign_greater:
.97a0		20 7a d8	jsr $d87a	                jsr underflow_2         ; double number
.97a3		a5 32		lda $32		                lda tohold
.97a5		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97a7		95 02		sta $02,x	                sta 2,x
.97a9		a5 33		lda $33		                lda tohold+1
.97ab		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97ad		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97af		20 85 98	jsr $9885	                jsr xt_pad      ; ( addr addr pad )
.97b2		38		sec		                sec
.97b3		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97b5		f5 02		sbc $02,x	                sbc 2,x
.97b7		95 02		sta $02,x	                sta 2,x
.97b9		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97bb		f5 03		sbc $03,x	                sbc 3,x
.97bd		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97bf		e8		inx		                inx
.97c0		e8		inx		                inx
.97c1						z_number_sign_greater:
.97c1		60		rts		                rts
.97c2						xt_number_sign_s:
.97c2		20 7a d8	jsr $d87a	                jsr underflow_2
.97c5						_loop:
.97c5		20 6b 97	jsr $976b	                jsr xt_number_sign
.97c8		b5 00		lda $00,x	                lda 0,x
.97ca		15 01		ora $01,x	                ora 1,x
.97cc		15 02		ora $02,x	                ora 2,x
.97ce		15 03		ora $03,x	                ora 3,x
.97d0		d0 f3		bne $97c5	                bne _loop
.97d2						z_number_sign_s:
.97d2		60		rts		                rts
.97d3						xt_of:
.97d3		a0 98		ldy #$98	                ldy #>xt_over
.97d5		a9 77		lda #$77	                lda #<xt_over
.97d7		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.97da		a0 8e		ldy #$8e	                ldy #>xt_equal
.97dc		a9 b3		lda #$b3	                lda #<xt_equal
.97de		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.97e1		20 e6 91	jsr $91e6	                jsr xt_if
.97e4		a0 8c		ldy #$8c	                ldy #>xt_drop
.97e6		a9 e1		lda #$e1	                lda #<xt_drop
.97e8		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.97eb		60		rts		z_of:           rts
.97ec						xt_editor_wordlist:
.97ec						xt_one:
.97ec		ca		dex		                dex
.97ed		ca		dex		                dex
.97ee		a9 01		lda #$01	                lda #1
.97f0		95 00		sta $00,x	                sta 0,x
.97f2		74 01		stz $01,x	                stz 1,x
.97f4						z_editor_wordlist:
.97f4						z_one:
.97f4		60		rts		                rts
.97f5						xt_one_minus:
.97f5		20 75 d8	jsr $d875	                jsr underflow_1
.97f8		b5 00		lda $00,x	                lda 0,x
.97fa		d0 02		bne $97fe	                bne +
.97fc		d6 01		dec $01,x	                dec 1,x
.97fe						+
.97fe		d6 00		dec $00,x	                dec 0,x
.9800		60		rts		z_one_minus:    rts
.9801						xt_char_plus:
.9801						xt_one_plus:
.9801		20 75 d8	jsr $d875	                jsr underflow_1
.9804		f6 00		inc $00,x	                inc 0,x
.9806		d0 02		bne $980a	                bne _done
.9808		f6 01		inc $01,x	                inc 1,x
.980a						_done:
.980a						z_char_plus:
.980a		60		rts		z_one_plus:     rts
.980b						xt_only:
.980b		ca		dex		                dex
.980c		ca		dex		                dex
.980d		a9 ff		lda #$ff	                lda #$FF
.980f		95 00		sta $00,x	                sta 0,x
.9811		95 01		sta $01,x	                sta 1,x
.9813		20 f8 9c	jsr $9cf8	                jsr xt_set_order
.9816		60		rts		z_only:         rts
.9817						xt_or:
.9817		20 7a d8	jsr $d87a	                jsr underflow_2
.981a		b5 00		lda $00,x	                lda 0,x
.981c		15 02		ora $02,x	                ora 2,x
.981e		95 02		sta $02,x	                sta 2,x
.9820		b5 01		lda $01,x	                lda 1,x
.9822		15 03		ora $03,x	                ora 3,x
.9824		95 03		sta $03,x	                sta 3,x
.9826		e8		inx		                inx
.9827		e8		inx		                inx
.9828		60		rts		z_or:           rts
.9829						xt_order:
.9829		20 2a 89	jsr $892a	                jsr xt_cr
.982c		20 19 91	jsr $9119	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.982f		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9831		f0 1e		beq $9851	                beq _drop_done
.9833						_have_wordlists:
.9833		a8		tay		                tay
.9834						_loop:
.9834		e8		inx		                inx
.9835		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9836		b5 00		lda $00,x	                lda 0,x
.9838		5a		phy		                phy
.9839		20 54 98	jsr $9854	                jsr order_print_wid_string   ; internal helper function
.983c		7a		ply		                ply
.983d		88		dey		                dey
.983e		d0 f4		bne $9834	                bne _loop
.9840		20 cc a0	jsr $a0cc	                jsr xt_space
.9843		20 cc a0	jsr $a0cc	                jsr xt_space
.9846		20 0e 91	jsr $910e	                jsr xt_get_current      ; ( wid )
.9849		b5 00		lda $00,x	                lda 0,x
.984b		20 54 98	jsr $9854	                jsr order_print_wid_string
.984e		20 2a 89	jsr $892a	                jsr xt_cr
.9851						_drop_done:
.9851		e8		inx		                inx
.9852		e8		inx		                inx
.9853						z_order:
.9853		60		rts		                rts
.9854						order_print_wid_string:
.9854		c9 04		cmp #$04	                cmp #4
.9856		90 09		bcc $9861	                bcc _output_string      ; less than 4, print a real string
.9858		ca		dex		                dex
.9859		ca		dex		                dex
.985a		95 00		sta $00,x	                sta 0,x
.985c		74 01		stz $01,x	                stz 1,x
.985e		4c d2 a4	jmp $a4d2	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.9861						_output_string:
.9861		a8		tay		                tay
.9862		b9 68 98	lda $9868,y	                lda _wid_data,y
.9865		4c b1 d8	jmp $d8b1	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9868						_wid_data:
>9868		04				        .byte str_wid_forth            ; WID 0: "Forth"
>9869		05				        .byte str_wid_editor           ; WID 1: "Editor"
>986a		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>986b		07				        .byte str_wid_root             ; WID 3: "Root"
.986c						xt_output:
.986c		ca		dex		                dex
.986d		ca		dex		                dex
.986e		a9 10		lda #$10	                lda #<output
.9870		95 00		sta $00,x	                sta 0,x
.9872		a9 00		lda #$00	                lda #>output
.9874		95 01		sta $01,x	                sta 1,x
.9876		60		rts		z_output:       rts
.9877						xt_over:
.9877		20 7a d8	jsr $d87a	                jsr underflow_2
.987a		ca		dex		                dex
.987b		ca		dex		                dex
.987c		b5 04		lda $04,x	                lda 4,x         ; LSB
.987e		95 00		sta $00,x	                sta 0,x
.9880		b5 05		lda $05,x	                lda 5,x         ; MSB
.9882		95 01		sta $01,x	                sta 1,x
.9884		60		rts		z_over:         rts
.9885						xt_pad:
.9885		ca		dex		                dex
.9886		ca		dex		                dex
.9887		a5 00		lda $00		                lda cp
.9889		18		clc		                clc
.988a		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.988c		95 00		sta $00,x	                sta 0,x
.988e		a5 01		lda $01		                lda cp+1
.9890		69 00		adc #$00	                adc #0          ; only need carry
.9892		95 01		sta $01,x	                sta 1,x
.9894		60		rts		z_pad:          rts
.9895						xt_page:
.9895		a9 1b		lda #$1b	                lda #AscESC
.9897		20 db 8d	jsr $8ddb	                jsr emit_a
.989a		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.989c		20 db 8d	jsr $8ddb	                jsr emit_a
.989f		a9 32		lda #$32	                lda #'2'
.98a1		20 db 8d	jsr $8ddb	                jsr emit_a
.98a4		a9 4a		lda #$4a	                lda #'J'
.98a6		20 db 8d	jsr $8ddb	                jsr emit_a
.98a9		20 56 a7	jsr $a756	                jsr xt_zero
.98ac		20 56 a7	jsr $a756	                jsr xt_zero
.98af		20 e4 82	jsr $82e4	                jsr xt_at_xy
.98b2		60		rts		z_page:         rts
.98b3						xt_paren:
.98b3		ca		dex		                dex
.98b4		ca		dex		                dex
.98b5		a9 29		lda #$29	                lda #41     ; Right parenthesis
.98b7		95 00		sta $00,x	                sta 0,x
.98b9		74 01		stz $01,x	                stz 1,x
.98bb		20 1e 99	jsr $991e	                jsr xt_parse
.98be		e8		inx		                inx
.98bf		e8		inx		                inx
.98c0		e8		inx		                inx
.98c1		e8		inx		                inx
.98c2		60		rts		z_paren:        rts
.98c3						xt_parse_name:
.98c3		a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98c5		38		sec		                sec
.98c6		e5 0c		sbc $0c		                sbc toin
.98c8		85 22		sta $22		                sta tmp1
.98ca		a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98cc		e5 0d		sbc $0d		                sbc toin+1
.98ce		85 23		sta $23		                sta tmp1+1
.98d0		a5 22		lda $22		                lda tmp1
.98d2		05 23		ora $23		                ora tmp1+1
.98d4		f0 28		beq $98fe	                beq _empty_line
.98d6		a5 08		lda $08		                lda cib
.98d8		18		clc		                clc
.98d9		65 0c		adc $0c		                adc toin
.98db		85 24		sta $24		                sta tmp2                ; LSB of first character
.98dd		a5 09		lda $09		                lda cib+1
.98df		65 0d		adc $0d		                adc toin+1
.98e1		85 25		sta $25		                sta tmp2+1              ; MSB
.98e3						_skip_loop:
.98e3		b2 24		lda ($24)	                lda (tmp2)              ; work copy of cib
.98e5		20 68 d8	jsr $d868	                jsr is_whitespace
.98e8		90 1f		bcc $9909	                bcc _char_found
.98ea		e6 24		inc $24		                inc tmp2
.98ec		d0 02		bne $98f0	                bne +
.98ee		e6 25		inc $25		                inc tmp2+1
.98f0						+
.98f0		a5 22		lda $22		                lda tmp1
.98f2		d0 02		bne $98f6	                bne +
.98f4		c6 23		dec $23		                dec tmp1+1
.98f6		c6 22		dec $22		+               dec tmp1
.98f8		a5 22		lda $22		                lda tmp1
.98fa		05 23		ora $23		                ora tmp1+1
.98fc		d0 e5		bne $98e3	                bne _skip_loop          ; fall through if empty line
.98fe						_empty_line:
.98fe		ca		dex		                dex
.98ff		ca		dex		                dex
.9900		ca		dex		                dex
.9901		ca		dex		                dex
.9902		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.9904		74 01		stz $01,x	                stz 1,x
.9906		4c b5 99	jmp $99b5	                jmp z_parse_name        ; skip over PARSE
.9909						_char_found:
.9909		a5 24		lda $24		                lda tmp2
.990b		38		sec		                sec
.990c		e5 08		sbc $08		                sbc cib
.990e		85 0c		sta $0c		                sta toin
.9910		a5 25		lda $25		                lda tmp2+1
.9912		e5 09		sbc $09		                sbc cib+1
.9914		85 0d		sta $0d		                sta toin+1
.9916		ca		dex		                dex
.9917		ca		dex		                dex
.9918		a9 20		lda #$20	                lda #AscSP
.991a		95 00		sta $00,x	                sta 0,x
.991c		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.991e						xt_parse:
.991e		20 75 d8	jsr $d875	                jsr underflow_1
.9921		a5 0a		lda $0a		                lda ciblen
.9923		05 0b		ora $0b		                ora ciblen+1
.9925		f0 0c		beq $9933	                beq _abort_parse
.9927		a5 0d		lda $0d		                lda toin+1              ; MSB
.9929		c5 0b		cmp $0b		                cmp ciblen+1
.992b		90 0e		bcc $993b	                bcc _go_parse           ; unsigned comparison
.992d		a5 0c		lda $0c		                lda toin                ; LSB
.992f		c5 0a		cmp $0a		                cmp ciblen
.9931		90 08		bcc $993b	                bcc _go_parse
.9933						_abort_parse:
.9933		ca		dex		                dex
.9934		ca		dex		                dex
.9935		74 00		stz $00,x	                stz 0,x
.9937		74 01		stz $01,x	                stz 1,x
.9939		80 7a		bra $99b5	                bra _done
.993b						_go_parse:
.993b		b5 00		lda $00,x	                lda 0,x
.993d		85 2a		sta $2a		                sta tmptos
.993f		ca		dex		                dex
.9940		ca		dex		                dex
.9941		a5 08		lda $08		                lda cib
.9943		18		clc		                clc
.9944		65 0c		adc $0c		                adc toin        ; LSB
.9946		85 22		sta $22		                sta tmp1
.9948		85 24		sta $24		                sta tmp2
.994a		95 02		sta $02,x	                sta 2,x
.994c		a5 09		lda $09		                lda cib+1
.994e		65 0d		adc $0d		                adc toin+1      ; MSB
.9950		85 23		sta $23		                sta tmp1+1
.9952		85 25		sta $25		                sta tmp2+1
.9954		95 03		sta $03,x	                sta 3,x
.9956		a5 08		lda $08		                lda cib
.9958		18		clc		                clc
.9959		65 0a		adc $0a		                adc ciblen
.995b		85 26		sta $26		                sta tmp3
.995d		a5 09		lda $09		                lda cib+1
.995f		65 0b		adc $0b		                adc ciblen+1
.9961		85 27		sta $27		                sta tmp3+1
.9963		64 2b		stz $2b		                stz tmptos+1
.9965						_loop:
.9965		a5 24		lda $24		                lda tmp2
.9967		c5 26		cmp $26		                cmp tmp3
.9969		d0 06		bne $9971	                bne _not_empty
.996b		a5 25		lda $25		                lda tmp2+1
.996d		c5 27		cmp $27		                cmp tmp3+1
.996f		f0 1d		beq $998e	                beq _eol
.9971						_not_empty:
.9971		b2 24		lda ($24)	                lda (tmp2)
.9973		a4 2a		ldy $2a		                ldy tmptos
.9975		c0 20		cpy #$20	                cpy #AscSP
.9977		d0 07		bne $9980	                bne _not_whitespace
.9979		20 68 d8	jsr $d868	                jsr is_whitespace
.997c		90 02		bcc $9980	                bcc _not_whitespace
.997e		80 0c		bra $998c	                bra _found_delimiter
.9980						_not_whitespace:
.9980		c5 2a		cmp $2a		                cmp tmptos
.9982		f0 08		beq $998c	                beq _found_delimiter
.9984		e6 24		inc $24		                inc tmp2
.9986		d0 dd		bne $9965	                bne _loop
.9988		e6 25		inc $25		                inc tmp2+1
.998a		80 d9		bra $9965	                bra _loop
.998c						_found_delimiter:
.998c		e6 2b		inc $2b		                inc tmptos+1
.998e						_eol:
.998e		a5 24		lda $24		                lda tmp2
.9990		38		sec		                sec
.9991		e5 22		sbc $22		                sbc tmp1
.9993		95 00		sta $00,x	                sta 0,x
.9995		a5 25		lda $25		                lda tmp2+1
.9997		e5 23		sbc $23		                sbc tmp1+1
.9999		95 01		sta $01,x	                sta 1,x
.999b		a5 24		lda $24		                lda tmp2
.999d		38		sec		                sec
.999e		e5 08		sbc $08		                sbc cib
.99a0		85 0c		sta $0c		                sta toin
.99a2		a5 25		lda $25		                lda tmp2+1
.99a4		e5 09		sbc $09		                sbc cib+1
.99a6		85 0d		sta $0d		                sta toin+1
.99a8		a5 0c		lda $0c		                lda toin
.99aa		18		clc		                clc
.99ab		65 2b		adc $2b		                adc tmptos+1
.99ad		85 0c		sta $0c		                sta toin
.99af		a5 0d		lda $0d		                lda toin+1
.99b1		69 00		adc #$00	                adc #0          ; we only need the carry
.99b3		85 0d		sta $0d		                sta toin+1
.99b5						_done:
.99b5						z_parse_name:
.99b5		60		rts		z_parse:        rts
.99b6						xt_pick:
.99b6		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99b8		8a		txa		                txa
.99b9		75 00		adc $00,x	                adc 0,x
.99bb		a8		tay		                tay
.99bc		b9 02 00	lda $0002,y	                lda 0002,y
.99bf		95 00		sta $00,x	                sta 0,x
.99c1		b9 03 00	lda $0003,y	                lda 0003,y
.99c4		95 01		sta $01,x	                sta 1,x
.99c6		60		rts		z_pick:         rts
.99c7						xt_plus:
.99c7		20 7a d8	jsr $d87a	                jsr underflow_2
.99ca		18		clc		                clc
.99cb		b5 00		lda $00,x	                lda 0,x         ; LSB
.99cd		75 02		adc $02,x	                adc 2,x
.99cf		95 02		sta $02,x	                sta 2,x
.99d1		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99d3		75 03		adc $03,x	                adc 3,x
.99d5		95 03		sta $03,x	                sta 3,x
.99d7		e8		inx		                inx
.99d8		e8		inx		                inx
.99d9		60		rts		z_plus:         rts
.99da						xt_plus_store:
.99da		20 7a d8	jsr $d87a	                jsr underflow_2
.99dd		b5 00		lda $00,x	                lda 0,x
.99df		85 22		sta $22		                sta tmp1
.99e1		b5 01		lda $01,x	                lda 1,x
.99e3		85 23		sta $23		                sta tmp1+1
.99e5		a0 00		ldy #$00	                ldy #0          ; LSB
.99e7		b1 22		lda ($22),y	                lda (tmp1),y
.99e9		18		clc		                clc
.99ea		75 02		adc $02,x	                adc 2,x
.99ec		91 22		sta ($22),y	                sta (tmp1),y
.99ee		c8		iny		                iny             ; MSB
.99ef		b1 22		lda ($22),y	                lda (tmp1),y
.99f1		75 03		adc $03,x	                adc 3,x
.99f3		91 22		sta ($22),y	                sta (tmp1),y
.99f5		e8		inx		                inx
.99f6		e8		inx		                inx
.99f7		e8		inx		                inx
.99f8		e8		inx		                inx
.99f9		60		rts		z_plus_store:   rts
.99fa						xt_postpone:
.99fa		20 c3 98	jsr $98c3	                jsr xt_parse_name               ; ( -- addr n )
.99fd		b5 00		lda $00,x	                lda 0,x
.99ff		15 01		ora $01,x	                ora 1,x
.9a01		d0 05		bne $9a08	                bne +
.9a03		a9 05		lda #$05	                lda #err_noname
.9a05		4c 8b d8	jmp $d88b	                jmp error
.9a08						+
.9a08		20 c0 8f	jsr $8fc0	                jsr xt_find_name                ; ( -- nt | 0 )
.9a0b		d0 05		bne $9a12	                bne +
.9a0d		a9 05		lda #$05	                lda #err_noname
.9a0f		4c 8b d8	jmp $d88b	                jmp error
.9a12						+
.9a12		b5 00		lda $00,x	                lda 0,x
.9a14		85 22		sta $22		                sta tmp1
.9a16		b5 01		lda $01,x	                lda 1,x
.9a18		85 23		sta $23		                sta tmp1+1
.9a1a		20 c5 95	jsr $95c5	                jsr xt_name_to_int              ; ( nt -- xt )
.9a1d		e6 22		inc $22		                inc tmp1
.9a1f		d0 02		bne $9a23	                bne +
.9a21		e6 23		inc $23		                inc tmp1+1
.9a23						+
.9a23		b2 22		lda ($22)	                lda (tmp1)
.9a25		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a27		f0 05		beq $9a2e	                beq _not_immediate
.9a29		20 a3 87	jsr $87a3	                jsr xt_compile_comma
.9a2c		80 0a		bra $9a38	                bra _done
.9a2e						_not_immediate:
.9a2e		20 6b 93	jsr $936b	                jsr xt_literal
.9a31		a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a33		a9 a3		lda #$a3	                lda #<xt_compile_comma
.9a35		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.9a38						_done:
.9a38		60		rts		z_postpone:     rts
.9a39						xt_previous:
.9a39		20 19 91	jsr $9119	                jsr xt_get_order
.9a3c		20 26 96	jsr $9626	                jsr xt_nip
.9a3f		20 f5 97	jsr $97f5	                jsr xt_one_minus
.9a42		20 f8 9c	jsr $9cf8	                jsr xt_set_order
.9a45		60		rts		z_previous:     rts
.9a46						xt_question:
.9a46		20 65 8f	jsr $8f65	                jsr xt_fetch
.9a49		20 e9 8b	jsr $8be9	                jsr xt_dot
.9a4c		60		rts		z_question:     rts
.9a4d						xt_question_dup:
.9a4d		20 75 d8	jsr $d875	                jsr underflow_1
.9a50		b5 00		lda $00,x	                lda 0,x
.9a52		15 01		ora $01,x	                ora 1,x
.9a54		f0 0a		beq $9a60	                beq _done
.9a56		ca		dex		                dex
.9a57		ca		dex		                dex
.9a58		b5 02		lda $02,x	                lda 2,x
.9a5a		95 00		sta $00,x	                sta 0,x
.9a5c		b5 03		lda $03,x	                lda 3,x
.9a5e		95 01		sta $01,x	                sta 1,x
.9a60						_done:
.9a60		60		rts		z_question_dup: rts
.9a61						xt_r_fetch:
.9a61		7a		ply		                ply             ; LSB
.9a62		84 22		sty $22		                sty tmp1
.9a64		7a		ply		                ply             ; MSB
.9a65		ca		dex		                dex
.9a66		ca		dex		                dex
.9a67		68		pla		                pla             ; LSB
.9a68		95 00		sta $00,x	                sta 0,x
.9a6a		68		pla		                pla             ; MSB
.9a6b		95 01		sta $01,x	                sta 1,x
.9a6d		48		pha		                pha
.9a6e		b5 00		lda $00,x	                lda 0,x
.9a70		48		pha		                pha
.9a71		5a		phy		                phy             ; MSB
.9a72		a4 22		ldy $22		                ldy tmp1
.9a74		5a		phy		                phy             ; LSB
.9a75		60		rts		z_r_fetch:      rts
.9a76						xt_r_from:
.9a76		68		pla		                pla             ; LSB
.9a77		85 2a		sta $2a		                sta tmptos
.9a79		7a		ply		                ply             ; MSB
.9a7a		ca		dex		                dex
.9a7b		ca		dex		                dex
.9a7c		68		pla		                pla             ; LSB
.9a7d		95 00		sta $00,x	                sta 0,x
.9a7f		68		pla		                pla             ; MSB
.9a80		95 01		sta $01,x	                sta 1,x
.9a82		5a		phy		                phy             ; MSB
.9a83		a5 2a		lda $2a		                lda tmptos
.9a85		48		pha		                pha             ; LSB
.9a86		60		rts		z_r_from:       rts
.9a87						xt_r_to_input:
.9a87		68		pla		                pla
.9a88		85 22		sta $22		                sta tmp1
.9a8a		68		pla		                pla
.9a8b		85 23		sta $23		                sta tmp1+1
.9a8d		a0 00		ldy #$00	                ldy #0
.9a8f						_loop:
.9a8f		68		pla		                pla
.9a90		99 06 00	sta $0006,y	                sta insrc,y
.9a93		c8		iny		                iny
.9a94		c0 08		cpy #$08	                cpy #8
.9a96		d0 f7		bne $9a8f	                bne _loop
.9a98		a5 23		lda $23		                lda tmp1+1
.9a9a		48		pha		                pha
.9a9b		a5 22		lda $22		                lda tmp1
.9a9d		48		pha		                pha
.9a9e		60		rts		z_r_to_input: 	rts
.9a9f						xt_recurse:
.9a9f		a0 00		ldy #$00	                ldy #0
.9aa1		a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9aa3		91 00		sta ($00),y	                sta (cp),y
.9aa5		c8		iny		                iny
.9aa6		24 20		bit $20		                bit status
.9aa8		70 0c		bvs $9ab6	                bvs _nt_in_workword
.9aaa		a5 04		lda $04		                lda workword
.9aac		91 00		sta ($00),y	                sta (cp),y
.9aae		c8		iny		                iny
.9aaf		a5 05		lda $05		                lda workword+1
.9ab1		91 00		sta ($00),y	                sta (cp),y
.9ab3		c8		iny		                iny
.9ab4		80 1b		bra $9ad1	                bra _update_cp
.9ab6						_nt_in_workword:
.9ab6		a5 04		lda $04		                lda workword            ; LSB
.9ab8		18		clc		                clc
.9ab9		69 04		adc #$04	                adc #4
.9abb		85 22		sta $22		                sta tmp1
.9abd		a5 05		lda $05		                lda workword+1          ; MSB
.9abf		69 00		adc #$00	                adc #0
.9ac1		85 23		sta $23		                sta tmp1+1
.9ac3		b2 22		lda ($22)	                lda (tmp1)
.9ac5		91 00		sta ($00),y	                sta (cp),y
.9ac7		5a		phy		                phy
.9ac8		a0 01		ldy #$01	                ldy #1
.9aca		b1 22		lda ($22),y	                lda (tmp1),y
.9acc		7a		ply		                ply
.9acd		c8		iny		                iny
.9ace		91 00		sta ($00),y	                sta (cp),y
.9ad0		c8		iny		                iny
.9ad1						_update_cp:
.9ad1		98		tya		                tya
.9ad2		18		clc		                clc
.9ad3		65 00		adc $00		                adc cp
.9ad5		85 00		sta $00		                sta cp
.9ad7		90 02		bcc $9adb	                bcc _done
.9ad9		e6 01		inc $01		                inc cp+1
.9adb						_done:
.9adb		60		rts		z_recurse:      rts
.9adc						xt_refill:
.9adc		a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9ade		d0 2d		bne $9b0d	                bne _src_not_kbd
.9ae0		ca		dex		                dex
.9ae1		ca		dex		                dex
.9ae2		ca		dex		                dex
.9ae3		ca		dex		                dex
.9ae4		a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9ae6		95 02		sta $02,x	                sta 2,x
.9ae8		a5 09		lda $09		                lda cib+1
.9aea		95 03		sta $03,x	                sta 3,x
.9aec		64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9aee		64 0b		stz $0b		                stz ciblen+1
.9af0		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9af2		95 00		sta $00,x	                sta 0,x
.9af4		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9af6		20 e2 80	jsr $80e2	                jsr xt_accept           ; ( addr n1 -- n2)
.9af9		b5 00		lda $00,x	                lda 0,x
.9afb		85 0a		sta $0a		                sta ciblen
.9afd		b5 01		lda $01,x	                lda 1,x
.9aff		85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b01		64 0c		stz $0c		                stz toin
.9b03		64 0d		stz $0d		                stz toin+1
.9b05		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b07		95 00		sta $00,x	                sta 0,x
.9b09		95 01		sta $01,x	                sta 1,x
.9b0b		80 10		bra $9b1d	                bra _done
.9b0d						_src_not_kbd:
.9b0d		1a		inc a		                ina
.9b0e		d0 08		bne $9b18	                bne _src_not_string
.9b10		ca		dex		                dex
.9b11		ca		dex		                dex
.9b12		74 00		stz $00,x	                stz 0,x
.9b14		74 01		stz $01,x	                stz 1,x
.9b16		80 05		bra $9b1d	                bra z_refill
.9b18						_src_not_string:
.9b18		a9 01		lda #$01	                lda #err_badsource
.9b1a		4c 8b d8	jmp $d88b	                jmp error
.9b1d						_done:
.9b1d		60		rts		z_refill:       rts
.9b1e						xt_repeat:
.9b1e		20 1d 82	jsr $821d	                jsr xt_again
.9b21		4c 85 8d	jmp $8d85	                jmp xt_then
.9b24						z_repeat:
.9b24						xt_right_bracket:
.9b24		a9 ff		lda #$ff	                lda #$FF
.9b26		85 16		sta $16		                sta state
.9b28		85 17		sta $17		                sta state+1
.9b2a						z_right_bracket:
.9b2a		60		rts		                rts
.9b2b						xt_root_wordlist:
.9b2b		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b2c		ca		dex		                dex
.9b2d		a9 03		lda #$03	                lda #3
.9b2f		95 00		sta $00,x	                sta 0,x
.9b31		74 01		stz $01,x	                stz 1,x
.9b33						z_root_wordlist:
.9b33		60		rts		                rts
.9b34						xt_rot:
.9b34		20 7f d8	jsr $d87f	                jsr underflow_3
.9b37		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b39		b5 03		lda $03,x	                lda 3,x
.9b3b		95 05		sta $05,x	                sta 5,x
.9b3d		b5 01		lda $01,x	                lda 1,x
.9b3f		95 03		sta $03,x	                sta 3,x
.9b41		94 01		sty $01,x	                sty 1,x
.9b43		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b45		b5 02		lda $02,x	                lda 2,x
.9b47		95 04		sta $04,x	                sta 4,x
.9b49		b5 00		lda $00,x	                lda 0,x
.9b4b		95 02		sta $02,x	                sta 2,x
.9b4d		94 00		sty $00,x	                sty 0,x
.9b4f		60		rts		z_rot:          rts
.9b50						xt_rshift:
.9b50		20 7a d8	jsr $d87a	                jsr underflow_2
.9b53		b5 00		lda $00,x	                lda 0,x
.9b55		29 0f		and #$0f	                and #%00001111
.9b57		f0 08		beq $9b61	                beq _done               ; if 0 shifts, quit
.9b59		a8		tay		                tay
.9b5a						_loop:
.9b5a		56 03		lsr $03,x	                lsr 3,x
.9b5c		76 02		ror $02,x	                ror 2,x
.9b5e		88		dey		                dey
.9b5f		d0 f9		bne $9b5a	                bne _loop
.9b61						_done:
.9b61		e8		inx		                inx
.9b62		e8		inx		                inx
.9b63		60		rts		z_rshift:       rts
.9b64						xt_s_backslash_quote:
.9b64		a9 ff		lda #$ff	                lda #$FF
.9b66		85 24		sta $24		                sta tmp2
.9b68		64 25		stz $25		                stz tmp2+1
.9b6a		20 30 9d	jsr $9d30	                jsr s_quote_start
.9b6d						_done:
.9b6d						z_s_backslash_quote:
.9b6d		60		rts		                rts
.9b6e						convert_hex_value:
.9b6e		c9 41		cmp #$41	        cmp #'A'
.9b70		90 07		bcc $9b79	        bcc _digit
.9b72		29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b74		38		sec		        sec
.9b75		e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b77		80 03		bra $9b7c	        bra _done
.9b79						_digit:
.9b79		38		sec		        sec
.9b7a		e9 30		sbc #$30	        sbc #'0'
.9b7c						_done:
.9b7c		60		rts		        rts
.9b7d						xt_search_wordlist:
.9b7d		20 7f d8	jsr $d87f	                jsr underflow_3
.9b80		a5 1e		lda $1e		                lda up
.9b82		18		clc		                clc
.9b83		69 06		adc #$06	                adc #wordlists_offset
.9b85		85 24		sta $24		                sta tmp2
.9b87		a5 1f		lda $1f		                lda up+1
.9b89		69 00		adc #$00	                adc #0          ; Adding carry
.9b8b		85 25		sta $25		                sta tmp2+1
.9b8d		b5 00		lda $00,x	                lda 0,x
.9b8f		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9b90		65 24		adc $24		                adc tmp2
.9b92		85 24		sta $24		                sta tmp2
.9b94		90 02		bcc $9b98	                bcc +
.9b96		e6 25		inc $25		                inc tmp2+1      ; Propagate carry if needed.
.9b98						+
.9b98		e8		inx		                inx
.9b99		e8		inx		                inx
.9b9a		b5 00		lda $00,x	                lda 0,x
.9b9c		15 01		ora $01,x	                ora 1,x
.9b9e		d0 03		bne $9ba3	                bne _check_wordlist
.9ba0		4c 5b 9c	jmp $9c5b	                jmp _done
.9ba3						_check_wordlist:
.9ba3		a5 24		lda $24		                lda tmp2
.9ba5		05 25		ora $25		                ora tmp2+1
.9ba7		d0 03		bne $9bac	                bne _have_string
.9ba9		4c 5b 9c	jmp $9c5b	                jmp _done
.9bac						_have_string:
.9bac		b2 24		lda ($24)	                lda (tmp2)              ; nt of first word in Dictionary
.9bae		85 22		sta $22		                sta tmp1
.9bb0		e6 24		inc $24		                inc tmp2                ; Move to the upper byte
.9bb2		d0 02		bne $9bb6	                bne +
.9bb4		e6 25		inc $25		                inc tmp2+1
.9bb6						+
.9bb6		b2 24		lda ($24)	                lda (tmp2)
.9bb8		85 23		sta $23		                sta tmp1+1
.9bba		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9bbc		85 24		sta $24		                sta tmp2
.9bbe		b5 03		lda $03,x	                lda 3,x
.9bc0		85 25		sta $25		                sta tmp2+1
.9bc2						_loop:
.9bc2		b2 22		lda ($22)	                lda (tmp1)
.9bc4		d5 00		cmp $00,x	                cmp 0,x
.9bc6		d0 7b		bne $9c43	                bne _next_entry
.9bc8						_compare_string:
.9bc8		b2 24		lda ($24)	                lda (tmp2)      ; first character of mystery string
.9bca		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bcc		b0 07		bcs $9bd5	                bcs _compare_first
.9bce		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bd0		90 03		bcc $9bd5	                bcc _compare_first
.9bd2		18		clc		                clc
.9bd3		69 20		adc #$20	                adc #$20
.9bd5						_compare_first:
.9bd5		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9bd7		d1 22		cmp ($22),y	                cmp (tmp1),y    ; first character of current word
.9bd9		d0 68		bne $9c43	                bne _next_entry
.9bdb		b5 00		lda $00,x	                lda 0,x
.9bdd		3a		dec a		                dea
.9bde		f0 2c		beq $9c0c	                beq _success
.9be0		a5 22		lda $22		                lda tmp1
.9be2		48		pha		                pha             ; Preserve tmp1 on the return stack.
.9be3		18		clc		                clc
.9be4		69 08		adc #$08	                adc #8
.9be6		85 22		sta $22		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9be8		a5 23		lda $23		                lda tmp1+1
.9bea		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9beb		69 00		adc #$00	                adc #0          ; we only need the carry
.9bed		85 23		sta $23		                sta tmp1+1
.9bef		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9bf1		88		dey		                dey
.9bf2						_string_loop:
.9bf2		b1 24		lda ($24),y	                lda (tmp2),y    ; last char of mystery string
.9bf4		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9bf6		b0 07		bcs $9bff	                bcs _check_char
.9bf8		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bfa		90 03		bcc $9bff	                bcc _check_char
.9bfc		18		clc		                clc
.9bfd		69 20		adc #$20	                adc #$20
.9bff						_check_char:
.9bff		d1 22		cmp ($22),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c01		d0 3a		bne $9c3d	                bne _next_entry_tmp1
.9c03		88		dey		                dey
.9c04		d0 ec		bne $9bf2	                bne _string_loop
.9c06						_success_tmp1:
.9c06		68		pla		                pla             ; Restore tmp1 from the return stack.
.9c07		85 23		sta $23		                sta tmp1+1
.9c09		68		pla		                pla
.9c0a		85 22		sta $22		                sta tmp1
.9c0c						_success:
.9c0c		e8		inx		                inx
.9c0d		e8		inx		                inx
.9c0e		a5 22		lda $22		                lda tmp1
.9c10		95 00		sta $00,x	                sta 0,x
.9c12		a5 23		lda $23		                lda tmp1+1
.9c14		95 01		sta $01,x	                sta 1,x
.9c16		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9c19		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt xt )
.9c1c		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( xt nt )
.9c1f		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c21		f6 00		inc $00,x	                inc 0,x
.9c23		d0 02		bne $9c27	                bne +
.9c25		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c27						+
.9c27		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c29		29 04		and #$04	                and #IM
.9c2b		d0 08		bne $9c35	                bne _immediate          ; bit set, we're immediate
.9c2d		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c2f		95 00		sta $00,x	                sta 0,x
.9c31		95 01		sta $01,x	                sta 1,x
.9c33		80 28		bra $9c5d	                bra _done_nodrop
.9c35						_immediate:
.9c35		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c37		95 00		sta $00,x	                sta 0,x
.9c39		74 01		stz $01,x	                stz 1,x
.9c3b		80 20		bra $9c5d	                bra _done_nodrop
.9c3d						_next_entry_tmp1:
.9c3d		68		pla		                pla             ; Restore tmp1 from the return stack.
.9c3e		85 23		sta $23		                sta tmp1+1
.9c40		68		pla		                pla
.9c41		85 22		sta $22		                sta tmp1
.9c43						_next_entry:
.9c43		a0 02		ldy #$02	                ldy #2
.9c45		b1 22		lda ($22),y	                lda (tmp1),y
.9c47		48		pha		                pha
.9c48		c8		iny		                iny
.9c49		b1 22		lda ($22),y	                lda (tmp1),y
.9c4b		85 23		sta $23		                sta tmp1+1
.9c4d		68		pla		                pla
.9c4e		85 22		sta $22		                sta tmp1
.9c50		05 23		ora $23		                ora tmp1+1
.9c52		f0 03		beq $9c57	                beq _fail_done
.9c54		4c c2 9b	jmp $9bc2	                jmp _loop
.9c57						_fail_done:
.9c57		74 02		stz $02,x	                stz 2,x         ; failure flag
.9c59		74 03		stz $03,x	                stz 3,x
.9c5b						_done:
.9c5b		e8		inx		                inx
.9c5c		e8		inx		                inx
.9c5d						_done_nodrop:
.9c5d						z_search_wordlist:
.9c5d		60		rts		                rts
.9c5e						xt_see:
.9c5e		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( addr u )
.9c61		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( nt | 0 )
.9c64		b5 00		lda $00,x	                lda 0,x
.9c66		15 01		ora $01,x	                ora 1,x
.9c68		d0 05		bne $9c6f	                bne +
.9c6a		a9 05		lda #$05	                lda #err_noname
.9c6c		4c 8b d8	jmp $d88b	                jmp error
.9c6f						+
.9c6f		20 2a 89	jsr $892a	                jsr xt_cr
.9c72		a5 18		lda $18		                lda base
.9c74		48		pha		                pha
.9c75		20 62 91	jsr $9162	                jsr xt_hex
.9c78		a9 09		lda #$09	                lda #str_see_nt
.9c7a		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.9c7d		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9c80		20 d2 a4	jsr $a4d2	                jsr xt_u_dot
.9c83		20 cc a0	jsr $a0cc	                jsr xt_space            ; ( nt )
.9c86		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9c89		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt xt )
.9c8c		a9 0a		lda #$0a	                lda #str_see_xt
.9c8e		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.9c91		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt xt xt )
.9c94		20 d2 a4	jsr $a4d2	                jsr xt_u_dot
.9c97		20 2a 89	jsr $892a	                jsr xt_cr               ; ( nt xt )
.9c9a		a9 08		lda #$08	                lda #str_see_flags
.9c9c		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.9c9f		20 77 98	jsr $9877	                jsr xt_over             ; ( nt xt nt )
.9ca2		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9ca5		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( nt xt flags )
.9ca8		b5 00		lda $00,x	                lda 0,x
.9caa		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cac						_flag_loop:
.9cac		48		pha		                pha
.9cad		29 01		and #$01	                and #%00000001
.9caf		18		clc		                clc
.9cb0		69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cb2		20 db 8d	jsr $8ddb	                jsr emit_a
.9cb5		20 cc a0	jsr $a0cc	                jsr xt_space
.9cb8		68		pla		                pla
.9cb9		6a		ror a		                ror                     ; Next flag
.9cba		88		dey		                dey
.9cbb		d0 ef		bne $9cac	                bne _flag_loop
.9cbd		20 2a 89	jsr $892a	                jsr xt_cr
.9cc0		e8		inx		                inx
.9cc1		e8		inx		                inx                     ; ( nt xt )
.9cc2		a9 0b		lda #$0b	                lda #str_see_size
.9cc4		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.9cc7		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( xt nt )
.9cca		20 23 a7	jsr $a723	                jsr xt_wordsize         ; ( xt u )
.9ccd		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cd0		20 6c 8a	jsr $8a6c	                jsr xt_decimal
.9cd3		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; ( xt u )
.9cd6		20 62 91	jsr $9162	                jsr xt_hex
.9cd9		20 2a 89	jsr $892a	                jsr xt_cr
.9cdc		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( xt u xt u )
.9cdf		20 e7 8c	jsr $8ce7	                jsr xt_dump
.9ce2		20 2a 89	jsr $892a	                jsr xt_cr
.9ce5		20 01 8b	jsr $8b01	                jsr xt_disasm
.9ce8		68		pla		                pla
.9ce9		85 18		sta $18		                sta base
.9ceb		60		rts		z_see:          rts
.9cec						xt_set_current:
.9cec		20 75 d8	jsr $d875	                jsr underflow_1
.9cef		a0 04		ldy #$04	                ldy #current_offset
.9cf1		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9cf3		91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9cf5		e8		inx		                inx
.9cf6		e8		inx		                inx
.9cf7		60		rts		z_set_current:  rts
.9cf8						xt_set_order:
.9cf8		a9 ff		lda #$ff	                lda #$FF
.9cfa		d5 01		cmp $01,x	                cmp 1,x
.9cfc		d0 12		bne $9d10	                bne _start
.9cfe		d5 00		cmp $00,x	                cmp 0,x
.9d00		d0 0e		bne $9d10	                bne _start
.9d02		ca		dex		                dex             ; Make room for the count.
.9d03		ca		dex		                dex
.9d04		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d06		a9 03		lda #$03	                lda #3
.9d08		95 02		sta $02,x	                sta 2,x
.9d0a		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d0c		a9 01		lda #$01	                lda #1
.9d0e		95 00		sta $00,x	                sta 0,x
.9d10						_start:
.9d10		a0 1e		ldy #$1e	                ldy #num_order_offset
.9d12		b5 00		lda $00,x	                lda 0,x
.9d14		91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d16		85 22		sta $22		                sta tmp1        ; Save a copy for zero check and looping.
.9d18		e8		inx		                inx             ; Drop the count off the data stack.
.9d19		e8		inx		                inx
.9d1a		a5 22		lda $22		                lda tmp1
.9d1c		f0 0d		beq $9d2b	                beq _done       ; If zero, there are no wordlists.
.9d1e		a0 1f		ldy #$1f	                ldy #search_order_offset
.9d20						_loop:
.9d20		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d22		91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d24		c8		iny		                iny
.9d25		e8		inx		                inx
.9d26		e8		inx		                inx
.9d27		c6 22		dec $22		                dec tmp1
.9d29		d0 f5		bne $9d20	                bne _loop
.9d2b						_done:
.9d2b		60		rts		z_set_order:    rts
.9d2c						xt_s_quote:
.9d2c		64 24		stz $24		                stz tmp2
.9d2e		64 25		stz $25		                stz tmp2+1
.9d30						s_quote_start:
.9d30		ca		dex		                dex
.9d31		ca		dex		                dex
.9d32		ca		dex		                dex
.9d33		ca		dex		                dex
.9d34		a9 4c		lda #$4c	                lda #$4C
.9d36		20 2d d7	jsr $d72d	                jsr cmpl_a
.9d39		20 2d d7	jsr $d72d	                jsr cmpl_a
.9d3c		20 2d d7	jsr $d72d	                jsr cmpl_a
.9d3f		a5 00		lda $00		                lda cp
.9d41		95 02		sta $02,x	                sta 2,x
.9d43		a5 01		lda $01		                lda cp+1
.9d45		95 03		sta $03,x	                sta 3,x
.9d47						_savechars_loop:
.9d47		a5 0d		lda $0d		                lda toin+1              ; MSB
.9d49		c5 0b		cmp $0b		                cmp ciblen+1
.9d4b		90 2a		bcc $9d77	                bcc _input_fine         ; unsigned comparison
.9d4d		a5 0c		lda $0c		                lda toin                ; LSB
.9d4f		c5 0a		cmp $0a		                cmp ciblen
.9d51		90 24		bcc $9d77	                bcc _input_fine
.9d53		a5 24		lda $24		                lda tmp2
.9d55		48		pha		                pha
.9d56		a5 25		lda $25		                lda tmp2+1
.9d58		48		pha		                pha
.9d59		a5 26		lda $26		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d5b		48		pha		                pha
.9d5c		20 dc 9a	jsr $9adc	                jsr xt_refill           ; ( -- f )
.9d5f		68		pla		                pla
.9d60		85 26		sta $26		                sta tmp3
.9d62		68		pla		                pla
.9d63		85 25		sta $25		                sta tmp2+1
.9d65		68		pla		                pla
.9d66		85 24		sta $24		                sta tmp2
.9d68		b5 00		lda $00,x	                lda 0,x
.9d6a		15 01		ora $01,x	                ora 1,x
.9d6c		d0 05		bne $9d73	                bne _refill_ok
.9d6e		a9 06		lda #$06	                lda #err_refill
.9d70		4c 8b d8	jmp $d88b	                jmp error
.9d73						_refill_ok:
.9d73		e8		inx		                inx
.9d74		e8		inx		                inx
.9d75		80 d0		bra $9d47	                bra _savechars_loop
.9d77						_input_fine:
.9d77		a5 08		lda $08		                lda cib
.9d79		18		clc		                clc
.9d7a		65 0c		adc $0c		                adc toin        ; LSB
.9d7c		85 22		sta $22		                sta tmp1
.9d7e		a5 09		lda $09		                lda cib+1
.9d80		65 0d		adc $0d		                adc toin+1      ; MSB
.9d82		85 23		sta $23		                sta tmp1+1
.9d84		b2 22		lda ($22)	                lda (tmp1)
.9d86		24 24		bit $24		                bit tmp2
.9d88		30 03		bmi $9d8d	                bmi _handle_escapes    ; Only checking bit 7
.9d8a		4c 16 9e	jmp $9e16	                jmp _regular_char
.9d8d						_handle_escapes:
.9d8d		24 25		bit $25		                bit tmp2+1
.9d8f		30 03		bmi $9d94	                bmi _escaped
.9d91		4c 0c 9e	jmp $9e0c	                jmp _not_escaped
.9d94						_escaped:
.9d94		70 3c		bvs $9dd2	                bvs _check_esc_chars
.9d96		a9 01		lda #$01	                lda #1
.9d98		24 25		bit $25		                bit tmp2+1
.9d9a		d0 10		bne $9dac	                bne _esc_x_second_digit
.9d9c		e6 25		inc $25		                inc tmp2+1  ; Adjust flag for second digit next time.
.9d9e		b2 22		lda ($22)	                lda (tmp1)  ; Get the char again.
.9da0		20 6e 9b	jsr $9b6e	                jsr convert_hex_value
.9da3		0a		asl a		                asl
.9da4		0a		asl a		                asl
.9da5		0a		asl a		                asl
.9da6		0a		asl a		                asl
.9da7		85 26		sta $26		                sta tmp3    ; Save it for later.
.9da9		4c 1d 9e	jmp $9e1d	                jmp _next_character
.9dac						_esc_x_second_digit:
.9dac		64 25		stz $25		                stz tmp2+1
.9dae		b2 22		lda ($22)	                lda (tmp1)
.9db0		20 6e 9b	jsr $9b6e	                jsr convert_hex_value
.9db3		05 26		ora $26		                ora tmp3
.9db5		4c 1a 9e	jmp $9e1a	                jmp _save_character
.9db8						_esc_tr_table:
>9db8		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9db9		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9dba		00 00				    .byte   0,0             ; c, d no escape
>9dbc		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9dbd		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9dbe		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9dc3		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9dc4		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9dc5		0a				    .byte   10              ; n behaves like l --> lf
>9dc6		00 00				    .byte   0,0             ; o,p
>9dc8		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9dc9		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9dca		00				    .byte   0               ; s
>9dcb		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9dcc		00				    .byte   0               ; u
>9dcd		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9dce		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9dd1		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9dd2						_check_esc_chars:
.9dd2		64 25		stz $25		                stz tmp2+1
.9dd4		c9 61		cmp #$61	                cmp #'a'
.9dd6		30 1a		bmi $9df2	                bmi _check_esc_quote
.9dd8		c9 7b		cmp #$7b	                cmp #'z'+1
.9dda		10 16		bpl $9df2	                bpl _check_esc_quote
.9ddc		a8		tay		                tay
.9ddd		b9 57 9d	lda $9d57,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9de0		d0 03		bne $9de5	                bne _esc_replace
.9de2		98		tya		                tya                     ; revert if no translation
.9de3		80 0d		bra $9df2	                bra _check_esc_quote
.9de5		10 33		bpl $9e1a	_esc_replace:   bpl _save_character     ; simple replacement
.9de7		29 7f		and #$7f	                and #$7f                ; clear hi bit
.9de9		f0 2f		beq $9e1a	                beq _save_character     ; NUL we can just output
.9deb		20 2d d7	jsr $d72d	                jsr cmpl_a              ; else output first char (CR)
.9dee		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9df0		80 28		bra $9e1a	                bra _save_character
.9df2						_check_esc_quote:
.9df2		c9 22		cmp #$22	                cmp #$22
.9df4		d0 04		bne $9dfa	                bne _check_esc_x
.9df6		a9 22		lda #$22	                lda #34
.9df8		80 20		bra $9e1a	                bra _save_character
.9dfa						_check_esc_x:
.9dfa		c9 78		cmp #$78	                cmp #'x'
.9dfc		d0 06		bne $9e04	                bne _check_esc_backslash
.9dfe		a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e00		85 25		sta $25		                sta tmp2+1
.9e02		80 19		bra $9e1d	                bra _next_character
.9e04						_check_esc_backslash:
.9e04		c9 5c		cmp #$5c	                cmp #$5C
.9e06		d0 04		bne $9e0c	                bne _not_escaped
.9e08		a9 5c		lda #$5c	                lda #92
.9e0a		80 0e		bra $9e1a	                bra _save_character
.9e0c						_not_escaped:
.9e0c		c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e0e		d0 06		bne $9e16	                bne _regular_char
.9e10		a9 ff		lda #$ff	                lda #$FF
.9e12		85 25		sta $25		                sta tmp2+1
.9e14		80 07		bra $9e1d	                bra _next_character
.9e16						_regular_char:
.9e16		c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e18		f0 0c		beq $9e26	                beq _found_string_end
.9e1a						_save_character:
.9e1a		20 2d d7	jsr $d72d	                jsr cmpl_a
.9e1d						_next_character:
.9e1d		e6 0c		inc $0c		                inc toin
.9e1f		d0 02		bne $9e23	                bne _savechars_loop_longjump
.9e21		e6 0d		inc $0d		                inc toin+1
.9e23						_savechars_loop_longjump:
.9e23		4c 47 9d	jmp $9d47	                jmp _savechars_loop
.9e26						_found_string_end:
.9e26		e6 0c		inc $0c		                inc toin
.9e28		d0 02		bne $9e2c	                bne +
.9e2a		e6 0d		inc $0d		                inc toin+1
.9e2c						+
.9e2c		a5 00		lda $00		                lda cp
.9e2e		38		sec		                sec
.9e2f		f5 02		sbc $02,x	                sbc 2,x
.9e31		95 00		sta $00,x	                sta 0,x         ; LSB
.9e33		a5 01		lda $01		                lda cp+1
.9e35		f5 03		sbc $03,x	                sbc 3,x
.9e37		95 01		sta $01,x	                sta 1,x         ; MSB
.9e39		b5 02		lda $02,x	                lda 2,x
.9e3b		38		sec		                sec
.9e3c		e9 02		sbc #$02	                sbc #2
.9e3e		85 22		sta $22		                sta tmp1
.9e40		b5 03		lda $03,x	                lda 3,x
.9e42		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e44		85 23		sta $23		                sta tmp1+1
.9e46		a5 00		lda $00		                lda cp
.9e48		92 22		sta ($22)	                sta (tmp1)
.9e4a		a0 01		ldy #$01	                ldy #1
.9e4c		a5 01		lda $01		                lda cp+1
.9e4e		91 22		sta ($22),y	                sta (tmp1),y
.9e50		a5 16		lda $16		                lda state
.9e52		05 17		ora $17		                ora state+1             ; paranoid
.9e54		f0 03		beq $9e59	                beq _done
.9e56		20 3d a0	jsr $a03d	                jsr sliteral_const_str         ; ( addr u -- )
.9e59						_done:
.9e59		60		rts		z_s_quote:      rts
.9e5a						xt_s_to_d:
.9e5a		20 75 d8	jsr $d875	                jsr underflow_1
.9e5d		ca		dex		                dex
.9e5e		ca		dex		                dex
.9e5f		74 00		stz $00,x	                stz 0,x
.9e61		74 01		stz $01,x	                stz 1,x
.9e63		b5 03		lda $03,x	                lda 3,x
.9e65		10 04		bpl $9e6b	                bpl _done
.9e67		d6 00		dec $00,x	                dec 0,x
.9e69		d6 01		dec $01,x	                dec 1,x
.9e6b						_done:
.9e6b		60		rts		z_s_to_d:       rts
.9e6c						xt_save_buffers:
.9e6c		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e6e		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9e70		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9e72		d0 12		bne $9e86	                bne _done       ; Either not used or not dirty = done!
.9e74		20 69 83	jsr $8369	                jsr xt_blkbuffer
.9e77		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.9e7a		20 65 8f	jsr $8f65	                jsr xt_fetch
.9e7d		20 16 85	jsr $8516	                jsr xt_block_write
.9e80		a9 01		lda #$01	                lda #1
.9e82		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e84		91 1e		sta ($1e),y	                sta (up),y
.9e86						_done:
.9e86		60		rts		z_save_buffers: rts
.9e87						xt_scr:
.9e87		ca		dex		                dex
.9e88		ca		dex		                dex
.9e89		18		clc		                clc
.9e8a		a5 1e		lda $1e		                lda up
.9e8c		69 02		adc #$02	                adc #scr_offset ; Add offset
.9e8e		95 00		sta $00,x	                sta 0,x
.9e90		a5 1f		lda $1f		                lda up+1
.9e92		69 00		adc #$00	                adc #0          ; Adding carry
.9e94		95 01		sta $01,x	                sta 1,x
.9e96		60		rts		z_scr:          rts
.9e97						xt_search:
.9e97		20 84 d8	jsr $d884	                jsr underflow_4
.9e9a		b5 00		lda $00,x	                lda 0,x
.9e9c		15 01		ora $01,x	                ora 1,x
.9e9e		d0 0b		bne $9eab	                bne _start_search
.9ea0		e8		inx		                inx             ; Remove u2
.9ea1		e8		inx		                inx
.9ea2		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ea4		95 00		sta $00,x	                sta 0,x
.9ea6		95 01		sta $01,x	                sta 1,x
.9ea8		4c 35 9f	jmp $9f35	                jmp z_search
.9eab						_start_search:
.9eab		20 56 a7	jsr $a756	                jsr xt_zero
.9eae						_search_loop:
.9eae		18		clc		                clc
.9eaf		b5 00		lda $00,x	                lda 0,x
.9eb1		75 02		adc $02,x	                adc 2,x
.9eb3		85 22		sta $22		                sta tmp1
.9eb5		b5 01		lda $01,x	                lda 1,x
.9eb7		75 03		adc $03,x	                adc 3,x
.9eb9		d5 07		cmp $07,x	                cmp 7,x
.9ebb		90 12		bcc $9ecf	                bcc _init_comparison ; Obviously less
.9ebd		d0 06		bne $9ec5	                bne _not_found
.9ebf		b5 06		lda $06,x	                lda 6,x
.9ec1		c5 22		cmp $22		                cmp tmp1
.9ec3		b0 0a		bcs $9ecf	                bcs _init_comparison
.9ec5						_not_found:
.9ec5		e8		inx		                inx             ; Remove offset
.9ec6		e8		inx		                inx
.9ec7		e8		inx		                inx             ; Remove u2
.9ec8		e8		inx		                inx
.9ec9		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9ecb		74 01		stz $01,x	                stz 1,x
.9ecd		80 66		bra $9f35	                bra z_search
.9ecf						_init_comparison:
.9ecf		18		clc		                clc
.9ed0		b5 08		lda $08,x	                lda 8,x
.9ed2		75 00		adc $00,x	                adc 0,x
.9ed4		85 22		sta $22		                sta tmp1
.9ed6		b5 09		lda $09,x	                lda 9,x
.9ed8		75 01		adc $01,x	                adc 1,x
.9eda		85 23		sta $23		                sta tmp1+1
.9edc		b5 04		lda $04,x	                lda 4,x
.9ede		85 24		sta $24		                sta tmp2
.9ee0		b5 05		lda $05,x	                lda 5,x
.9ee2		85 25		sta $25		                sta tmp2+1
.9ee4		b5 02		lda $02,x	                lda 2,x
.9ee6		85 26		sta $26		                sta tmp3
.9ee8		b5 03		lda $03,x	                lda 3,x
.9eea		85 27		sta $27		                sta tmp3+1
.9eec						_comparison_loop:
.9eec		b2 22		lda ($22)	                lda (tmp1)
.9eee		d2 24		cmp ($24)	                cmp (tmp2)
.9ef0		f0 05		beq $9ef7	                beq _letters_match
.9ef2		20 01 98	jsr $9801	                jsr xt_one_plus
.9ef5		80 b7		bra $9eae	                bra _search_loop
.9ef7						_letters_match:
.9ef7		e6 22		inc $22		                inc tmp1
.9ef9		d0 02		bne $9efd	                bne +
.9efb		e6 23		inc $23		                inc tmp1+1
.9efd						+
.9efd		e6 24		inc $24		                inc tmp2
.9eff		d0 02		bne $9f03	                bne +
.9f01		e6 25		inc $25		                inc tmp2+1
.9f03						+
.9f03		a5 26		lda $26		                lda tmp3
.9f05		d0 02		bne $9f09	                bne +
.9f07		c6 27		dec $27		                dec tmp3+1
.9f09						+
.9f09		c6 26		dec $26		                dec tmp3
.9f0b		a5 26		lda $26		                lda tmp3
.9f0d		05 27		ora $27		                ora tmp3+1
.9f0f		d0 db		bne $9eec	                bne _comparison_loop ; Check the next letter
.9f11		18		clc		                clc
.9f12		b5 00		lda $00,x	                lda 0,x
.9f14		75 08		adc $08,x	                adc 8,x
.9f16		95 08		sta $08,x	                sta 8,x
.9f18		b5 01		lda $01,x	                lda 1,x
.9f1a		75 09		adc $09,x	                adc 9,x
.9f1c		95 09		sta $09,x	                sta 9,x
.9f1e		38		sec		                sec
.9f1f		b5 06		lda $06,x	                lda 6,x
.9f21		f5 00		sbc $00,x	                sbc 0,x
.9f23		95 06		sta $06,x	                sta 6,x
.9f25		b5 07		lda $07,x	                lda 7,x
.9f27		f5 01		sbc $01,x	                sbc 1,x
.9f29		95 07		sta $07,x	                sta 7,x
.9f2b		e8		inx		                inx             ; drop offset
.9f2c		e8		inx		                inx
.9f2d		e8		inx		                inx             ; drop u2
.9f2e		e8		inx		                inx
.9f2f		a9 ff		lda #$ff	                lda #$FF
.9f31		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f33		95 01		sta $01,x	                sta 1,x
.9f35		60		rts		z_search:       rts
.9f36						xt_semicolon:
.9f36		24 20		bit $20		                bit status
.9f38		70 11		bvs $9f4b	                bvs _colonword
.9f3a		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f3c		20 2d d7	jsr $d72d	                jsr cmpl_a
.9f3f		ca		dex		                dex
.9f40		ca		dex		                dex
.9f41		a5 04		lda $04		                lda workword
.9f43		95 00		sta $00,x	                sta 0,x
.9f45		a5 05		lda $05		                lda workword+1
.9f47		95 01		sta $01,x	                sta 1,x
.9f49		80 45		bra $9f90	                bra _semicolon_done
.9f4b						_colonword:
.9f4b		a0 06		ldy #$06	                ldy #6
.9f4d		a5 00		lda $00		                lda cp
.9f4f		91 04		sta ($04),y	                sta (workword),y
.9f51		c8		iny		                iny
.9f52		a5 01		lda $01		                lda cp+1
.9f54		91 04		sta ($04),y	                sta (workword),y
.9f56		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f58		20 2d d7	jsr $d72d	                jsr cmpl_a
.9f5b		24 20		bit $20		                bit status
.9f5d		10 26		bpl $9f85	                bpl _new_word   ; Bit 7 is clear = new word
.9f5f		ca		dex		                dex
.9f60		ca		dex		                dex
.9f61		ca		dex		                dex
.9f62		ca		dex		                dex
.9f63		b2 04		lda ($04)	                lda (workword)
.9f65		95 00		sta $00,x	                sta 0,x
.9f67		74 01		stz $01,x	                stz 1,x
.9f69		a5 04		lda $04		                lda workword
.9f6b		18		clc		                clc
.9f6c		69 08		adc #$08	                adc #8
.9f6e		95 02		sta $02,x	                sta 2,x
.9f70		a5 05		lda $05		                lda workword+1
.9f72		69 00		adc #$00	                adc #0                  ; only want carry
.9f74		95 03		sta $03,x	                sta 3,x
.9f76		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9f78		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.9f7b		20 a7 a4	jsr $a4a7	                jsr xt_type
.9f7e		20 cc a0	jsr $a0cc	                jsr xt_space
.9f81		a9 80		lda #$80	                lda #%10000000
.9f83		14 20		trb $20		                trb status
.9f85						_new_word:
.9f85		a5 04		lda $04		                lda workword
.9f87		85 02		sta $02		                sta dp
.9f89		a5 05		lda $05		                lda workword+1
.9f8b		85 03		sta $03		                sta dp+1
.9f8d		20 cf d7	jsr $d7cf	                jsr dp_to_current       ; Save the updated DP to the
.9f90						_semicolon_done:
.9f90		64 16		stz $16		                stz state
.9f92		64 17		stz $17		                stz state+1
.9f94		60		rts		z_semicolon:    rts
.9f95						xt_sign:
.9f95		20 75 d8	jsr $d875	                jsr underflow_1
.9f98		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9f9a		30 04		bmi $9fa0	                bmi _minus
.9f9c		e8		inx		                inx
.9f9d		e8		inx		                inx
.9f9e		80 09		bra $9fa9	                bra _done
.9fa0						_minus:
.9fa0		a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9fa2		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9fa4		74 01		stz $01,x	                stz 1,x         ; paranoid
.9fa6		20 bc 91	jsr $91bc	                jsr xt_hold
.9fa9						_done:
.9fa9		60		rts		z_sign:         rts
.9faa						xt_slash:
.9faa		a9 00		lda #$00	                lda #0
.9fac		48		pha		                pha
.9fad		80 03		bra $9fb2	                bra slashmod_common
.9faf						xt_slash_mod:
.9faf		a9 ff		lda #$ff	                lda #$FF
.9fb1		48		pha		                pha             ; falls through to _common
.9fb2						slashmod_common:
.9fb2		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R
.9fb5		20 5a 9e	jsr $9e5a	                jsr xt_s_to_d           ; S>D
.9fb8		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R>
.9fbb		20 83 a0	jsr $a083	                jsr xt_sm_slash_rem     ; SM/REM
.9fbe		68		pla		                pla
.9fbf		d0 05		bne $9fc6	                bne _done
.9fc1		20 5c a1	jsr $a15c	                jsr xt_swap
.9fc4		e8		inx		                inx             ; DROP
.9fc5		e8		inx		                inx
.9fc6						_done:
.9fc6						z_slash_mod:
.9fc6		60		rts		z_slash:        rts
.9fc7						xt_slash_string:
.9fc7		20 7f d8	jsr $d87f	                jsr underflow_3
.9fca		18		clc		                clc             ; 3OS+TOS
.9fcb		b5 00		lda $00,x	                lda 0,x
.9fcd		75 04		adc $04,x	                adc 4,x
.9fcf		95 04		sta $04,x	                sta 4,x
.9fd1		b5 01		lda $01,x	                lda 1,x
.9fd3		75 05		adc $05,x	                adc 5,x
.9fd5		95 05		sta $05,x	                sta 5,x
.9fd7		38		sec		                sec             ; NOS-TOS
.9fd8		b5 02		lda $02,x	                lda 2,x
.9fda		f5 00		sbc $00,x	                sbc 0,x
.9fdc		95 02		sta $02,x	                sta 2,x
.9fde		b5 03		lda $03,x	                lda 3,x
.9fe0		f5 01		sbc $01,x	                sbc 1,x
.9fe2		95 03		sta $03,x	                sta 3,x
.9fe4		e8		inx		                inx
.9fe5		e8		inx		                inx
.9fe6		60		rts		z_slash_string: rts
.9fe7						xt_sliteral:
.9fe7		20 7a d8	jsr $d87a	                jsr underflow_2
.9fea		a9 4c		lda #$4c	                lda #$4C
.9fec		20 2d d7	jsr $d72d	                jsr cmpl_a
.9fef		20 2d d7	jsr $d72d	                jsr cmpl_a
.9ff2		20 2d d7	jsr $d72d	                jsr cmpl_a
.9ff5		8a		txa		                txa
.9ff6		38		sec		                sec
.9ff7		e9 06		sbc #$06	                sbc #6
.9ff9		aa		tax		                tax
.9ffa		b5 08		lda $08,x	                lda 8,x
.9ffc		95 04		sta $04,x	                sta 4,x
.9ffe		b5 09		lda $09,x	                lda 9,x
.a000		95 05		sta $05,x	                sta 5,x
.a002		b5 06		lda $06,x	                lda 6,x
.a004		95 00		sta $00,x	                sta 0,x
.a006		b5 07		lda $07,x	                lda 7,x
.a008		95 01		sta $01,x	                sta 1,x
.a00a		a5 00		lda $00		                lda cp
.a00c		95 08		sta $08,x	                sta 8,x
.a00e		95 02		sta $02,x	                sta 2,x
.a010		a5 01		lda $01		                lda cp+1
.a012		95 09		sta $09,x	                sta 9,x
.a014		95 03		sta $03,x	                sta 3,x
.a016		20 a6 95	jsr $95a6	                jsr xt_move
.a019		18		clc		                clc
.a01a		a5 00		lda $00		                lda cp
.a01c		75 00		adc $00,x	                adc 0,x
.a01e		85 00		sta $00		                sta cp
.a020		a5 01		lda $01		                lda cp+1
.a022		75 01		adc $01,x	                adc 1,x
.a024		85 01		sta $01		                sta cp+1
.a026		b5 02		lda $02,x	                lda 2,x
.a028		38		sec		                sec
.a029		e9 02		sbc #$02	                sbc #2
.a02b		85 22		sta $22		                sta tmp1
.a02d		b5 03		lda $03,x	                lda 3,x
.a02f		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a031		85 23		sta $23		                sta tmp1+1
.a033		a5 00		lda $00		                lda cp
.a035		92 22		sta ($22)	                sta (tmp1)
.a037		a0 01		ldy #$01	                ldy #1
.a039		a5 01		lda $01		                lda cp+1
.a03b		91 22		sta ($22),y	                sta (tmp1),y
.a03d						sliteral_const_str:
.a03d		a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a03f		a9 57		lda #$57	                lda #<sliteral_runtime
.a041		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.a044		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a046		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a048		20 29 d7	jsr $d729	                jsr cmpl_word
.a04b		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a04d		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a04f		20 29 d7	jsr $d729	                jsr cmpl_word
.a052		e8		inx		                inx
.a053		e8		inx		                inx
.a054		e8		inx		                inx
.a055		e8		inx		                inx
.a056		60		rts		z_sliteral:     rts
.a057						sliteral_runtime:
.a057		ca		dex		                dex
.a058		ca		dex		                dex
.a059		ca		dex		                dex
.a05a		ca		dex		                dex
.a05b		68		pla		                pla
.a05c		85 22		sta $22		                sta tmp1        ; LSB of address
.a05e		68		pla		                pla
.a05f		85 23		sta $23		                sta tmp1+1      ; MSB of address
.a061		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a063		b1 22		lda ($22),y	                lda (tmp1),y
.a065		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a067		c8		iny		                iny
.a068		b1 22		lda ($22),y	                lda (tmp1),y
.a06a		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a06c		c8		iny		                iny
.a06d		b1 22		lda ($22),y	                lda (tmp1),y
.a06f		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a071		c8		iny		                iny
.a072		b1 22		lda ($22),y	                lda (tmp1),y
.a074		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a076		18		clc		                clc
.a077		a5 22		lda $22		                lda tmp1
.a079		69 04		adc #$04	                adc #4
.a07b		a8		tay		                tay             ; LSB
.a07c		a5 23		lda $23		                lda tmp1+1
.a07e		69 00		adc #$00	                adc #0          ; we only need carry
.a080		48		pha		                pha             ; MSB
.a081		5a		phy		                phy
.a082		60		rts		                rts
.a083						xt_sm_slash_rem:
.a083		20 7f d8	jsr $d87f	                jsr underflow_3 ; contains double number
.a086		b5 03		lda $03,x	                lda 3,x
.a088		48		pha		                pha
.a089		b5 01		lda $01,x	                lda 1,x
.a08b		55 03		eor $03,x	                eor 3,x
.a08d		48		pha		                pha
.a08e		20 cd 80	jsr $80cd	                jsr xt_abs
.a091		e8		inx		                inx             ; pretend we pushed n1 to R
.a092		e8		inx		                inx
.a093		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.a096		ca		dex		                dex
.a097		ca		dex		                dex
.a098		20 5e a5	jsr $a55e	                jsr xt_um_slash_mod     ; UM/MOD
.a09b		68		pla		                pla
.a09c		10 03		bpl $a0a1	                bpl +
.a09e		20 07 96	jsr $9607	                jsr xt_negate
.a0a1						+
.a0a1		68		pla		                pla
.a0a2		10 07		bpl $a0ab	                bpl _done
.a0a4		e8		inx		                inx             ; pretend we pushed quotient to R
.a0a5		e8		inx		                inx
.a0a6		20 07 96	jsr $9607	                jsr xt_negate
.a0a9		ca		dex		                dex
.a0aa		ca		dex		                dex
.a0ab						_done:
.a0ab		60		rts		z_sm_slash_rem: rts
.a0ac						xt_source:
.a0ac		ca		dex		                dex
.a0ad		ca		dex		                dex
.a0ae		a5 08		lda $08		                lda cib
.a0b0		95 00		sta $00,x	                sta 0,x
.a0b2		a5 09		lda $09		                lda cib+1
.a0b4		95 01		sta $01,x	                sta 1,x
.a0b6		ca		dex		                dex
.a0b7		ca		dex		                dex
.a0b8		a5 0a		lda $0a		                lda ciblen
.a0ba		95 00		sta $00,x	                sta 0,x
.a0bc		a5 0b		lda $0b		                lda ciblen+1
.a0be		95 01		sta $01,x	                sta 1,x
.a0c0		60		rts		z_source:       rts
.a0c1						xt_source_id:
.a0c1		ca		dex		                dex
.a0c2		ca		dex		                dex
.a0c3		a5 06		lda $06		                lda insrc
.a0c5		95 00		sta $00,x	                sta 0,x
.a0c7		a5 07		lda $07		                lda insrc+1
.a0c9		95 01		sta $01,x	                sta 1,x
.a0cb		60		rts		z_source_id:    rts
.a0cc						xt_space:
.a0cc		a9 20		lda #$20	                lda #AscSP
.a0ce		20 db 8d	jsr $8ddb	                jsr emit_a
.a0d1		60		rts		z_space:        rts
.a0d2						xt_spaces:
.a0d2		20 75 d8	jsr $d875	                jsr underflow_1
.a0d5		20 56 a7	jsr $a756	                jsr xt_zero
.a0d8		20 fc 94	jsr $94fc	                jsr xt_max
.a0db		b5 00		lda $00,x	                lda 0,x
.a0dd		15 01		ora $01,x	                ora 1,x
.a0df		f0 2a		beq $a10b	                beq _done
.a0e1		b4 01		ldy $01,x	                ldy 1,x
.a0e3		d0 0c		bne $a0f1	                bne _lots_of_spaces
.a0e5		b4 00		ldy $00,x	                ldy 0,x
.a0e7						_quick_loop:
.a0e7		a9 20		lda #$20	                lda #AscSP
.a0e9		20 db 8d	jsr $8ddb	                jsr emit_a
.a0ec		88		dey		                dey
.a0ed		f0 1c		beq $a10b	                beq _done
.a0ef		80 f6		bra $a0e7	                bra _quick_loop
.a0f1						_lots_of_spaces:
.a0f1		b4 00		ldy $00,x	                ldy 0,x
.a0f3						_first_slow_loop:
.a0f3		f0 08		beq $a0fd	                beq _slow_outer_loop
.a0f5		a9 20		lda #$20	                lda #AscSP
.a0f7		20 db 8d	jsr $8ddb	                jsr emit_a
.a0fa		88		dey		                dey
.a0fb		80 f6		bra $a0f3	                bra _first_slow_loop
.a0fd						_slow_outer_loop:
.a0fd		a0 00		ldy #$00	                ldy #00
.a0ff						_slow_inner_loop:
.a0ff		a9 20		lda #$20	                lda #AscSP
.a101		20 db 8d	jsr $8ddb	                jsr emit_a
.a104		88		dey		                dey
.a105		d0 f8		bne $a0ff	                bne _slow_inner_loop
.a107		d6 01		dec $01,x	                dec 1,x
.a109		d0 f2		bne $a0fd	                bne _slow_outer_loop
.a10b						_done:
.a10b		e8		inx		                inx             ; drop
.a10c		e8		inx		                inx
.a10d		60		rts		z_spaces:       rts
.a10e						xt_star:
.a10e		20 7a d8	jsr $d87a	                jsr underflow_2
.a111		20 a0 a5	jsr $a5a0	                jsr xt_um_star
.a114		e8		inx		                inx
.a115		e8		inx		                inx
.a116		60		rts		z_star:         rts
.a117						xt_star_slash:
.a117		20 20 a1	jsr $a120	                jsr xt_star_slash_mod
.a11a		20 5c a1	jsr $a15c	                jsr xt_swap
.a11d		e8		inx		                inx
.a11e		e8		inx		                inx
.a11f						z_star_slash:
.a11f		60		rts		                rts
.a120						xt_star_slash_mod:
.a120		20 7f d8	jsr $d87f	                jsr underflow_3
.a123		20 14 a3	jsr $a314	                jsr xt_to_r
.a126		20 72 94	jsr $9472	                jsr xt_m_star
.a129		20 76 9a	jsr $9a76	                jsr xt_r_from
.a12c		20 83 a0	jsr $a083	                jsr xt_sm_slash_rem
.a12f						z_star_slash_mod:
.a12f		60		rts		                rts
.a130						xt_state:
.a130		ca		dex		                dex
.a131		ca		dex		                dex
.a132		a9 16		lda #$16	                lda #<state
.a134		95 00		sta $00,x	                sta 0,x
.a136		a9 00		lda #$00	                lda #>state
.a138		95 01		sta $01,x	                sta 1,x
.a13a		60		rts		z_state:        rts
.a13b						xt_store:
.a13b		20 7a d8	jsr $d87a	                jsr underflow_2
.a13e		b5 02		lda $02,x	                lda 2,x         ; LSB
.a140		81 00		sta ($00,x)	                sta (0,x)
.a142		f6 00		inc $00,x	                inc 0,x
.a144		d0 02		bne $a148	                bne +
.a146		f6 01		inc $01,x	                inc 1,x
.a148						+
.a148		b5 03		lda $03,x	                lda 3,x         ; MSB
.a14a		81 00		sta ($00,x)	                sta (0,x)
.a14c		e8		inx		                inx             ; 2DROP
.a14d		e8		inx		                inx
.a14e		e8		inx		                inx
.a14f		e8		inx		                inx
.a150		60		rts		z_store:        rts
.a151						xt_strip_underflow:
.a151		ca		dex		                dex
.a152		ca		dex		                dex
.a153		a9 1c		lda #$1c	                lda #<uf_strip
.a155		95 00		sta $00,x	                sta 0,x
.a157		a9 00		lda #$00	                lda #>uf_strip
.a159		95 01		sta $01,x	                sta 1,x
.a15b						z_strip_underflow:
.a15b		60		rts		                rts
.a15c						xt_swap:
.a15c		20 7a d8	jsr $d87a	                jsr underflow_2
.a15f		b5 00		lda $00,x	                lda 0,x         ; LSB
.a161		b4 02		ldy $02,x	                ldy 2,x
.a163		95 02		sta $02,x	                sta 2,x
.a165		94 00		sty $00,x	                sty 0,x
.a167		b5 01		lda $01,x	                lda 1,x         ; MSB
.a169		b4 03		ldy $03,x	                ldy 3,x
.a16b		95 03		sta $03,x	                sta 3,x
.a16d		94 01		sty $01,x	                sty 1,x
.a16f		60		rts		z_swap:         rts
.a170						xt_thru:
.a170		20 7a d8	jsr $d87a	                jsr underflow_2
.a173		b5 01		lda $01,x	                lda 1,x
.a175		48		pha		                pha
.a176		b5 00		lda $00,x	                lda 0,x
.a178		48		pha		                pha
.a179		e8		inx		                inx
.a17a		e8		inx		                inx
.a17b						_thru_loop:
.a17b		b5 01		lda $01,x	                lda 1,x
.a17d		48		pha		                pha
.a17e		b5 00		lda $00,x	                lda 0,x
.a180		48		pha		                pha
.a181		20 98 93	jsr $9398	                jsr xt_load
.a184		68		pla		                pla
.a185		85 22		sta $22		                sta tmp1
.a187		68		pla		                pla
.a188		85 23		sta $23		                sta tmp1+1
.a18a		68		pla		                pla
.a18b		85 24		sta $24		                sta tmp2
.a18d		68		pla		                pla
.a18e		85 25		sta $25		                sta tmp2+1
.a190		c5 23		cmp $23		                cmp tmp1+1
.a192		d0 08		bne $a19c	                bne _next_screen
.a194		a5 24		lda $24		                lda tmp2        ; Compare the LSB
.a196		c5 22		cmp $22		                cmp tmp1
.a198		d0 02		bne $a19c	                bne _next_screen
.a19a		80 18		bra $a1b4	                bra _done       ; We just did the last screen.
.a19c						_next_screen:
.a19c		a5 25		lda $25		                lda tmp2+1
.a19e		48		pha		                pha
.a19f		a5 24		lda $24		                lda tmp2
.a1a1		48		pha		                pha
.a1a2		e6 22		inc $22		                inc tmp1
.a1a4		d0 02		bne $a1a8	                bne +
.a1a6		e6 23		inc $23		                inc tmp1+1
.a1a8						+
.a1a8		ca		dex		                dex
.a1a9		ca		dex		                dex
.a1aa		a5 22		lda $22		                lda tmp1
.a1ac		95 00		sta $00,x	                sta 0,x
.a1ae		a5 23		lda $23		                lda tmp1+1
.a1b0		95 01		sta $01,x	                sta 1,x
.a1b2		80 c7		bra $a17b	                bra _thru_loop
.a1b4						_done:
.a1b4		60		rts		z_thru:         rts
.a1b5						xt_tick:
.a1b5		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( -- addr u )
.a1b8		b5 00		lda $00,x	                lda 0,x
.a1ba		15 01		ora $01,x	                ora 1,x
.a1bc		d0 05		bne $a1c3	                bne +
.a1be		a9 05		lda #$05	                lda #err_noname
.a1c0		4c 8b d8	jmp $d88b	                jmp error
.a1c3						+
.a1c3		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( addr u -- nt )
.a1c6		b5 00		lda $00,x	                lda 0,x
.a1c8		15 01		ora $01,x	                ora 1,x
.a1ca		d0 05		bne $a1d1	                bne +
.a1cc		a9 08		lda #$08	                lda #err_syntax
.a1ce		4c 8b d8	jmp $d88b	                jmp error
.a1d1						+
.a1d1		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt -- xt )
.a1d4		60		rts		z_tick:         rts
.a1d5						xt_to:
.a1d5		20 b5 a1	jsr $a1b5	                jsr xt_tick             ; ( [n] xt )
.a1d8		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a1da		18		clc		                clc
.a1db		69 03		adc #$03	                adc #3
.a1dd		85 22		sta $22		                sta tmp1
.a1df		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a1e1		69 00		adc #$00	                adc #0                  ; we just want the carry
.a1e3		85 23		sta $23		                sta tmp1+1
.a1e5		e8		inx		                inx
.a1e6		e8		inx		                inx                     ; ( [n] )
.a1e7		a5 16		lda $16		                lda state
.a1e9		05 17		ora $17		                ora state+1
.a1eb		f0 34		beq $a221	                beq _interpret
.a1ed		a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a1ef		a9 b5		lda #$b5	                lda #$B5
.a1f1		20 29 d7	jsr $d729	                jsr cmpl_word
.a1f4		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a1f6		20 2d d7	jsr $d72d	                jsr cmpl_a
.a1f9		a4 23		ldy $23		                ldy tmp1+1              ; MSB goes in Y
.a1fb		a5 22		lda $22		                lda tmp1
.a1fd		20 29 d7	jsr $d729	                jsr cmpl_word
.a200		a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a202		a9 b5		lda #$b5	                lda #$B5
.a204		20 29 d7	jsr $d729	                jsr cmpl_word
.a207		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a209		20 2d d7	jsr $d72d	                jsr cmpl_a
.a20c		e6 22		inc $22		                inc tmp1                ; Calculate MSB
.a20e		d0 02		bne $a212	                bne +
.a210		e6 23		inc $23		                inc tmp1+1
.a212						+
.a212		a4 23		ldy $23		                ldy tmp1+1              ; MSB goes in Y
.a214		a5 22		lda $22		                lda tmp1
.a216		20 29 d7	jsr $d729	                jsr cmpl_word
.a219		a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a21b		98		tya		                tya
.a21c		20 29 d7	jsr $d729	                jsr cmpl_word
.a21f		80 0f		bra $a230	                bra _done
.a221						_interpret:
.a221		20 75 d8	jsr $d875	                jsr underflow_1
.a224		b5 00		lda $00,x	                lda 0,x
.a226		92 22		sta ($22)	                sta (tmp1)              ; LSB
.a228		a0 01		ldy #$01	                ldy #1
.a22a		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a22c		91 22		sta ($22),y	                sta (tmp1),y            ; fall through to common
.a22e		e8		inx		                inx                     ; DROP
.a22f		e8		inx		                inx
.a230						_done:
.a230		60		rts		z_to:           rts
.a231						xt_to_body:
.a231		20 75 d8	jsr $d875	                jsr underflow_1
.a234		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( xt xt )
.a237		20 59 92	jsr $9259	                jsr xt_int_to_name      ; ( xt nt )
.a23a		f6 00		inc $00,x	                inc 0,x
.a23c		d0 02		bne $a240	                bne +
.a23e		f6 01		inc $01,x	                inc 1,x
.a240						+
.a240		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a242		29 20		and #$20	                and #HC
.a244		f0 0d		beq $a253	                beq _no_cfa
.a246		18		clc		                clc
.a247		b5 02		lda $02,x	                lda 2,x         ; LSB
.a249		69 03		adc #$03	                adc #3
.a24b		95 02		sta $02,x	                sta 2,x
.a24d		b5 03		lda $03,x	                lda 3,x         ; MSB
.a24f		69 00		adc #$00	                adc #0          ; we conly care about the carry
.a251		95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a253						_no_cfa:
.a253		e8		inx		                inx             ; get rid of the nt
.a254		e8		inx		                inx
.a255						_done:
.a255		60		rts		z_to_body:      rts
.a256						xt_to_in:
.a256		ca		dex		                dex
.a257		ca		dex		                dex
.a258		a9 0c		lda #$0c	                lda #<toin
.a25a		95 00		sta $00,x	                sta 0,x
.a25c		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a25e		95 01		sta $01,x	                sta 1,x
.a260		60		rts		z_to_in:        rts
.a261						xt_to_number:
.a261		20 84 d8	jsr $d884	                jsr underflow_4
.a264		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a266		85 34		sta $34		                sta scratch
.a268		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a26a		85 35		sta $35		                sta scratch+1
.a26c		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a26e		85 36		sta $36		                sta scratch+2
.a270		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a272		85 37		sta $37		                sta scratch+3
.a274		ca		dex		                dex
.a275		ca		dex		                dex
.a276						_loop:
.a276		a1 04		lda ($04,x)	                lda (4,x)
.a278		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a27a		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a27c		20 cc 8a	jsr $8acc	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a27f		b5 00		lda $00,x	                lda 0,x
.a281		d0 04		bne $a287	                bne _digit_ok
.a283		e8		inx		                inx
.a284		e8		inx		                inx
.a285		80 67		bra $a2ee	                bra _done       ; ( ud-lo ud-hi addr u char )
.a287						_digit_ok:
.a287		b5 02		lda $02,x	                lda 2,x
.a289		85 38		sta $38		                sta scratch+4
.a28b		b5 03		lda $03,x	                lda 3,x
.a28d		85 39		sta $39		                sta scratch+5
.a28f		a5 36		lda $36		                lda scratch+2
.a291		95 02		sta $02,x	                sta 2,x         ; NOS
.a293		a5 37		lda $37		                lda scratch+3
.a295		95 03		sta $03,x	                sta 3,x
.a297		a5 18		lda $18		                lda base
.a299		95 00		sta $00,x	                sta 0,x         ; TOS
.a29b		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a29d		20 a0 a5	jsr $a5a0	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2a0		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2a2		85 3a		sta $3a		                sta scratch+6
.a2a4		b5 03		lda $03,x	                lda 3,x
.a2a6		85 3b		sta $3b		                sta scratch+7
.a2a8		a5 34		lda $34		                lda scratch
.a2aa		95 02		sta $02,x	                sta 2,x
.a2ac		a5 35		lda $35		                lda scratch+1
.a2ae		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a2b0		a5 18		lda $18		                lda base
.a2b2		95 00		sta $00,x	                sta 0,x
.a2b4		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a2b6		20 a0 a5	jsr $a5a0	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a2b9		b5 00		lda $00,x	                lda 0,x
.a2bb		85 36		sta $36		                sta scratch+2
.a2bd		b5 01		lda $01,x	                lda 1,x
.a2bf		85 37		sta $37		                sta scratch+3
.a2c1		b5 02		lda $02,x	                lda 2,x
.a2c3		85 34		sta $34		                sta scratch
.a2c5		b5 03		lda $03,x	                lda 3,x
.a2c7		85 35		sta $35		                sta scratch+1
.a2c9		18		clc		                clc
.a2ca		a5 34		lda $34		                lda scratch     ; ud-lo LSB
.a2cc		65 38		adc $38		                adc scratch+4   ; n LSB
.a2ce		85 34		sta $34		                sta scratch     ; this is the new ud-lo
.a2d0		a5 35		lda $35		                lda scratch+1   ; ud-lo MSB
.a2d2		65 39		adc $39		                adc scratch+5   ; n MSB
.a2d4		85 35		sta $35		                sta scratch+1
.a2d6		a5 36		lda $36		                lda scratch+2   ; LSB
.a2d8		65 3a		adc $3a		                adc scratch+6
.a2da		85 36		sta $36		                sta scratch+2   ; this is the new ud-hi
.a2dc		a5 37		lda $37		                lda scratch+3   ; MSB
.a2de		65 3b		adc $3b		                adc scratch+7
.a2e0		85 37		sta $37		                sta scratch+3
.a2e2		e8		inx		                inx
.a2e3		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a2e4		f6 04		inc $04,x	                inc 4,x
.a2e6		d0 02		bne $a2ea	                bne +
.a2e8		f6 05		inc $05,x	                inc 5,x
.a2ea						+
.a2ea		d6 02		dec $02,x	                dec 2,x
.a2ec		d0 88		bne $a276	                bne _loop
.a2ee						_done:
.a2ee		e8		inx		                inx
.a2ef		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a2f0		a5 34		lda $34		                lda scratch     ; new ud-lo
.a2f2		95 06		sta $06,x	                sta 6,x
.a2f4		a5 35		lda $35		                lda scratch+1
.a2f6		95 07		sta $07,x	                sta 7,x
.a2f8		a5 36		lda $36		                lda scratch+2
.a2fa		95 04		sta $04,x	                sta 4,x
.a2fc		a5 37		lda $37		                lda scratch+3
.a2fe		95 05		sta $05,x	                sta 5,x
.a300		60		rts		z_to_number:    rts
.a301						xt_to_order:
.a301		20 14 a3	jsr $a314	                jsr xt_to_r
.a304		20 19 91	jsr $9119	                jsr xt_get_order
.a307		20 76 9a	jsr $9a76	                jsr xt_r_from
.a30a		20 5c a1	jsr $a15c	                jsr xt_swap
.a30d		20 01 98	jsr $9801	                jsr xt_one_plus
.a310		20 f8 9c	jsr $9cf8	                jsr xt_set_order
.a313		60		rts		z_to_order:     rts
.a314						xt_to_r:
.a314		68		pla		                pla             ; LSB
.a315		85 2a		sta $2a		                sta tmptos
.a317		7a		ply		                ply             ; MSB
.a318		20 75 d8	jsr $d875	                jsr underflow_1
.a31b		b5 01		lda $01,x	                lda 1,x         ; MSB
.a31d		48		pha		                pha
.a31e		b5 00		lda $00,x	                lda 0,x         ; LSB
.a320		48		pha		                pha
.a321		e8		inx		                inx
.a322		e8		inx		                inx
.a323		5a		phy		                phy             ; MSB
.a324		a5 2a		lda $2a		                lda tmptos
.a326		48		pha		                pha             ; LSB
.a327		60		rts		z_to_r:         rts
.a328						xt_true:
.a328		ca		dex		                dex
.a329		ca		dex		                dex
.a32a		a9 ff		lda #$ff	                lda #$FF
.a32c		95 00		sta $00,x	                sta 0,x
.a32e		95 01		sta $01,x	                sta 1,x
.a330		60		rts		z_true:         rts
.a331						xt_tuck:
.a331		20 7a d8	jsr $d87a	                jsr underflow_2
.a334		ca		dex		                dex
.a335		ca		dex		                dex
.a336		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a338		b5 02		lda $02,x	                lda 2,x
.a33a		95 04		sta $04,x	                sta 4,x
.a33c		94 02		sty $02,x	                sty 2,x
.a33e		95 00		sta $00,x	                sta 0,x
.a340		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a342		b5 03		lda $03,x	                lda 3,x
.a344		95 05		sta $05,x	                sta 5,x
.a346		94 03		sty $03,x	                sty 3,x         ; bba
.a348		95 01		sta $01,x	                sta 1,x         ; baa
.a34a		60		rts		z_tuck:         rts
.a34b						xt_assembler_wordlist:
.a34b						xt_two:
.a34b		ca		dex		                dex
.a34c		ca		dex		                dex
.a34d		a9 02		lda #$02	                lda #2
.a34f		95 00		sta $00,x	                sta 0,x
.a351		74 01		stz $01,x	                stz 1,x
.a353						z_assembler_wordlist:
.a353		60		rts		z_two:          rts
.a354						xt_two_drop:
.a354		20 7a d8	jsr $d87a	                jsr underflow_2
.a357		e8		inx		                inx
.a358		e8		inx		                inx
.a359		e8		inx		                inx
.a35a		e8		inx		                inx
.a35b		60		rts		z_two_drop:     rts
.a35c						xt_two_dup:
.a35c		20 7a d8	jsr $d87a	                jsr underflow_2
.a35f		ca		dex		                dex
.a360		ca		dex		                dex
.a361		ca		dex		                dex
.a362		ca		dex		                dex
.a363		b5 04		lda $04,x	                lda 4,x         ; TOS
.a365		95 00		sta $00,x	                sta 0,x
.a367		b5 05		lda $05,x	                lda 5,x
.a369		95 01		sta $01,x	                sta 1,x
.a36b		b5 06		lda $06,x	                lda 6,x         ; NOS
.a36d		95 02		sta $02,x	                sta 2,x
.a36f		b5 07		lda $07,x	                lda 7,x
.a371		95 03		sta $03,x	                sta 3,x
.a373		60		rts		z_two_dup:      rts
.a374						xt_two_fetch:
.a374		20 75 d8	jsr $d875	                jsr underflow_1
.a377		b5 00		lda $00,x	                lda 0,x
.a379		85 22		sta $22		                sta tmp1
.a37b		b4 01		ldy $01,x	                ldy 1,x
.a37d		84 23		sty $23		                sty tmp1+1
.a37f		ca		dex		                dex             ; reuse one stack element
.a380		ca		dex		                dex
.a381		b2 22		lda ($22)	                lda (tmp1)      ; copy LSB
.a383		95 00		sta $00,x	                sta 0,x
.a385		a0 01		ldy #$01	                ldy #1          ; copy next
.a387		b1 22		lda ($22),y	                lda (tmp1),y
.a389		95 01		sta $01,x	                sta 1,x
.a38b		c8		iny		                iny             ; copy next
.a38c		b1 22		lda ($22),y	                lda (tmp1),y
.a38e		95 02		sta $02,x	                sta 2,x
.a390		c8		iny		                iny             ; copy next
.a391		b1 22		lda ($22),y	                lda (tmp1),y
.a393		95 03		sta $03,x	                sta 3,x
.a395		60		rts		z_two_fetch:    rts
.a396						xt_two_over:
.a396		20 84 d8	jsr $d884	                jsr underflow_4
.a399		ca		dex		                dex
.a39a		ca		dex		                dex
.a39b		ca		dex		                dex
.a39c		ca		dex		                dex
.a39d		b5 08		lda $08,x	                lda 8,x
.a39f		95 00		sta $00,x	                sta 0,x
.a3a1		b5 09		lda $09,x	                lda 9,x
.a3a3		95 01		sta $01,x	                sta 1,x
.a3a5		b5 0a		lda $0a,x	                lda 10,x
.a3a7		95 02		sta $02,x	                sta 2,x
.a3a9		b5 0b		lda $0b,x	                lda 11,x
.a3ab		95 03		sta $03,x	                sta 3,x
.a3ad		60		rts		z_two_over:     rts
.a3ae						xt_two_r_fetch:
.a3ae		ca		dex		                dex
.a3af		ca		dex		                dex
.a3b0		ca		dex		                dex
.a3b1		ca		dex		                dex
.a3b2		8a		txa		                txa
.a3b3		ba		tsx		                tsx
.a3b4		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a3b5		7a		ply		                ply
.a3b6		aa		tax		                tax
.a3b7		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a3ba		95 00		sta $00,x	                sta 0,x
.a3bc		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a3bf		95 01		sta $01,x	                sta 1,x
.a3c1		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a3c4		95 02		sta $02,x	                sta 2,x
.a3c6		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a3c9		95 03		sta $03,x	                sta 3,x
.a3cb		60		rts		z_two_r_fetch:  rts
.a3cc						xt_two_r_from:
.a3cc		68		pla		                pla                     ; LSB
.a3cd		85 22		sta $22		                sta tmp1
.a3cf		68		pla		                pla                     ; MSB
.a3d0		85 23		sta $23		                sta tmp1+1
.a3d2		ca		dex		                dex
.a3d3		ca		dex		                dex
.a3d4		ca		dex		                dex
.a3d5		ca		dex		                dex
.a3d6		68		pla		                pla                     ; LSB
.a3d7		95 00		sta $00,x	                sta 0,x
.a3d9		68		pla		                pla                     ; MSB
.a3da		95 01		sta $01,x	                sta 1,x
.a3dc		68		pla		                pla                     ; LSB
.a3dd		95 02		sta $02,x	                sta 2,x
.a3df		68		pla		                pla                     ; MSB
.a3e0		95 03		sta $03,x	                sta 3,x
.a3e2		a5 23		lda $23		                lda tmp1+1              ; MSB
.a3e4		48		pha		                pha
.a3e5		a5 22		lda $22		                lda tmp1                ; LSB
.a3e7		48		pha		                pha
.a3e8		60		rts		z_two_r_from:   rts
.a3e9						xt_two_slash:
.a3e9		20 75 d8	jsr $d875	                jsr underflow_1
.a3ec		b5 01		lda $01,x	                lda 1,x
.a3ee		0a		asl a		                asl                     ; save the sign
.a3ef		76 01		ror $01,x	                ror 1,x
.a3f1		76 00		ror $00,x	                ror 0,x
.a3f3		60		rts		z_two_slash:    rts
.a3f4						xt_two_star:
.a3f4						xt_cells:
.a3f4		20 75 d8	jsr $d875	                jsr underflow_1
.a3f7		16 00		asl $00,x	                asl 0,x
.a3f9		36 01		rol $01,x	                rol 1,x
.a3fb						z_cells:
.a3fb		60		rts		z_two_star:     rts
.a3fc						xt_two_store:
.a3fc		20 7f d8	jsr $d87f	                jsr underflow_3
.a3ff		b5 00		lda $00,x	                lda 0,x
.a401		85 22		sta $22		                sta tmp1
.a403		b4 01		ldy $01,x	                ldy 1,x
.a405		84 23		sty $23		                sty tmp1+1
.a407		e8		inx		                inx
.a408		e8		inx		                inx
.a409		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a40b		92 22		sta ($22)	                sta (tmp1)
.a40d		b5 01		lda $01,x	                lda 1,x         ; copy next
.a40f		a0 01		ldy #$01	                ldy #1
.a411		91 22		sta ($22),y	                sta (tmp1),y
.a413		b5 02		lda $02,x	                lda 2,x         ; copy next
.a415		c8		iny		                iny
.a416		91 22		sta ($22),y	                sta (tmp1),y
.a418		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a41a		c8		iny		                iny
.a41b		91 22		sta ($22),y	                sta (tmp1),y
.a41d		e8		inx		                inx             ; 2DROP
.a41e		e8		inx		                inx
.a41f		e8		inx		                inx
.a420		e8		inx		                inx
.a421		60		rts		z_two_store:    rts
.a422						xt_two_swap:
.a422		20 84 d8	jsr $d884	                jsr underflow_4
.a425		b5 00		lda $00,x	                lda 0,x
.a427		b4 04		ldy $04,x	                ldy 4,x
.a429		95 04		sta $04,x	                sta 4,x
.a42b		94 00		sty $00,x	                sty 0,x
.a42d		b5 01		lda $01,x	                lda 1,x
.a42f		b4 05		ldy $05,x	                ldy 5,x
.a431		95 05		sta $05,x	                sta 5,x
.a433		94 01		sty $01,x	                sty 1,x
.a435		b5 02		lda $02,x	                lda 2,x
.a437		b4 06		ldy $06,x	                ldy 6,x
.a439		95 06		sta $06,x	                sta 6,x
.a43b		94 02		sty $02,x	                sty 2,x
.a43d		b5 03		lda $03,x	                lda 3,x
.a43f		b4 07		ldy $07,x	                ldy 7,x
.a441		95 07		sta $07,x	                sta 7,x
.a443		94 03		sty $03,x	                sty 3,x
.a445		60		rts		z_two_swap:     rts
.a446						xt_two_to_r:
.a446		68		pla		                pla             ; LSB
.a447		85 22		sta $22		                sta tmp1
.a449		68		pla		                pla             ; MSB
.a44a		85 23		sta $23		                sta tmp1+1
.a44c		20 7a d8	jsr $d87a	                jsr underflow_2
.a44f		b5 03		lda $03,x	                lda 3,x         ; MSB
.a451		48		pha		                pha
.a452		b5 02		lda $02,x	                lda 2,x         ; LSB
.a454		48		pha		                pha
.a455		b5 01		lda $01,x	                lda 1,x         ; MSB
.a457		48		pha		                pha
.a458		b5 00		lda $00,x	                lda 0,x         ; LSB
.a45a		48		pha		                pha
.a45b		e8		inx		                inx
.a45c		e8		inx		                inx
.a45d		e8		inx		                inx
.a45e		e8		inx		                inx
.a45f		a5 23		lda $23		                lda tmp1+1      ; MSB
.a461		48		pha		                pha
.a462		a5 22		lda $22		                lda tmp1        ; LSB
.a464		48		pha		                pha
.a465		60		rts		z_two_to_r:     rts
.a466						xt_two_constant:
.a466		20 7a d8	jsr $d87a	                jsr underflow_2
.a469		20 30 89	jsr $8930	                jsr xt_create
.a46c		20 5c a1	jsr $a15c	                jsr xt_swap
.a46f		20 24 87	jsr $8724	                jsr xt_comma
.a472		20 24 87	jsr $8724	                jsr xt_comma
.a475		20 b7 8b	jsr $8bb7	                jsr does_runtime    ; does> turns into these two routines.
.a478		20 63 d7	jsr $d763	                jsr dodoes
.a47b		20 62 8d	jsr $8d62	                jsr xt_dup
.a47e		20 65 8f	jsr $8f65	                jsr xt_fetch
.a481		20 5c a1	jsr $a15c	                jsr xt_swap
.a484		20 d7 85	jsr $85d7	                jsr xt_cell_plus
.a487		20 65 8f	jsr $8f65	                jsr xt_fetch
.a48a		60		rts		z_two_constant: rts
.a48b						xt_two_literal:
.a48b		20 7a d8	jsr $d87a	                jsr underflow_2 ; double number
.a48e		20 5c a1	jsr $a15c	                jsr xt_swap
.a491		20 6b 93	jsr $936b	                jsr xt_literal
.a494		20 6b 93	jsr $936b	                jsr xt_literal
.a497		60		rts		z_two_literal:  rts
.a498						xt_two_variable:
.a498		20 30 89	jsr $8930	                jsr xt_create
.a49b		ca		dex		                dex
.a49c		ca		dex		                dex
.a49d		a9 04		lda #$04	                lda #4
.a49f		95 00		sta $00,x	                sta 0,x
.a4a1		74 01		stz $01,x	                stz 1,x
.a4a3		20 3f 82	jsr $823f	                jsr xt_allot
.a4a6		60		rts		z_two_variable: rts
.a4a7						xt_type:
.a4a7		20 7a d8	jsr $d87a	                jsr underflow_2
.a4aa		b5 02		lda $02,x	                lda 2,x
.a4ac		85 22		sta $22		                sta tmp1
.a4ae		b5 03		lda $03,x	                lda 3,x
.a4b0		85 23		sta $23		                sta tmp1+1
.a4b2						_loop:
.a4b2		b5 00		lda $00,x	                lda 0,x
.a4b4		15 01		ora $01,x	                ora 1,x
.a4b6		f0 15		beq $a4cd	                beq _done
.a4b8		b2 22		lda ($22)	                lda (tmp1)
.a4ba		20 db 8d	jsr $8ddb	                jsr emit_a      ; avoids stack foolery
.a4bd		e6 22		inc $22		                inc tmp1
.a4bf		d0 02		bne $a4c3	                bne +
.a4c1		e6 23		inc $23		                inc tmp1+1
.a4c3						+
.a4c3		b5 00		lda $00,x	                lda 0,x
.a4c5		d0 02		bne $a4c9	                bne +
.a4c7		d6 01		dec $01,x	                dec 1,x
.a4c9						+
.a4c9		d6 00		dec $00,x	                dec 0,x
.a4cb		80 e5		bra $a4b2	                bra _loop
.a4cd						_done:
.a4cd		e8		inx		                inx
.a4ce		e8		inx		                inx
.a4cf		e8		inx		                inx
.a4d0		e8		inx		                inx
.a4d1		60		rts		z_type:         rts
.a4d2						xt_u_dot:
.a4d2		20 75 d8	jsr $d875	                jsr underflow_1
.a4d5		20 e2 d8	jsr $d8e2	                jsr print_u
.a4d8		a9 20		lda #$20	                lda #AscSP
.a4da		20 db 8d	jsr $8ddb	                jsr emit_a
.a4dd		60		rts		z_u_dot:        rts
.a4de						xt_u_dot_r:
.a4de		20 7a d8	jsr $d87a	                jsr underflow_2
.a4e1		20 14 a3	jsr $a314	                jsr xt_to_r
.a4e4		20 56 a7	jsr $a756	                jsr xt_zero
.a4e7		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a4ea		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.a4ed		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.a4f0		20 76 9a	jsr $9a76	                jsr xt_r_from
.a4f3		20 77 98	jsr $9877	                jsr xt_over
.a4f6		20 34 95	jsr $9534	                jsr xt_minus
.a4f9		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.a4fc		20 a7 a4	jsr $a4a7	                jsr xt_type
.a4ff		60		rts		z_u_dot_r:      rts
.a500						xt_u_greater_than:
.a500		20 7a d8	jsr $d87a	                jsr underflow_2
.a503		b5 00		lda $00,x	                lda 0,x
.a505		d5 02		cmp $02,x	                cmp 2,x
.a507		b5 01		lda $01,x	                lda 1,x
.a509		f5 03		sbc $03,x	                sbc 3,x
.a50b		e8		inx		                inx
.a50c		e8		inx		                inx
.a50d		a9 00		lda #$00	                lda #0
.a50f		69 ff		adc #$ff	                adc #$ff
.a511		95 00		sta $00,x	                sta 0,x         ; store flag
.a513		95 01		sta $01,x	                sta 1,x
.a515		60		rts		z_u_greater_than:    rts
.a516						xt_u_less_than:
.a516		20 7a d8	jsr $d87a	                jsr underflow_2
.a519		b5 02		lda $02,x	                lda 2,x
.a51b		d5 00		cmp $00,x	                cmp 0,x
.a51d		b5 03		lda $03,x	                lda 3,x
.a51f		f5 01		sbc $01,x	                sbc 1,x
.a521		e8		inx		                inx
.a522		e8		inx		                inx
.a523		a9 00		lda #$00	                lda #0
.a525		69 ff		adc #$ff	                adc #$ff
.a527		95 00		sta $00,x	                sta 0,x         ; store flag
.a529		95 01		sta $01,x	                sta 1,x
.a52b		60		rts		z_u_less_than:    rts
.a52c						xt_ud_dot:
.a52c		20 7a d8	jsr $d87a	                jsr underflow_2 ; double number
.a52f		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a532		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.a535		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.a538		20 a7 a4	jsr $a4a7	                jsr xt_type
.a53b		20 cc a0	jsr $a0cc	                jsr xt_space
.a53e		60		rts		z_ud_dot:        rts
.a53f						xt_ud_dot_r:
.a53f		20 7f d8	jsr $d87f	                jsr underflow_3
.a542		20 14 a3	jsr $a314	                jsr xt_to_r
.a545		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a548		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.a54b		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.a54e		20 76 9a	jsr $9a76	                jsr xt_r_from
.a551		20 77 98	jsr $9877	                jsr xt_over
.a554		20 34 95	jsr $9534	                jsr xt_minus
.a557		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.a55a		20 a7 a4	jsr $a4a7	                jsr xt_type
.a55d		60		rts		z_ud_dot_r:      rts
.a55e						xt_um_slash_mod:
.a55e		20 7f d8	jsr $d87f	                jsr underflow_3
.a561		b5 00		lda $00,x	                lda 0,x
.a563		15 01		ora $01,x	                ora 1,x
.a565		d0 05		bne $a56c	                bne _not_zero
.a567		a9 04		lda #$04	                lda #err_divzero
.a569		4c 8b d8	jmp $d88b	                jmp error
.a56c						_not_zero:
.a56c		a9 11		lda #$11	                lda #17
.a56e		85 2a		sta $2a		                sta tmptos
.a570						_loop:
.a570		36 04		rol $04,x	                rol 4,x
.a572		36 05		rol $05,x	                rol 5,x
.a574		c6 2a		dec $2a		                dec tmptos
.a576		f0 22		beq $a59a	                beq _done
.a578		36 02		rol $02,x	                rol 2,x
.a57a		36 03		rol $03,x	                rol 3,x
.a57c		64 22		stz $22		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a57e		26 22		rol $22		                rol tmp1
.a580		38		sec		                sec
.a581		b5 02		lda $02,x	                lda 2,x
.a583		f5 00		sbc $00,x	                sbc 0,x
.a585		85 23		sta $23		                sta tmp1+1
.a587		b5 03		lda $03,x	                lda 3,x
.a589		f5 01		sbc $01,x	                sbc 1,x
.a58b		a8		tay		                tay
.a58c		a5 22		lda $22		                lda tmp1
.a58e		e9 00		sbc #$00	                sbc #0
.a590		90 de		bcc $a570	                bcc _loop
.a592		a5 23		lda $23		                lda tmp1+1
.a594		95 02		sta $02,x	                sta 2,x
.a596		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a598		80 d6		bra $a570	                bra _loop
.a59a						_done:
.a59a		e8		inx		                inx
.a59b		e8		inx		                inx
.a59c		20 5c a1	jsr $a15c	                jsr xt_swap
.a59f		60		rts		z_um_slash_mod: rts
.a5a0						xt_um_star:
.a5a0		20 7a d8	jsr $d87a	                jsr underflow_2
.a5a3		18		clc		                clc
.a5a4		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a5a6		e9 00		sbc #$00	                sbc #0
.a5a8		85 24		sta $24		                sta tmp2
.a5aa		b5 01		lda $01,x	                lda 1,x
.a5ac		e9 00		sbc #$00	                sbc #0
.a5ae		90 31		bcc $a5e1	                bcc _zero       ; is TOS zero?
.a5b0		85 25		sta $25		                sta tmp2+1
.a5b2		a9 00		lda #$00	                lda #0
.a5b4		85 22		sta $22		                sta tmp1
.a5b6		86 26		stx $26		                stx tmp3        ; tested for exit from outer loop
.a5b8		ca		dex		                dex
.a5b9		ca		dex		                dex
.a5ba						_outer_loop:
.a5ba		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a5bc		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a5be						_inner_loop:
.a5be		90 0c		bcc $a5cc	                bcc _no_add
.a5c0		85 23		sta $23		                sta tmp1+1      ; save time, don't CLC
.a5c2		a5 22		lda $22		                lda tmp1
.a5c4		65 24		adc $24		                adc tmp2
.a5c6		85 22		sta $22		                sta tmp1
.a5c8		a5 23		lda $23		                lda tmp1+1
.a5ca		65 25		adc $25		                adc tmp2+1
.a5cc						_no_add:
.a5cc		6a		ror a		                ror
.a5cd		66 22		ror $22		                ror tmp1
.a5cf		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a5d1		88		dey		                dey
.a5d2		d0 ea		bne $a5be	                bne _inner_loop ; go back for one more shift?
.a5d4		e8		inx		                inx
.a5d5		e4 26		cpx $26		                cpx tmp3
.a5d7		d0 e1		bne $a5ba	                bne _outer_loop ; go back for eight more shifts?
.a5d9		95 01		sta $01,x	                sta 1,x
.a5db		a5 22		lda $22		                lda tmp1
.a5dd		95 00		sta $00,x	                sta 0,x
.a5df		80 04		bra $a5e5	                bra _done
.a5e1						_zero:
.a5e1		74 02		stz $02,x	                stz 2,x
.a5e3		74 03		stz $03,x	                stz 3,x
.a5e5						_done:
.a5e5		60		rts		z_um_star:      rts
.a5e6						xt_unloop:
.a5e6		68		pla		                pla
.a5e7		68		pla		                pla
.a5e8		68		pla		                pla
.a5e9		68		pla		                pla
.a5ea		68		pla		                pla
.a5eb		68		pla		                pla
.a5ec		60		rts		z_unloop:       rts
.a5ed						xt_until:
.a5ed		a0 00		ldy #$00	                ldy #0
.a5ef						-
.a5ef		b9 f7 91	lda $91f7,y	                lda zero_test_runtime,y
.a5f2		c9 60		cmp #$60	                cmp #$60            ; skip RTS
.a5f4		f0 03		beq $a5f9	                beq +
.a5f6		20 2d d7	jsr $d72d	                jsr cmpl_a
.a5f9						+
.a5f9		c8		iny		                iny
.a5fa		c0 0a		cpy #$0a	                cpy #(zero_test_footer_end - zero_test_runtime)
.a5fc		d0 f1		bne $a5ef	                bne -
.a5fe		20 24 87	jsr $8724	                jsr xt_comma
.a601		60		rts		z_until:        rts
.a602						xt_unused:
.a602		ca		dex		                dex
.a603		ca		dex		                dex
.a604		a9 00		lda #$00	                lda #<cp_end
.a606		38		sec		                sec
.a607		e5 00		sbc $00		                sbc cp
.a609		95 00		sta $00,x	                sta 0,x
.a60b		a9 7c		lda #$7c	                lda #>cp_end
.a60d		e5 01		sbc $01		                sbc cp+1
.a60f		95 01		sta $01,x	                sta 1,x
.a611		60		rts		z_unused:       rts
.a612						xt_update:
.a612		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a614		b1 1e		lda ($1e),y	                lda (up),y
.a616		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a618		91 1e		sta ($1e),y	                sta (up),y
.a61a		60		rts		z_update:       rts
.a61b						xt_useraddr:
.a61b		ca		dex		                dex
.a61c		ca		dex		                dex
.a61d		a9 1e		lda #$1e	                lda #<up
.a61f		95 00		sta $00,x	                sta 0,x
.a621		a9 00		lda #$00	                lda #>up
.a623		95 01		sta $01,x	                sta 1,x
.a625		60		rts		z_useraddr:     rts
.a626						xt_variable:
.a626		20 30 89	jsr $8930	                jsr xt_create
.a629		a9 00		lda #$00	                lda #0
.a62b		92 00		sta ($00)	                sta (cp)
.a62d		e6 00		inc $00		                inc cp
.a62f		d0 02		bne $a633	                bne +
.a631		e6 01		inc $01		                inc cp+1
.a633						+
.a633		92 00		sta ($00)	                sta (cp)
.a635		e6 00		inc $00		                inc cp
.a637		d0 02		bne $a63b	                bne +
.a639		e6 01		inc $01		                inc cp+1
.a63b						+
.a63b		20 f8 88	jsr $88f8	                jsr adjust_z
.a63e		60		rts		z_variable:     rts
.a63f						xt_while:
.a63f		a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a641		a9 01		lda #$01	                lda #<zero_branch_runtime
.a643		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.a646		20 57 91	jsr $9157	                jsr xt_here
.a649		20 28 a3	jsr $a328	                jsr xt_true
.a64c		20 24 87	jsr $8724	                jsr xt_comma
.a64f		20 5c a1	jsr $a15c	                jsr xt_swap
.a652		60		rts		z_while:        rts
.a653						xt_within:
.a653		20 7f d8	jsr $d87f	                jsr underflow_3
.a656		20 77 98	jsr $9877	                jsr xt_over
.a659		20 34 95	jsr $9534	                jsr xt_minus
.a65c		20 14 a3	jsr $a314	                jsr xt_to_r
.a65f		20 34 95	jsr $9534	                jsr xt_minus
.a662		20 76 9a	jsr $9a76	                jsr xt_r_from
.a665		20 16 a5	jsr $a516	                jsr xt_u_less_than
.a668		60		rts		z_within:       rts
.a669						xt_word:
.a669		20 75 d8	jsr $d875	                jsr underflow_1
.a66c		a4 0c		ldy $0c		                ldy toin                ; >IN
.a66e						_loop:
.a66e		c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a670		f0 09		beq $a67b	                beq _found_char
.a672		b1 08		lda ($08),y	                lda (cib),y
.a674		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a676		d0 03		bne $a67b	                bne _found_char
.a678		c8		iny		                iny
.a679		80 f3		bra $a66e	                bra _loop
.a67b						_found_char:
.a67b		84 0c		sty $0c		                sty toin
.a67d		20 1e 99	jsr $991e	                jsr xt_parse            ; Returns ( addr u )
.a680		b5 00		lda $00,x	                lda 0,x
.a682		92 00		sta ($00)	                sta (cp)                ; Save length of string
.a684		48		pha		                pha                     ; Keep copy of length for later
.a685		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr u u )
.a688		a5 00		lda $00		                lda cp
.a68a		18		clc		                clc
.a68b		69 01		adc #$01	                adc #1
.a68d		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a68f		a5 01		lda $01		                lda cp+1
.a691		69 00		adc #$00	                adc #0
.a693		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a695		20 a6 95	jsr $95a6	                jsr xt_move
.a698		ca		dex		                dex
.a699		ca		dex		                dex
.a69a		a5 00		lda $00		                lda cp
.a69c		95 00		sta $00,x	                sta 0,x
.a69e		a5 01		lda $01		                lda cp+1
.a6a0		95 01		sta $01,x	                sta 1,x
.a6a2		68		pla		                pla                     ; length of string
.a6a3		18		clc		                clc
.a6a4		65 00		adc $00		                adc cp
.a6a6		85 00		sta $00		                sta cp
.a6a8		a5 01		lda $01		                lda cp+1
.a6aa		69 00		adc #$00	                adc #0                  ; we only need the carry
.a6ac		85 01		sta $01		                sta cp+1
.a6ae		60		rts		z_word:         rts
.a6af						xt_wordlist:
.a6af		a0 05		ldy #$05	                ldy #num_wordlists_offset
.a6b1		b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a6b3		c9 0c		cmp #$0c	                cmp #max_wordlists
.a6b5		d0 05		bne $a6bc	                bne _ok
.a6b7		a9 0b		lda #$0b	                lda #err_wordlist
.a6b9		4c 8b d8	jmp $d88b	                jmp error
.a6bc						_ok:
.a6bc		1a		inc a		                ina             ; Increment the wordlist#
.a6bd		91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a6bf		ca		dex		                dex             ; and put it on the stack.
.a6c0		ca		dex		                dex
.a6c1		95 00		sta $00,x	                sta 0,x
.a6c3		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a6c5		60		rts		z_wordlist:     rts
.a6c6						xt_words:
.a6c6		20 2a 89	jsr $892a	                jsr xt_cr
.a6c9		a9 00		lda #$00	                lda #0
.a6cb		48		pha		                pha
.a6cc		ca		dex		                dex                     ; Make room on the stack for
.a6cd		ca		dex		                dex                     ; a dictionary pointer.
.a6ce		64 26		stz $26		                stz tmp3                ; Start at the beginning of
.a6d0						_wordlist_loop:
.a6d0		a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a6d2		a5 26		lda $26		                lda tmp3
.a6d4		d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a6d6		d0 02		bne $a6da	                bne _have_wordlist
.a6d8		80 45		bra $a71f	                bra _words_done
.a6da						_have_wordlist:
.a6da		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a6db		69 1f		adc #$1f	                adc #search_order_offset
.a6dd		a8		tay		                tay
.a6de		b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a6e0		0a		asl a		                asl                     ; Turn offset into cells offset.
.a6e1		18		clc		                clc
.a6e2		69 06		adc #$06	                adc #wordlists_offset
.a6e4		a8		tay		                tay
.a6e5		b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a6e7		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a6e9		c8		iny		                iny
.a6ea		b1 1e		lda ($1e),y	                lda (up),y
.a6ec		95 01		sta $01,x	                sta 1,x
.a6ee						_loop:
.a6ee		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.a6f1		20 e2 95	jsr $95e2	                jsr xt_name_to_string   ; ( nt addr u )
.a6f4		68		pla		                pla
.a6f5		18		clc		                clc
.a6f6		75 00		adc $00,x	                adc 0,x
.a6f8		1a		inc a		                ina                     ; don't forget the space between words
.a6f9		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a6fb		90 06		bcc $a703	                bcc +
.a6fd		20 2a 89	jsr $892a	                jsr xt_cr
.a700		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a702		1a		inc a		                ina                     ; with length of this word.
.a703						+
.a703		48		pha		                pha
.a704		20 a7 a4	jsr $a4a7	                jsr xt_type             ; ( nt )
.a707		a9 20		lda #$20	                lda #AscSP
.a709		20 db 8d	jsr $8ddb	                jsr emit_a
.a70c		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+
.a70f		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+
.a712		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( nt+1 )
.a715		b5 00		lda $00,x	                lda 0,x
.a717		15 01		ora $01,x	                ora 1,x
.a719		d0 d3		bne $a6ee	                bne _loop
.a71b		e6 26		inc $26		                inc tmp3
.a71d		80 b1		bra $a6d0	                bra _wordlist_loop
.a71f						_words_done:
.a71f		68		pla		                pla                     ; dump counter
.a720		e8		inx		                inx
.a721		e8		inx		                inx
.a722		60		rts		z_words:        rts
.a723						xt_wordsize:
.a723		20 75 d8	jsr $d875	                jsr underflow_1
.a726		b5 00		lda $00,x	                lda 0,x
.a728		85 22		sta $22		                sta tmp1
.a72a		b5 01		lda $01,x	                lda 1,x
.a72c		85 23		sta $23		                sta tmp1+1
.a72e		a0 06		ldy #$06	                ldy #6
.a730		b1 22		lda ($22),y	                lda (tmp1),y    ; LSB of z
.a732		88		dey		                dey
.a733		88		dey		                dey
.a734		38		sec		                sec
.a735		f1 22		sbc ($22),y	                sbc (tmp1),y    ; LSB of xt
.a737		95 00		sta $00,x	                sta 0,x
.a739		a0 07		ldy #$07	                ldy #7
.a73b		b1 22		lda ($22),y	                lda (tmp1),y    ; MSB of z
.a73d		88		dey		                dey
.a73e		88		dey		                dey
.a73f		f1 22		sbc ($22),y	                sbc (tmp1),y    ; MSB of xt
.a741		95 01		sta $01,x	                sta 1,x
.a743		60		rts		z_wordsize:     rts
.a744						xt_xor:
.a744		20 7a d8	jsr $d87a	                jsr underflow_2
.a747		b5 00		lda $00,x	                lda 0,x
.a749		55 02		eor $02,x	                eor 2,x
.a74b		95 02		sta $02,x	                sta 2,x
.a74d		b5 01		lda $01,x	                lda 1,x
.a74f		55 03		eor $03,x	                eor 3,x
.a751		95 03		sta $03,x	                sta 3,x
.a753		e8		inx		                inx
.a754		e8		inx		                inx
.a755		60		rts		z_xor:          rts
.a756						xt_case:
.a756						xt_forth_wordlist:
.a756						xt_zero:
.a756		ca		dex		                dex             ; push
.a757		ca		dex		                dex
.a758		74 00		stz $00,x	                stz 0,x
.a75a		74 01		stz $01,x	                stz 1,x
.a75c						z_case:
.a75c						z_forth_wordlist:
.a75c						z_zero:
.a75c		60		rts		                rts
.a75d						xt_zero_equal:
.a75d		20 75 d8	jsr $d875	                jsr underflow_1
.a760		b5 00		lda $00,x	                lda 0,x
.a762		15 01		ora $01,x	                ora 1,x
.a764		f0 02		beq $a768	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.a766		a9 ff		lda #$ff	                lda #$ff        ; else set A inverse of the FALSE (0) we want
.a768						_zero:
.a768		49 ff		eor #$ff	                eor #$ff        ; now just invert
.a76a						_store:
.a76a		95 00		sta $00,x	                sta 0,x
.a76c		95 01		sta $01,x	                sta 1,x
.a76e		60		rts		z_zero_equal:   rts
.a76f						xt_zero_greater:
.a76f		20 75 d8	jsr $d875	                jsr underflow_1
.a772		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a774		b5 01		lda $01,x	                lda 1,x         ; MSB
.a776		30 05		bmi $a77d	                bmi _done       ; TOS is negative, keep FLASE
.a778		15 00		ora $00,x	                ora 0,x
.a77a		f0 01		beq $a77d	                beq _done       ; TOS is zero, keep FALSE
.a77c		88		dey		                dey             ; TOS is postive, make true
.a77d						_done:
.a77d		98		tya		                tya
.a77e		95 00		sta $00,x	                sta 0,x
.a780		95 01		sta $01,x	                sta 1,x
.a782		60		rts		z_zero_greater: rts
.a783						xt_zero_less:
.a783		20 75 d8	jsr $d875	                jsr underflow_1
.a786		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a788		b5 01		lda $01,x	                lda 1,x         ; MSB
.a78a		10 01		bpl $a78d	                bpl _done       ; TOS is positive, so keep FALSE
.a78c		88		dey		                dey             ; TOS is negative, make TRUE
.a78d						_done:
.a78d		98		tya		                tya
.a78e		95 00		sta $00,x	                sta 0,x
.a790		95 01		sta $01,x	                sta 1,x
.a792		60		rts		z_zero_less:    rts
.a793						xt_zero_unequal:
.a793		20 75 d8	jsr $d875	                jsr underflow_1
.a796		b5 00		lda $00,x	                lda 0,x
.a798		15 01		ora $01,x	                ora 1,x
.a79a		f0 02		beq $a79e	                beq _zero
.a79c		a9 ff		lda #$ff	                lda #$ff
.a79e						_zero:
.a79e		95 00		sta $00,x	                sta 0,x
.a7a0		95 01		sta $01,x	                sta 1,x
.a7a2		60		rts		z_zero_unequal: rts
.a7a3						xt_editor_screen_helper:
.a7a3		20 62 8d	jsr $8d62	                jsr xt_dup
.a7a6		20 87 9e	jsr $9e87	                jsr xt_scr
.a7a9		20 3b a1	jsr $a13b	                jsr xt_store
.a7ac		20 6b 85	jsr $856b	                jsr xt_buffer
.a7af						z_editor_screen_helper:
.a7af		60		rts		                rts
.a7b0						xt_editor_enter_screen:
.a7b0		20 a3 a7	jsr $a7a3	                jsr xt_editor_screen_helper
.a7b3		20 e1 8c	jsr $8ce1	                jsr xt_drop
.a7b6		64 2c		stz $2c		                stz editor1
.a7b8						_prompt_loop:
.a7b8		ca		dex		                dex
.a7b9		ca		dex		                dex
.a7ba		a5 2c		lda $2c		                lda editor1
.a7bc		95 00		sta $00,x	                sta 0,x
.a7be		74 01		stz $01,x	                stz 1,x
.a7c0		20 85 a8	jsr $a885	                jsr xt_editor_o
.a7c3		e6 2c		inc $2c		                inc editor1
.a7c5		a9 10		lda #$10	                lda #16
.a7c7		c5 2c		cmp $2c		                cmp editor1
.a7c9		d0 ed		bne $a7b8	                bne _prompt_loop
.a7cb						z_editor_enter_screen:
.a7cb		60		rts		                rts
.a7cc						xt_editor_erase_screen:
.a7cc		20 a3 a7	jsr $a7a3	                jsr xt_editor_screen_helper
.a7cf		ca		dex		                dex
.a7d0		ca		dex		                dex
.a7d1		74 00		stz $00,x	                stz 0,x
.a7d3		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a7d5		95 01		sta $01,x	                sta 1,x
.a7d7		20 cf 8e	jsr $8ecf	                jsr xt_blank
.a7da		20 12 a6	jsr $a612	                jsr xt_update
.a7dd						z_editor_erase_screen:
.a7dd		60		rts		                rts
.a7de						xt_editor_el:
.a7de		20 6c a8	jsr $a86c	                jsr xt_editor_line
.a7e1		ca		dex		                dex
.a7e2		ca		dex		                dex
.a7e3		a9 40		lda #$40	                lda #64
.a7e5		95 00		sta $00,x	                sta 0,x
.a7e7		74 01		stz $01,x	                stz 1,x
.a7e9		20 cf 8e	jsr $8ecf	                jsr xt_blank
.a7ec		20 12 a6	jsr $a612	                jsr xt_update
.a7ef		60		rts		z_editor_el:    rts
.a7f0						xt_editor_l:
.a7f0		ca		dex		                dex             ; Put SCR on the stack.
.a7f1		ca		dex		                dex
.a7f2		a0 02		ldy #$02	                ldy #scr_offset
.a7f4		b1 1e		lda ($1e),y	                lda (up),y
.a7f6		95 00		sta $00,x	                sta 0,x
.a7f8		c8		iny		                iny
.a7f9		b1 1e		lda ($1e),y	                lda (up),y
.a7fb		95 01		sta $01,x	                sta 1,x
.a7fd		20 77 83	jsr $8377	                jsr xt_block    ; Get the current screen.
.a800		20 2a 89	jsr $892a	                jsr xt_cr
.a803		80 08		bra $a80d	                bra _after_screen_msg
.a805						_screen_msg:
>a805		53 63 72 65 65 6e 20 23		                .text "Screen #"
.a80d						_after_screen_msg:
.a80d		20 57 a0	jsr $a057	                jsr sliteral_runtime
>a810		05 a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a814		20 a7 a4	jsr $a4a7	                jsr xt_type
.a817		20 87 9e	jsr $9e87	                jsr xt_scr
.a81a		20 65 8f	jsr $8f65	                jsr xt_fetch
.a81d		ca		dex		                dex
.a81e		ca		dex		                dex
.a81f		a9 04		lda #$04	                lda #4          ; four spaces
.a821		95 00		sta $00,x	                sta 0,x
.a823		74 01		stz $01,x	                stz 1,x
.a825		20 de a4	jsr $a4de	                jsr xt_u_dot_r
.a828		64 26		stz $26		                stz tmp3
.a82a						_line_loop:
.a82a		20 2a 89	jsr $892a	                jsr xt_cr
.a82d		ca		dex		                dex
.a82e		ca		dex		                dex
.a82f		ca		dex		                dex
.a830		ca		dex		                dex
.a831		74 03		stz $03,x	                stz 3,x
.a833		a5 26		lda $26		                lda tmp3
.a835		95 02		sta $02,x	                sta 2,x
.a837		74 01		stz $01,x	                stz 1,x
.a839		a9 02		lda #$02	                lda #2
.a83b		95 00		sta $00,x	                sta 0,x
.a83d		20 de a4	jsr $a4de	                jsr xt_u_dot_r
.a840		20 cc a0	jsr $a0cc	                jsr xt_space
.a843		20 62 8d	jsr $8d62	                jsr xt_dup
.a846		ca		dex		                dex
.a847		ca		dex		                dex
.a848		a9 40		lda #$40	                lda #64
.a84a		95 00		sta $00,x	                sta 0,x
.a84c		74 01		stz $01,x	                stz 1,x
.a84e		20 a7 a4	jsr $a4a7	                jsr xt_type
.a851		18		clc		                clc
.a852		a9 40		lda #$40	                lda #64
.a854		75 00		adc $00,x	                adc 0,x
.a856		95 00		sta $00,x	                sta 0,x
.a858		b5 01		lda $01,x	                lda 1,x
.a85a		69 00		adc #$00	                adc #0      ; Add carry
.a85c		95 01		sta $01,x	                sta 1,x
.a85e		e6 26		inc $26		                inc tmp3
.a860		a5 26		lda $26		                lda tmp3
.a862		c9 10		cmp #$10	                cmp #16
.a864		d0 c4		bne $a82a	                bne _line_loop
.a866		20 2a 89	jsr $892a	                jsr xt_cr
.a869		e8		inx		                inx
.a86a		e8		inx		                inx
.a86b		60		rts		z_editor_l:            rts
.a86c						xt_editor_line:
.a86c		20 75 d8	jsr $d875	                jsr underflow_1
.a86f		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a871						_shift_tos_left:
.a871		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a873		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a875		88		dey		                dey
.a876		d0 f9		bne $a871	                bne _shift_tos_left
.a878		20 87 9e	jsr $9e87	                jsr xt_scr
.a87b		20 65 8f	jsr $8f65	                jsr xt_fetch
.a87e		20 77 83	jsr $8377	                jsr xt_block
.a881		20 c7 99	jsr $99c7	                jsr xt_plus
.a884		60		rts		z_editor_line:  rts
.a885						xt_editor_o:
.a885		20 2a 89	jsr $892a	                jsr xt_cr
.a888		20 62 8d	jsr $8d62	                jsr xt_dup
.a88b		20 4b a3	jsr $a34b	                jsr xt_two
.a88e		20 de a4	jsr $a4de	                jsr xt_u_dot_r
.a891		20 cc a0	jsr $a0cc	                jsr xt_space
.a894		a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a896		20 db 8d	jsr $8ddb	                jsr emit_a
.a899		20 cc a0	jsr $a0cc	                jsr xt_space
.a89c		20 6c a8	jsr $a86c	                jsr xt_editor_line
.a89f		20 62 8d	jsr $8d62	                jsr xt_dup      ; Save a copy of the line address for later.
.a8a2		ca		dex		                dex
.a8a3		ca		dex		                dex
.a8a4		a9 40		lda #$40	                lda #64         ; chars/line
.a8a6		95 00		sta $00,x	                sta 0,x
.a8a8		74 01		stz $01,x	                stz 1,x
.a8aa		20 e2 80	jsr $80e2	                jsr xt_accept
.a8ad		20 62 8d	jsr $8d62	                jsr xt_dup
.a8b0		20 52 96	jsr $9652	                jsr xt_not_rote ; -rot
.a8b3		20 c7 99	jsr $99c7	                jsr xt_plus
.a8b6		ca		dex		                dex
.a8b7		ca		dex		                dex
.a8b8		a9 40		lda #$40	                lda #64         ; chars/line
.a8ba		95 00		sta $00,x	                sta 0,x
.a8bc		74 01		stz $01,x	                stz 1,x
.a8be		20 34 9b	jsr $9b34	                jsr xt_rot
.a8c1		20 34 95	jsr $9534	                jsr xt_minus
.a8c4		20 cf 8e	jsr $8ecf	                jsr xt_blank
.a8c7		20 12 a6	jsr $a612	                jsr xt_update
.a8ca		60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.a8cb						cold_zp_table:
>a8cb	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>a8cd	0002	86 bc				dp:         .word dictionary_start  ; Dictionary Pointer
>a8cf	0004	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>a8d1	0006	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>a8d3	0008	00 02				cib:        .word buffer0           ; address of current input buffer
>a8d5	000a	00 00				ciblen:     .word 0                 ; length of current input buffer
>a8d7	000c	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>a8d9	000e	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>a8db	0010	27 f0				output:     .word kernel_putc       ; vector for EMIT
>a8dd	0012	21 f0				input:      .word kernel_getc       ; vector for KEY
>a8df	0014	00 00				havekey:    .word 0                 ; vector for KEY?
>a8e1	0016	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>a8e3	0018	0a 00				base:       .word 10                ; number radix, default decimal
>a8e5	001a	14 00				nc_limit:   .word 20                ; byte limit for Native Compile size
>a8e7	001c	00 00				uf_strip:   .word 0                 ; flag to strip underflow detection code (0 off)
>a8e9	001e	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>a8eb	0020	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>a8ed	0022					tmp1:       .word ?         ; temporary storage [address hard-coded in tests/ed.fs]
>a8ef	0024					tmp2:       .word ?         ; temporary storage
>a8f1	0026					tmp3:       .word ?         ; temporary storage (especially for print)
>a8f3	0028					tmpdsp:     .word ?         ; temporary DSP (X) storage (two bytes)
>a8f5	002a					tmptos:     .word ?         ; temporary TOS storage
>a8f7	002c					editor1:    .word ?         ; temporary for editors
>a8f9	002e					editor2:    .word ?         ; temporary for editors
>a8fb	0030					editor3:    .word ?         ; temporary for editors
>a8fd	0032					tohold:     .word ?         ; pointer for formatted output
>a8ff	0034					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
.a8ed						cold_zp_table_end:
.a8ed						cold_user_table:
>a8ed	0000	00 00				blk_offset:             .word 0         ; BLK
>a8ef	0002	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
>a8f1	0004	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>a8f2	0005	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.a8f3	0006					wordlists_offset:
>a8f3	0006	86 bc				    .word dictionary_start              ; FORTH-WORDLIST
>a8f5	0008	ce ca				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>a8f7	000a	1e cb				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>a8f9	000c	8d ca				    .word root_dictionary_start         ; ROOT-WORDLIST
>a8fb	000e	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>a903	0016	00 00 00 00 00 00 00 00
>a90b	001e	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.a90c	001f					search_order_offset:
>a90c	001f	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>a914	0027	00
>a915	0028	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>a917	002a	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>a919	002c	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>a91b	002e	11 85				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>a91d	0030	11 85				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.a91f						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0a  ; line feed
=$0d						AscCR   = $0d  ; carriage return
=$1b						AscESC  = $1b  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7f  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a91f						assembler:
.a91f						xt_asm_adc_h:
.a91f		a9 69		lda #$69	                lda #$69
.a921		4c 7a ac	jmp $ac7a	                jmp asm_common
.a924						z_asm_adc_h:
.a924						xt_asm_adc_x:
.a924		a9 7d		lda #$7d	                lda #$7D
.a926		4c 7a ac	jmp $ac7a	                jmp asm_common
.a929						z_asm_adc_x:
.a929						xt_asm_adc_y:
.a929		a9 79		lda #$79	                lda #$79
.a92b		4c 7a ac	jmp $ac7a	                jmp asm_common
.a92e						z_asm_adc_y:
.a92e						xt_asm_adc_z:
.a92e		a9 65		lda #$65	                lda #$65
.a930		4c 7a ac	jmp $ac7a	                jmp asm_common
.a933						z_asm_adc_z:
.a933						xt_asm_adc_zi:
.a933		a9 72		lda #$72	                lda #$72
.a935		4c 7a ac	jmp $ac7a	                jmp asm_common
.a938						z_asm_adc_zi:
.a938						xt_asm_adc_ziy:
.a938		a9 71		lda #$71	                lda #$71
.a93a		4c 7a ac	jmp $ac7a	                jmp asm_common
.a93d						z_asm_adc_ziy:
.a93d						xt_asm_adc_zx:
.a93d		a9 75		lda #$75	                lda #$75
.a93f		4c 7a ac	jmp $ac7a	                jmp asm_common
.a942						z_asm_adc_zx:
.a942						xt_asm_adc_zxi:
.a942		a9 61		lda #$61	                lda #$61
.a944		4c 7a ac	jmp $ac7a	                jmp asm_common
.a947						z_asm_adc_zxi:
.a947						xt_asm_and:
.a947		a9 2d		lda #$2d	                lda #$2D
.a949		4c 7a ac	jmp $ac7a	                jmp asm_common
.a94c						z_asm_and:
.a94c						xt_asm_and_h:
.a94c		a9 29		lda #$29	                lda #$29
.a94e		4c 7a ac	jmp $ac7a	                jmp asm_common
.a951						z_asm_and_h:
.a951						xt_asm_and_x:
.a951		a9 3d		lda #$3d	                lda #$3D
.a953		4c 7a ac	jmp $ac7a	                jmp asm_common
.a956						z_asm_and_x:
.a956						xt_asm_and_y:
.a956		a9 39		lda #$39	                lda #$39
.a958		4c 7a ac	jmp $ac7a	                jmp asm_common
.a95b						z_asm_and_y:
.a95b						xt_asm_and_z:
.a95b		a9 25		lda #$25	                lda #$25
.a95d		4c 7a ac	jmp $ac7a	                jmp asm_common
.a960						z_asm_and_z:
.a960						xt_asm_and_zi:
.a960		a9 32		lda #$32	                lda #$32
.a962		4c 7a ac	jmp $ac7a	                jmp asm_common
.a965						z_asm_and_zi:
.a965						xt_asm_and_ziy:
.a965		a9 31		lda #$31	                lda #$31
.a967		4c 7a ac	jmp $ac7a	                jmp asm_common
.a96a						z_asm_and_ziy:
.a96a						xt_asm_and_zx:
.a96a		a9 35		lda #$35	                lda #$35
.a96c		4c 7a ac	jmp $ac7a	                jmp asm_common
.a96f						z_asm_and_zx:
.a96f						xt_asm_and_zxi:
.a96f		a9 21		lda #$21	                lda #$21
.a971		4c 7a ac	jmp $ac7a	                jmp asm_common
.a974						z_asm_and_zxi:
.a974						xt_asm_asl:
.a974		a9 0e		lda #$0e	                lda #$0E
.a976		4c 7a ac	jmp $ac7a	                jmp asm_common
.a979						z_asm_asl:
.a979						xt_asm_asl_a:
.a979		a9 0a		lda #$0a	                lda #$0A
.a97b		4c 7a ac	jmp $ac7a	                jmp asm_common
.a97e						z_asm_asl_a:
.a97e						xt_asm_asl_x:
.a97e		a9 1e		lda #$1e	                lda #$1E
.a980		4c 7a ac	jmp $ac7a	                jmp asm_common
.a983						z_asm_asl_x:
.a983						xt_asm_asl_z:
.a983		a9 06		lda #$06	                lda #$06
.a985		4c 7a ac	jmp $ac7a	                jmp asm_common
.a988						z_asm_asl_z:
.a988						xt_asm_asl_zx:
.a988		a9 16		lda #$16	                lda #$16
.a98a		4c 7a ac	jmp $ac7a	                jmp asm_common
.a98d						z_asm_asl_zx:
.a98d						xt_asm_bcc:
.a98d		a9 90		lda #$90	                lda #$90
.a98f		4c 7a ac	jmp $ac7a	                jmp asm_common
.a992						z_asm_bcc:
.a992						xt_asm_bcs:
.a992		a9 b0		lda #$b0	                lda #$B0
.a994		a0 02		ldy #$02	                ldy #2
.a996		4c 7a ac	jmp $ac7a	                jmp asm_common
.a999						z_asm_bcs:
.a999						xt_asm_beq:
.a999		a9 f0		lda #$f0	                lda #$F0
.a99b		4c 7a ac	jmp $ac7a	                jmp asm_common
.a99e						z_asm_beq:
.a99e						xt_asm_bit:
.a99e		a9 2c		lda #$2c	                lda #$2C
.a9a0		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9a3						z_asm_bit:
.a9a3						xt_asm_bit_h:
.a9a3		a9 89		lda #$89	                lda #$89
.a9a5		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9a8						z_asm_bit_h:
.a9a8						xt_asm_bit_x:
.a9a8		a9 3c		lda #$3c	                lda #$3C
.a9aa		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9ad						z_asm_bit_x:
.a9ad						xt_asm_bit_z:
.a9ad		a9 24		lda #$24	                lda #$24
.a9af		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9b2						z_asm_bit_z:
.a9b2						xt_asm_bit_zx:
.a9b2		a9 34		lda #$34	                lda #$34
.a9b4		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9b7						z_asm_bit_zx:
.a9b7						xt_asm_bmi:
.a9b7		a9 30		lda #$30	                lda #$30
.a9b9		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9bc						z_asm_bmi:
.a9bc						xt_asm_bne:
.a9bc		a9 d0		lda #$d0	                lda #$D0
.a9be		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9c1						z_asm_bne:
.a9c1						xt_asm_bpl:
.a9c1		a9 10		lda #$10	                lda #$10
.a9c3		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9c6						z_asm_bpl:
.a9c6						xt_asm_bra:
.a9c6		a9 80		lda #$80	                lda #$80
.a9c8		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9cb						z_asm_bra:
.a9cb						xt_asm_brk:
.a9cb		a9 00		lda #$00	                lda #$00
.a9cd		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9d0						z_asm_brk:
.a9d0						xt_asm_bvc:
.a9d0		a9 50		lda #$50	                lda #$50
.a9d2		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9d5						z_asm_bvc:
.a9d5						xt_asm_bvs:
.a9d5		a9 70		lda #$70	                lda #$70
.a9d7		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9da						z_asm_bvs:
.a9da						xt_asm_clc:
.a9da		a9 18		lda #$18	                lda #$18
.a9dc		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9df						z_asm_clc:
.a9df						xt_asm_cld:
.a9df		a9 d8		lda #$d8	                lda #$D8
.a9e1		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9e4						z_asm_cld:
.a9e4						xt_asm_cli:
.a9e4		a9 58		lda #$58	                lda #$58
.a9e6		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9e9						z_asm_cli:
.a9e9						xt_asm_clv:
.a9e9		a9 b8		lda #$b8	                lda #$B8
.a9eb		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9ee						z_asm_clv:
.a9ee						xt_asm_cmp:
.a9ee		a9 cd		lda #$cd	                lda #$CD
.a9f0		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9f3						z_asm_cmp:
.a9f3						xt_asm_cmp_h:
.a9f3		a9 c9		lda #$c9	                lda #$C9
.a9f5		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9f8						z_asm_cmp_h:
.a9f8						xt_asm_cmp_x:
.a9f8		a9 dd		lda #$dd	                lda #$DD
.a9fa		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9fd						z_asm_cmp_x:
.a9fd						xt_asm_cmp_y:
.a9fd		a9 d9		lda #$d9	                lda #$D9
.a9ff		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa02						z_asm_cmp_y:
.aa02						xt_asm_cmp_z:
.aa02		a9 c5		lda #$c5	                lda #$C5
.aa04		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa07						z_asm_cmp_z:
.aa07						xt_asm_cmp_zi:
.aa07		a9 d2		lda #$d2	                lda #$D2
.aa09		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa0c						z_asm_cmp_zi:
.aa0c						xt_asm_cmp_ziy:
.aa0c		a9 d1		lda #$d1	                lda #$D1
.aa0e		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa11						z_asm_cmp_ziy:
.aa11						xt_asm_cmp_zx:
.aa11		a9 d5		lda #$d5	                lda #$D5
.aa13		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa16						z_asm_cmp_zx:
.aa16						xt_asm_cmp_zxi:
.aa16		a9 c1		lda #$c1	                lda #$C1
.aa18		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa1b						z_asm_cmp_zxi:
.aa1b						xt_asm_cpx:
.aa1b		a9 ec		lda #$ec	                lda #$EC
.aa1d		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa20						z_asm_cpx:
.aa20						xt_asm_cpx_h:
.aa20		a9 e0		lda #$e0	                lda #$E0
.aa22		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa25						z_asm_cpx_h:
.aa25						xt_asm_cpx_z:
.aa25		a9 e4		lda #$e4	                lda #$E4
.aa27		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa2a						z_asm_cpx_z:
.aa2a						xt_asm_cpy:
.aa2a		a9 cc		lda #$cc	                lda #$CC
.aa2c		a0 03		ldy #$03	                ldy #3
.aa2e		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa31						z_asm_cpy:
.aa31						xt_asm_cpy_h:
.aa31		a9 c0		lda #$c0	                lda #$C0
.aa33		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa36						z_asm_cpy_h:
.aa36						xt_asm_cpy_z:
.aa36		a9 c4		lda #$c4	                lda #$C4
.aa38		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa3b						z_asm_cpy_z:
.aa3b						xt_asm_dec:
.aa3b		a9 ce		lda #$ce	                lda #$CE
.aa3d		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa40						z_asm_dec:
.aa40						xt_asm_dec_a:
.aa40		a9 3a		lda #$3a	                lda #$3A
.aa42		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa45						z_asm_dec_a:
.aa45						xt_asm_dec_x:
.aa45		a9 de		lda #$de	                lda #$DE
.aa47		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa4a						z_asm_dec_x:
.aa4a						xt_asm_dec_z:
.aa4a		a9 c6		lda #$c6	                lda #$C6
.aa4c		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa4f						z_asm_dec_z:
.aa4f						xt_asm_dec_zx:
.aa4f		a9 d6		lda #$d6	                lda #$D6
.aa51		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa54						z_asm_dec_zx:
.aa54						xt_asm_dex:
.aa54		a9 ca		lda #$ca	                lda #$CA
.aa56		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa59						z_asm_dex:
.aa59						xt_asm_dey:
.aa59		a9 88		lda #$88	                lda #$88
.aa5b		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa5e						z_asm_dey:
.aa5e						xt_asm_eor:
.aa5e		a9 4d		lda #$4d	                lda #$4D
.aa60		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa63						z_asm_eor:
.aa63						xt_asm_eor_h:
.aa63		a9 49		lda #$49	                lda #$49
.aa65		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa68						z_asm_eor_h:
.aa68						xt_asm_eor_x:
.aa68		a9 5d		lda #$5d	                lda #$5D
.aa6a		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa6d						z_asm_eor_x:
.aa6d						xt_asm_eor_y:
.aa6d		a9 59		lda #$59	                lda #$59
.aa6f		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa72						z_asm_eor_y:
.aa72						xt_asm_eor_z:
.aa72		a9 45		lda #$45	                lda #$45
.aa74		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa77						z_asm_eor_z:
.aa77						xt_asm_eor_zi:
.aa77		a9 52		lda #$52	                lda #$52
.aa79		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa7c						z_asm_eor_zi:
.aa7c						xt_asm_eor_ziy:
.aa7c		a9 51		lda #$51	                lda #$51
.aa7e		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa81						z_asm_eor_ziy:
.aa81						xt_asm_eor_zx:
.aa81		a9 55		lda #$55	                lda #$55
.aa83		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa86						z_asm_eor_zx:
.aa86						xt_asm_eor_zxi:
.aa86		a9 41		lda #$41	                lda #$41
.aa88		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa8b						z_asm_eor_zxi:
.aa8b						xt_asm_inc:
.aa8b		a9 ee		lda #$ee	                lda #$EE
.aa8d		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa90						z_asm_inc:
.aa90						xt_asm_inc_a:
.aa90		a9 1a		lda #$1a	                lda #$1A
.aa92		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa95						z_asm_inc_a:
.aa95						xt_asm_inc_x:
.aa95		a9 fe		lda #$fe	                lda #$FE
.aa97		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa9a						z_asm_inc_x:
.aa9a						xt_asm_inc_z:
.aa9a		a9 e6		lda #$e6	                lda #$E6
.aa9c		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa9f						z_asm_inc_z:
.aa9f						xt_asm_inc_zx:
.aa9f		a9 f6		lda #$f6	                lda #$F6
.aaa1		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaa4						z_asm_inc_zx:
.aaa4						xt_asm_inx:
.aaa4		a9 e8		lda #$e8	                lda #$E8
.aaa6		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaa9						z_asm_inx:
.aaa9						xt_asm_iny:
.aaa9		a9 c8		lda #$c8	                lda #$C8
.aaab		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaae						z_asm_iny:
.aaae						xt_asm_jmp:
.aaae		a9 4c		lda #$4c	                lda #$4C
.aab0		4c 7a ac	jmp $ac7a	                jmp asm_common
.aab3						z_asm_jmp:
.aab3						xt_asm_jmp_i:
.aab3		a9 6c		lda #$6c	                lda #$6C
.aab5		4c 7a ac	jmp $ac7a	                jmp asm_common
.aab8						z_asm_jmp_i:
.aab8						xt_asm_jmp_xi:
.aab8		a9 7c		lda #$7c	                lda #$7C
.aaba		4c 7a ac	jmp $ac7a	                jmp asm_common
.aabd						z_asm_jmp_xi:
.aabd						xt_asm_jsr:
.aabd		a9 20		lda #$20	                lda #$20
.aabf		4c 7a ac	jmp $ac7a	                jmp asm_common
.aac2						z_asm_jsr:
.aac2						xt_asm_lda:
.aac2		a9 ad		lda #$ad	                lda #$AD
.aac4		4c 7a ac	jmp $ac7a	                jmp asm_common
.aac7						z_asm_lda:
.aac7						xt_asm_lda_h:
.aac7		a9 a9		lda #$a9	                lda #$A9
.aac9		4c 7a ac	jmp $ac7a	                jmp asm_common
.aacc						z_asm_lda_h:
.aacc						xt_asm_lda_x:
.aacc		a9 bd		lda #$bd	                lda #$BD
.aace		4c 7a ac	jmp $ac7a	                jmp asm_common
.aad1						z_asm_lda_x:
.aad1						xt_asm_lda_y:
.aad1		a9 b9		lda #$b9	                lda #$B9
.aad3		4c 7a ac	jmp $ac7a	                jmp asm_common
.aad6						z_asm_lda_y:
.aad6						xt_asm_lda_z:
.aad6		a9 a5		lda #$a5	                lda #$A5
.aad8		4c 7a ac	jmp $ac7a	                jmp asm_common
.aadb						z_asm_lda_z:
.aadb						xt_asm_lda_zi:
.aadb		a9 b2		lda #$b2	                lda #$B2
.aadd		4c 7a ac	jmp $ac7a	                jmp asm_common
.aae0						z_asm_lda_zi:
.aae0						xt_asm_lda_ziy:
.aae0		a9 b1		lda #$b1	                lda #$B1
.aae2		4c 7a ac	jmp $ac7a	                jmp asm_common
.aae5						z_asm_lda_ziy:
.aae5						xt_asm_lda_zx:
.aae5		a9 b5		lda #$b5	                lda #$B5
.aae7		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaea						z_asm_lda_zx:
.aaea						xt_asm_lda_zxi:
.aaea		a9 a1		lda #$a1	                lda #$A1
.aaec		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaef						z_asm_lda_zxi:
.aaef						xt_asm_ldx:
.aaef		a9 ae		lda #$ae	                lda #$AE
.aaf1		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaf4						z_asm_ldx:
.aaf4						xt_asm_ldx_h:
.aaf4		a9 a2		lda #$a2	                lda #$A2
.aaf6		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaf9						z_asm_ldx_h:
.aaf9						xt_asm_ldx_y:
.aaf9		a9 be		lda #$be	                lda #$BE
.aafb		4c 7a ac	jmp $ac7a	                jmp asm_common
.aafe						z_asm_ldx_y:
.aafe						xt_asm_ldx_z:
.aafe		a9 a6		lda #$a6	                lda #$A6
.ab00		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab03						z_asm_ldx_z:
.ab03						xt_asm_ldx_zy:
.ab03		a9 b6		lda #$b6	                lda #$B6
.ab05		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab08						z_asm_ldx_zy:
.ab08						xt_asm_ldy:
.ab08		a9 ac		lda #$ac	                lda #$AC
.ab0a		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab0d						z_asm_ldy:
.ab0d						xt_asm_ldy_h:
.ab0d		a9 a0		lda #$a0	                lda #$A0
.ab0f		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab12						z_asm_ldy_h:
.ab12						xt_asm_ldy_x:
.ab12		a9 bc		lda #$bc	                lda #$BC
.ab14		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab17						z_asm_ldy_x:
.ab17						xt_asm_ldy_z:
.ab17		a9 a4		lda #$a4	                lda #$A4
.ab19		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab1c						z_asm_ldy_z:
.ab1c						xt_asm_ldy_zx:
.ab1c		a9 b4		lda #$b4	                lda #$B4
.ab1e		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab21						z_asm_ldy_zx:
.ab21						xt_asm_lsr:
.ab21		a9 4e		lda #$4e	                lda #$4E
.ab23		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab26						z_asm_lsr:
.ab26						xt_asm_lsr_a:
.ab26		a9 4a		lda #$4a	                lda #$4A
.ab28		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab2b						z_asm_lsr_a:
.ab2b						xt_asm_lsr_x:
.ab2b		a9 5e		lda #$5e	                lda #$5E
.ab2d		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab30						z_asm_lsr_x:
.ab30						xt_asm_lsr_z:
.ab30		a9 46		lda #$46	                lda #$46
.ab32		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab35						z_asm_lsr_z:
.ab35						xt_asm_lsr_zx:
.ab35		a9 56		lda #$56	                lda #$56
.ab37		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab3a						z_asm_lsr_zx:
.ab3a						xt_asm_nop:
.ab3a		a9 ea		lda #$ea	                lda #$EA
.ab3c		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab3f						z_asm_nop:
.ab3f						xt_asm_ora:
.ab3f		a9 0d		lda #$0d	                lda #$0D
.ab41		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab44						z_asm_ora:
.ab44						xt_asm_ora_h:
.ab44		a9 09		lda #$09	                lda #$09
.ab46		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab49						z_asm_ora_h:
.ab49						xt_asm_ora_x:
.ab49		a9 1d		lda #$1d	                lda #$1D
.ab4b		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab4e						z_asm_ora_x:
.ab4e						xt_asm_ora_y:
.ab4e		a9 19		lda #$19	                lda #$19
.ab50		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab53						z_asm_ora_y:
.ab53						xt_asm_ora_z:
.ab53		a9 05		lda #$05	                lda #$05
.ab55		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab58						z_asm_ora_z:
.ab58						xt_asm_ora_zi:
.ab58		a9 12		lda #$12	                lda #$12
.ab5a		a0 02		ldy #$02	                ldy #2
.ab5c		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab5f						z_asm_ora_zi:
.ab5f						xt_asm_ora_ziy:
.ab5f		a9 11		lda #$11	                lda #$11
.ab61		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab64						z_asm_ora_ziy:
.ab64						xt_asm_ora_zx:
.ab64		a9 15		lda #$15	                lda #$15
.ab66		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab69						z_asm_ora_zx:
.ab69						xt_asm_ora_zxi:
.ab69		a9 01		lda #$01	                lda #$01
.ab6b		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab6e						z_asm_ora_zxi:
.ab6e						xt_asm_pha:
.ab6e		a9 48		lda #$48	                lda #$48
.ab70		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab73						z_asm_pha:
.ab73						xt_asm_php:
.ab73		a9 08		lda #$08	                lda #$08
.ab75		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab78						z_asm_php:
.ab78						xt_asm_phx:
.ab78		a9 da		lda #$da	                lda #$DA
.ab7a		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab7d						z_asm_phx:
.ab7d						xt_asm_phy:
.ab7d		a9 5a		lda #$5a	                lda #$5A
.ab7f		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab82						z_asm_phy:
.ab82						xt_asm_pla:
.ab82		a9 68		lda #$68	                lda #$68
.ab84		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab87						z_asm_pla:
.ab87						xt_asm_plp:
.ab87		a9 28		lda #$28	                lda #$28
.ab89		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab8c						z_asm_plp:
.ab8c						xt_asm_plx:
.ab8c		a9 fa		lda #$fa	                lda #$FA
.ab8e		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab91						z_asm_plx:
.ab91						xt_asm_ply:
.ab91		a9 7a		lda #$7a	                lda #$7A
.ab93		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab96						z_asm_ply:
.ab96						xt_asm_rol:
.ab96		a9 2e		lda #$2e	                lda #$2E
.ab98		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab9b						z_asm_rol:
.ab9b						xt_asm_rol_a:
.ab9b		a9 2a		lda #$2a	                lda #$2A
.ab9d		4c 7a ac	jmp $ac7a	                jmp asm_common
.aba0						z_asm_rol_a:
.aba0						xt_asm_rol_x:
.aba0		a9 3e		lda #$3e	                lda #$3E
.aba2		4c 7a ac	jmp $ac7a	                jmp asm_common
.aba5						z_asm_rol_x:
.aba5						xt_asm_rol_z:
.aba5		a9 26		lda #$26	                lda #$26
.aba7		4c 7a ac	jmp $ac7a	                jmp asm_common
.abaa						z_asm_rol_z:
.abaa						xt_asm_rol_zx:
.abaa		a9 36		lda #$36	                lda #$36
.abac		4c 7a ac	jmp $ac7a	                jmp asm_common
.abaf						z_asm_rol_zx:
.abaf						xt_asm_ror:
.abaf		a9 6e		lda #$6e	                lda #$6E
.abb1		4c 7a ac	jmp $ac7a	                jmp asm_common
.abb4						z_asm_ror:
.abb4						xt_asm_ror_a:
.abb4		a9 6a		lda #$6a	                lda #$6A
.abb6		4c 7a ac	jmp $ac7a	                jmp asm_common
.abb9						z_asm_ror_a:
.abb9						xt_asm_ror_x:
.abb9		a9 7e		lda #$7e	                lda #$7E
.abbb		4c 7a ac	jmp $ac7a	                jmp asm_common
.abbe						z_asm_ror_x:
.abbe						xt_asm_ror_z:
.abbe		a9 66		lda #$66	                lda #$66
.abc0		4c 7a ac	jmp $ac7a	                jmp asm_common
.abc3						z_asm_ror_z:
.abc3						xt_asm_ror_zx:
.abc3		a9 76		lda #$76	                lda #$76
.abc5		4c 7a ac	jmp $ac7a	                jmp asm_common
.abc8						z_asm_ror_zx:
.abc8						xt_asm_rti:
.abc8		a9 40		lda #$40	                lda #$40
.abca		4c 7a ac	jmp $ac7a	                jmp asm_common
.abcd						z_asm_rti:
.abcd						xt_asm_rts:
.abcd		a9 60		lda #$60	                lda #$60
.abcf		4c 7a ac	jmp $ac7a	                jmp asm_common
.abd2						z_asm_rts:
.abd2						xt_asm_sbc:
.abd2		a9 ed		lda #$ed	                lda #$ED
.abd4		4c 7a ac	jmp $ac7a	                jmp asm_common
.abd7						z_asm_sbc:
.abd7						xt_asm_sbc_h:
.abd7		a9 e9		lda #$e9	                lda #$E9
.abd9		4c 7a ac	jmp $ac7a	                jmp asm_common
.abdc						z_asm_sbc_h:
.abdc						xt_asm_sbc_x:
.abdc		a9 fd		lda #$fd	                lda #$FD
.abde		4c 7a ac	jmp $ac7a	                jmp asm_common
.abe1						z_asm_sbc_x:
.abe1						xt_asm_sbc_y:
.abe1		a9 f9		lda #$f9	                lda #$F9
.abe3		4c 7a ac	jmp $ac7a	                jmp asm_common
.abe6						z_asm_sbc_y:
.abe6						xt_asm_sbc_z:
.abe6		a9 e5		lda #$e5	                lda #$E5
.abe8		4c 7a ac	jmp $ac7a	                jmp asm_common
.abeb						z_asm_sbc_z:
.abeb						xt_asm_sbc_zi:
.abeb		a9 f2		lda #$f2	                lda #$F2
.abed		4c 7a ac	jmp $ac7a	                jmp asm_common
.abf0						z_asm_sbc_zi:
.abf0						xt_asm_sbc_ziy:
.abf0		a9 f1		lda #$f1	                lda #$F1
.abf2		4c 7a ac	jmp $ac7a	                jmp asm_common
.abf5						z_asm_sbc_ziy:
.abf5						xt_asm_sbc_zx:
.abf5		a9 f5		lda #$f5	                lda #$F5
.abf7		4c 7a ac	jmp $ac7a	                jmp asm_common
.abfa						z_asm_sbc_zx:
.abfa						xt_asm_sbc_zxi:
.abfa		a9 e1		lda #$e1	                lda #$E1
.abfc		80 7c		bra $ac7a	                bra asm_common  ; <-- limit for BRA instead of JMP
.abfe						z_asm_sbc_zxi:
.abfe						xt_asm_sec:
.abfe		a9 38		lda #$38	                lda #$38
.ac00		80 78		bra $ac7a	                bra asm_common
.ac02						z_asm_sec:
.ac02						xt_asm_sed:
.ac02		a9 f8		lda #$f8	                lda #$F8
.ac04		80 74		bra $ac7a	                bra asm_common
.ac06						z_asm_sed:
.ac06						xt_asm_sei:
.ac06		a9 78		lda #$78	                lda #$78
.ac08		80 70		bra $ac7a	                bra asm_common
.ac0a						z_asm_sei:
.ac0a						xt_asm_sta:
.ac0a		a9 8d		lda #$8d	                lda #$8D
.ac0c		80 6c		bra $ac7a	                bra asm_common
.ac0e						z_asm_sta:
.ac0e						xt_asm_sta_x:
.ac0e		a9 9d		lda #$9d	                lda #$9D
.ac10		80 68		bra $ac7a	                bra asm_common
.ac12						z_asm_sta_x:
.ac12						xt_asm_sta_y:
.ac12		a9 99		lda #$99	                lda #$99
.ac14		80 64		bra $ac7a	                bra asm_common
.ac16						z_asm_sta_y:
.ac16						xt_asm_sta_z:
.ac16		a9 85		lda #$85	                lda #$85
.ac18		80 60		bra $ac7a	                bra asm_common
.ac1a						z_asm_sta_z:
.ac1a						xt_asm_sta_zi:
.ac1a		a9 92		lda #$92	                lda #$92
.ac1c		80 5c		bra $ac7a	                bra asm_common
.ac1e						z_asm_sta_zi:
.ac1e						xt_asm_sta_ziy:
.ac1e		a9 91		lda #$91	                lda #$91
.ac20		80 58		bra $ac7a	                bra asm_common
.ac22						z_asm_sta_ziy:
.ac22						xt_asm_sta_zx:
.ac22		a9 95		lda #$95	                lda #$95
.ac24		80 54		bra $ac7a	                bra asm_common
.ac26						z_asm_sta_zx:
.ac26						xt_asm_sta_zxi:
.ac26		a9 81		lda #$81	                lda #$81
.ac28		80 50		bra $ac7a	                bra asm_common
.ac2a						z_asm_sta_zxi:
.ac2a						xt_asm_stx:
.ac2a		a9 8e		lda #$8e	                lda #$8E
.ac2c		80 4c		bra $ac7a	                bra asm_common
.ac2e						z_asm_stx:
.ac2e						xt_asm_stx_z:
.ac2e		a9 86		lda #$86	                lda #$86
.ac30		80 48		bra $ac7a	                bra asm_common
.ac32						z_asm_stx_z:
.ac32						xt_asm_stx_zy:
.ac32		a9 96		lda #$96	                lda #$96
.ac34		80 44		bra $ac7a	                bra asm_common
.ac36						z_asm_stx_zy:
.ac36						xt_asm_sty:
.ac36		a9 8c		lda #$8c	                lda #$8C
.ac38		80 40		bra $ac7a	                bra asm_common
.ac3a						z_asm_sty:
.ac3a						xt_asm_sty_z:
.ac3a		a9 84		lda #$84	                lda #$84
.ac3c		80 3c		bra $ac7a	                bra asm_common
.ac3e						z_asm_sty_z:
.ac3e						xt_asm_sty_zx:
.ac3e		a9 94		lda #$94	                lda #$94
.ac40		80 38		bra $ac7a	                bra asm_common
.ac42						z_asm_sty_zx:
.ac42						xt_asm_stz:
.ac42		a9 9c		lda #$9c	                lda #$9C
.ac44		80 34		bra $ac7a	                bra asm_common
.ac46						z_asm_stz:
.ac46						xt_asm_stz_x:
.ac46		a9 9e		lda #$9e	                lda #$9E
.ac48		80 30		bra $ac7a	                bra asm_common
.ac4a						z_asm_stz_x:
.ac4a						xt_asm_stz_z:
.ac4a		a9 64		lda #$64	                lda #$64
.ac4c		80 2c		bra $ac7a	                bra asm_common
.ac4e						z_asm_stz_z:
.ac4e						xt_asm_stz_zx:
.ac4e		a9 74		lda #$74	                lda #$74
.ac50		80 28		bra $ac7a	                bra asm_common
.ac52						z_asm_stz_zx:
.ac52						xt_asm_tax:
.ac52		a9 aa		lda #$aa	                lda #$AA
.ac54		80 24		bra $ac7a	                bra asm_common
.ac56						z_asm_tax:
.ac56						xt_asm_tay:
.ac56		a9 a8		lda #$a8	                lda #$A8
.ac58		80 20		bra $ac7a	                bra asm_common
.ac5a						z_asm_tay:
.ac5a						xt_asm_trb:
.ac5a		a9 1c		lda #$1c	                lda #$1C
.ac5c		80 1c		bra $ac7a	                bra asm_common
.ac5e						z_asm_trb:
.ac5e						xt_asm_trb_z:
.ac5e		a9 14		lda #$14	                lda #$14
.ac60		80 18		bra $ac7a	                bra asm_common
.ac62						z_asm_trb_z:
.ac62						xt_asm_tsb:
.ac62		a9 0c		lda #$0c	                lda #$0C
.ac64		80 14		bra $ac7a	                bra asm_common
.ac66						z_asm_tsb:
.ac66						xt_asm_tsb_z:
.ac66		a9 04		lda #$04	                lda #$04
.ac68		80 10		bra $ac7a	                bra asm_common
.ac6a						z_asm_tsb_z:
.ac6a						xt_asm_tsx:
.ac6a		a9 ba		lda #$ba	                lda #$BA
.ac6c		80 0c		bra $ac7a	                bra asm_common
.ac6e						z_asm_tsx:
.ac6e						xt_asm_txa:
.ac6e		a9 8a		lda #$8a	                lda #$8A
.ac70		80 08		bra $ac7a	                bra asm_common
.ac72						z_asm_txa:
.ac72						xt_asm_txs:
.ac72		a9 9a		lda #$9a	                lda #$9A
.ac74		80 04		bra $ac7a	                bra asm_common
.ac76						z_asm_txs:
.ac76						xt_asm_tya:
.ac76		a9 98		lda #$98	                lda #$98
.ac78		80 00		bra $ac7a	                bra asm_common
.ac7a						z_asm_tya:
.ac7a						asm_common:
.ac7a		a8		tay		                tay
.ac7b		20 2d d7	jsr $d72d	                jsr cmpl_a
.ac7e		a9 2a		lda #$2a	                lda #<oc_index_table
.ac80		85 24		sta $24		                sta tmp2
.ac82		a9 af		lda #$af	                lda #>oc_index_table
.ac84		85 25		sta $25		                sta tmp2+1
.ac86		98		tya		                tya             ; retrieve opcode
.ac87		0a		asl a		                asl             ; times two for offset
.ac88		90 02		bcc $ac8c	                bcc +
.ac8a		e6 25		inc $25		                inc tmp2+1
.ac8c						+
.ac8c		a8		tay		                tay             ; use Y as the index
.ac8d		b1 24		lda ($24),y	                lda (tmp2),y    ; LSB
.ac8f		85 26		sta $26		                sta tmp3
.ac91		c8		iny		                iny
.ac92		b1 24		lda ($24),y	                lda (tmp2),y    ; MSB
.ac94		85 27		sta $27		                sta tmp3+1
.ac96		b2 26		lda ($26)	                lda (tmp3)      ; get "lengths byte"
.ac98		2a		rol a		                rol
.ac99		2a		rol a		                rol
.ac9a		2a		rol a		                rol             ; Three times because we go through Carry
.ac9b		29 03		and #$03	                and #%00000011
.ac9d		a8		tay		                tay
.ac9e		88		dey		                dey
.ac9f		f0 12		beq $acb3	                beq _done
.aca1		20 75 d8	jsr $d875	                jsr underflow_1
.aca4		b5 00		lda $00,x	                lda 0,x
.aca6		20 2d d7	jsr $d72d	                jsr cmpl_a      ; does not use Y
.aca9		88		dey		                dey
.acaa		f0 05		beq $acb1	                beq _done_drop
.acac		b5 01		lda $01,x	                lda 1,x
.acae		20 2d d7	jsr $d72d	                jsr cmpl_a      ; Fall through to _done_drop
.acb1						_done_drop:
.acb1		e8		inx		                inx
.acb2		e8		inx		                inx             ; Fall through to _done
.acb3						_done:
.acb3		60		rts		                rts             ; Returns to original caller
.acb4						xt_asm_push_a:
.acb4		a0 00		ldy #$00	                ldy #0
.acb6						_loop:
.acb6		b9 c4 ac	lda $acc4,y	                lda asm_push_a_data,y
.acb9		c9 ff		cmp #$ff	                cmp #$FF
.acbb		f0 06		beq $acc3	                beq _done
.acbd		20 2d d7	jsr $d72d	                jsr cmpl_a      ; does not change Y
.acc0		c8		iny		                iny
.acc1		80 f3		bra $acb6	                bra _loop
.acc3						_done:
.acc3						z_asm_push_a:
.acc3		60		rts		                rts
.acc4						asm_push_a_data:
>acc4		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acca		ff				        .byte $FF               ; terminator
.accb						xt_asm_back_jump:
.accb						z_asm_back_jump:
.accb		60		rts		                rts
.accc						xt_asm_back_branch:
.accc		20 57 91	jsr $9157	                jsr xt_here             ; ( addr-l addr-h )
.accf		20 34 95	jsr $9534	                jsr xt_minus            ; ( offset )
.acd2		3a		dec a		                dea
.acd3		3a		dec a		                dea
.acd4						z_asm_back_branch:
.acd4		60		rts		                rts
.acd5						assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acd5						disassembler:
.acd5		20 2a 89	jsr $892a	                jsr xt_cr       ; ( addr u )
.acd8						_byte_loop:
.acd8		20 77 98	jsr $9877	                jsr xt_over     ; ( addr u addr )
.acdb		20 d2 a4	jsr $a4d2	                jsr xt_u_dot    ; ( addr u )
.acde		20 cc a0	jsr $a0cc	                jsr xt_space
.ace1		a9 2a		lda #$2a	                lda #<oc_index_table
.ace3		85 24		sta $24		                sta tmp2
.ace5		a9 af		lda #$af	                lda #>oc_index_table
.ace7		85 25		sta $25		                sta tmp2+1
.ace9		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.aceb		85 34		sta $34		                sta scratch     ; Save opcode
.aced		0a		asl a		                asl             ; multiply by two for offset
.acee		90 02		bcc $acf2	                bcc +
.acf0		e6 25		inc $25		                inc tmp2+1      ; we're on second page
.acf2						+
.acf2		a8		tay		                tay             ; use Y as the index
.acf3		b1 24		lda ($24),y	                lda (tmp2),y    ; LSB
.acf5		85 26		sta $26		                sta tmp3
.acf7		48		pha		                pha
.acf8		c8		iny		                iny
.acf9		b1 24		lda ($24),y	                lda (tmp2),y    ; MSB
.acfb		85 27		sta $27		                sta tmp3+1
.acfd		48		pha		                pha
.acfe		b2 26		lda ($26)	                lda (tmp3)
.ad00		a8		tay		                tay                     ; save copy of lengths byte
.ad01		10 3c		bpl $ad3f	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.ad03		20 56 a7	jsr $a756	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ad06		f6 04		inc $04,x	                inc 4,x
.ad08		d0 02		bne $ad0c	                bne +
.ad0a		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ad0c						+
.ad0c		b5 02		lda $02,x	                lda 2,x
.ad0e		d0 02		bne $ad12	                bne +
.ad10		d6 03		dec $03,x	                dec 3,x
.ad12						+
.ad12		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.ad14		a1 04		lda ($04,x)	                lda (4,x)
.ad16		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.ad18		85 35		sta $35		                sta scratch+1           ; Save a copy in the scratch buffer
.ad1a		98		tya		                tya                     ; retrieve copy of lengths byte
.ad1b		2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad1c		10 14		bpl $ad32	                bpl _print_operand
.ad1e		f6 04		inc $04,x	                inc 4,x
.ad20		d0 02		bne $ad24	                bne +
.ad22		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad24						+
.ad24		b5 02		lda $02,x	                lda 2,x
.ad26		d0 02		bne $ad2a	                bne +
.ad28		d6 03		dec $03,x	                dec 3,x
.ad2a						+
.ad2a		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad2c		a1 04		lda ($04,x)	                lda (4,x)
.ad2e		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad30		85 36		sta $36		                sta scratch+2           ; Save a copy in the scratch buffer
.ad32						_print_operand:
.ad32		ca		dex		                dex
.ad33		ca		dex		                dex
.ad34		a9 05		lda #$05	                lda #5
.ad36		95 00		sta $00,x	                sta 0,x
.ad38		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad3a		20 de a4	jsr $a4de	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad3d		80 0b		bra $ad4a	                bra _print_mnemonic
.ad3f						_no_operand:
.ad3f		ca		dex		                dex
.ad40		ca		dex		                dex
.ad41		a9 05		lda #$05	                lda #5
.ad43		95 00		sta $00,x	                sta 0,x
.ad45		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad47		20 d2 a0	jsr $a0d2	                jsr xt_spaces           ; ( addr u )
.ad4a						_print_mnemonic:
.ad4a		20 cc a0	jsr $a0cc	                jsr xt_space
.ad4d		ca		dex		                dex
.ad4e		ca		dex		                dex                     ; ( addr u ? )
.ad4f		68		pla		                pla                     ; MSB
.ad50		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad52		68		pla		                pla                     ; LSB
.ad53		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad55		20 16 89	jsr $8916	                jsr xt_count            ; ( addr u addr-o u-o )
.ad58		74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad5a		b5 00		lda $00,x	                lda 0,x
.ad5c		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad5e		95 00		sta $00,x	                sta 0,x
.ad60		20 a7 a4	jsr $a4a7	                jsr xt_type             ; ( addr u )
.ad63		a5 34		lda $34		                lda scratch
.ad65		c9 20		cmp #$20	                cmp #$20
.ad67		d0 4e		bne $adb7	                bne _not_jsr
.ad69		ca		dex		                dex
.ad6a		ca		dex		                dex
.ad6b		a9 05		lda #$05	                lda #5
.ad6d		95 00		sta $00,x	                sta 0,x
.ad6f		74 01		stz $01,x	                stz 1,x
.ad71		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.ad74		a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.ad76		b9 a3 ad	lda $ada3,y	_check_handler: lda _special_handlers,y
.ad79		c5 35		cmp $35		                cmp scratch+1
.ad7b		d0 07		bne $ad84	                bne _next_handler
.ad7d		b9 a4 ad	lda $ada4,y	                lda _special_handlers+1,y
.ad80		c5 36		cmp $36		                cmp scratch+2
.ad82		f0 0c		beq $ad90	                beq _run_handler
.ad84		88		dey		_next_handler:  dey
.ad85		88		dey		                dey
.ad86		88		dey		                dey
.ad87		88		dey		                dey
.ad88		10 ec		bpl $ad76	                bpl _check_handler
.ad8a						_not_special:
.ad8a		20 da ae	jsr $aeda	                jsr disasm_jsr
.ad8d		4c 21 ae	jmp $ae21	                jmp _printing_done
.ad90						_run_handler:
.ad90		b9 a5 ad	lda $ada5,y	                lda _special_handlers+2,y
.ad93		85 37		sta $37		                sta scratch+3
.ad95		b9 a6 ad	lda $ada6,y	                lda _special_handlers+3,y
.ad98		85 38		sta $38		                sta scratch+4
.ad9a		20 a0 ad	jsr $ada0	                jsr _dispatch_handler
.ad9d		4c 21 ae	jmp $ae21	                jmp _printing_done
.ada0						_dispatch_handler:
.ada0		6c 37 00	jmp ($0037)	                jmp (scratch+3)
.ada3						_special_handlers:
>ada3		79 93 bc ae			    .word literal_runtime,      disasm_literal
>ada7		57 a0 67 ae			    .word sliteral_runtime,     disasm_sliteral
>adab		01 92 9e ae			    .word zero_branch_runtime,  disasm_0branch
>adaf		f7 91 aa ae			    .word zero_test_runtime,    disasm_0test
>adb3		63 8b b2 ae			    .word do_runtime,           disasm_do
.adb7						_end_handlers:
.adb7						_not_jsr:
.adb7		c9 4c		cmp #$4c	                cmp #$4C
.adb9		d0 2c		bne $ade7	                bne _not_jmp
.adbb		a5 35		lda $35		                lda scratch+1   ; Copy the pointer.
.adbd		85 37		sta $37		                sta scratch+3
.adbf		a5 36		lda $36		                lda scratch+2
.adc1		85 38		sta $38		                sta scratch+4
.adc3		b2 37		lda ($37)	                lda (scratch+3)
.adc5		c9 20		cmp #$20	                cmp #$20 ; check for JSR
.adc7		d0 58		bne $ae21	                bne _printing_done
.adc9		e6 37		inc $37		                inc scratch+3
.adcb		d0 02		bne $adcf	                bne +
.adcd		e6 38		inc $38		                inc scratch+4
.adcf						+
.adcf		b2 37		lda ($37)	                lda (scratch+3)
.add1		c9 57		cmp #$57	                cmp #<sliteral_runtime
.add3		d0 4c		bne $ae21	                bne _printing_done
.add5		e6 37		inc $37		                inc scratch+3
.add7		d0 02		bne $addb	                bne +
.add9		e6 38		inc $38		                inc scratch+4
.addb						+
.addb		b2 37		lda ($37)	                lda (scratch+3)
.addd		c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.addf		d0 40		bne $ae21	                bne _printing_done
.ade1		20 3d ae	jsr $ae3d	                jsr disasm_sliteral_jump
.ade4		4c 21 ae	jmp $ae21	                jmp _printing_done
.ade7						_not_jmp:
.ade7		c9 80		cmp #$80	                cmp #$80            ; is it bra?
.ade9		f0 06		beq $adf1	                beq _is_rel
.adeb		29 1f		and #$1f	                and #$1f
.aded		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.adef		d0 30		bne $ae21	                bne _printing_done
.adf1						_is_rel:
.adf1		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.adf3		ca		dex		                dex
.adf4		ca		dex		                dex
.adf5		74 01		stz $01,x	                stz 1,x
.adf7		a5 35		lda $35		                lda scratch+1
.adf9		95 00		sta $00,x	                sta 0,x
.adfb		10 04		bpl $ae01	                bpl +
.adfd		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.adff		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.ae01		38		sec		+               sec                 ; start counting from address after opcode
.ae02		75 04		adc $04,x	                adc 4,x
.ae04		95 00		sta $00,x	                sta 0,x
.ae06		b5 01		lda $01,x	                lda 1,x
.ae08		75 05		adc $05,x	                adc 5,x
.ae0a		95 01		sta $01,x	                sta 1,x
.ae0c		5a		phy		                phy                 ; save the direction indicator
.ae0d		ca		dex		                dex
.ae0e		ca		dex		                dex
.ae0f		a9 09		lda #$09	                lda #9
.ae11		95 00		sta $00,x	                sta 0,x
.ae13		74 01		stz $01,x	                stz 1,x
.ae15		20 de a4	jsr $a4de	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.ae18		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.ae1a		20 db 8d	jsr $8ddb	                jsr emit_a
.ae1d		68		pla		                pla
.ae1e		20 db 8d	jsr $8ddb	                jsr emit_a
.ae21						_printing_done:
.ae21		20 2a 89	jsr $892a	                jsr xt_cr
.ae24		f6 02		inc $02,x	                inc 2,x
.ae26		d0 02		bne $ae2a	                bne +
.ae28		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae2a						+
.ae2a		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae2d		b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae2f		15 01		ora $01,x	                ora 1,x
.ae31		f0 07		beq $ae3a	                beq _done
.ae33		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae35		30 03		bmi $ae3a	                bmi _done
.ae37		4c d8 ac	jmp $acd8	                jmp _byte_loop          ; out of range for BRA
.ae3a						_done:
.ae3a		4c 54 a3	jmp $a354	                jmp xt_two_drop         ; JSR/RTS
.ae3d						disasm_sliteral_jump:
.ae3d		20 5c a1	jsr $a15c	                jsr xt_swap
.ae40		ca		dex		                dex
.ae41		ca		dex		                dex
.ae42		a5 35		lda $35		                lda scratch+1
.ae44		95 00		sta $00,x	                sta 0,x
.ae46		a5 36		lda $36		                lda scratch+2
.ae48		95 01		sta $01,x	                sta 1,x
.ae4a		20 5c a1	jsr $a15c	                jsr xt_swap
.ae4d		20 34 95	jsr $9534	                jsr xt_minus
.ae50		20 f5 97	jsr $97f5	                jsr xt_one_minus
.ae53		20 34 95	jsr $9534	                jsr xt_minus
.ae56		ca		dex		                dex
.ae57		ca		dex		                dex
.ae58		a5 35		lda $35		                lda scratch+1
.ae5a		95 00		sta $00,x	                sta 0,x
.ae5c		a5 36		lda $36		                lda scratch+2
.ae5e		95 01		sta $01,x	                sta 1,x
.ae60		20 f5 97	jsr $97f5	                jsr xt_one_minus
.ae63		20 5c a1	jsr $a15c	                jsr xt_swap ; ( new_addr new_n )
.ae66		60		rts		                rts
.ae67						disasm_sliteral:
.ae67		a9 53		lda #$53	                lda #'S'
.ae69		20 db 8d	jsr $8ddb	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae6c		a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.ae6e		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.ae71		20 5c a1	jsr $a15c	                jsr xt_swap             ; switch to (u addr)
.ae74		20 01 98	jsr $9801	                jsr xt_one_plus
.ae77		20 62 8d	jsr $8d62	                jsr xt_dup
.ae7a		20 65 8f	jsr $8f65	                jsr xt_fetch
.ae7d		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; Print the address of the string
.ae80		20 4b a3	jsr $a34b	                jsr xt_two
.ae83		20 c7 99	jsr $99c7	                jsr xt_plus
.ae86		20 62 8d	jsr $8d62	                jsr xt_dup
.ae89		20 46 9a	jsr $9a46	                jsr xt_question         ; Print the length of the string
.ae8c		20 01 98	jsr $9801	                jsr xt_one_plus
.ae8f		20 5c a1	jsr $a15c	                jsr xt_swap            ; ( addr+4 u )
.ae92		ca		dex		                dex
.ae93		ca		dex		                dex
.ae94		a9 04		lda #$04	                lda #4
.ae96		95 00		sta $00,x	                sta 0,x
.ae98		74 01		stz $01,x	                stz 1,x
.ae9a		20 34 95	jsr $9534	                jsr xt_minus            ; ( addr+4 u-4 )
.ae9d		60		rts		                rts
.ae9e						disasm_0branch:
.ae9e		a9 30		lda #$30	                lda #'0'
.aea0		20 db 8d	jsr $8ddb	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.aea3						disasm_branch:
.aea3		a9 0e		lda #$0e	                lda #str_disasm_bra
.aea5		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf ; "BRANCH "
.aea8		80 17		bra $aec1	                bra disasm_print_literal
.aeaa						disasm_0test:
.aeaa		a9 0f		lda #$0f	                lda #str_disasm_0test
.aeac		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.aeaf		4c db 8d	jmp $8ddb	                jmp emit_a
.aeb2						disasm_do:
.aeb2		a9 44		lda #$44	                lda #'D'
.aeb4		20 db 8d	jsr $8ddb	                jsr emit_a
.aeb7		a9 4f		lda #$4f	                lda #'O'
.aeb9		4c db 8d	jmp $8ddb	                jmp emit_a
.aebc						disasm_literal:
.aebc		a9 0c		lda #$0c	                lda #str_disasm_lit
.aebe		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf ; "LITERAL "
.aec1						disasm_print_literal:
.aec1		20 5c a1	jsr $a15c	                jsr xt_swap ; switch to (u addr)
.aec4		20 01 98	jsr $9801	                jsr xt_one_plus
.aec7		20 62 8d	jsr $8d62	                jsr xt_dup
.aeca		20 46 9a	jsr $9a46	                jsr xt_question ; Print the value at the address
.aecd		20 01 98	jsr $9801	                jsr xt_one_plus
.aed0		20 5c a1	jsr $a15c	                jsr xt_swap ; (addr+2 u)
.aed3		20 f5 97	jsr $97f5	                jsr xt_one_minus
.aed6		20 f5 97	jsr $97f5	                jsr xt_one_minus ; (addr+2 u-2)
.aed9		60		rts		                rts
.aeda						disasm_jsr:
.aeda		ca		dex		                dex
.aedb		ca		dex		                dex
.aedc		a5 35		lda $35		                lda scratch+1
.aede		95 00		sta $00,x	                sta 0,x
.aee0		a5 36		lda $36		                lda scratch+2
.aee2		95 01		sta $01,x	                sta 1,x
.aee4		20 59 92	jsr $9259	                jsr xt_int_to_name
.aee7		b5 00		lda $00,x	                lda 0,x
.aee9		15 01		ora $01,x	                ora 1,x
.aeeb		f0 07		beq $aef4	                beq _disasm_no_nt
.aeed		20 e2 95	jsr $95e2	                jsr xt_name_to_string
.aef0		20 a7 a4	jsr $a4a7	                jsr xt_type
.aef3		60		rts		                rts
.aef4						_disasm_no_nt:
.aef4		20 e1 8c	jsr $8ce1	                jsr xt_drop ; the 0 indicating no name token
.aef7		ca		dex		                dex
.aef8		ca		dex		                dex
.aef9		a5 35		lda $35		                lda scratch+1
.aefb		95 00		sta $00,x	                sta 0,x
.aefd		a5 36		lda $36		                lda scratch+2
.aeff		95 01		sta $01,x	                sta 1,x
.af01		ca		dex		                dex
.af02		ca		dex		                dex
.af03		a9 75		lda #$75	                lda #<underflow_1
.af05		95 00		sta $00,x	                sta 0,x
.af07		a9 d8		lda #$d8	                lda #>underflow_1
.af09		95 01		sta $01,x	                sta 1,x
.af0b		20 a1 d7	jsr $d7a1	                jsr compare_16bit
.af0e		f0 02		beq $af12	                beq _disasm_jsr_uflow_check_upper
.af10		b0 14		bcs $af26	                bcs _disasm_jsr_unknown
.af12						_disasm_jsr_uflow_check_upper:
.af12		a9 84		lda #$84	                lda #<underflow_4
.af14		95 00		sta $00,x	                sta 0,x
.af16		a9 d8		lda #$d8	                lda #>underflow_4
.af18		95 01		sta $01,x	                sta 1,x
.af1a		20 a1 d7	jsr $d7a1	                jsr compare_16bit
.af1d		f0 02		beq $af21	                beq _disasm_jsr_soc
.af1f		90 05		bcc $af26	                bcc _disasm_jsr_unknown
.af21						_disasm_jsr_soc:
.af21		a9 0d		lda #$0d	                lda #str_disasm_sdc
.af23		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.af26						_disasm_jsr_unknown:
.af26		20 54 a3	jsr $a354	                jsr xt_two_drop
.af29		60		rts		                rts
.af2a						oc_index_table:
>af2a		2a b1 2e b1 c2 b5 c2 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>af32		36 b1 3c b1 42 b1 c2 b5
>af3a		48 b1 4c b1 52 b1 c2 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af42		58 b1 5c b1 60 b1 64 b1
>af4a		69 b1 6d b1 75 b1 c2 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af52		7c b1 82 b1 89 b1 90 b1
>af5a		97 b1 9b b1 a1 b1 c2 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af62		a7 b1 ab b1 c2 b5 b1 b1
>af6a		b7 b1 bb b1 c2 b5 c2 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af72		c3 b1 c9 b1 cf b1 d5 b1
>af7a		dc b1 e0 b1 e6 b1 c2 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af82		ec b1 f0 b1 f5 b1 f9 b1
>af8a		fe b1 02 b2 0a b2 c2 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af92		11 b2 19 b2 20 b2 27 b2
>af9a		2e b2 32 b2 38 b2 c2 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>afa2		3e b2 44 b2 4a b2 64 b1
>afaa		55 b2 59 b2 c2 b5 c2 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>afb2		c2 b5 61 b2 67 b2 6d b2
>afba		74 b2 78 b2 7e b2 c2 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>afc2		84 b2 88 b2 8c b2 90 b2
>afca		95 b2 99 b2 a1 b2 c2 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>afd2		c2 b5 a8 b2 af b2 b6 b2
>afda		bd b2 c1 b2 c7 b2 c2 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>afe2		c2 b5 c2 b5 d1 b2 d7 b2
>afea		dc b2 e0 b2 c2 b5 c2 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>aff2		e8 b2 ee b2 f4 b2 fa b2
>affa		01 b3 05 b3 0b b3 c2 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>b002		11 b3 17 b3 1b b3 1f b3
>b00a		24 b3 28 b3 30 b3 c2 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b012		37 b3 3e b3 45 b3 4c b3
>b01a		53 b3 57 b3 5d b3 c2 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>b022		61 b3 68 b3 6e b3 74 b3
>b02a		79 b3 7d b3 c2 b5 c2 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b032		85 b3 8b b3 91 b3 c2 b5
>b03a		97 b3 9b b3 a1 b3 c2 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b042		a5 b3 a9 b3 ad b3 b1 b3
>b04a		b6 b3 ba b3 c2 b3 c2 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b052		c9 b3 d0 b3 d7 b3 de b3
>b05a		e5 b3 e9 b3 ef b3 c2 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b062		f3 b3 f7 b3 fd b3 03 b4
>b06a		08 b4 0e b4 16 b4 c2 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b072		1c b4 22 b4 28 b4 2e b4
>b07a		35 b4 39 b4 3f b4 c2 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b082		43 b4 47 b4 4b b4 4f b4
>b08a		54 b4 58 b4 60 b4 c2 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b092		67 b4 6e b4 75 b4 7c b4
>b09a		83 b4 87 b4 8d b4 c2 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b0a2		91 b4 97 b4 9d b4 a3 b4
>b0aa		a8 b4 ae b4 c2 b5 c2 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b0b2		b6 b4 bc b4 c2 b4 c8 b4
>b0ba		cf b4 d3 b4 d9 b4 c2 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b0c2		dd b4 e1 b4 e5 b4 e9 b4
>b0ca		ee b4 f2 b4 fa b4 c2 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b0d2		c2 b5 01 b5 08 b5 0f b5
>b0da		16 b5 1a b5 20 b5 c2 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0e2		c2 b5 24 b5 2a b5 30 b5
>b0ea		35 b5 3b b5 c2 b5 c2 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0f2		43 b5 49 b5 4f b5 55 b5
>b0fa		5c b5 60 b5 66 b5 c2 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b102		6a b5 6e b5 72 b5 76 b5
>b10a		7b b5 7f b5 87 b5 c2 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b112		c2 b5 8e b5 95 b5 9c b5
>b11a		a3 b5 a7 b5 ad b5 c2 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b122		c2 b5 b1 b5 b7 b5 bd b5
.b12a						oc_table:
>b12a		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b12e		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b136		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b13c		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b142		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b148		43 70 68 70				oc08:	.text 1*64+3, "php"
>b14c		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b152		45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b158		c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b15c		c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b160		c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b164		c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b169		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b16d		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b175		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b17c		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b182		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b189		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b190		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b197		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b19b		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b1a1		45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b1a7		c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b1ab		c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b1b1		c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b1b7		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b1bb		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b1c3		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b1c9		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b1cf		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b1d5		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1dc		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1e0		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1e6		45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1ec		c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b1f0		c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1f5		c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1f9		c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1fe		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b202		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b20a		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b211		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b219		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b220		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b227		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b22e		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b232		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b238		45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b23e		c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b244		c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b24a		c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b250		c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b255		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b259		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b261		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b267		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b26d		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b274		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b278		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b27e		45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b284		c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b288		c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b28c		c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b290		c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b295		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b299		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b2a1		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b2a8		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b2af		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b2b6		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b2bd		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b2c1		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b2c7		43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b2cb		c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b2d1		c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2d7		c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2dc		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2e0		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2e8		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b2ee		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2f4		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2fa		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b301		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b305		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b30b		45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b311		c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b317		c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b31b		c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b31f		c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b324		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b328		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b330		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b337		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b33e		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b345		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b34c		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b353		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b357		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b35d		43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b361		c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b368		c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b36e		c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b374		c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b379		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b37d		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b385		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b38b		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b391		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b397		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b39b		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b3a1		43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b3a5		c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b3a9		c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b3ad		c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b3b1		c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b3b6		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b3ba		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b3c2		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b3c9		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b3d0		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3d7		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3de		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3e5		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3e9		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b3ef		43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3f3		c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3f7		c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3fd		c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b403		c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b408		85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b40e		87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b416		85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b41c		85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b422		85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b428		85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b42e		86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b435		43 74 61 79				oca8:	.text 1*64+3, "tay"
>b439		85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b43f		43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b443		c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b447		c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b44b		c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b44f		c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b454		83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b458		87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b460		86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b467		86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b46e		86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b475		86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b47c		86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b483		43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b487		c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b48d		43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b491		c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b497		c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b49d		c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b4a3		c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b4a8		85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b4ae		87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b4b6		85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b4bc		85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b4c2		85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b4c8		86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b4cf		43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b4d3		85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4d9		43 64 65 78				occa:	.text 1*64+3, "dex"
>b4dd		c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4e1		c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4e5		c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4e9		c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b4ee		83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4f2		87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4fa		86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b501		86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b508		86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b50f		86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b516		43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b51a		c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b520		43 70 68 78				ocda:	.text 1*64+3, "phx"
>b524		c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b52a		c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b530		c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b535		85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b53b		87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b543		85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b549		85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b54f		85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b555		86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b55c		43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b560		85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b566		43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b56a		c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b56e		c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b572		c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b576		c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b57b		83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b57f		87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b587		86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b58e		86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b595		86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b59c		86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b5a3		43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b5a7		c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b5ad		43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b5b1		c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b5b7		c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b5bd		c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b5c2		01 3f					oc__:	.text 1, "?"
.b5c4						disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=$002c						ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=$002e						ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=$0030						ed_flags = editor3  ; Flags used by ed, where
.b5c4						ed6502:
.b5c4		a5 18		lda $18		                lda base
.b5c6		85 31		sta $31		                sta editor3+1
.b5c8		a9 0a		lda #$0a	                lda #10
.b5ca		85 18		sta $18		                sta base
.b5cc		64 2c		stz $2c		                stz ed_head
.b5ce		64 2d		stz $2d		                stz ed_head+1
.b5d0		64 2e		stz $2e		                stz ed_cur
.b5d2		64 2f		stz $2f		                stz ed_cur+1
.b5d4		64 30		stz $30		                stz ed_flags
.b5d6		20 56 a7	jsr $a756	                jsr xt_zero
.b5d9		20 56 a7	jsr $a756	                jsr xt_zero             ; ( addr-t u-t )
.b5dc		20 2a 89	jsr $892a	                jsr xt_cr
.b5df						ed_input_loop:
.b5df		a9 81		lda #$81	                lda #%10000001
.b5e1		14 30		trb $30		                trb ed_flags
.b5e3		20 be ba	jsr $babe	                jsr ed_get_input
.b5e6		a5 0a		lda $0a		                lda ciblen
.b5e8		d0 1f		bne $b609	                bne _command_mode
.b5ea		ca		dex		                dex
.b5eb		ca		dex		                dex                     ; ( addr-t u-t ? )
.b5ec		a5 2e		lda $2e		                lda ed_cur
.b5ee		95 00		sta $00,x	                sta 0,x
.b5f0		a5 2f		lda $2f		                lda ed_cur+1
.b5f2		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5f4		a9 80		lda #$80	                lda #%10000000
.b5f6		04 30		tsb $30		                tsb ed_flags
.b5f8		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5fb		20 da ba	jsr $bada	                jsr ed_is_valid_line
.b5fe		b0 03		bcs $b603	                bcs +
.b600		4c ae ba	jmp $baae	                jmp ed_error_1drop
.b603						+
.b603		20 56 a7	jsr $a756	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b606		4c d4 b6	jmp $b6d4	                jmp _line_number_only_from_external
.b609						_command_mode:
.b609		20 56 a7	jsr $a756	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b60c		20 56 a7	jsr $a756	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b60f						_prefix_dot:
.b60f		b2 08		lda ($08)	                lda (cib)
.b611		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b613		d0 3a		bne $b64f	                bne _prefix_dollar
.b615		20 cf ba	jsr $bacf	                jsr ed_have_text
.b618		a5 2e		lda $2e		                lda ed_cur
.b61a		95 02		sta $02,x	                sta 2,x
.b61c		a5 2f		lda $2f		                lda ed_cur+1
.b61e		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b620		a9 80		lda #$80	                lda #%10000000
.b622		04 30		tsb $30		                tsb ed_flags
.b624		a5 0a		lda $0a		                lda ciblen
.b626		3a		dec a		                dea                     ; sets Z if A was 1
.b627		d0 03		bne $b62c	                bne +
.b629		4c d4 b6	jmp $b6d4	                jmp _line_number_only_from_external
.b62c						+
.b62c		ca		dex		                dex
.b62d		ca		dex		                dex
.b62e		ca		dex		                dex
.b62f		ca		dex		                dex
.b630		a5 08		lda $08		                lda cib
.b632		95 02		sta $02,x	                sta 2,x
.b634		a5 09		lda $09		                lda cib+1
.b636		95 03		sta $03,x	                sta 3,x
.b638		a5 0a		lda $0a		                lda ciblen
.b63a		95 00		sta $00,x	                sta 0,x
.b63c		a5 0b		lda $0b		                lda ciblen+1
.b63e		95 01		sta $01,x	                sta 1,x
.b640		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b643		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b646		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b649		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b64c		4c 2c b7	jmp $b72c	                jmp _check_for_para2
.b64f						_prefix_dollar:
.b64f		b2 08		lda ($08)	                lda (cib)
.b651		c9 24		cmp #$24	                cmp #'$'
.b653		d0 1c		bne $b671	                bne _prefix_percent
.b655		20 cf ba	jsr $bacf	                jsr ed_have_text
.b658		e8		inx		                inx
.b659		e8		inx		                inx                     ; ( addr-t u-t 0 )
.b65a		20 fc ba	jsr $bafc	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b65d		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b660		a9 80		lda #$80	                lda #%10000000
.b662		04 30		tsb $30		                tsb ed_flags
.b664		a5 0a		lda $0a		                lda ciblen
.b666		3a		dec a		                dea                     ; sets Z if A was 1
.b667		d0 03		bne $b66c	                bne +
.b669		4c d4 b6	jmp $b6d4	                jmp _line_number_only_from_external
.b66c						+
.b66c		a0 01		ldy #$01	                ldy #01
.b66e		4c a8 b7	jmp $b7a8	                jmp _check_command
.b671						_prefix_percent:
.b671		b2 08		lda ($08)	                lda (cib)
.b673		c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b675		f0 04		beq $b67b	                beq _whole_text
.b677		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b679		d0 17		bne $b692	                bne _prefix_semicolon
.b67b						_whole_text:
.b67b		20 cf ba	jsr $bacf	                jsr ed_have_text
.b67e		a9 01		lda #$01	                lda #01
.b680		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b682		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b684						_semicolon_entry:
.b684		e8		inx		                inx
.b685		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b686		20 fc ba	jsr $bafc	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b689		a9 80		lda #$80	                lda #%10000000
.b68b		04 30		tsb $30		                tsb ed_flags
.b68d		a0 01		ldy #$01	                ldy #01
.b68f		4c a8 b7	jmp $b7a8	                jmp _check_command
.b692						_prefix_semicolon:
.b692		b2 08		lda ($08)	                lda (cib)
.b694		c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b696		d0 0d		bne $b6a5	                bne _prefix_number
.b698		20 cf ba	jsr $bacf	                jsr ed_have_text
.b69b		a5 2e		lda $2e		                lda ed_cur
.b69d		95 02		sta $02,x	                sta 2,x
.b69f		a5 2f		lda $2f		                lda ed_cur+1
.b6a1		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b6a3		80 df		bra $b684	                bra _semicolon_entry
.b6a5						_prefix_number:
.b6a5		20 56 a7	jsr $a756	                jsr xt_zero
.b6a8		20 56 a7	jsr $a756	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b6ab		ca		dex		                dex
.b6ac		ca		dex		                dex
.b6ad		ca		dex		                dex
.b6ae		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b6af		a5 08		lda $08		                lda cib
.b6b1		95 02		sta $02,x	                sta 2,x
.b6b3		a5 09		lda $09		                lda cib+1
.b6b5		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b6b7		a5 0a		lda $0a		                lda ciblen
.b6b9		95 00		sta $00,x	                sta 0,x
.b6bb		a5 0b		lda $0b		                lda ciblen+1
.b6bd		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b6bf		20 61 a2	jsr $a261	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b6c2		b5 00		lda $00,x	                lda 0,x
.b6c4		15 01		ora $01,x	                ora 1,x
.b6c6		d0 24		bne $b6ec	                bne _have_unconverted_chars
.b6c8		e8		inx		                inx
.b6c9		e8		inx		                inx
.b6ca		e8		inx		                inx
.b6cb		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b6cc		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b6cf		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b6d2		e8		inx		                inx
.b6d3		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b6d4						_line_number_only_from_external:
.b6d4		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6d7		20 da ba	jsr $bada	                jsr ed_is_valid_line
.b6da		b0 03		bcs $b6df	                bcs +
.b6dc		4c ac ba	jmp $baac	                jmp ed_error_2drop
.b6df						+
.b6df		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6e2		20 69 bb	jsr $bb69	                jsr ed_para1_to_cur
.b6e5		a9 80		lda #$80	                lda #%10000000
.b6e7		04 30		tsb $30		                tsb ed_flags
.b6e9		4c 87 b9	jmp $b987	                jmp ed_cmd_p_from_external
.b6ec						_have_unconverted_chars:
.b6ec		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b6ef		ca		dex		                dex
.b6f0		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6f1		a5 0a		lda $0a		                lda ciblen
.b6f3		95 00		sta $00,x	                sta 0,x
.b6f5		a5 0b		lda $0b		                lda ciblen+1
.b6f7		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6f9		20 b3 8e	jsr $8eb3	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6fc		b5 00		lda $00,x	                lda 0,x
.b6fe		15 01		ora $01,x	                ora 1,x
.b700		f0 0e		beq $b710	                beq _no_command_yet
.b702		8a		txa		                txa
.b703		18		clc		                clc
.b704		69 0a		adc #$0a	                adc #10
.b706		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b707		a9 80		lda #$80	                lda #%10000000
.b709		14 30		trb $30		                trb ed_flags
.b70b		a0 00		ldy #$00	                ldy #00
.b70d		4c a8 b7	jmp $b7a8	                jmp _check_command
.b710						_no_command_yet:
.b710		e8		inx		                inx
.b711		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b712		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b715		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b718		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b71b		b5 00		lda $00,x	                lda 0,x                 ; LSB
.b71d		95 06		sta $06,x	                sta 6,x
.b71f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.b721		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b723		e8		inx		                inx
.b724		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b725		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b728		a9 80		lda #$80	                lda #%10000000
.b72a		04 30		tsb $30		                tsb ed_flags
.b72c						_check_for_para2:
.b72c		a1 02		lda ($02,x)	                lda (2,x)
.b72e		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b730		f0 0d		beq $b73f	                beq _got_comma
.b732		38		sec		                sec
.b733		a5 0a		lda $0a		                lda ciblen
.b735		f5 00		sbc $00,x	                sbc 0,x
.b737		a8		tay		                tay
.b738		e8		inx		                inx
.b739		e8		inx		                inx
.b73a		e8		inx		                inx
.b73b		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b73c		4c a8 b7	jmp $b7a8	                jmp _check_command
.b73f						_got_comma:
.b73f		f6 02		inc $02,x	                inc 2,x
.b741		d0 02		bne $b745	                bne +
.b743		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b745						+
.b745		b5 01		lda $01,x	                lda 1,x
.b747		f0 02		beq $b74b	                beq +
.b749		d6 01		dec $01,x	                dec 1,x
.b74b						+
.b74b		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b74d		a1 02		lda ($02,x)	                lda (2,x)
.b74f		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b751		d0 14		bne $b767	                bne _para2_not_dollar
.b753		38		sec		                sec
.b754		a5 0a		lda $0a		                lda ciblen
.b756		f5 02		sbc $02,x	                sbc 2,x
.b758		a8		tay		                tay
.b759		c8		iny		                iny
.b75a		5a		phy		                phy
.b75b		8a		txa		                txa
.b75c		18		clc		                clc
.b75d		69 06		adc #$06	                adc #06
.b75f		aa		tax		                tax                     ; ( addr-t u-t para1 )
.b760		20 fc ba	jsr $bafc	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b763		7a		ply		                ply
.b764		4c a8 b7	jmp $b7a8	                jmp _check_command
.b767						_para2_not_dollar:
.b767		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b76a		20 56 a7	jsr $a756	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b76d		20 56 a7	jsr $a756	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b770		20 34 9b	jsr $9b34	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b773		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b776		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b779		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b77c		20 61 a2	jsr $a261	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b77f		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b782		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b785		20 b3 8e	jsr $8eb3	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b788		b5 00		lda $00,x	                lda 0,x
.b78a		15 01		ora $01,x	                ora 1,x
.b78c		f0 08		beq $b796	                beq _second_number
.b78e		8a		txa		                txa
.b78f		18		clc		                clc
.b790		69 0c		adc #$0c	                adc #12
.b792		aa		tax		                tax                     ; back to ( addr-t u-t )
.b793		4c b0 ba	jmp $bab0	                jmp ed_error
.b796						_second_number:
.b796		e8		inx		                inx
.b797		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b798		38		sec		                sec
.b799		a5 0a		lda $0a		                lda ciblen
.b79b		f5 00		sbc $00,x	                sbc 0,x
.b79d		48		pha		                pha
.b79e		20 54 a3	jsr $a354	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b7a1		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b7a4		20 26 96	jsr $9626	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b7a7		7a		ply		                ply
.b7a8						_check_command:
.b7a8		24 30		bit $30		                bit ed_flags
.b7aa		30 08		bmi $b7b4	                bmi _check_command_have_arg
.b7ac		a5 2e		lda $2e		                lda ed_cur
.b7ae		95 02		sta $02,x	                sta 2,x
.b7b0		a5 2f		lda $2f		                lda ed_cur+1
.b7b2		95 03		sta $03,x	                sta 3,x
.b7b4						_check_command_have_arg:
.b7b4		b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b7b6		85 22		sta $22		                sta tmp1
.b7b8		da		phx		                phx
.b7b9		a2 00		ldx #$00	                ldx #00
.b7bb						_cmd_loop:
.b7bb		bd 94 bb	lda $bb94,x	                lda ed_cmd_list,x
.b7be		f0 07		beq $b7c7	                beq _illegal_command    ; zero marks end of list
.b7c0		c5 22		cmp $22		                cmp tmp1
.b7c2		f0 07		beq $b7cb	                beq _found_cmd
.b7c4		e8		inx		                inx
.b7c5		80 f4		bra $b7bb	                bra _cmd_loop
.b7c7						_illegal_command:
.b7c7		fa		plx		                plx
.b7c8		4c ac ba	jmp $baac	                jmp ed_error_2drop
.b7cb						_found_cmd:
.b7cb		8a		txa		                txa
.b7cc		0a		asl a		                asl
.b7cd		aa		tax		                tax                     ; X * 2 for table
.b7ce		7c 9f bb	jmp ($bb9f,x)	                jmp (ed_cmd_table,x)
.b7d1						ed_next_command:
.b7d1		e8		inx		                inx
.b7d2		e8		inx		                inx
.b7d3		e8		inx		                inx
.b7d4		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b7d5						_next_command_empty:
.b7d5		4c df b5	jmp $b5df	                jmp ed_input_loop
.b7d8						ed_all_done:
.b7d8		64 0a		stz $0a		                stz ciblen
.b7da		64 0b		stz $0b		                stz ciblen+1
.b7dc		20 54 a3	jsr $a354	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7df		a5 31		lda $31		                lda editor3+1
.b7e1		85 18		sta $18		                sta base
.b7e3		60		rts		                rts
.b7e4						ed_cmd_a:
.b7e4		fa		plx		                plx
.b7e5		e8		inx		                inx
.b7e6		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7e7						ed_entry_cmd_i:
.b7e7						ed_cmd_a_have_para:
.b7e7		20 32 bb	jsr $bb32	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7ea		20 2a 89	jsr $892a	                jsr xt_cr
.b7ed						_next_string_loop:
.b7ed		20 be ba	jsr $babe	                jsr ed_get_input
.b7f0		b2 08		lda ($08)	                lda (cib)
.b7f2		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7f4		d0 16		bne $b80c	                bne _add_line
.b7f6		a4 0a		ldy $0a		                ldy ciblen
.b7f8		c0 01		cpy #$01	                cpy #01
.b7fa		d0 10		bne $b80c	                bne _add_line
.b7fc		a4 0b		ldy $0b		                ldy ciblen+1
.b7fe		d0 0c		bne $b80c	                bne _add_line
.b800		e8		inx		                inx
.b801		e8		inx		                inx
.b802		a9 40		lda #$40	                lda #%01000000
.b804		04 30		tsb $30		                tsb ed_flags
.b806		20 2a 89	jsr $892a	                jsr xt_cr
.b809		4c df b5	jmp $b5df	                jmp ed_input_loop
.b80c						_add_line:
.b80c		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b80f		20 57 91	jsr $9157	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b812		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b815		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b818		20 24 87	jsr $8724	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b81b		20 31 a3	jsr $a331	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b81e		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b821		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-t u-t here )
.b824		20 57 91	jsr $9157	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b827		a5 00		lda $00		                lda cp
.b829		18		clc		                clc
.b82a		69 04		adc #$04	                adc #04
.b82c		85 00		sta $00		                sta cp
.b82e		90 02		bcc $b832	                bcc +
.b830		e6 01		inc $01		                inc cp+1
.b832						+
.b832		e6 2e		inc $2e		                inc ed_cur
.b834		d0 02		bne $b838	                bne +
.b836		e6 2f		inc $2f		                inc ed_cur+1
.b838						+
.b838		20 57 91	jsr $9157	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b83b		20 62 8d	jsr $8d62	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b83e		ca		dex		                dex
.b83f		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b840		a5 08		lda $08		                lda cib
.b842		95 00		sta $00,x	                sta 0,x
.b844		a5 09		lda $09		                lda cib+1
.b846		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b848		20 5c a1	jsr $a15c	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b84b		ca		dex		                dex
.b84c		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b84d		a5 0a		lda $0a		                lda ciblen
.b84f		95 00		sta $00,x	                sta 0,x
.b851		a5 0b		lda $0b		                lda ciblen+1
.b853		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b855		20 a6 95	jsr $95a6	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b858		18		clc		                clc
.b859		a5 00		lda $00		                lda cp
.b85b		65 0a		adc $0a		                adc ciblen
.b85d		85 00		sta $00		                sta cp
.b85f		90 06		bcc $b867	                bcc +
.b861		a5 01		lda $01		                lda cp+1
.b863		65 0b		adc $0b		                adc ciblen+1
.b865		85 01		sta $01		                sta cp+1
.b867						+
.b867		20 77 98	jsr $9877	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b86a		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b86d		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+
.b870		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b873		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b876		a5 0a		lda $0a		                lda ciblen
.b878		95 02		sta $02,x	                sta 2,x
.b87a		a5 0b		lda $0b		                lda ciblen+1
.b87c		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b87e		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-t u-t here )
.b881		20 2a 89	jsr $892a	                jsr xt_cr
.b884		4c ed b7	jmp $b7ed	                jmp _next_string_loop
.b887						ed_cmd_d:
.b887		fa		plx		                plx
.b888		20 cf ba	jsr $bacf	                jsr ed_have_text
.b88b		20 24 bb	jsr $bb24	                jsr ed_no_line_zero
.b88e		b5 00		lda $00,x	                lda 0,x
.b890		15 01		ora $01,x	                ora 1,x
.b892		d0 08		bne $b89c	                bne +
.b894		20 77 98	jsr $9877	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b897		20 d9 b8	jsr $b8d9	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b89a		80 33		bra $b8cf	                bra _cmd_d_done
.b89c						+
.b89c		20 da ba	jsr $bada	                jsr ed_is_valid_line      ; result is in C flag
.b89f		b0 03		bcs $b8a4	                bcs _cmd_d_loop
.b8a1		4c ac ba	jmp $baac	                jmp ed_error_2drop
.b8a4						_cmd_d_loop:
.b8a4		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b8a7		20 42 91	jsr $9142	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b8aa		b5 00		lda $00,x	                lda 0,x
.b8ac		15 01		ora $01,x	                ora 1,x
.b8ae		d0 0d		bne $b8bd	                bne _cmd_d_done_with_flag
.b8b0		e8		inx		                inx
.b8b1		e8		inx		                inx                     ; Get rid of the flag from >
.b8b2		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b8b5		20 d9 b8	jsr $b8d9	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b8b8		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b8bb		80 e7		bra $b8a4	                bra _cmd_d_loop
.b8bd						_cmd_d_done_with_flag:
.b8bd		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b8be		e8		inx		                inx
.b8bf		b5 02		lda $02,x	                lda 2,x
.b8c1		d0 02		bne $b8c5	                bne +
.b8c3		d6 03		dec $03,x	                dec 3,x
.b8c5						+
.b8c5		d6 02		dec $02,x	                dec 2,x
.b8c7		b5 02		lda $02,x	                lda 2,x
.b8c9		85 2e		sta $2e		                sta ed_cur
.b8cb		b5 03		lda $03,x	                lda 3,x
.b8cd		85 2f		sta $2f		                sta ed_cur+1            ; drop through to _cmd_d_done
.b8cf						_cmd_d_done:
.b8cf		a9 40		lda #$40	                lda #%01000000
.b8d1		04 30		tsb $30		                tsb ed_flags
.b8d3		20 2a 89	jsr $892a	                jsr xt_cr
.b8d6		4c d1 b7	jmp $b7d1	                jmp ed_next_command
.b8d9						_cmd_d_common:
.b8d9		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8dc		20 32 bb	jsr $bb32	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8df		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8e2		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8e5		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8e8		20 32 bb	jsr $bb32	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8eb		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-t u-t )
.b8ee		60		rts		                rts
.b8ef						ed_cmd_equ:
.b8ef		fa		plx		                plx
.b8f0		a5 2c		lda $2c		                lda ed_head
.b8f2		05 2d		ora $2d		                ora ed_head+1
.b8f4		d0 08		bne $b8fe	                bne _cmd_equ_have_text
.b8f6		ca		dex		                dex
.b8f7		ca		dex		                dex
.b8f8		74 00		stz $00,x	                stz 0,x
.b8fa		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8fc		80 21		bra $b91f	                bra _cmd_equ_done
.b8fe						_cmd_equ_have_text:
.b8fe		20 24 bb	jsr $bb24	                jsr ed_no_line_zero
.b901		24 30		bit $30		                bit ed_flags
.b903		30 0c		bmi $b911	                bmi _cmd_equ_have_para
.b905		ca		dex		                dex
.b906		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b907		a5 2e		lda $2e		                lda ed_cur
.b909		95 00		sta $00,x	                sta 0,x
.b90b		a5 2f		lda $2f		                lda ed_cur+1
.b90d		95 01		sta $01,x	                sta 1,x
.b90f		80 0e		bra $b91f	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b911						_cmd_equ_have_para:
.b911		b5 00		lda $00,x	                lda 0,x
.b913		15 01		ora $01,x	                ora 1,x
.b915		d0 05		bne $b91c	                bne _cmd_equ_two_paras
.b917		20 77 98	jsr $9877	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b91a		80 03		bra $b91f	                bra _cmd_equ_done
.b91c						_cmd_equ_two_paras:
.b91c		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b91f						_cmd_equ_done:
.b91f		20 2a 89	jsr $892a	                jsr xt_cr               ; number goes on new line
.b922		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b925		20 2a 89	jsr $892a	                jsr xt_cr
.b928		4c d1 b7	jmp $b7d1	                jmp ed_next_command
.b92b						ed_cmd_f:
.b92b		fa		plx		                plx
.b92c		24 30		bit $30		                bit ed_flags
.b92e		30 17		bmi $b947	                bmi _cmd_f_have_para
.b930		20 2a 89	jsr $892a	                jsr xt_cr
.b933		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b936		20 34 9b	jsr $9b34	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b939		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b93c		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b93f		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b942		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b945		80 11		bra $b958	                bra _cmd_f_done
.b947						_cmd_f_have_para:
.b947		20 77 98	jsr $9877	                jsr xt_over
.b94a		20 2a 89	jsr $892a	                jsr xt_cr
.b94d		20 d2 a4	jsr $a4d2	                jsr xt_u_dot
.b950		b5 02		lda $02,x	                lda 2,x
.b952		95 06		sta $06,x	                sta 6,x
.b954		b5 03		lda $03,x	                lda 3,x
.b956		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b958						_cmd_f_done:
.b958		20 2a 89	jsr $892a	                jsr xt_cr
.b95b		4c d1 b7	jmp $b7d1	                jmp ed_next_command
.b95e						ed_cmd_i:
.b95e		fa		plx		                plx
.b95f		e8		inx		                inx
.b960		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b961		24 30		bit $30		                bit ed_flags
.b963		30 08		bmi $b96d	                bmi _cmd_i_have_para
.b965		a5 2e		lda $2e		                lda ed_cur
.b967		95 00		sta $00,x	                sta 0,x
.b969		a5 2f		lda $2f		                lda ed_cur+1
.b96b		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b96d						_cmd_i_have_para:
.b96d		b5 00		lda $00,x	                lda 0,x
.b96f		15 01		ora $01,x	                ora 1,x
.b971		f0 09		beq $b97c	                beq _cmd_i_done
.b973		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b976		20 56 a7	jsr $a756	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b979		20 fc 94	jsr $94fc	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b97c						_cmd_i_done:
.b97c		4c e7 b7	jmp $b7e7	                jmp ed_entry_cmd_i
.b97f						ed_cmd_n:
.b97f		fa		plx		                plx
.b980		a9 01		lda #$01	                lda #%00000001
.b982		04 30		tsb $30		                tsb ed_flags
.b984		80 05		bra $b98b	                bra ed_cmd_p_entry_for_cmd_n
.b986						ed_cmd_p:
.b986		fa		plx		                plx
.b987						ed_cmd_p_from_external:
.b987		a9 01		lda #$01	                lda #%00000001
.b989		14 30		trb $30		                trb ed_flags
.b98b						ed_cmd_p_entry_for_cmd_n:
.b98b		20 cf ba	jsr $bacf	                jsr ed_have_text
.b98e		20 24 bb	jsr $bb24	                jsr ed_no_line_zero
.b991		20 2a 89	jsr $892a	                jsr xt_cr
.b994		b5 00		lda $00,x	                lda 0,x
.b996		15 01		ora $01,x	                ora 1,x
.b998		d0 10		bne $b9aa	                bne _cmd_p_loop
.b99a		b5 02		lda $02,x	                lda 2,x
.b99c		85 2e		sta $2e		                sta ed_cur
.b99e		b5 03		lda $03,x	                lda 3,x
.b9a0		85 2f		sta $2f		                sta ed_cur+1
.b9a2		20 77 98	jsr $9877	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b9a5		20 d3 b9	jsr $b9d3	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9a8		80 26		bra $b9d0	                bra _cmd_p_all_done
.b9aa						_cmd_p_loop:
.b9aa		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b9ad		20 42 91	jsr $9142	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b9b0		b5 00		lda $00,x	                lda 0,x
.b9b2		15 01		ora $01,x	                ora 1,x
.b9b4		d0 10		bne $b9c6	                bne _cmd_p_done
.b9b6		e8		inx		                inx
.b9b7		e8		inx		                inx                     ; Get rid of the flag from >
.b9b8		20 77 98	jsr $9877	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b9bb		20 d3 b9	jsr $b9d3	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9be		f6 02		inc $02,x	                inc 2,x
.b9c0		d0 02		bne $b9c4	                bne +
.b9c2		f6 03		inc $03,x	                inc 3,x
.b9c4						+
.b9c4		80 e4		bra $b9aa	                bra _cmd_p_loop
.b9c6						_cmd_p_done:
.b9c6		e8		inx		                inx
.b9c7		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b9c8		b5 00		lda $00,x	                lda 0,x
.b9ca		85 2e		sta $2e		                sta ed_cur
.b9cc		b5 01		lda $01,x	                lda 1,x
.b9ce		85 2f		sta $2f		                sta ed_cur+1
.b9d0						_cmd_p_all_done:
.b9d0		4c d1 b7	jmp $b7d1	                jmp ed_next_command
.b9d3						_cmd_p_common:
.b9d3		a5 30		lda $30		                lda ed_flags
.b9d5		4a		lsr a		                lsr                     ; bit 0 now in carry
.b9d6		90 0b		bcc $b9e3	                bcc _cmd_p_common_no_num
.b9d8		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9db		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9de		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9e0		20 db 8d	jsr $8ddb	                jsr emit_a
.b9e3						_cmd_p_common_no_num:
.b9e3		20 32 bb	jsr $bb32	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9e6		20 72 bb	jsr $bb72	                jsr ed_print_addr
.b9e9		60		rts		                rts
.b9ea						ed_cmd_q:
.b9ea		fa		plx		                plx
.b9eb		24 30		bit $30		                bit ed_flags            ; bit 6 is change flag
.b9ed		50 03		bvc $b9f2	                bvc +
.b9ef		4c ac ba	jmp $baac	                jmp ed_error_2drop
.b9f2						+
.b9f2		4c d8 b7	jmp $b7d8	                jmp ed_all_done            ; can't fall thru because of PLX
.b9f5						ed_cmd_qq:
.b9f5		fa		plx		                plx
.b9f6		4c d8 b7	jmp $b7d8	                jmp ed_all_done
.b9f9						ed_cmd_w:
.b9f9		fa		plx		                plx
.b9fa		20 cf ba	jsr $bacf	                jsr ed_have_text
.b9fd		24 30		bit $30		                bit ed_flags
.b9ff		30 13		bmi $ba14	                bmi _cmd_w_have_para
.ba01		b5 06		lda $06,x	                lda 6,x
.ba03		15 07		ora $07,x	                ora 7,x
.ba05		d0 03		bne $ba0a	                bne +
.ba07		4c ac ba	jmp $baac	                jmp ed_error_2drop
.ba0a						+
.ba0a		b5 06		lda $06,x	                lda 6,x
.ba0c		95 02		sta $02,x	                sta 2,x
.ba0e		b5 07		lda $07,x	                lda 7,x
.ba10		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.ba12		80 08		bra $ba1c	                bra _cmd_w_para_ready
.ba14						_cmd_w_have_para:
.ba14		b5 02		lda $02,x	                lda 2,x
.ba16		95 06		sta $06,x	                sta 6,x
.ba18		b5 03		lda $03,x	                lda 3,x
.ba1a		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ba1c						_cmd_w_para_ready:
.ba1c		a9 2c		lda #$2c	                lda #<ed_head
.ba1e		95 00		sta $00,x	                sta 0,x
.ba20		a9 00		lda #$00	                lda #>ed_head
.ba22		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ba24		20 77 98	jsr $9877	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ba27		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ba2a						_cmd_w_loop:
.ba2a		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ba2d		b5 00		lda $00,x	                lda 0,x
.ba2f		15 01		ora $01,x	                ora 1,x
.ba31		f0 55		beq $ba88	                beq _cmd_w_eol
.ba33		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba36		20 46 a4	jsr $a446	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba39		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba3c		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba3f		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba42		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba45		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba48		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba4b		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba4e		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba51		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba54		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba57		20 34 9b	jsr $9b34	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba5a		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba5d		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba60		20 a6 95	jsr $95a6	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba63		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba66		20 cc a3	jsr $a3cc	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba69		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba6c		20 c7 99	jsr $99c7	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba6f		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba72		ca		dex		                dex
.ba73		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba74		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba76		95 00		sta $00,x	                sta 0,x
.ba78		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba7a		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba7d		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba80		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba83		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba86		80 a2		bra $ba2a	                bra _cmd_w_loop
.ba88						_cmd_w_eol:
.ba88		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba8b		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba8e		20 34 95	jsr $9534	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba91		b5 00		lda $00,x	                lda 0,x
.ba93		95 04		sta $04,x	                sta 4,x
.ba95		b5 01		lda $01,x	                lda 1,x
.ba97		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba99		20 2a 89	jsr $892a	                jsr xt_cr
.ba9c		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba9f		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.baa2		20 2a 89	jsr $892a	                jsr xt_cr
.baa5		a9 40		lda #$40	                lda #%01000000
.baa7		14 30		trb $30		                trb ed_flags
.baa9		4c d1 b7	jmp $b7d1	                jmp ed_next_command
.baac						ed_error_2drop:
.baac		e8		inx		                inx
.baad		e8		inx		                inx                     ; drop through to _error_1drop
.baae						ed_error_1drop:
.baae		e8		inx		                inx
.baaf		e8		inx		                inx                     ; drop through to _error
.bab0						ed_error:
.bab0		20 2a 89	jsr $892a	                jsr xt_cr
.bab3		a9 3f		lda #$3f	                lda #'?'
.bab5		20 db 8d	jsr $8ddb	                jsr emit_a
.bab8		20 2a 89	jsr $892a	                jsr xt_cr
.babb		4c df b5	jmp $b5df	                jmp ed_input_loop
.babe						ed_get_input:
.babe		20 dc 9a	jsr $9adc	                jsr xt_refill           ;  ( addr-t u-t f )
.bac1		b5 00		lda $00,x	                lda 0,x
.bac3		15 01		ora $01,x	                ora 1,x
.bac5		d0 05		bne $bacc	                bne +
.bac7		7a		ply		                ply
.bac8		7a		ply		                ply
.bac9		4c ae ba	jmp $baae	                jmp ed_error_1drop
.bacc						+
.bacc		e8		inx		                inx
.bacd		e8		inx		                inx
.bace		60		rts		                rts
.bacf						ed_have_text:
.bacf		a5 2c		lda $2c		                lda ed_head
.bad1		05 2d		ora $2d		                ora ed_head+1
.bad3		d0 04		bne $bad9	                bne +
.bad5		7a		ply		                ply
.bad6		7a		ply		                ply
.bad7		80 d7		bra $bab0	                bra ed_error
.bad9						+
.bad9		60		rts		                rts
.bada						ed_is_valid_line:
.bada		38		sec		                sec                             ; default is legal line number
.badb		b5 00		lda $00,x	                lda 0,x
.badd		15 01		ora $01,x	                ora 1,x
.badf		f0 19		beq $bafa	                beq _is_valid_line_nope_zero    ; ( n )
.bae1		20 62 8d	jsr $8d62	                jsr xt_dup                      ; DUP ( n n )
.bae4		20 fc ba	jsr $bafc	                jsr ed_last_line                  ; ( n n last )
.bae7		20 5c a1	jsr $a15c	                jsr xt_swap                     ; SWAP ( n last n )
.baea		20 49 93	jsr $9349	                jsr xt_less_than                ; < ( n f )
.baed		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.baef		15 01		ora $01,x	                ora 1,x
.baf1		d0 05		bne $baf8	                bne _is_valid_line_too_small
.baf3		e8		inx		                inx
.baf4		e8		inx		                inx                     ; DROP flag ( n )
.baf5		38		sec		                sec                     ; Who knows what's happened to C by now
.baf6		80 03		bra $bafb	                bra _is_valid_line_done ; only one exit from this routine
.baf8						_is_valid_line_too_small:
.baf8		e8		inx		                inx
.baf9		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.bafa						_is_valid_line_nope_zero:
.bafa		18		clc		                clc                     ; drop through to _is_valid_line_done
.bafb						_is_valid_line_done:
.bafb		60		rts		                rts
.bafc						ed_last_line:
.bafc		64 22		stz $22		                stz tmp1
.bafe		64 23		stz $23		                stz tmp1+1
.bb00		ca		dex		                dex
.bb01		ca		dex		                dex                     ; ( ? )
.bb02		a9 2c		lda #$2c	                lda #<ed_head
.bb04		95 00		sta $00,x	                sta 0,x
.bb06		a9 00		lda #$00	                lda #>ed_head
.bb08		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.bb0a						_last_line_loop:
.bb0a		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( addr | 0 )
.bb0d		b5 00		lda $00,x	                lda 0,x
.bb0f		15 01		ora $01,x	                ora 1,x
.bb11		f0 08		beq $bb1b	                beq _last_line_done
.bb13		e6 22		inc $22		                inc tmp1
.bb15		d0 02		bne $bb19	                bne +
.bb17		e6 23		inc $23		                inc tmp1+1
.bb19						+
.bb19		80 ef		bra $bb0a	                bra _last_line_loop
.bb1b						_last_line_done:
.bb1b		a5 22		lda $22		                lda tmp1
.bb1d		95 00		sta $00,x	                sta 0,x
.bb1f		a5 23		lda $23		                lda tmp1+1
.bb21		95 01		sta $01,x	                sta 1,x                 ; ( u )
.bb23		60		rts		                rts
.bb24						ed_no_line_zero:
.bb24		b5 02		lda $02,x	                lda 2,x
.bb26		15 03		ora $03,x	                ora 3,x
.bb28		d0 07		bne $bb31	                bne _no_line_zero_done
.bb2a		24 30		bit $30		                bit ed_flags
.bb2c		10 03		bpl $bb31	                bpl _no_line_zero_done
.bb2e		4c ac ba	jmp $baac	                jmp ed_error_2drop
.bb31						_no_line_zero_done:
.bb31		60		rts		                rts
.bb32						ed_num_to_addr:
.bb32		ca		dex		                dex
.bb33		ca		dex		                dex                     ; ( u ? )
.bb34		a9 2c		lda #$2c	                lda #<ed_head
.bb36		95 00		sta $00,x	                sta 0,x
.bb38		a9 00		lda #$00	                lda #>ed_head
.bb3a		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb3c		b5 02		lda $02,x	                lda 2,x
.bb3e		15 03		ora $03,x	                ora 3,x
.bb40		d0 05		bne $bb47	                bne _num_to_addr_loop
.bb42		20 26 96	jsr $9626	                jsr xt_nip              ; ( addr-h )
.bb45		80 21		bra $bb68	                bra _num_to_addr_done
.bb47						_num_to_addr_loop:
.bb47		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( u addr1 )
.bb4a		b5 00		lda $00,x	                lda 0,x
.bb4c		15 01		ora $01,x	                ora 1,x
.bb4e		d0 05		bne $bb55	                bne +
.bb50		20 26 96	jsr $9626	                jsr xt_nip              ; NIP ( addr1 )
.bb53		80 13		bra $bb68	                bra _num_to_addr_done
.bb55						+
.bb55		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr1 u )
.bb58		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb5b		b5 00		lda $00,x	                lda 0,x
.bb5d		15 01		ora $01,x	                ora 1,x
.bb5f		f0 05		beq $bb66	                beq _num_to_addr_finished
.bb61		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb64		80 e1		bra $bb47	                bra _num_to_addr_loop
.bb66						_num_to_addr_finished:
.bb66		e8		inx		                inx
.bb67		e8		inx		                inx                     ; ( addr )
.bb68						_num_to_addr_done:
.bb68		60		rts		                rts
.bb69						ed_para1_to_cur:
.bb69		b5 02		lda $02,x	                lda 2,x
.bb6b		85 2e		sta $2e		                sta ed_cur
.bb6d		b5 03		lda $03,x	                lda 3,x
.bb6f		85 2f		sta $2f		                sta ed_cur+1
.bb71		60		rts		                rts
.bb72						ed_print_addr:
.bb72		20 01 98	jsr $9801	                jsr xt_one_plus
.bb75		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( addr+2 )
.bb78		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb7b		20 01 98	jsr $9801	                jsr xt_one_plus
.bb7e		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb81		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( addr+2 u-s )
.bb84		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( u-s addr+2 )
.bb87		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( u-s addr-s )
.bb8a		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-s u-s )
.bb8d		20 a7 a4	jsr $a4a7	                jsr xt_type
.bb90		20 2a 89	jsr $892a	                jsr xt_cr
.bb93		60		rts		                rts
>bb94		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb9c		71 51 00
.bb9f						ed_cmd_table:
>bb9f		e4 b7 2b b9 5e b9 87 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bba7		86 b9 7f b9
>bbab		ef b8 f9 b9 ea b9 f5 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bbb3						ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bbb3						forth_words_start:
>bbb3		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bbbb		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bbcb		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bbdb		20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bbeb		20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bbfb		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bc0b		2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bc1b		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bc2b		77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bc3b		20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc4b		69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc5b		4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc6b		28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc7b		65 78 69 74 29 20 63 72 20
.bc84						forth_words_end:
.bc84						user_words_start:
>bc84		20 20				.binary "user_words.asc"
.bc86						user_words_end:

;******  Processing file: platform/../headers.asm

.bc86						dictionary_start:
.bc86						nt_drop:
>bc86		04 10				        .byte 4, UF
>bc88		92 bc e1 8c e6 8c		        .word nt_dup, xt_drop, z_drop
>bc8e		64 72 6f 70			        .text "drop"
.bc92						nt_dup:
>bc92		03 10				        .byte 3, UF
>bc94		9d bc 62 8d 6f 8d		        .word nt_swap, xt_dup, z_dup
>bc9a		64 75 70			        .text "dup"
.bc9d						nt_swap:
>bc9d		04 10				        .byte 4, UF
>bc9f		a9 bc 5c a1 6f a1		        .word nt_store, xt_swap, z_swap
>bca5		73 77 61 70			        .text "swap"
.bca9						nt_store:
>bca9		01 10				        .byte 1, UF
>bcab		b2 bc 3b a1 50 a1		        .word nt_fetch, xt_store, z_store
>bcb1		21				        .text "!"
.bcb2						nt_fetch:
>bcb2		01 10				        .byte 1, UF
>bcb4		bb bc 65 8f 77 8f		        .word nt_over, xt_fetch, z_fetch
>bcba		40				        .text "@"
.bcbb						nt_over:
>bcbb		04 10				        .byte 4, UF
>bcbd		c7 bc 77 98 84 98		        .word nt_to_r, xt_over, z_over
>bcc3		6f 76 65 72			        .text "over"
.bcc7						nt_to_r:
>bcc7		02 11				        .byte 2, CO+UF ; native is special case
>bcc9		d1 bc 14 a3 27 a3		        .word nt_r_from, xt_to_r, z_to_r
>bccf		3e 72				        .text ">r"
.bcd1						nt_r_from:
>bcd1		02 01				        .byte 2, CO    ; native is special case
>bcd3		db bc 76 9a 86 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bcd9		72 3e				        .text "r>"
.bcdb						nt_r_fetch:
>bcdb		02 01				        .byte 2, CO    ; native is special case
>bcdd		e5 bc 61 9a 75 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bce3		72 40				        .text "r@"
.bce5						nt_nip:
>bce5		03 10				        .byte 3, UF
>bce7		f0 bc 26 96 33 96		        .word nt_rot, xt_nip, z_nip
>bced		6e 69 70			        .text "nip"
.bcf0						nt_rot:
>bcf0		03 10				        .byte 3, UF
>bcf2		fb bc 34 9b 4f 9b		        .word nt_not_rote, xt_rot, z_rot
>bcf8		72 6f 74			        .text "rot"
.bcfb						nt_not_rote:
>bcfb		04 10				        .byte 4, UF
>bcfd		07 bd 52 96 6d 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bd03		2d 72 6f 74			        .text "-rot"
.bd07						nt_tuck:
>bd07		04 10				        .byte 4, UF
>bd09		13 bd 31 a3 4a a3		        .word nt_comma, xt_tuck, z_tuck
>bd0f		74 75 63 6b			        .text "tuck"
.bd13						nt_comma:
>bd13		01 10				        .byte 1, UF
>bd15		1c bd 24 87 3d 87		        .word nt_c_fetch, xt_comma, z_comma
>bd1b		2c				        .text ","
.bd1c						nt_c_fetch:
>bd1c		02 10				        .byte 2, UF
>bd1e		26 bd c1 85 ca 85		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bd24		63 40				        .text "c@"
.bd26						nt_c_store:
>bd26		02 10				        .byte 2, UF
>bd28		30 bd cb 85 d6 85		        .word nt_plus_store, xt_c_store, z_c_store
>bd2e		63 21				        .text "c!"
.bd30						nt_plus_store:
>bd30		02 10				        .byte 2, UF
>bd32		3a bd da 99 f9 99		        .word nt_execute, xt_plus_store, z_plus_store
>bd38		2b 21				        .text "+!"
.bd3a						nt_execute:
>bd3a		07 10				        .byte 7, UF
>bd3c		49 bd 22 8f 28 8f		        .word nt_emit, xt_execute, z_execute
>bd42		65 78 65 63 75 74 65		        .text "execute"
.bd49						nt_emit:
>bd49		04 18				        .byte 4, NN+UF
>bd4b		55 bd d4 8d de 8d		        .word nt_type, xt_emit, z_emit
>bd51		65 6d 69 74			        .text "emit"
.bd55						nt_type:
>bd55		04 10				        .byte 4, UF
>bd57		61 bd a7 a4 d1 a4		        .word nt_dot, xt_type, z_type
>bd5d		74 79 70 65			        .text "type"
.bd61						nt_dot:
>bd61		01 10				        .byte 1, UF
>bd63		6a bd e9 8b 0a 8c		        .word nt_u_dot, xt_dot, z_dot
>bd69		2e				        .text "."
.bd6a						nt_u_dot:
>bd6a		02 10				        .byte 2, UF
>bd6c		74 bd d2 a4 dd a4		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd72		75 2e				        .text "u."
.bd74						nt_u_dot_r:
>bd74		03 10				        .byte 3, UF
>bd76		7f bd de a4 ff a4		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd7c		75 2e 72			        .text "u.r"
.bd7f						nt_dot_r:
>bd7f		02 10				        .byte 2, UF
>bd81		89 bd 25 8c 52 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd87		2e 72				        .text ".r"
.bd89						nt_d_dot:
>bd89		02 10				        .byte 2, UF
>bd8b		93 bd 97 8c b5 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd91		64 2e				        .text "d."
.bd93						nt_d_dot_r:
>bd93		03 10				        .byte 3, UF
>bd95		9e bd b6 8c e0 8c		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd9b		64 2e 72			        .text "d.r"
.bd9e						nt_ud_dot:
>bd9e		03 10				        .byte 3, UF
>bda0		a9 bd 2c a5 3e a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bda6		75 64 2e			        .text "ud."
.bda9						nt_ud_dot_r:
>bda9		04 10				        .byte 4, UF
>bdab		b5 bd 3f a5 5d a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bdb1		75 64 2e 72			        .text "ud.r"
.bdb5						nt_question:
>bdb5		01 00				        .byte 1, 0
>bdb7		be bd 46 9a 4c 9a		        .word nt_false, xt_question, z_question
>bdbd		3f				        .text "?"
.bdbe						nt_false:
>bdbe		05 00				        .byte 5, 0
>bdc0		cb bd 5e 8f 64 8f		        .word nt_true, xt_false, z_false
>bdc6		66 61 6c 73 65			        .text "false"
.bdcb						nt_true:
>bdcb		04 00				        .byte 4, 0
>bdcd		d7 bd 28 a3 30 a3		        .word nt_space, xt_true, z_true
>bdd3		74 72 75 65			        .text "true"
.bdd7						nt_space:
>bdd7		05 00				        .byte 5, 0
>bdd9		e4 bd cc a0 d1 a0		        .word nt_zero, xt_space, z_space
>bddf		73 70 61 63 65			        .text "space"
.bde4						nt_zero:
>bde4		01 00				        .byte 1, 0
>bde6		ed bd 56 a7 5c a7		        .word nt_one, xt_zero, z_zero
>bdec		30				        .text "0"
.bded						nt_one:
>bded		01 00				        .byte 1, 0
>bdef		f6 bd ec 97 f4 97		        .word nt_two, xt_one, z_one
>bdf5		31				        .text "1"
.bdf6						nt_two:
>bdf6		01 00				        .byte 1, 0
>bdf8		ff bd 4b a3 53 a3		        .word nt_two_dup, xt_two, z_two
>bdfe		32				        .text "2"
.bdff						nt_two_dup:
>bdff		04 10				        .byte 4, UF
>be01		0b be 5c a3 73 a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>be07		32 64 75 70			        .text "2dup"
.be0b						nt_question_dup:
>be0b		04 10				        .byte 4, UF
>be0d		17 be 4d 9a 60 9a		        .word nt_plus, xt_question_dup, z_question_dup
>be13		3f 64 75 70			        .text "?dup"
.be17						nt_plus:
>be17		01 10				        .byte 1, UF
>be19		20 be c7 99 d9 99		        .word nt_minus, xt_plus, z_plus
>be1f		2b				        .text "+"
.be20						nt_minus:
>be20		01 10				        .byte 1, UF
>be22		29 be 34 95 46 95		        .word nt_one_minus, xt_minus, z_minus
>be28		2d				        .text "-"
.be29						nt_one_minus:
>be29		02 10				        .byte 2, UF
>be2b		33 be f5 97 00 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>be31		31 2d				        .text "1-"
.be33						nt_one_plus:
>be33		02 10				        .byte 2, UF
>be35		3d be 01 98 0a 98		        .word nt_two_star, xt_one_plus, z_one_plus
>be3b		31 2b				        .text "1+"
.be3d						nt_two_star:
>be3d		02 10				        .byte 2, UF
>be3f		47 be f4 a3 fb a3		        .word nt_two_slash, xt_two_star, z_two_star
>be45		32 2a				        .text "2*"
.be47						nt_two_slash:
>be47		02 10				        .byte 2, UF
>be49		51 be e9 a3 f3 a3		        .word nt_abs, xt_two_slash, z_two_slash
>be4f		32 2f				        .text "2/"
.be51						nt_abs:
>be51		03 10				        .byte 3, UF
>be53		5c be cd 80 e1 80		        .word nt_dabs, xt_abs, z_abs
>be59		61 62 73			        .text "abs"
.be5c						nt_dabs:
>be5c		04 10				        .byte 4, UF
>be5e		68 be 4d 8a 6b 8a		        .word nt_and, xt_dabs, z_dabs
>be64		64 61 62 73			        .text "dabs"
.be68						nt_and:
>be68		03 10				        .byte 3, UF
>be6a		73 be d2 82 e3 82		        .word nt_or, xt_and, z_and
>be70		61 6e 64			        .text "and"
.be73						nt_or:
>be73		02 10				        .byte 2, UF
>be75		7d be 17 98 28 98		        .word nt_xor, xt_or, z_or
>be7b		6f 72				        .text "or"
.be7d						nt_xor:
>be7d		03 10				        .byte 3, UF
>be7f		88 be 44 a7 55 a7		        .word nt_rshift, xt_xor, z_xor
>be85		78 6f 72			        .text "xor"
.be88						nt_rshift:
>be88		06 10				        .byte 6, UF
>be8a		96 be 50 9b 63 9b		        .word nt_lshift, xt_rshift, z_rshift
>be90		72 73 68 69 66 74		        .text "rshift"
.be96						nt_lshift:
>be96		06 10				        .byte 6, UF
>be98		a4 be 5e 94 71 94		        .word nt_pick, xt_lshift, z_lshift
>be9e		6c 73 68 69 66 74		        .text "lshift"
.bea4						nt_pick:
>bea4		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bea6		b0 be b6 99 c6 99		        .word nt_char, xt_pick, z_pick
>beac		70 69 63 6b			        .text "pick"
.beb0						nt_char:
>beb0		04 00				        .byte 4, 0
>beb2		bc be e7 85 fd 85		        .word nt_bracket_char, xt_char, z_char
>beb8		63 68 61 72			        .text "char"
.bebc						nt_bracket_char:
>bebc		06 05				        .byte 6, CO+IM
>bebe		ca be 4d 85 53 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bec4		5b 63 68 61 72 5d		        .text "[char]"
.beca						nt_char_plus:
>beca		05 00				        .byte 5, 0
>becc		d7 be 01 98 0a 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bed2		63 68 61 72 2b			        .text "char+"
.bed7						nt_chars:
>bed7		05 12				        .byte 5, AN+UF   ; deleted during compile
>bed9		e4 be fe 85 01 86		        .word nt_cells, xt_chars, z_chars
>bedf		63 68 61 72 73			        .text "chars"
.bee4						nt_cells:
>bee4		05 00				        .byte 5, 0
>bee6		f1 be f4 a3 fb a3		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>beec		63 65 6c 6c 73			        .text "cells"
.bef1						nt_cell_plus:
>bef1		05 10				        .byte 5, UF
>bef3		fe be d7 85 e6 85		        .word nt_here, xt_cell_plus, z_cell_plus
>bef9		63 65 6c 6c 2b			        .text "cell+"
.befe						nt_here:
>befe		04 00				        .byte 4, 0
>bf00		0a bf 57 91 61 91		        .word nt_equal, xt_here, z_here
>bf06		68 65 72 65			        .text "here"
.bf0a						nt_equal:
>bf0a		01 10				        .byte 1, UF
>bf0c		13 bf b3 8e ce 8e		        .word nt_not_equals, xt_equal, z_equal
>bf12		3d				        .text "="
.bf13						nt_not_equals:
>bf13		02 10				        .byte 2, UF
>bf15		1d bf 34 96 51 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bf1b		3c 3e				        .text "<>"
.bf1d						nt_less_than:
>bf1d		01 10				        .byte 1, UF
>bf1f		26 bf 49 93 5d 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bf25		3c				        .text "<"
.bf26						nt_u_less_than:
>bf26		02 10				        .byte 2, UF
>bf28		30 bf 16 a5 2b a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bf2e		75 3c				        .text "u<"
.bf30						nt_u_greater_than:
>bf30		02 10				        .byte 2, UF
>bf32		3a bf 00 a5 15 a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bf38		75 3e				        .text "u>"
.bf3a						nt_greater_than:
>bf3a		01 10				        .byte 1, UF
>bf3c		43 bf 42 91 56 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bf42		3e				        .text ">"
.bf43						nt_zero_equal:
>bf43		02 10				        .byte 2, UF
>bf45		4d bf 5d a7 6e a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bf4b		30 3d				        .text "0="
.bf4d						nt_zero_unequal:
>bf4d		03 10				        .byte 3, UF
>bf4f		58 bf 93 a7 a2 a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bf55		30 3c 3e			        .text "0<>"
.bf58						nt_zero_greater:
>bf58		02 10				        .byte 2, UF
>bf5a		62 bf 6f a7 82 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf60		30 3e				        .text "0>"
.bf62						nt_zero_less:
>bf62		02 10				        .byte 2, UF
>bf64		6c bf 83 a7 92 a7		        .word nt_min, xt_zero_less, z_zero_less
>bf6a		30 3c				        .text "0<"
.bf6c						nt_min:
>bf6c		03 10				        .byte 3, UF
>bf6e		77 bf 18 95 33 95		        .word nt_max, xt_min, z_min
>bf74		6d 69 6e			        .text "min"
.bf77						nt_max:
>bf77		03 10				        .byte 3, UF
>bf79		82 bf fc 94 17 95		        .word nt_two_drop, xt_max, z_max
>bf7f		6d 61 78			        .text "max"
.bf82						nt_two_drop:
>bf82		05 10				        .byte 5, UF
>bf84		8f bf 54 a3 5b a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf8a		32 64 72 6f 70			        .text "2drop"
.bf8f						nt_two_swap:
>bf8f		05 10				        .byte 5, UF
>bf91		9c bf 22 a4 45 a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf97		32 73 77 61 70			        .text "2swap"
.bf9c						nt_two_over:
>bf9c		05 10				        .byte 5, UF
>bf9e		a9 bf 96 a3 ad a3		        .word nt_two_store, xt_two_over, z_two_over
>bfa4		32 6f 76 65 72			        .text "2over"
.bfa9						nt_two_store:
>bfa9		02 10				        .byte 2, UF
>bfab		b3 bf fc a3 21 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bfb1		32 21				        .text "2!"
.bfb3						nt_two_fetch:
>bfb3		02 10				        .byte 2, UF
>bfb5		bd bf 74 a3 95 a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bfbb		32 40				        .text "2@"
.bfbd						nt_two_variable:
>bfbd		09 00				        .byte 9, 0
>bfbf		ce bf 98 a4 a6 a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>bfc5		32 76 61 72 69 61 62 6c		        .text "2variable"
>bfcd		65
.bfce						nt_two_constant:
>bfce		09 10				        .byte 9, UF
>bfd0		df bf 66 a4 8a a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bfd6		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bfde		74
.bfdf						nt_two_literal:
>bfdf		08 14				        .byte 8, UF+IM
>bfe1		ef bf 8b a4 97 a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bfe7		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bfef						nt_two_r_fetch:
>bfef		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bff1		fa bf ae a3 cb a3		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bff7		32 72 40			        .text "2r@"
.bffa						nt_two_r_from:
>bffa		03 01				        .byte 3, CO             ; native is special case
>bffc		05 c0 cc a3 e8 a3		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>c002		32 72 3e			        .text "2r>"
.c005						nt_two_to_r:
>c005		03 11				        .byte 3, CO+UF          ; native is special case
>c007		10 c0 46 a4 65 a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>c00d		32 3e 72			        .text "2>r"
.c010						nt_invert:
>c010		06 10				        .byte 6, UF
>c012		1e c0 cc 92 db 92		        .word nt_negate, xt_invert, z_invert
>c018		69 6e 76 65 72 74		        .text "invert"
.c01e						nt_negate:
>c01e		06 10				        .byte 6, UF
>c020		2c c0 07 96 17 96		        .word nt_dnegate, xt_negate, z_negate
>c026		6e 65 67 61 74 65		        .text "negate"
.c02c						nt_dnegate:
>c02c		07 10				        .byte 7, UF
>c02e		3b c0 08 8b 22 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>c034		64 6e 65 67 61 74 65		        .text "dnegate"
.c03b						nt_c_comma:
>c03b		02 10				        .byte 2, UF
>c03d		45 c0 b6 85 c0 85		        .word nt_bounds, xt_c_comma, z_c_comma
>c043		63 2c				        .text "c,"
.c045						nt_bounds:
>c045		06 10				        .byte 6, UF
>c047		53 c0 34 85 4c 85		        .word nt_spaces, xt_bounds, z_bounds
>c04d		62 6f 75 6e 64 73		        .text "bounds"
.c053						nt_spaces:
>c053		06 10				        .byte 6, UF
>c055		61 c0 d2 a0 0d a1		        .word nt_bl, xt_spaces, z_spaces
>c05b		73 70 61 63 65 73		        .text "spaces"
.c061						nt_bl:
>c061		02 00				        .byte 2, 0
>c063		6b c0 50 83 58 83		        .word nt_minus_trailing, xt_bl, z_bl
>c069		62 6c				        .text "bl"
.c06b						nt_minus_trailing:
>c06b		09 10				        .byte 9, UF
>c06d		7c c0 60 95 9c 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c073		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c07b		67
.c07c						nt_minus_leading:
>c07c		08 10				        .byte 8, UF
>c07e		8c c0 47 95 5f 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c084		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c08c						nt_slash_string:
>c08c		07 10				        .byte 7, UF
>c08e		9b c0 c7 9f e6 9f		        .word nt_refill, xt_slash_string, z_slash_string
>c094		2f 73 74 72 69 6e 67		        .text "/string"
.c09b						nt_refill:
>c09b		06 00				        .byte 6, 0
>c09d		a9 c0 dc 9a 1d 9b		        .word nt_accept, xt_refill, z_refill
>c0a3		72 65 66 69 6c 6c		        .text "refill"
.c0a9						nt_accept:
>c0a9		06 18				        .byte 6, UF+NN
>c0ab		b7 c0 e2 80 da 81		        .word nt_input_to_r, xt_accept, z_accept
>c0b1		61 63 63 65 70 74		        .text "accept"
.c0b7						nt_input_to_r:
>c0b7		07 08				        .byte 7, NN
>c0b9		c6 c0 43 92 58 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c0bf		69 6e 70 75 74 3e 72		        .text "input>r"
.c0c6						nt_r_to_input:
>c0c6		07 08				        .byte 7, NN
>c0c8		d5 c0 87 9a 9e 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c0ce		72 3e 69 6e 70 75 74		        .text "r>input"
.c0d5						nt_unused:
>c0d5		06 00				        .byte 6, 0
>c0d7		e3 c0 02 a6 11 a6		        .word nt_depth, xt_unused, z_unused
>c0dd		75 6e 75 73 65 64		        .text "unused"
.c0e3						nt_depth:
>c0e3		05 00				        .byte 5, 0
>c0e5		f0 c0 bd 8a cb 8a		        .word nt_key, xt_depth, z_depth
>c0eb		64 65 70 74 68			        .text "depth"
.c0f0						nt_key:
>c0f0		03 00				        .byte 3, 0
>c0f2		fb c0 0f 93 18 93		        .word nt_allot, xt_key, z_key
>c0f8		6b 65 79			        .text "key"
.c0fb						nt_allot:
>c0fb		05 10				        .byte 5, UF
>c0fd		08 c1 3f 82 a7 82		        .word nt_create, xt_allot, z_allot
>c103		61 6c 6c 6f 74			        .text "allot"
.c108						nt_create:
>c108		06 00				        .byte 6, 0
>c10a		16 c1 30 89 04 8a		        .word nt_does, xt_create, z_create
>c110		63 72 65 61 74 65		        .text "create"
.c116						nt_does:
>c116		05 05				        .byte 5, CO+IM
>c118		23 c1 a8 8b b6 8b		        .word nt_variable, xt_does, z_does
>c11e		64 6f 65 73 3e			        .text "does>"
.c123						nt_variable:
>c123		08 00				        .byte 8, 0
>c125		33 c1 26 a6 3e a6		        .word nt_constant, xt_variable, z_variable
>c12b		76 61 72 69 61 62 6c 65		        .text "variable"
.c133						nt_constant:
>c133		08 10				        .byte 8, UF
>c135		43 c1 d8 88 15 89		        .word nt_value, xt_constant, z_constant
>c13b		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c143						nt_value:
>c143		05 10				        .byte 5, UF
>c145		50 c1 d8 88 15 89		        .word nt_to, xt_constant, z_constant
>c14b		76 61 6c 75 65			        .text "value"
.c150						nt_to:
>c150		02 0c				        .byte 2, NN+IM
>c152		5a c1 d5 a1 30 a2		        .word nt_s_to_d, xt_to, z_to
>c158		74 6f				        .text "to"
.c15a						nt_s_to_d:
>c15a		03 10				        .byte 3, UF
>c15c		65 c1 5a 9e 6b 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c162		73 3e 64			        .text "s>d"
.c165						nt_d_to_s:
>c165		03 10				        .byte 3, UF
>c167		70 c1 47 8a 4c 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c16d		64 3e 73			        .text "d>s"
.c170						nt_d_minus:
>c170		02 10				        .byte 2, UF
>c172		7a c1 05 8a 25 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c178		64 2d				        .text "d-"
.c17a						nt_d_plus:
>c17a		02 10				        .byte 2, UF
>c17c		84 c1 26 8a 46 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c182		64 2b				        .text "d+"
.c184						nt_erase:
>c184		05 00				        .byte 5, 0      ; underflow checked by FILL
>c186		91 c1 d9 8e 21 8f		        .word nt_blank, xt_erase, z_erase
>c18c		65 72 61 73 65			        .text "erase"
.c191						nt_blank:
>c191		05 00				        .byte 5, 0     ; underflow checked by FILL
>c193		9e c1 cf 8e 21 8f		        .word nt_fill, xt_blank, z_blank
>c199		62 6c 61 6e 6b			        .text "blank"
.c19e						nt_fill:
>c19e		04 10				        .byte 4, UF
>c1a0		aa c1 df 8e 21 8f		        .word nt_find_name, xt_fill, z_fill
>c1a6		66 69 6c 6c			        .text "fill"
.c1aa						nt_find_name:
>c1aa		09 10				        .byte 9, UF
>c1ac		bb c1 c0 8f 6b 90		        .word nt_tick, xt_find_name, z_find_name
>c1b2		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c1ba		65
.c1bb						nt_tick:
>c1bb		01 00				        .byte 1, 0
>c1bd		c4 c1 b5 a1 d4 a1		        .word nt_bracket_tick, xt_tick, z_tick
>c1c3		27				        .text "'"
.c1c4						nt_bracket_tick:
>c1c4		03 05				        .byte 3, CO+IM
>c1c6		cf c1 54 85 5a 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c1cc		5b 27 5d			        .text "[']"
.c1cf						nt_name_to_int:
>c1cf		08 10				        .byte 8, UF
>c1d1		df c1 c5 95 e1 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c1d7		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c1df						nt_int_to_name:
>c1df		08 10				        .byte 8, UF
>c1e1		ef c1 59 92 cb 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c1e7		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c1ef						nt_name_to_string:
>c1ef		0b 10				        .byte 11, UF
>c1f1		02 c2 e2 95 fb 95		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c1f7		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1ff		69 6e 67
.c202						nt_to_body:
>c202		05 10				        .byte 5, UF
>c204		0f c2 31 a2 55 a2		        .word nt_defer, xt_to_body, z_to_body
>c20a		3e 62 6f 64 79			        .text ">body"
.c20f						nt_defer:
>c20f		05 00				        .byte 5, 0
>c211		1c c2 73 8a a5 8a		        .word nt_latestxt, xt_defer, z_defer
>c217		64 65 66 65 72			        .text "defer"
.c21c						nt_latestxt:
>c21c		08 00				        .byte 8, 0
>c21e		2c c2 2a 93 30 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c224		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c22c						nt_latestnt:
>c22c		08 00				        .byte 8, 0
>c22e		3c c2 1c 93 29 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c234		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c23c						nt_parse_name:
>c23c		0a 08				        .byte 10, NN
>c23e		4e c2 c3 98 b5 99		        .word nt_parse, xt_parse_name, z_parse_name
>c244		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c24c		6d 65
.c24e						nt_parse:
>c24e		05 10				        .byte 5, UF
>c250		5b c2 1e 99 b5 99		        .word nt_execute_parsing, xt_parse, z_parse
>c256		70 61 72 73 65			        .text "parse"
.c25b						nt_execute_parsing:
>c25b		0f 10				        .byte 15, UF
>c25d		72 c2 36 8f 5c 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c263		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c26b		70 61 72 73 69 6e 67
.c272						nt_source:
>c272		06 00				        .byte 6, 0
>c274		80 c2 ac a0 c0 a0		        .word nt_source_id, xt_source, z_source
>c27a		73 6f 75 72 63 65		        .text "source"
.c280						nt_source_id:
>c280		09 00				        .byte 9, 0
>c282		91 c2 c1 a0 cb a0		        .word nt_colon, xt_source_id, z_source_id
>c288		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c290		64
.c291						nt_colon:
>c291		01 00				        .byte 1, 0
>c293		9a c2 c5 86 07 87		        .word nt_semicolon, xt_colon, z_colon
>c299		3a				        .text ":"
.c29a						nt_semicolon:
>c29a		01 05				        .byte 1, CO+IM
>c29c		a3 c2 36 9f 94 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c2a2		3b				        .text ";"
.c2a3						nt_colon_noname:
>c2a3		07 00				        .byte 7, 0
>c2a5		b2 c2 08 87 23 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c2ab		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c2b2						nt_compile_comma:
>c2b2		08 18				        .byte 8, UF+NN
>c2b4		c2 c2 a3 87 cb 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c2ba		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c2c2						nt_left_bracket:
>c2c2		01 05				        .byte 1, IM+CO
>c2c4		cb c2 36 93 3a 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c2ca		5b				        .text "["
.c2cb						nt_right_bracket:
>c2cb		01 04				        .byte 1, IM
>c2cd		d4 c2 24 9b 2a 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c2d3		5d				        .text "]"
.c2d4						nt_literal:
>c2d4		07 15				        .byte 7, IM+CO+UF
>c2d6		e3 c2 6b 93 78 93		        .word nt_sliteral, xt_literal, z_literal
>c2dc		6c 69 74 65 72 61 6c		        .text "literal"
.c2e3						nt_sliteral:
>c2e3		08 15				        .byte 8, CO+IM+UF
>c2e5		f3 c2 e7 9f 56 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c2eb		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c2f3						nt_dot_quote:
>c2f3		02 05				        .byte 2, CO+IM
>c2f5		fd c2 1a 8c 24 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2fb		2e 22				        .text ".", $22
.c2fd						nt_s_quote:
>c2fd		02 0c				        .byte 2, IM+NN
>c2ff		07 c3 2c 9d 59 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c305		73 22				        .text "s", $22
.c307						nt_s_backslash_quote:
>c307		03 04				        .byte 3, IM
>c309		12 c3 64 9b 6d 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c30f		73 5c 22			        .text "s", $5C, $22
.c312						nt_postpone:
>c312		08 05				        .byte 8, IM+CO
>c314		22 c3 fa 99 38 9a		        .word nt_immediate, xt_postpone, z_postpone
>c31a		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c322						nt_immediate:
>c322		09 00				        .byte 9, 0
>c324		33 c3 2c 92 37 92		        .word nt_compile_only, xt_immediate, z_immediate
>c32a		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c332		65
.c333						nt_compile_only:
>c333		0c 00				        .byte 12, 0
>c335		47 c3 cc 88 d7 88		        .word nt_never_native, xt_compile_only, z_compile_only
>c33b		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c343		6f 6e 6c 79
.c347						nt_never_native:
>c347		0c 00				        .byte 12, 0
>c349		5b c3 18 96 25 96		        .word nt_always_native, xt_never_native, z_never_native
>c34f		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c357		74 69 76 65
.c35b						nt_always_native:
>c35b		0d 00				        .byte 13, 0
>c35d		70 c3 c4 82 d1 82		        .word nt_allow_native, xt_always_native, z_always_native
>c363		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c36b		61 74 69 76 65
.c370						nt_allow_native:
>c370		0c 00				        .byte 12, 0
>c372		84 c3 a8 82 b3 82		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c378		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c380		74 69 76 65
.c384						nt_nc_limit:
>c384		08 00				        .byte 8, 0
>c386		94 c3 fc 95 06 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c38c		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c394						nt_strip_underflow:
>c394		0f 00				        .byte 15, 0
>c396		ab c3 51 a1 5b a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c39c		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c3a4		64 65 72 66 6c 6f 77
.c3ab						nt_abort:
>c3ab		05 00				        .byte 5, 0
>c3ad		b8 c3 60 80 ad 80		        .word nt_abort_quote, xt_abort, z_abort
>c3b3		61 62 6f 72 74			        .text "abort"
.c3b8						nt_abort_quote:
>c3b8		06 0d				        .byte 6, CO+IM+NN
>c3ba		c6 c3 ad 80 b7 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c3c0		61 62 6f 72 74 22		        .text "abort", $22
.c3c6						nt_do:
>c3c6		02 0d				        .byte 2, CO+IM+NN
>c3c8		d0 c3 29 8b 62 8b		        .word nt_question_do, xt_do, z_do
>c3ce		64 6f				        .text "do"
.c3d0						nt_question_do:
>c3d0		03 0d				        .byte 3, CO+IM+NN
>c3d2		db c3 23 8b 62 8b		        .word nt_i, xt_question_do, z_question_do
>c3d8		3f 64 6f			        .text "?do"
.c3db						nt_i:
>c3db		01 03				        .byte 1, AN+CO
>c3dd		e4 c3 ce 91 e5 91		        .word nt_j, xt_i, z_i
>c3e3		69				        .text "i"
.c3e4						nt_j:
>c3e4		01 03				        .byte 1, AN+CO
>c3e6		ed c3 f5 92 0e 93		        .word nt_loop, xt_j, z_j
>c3ec		6a				        .text "j"
.c3ed						nt_loop:
>c3ed		04 05				        .byte 4, CO+IM
>c3ef		f9 c3 dc 93 39 94		        .word nt_plus_loop, xt_loop, z_loop
>c3f5		6c 6f 6f 70			        .text "loop"
.c3f9						nt_plus_loop:
>c3f9		05 05				        .byte 5, CO+IM
>c3fb		06 c4 ed 93 39 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c401		2b 6c 6f 6f 70			        .text "+loop"
.c406						nt_exit:
>c406		04 03				        .byte 4, AN+CO
>c408		12 c4 5d 8f 5e 8f		        .word nt_unloop, xt_exit, z_exit
>c40e		65 78 69 74			        .text "exit"
.c412						nt_unloop:
>c412		06 03				        .byte 6, AN+CO
>c414		20 c4 e6 a5 ec a5		        .word nt_leave, xt_unloop, z_unloop
>c41a		75 6e 6c 6f 6f 70		        .text "unloop"
.c420						nt_leave:
>c420		05 03				        .byte 5, AN+CO
>c422		2d c4 31 93 36 93		        .word nt_recurse, xt_leave, z_leave
>c428		6c 65 61 76 65			        .text "leave"
.c42d						nt_recurse:
>c42d		07 0d				        .byte 7, CO+IM+NN
>c42f		3c c4 9f 9a db 9a		        .word nt_quit, xt_recurse, z_recurse
>c435		72 65 63 75 72 73 65		        .text "recurse"
.c43c						nt_quit:
>c43c		04 00				        .byte 4, 0
>c43e		48 c4 62 80 ad 80		        .word nt_begin, xt_quit, z_quit
>c444		71 75 69 74			        .text "quit"
.c448						nt_begin:
>c448		05 07				        .byte 5, AN+CO+IM
>c44a		55 c4 46 83 49 83		        .word nt_again, xt_begin, z_begin
>c450		62 65 67 69 6e			        .text "begin"
.c455						nt_again:
>c455		05 17				        .byte 5, AN+CO+IM+UF
>c457		62 c4 1d 82 3d 82		        .word nt_state, xt_again, z_again
>c45d		61 67 61 69 6e			        .text "again"
.c462						nt_state:
>c462		05 00				        .byte 5, 0
>c464		6f c4 30 a1 3a a1		        .word nt_evaluate, xt_state, z_state
>c46a		73 74 61 74 65			        .text "state"
.c46f						nt_evaluate:
>c46f		08 10				        .byte 8, UF
>c471		7f c4 ba 90 0d 91		        .word nt_base, xt_evaluate, z_evaluate
>c477		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c47f						nt_base:
>c47f		04 00				        .byte 4, 0
>c481		8b c4 3d 83 45 83		        .word nt_digit_question, xt_base, z_base
>c487		62 61 73 65			        .text "base"
.c48b						nt_digit_question:
>c48b		06 10				        .byte 6, UF
>c48d		99 c4 cc 8a 00 8b		        .word nt_number, xt_digit_question, z_digit_question
>c493		64 69 67 69 74 3f		        .text "digit?"
.c499						nt_number:
>c499		06 10				        .byte 6, UF
>c49b		a7 c4 6e 96 6a 97		        .word nt_to_number, xt_number, z_number
>c4a1		6e 75 6d 62 65 72		        .text "number"
.c4a7						nt_to_number:
>c4a7		07 10				        .byte 7, UF
>c4a9		b6 c4 61 a2 00 a3		        .word nt_hex, xt_to_number, z_to_number
>c4af		3e 6e 75 6d 62 65 72		        .text ">number"
.c4b6						nt_hex:
>c4b6		03 00				        .byte 3, 0
>c4b8		c1 c4 62 91 68 91		        .word nt_decimal, xt_hex, z_hex
>c4be		68 65 78			        .text "hex"
.c4c1						nt_decimal:
>c4c1		07 00				        .byte 7, 0
>c4c3		d0 c4 6c 8a 72 8a		        .word nt_count, xt_decimal, z_decimal
>c4c9		64 65 63 69 6d 61 6c		        .text "decimal"
.c4d0						nt_count:
>c4d0		05 10				        .byte 5, UF
>c4d2		dd c4 16 89 29 89		        .word nt_m_star, xt_count, z_count
>c4d8		63 6f 75 6e 74			        .text "count"
.c4dd						nt_m_star:
>c4dd		02 10				        .byte 2, UF
>c4df		e7 c4 72 94 8c 94		        .word nt_um_star, xt_m_star, z_m_star
>c4e5		6d 2a				        .text "m*"
.c4e7						nt_um_star:
>c4e7		03 10				        .byte 3, UF
>c4e9		f2 c4 a0 a5 e5 a5		        .word nt_star, xt_um_star, z_um_star
>c4ef		75 6d 2a			        .text "um*"
.c4f2						nt_star:
>c4f2		01 10				        .byte 1, UF
>c4f4		fb c4 0e a1 16 a1		        .word nt_um_slash_mod, xt_star, z_star
>c4fa		2a				        .text "*"
.c4fb						nt_um_slash_mod:
>c4fb		06 10				        .byte 6, UF
>c4fd		09 c5 5e a5 9f a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c503		75 6d 2f 6d 6f 64		        .text "um/mod"
.c509						nt_sm_slash_rem:
>c509		06 10				        .byte 6, UF
>c50b		17 c5 83 a0 ab a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c511		73 6d 2f 72 65 6d		        .text "sm/rem"
.c517						nt_fm_slash_mod:
>c517		06 10				        .byte 6, UF
>c519		25 c5 76 90 ac 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c51f		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c525						nt_slash:
>c525		01 10				        .byte 1, UF
>c527		2e c5 aa 9f c6 9f		        .word nt_slash_mod, xt_slash, z_slash
>c52d		2f				        .text "/"
.c52e						nt_slash_mod:
>c52e		04 10				        .byte 4, UF
>c530		3a c5 af 9f c6 9f		        .word nt_mod, xt_slash_mod, z_slash_mod
>c536		2f 6d 6f 64			        .text "/mod"
.c53a						nt_mod:
>c53a		03 10				        .byte 3, UF
>c53c		45 c5 9d 95 a5 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c542		6d 6f 64			        .text "mod"
.c545						nt_star_slash_mod:
>c545		05 10				        .byte 5, UF
>c547		52 c5 20 a1 2f a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c54d		2a 2f 6d 6f 64			        .text "*/mod"
.c552						nt_star_slash:
>c552		02 10				        .byte 2, UF
>c554		5c c5 17 a1 1f a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c55a		2a 2f				        .text "*/"
.c55c						nt_backslash:
>c55c		01 04				        .byte 1, IM
>c55e		65 c5 12 83 3c 83		        .word nt_move, xt_backslash, z_backslash
>c564		5c				        .byte $5c
.c565						nt_move:
>c565		04 18				        .byte 4, NN+UF
>c567		71 c5 a6 95 c4 95		        .word nt_cmove_up, xt_move, z_move
>c56d		6d 6f 76 65			        .text "move"
.c571						nt_cmove_up:
>c571		06 10				        .byte 6, UF
>c573		7f c5 8a 86 c4 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c579		63 6d 6f 76 65 3e		        .text "cmove>"
.c57f						nt_cmove:
>c57f		05 10				        .byte 5, UF
>c581		8c c5 4f 86 89 86		        .word nt_pad, xt_cmove, z_cmove
>c587		63 6d 6f 76 65			        .text "cmove"
.c58c						nt_pad:
>c58c		03 00				        .byte 3, 0
>c58e		97 c5 85 98 94 98		        .word nt_cleave, xt_pad, z_pad
>c594		70 61 64			        .text "pad"
.c597						nt_cleave:
>c597		06 10				        .byte 6, UF
>c599		a5 c5 02 86 4e 86		        .word nt_hexstore, xt_cleave, z_cleave
>c59f		63 6c 65 61 76 65		        .text "cleave"
.c5a5						nt_hexstore:
>c5a5		08 10				        .byte 8, UF
>c5a7		b5 c5 69 91 bb 91		        .word nt_within, xt_hexstore, z_hexstore
>c5ad		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c5b5						nt_within:
>c5b5		06 10				        .byte 6, UF
>c5b7		c3 c5 53 a6 68 a6		        .word nt_to_in, xt_within, z_within
>c5bd		77 69 74 68 69 6e		        .text "within"
.c5c3						nt_to_in:
>c5c3		03 00				        .byte 3, 0
>c5c5		ce c5 56 a2 60 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c5cb		3e 69 6e			        .text ">in"
.c5ce						nt_less_number_sign:
>c5ce		02 00				        .byte 2, 0
>c5d0		d8 c5 3b 93 48 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c5d6		3c 23				        .text "<#"
.c5d8						nt_number_sign:
>c5d8		01 10				        .byte 1, UF
>c5da		e1 c5 6b 97 9f 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c5e0		23				        .text "#"
.c5e1						nt_number_sign_s:
>c5e1		02 10				        .byte 2, UF
>c5e3		eb c5 c2 97 d2 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c5e9		23 73				        .text "#s"
.c5eb						nt_number_sign_greater:
>c5eb		02 10				        .byte 2, UF
>c5ed		f5 c5 a0 97 c1 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c5f3		23 3e				        .text "#>"
.c5f5						nt_hold:
>c5f5		04 10				        .byte 4, UF
>c5f7		01 c6 bc 91 cd 91		        .word nt_sign, xt_hold, z_hold
>c5fd		68 6f 6c 64			        .text "hold"
.c601						nt_sign:
>c601		04 10				        .byte 4, UF
>c603		0d c6 95 9f a9 9f		        .word nt_output, xt_sign, z_sign
>c609		73 69 67 6e			        .text "sign"
.c60d						nt_output:
>c60d		06 00				        .byte 6, 0
>c60f		1b c6 6c 98 76 98		        .word nt_input, xt_output, z_output
>c615		6f 75 74 70 75 74		        .text "output"
.c61b						nt_input:
>c61b		05 00				        .byte 5, 0
>c61d		28 c6 38 92 42 92		        .word nt_cr, xt_input, z_input
>c623		69 6e 70 75 74			        .text "input"
.c628						nt_cr:
>c628		02 00				        .byte 2, 0
>c62a		32 c6 2a 89 2f 89		        .word nt_page, xt_cr, z_cr
>c630		63 72				        .text "cr"
.c632						nt_page:
>c632		04 00				        .byte 4, 0
>c634		3e c6 95 98 b2 98		        .word nt_at_xy, xt_page, z_page
>c63a		70 61 67 65			        .text "page"
.c63e						nt_at_xy:
>c63e		05 10				        .byte 5, UF
>c640		4b c6 e4 82 11 83		        .word nt_marker, xt_at_xy, z_at_xy
>c646		61 74 2d 78 79			        .text "at-xy"
.c64b						nt_marker:
>c64b		06 04				        .byte 6, IM
>c64d		59 c6 8d 94 ca 94		        .word nt_words, xt_marker, z_marker
>c653		6d 61 72 6b 65 72		        .text "marker"
.c659						nt_words:
>c659		05 00				        .byte 5, 0
>c65b		66 c6 c6 a6 22 a7		        .word nt_wordsize, xt_words, z_words
>c661		77 6f 72 64 73			        .text "words"
.c666						nt_wordsize:
>c666		08 10				        .byte 8, UF
>c668		76 c6 23 a7 43 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c66e		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c676						nt_aligned:
>c676		07 00				        .byte 7, 0
>c678		85 c6 3e 82 3e 82		        .word nt_align, xt_align, z_align
>c67e		61 6c 69 67 6e 65 64		        .text "aligned"
.c685						nt_align:
>c685		05 00				        .byte 5, 0
>c687		92 c6 3e 82 3e 82		        .word nt_bell, xt_align, z_align
>c68d		61 6c 69 67 6e			        .text "align"
.c692						nt_bell:
>c692		04 00				        .byte 4, 0
>c694		9e c6 4a 83 4f 83		        .word nt_dump, xt_bell, z_bell
>c69a		62 65 6c 6c			        .text "bell"
.c69e						nt_dump:
>c69e		04 10				        .byte 4, UF
>c6a0		aa c6 e7 8c 4d 8d		        .word nt_dot_s, xt_dump, z_dump
>c6a6		64 75 6d 70			        .text "dump"
.c6aa						nt_dot_s:
>c6aa		02 00				        .byte 2, 0
>c6ac		b4 c6 53 8c 96 8c		        .word +, xt_dot_s, z_dot_s
>c6b2		2e 73				        .text ".s"
.c6b4						+
.c6b4						nt_disasm:
>c6b4		06 10				        .byte 6, UF
>c6b6		c2 c6 01 8b 07 8b		        .word +, xt_disasm, z_disasm
>c6bc		64 69 73 61 73 6d		        .text "disasm"
.c6c2						+
.c6c2						nt_compare:
>c6c2		07 10				        .byte 7, UF
>c6c4		d1 c6 3e 87 a2 87		        .word nt_search, xt_compare, z_compare
>c6ca		63 6f 6d 70 61 72 65		        .text "compare"
.c6d1						nt_search:
>c6d1		06 18				        .byte 6, UF+NN
>c6d3		df c6 97 9e 35 9f		        .word +, xt_search, z_search
>c6d9		73 65 61 72 63 68		        .text "search"
.c6df						+
.c6df						nt_environment_q:
>c6df		0c 10				        .byte 12, UF
>c6e1		f3 c6 fa 8d 76 8e		        .word +, xt_environment_q, z_environment_q
>c6e7		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6ef		65 6e 74 3f
.c6f3						+
.c6f3						nt_find:
>c6f3		04 10				        .byte 4, UF
>c6f5		ff c6 78 8f bf 8f		        .word nt_word, xt_find, z_find
>c6fb		66 69 6e 64			        .text "find"
.c6ff						nt_word:
>c6ff		04 10				        .byte 4, UF
>c701		0b c7 69 a6 ae a6		        .word nt_paren, xt_word, z_word
>c707		77 6f 72 64			        .text "word"
.c70b						nt_paren:
>c70b		01 04				        .byte 1, IM
>c70d		14 c7 b3 98 c2 98		        .word nt_dot_paren, xt_paren, z_paren
>c713		28				        .text "("
.c714						nt_dot_paren:
>c714		02 04				        .byte 2, IM
>c716		1e c7 0b 8c 19 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c71c		2e 28				        .text ".("
.c71e						nt_if:
>c71e		02 0d				        .byte 2, IM+CO+NN
>c720		28 c7 e6 91 f6 91		        .word nt_then, xt_if, z_if
>c726		69 66				        .text "if"
.c728						nt_then:
>c728		04 0d				        .byte 4, IM+CO+NN
>c72a		34 c7 85 8d ce 8d		        .word nt_else, xt_then, z_then
>c730		74 68 65 6e			        .text "then"
.c734						nt_else:
>c734		04 0d				        .byte 4, IM+CO+NN
>c736		40 c7 74 8d ce 8d		        .word nt_repeat, xt_else, z_else
>c73c		65 6c 73 65			        .text "else"
.c740						nt_repeat:
>c740		06 0d				        .byte 6, IM+CO+NN
>c742		4e c7 1e 9b 24 9b		        .word nt_until, xt_repeat, z_repeat
>c748		72 65 70 65 61 74		        .text "repeat"
.c74e						nt_until:
>c74e		05 0d				        .byte 5, IM+CO+NN
>c750		5b c7 ed a5 01 a6		        .word nt_while, xt_until, z_until
>c756		75 6e 74 69 6c			        .text "until"
.c75b						nt_while:
>c75b		05 0d				        .byte 5, IM+CO+NN
>c75d		68 c7 3f a6 52 a6		        .word nt_case, xt_while, z_while
>c763		77 68 69 6c 65			        .text "while"
.c768						nt_case:
>c768		04 0d				        .byte 4, IM+CO+NN
>c76a		74 c7 56 a7 5c a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c770		63 61 73 65			        .text "case"
.c774						nt_of:
>c774		02 0d				        .byte 2, IM+CO+NN
>c776		7e c7 d3 97 eb 97		        .word nt_endof, xt_of, z_of
>c77c		6f 66				        .text "of"
.c77e						nt_endof:
>c77e		05 0d				        .byte 5, IM+CO+NN
>c780		8b c7 74 8d ce 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c786		65 6e 64 6f 66			        .text "endof"
.c78b						nt_endcase:
>c78b		07 0d				        .byte 7, IM+CO+NN
>c78d		9a c7 e5 8d f9 8d		        .word nt_defer_fetch, xt_endcase, z_endcase
>c793		65 6e 64 63 61 73 65		        .text "endcase"
.c79a						nt_defer_fetch:
>c79a		06 00				        .byte 6, 0
>c79c		a8 c7 a6 8a ac 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c7a2		64 65 66 65 72 40		        .text "defer@"
.c7a8						nt_defer_store:
>c7a8		06 00				        .byte 6, 0
>c7aa		b6 c7 ad 8a b3 8a		        .word nt_is, xt_defer_store, z_defer_store
>c7b0		64 65 66 65 72 21		        .text "defer!"
.c7b6						nt_is:
>c7b6		02 04				        .byte 2, IM
>c7b8		c0 c7 dc 92 f4 92		        .word nt_action_of, xt_is, z_is
>c7be		69 73				        .text "is"
.c7c0						nt_action_of:
>c7c0		09 04				        .byte 9, IM
>c7c2		d1 c7 04 82 1c 82		        .word nt_useraddr, xt_action_of, z_action_of
>c7c8		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c7d0		66
.c7d1						nt_useraddr:
>c7d1		08 00				        .byte 8, 0
>c7d3		e1 c7 1b a6 25 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c7d9		75 73 65 72 61 64 64 72		        .text "useraddr"
.c7e1						nt_buffer_colon:
>c7e1		07 00				        .byte 7, 0
>c7e3		f0 c7 9c 85 a2 85		        .word +, xt_buffer_colon, z_buffer_colon
>c7e9		62 75 66 66 65 72 3a		        .text "buffer:"
.c7f0						+
.c7f0						nt_buffstatus:
>c7f0		0a 00				        .byte 10, 0
>c7f2		02 c8 a3 85 b2 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7f8		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c800		75 73
.c802						nt_buffblocknum:
>c802		0c 00				        .byte 12, 0
>c804		16 c8 5b 85 6a 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c80a		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c812		6b 6e 75 6d
.c816						nt_blkbuffer:
>c816		09 00				        .byte 9, 0
>c818		27 c8 69 83 76 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c81e		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c826		72
.c827						nt_scr:
>c827		03 00				        .byte 3, 0
>c829		32 c8 87 9e 96 9e		        .word nt_blk, xt_scr, z_scr
>c82f		73 63 72			        .text "scr"
.c832						nt_blk:
>c832		03 00				        .byte 3, 0
>c834		3d c8 59 83 68 83		        .word nt_block_write, xt_blk, z_blk
>c83a		62 6c 6b			        .text "blk"
.c83d						nt_block_write:
>c83d		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c83f		50 c8 16 85 24 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c845		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c84d		69 74 65
.c850						nt_block_write_vector:
>c850		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c852		6a c8 24 85 33 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c858		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c860		69 74 65 2d 76 65 63 74 6f 72
.c86a						nt_block_read:
>c86a		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c86c		7c c8 f3 84 01 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c872		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c87a		61 64
.c87c						nt_block_read_vector:
>c87c		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c87e		95 c8 01 85 10 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c884		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c88c		61 64 2d 76 65 63 74 6f 72
.c895						nt_save_buffers:
>c895		0c 00				        .byte 12, 0
>c897		a9 c8 6c 9e 86 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c89d		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c8a5		66 65 72 73
.c8a9						nt_block:
>c8a9		05 00				        .byte 5, 0
>c8ab		b6 c8 77 83 c9 83		        .word nt_update, xt_block, z_block
>c8b1		62 6c 6f 63 6b			        .text "block"
.c8b6						nt_update:
>c8b6		06 00				        .byte 6, 0
>c8b8		c4 c8 12 a6 1a a6		        .word nt_buffer, xt_update, z_update
>c8be		75 70 64 61 74 65		        .text "update"
.c8c4						nt_buffer:
>c8c4		06 00				        .byte 6, 0
>c8c6		d2 c8 6b 85 9b 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c8cc		62 75 66 66 65 72		        .text "buffer"
.c8d2						nt_empty_buffers:
>c8d2		0d 00				        .byte 13, 0
>c8d4		e7 c8 de 8d e4 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c8da		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c8e2		66 66 65 72 73
.c8e7						nt_flush:
>c8e7		05 00				        .byte 5, 0
>c8e9		f4 c8 6c 90 75 90		        .word nt_load, xt_flush, z_flush
>c8ef		66 6c 75 73 68			        .text "flush"
.c8f4						nt_load:
>c8f4		04 10				        .byte 4, UF
>c8f6		00 c9 98 93 db 93		        .word nt_thru, xt_load, z_load
>c8fc		6c 6f 61 64			        .text "load"
.c900						nt_thru:
>c900		04 10				        .byte 4, UF
>c902		0c c9 70 a1 b4 a1		        .word nt_list, xt_thru, z_thru
>c908		74 68 72 75			        .text "thru"
.c90c						nt_list:
>c90c		04 10				        .byte 4, UF
>c90e		18 c9 5e 93 6a 93		        .word +, xt_list, z_list
>c914		6c 69 73 74			        .text "list"
.c918						+
.c918						nt_block_ramdrive_init:
>c918		13 10				        .byte 19, UF
>c91a		33 c9 ca 83 f2 84		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c920		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c928		6d 64 72 69 76 65 2d 69 6e 69 74
.c933						+
.c933						nt_definitions:
>c933		0b 00				        .byte 11, 0
>c935		46 c9 b4 8a bc 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c93b		64 65 66 69 6e 69 74 69		        .text "definitions"
>c943		6f 6e 73
.c946						nt_wordlist:
>c946		08 00				        .byte 8, 0
>c948		56 c9 af a6 c5 a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c94e		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c956						nt_search_wordlist:
>c956		0f 10				        .byte 15, UF
>c958		6d c9 7d 9b 5d 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c95e		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c966		6f 72 64 6c 69 73 74
.c96d						nt_set_current:
>c96d		0b 10				        .byte 11, UF
>c96f		80 c9 ec 9c f7 9c		        .word nt_get_current, xt_set_current, z_set_current
>c975		73 65 74 2d 63 75 72 72		        .text "set-current"
>c97d		65 6e 74
.c980						nt_get_current:
>c980		0b 00				        .byte 11, 0
>c982		93 c9 0e 91 18 91		        .word nt_set_order, xt_get_current, z_get_current
>c988		67 65 74 2d 63 75 72 72		        .text "get-current"
>c990		65 6e 74
.c993						nt_set_order:
>c993		09 00				        .byte 9, 0
>c995		a4 c9 f8 9c 2b 9d		        .word nt_get_order, xt_set_order, z_set_order
>c99b		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c9a3		72
.c9a4						nt_get_order:
>c9a4		09 00				        .byte 9, 0
>c9a6		b5 c9 19 91 41 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c9ac		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c9b4		72
.c9b5						nt_root_wordlist:
>c9b5		0d 00				        .byte 13, 0
>c9b7		ca c9 2b 9b 33 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c9bd		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c9c5		64 6c 69 73 74
.c9ca						+
.c9ca						nt_assembler_wordlist:
>c9ca		12 00				        .byte 18, 0
>c9cc		e4 c9 4b a3 53 a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c9d2		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c9da		72 2d 77 6f 72 64 6c 69 73 74
.c9e4						+
.c9e4						nt_editor_wordlist:
>c9e4		0f 00				        .byte 15, 0
>c9e6		fb c9 ec 97 f4 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9ec		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9f4		6f 72 64 6c 69 73 74
.c9fb						+
.c9fb						nt_forth_wordlist:
>c9fb		0e 00				        .byte 14, 0
>c9fd		11 ca 56 a7 5c a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>ca03		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca0b		72 64 6c 69 73 74
.ca11						nt_only:
>ca11		04 00				        .byte 4, 0
>ca13		1d ca 0b 98 16 98		        .word nt_also, xt_only, z_only
>ca19		6f 6e 6c 79			        .text "only"
.ca1d						nt_also:
>ca1d		04 00				        .byte 4, 0
>ca1f		29 ca b4 82 c3 82		        .word nt_previous, xt_also, z_also
>ca25		61 6c 73 6f			        .text "also"
.ca29						nt_previous:
>ca29		08 00				        .byte 8, 0
>ca2b		39 ca 39 9a 45 9a		        .word nt_to_order, xt_previous, z_previous
>ca31		70 72 65 76 69 6f 75 73		        .text "previous"
.ca39						nt_to_order:
>ca39		06 00				        .byte 6, 0
>ca3b		47 ca 01 a3 13 a3		        .word nt_order, xt_to_order, z_to_order
>ca41		3e 6f 72 64 65 72		        .text ">order"
.ca47						nt_order:
>ca47		05 00				        .byte 5, 0
>ca49		54 ca 29 98 53 98		        .word nt_forth, xt_order, z_order
>ca4f		6f 72 64 65 72			        .text "order"
.ca54						nt_forth:
>ca54		05 00				        .byte 5, 0
>ca56		61 ca ad 90 b3 90		        .word +, xt_forth, z_forth
>ca5c		66 6f 72 74 68			        .text "forth"
.ca61						+
>ca61		03 08				nt_see: .byte 3, NN
>ca63		6c ca 5e 9c eb 9c		        .word +, xt_see, z_see
>ca69		73 65 65			        .text "see"
.ca6c						+
.ca6c						nt_ed:
>ca6c		02 08				        .byte 2, NN
>ca6e		76 ca 70 8d 73 8d		        .word +, xt_ed, z_ed
>ca74		65 64				        .text "ed"
.ca76						+
.ca76						nt_cold:
>ca76		04 00				        .byte 4, 0
>ca78		82 ca 00 80 ad 80		        .word nt_bye, xt_cold, z_cold
>ca7e		63 6f 6c 64			        .text "cold"
.ca82						nt_bye:
>ca82		03				        .byte 3         ; length of word strings
>ca83		00				        .byte 0         ; status byte
>ca84		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca86		b3 85				        .word xt_bye    ; start of code block (xt of this word)
>ca88		b6 85				        .word z_bye     ; end of code (RTS)
>ca8a		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca8d						root_dictionary_start:
.ca8d						nt_root_set_order:
>ca8d		09 00				        .byte 9, 0
>ca8f		9e ca f8 9c 2b 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca95		73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca9d		72
.ca9e						nt_root_forth:
>ca9e		05 00				        .byte 5, 0
>caa0		ab ca ad 90 b3 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>caa6		66 6f 72 74 68			        .text "forth"
.caab						nt_root_forth_wordlist:
>caab		0e 00				        .byte 14, 0
>caad		c1 ca 56 a7 5c a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>cab3		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>cabb		72 64 6c 69 73 74
.cac1						nt_root_words:
>cac1		05 00				        .byte 5, 0
>cac3		00 00 c6 a6 22 a7		        .word 0000, xt_words, z_words
>cac9		77 6f 72 64 73			        .text "words"
.cace						editor_dictionary_start:
.cace						nt_editor_o:
>cace		01 00				        .byte 1, 0
>cad0		d7 ca 85 a8 ca a8		        .word nt_editor_line, xt_editor_o, z_editor_o
>cad6		6f				        .text "o"
.cad7						nt_editor_line:
>cad7		04 10				        .byte 4, UF
>cad9		e3 ca 6c a8 84 a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>cadf		6c 69 6e 65			        .text "line"
.cae3						nt_editor_l:
>cae3		01 00				        .byte 1, 0
>cae5		ec ca f0 a7 6b a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>caeb		6c				        .text "l"
.caec						nt_editor_el:
>caec		02 00				        .byte 2, 0
>caee		f6 ca de a7 ef a7		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>caf4		65 6c				        .text "el"
.caf6						nt_editor_erase_screen:
>caf6		0c 00				        .byte 12, 0
>caf8		0a cb cc a7 dd a7		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cafe		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cb06		72 65 65 6e
.cb0a						nt_editor_enter_screen:
>cb0a		0c 00				        .byte 12, 0
>cb0c		00 00 b0 a7 cb a7		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cb12		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cb1a		72 65 65 6e
.cb1e						assembler_dictionary_start:
.cb1e						nt_asm_adc_h:
>cb1e		05 0c						.byte 5, IM+NN
>cb20		2b cb				                .word nt_asm_adc_x
>cb22		1f a9 24 a9					.word xt_asm_adc_h, z_asm_adc_h
>cb26		61 64 63 2e 23					.text "adc.#"
.cb2b						nt_asm_adc_x:
>cb2b		05 0c						.byte 5, IM+NN
>cb2d		38 cb				                .word nt_asm_adc_y
>cb2f		24 a9 29 a9					.word xt_asm_adc_x, z_asm_adc_x
>cb33		61 64 63 2e 78					.text "adc.x"
.cb38						nt_asm_adc_y:
>cb38		05 0c						.byte 5, IM+NN
>cb3a		45 cb				                .word nt_asm_adc_z
>cb3c		29 a9 2e a9					.word xt_asm_adc_y, z_asm_adc_y
>cb40		61 64 63 2e 79					.text "adc.y"
.cb45						nt_asm_adc_z:
>cb45		05 0c						.byte 5, IM+NN
>cb47		52 cb				                .word nt_asm_adc_zi
>cb49		2e a9 33 a9					.word xt_asm_adc_z, z_asm_adc_z
>cb4d		61 64 63 2e 7a					.text "adc.z"
.cb52						nt_asm_adc_zi:
>cb52		06 0c						.byte 6, IM+NN
>cb54		60 cb				                .word nt_asm_adc_ziy
>cb56		33 a9 38 a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cb5a		61 64 63 2e 7a 69				.text "adc.zi"
.cb60						nt_asm_adc_ziy:
>cb60		07 0c						.byte 7, IM+NN
>cb62		6f cb				                .word nt_asm_adc_zx
>cb64		38 a9 3d a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb68		61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb6f						nt_asm_adc_zx:
>cb6f		06 0c						.byte 6, IM+NN
>cb71		7d cb				                .word nt_asm_adc_zxi
>cb73		3d a9 42 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb77		61 64 63 2e 7a 78				.text "adc.zx"
.cb7d						nt_asm_adc_zxi:
>cb7d		07 0c						.byte 7, IM+NN
>cb7f		8c cb				                .word nt_asm_and
>cb81		42 a9 47 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb85		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb8c						nt_asm_and:
>cb8c		04 0c						.byte 4, IM+NN
>cb8e		98 cb				                .word nt_asm_and_h
>cb90		47 a9 4c a9					.word xt_asm_and, z_asm_and
>cb94		61 6e 64 2e					.text "and."
.cb98						nt_asm_and_h:
>cb98		05 0c						.byte 5, IM+NN
>cb9a		a5 cb				                .word nt_asm_and_x
>cb9c		4c a9 51 a9					.word xt_asm_and_h, z_asm_and_h
>cba0		61 6e 64 2e 23					.text "and.#"
.cba5						nt_asm_and_x:
>cba5		05 0c						.byte 5, IM+NN
>cba7		b2 cb				                .word nt_asm_and_y
>cba9		51 a9 56 a9					.word xt_asm_and_x, z_asm_and_x
>cbad		61 6e 64 2e 78					.text "and.x"
.cbb2						nt_asm_and_y:
>cbb2		05 0c						.byte 5, IM+NN
>cbb4		bf cb				                .word nt_asm_and_z
>cbb6		56 a9 5b a9					.word xt_asm_and_y, z_asm_and_y
>cbba		61 6e 64 2e 79					.text "and.y"
.cbbf						nt_asm_and_z:
>cbbf		05 0c						.byte 5, IM+NN
>cbc1		cc cb				                .word nt_asm_and_zi
>cbc3		5b a9 60 a9					.word xt_asm_and_z, z_asm_and_z
>cbc7		61 6e 64 2e 7a					.text "and.z"
.cbcc						nt_asm_and_zi:
>cbcc		06 0c						.byte 6, IM+NN
>cbce		da cb				                .word nt_asm_and_ziy
>cbd0		60 a9 65 a9					.word xt_asm_and_zi, z_asm_and_zi
>cbd4		61 6e 64 2e 7a 69				.text "and.zi"
.cbda						nt_asm_and_ziy:
>cbda		07 0c						.byte 7, IM+NN
>cbdc		e9 cb				                .word nt_asm_and_zx
>cbde		65 a9 6a a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cbe2		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbe9						nt_asm_and_zx:
>cbe9		06 0c						.byte 6, IM+NN
>cbeb		f7 cb				                .word nt_asm_and_zxi
>cbed		6a a9 6f a9					.word xt_asm_and_zx, z_asm_and_zx
>cbf1		61 6e 64 2e 7a 78				.text "and.zx"
.cbf7						nt_asm_and_zxi:
>cbf7		07 0c						.byte 7, IM+NN
>cbf9		06 cc				                .word nt_asm_asl
>cbfb		6f a9 74 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cbff		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cc06						nt_asm_asl:
>cc06		03 0c						.byte 3, IM+NN
>cc08		11 cc				                .word nt_asm_asl_a
>cc0a		74 a9 79 a9					.word xt_asm_asl, z_asm_asl
>cc0e		61 73 6c					.text "asl"
.cc11						nt_asm_asl_a:
>cc11		05 0c						.byte 5, IM+NN
>cc13		1e cc				                .word nt_asm_asl_x
>cc15		79 a9 7e a9					.word xt_asm_asl_a, z_asm_asl_a
>cc19		61 73 6c 2e 61					.text "asl.a"
.cc1e						nt_asm_asl_x:
>cc1e		05 0c						.byte 5, IM+NN
>cc20		2b cc				                .word nt_asm_asl_z
>cc22		7e a9 83 a9					.word xt_asm_asl_x, z_asm_asl_x
>cc26		61 73 6c 2e 78					.text "asl.x"
.cc2b						nt_asm_asl_z:
>cc2b		05 0c						.byte 5, IM+NN
>cc2d		38 cc				                .word nt_asm_asl_zx
>cc2f		83 a9 88 a9					.word xt_asm_asl_z, z_asm_asl_z
>cc33		61 73 6c 2e 7a					.text "asl.z"
.cc38						nt_asm_asl_zx:
>cc38		06 0c						.byte 6, IM+NN
>cc3a		46 cc				                .word nt_asm_bcc
>cc3c		88 a9 8d a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cc40		61 73 6c 2e 7a 78				.text "asl.zx"
.cc46						nt_asm_bcc:
>cc46		03 0c						.byte 3, IM+NN
>cc48		51 cc				                .word nt_asm_bcs
>cc4a		8d a9 92 a9					.word xt_asm_bcc, z_asm_bcc
>cc4e		62 63 63					.text "bcc"
.cc51						nt_asm_bcs:
>cc51		03 0c						.byte 3, IM+NN
>cc53		5c cc				                .word nt_asm_beq
>cc55		92 a9 99 a9					.word xt_asm_bcs, z_asm_bcs
>cc59		62 63 73					.text "bcs"
.cc5c						nt_asm_beq:
>cc5c		03 0c						.byte 3, IM+NN
>cc5e		67 cc				                .word nt_asm_bit
>cc60		99 a9 9e a9					.word xt_asm_beq, z_asm_beq
>cc64		62 65 71					.text "beq"
.cc67						nt_asm_bit:
>cc67		03 0c						.byte 3, IM+NN
>cc69		72 cc				                .word nt_asm_bit_h
>cc6b		9e a9 a3 a9					.word xt_asm_bit, z_asm_bit
>cc6f		62 69 74					.text "bit"
.cc72						nt_asm_bit_h:
>cc72		05 0c						.byte 5, IM+NN
>cc74		7f cc				                .word nt_asm_bit_x
>cc76		a3 a9 a8 a9					.word xt_asm_bit_h, z_asm_bit_h
>cc7a		62 69 74 2e 23					.text "bit.#"
.cc7f						nt_asm_bit_x:
>cc7f		05 0c						.byte 5, IM+NN
>cc81		8c cc				                .word nt_asm_bit_z
>cc83		a8 a9 ad a9					.word xt_asm_bit_x, z_asm_bit_x
>cc87		62 69 74 2e 78					.text "bit.x"
.cc8c						nt_asm_bit_z:
>cc8c		05 0c						.byte 5, IM+NN
>cc8e		99 cc				                .word nt_asm_bit_zx
>cc90		ad a9 b2 a9					.word xt_asm_bit_z, z_asm_bit_z
>cc94		62 69 74 2e 7a					.text "bit.z"
.cc99						nt_asm_bit_zx:
>cc99		06 0c						.byte 6, IM+NN
>cc9b		a7 cc				                .word nt_asm_bmi
>cc9d		b2 a9 b7 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cca1		62 69 74 2e 7a 78				.text "bit.zx"
.cca7						nt_asm_bmi:
>cca7		03 0c						.byte 3, IM+NN
>cca9		b2 cc				                .word nt_asm_bne
>ccab		b7 a9 bc a9					.word xt_asm_bmi, z_asm_bmi
>ccaf		62 6d 69					.text "bmi"
.ccb2						nt_asm_bne:
>ccb2		03 0c						.byte 3, IM+NN
>ccb4		bd cc				                .word nt_asm_bpl
>ccb6		bc a9 c1 a9					.word xt_asm_bne, z_asm_bne
>ccba		62 6e 65					.text "bne"
.ccbd						nt_asm_bpl:
>ccbd		03 0c						.byte 3, IM+NN
>ccbf		c8 cc				                .word nt_asm_bra
>ccc1		c1 a9 c6 a9					.word xt_asm_bpl, z_asm_bpl
>ccc5		62 70 6c					.text "bpl"
.ccc8						nt_asm_bra:
>ccc8		03 0c						.byte 3, IM+NN
>ccca		d3 cc				                .word nt_asm_brk
>cccc		c6 a9 cb a9					.word xt_asm_bra, z_asm_bra
>ccd0		62 72 61					.text "bra"
.ccd3						nt_asm_brk:
>ccd3		03 0c						.byte 3, IM+NN
>ccd5		de cc				                .word nt_asm_bvc
>ccd7		cb a9 d0 a9					.word xt_asm_brk, z_asm_brk
>ccdb		62 72 6b					.text "brk"
.ccde						nt_asm_bvc:
>ccde		03 0c						.byte 3, IM+NN
>cce0		e9 cc				                .word nt_asm_bvs
>cce2		d0 a9 d5 a9					.word xt_asm_bvc, z_asm_bvc
>cce6		62 76 63					.text "bvc"
.cce9						nt_asm_bvs:
>cce9		03 0c						.byte 3, IM+NN
>cceb		f4 cc				                .word nt_asm_clc
>cced		d5 a9 da a9					.word xt_asm_bvs, z_asm_bvs
>ccf1		62 76 73					.text "bvs"
.ccf4						nt_asm_clc:
>ccf4		03 0c						.byte 3, IM+NN
>ccf6		ff cc				                .word nt_asm_cld
>ccf8		da a9 df a9					.word xt_asm_clc, z_asm_clc
>ccfc		63 6c 63					.text "clc"
.ccff						nt_asm_cld:
>ccff		03 0c						.byte 3, IM+NN
>cd01		0a cd				                .word nt_asm_cli
>cd03		df a9 e4 a9					.word xt_asm_cld, z_asm_cld
>cd07		63 6c 64					.text "cld"
.cd0a						nt_asm_cli:
>cd0a		03 0c						.byte 3, IM+NN
>cd0c		15 cd				                .word nt_asm_clv
>cd0e		e4 a9 e9 a9					.word xt_asm_cli, z_asm_cli
>cd12		63 6c 69					.text "cli"
.cd15						nt_asm_clv:
>cd15		03 0c						.byte 3, IM+NN
>cd17		20 cd				                .word nt_asm_cmp
>cd19		e9 a9 ee a9					.word xt_asm_clv, z_asm_clv
>cd1d		63 6c 76					.text "clv"
.cd20						nt_asm_cmp:
>cd20		03 0c						.byte 3, IM+NN
>cd22		2b cd				                .word nt_asm_cmp_h
>cd24		ee a9 f3 a9					.word xt_asm_cmp, z_asm_cmp
>cd28		63 6d 70					.text "cmp"
.cd2b						nt_asm_cmp_h:
>cd2b		05 0c						.byte 5, IM+NN
>cd2d		38 cd				                .word nt_asm_cmp_x
>cd2f		f3 a9 f8 a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cd33		63 6d 70 2e 23					.text "cmp.#"
.cd38						nt_asm_cmp_x:
>cd38		05 0c						.byte 5, IM+NN
>cd3a		45 cd				                .word nt_asm_cmp_y
>cd3c		f8 a9 fd a9					.word xt_asm_cmp_x, z_asm_cmp_x
>cd40		63 6d 70 2e 78					.text "cmp.x"
.cd45						nt_asm_cmp_y:
>cd45		05 0c						.byte 5, IM+NN
>cd47		52 cd				                .word nt_asm_cmp_z
>cd49		fd a9 02 aa					.word xt_asm_cmp_y, z_asm_cmp_y
>cd4d		63 6d 70 2e 79					.text "cmp.y"
.cd52						nt_asm_cmp_z:
>cd52		05 0c						.byte 5, IM+NN
>cd54		5f cd				                .word nt_asm_cmp_zi
>cd56		02 aa 07 aa					.word xt_asm_cmp_z, z_asm_cmp_z
>cd5a		63 6d 70 2e 7a					.text "cmp.z"
.cd5f						nt_asm_cmp_zi:
>cd5f		06 0c						.byte 6, IM+NN
>cd61		6d cd				                .word nt_asm_cmp_ziy
>cd63		07 aa 0c aa					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd67		63 6d 70 2e 7a 69				.text "cmp.zi"
.cd6d						nt_asm_cmp_ziy:
>cd6d		07 0c						.byte 7, IM+NN
>cd6f		7c cd				                .word nt_asm_cmp_zx
>cd71		0c aa 11 aa					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd75		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd7c						nt_asm_cmp_zx:
>cd7c		06 0c						.byte 6, IM+NN
>cd7e		8a cd				                .word nt_asm_cmp_zxi
>cd80		11 aa 16 aa					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd84		63 6d 70 2e 7a 78				.text "cmp.zx"
.cd8a						nt_asm_cmp_zxi:
>cd8a		07 0c						.byte 7, IM+NN
>cd8c		99 cd				                .word nt_asm_cpx
>cd8e		16 aa 1b aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd92		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd99						nt_asm_cpx:
>cd99		03 0c						.byte 3, IM+NN
>cd9b		a4 cd				                .word nt_asm_cpx_h
>cd9d		1b aa 20 aa					.word xt_asm_cpx, z_asm_cpx
>cda1		63 70 78					.text "cpx"
.cda4						nt_asm_cpx_h:
>cda4		05 0c						.byte 5, IM+NN
>cda6		b1 cd				                .word nt_asm_cpx_z
>cda8		20 aa 25 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>cdac		63 70 78 2e 23					.text "cpx.#"
.cdb1						nt_asm_cpx_z:
>cdb1		05 0c						.byte 5, IM+NN
>cdb3		be cd				                .word nt_asm_cpy
>cdb5		25 aa 2a aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cdb9		63 70 78 2e 7a					.text "cpx.z"
.cdbe						nt_asm_cpy:
>cdbe		03 0c						.byte 3, IM+NN
>cdc0		c9 cd				                .word nt_asm_cpy_h
>cdc2		2a aa 31 aa					.word xt_asm_cpy, z_asm_cpy
>cdc6		63 70 79					.text "cpy"
.cdc9						nt_asm_cpy_h:
>cdc9		05 0c						.byte 5, IM+NN
>cdcb		d6 cd				                .word nt_asm_cpy_z
>cdcd		31 aa 36 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cdd1		63 70 79 2e 23					.text "cpy.#"
.cdd6						nt_asm_cpy_z:
>cdd6		05 0c						.byte 5, IM+NN
>cdd8		e3 cd				                .word nt_asm_dec
>cdda		36 aa 3b aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cdde		63 70 79 2e 7a					.text "cpy.z"
.cde3						nt_asm_dec:
>cde3		03 0c						.byte 3, IM+NN
>cde5		ee cd				                .word nt_asm_dec_a
>cde7		3b aa 40 aa					.word xt_asm_dec, z_asm_dec
>cdeb		64 65 63					.text "dec"
.cdee						nt_asm_dec_a:
>cdee		05 0c						.byte 5, IM+NN
>cdf0		fb cd				                .word nt_asm_dec_x
>cdf2		40 aa 45 aa					.word xt_asm_dec_a, z_asm_dec_a
>cdf6		64 65 63 2e 61					.text "dec.a"
.cdfb						nt_asm_dec_x:
>cdfb		05 0c						.byte 5, IM+NN
>cdfd		08 ce				                .word nt_asm_dec_z
>cdff		45 aa 4a aa					.word xt_asm_dec_x, z_asm_dec_x
>ce03		64 65 63 2e 78					.text "dec.x"
.ce08						nt_asm_dec_z:
>ce08		05 0c						.byte 5, IM+NN
>ce0a		15 ce				                .word nt_asm_dec_zx
>ce0c		4a aa 4f aa					.word xt_asm_dec_z, z_asm_dec_z
>ce10		64 65 63 2e 7a					.text "dec.z"
.ce15						nt_asm_dec_zx:
>ce15		06 0c						.byte 6, IM+NN
>ce17		23 ce				                .word nt_asm_dex
>ce19		4f aa 54 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>ce1d		64 65 63 2e 7a 78				.text "dec.zx"
.ce23						nt_asm_dex:
>ce23		03 0c						.byte 3, IM+NN
>ce25		2e ce				                .word nt_asm_dey
>ce27		54 aa 59 aa					.word xt_asm_dex, z_asm_dex
>ce2b		64 65 78					.text "dex"
.ce2e						nt_asm_dey:
>ce2e		03 0c						.byte 3, IM+NN
>ce30		39 ce				                .word nt_asm_eor
>ce32		59 aa 5e aa					.word xt_asm_dey, z_asm_dey
>ce36		64 65 79					.text "dey"
.ce39						nt_asm_eor:
>ce39		03 0c						.byte 3, IM+NN
>ce3b		44 ce				                .word nt_asm_eor_h
>ce3d		5e aa 63 aa					.word xt_asm_eor, z_asm_eor
>ce41		65 6f 72					.text "eor"
.ce44						nt_asm_eor_h:
>ce44		05 0c						.byte 5, IM+NN
>ce46		51 ce				                .word nt_asm_eor_x
>ce48		63 aa 68 aa					.word xt_asm_eor_h, z_asm_eor_h
>ce4c		65 6f 72 2e 23					.text "eor.#"
.ce51						nt_asm_eor_x:
>ce51		05 0c						.byte 5, IM+NN
>ce53		5e ce				                .word nt_asm_eor_y
>ce55		68 aa 6d aa					.word xt_asm_eor_x, z_asm_eor_x
>ce59		65 6f 72 2e 78					.text "eor.x"
.ce5e						nt_asm_eor_y:
>ce5e		05 0c						.byte 5, IM+NN
>ce60		6b ce				                .word nt_asm_eor_z
>ce62		6d aa 72 aa					.word xt_asm_eor_y, z_asm_eor_y
>ce66		65 6f 72 2e 79					.text "eor.y"
.ce6b						nt_asm_eor_z:
>ce6b		05 0c						.byte 5, IM+NN
>ce6d		78 ce				                .word nt_asm_eor_zi
>ce6f		72 aa 77 aa					.word xt_asm_eor_z, z_asm_eor_z
>ce73		65 6f 72 2e 7a					.text "eor.z"
.ce78						nt_asm_eor_zi:
>ce78		06 0c						.byte 6, IM+NN
>ce7a		86 ce				                .word nt_asm_eor_ziy
>ce7c		77 aa 7c aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce80		65 6f 72 2e 7a 69				.text "eor.zi"
.ce86						nt_asm_eor_ziy:
>ce86		07 0c						.byte 7, IM+NN
>ce88		95 ce				                .word nt_asm_eor_zx
>ce8a		7c aa 81 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce8e		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce95						nt_asm_eor_zx:
>ce95		06 0c						.byte 6, IM+NN
>ce97		a3 ce				                .word nt_asm_eor_zxi
>ce99		81 aa 86 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce9d		65 6f 72 2e 7a 78				.text "eor.zx"
.cea3						nt_asm_eor_zxi:
>cea3		07 0c						.byte 7, IM+NN
>cea5		b2 ce				                .word nt_asm_inc
>cea7		86 aa 8b aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ceab		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ceb2						nt_asm_inc:
>ceb2		03 0c						.byte 3, IM+NN
>ceb4		bd ce				                .word nt_asm_inc_a
>ceb6		8b aa 90 aa					.word xt_asm_inc, z_asm_inc
>ceba		69 6e 63					.text "inc"
.cebd						nt_asm_inc_a:
>cebd		05 0c						.byte 5, IM+NN
>cebf		ca ce				                .word nt_asm_inc_x
>cec1		90 aa 95 aa					.word xt_asm_inc_a, z_asm_inc_a
>cec5		69 6e 63 2e 61					.text "inc.a"
.ceca						nt_asm_inc_x:
>ceca		05 0c						.byte 5, IM+NN
>cecc		d7 ce				                .word nt_asm_inc_z
>cece		95 aa 9a aa					.word xt_asm_inc_x, z_asm_inc_x
>ced2		69 6e 63 2e 78					.text "inc.x"
.ced7						nt_asm_inc_z:
>ced7		05 0c						.byte 5, IM+NN
>ced9		e4 ce				                .word nt_asm_inc_zx
>cedb		9a aa 9f aa					.word xt_asm_inc_z, z_asm_inc_z
>cedf		69 6e 63 2e 7a					.text "inc.z"
.cee4						nt_asm_inc_zx:
>cee4		06 0c						.byte 6, IM+NN
>cee6		f2 ce				                .word nt_asm_inx
>cee8		9f aa a4 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>ceec		69 6e 63 2e 7a 78				.text "inc.zx"
.cef2						nt_asm_inx:
>cef2		03 0c						.byte 3, IM+NN
>cef4		fd ce				                .word nt_asm_iny
>cef6		a4 aa a9 aa					.word xt_asm_inx, z_asm_inx
>cefa		69 6e 78					.text "inx"
.cefd						nt_asm_iny:
>cefd		03 0c						.byte 3, IM+NN
>ceff		08 cf				                .word nt_asm_jmp
>cf01		a9 aa ae aa					.word xt_asm_iny, z_asm_iny
>cf05		69 6e 79					.text "iny"
.cf08						nt_asm_jmp:
>cf08		03 0c						.byte 3, IM+NN
>cf0a		13 cf				                .word nt_asm_jmp_i
>cf0c		ae aa b3 aa					.word xt_asm_jmp, z_asm_jmp
>cf10		6a 6d 70					.text "jmp"
.cf13						nt_asm_jmp_i:
>cf13		05 0c						.byte 5, IM+NN
>cf15		20 cf				                .word nt_asm_jmp_xi
>cf17		b3 aa b8 aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cf1b		6a 6d 70 2e 69					.text "jmp.i"
.cf20						nt_asm_jmp_xi:
>cf20		06 0c						.byte 6, IM+NN
>cf22		2e cf				                .word nt_asm_jsr
>cf24		b8 aa bd aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cf28		6a 6d 70 2e 78 69				.text "jmp.xi"
.cf2e						nt_asm_jsr:
>cf2e		03 0c						.byte 3, IM+NN
>cf30		39 cf				                .word nt_asm_lda
>cf32		bd aa c2 aa					.word xt_asm_jsr, z_asm_jsr
>cf36		6a 73 72					.text "jsr"
.cf39						nt_asm_lda:
>cf39		03 0c						.byte 3, IM+NN
>cf3b		44 cf				                .word nt_asm_lda_h
>cf3d		c2 aa c7 aa					.word xt_asm_lda, z_asm_lda
>cf41		6c 64 61					.text "lda"
.cf44						nt_asm_lda_h:
>cf44		05 0c						.byte 5, IM+NN
>cf46		51 cf				                .word nt_asm_lda_x
>cf48		c7 aa cc aa					.word xt_asm_lda_h, z_asm_lda_h
>cf4c		6c 64 61 2e 23					.text "lda.#"
.cf51						nt_asm_lda_x:
>cf51		05 0c						.byte 5, IM+NN
>cf53		5e cf				                .word nt_asm_lda_y
>cf55		cc aa d1 aa					.word xt_asm_lda_x, z_asm_lda_x
>cf59		6c 64 61 2e 78					.text "lda.x"
.cf5e						nt_asm_lda_y:
>cf5e		05 0c						.byte 5, IM+NN
>cf60		6b cf				                .word nt_asm_lda_z
>cf62		d1 aa d6 aa					.word xt_asm_lda_y, z_asm_lda_y
>cf66		6c 64 61 2e 79					.text "lda.y"
.cf6b						nt_asm_lda_z:
>cf6b		05 0c						.byte 5, IM+NN
>cf6d		78 cf				                .word nt_asm_lda_zi
>cf6f		d6 aa db aa					.word xt_asm_lda_z, z_asm_lda_z
>cf73		6c 64 61 2e 7a					.text "lda.z"
.cf78						nt_asm_lda_zi:
>cf78		06 0c						.byte 6, IM+NN
>cf7a		86 cf				                .word nt_asm_lda_ziy
>cf7c		db aa e0 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cf80		6c 64 61 2e 7a 69				.text "lda.zi"
.cf86						nt_asm_lda_ziy:
>cf86		07 0c						.byte 7, IM+NN
>cf88		95 cf				                .word nt_asm_lda_zx
>cf8a		e0 aa e5 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf8e		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf95						nt_asm_lda_zx:
>cf95		06 0c						.byte 6, IM+NN
>cf97		a3 cf				                .word nt_asm_lda_zxi
>cf99		e5 aa ea aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf9d		6c 64 61 2e 7a 78				.text "lda.zx"
.cfa3						nt_asm_lda_zxi:
>cfa3		07 0c						.byte 7, IM+NN
>cfa5		b2 cf				                .word nt_asm_ldx
>cfa7		ea aa ef aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cfab		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cfb2						nt_asm_ldx:
>cfb2		03 0c						.byte 3, IM+NN
>cfb4		bd cf				                .word nt_asm_ldx_h
>cfb6		ef aa f4 aa					.word xt_asm_ldx, z_asm_ldx
>cfba		6c 64 78					.text "ldx"
.cfbd						nt_asm_ldx_h:
>cfbd		05 0c						.byte 5, IM+NN
>cfbf		ca cf				                .word nt_asm_ldx_y
>cfc1		f4 aa f9 aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cfc5		6c 64 78 2e 23					.text "ldx.#"
.cfca						nt_asm_ldx_y:
>cfca		05 0c						.byte 5, IM+NN
>cfcc		d7 cf				                .word nt_asm_ldx_z
>cfce		f9 aa fe aa					.word xt_asm_ldx_y, z_asm_ldx_y
>cfd2		6c 64 78 2e 79					.text "ldx.y"
.cfd7						nt_asm_ldx_z:
>cfd7		05 0c						.byte 5, IM+NN
>cfd9		e4 cf				                .word nt_asm_ldx_zy
>cfdb		fe aa 03 ab					.word xt_asm_ldx_z, z_asm_ldx_z
>cfdf		6c 64 78 2e 7a					.text "ldx.z"
.cfe4						nt_asm_ldx_zy:
>cfe4		06 0c						.byte 6, IM+NN
>cfe6		f2 cf				                .word nt_asm_ldy
>cfe8		03 ab 08 ab					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfec		6c 64 78 2e 7a 79				.text "ldx.zy"
.cff2						nt_asm_ldy:
>cff2		03 0c						.byte 3, IM+NN
>cff4		fd cf				                .word nt_asm_ldy_h
>cff6		08 ab 0d ab					.word xt_asm_ldy, z_asm_ldy
>cffa		6c 64 79					.text "ldy"
.cffd						nt_asm_ldy_h:
>cffd		05 0c						.byte 5, IM+NN
>cfff		0a d0				                .word nt_asm_ldy_x
>d001		0d ab 12 ab					.word xt_asm_ldy_h, z_asm_ldy_h
>d005		6c 64 79 2e 23					.text "ldy.#"
.d00a						nt_asm_ldy_x:
>d00a		05 0c						.byte 5, IM+NN
>d00c		17 d0				                .word nt_asm_ldy_z
>d00e		12 ab 17 ab					.word xt_asm_ldy_x, z_asm_ldy_x
>d012		6c 64 79 2e 78					.text "ldy.x"
.d017						nt_asm_ldy_z:
>d017		05 0c						.byte 5, IM+NN
>d019		24 d0				                .word nt_asm_ldy_zx
>d01b		17 ab 1c ab					.word xt_asm_ldy_z, z_asm_ldy_z
>d01f		6c 64 79 2e 7a					.text "ldy.z"
.d024						nt_asm_ldy_zx:
>d024		06 0c						.byte 6, IM+NN
>d026		32 d0				                .word nt_asm_lsr
>d028		1c ab 21 ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>d02c		6c 64 79 2e 7a 78				.text "ldy.zx"
.d032						nt_asm_lsr:
>d032		03 0c						.byte 3, IM+NN
>d034		3d d0				                .word nt_asm_lsr_a
>d036		21 ab 26 ab					.word xt_asm_lsr, z_asm_lsr
>d03a		6c 73 72					.text "lsr"
.d03d						nt_asm_lsr_a:
>d03d		05 0c						.byte 5, IM+NN
>d03f		4a d0				                .word nt_asm_lsr_x
>d041		26 ab 2b ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d045		6c 73 72 2e 61					.text "lsr.a"
.d04a						nt_asm_lsr_x:
>d04a		05 0c						.byte 5, IM+NN
>d04c		57 d0				                .word nt_asm_lsr_z
>d04e		2b ab 30 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d052		6c 73 72 2e 78					.text "lsr.x"
.d057						nt_asm_lsr_z:
>d057		05 0c						.byte 5, IM+NN
>d059		64 d0				                .word nt_asm_lsr_zx
>d05b		30 ab 35 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d05f		6c 73 72 2e 7a					.text "lsr.z"
.d064						nt_asm_lsr_zx:
>d064		06 0c						.byte 6, IM+NN
>d066		72 d0				                .word nt_asm_nop
>d068		35 ab 3a ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d06c		6c 73 72 2e 7a 78				.text "lsr.zx"
.d072						nt_asm_nop:
>d072		03 0c						.byte 3, IM+NN
>d074		7d d0				                .word nt_asm_ora
>d076		3a ab 3f ab					.word xt_asm_nop, z_asm_nop
>d07a		6e 6f 70					.text "nop"
.d07d						nt_asm_ora:
>d07d		03 0c						.byte 3, IM+NN
>d07f		88 d0				                .word nt_asm_ora_h
>d081		3f ab 44 ab					.word xt_asm_ora, z_asm_ora
>d085		6f 72 61					.text "ora"
.d088						nt_asm_ora_h:
>d088		05 0c						.byte 5, IM+NN
>d08a		95 d0				                .word nt_asm_ora_x
>d08c		44 ab 49 ab					.word xt_asm_ora_h, z_asm_ora_h
>d090		6f 72 61 2e 23					.text "ora.#"
.d095						nt_asm_ora_x:
>d095		05 0c						.byte 5, IM+NN
>d097		a2 d0				                .word nt_asm_ora_y
>d099		49 ab 4e ab					.word xt_asm_ora_x, z_asm_ora_x
>d09d		6f 72 61 2e 78					.text "ora.x"
.d0a2						nt_asm_ora_y:
>d0a2		05 0c						.byte 5, IM+NN
>d0a4		af d0				                .word nt_asm_ora_z
>d0a6		4e ab 53 ab					.word xt_asm_ora_y, z_asm_ora_y
>d0aa		6f 72 61 2e 79					.text "ora.y"
.d0af						nt_asm_ora_z:
>d0af		05 0c						.byte 5, IM+NN
>d0b1		bc d0				                .word nt_asm_ora_zi
>d0b3		53 ab 58 ab					.word xt_asm_ora_z, z_asm_ora_z
>d0b7		6f 72 61 2e 7a					.text "ora.z"
.d0bc						nt_asm_ora_zi:
>d0bc		06 0c						.byte 6, IM+NN
>d0be		ca d0				                .word nt_asm_ora_ziy
>d0c0		58 ab 5f ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d0c4		6f 72 61 2e 7a 69				.text "ora.zi"
.d0ca						nt_asm_ora_ziy:
>d0ca		07 0c						.byte 7, IM+NN
>d0cc		d9 d0				                .word nt_asm_ora_zx
>d0ce		5f ab 64 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d0d2		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d0d9						nt_asm_ora_zx:
>d0d9		06 0c						.byte 6, IM+NN
>d0db		e7 d0				                .word nt_asm_ora_zxi
>d0dd		64 ab 69 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d0e1		6f 72 61 2e 7a 78				.text "ora.zx"
.d0e7						nt_asm_ora_zxi:
>d0e7		07 0c						.byte 7, IM+NN
>d0e9		f6 d0				                .word nt_asm_pha
>d0eb		69 ab 6e ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0ef		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0f6						nt_asm_pha:
>d0f6		03 0c						.byte 3, IM+NN
>d0f8		01 d1				                .word nt_asm_php
>d0fa		6e ab 73 ab					.word xt_asm_pha, z_asm_pha
>d0fe		70 68 61					.text "pha"
.d101						nt_asm_php:
>d101		03 0c						.byte 3, IM+NN
>d103		0c d1				                .word nt_asm_phx
>d105		73 ab 78 ab					.word xt_asm_php, z_asm_php
>d109		70 68 70					.text "php"
.d10c						nt_asm_phx:
>d10c		03 0c						.byte 3, IM+NN
>d10e		17 d1				                .word nt_asm_phy
>d110		78 ab 7d ab					.word xt_asm_phx, z_asm_phx
>d114		70 68 78					.text "phx"
.d117						nt_asm_phy:
>d117		03 0c						.byte 3, IM+NN
>d119		22 d1				                .word nt_asm_pla
>d11b		7d ab 82 ab					.word xt_asm_phy, z_asm_phy
>d11f		70 68 79					.text "phy"
.d122						nt_asm_pla:
>d122		03 0c						.byte 3, IM+NN
>d124		2d d1				                .word nt_asm_plp
>d126		82 ab 87 ab					.word xt_asm_pla, z_asm_pla
>d12a		70 6c 61					.text "pla"
.d12d						nt_asm_plp:
>d12d		03 0c						.byte 3, IM+NN
>d12f		38 d1				                .word nt_asm_plx
>d131		87 ab 8c ab					.word xt_asm_plp, z_asm_plp
>d135		70 6c 70					.text "plp"
.d138						nt_asm_plx:
>d138		03 0c						.byte 3, IM+NN
>d13a		43 d1				                .word nt_asm_ply
>d13c		8c ab 91 ab					.word xt_asm_plx, z_asm_plx
>d140		70 6c 78					.text "plx"
.d143						nt_asm_ply:
>d143		03 0c						.byte 3, IM+NN
>d145		4e d1				                .word nt_asm_rol
>d147		91 ab 96 ab					.word xt_asm_ply, z_asm_ply
>d14b		70 6c 79					.text "ply"
.d14e						nt_asm_rol:
>d14e		03 0c						.byte 3, IM+NN
>d150		59 d1				                .word nt_asm_rol_a
>d152		96 ab 9b ab					.word xt_asm_rol, z_asm_rol
>d156		72 6f 6c					.text "rol"
.d159						nt_asm_rol_a:
>d159		05 0c						.byte 5, IM+NN
>d15b		66 d1				                .word nt_asm_rol_x
>d15d		9b ab a0 ab					.word xt_asm_rol_a, z_asm_rol_a
>d161		72 6f 6c 2e 61					.text "rol.a"
.d166						nt_asm_rol_x:
>d166		05 0c						.byte 5, IM+NN
>d168		73 d1				                .word nt_asm_rol_z
>d16a		a0 ab a5 ab					.word xt_asm_rol_x, z_asm_rol_x
>d16e		72 6f 6c 2e 78					.text "rol.x"
.d173						nt_asm_rol_z:
>d173		05 0c						.byte 5, IM+NN
>d175		80 d1				                .word nt_asm_rol_zx
>d177		a5 ab aa ab					.word xt_asm_rol_z, z_asm_rol_z
>d17b		72 6f 6c 2e 7a					.text "rol.z"
.d180						nt_asm_rol_zx:
>d180		06 0c						.byte 6, IM+NN
>d182		8e d1				                .word nt_asm_ror
>d184		aa ab af ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d188		72 6f 6c 2e 7a 78				.text "rol.zx"
.d18e						nt_asm_ror:
>d18e		03 0c						.byte 3, IM+NN
>d190		99 d1				                .word nt_asm_ror_a
>d192		af ab b4 ab					.word xt_asm_ror, z_asm_ror
>d196		72 6f 72					.text "ror"
.d199						nt_asm_ror_a:
>d199		05 0c						.byte 5, IM+NN
>d19b		a6 d1				                .word nt_asm_ror_x
>d19d		b4 ab b9 ab					.word xt_asm_ror_a, z_asm_ror_a
>d1a1		72 6f 72 2e 61					.text "ror.a"
.d1a6						nt_asm_ror_x:
>d1a6		05 0c						.byte 5, IM+NN
>d1a8		b3 d1				                .word nt_asm_ror_z
>d1aa		b9 ab be ab					.word xt_asm_ror_x, z_asm_ror_x
>d1ae		72 6f 72 2e 78					.text "ror.x"
.d1b3						nt_asm_ror_z:
>d1b3		05 0c						.byte 5, IM+NN
>d1b5		c0 d1				                .word nt_asm_ror_zx
>d1b7		be ab c3 ab					.word xt_asm_ror_z, z_asm_ror_z
>d1bb		72 6f 72 2e 7a					.text "ror.z"
.d1c0						nt_asm_ror_zx:
>d1c0		06 0c						.byte 6, IM+NN
>d1c2		ce d1				                .word nt_asm_rti
>d1c4		c3 ab c8 ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d1c8		72 6f 72 2e 7a 78				.text "ror.zx"
.d1ce						nt_asm_rti:
>d1ce		03 0c						.byte 3, IM+NN
>d1d0		d9 d1				                .word nt_asm_rts
>d1d2		c8 ab cd ab					.word xt_asm_rti, z_asm_rti
>d1d6		72 74 69					.text "rti"
.d1d9						nt_asm_rts:
>d1d9		03 0c						.byte 3, IM+NN
>d1db		e4 d1				                .word nt_asm_sbc
>d1dd		cd ab d2 ab					.word xt_asm_rts, z_asm_rts
>d1e1		72 74 73					.text "rts"
.d1e4						nt_asm_sbc:
>d1e4		03 0c						.byte 3, IM+NN
>d1e6		ef d1				                .word nt_asm_sbc_h
>d1e8		d2 ab d7 ab					.word xt_asm_sbc, z_asm_sbc
>d1ec		73 62 63					.text "sbc"
.d1ef						nt_asm_sbc_h:
>d1ef		05 0c						.byte 5, IM+NN
>d1f1		fc d1				                .word nt_asm_sbc_x
>d1f3		d7 ab dc ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d1f7		73 62 63 2e 23					.text "sbc.#"
.d1fc						nt_asm_sbc_x:
>d1fc		05 0c						.byte 5, IM+NN
>d1fe		09 d2				                .word nt_asm_sbc_y
>d200		dc ab e1 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d204		73 62 63 2e 78					.text "sbc.x"
.d209						nt_asm_sbc_y:
>d209		05 0c						.byte 5, IM+NN
>d20b		16 d2				                .word nt_asm_sbc_z
>d20d		e1 ab e6 ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d211		73 62 63 2e 79					.text "sbc.y"
.d216						nt_asm_sbc_z:
>d216		05 0c						.byte 5, IM+NN
>d218		23 d2				                .word nt_asm_sbc_zi
>d21a		e6 ab eb ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d21e		73 62 63 2e 7a					.text "sbc.z"
.d223						nt_asm_sbc_zi:
>d223		06 0c						.byte 6, IM+NN
>d225		31 d2				                .word nt_asm_sbc_ziy
>d227		eb ab f0 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d22b		73 62 63 2e 7a 69				.text "sbc.zi"
.d231						nt_asm_sbc_ziy:
>d231		07 0c						.byte 7, IM+NN
>d233		40 d2				                .word nt_asm_sbc_zx
>d235		f0 ab f5 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d239		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d240						nt_asm_sbc_zx:
>d240		06 0c						.byte 6, IM+NN
>d242		4e d2				                .word nt_asm_sbc_zxi
>d244		f5 ab fa ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d248		73 62 63 2e 7a 78				.text "sbc.zx"
.d24e						nt_asm_sbc_zxi:
>d24e		07 0c						.byte 7, IM+NN
>d250		5d d2				                .word nt_asm_sec
>d252		fa ab fe ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d256		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d25d						nt_asm_sec:
>d25d		03 0c						.byte 3, IM+NN
>d25f		68 d2				                .word nt_asm_sed
>d261		fe ab 02 ac					.word xt_asm_sec, z_asm_sec
>d265		73 65 63					.text "sec"
.d268						nt_asm_sed:
>d268		03 0c						.byte 3, IM+NN
>d26a		73 d2				                .word nt_asm_sei
>d26c		02 ac 06 ac					.word xt_asm_sed, z_asm_sed
>d270		73 65 64					.text "sed"
.d273						nt_asm_sei:
>d273		03 0c						.byte 3, IM+NN
>d275		7e d2				                .word nt_asm_sta
>d277		06 ac 0a ac					.word xt_asm_sei, z_asm_sei
>d27b		73 65 69					.text "sei"
.d27e						nt_asm_sta:
>d27e		03 0c						.byte 3, IM+NN
>d280		89 d2				                .word nt_asm_sta_x
>d282		0a ac 0e ac					.word xt_asm_sta, z_asm_sta
>d286		73 74 61					.text "sta"
.d289						nt_asm_sta_x:
>d289		05 0c						.byte 5, IM+NN
>d28b		96 d2				                .word nt_asm_sta_y
>d28d		0e ac 12 ac					.word xt_asm_sta_x, z_asm_sta_x
>d291		73 74 61 2e 78					.text "sta.x"
.d296						nt_asm_sta_y:
>d296		05 0c						.byte 5, IM+NN
>d298		a3 d2				                .word nt_asm_sta_z
>d29a		12 ac 16 ac					.word xt_asm_sta_y, z_asm_sta_y
>d29e		73 74 61 2e 79					.text "sta.y"
.d2a3						nt_asm_sta_z:
>d2a3		05 0c						.byte 5, IM+NN
>d2a5		b0 d2				                .word nt_asm_sta_zi
>d2a7		16 ac 1a ac					.word xt_asm_sta_z, z_asm_sta_z
>d2ab		73 74 61 2e 7a					.text "sta.z"
.d2b0						nt_asm_sta_zi:
>d2b0		06 0c						.byte 6, IM+NN
>d2b2		be d2				                .word nt_asm_sta_ziy
>d2b4		1a ac 1e ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d2b8		73 74 61 2e 7a 69				.text "sta.zi"
.d2be						nt_asm_sta_ziy:
>d2be		07 0c						.byte 7, IM+NN
>d2c0		cd d2				                .word nt_asm_sta_zx
>d2c2		1e ac 22 ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d2c6		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d2cd						nt_asm_sta_zx:
>d2cd		06 0c						.byte 6, IM+NN
>d2cf		db d2				                .word nt_asm_sta_zxi
>d2d1		22 ac 26 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d2d5		73 74 61 2e 7a 78				.text "sta.zx"
.d2db						nt_asm_sta_zxi:
>d2db		07 0c						.byte 7, IM+NN
>d2dd		ea d2				                .word nt_asm_stx
>d2df		26 ac 2a ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2e3		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2ea						nt_asm_stx:
>d2ea		03 0c						.byte 3, IM+NN
>d2ec		f5 d2				                .word nt_asm_stx_z
>d2ee		2a ac 2e ac					.word xt_asm_stx, z_asm_stx
>d2f2		73 74 78					.text "stx"
.d2f5						nt_asm_stx_z:
>d2f5		05 0c						.byte 5, IM+NN
>d2f7		02 d3				                .word nt_asm_stx_zy
>d2f9		2e ac 32 ac					.word xt_asm_stx_z, z_asm_stx_z
>d2fd		73 74 78 2e 7a					.text "stx.z"
.d302						nt_asm_stx_zy:
>d302		06 0c						.byte 6, IM+NN
>d304		10 d3				                .word nt_asm_sty
>d306		32 ac 36 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d30a		73 74 78 2e 7a 79				.text "stx.zy"
.d310						nt_asm_sty:
>d310		03 0c						.byte 3, IM+NN
>d312		1b d3				                .word nt_asm_sty_z
>d314		36 ac 3a ac					.word xt_asm_sty, z_asm_sty
>d318		73 74 79					.text "sty"
.d31b						nt_asm_sty_z:
>d31b		05 0c						.byte 5, IM+NN
>d31d		28 d3				                .word nt_asm_sty_zx
>d31f		3a ac 3e ac					.word xt_asm_sty_z, z_asm_sty_z
>d323		73 74 79 2e 7a					.text "sty.z"
.d328						nt_asm_sty_zx:
>d328		06 0c						.byte 6, IM+NN
>d32a		36 d3				                .word nt_asm_stz
>d32c		3e ac 42 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d330		73 74 79 2e 7a 78				.text "sty.zx"
.d336						nt_asm_stz:
>d336		03 0c						.byte 3, IM+NN
>d338		41 d3				                .word nt_asm_stz_x
>d33a		42 ac 46 ac					.word xt_asm_stz, z_asm_stz
>d33e		73 74 7a					.text "stz"
.d341						nt_asm_stz_x:
>d341		05 0c						.byte 5, IM+NN
>d343		4e d3				                .word nt_asm_stz_z
>d345		46 ac 4a ac					.word xt_asm_stz_x, z_asm_stz_x
>d349		73 74 7a 2e 78					.text "stz.x"
.d34e						nt_asm_stz_z:
>d34e		05 0c						.byte 5, IM+NN
>d350		5b d3				                .word nt_asm_stz_zx
>d352		4a ac 4e ac					.word xt_asm_stz_z, z_asm_stz_z
>d356		73 74 7a 2e 7a					.text "stz.z"
.d35b						nt_asm_stz_zx:
>d35b		06 0c						.byte 6, IM+NN
>d35d		69 d3				                .word nt_asm_tax
>d35f		4e ac 52 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d363		73 74 7a 2e 7a 78				.text "stz.zx"
.d369						nt_asm_tax:
>d369		03 0c						.byte 3, IM+NN
>d36b		74 d3				                .word nt_asm_tay
>d36d		52 ac 56 ac					.word xt_asm_tax, z_asm_tax
>d371		74 61 78					.text "tax"
.d374						nt_asm_tay:
>d374		03 0c						.byte 3, IM+NN
>d376		7f d3				                .word nt_asm_trb
>d378		56 ac 5a ac					.word xt_asm_tay, z_asm_tay
>d37c		74 61 79					.text "tay"
.d37f						nt_asm_trb:
>d37f		03 0c						.byte 3, IM+NN
>d381		8a d3				                .word nt_asm_trb_z
>d383		5a ac 5e ac					.word xt_asm_trb, z_asm_trb
>d387		74 72 62					.text "trb"
.d38a						nt_asm_trb_z:
>d38a		05 0c						.byte 5, IM+NN
>d38c		97 d3				                .word nt_asm_tsb
>d38e		5e ac 62 ac					.word xt_asm_trb_z, z_asm_trb_z
>d392		74 72 62 2e 7a					.text "trb.z"
.d397						nt_asm_tsb:
>d397		03 0c						.byte 3, IM+NN
>d399		a2 d3				                .word nt_asm_tsb_z
>d39b		62 ac 66 ac					.word xt_asm_tsb, z_asm_tsb
>d39f		74 73 62					.text "tsb"
.d3a2						nt_asm_tsb_z:
>d3a2		05 0c						.byte 5, IM+NN
>d3a4		af d3				                .word nt_asm_tsx
>d3a6		66 ac 6a ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d3aa		74 73 62 2e 7a					.text "tsb.z"
.d3af						nt_asm_tsx:
>d3af		03 0c						.byte 3, IM+NN
>d3b1		ba d3				                .word nt_asm_txa
>d3b3		6a ac 6e ac					.word xt_asm_tsx, z_asm_tsx
>d3b7		74 73 78					.text "tsx"
.d3ba						nt_asm_txa:
>d3ba		03 0c						.byte 3, IM+NN
>d3bc		c5 d3				                .word nt_asm_txs
>d3be		6e ac 72 ac					.word xt_asm_txa, z_asm_txa
>d3c2		74 78 61					.text "txa"
.d3c5						nt_asm_txs:
>d3c5		03 0c						.byte 3, IM+NN
>d3c7		d0 d3				                .word nt_asm_tya
>d3c9		72 ac 76 ac					.word xt_asm_txs, z_asm_txs
>d3cd		74 78 73					.text "txs"
.d3d0						nt_asm_tya:
>d3d0		03 0c						.byte 3, IM+NN
>d3d2		db d3				                .word nt_asm_arrow
>d3d4		76 ac 7a ac					.word xt_asm_tya, z_asm_tya
>d3d8		74 79 61					.text "tya"
.d3db						nt_asm_arrow:
>d3db		03 04				                .byte 3, IM
>d3dd		e6 d3				                .word nt_asm_back_jump
>d3df		57 91 61 91			                .word xt_asm_arrow, z_asm_arrow
>d3e3		2d 2d 3e			                .text "-->"
.d3e6						nt_asm_back_jump:
>d3e6		02 04				                .byte 2, IM
>d3e8		f0 d3				                .word nt_asm_back_branch
>d3ea		cb ac cb ac			                .word xt_asm_back_jump, z_asm_back_jump
>d3ee		3c 6a				                .text "<j"
.d3f0						nt_asm_back_branch:
>d3f0		02 04				                .byte 2, IM
>d3f2		fa d3				                .word nt_asm_push_a
>d3f4		cc ac d4 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d3f8		3c 62				                .text "<b"
.d3fa						nt_asm_push_a:
>d3fa		06 0c				                .byte 6, IM+NN
>d3fc		00 00				                .word 0000
>d3fe		b4 ac c3 ac			                .word xt_asm_push_a, z_asm_push_a
>d402		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix
=1						ix += 1
=1						str_compile        = ix
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_sdc     = ix
=14						ix += 1
=14						str_disasm_bra     = ix
=15						ix += 1
=15						str_disasm_0test   = ix
=16						ix += 1
.d408						string_table:
>d408		28 d4 2c d4 36 d4 41 d4		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d410		78 d4 70 d4 65 d4 7f d4		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d418		85 d4 a1 d4 a6 d4 ab d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d420		bc d4 c5 d4 d7 d4 df d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra, s_disasm_0test ; 12-15
>d428		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d42c		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d434		64 00
>d436		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d43e		64 20 00
>d441		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d449		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d459		4f 50 51 52 53 54 55 56 57 58 59 5a
>d465		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d46d		72 20 00
>d470		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d478		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d47f		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d485		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d48d		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d49d		29 3a 20 00
>d4a1		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d4a6		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d4ab		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d4b3		63 69 6d 61 6c 29 3a 20 00
>d4bc		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d4c4		00
>d4c5		53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d4cd		50 54 48 20 43 48 45 43 4b 00
>d4d7		42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
>d4df		30 54 45 53 54 00		s_disasm_0test: .text "0TEST",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d4e5						error_table:
>d4e5		01 d5 22 d5 42 d5 63 d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4ed		80 d5 91 d5 a1 d5 cf d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4f5		e7 d5 08 d6 1d d6 39 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4fd		50 d6 8f d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d501		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d509		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d519		65 20 6d 65 6d 6f 72 79 00
>d522		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d52a		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d53a		20 52 45 46 49 4c 4c 00
>d542		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d54a		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d55a		6e 6c 79 20 77 6f 72 64 00
>d563		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d56b		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d57b		20 79 65 74 00
>d580		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d588		20 62 79 20 7a 65 72 6f 00
>d591		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d599		66 61 69 6c 75 72 65 00
>d5a1		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d5a9		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d5b9		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d5c9		64 20 2d 31 29 00
>d5cf		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5d7		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5e7		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d5ef		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d5ff		64 20 6e 75 6d 62 65 72 00
>d608		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d610		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d61d		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d625		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d635		4c 4f 54 00
>d639		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d641		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d650		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d658		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d668		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d678		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d688		56 45 43 54 4f 52 00
>d68f		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d697		74 61 63 6b 3a 00
>d69d		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d6a5		44 2d 53 54 52 49 4e 47
>d6ad		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d6b3		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d6b8		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d6c0		2d 55 4e 49 54 2d 42 49 54 53
>d6ca		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d6d2		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6da		52
>d6db		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6e1		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6e7		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6ef		53 54 41 43 4b 2d 43 45 4c 4c 53
>d6fa		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d702		45 4c 4c 53
>d706		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d70e		54 53
>d710		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d716		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d71d						cmpl_subroutine:
.d71d		48		pha		                pha             ; save LSB of address
.d71e		a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d720		80 03		bra $d725	                bra cmpl_common
.d722						cmpl_jump:
.d722		48		pha		                pha             ; save LSB of address
.d723		a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d725						cmpl_common:
.d725		20 2d d7	jsr $d72d	                jsr cmpl_a      ; compile opcode
.d728		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d729						cmpl_word:
.d729		20 2d d7	jsr $d72d	                jsr cmpl_a      ; compile LSB of address
.d72c		98		tya		                tya             ; fall thru for MSB
.d72d						cmpl_a:
.d72d		92 00		sta ($00)	                sta (cp)
.d72f		e6 00		inc $00		                inc cp
.d731		d0 02		bne $d735	                bne _done
.d733		e6 01		inc $01		                inc cp+1
.d735						_done:
.d735		60		rts		                rts
.d736						doconst:
.d736		ca		dex		                dex             ; make room for constant
.d737		ca		dex		                dex
.d738		68		pla		                pla             ; LSB of return address
.d739		85 22		sta $22		                sta tmp1
.d73b		68		pla		                pla             ; MSB of return address
.d73c		85 23		sta $23		                sta tmp1+1
.d73e		a0 01		ldy #$01	                ldy #1
.d740		b1 22		lda ($22),y	                lda (tmp1),y
.d742		95 00		sta $00,x	                sta 0,x
.d744		c8		iny		                iny
.d745		b1 22		lda ($22),y	                lda (tmp1),y
.d747		95 01		sta $01,x	                sta 1,x
.d749		60		rts		                rts
.d74a						dodefer:
.d74a		68		pla		                pla             ; LSB
.d74b		85 22		sta $22		                sta tmp1
.d74d		68		pla		                pla             ; MSB
.d74e		85 23		sta $23		                sta tmp1+1
.d750		a0 01		ldy #$01	                ldy #1
.d752		b1 22		lda ($22),y	                lda (tmp1),y
.d754		85 24		sta $24		                sta tmp2
.d756		c8		iny		                iny
.d757		b1 22		lda ($22),y	                lda (tmp1),y
.d759		85 25		sta $25		                sta tmp2+1
.d75b		6c 24 00	jmp ($0024)	                jmp (tmp2)      ; This is actually a jump to the new target
.d75e						defer_error:
.d75e		a9 03		lda #$03	                lda #err_defer
.d760		4c 8b d8	jmp $d88b	                jmp error
.d763						dodoes:
.d763		7a		ply		                ply             ; LSB
.d764		68		pla		                pla             ; MSB
.d765		c8		iny		                iny
.d766		d0 01		bne $d769	                bne +
.d768		1a		inc a		                ina
.d769						+
.d769		84 24		sty $24		                sty tmp2
.d76b		85 25		sta $25		                sta tmp2+1
.d76d		ca		dex		                dex
.d76e		ca		dex		                dex
.d76f		7a		ply		                ply
.d770		68		pla		                pla
.d771		c8		iny		                iny
.d772		d0 01		bne $d775	                bne +
.d774		1a		inc a		                ina
.d775						+
.d775		94 00		sty $00,x	                sty 0,x         ; LSB
.d777		95 01		sta $01,x	                sta 1,x         ; MSB
.d779		6c 24 00	jmp ($0024)	                jmp (tmp2)
.d77c						dovar:
.d77c		7a		ply		                ply             ; LSB
.d77d		68		pla		                pla             ; MSB
.d77e		c8		iny		                iny
.d77f		d0 01		bne $d782	                bne +
.d781		1a		inc a		                ina
.d782						+
.d782		ca		dex		                dex
.d783		ca		dex		                dex
.d784		95 01		sta $01,x	                sta 1,x
.d786		98		tya		                tya
.d787		95 00		sta $00,x	                sta 0,x
.d789		60		rts		                rts
.d78a						byte_to_ascii:
.d78a		48		pha		                pha
.d78b		4a		lsr a		                lsr             ; convert high nibble first
.d78c		4a		lsr a		                lsr
.d78d		4a		lsr a		                lsr
.d78e		4a		lsr a		                lsr
.d78f		20 93 d7	jsr $d793	                jsr _nibble_to_ascii
.d792		68		pla		                pla
.d793						_nibble_to_ascii:
.d793		29 0f		and #$0f	                and #$0F
.d795		09 30		ora #$30	                ora #'0'
.d797		c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d799		90 02		bcc $d79d	                bcc +
.d79b		69 06		adc #$06	                adc #$06
.d79d		4c db 8d	jmp $8ddb	+               jmp emit_a
.d7a0		60		rts		                rts
.d7a1						compare_16bit:
.d7a1		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d7a3		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d7a5		f0 0a		beq $d7b1	                beq _equal
.d7a7		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7a9		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7ab		09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d7ad		70 08		bvs $d7b7	                bvs _overflow
.d7af		80 08		bra $d7b9	                bra _not_equal
.d7b1						_equal:
.d7b1		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7b3		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7b5		50 04		bvc $d7bb	                bvc _done
.d7b7						_overflow:
.d7b7		49 80		eor #$80	                eor #$80                ; complement negative flag
.d7b9						_not_equal:
.d7b9		09 01		ora #$01	                ora #1                  ; if overflow, we can't be equal
.d7bb						_done:
.d7bb		60		rts		                rts
.d7bc						current_to_dp:
.d7bc		a0 04		ldy #$04	                ldy #current_offset
.d7be		b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d7c0		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7c1		18		clc		                clc
.d7c2		69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7c4		a8		tay		                tay
.d7c5		b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d7c7		85 02		sta $02		                sta dp
.d7c9		c8		iny		                iny
.d7ca		b1 1e		lda ($1e),y	                lda (up),y
.d7cc		85 03		sta $03		                sta dp+1
.d7ce		60		rts		                rts
.d7cf						dp_to_current:
.d7cf		a0 04		ldy #$04	                ldy #current_offset
.d7d1		b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d7d3		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7d4		18		clc		                clc
.d7d5		69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7d7		a8		tay		                tay
.d7d8		a5 02		lda $02		                lda dp
.d7da		91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d7dc		c8		iny		                iny
.d7dd		a5 03		lda $03		                lda dp+1
.d7df		91 1e		sta ($1e),y	                sta (up),y
.d7e1		60		rts		                rts
.d7e2						interpret:
.d7e2						_loop:
.d7e2		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7e5		b5 00		lda $00,x	                lda 0,x
.d7e7		15 01		ora $01,x	                ora 1,x
.d7e9		f0 6b		beq $d856	                beq _line_done
.d7eb		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7ee		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7f1		b5 00		lda $00,x	                lda 0,x
.d7f3		15 01		ora $01,x	                ora 1,x
.d7f5		d0 28		bne $d81f	                bne _got_name_token
.d7f7		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7f8		e8		inx		                inx
.d7f9		20 6e 96	jsr $966e	                jsr xt_number           ; ( addr u -- u|d )
.d7fc		a5 16		lda $16		                lda state
.d7fe		f0 e2		beq $d7e2	                beq _loop
.d800		a9 20		lda #$20	                lda #$20
.d802		24 20		bit $20		                bit status
.d804		f0 0d		beq $d813	                beq _single_number
.d806		20 5c a1	jsr $a15c	                jsr xt_swap
.d809		a0 93		ldy #$93	                ldy #>literal_runtime
.d80b		a9 79		lda #$79	                lda #<literal_runtime
.d80d		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.d810		20 24 87	jsr $8724	                jsr xt_comma
.d813						_single_number:
.d813		a0 93		ldy #$93	                ldy #>literal_runtime
.d815		a9 79		lda #$79	                lda #<literal_runtime
.d817		20 1d d7	jsr $d71d	                jsr cmpl_subroutine
.d81a		20 24 87	jsr $8724	                jsr xt_comma
.d81d		80 c3		bra $d7e2	                bra _loop
.d81f						_got_name_token:
.d81f		b5 00		lda $00,x	                lda 0,x
.d821		95 04		sta $04,x	                sta 4,x
.d823		b5 01		lda $01,x	                lda 1,x
.d825		95 05		sta $05,x	                sta 5,x
.d827		e8		inx		                inx
.d828		e8		inx		                inx
.d829		e8		inx		                inx
.d82a		e8		inx		                inx                     ; ( nt )
.d82b		20 01 98	jsr $9801	                jsr xt_one_plus
.d82e		a1 00		lda ($00,x)	                lda (0,x)
.d830		48		pha		                pha
.d831		20 f5 97	jsr $97f5	                jsr xt_one_minus
.d834		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt - xt )
.d837		a5 16		lda $16		                lda state
.d839		d0 10		bne $d84b	                bne _compile
.d83b		68		pla		                pla
.d83c		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d83e		f0 05		beq $d845	                beq _interpret
.d840		a9 02		lda #$02	                lda #err_compileonly
.d842		4c 8b d8	jmp $d88b	                jmp error
.d845						_interpret:
.d845		20 22 8f	jsr $8f22	                jsr xt_execute
.d848		4c e2 d7	jmp $d7e2	                jmp _loop
.d84b						_compile:
.d84b		68		pla		                pla
.d84c		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d84e		d0 f5		bne $d845	                bne _interpret          ; IMMEDIATE word, execute right now
.d850		20 a3 87	jsr $87a3	                jsr xt_compile_comma
.d853		4c e2 d7	jmp $d7e2	                jmp _loop
.d856						_line_done:
.d856		e8		inx		                inx
.d857		e8		inx		                inx
.d858		e8		inx		                inx
.d859		e8		inx		                inx
.d85a		60		rts		                rts
.d85b						is_printable:
.d85b		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d85d		90 08		bcc $d867	                bcc _done
.d85f		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d861		b0 03		bcs $d866	                bcs _failed
.d863		38		sec		                sec
.d864		80 01		bra $d867	                bra _done
.d866						_failed:
.d866		18		clc		                clc
.d867						_done:
.d867		60		rts		                rts
.d868						is_whitespace:
.d868		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d86a		90 08		bcc $d874	                bcc _done
.d86c		c9 21		cmp #$21	                cmp #AscSP+1
.d86e		b0 03		bcs $d873	                bcs _failed
.d870		38		sec		                sec
.d871		80 01		bra $d874	                bra _done
.d873						_failed:
.d873		18		clc		                clc
.d874						_done:
.d874		60		rts		                rts
.d875						underflow_1:
.d875		e0 77		cpx #$77	                cpx #dsp0-1
.d877		10 10		bpl $d889	                bpl underflow_error
.d879		60		rts		                rts
.d87a						underflow_2:
.d87a		e0 75		cpx #$75	                cpx #dsp0-3
.d87c		10 0b		bpl $d889	                bpl underflow_error
.d87e		60		rts		                rts
.d87f						underflow_3:
.d87f		e0 73		cpx #$73	                cpx #dsp0-5
.d881		10 06		bpl $d889	                bpl underflow_error
.d883		60		rts		                rts
.d884						underflow_4:
.d884		e0 71		cpx #$71	                cpx #dsp0-7
.d886		10 01		bpl $d889	                bpl underflow_error
.d888		60		rts		                rts
.d889						underflow_error:
.d889		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d88b						error:
.d88b		48		pha		                pha                     ; save error
.d88c		20 cb d8	jsr $d8cb	                jsr print_error
.d88f		20 2a 89	jsr $892a	                jsr xt_cr
.d892		68		pla		                pla
.d893		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d895		d0 17		bne $d8ae	                bne _no_underflow
.d897		a9 0d		lda #$0d	                lda #err_returnstack
.d899		20 cb d8	jsr $d8cb	                jsr print_error
.d89c		ba		tsx		                tsx
.d89d						-
.d89d		e8		inx		                inx
.d89e		f0 0b		beq $d8ab	                beq +
.d8a0		20 cc a0	jsr $a0cc	                jsr xt_space
.d8a3		bd 00 01	lda $0100,x	                lda $100,x
.d8a6		20 8a d7	jsr $d78a	                jsr byte_to_ascii
.d8a9		80 f2		bra $d89d	                bra -
.d8ab						+
.d8ab		20 2a 89	jsr $892a	                jsr xt_cr
.d8ae						_no_underflow:
.d8ae		4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d8b1						print_string_no_lf:
.d8b1		0a		asl a		                asl
.d8b2		a8		tay		                tay
.d8b3		b9 08 d4	lda $d408,y	                lda string_table,y
.d8b6		85 26		sta $26		                sta tmp3                ; LSB
.d8b8		c8		iny		                iny
.d8b9		b9 08 d4	lda $d408,y	                lda string_table,y
.d8bc		85 27		sta $27		                sta tmp3+1              ; MSB
.d8be						print_common:
.d8be		a0 00		ldy #$00	                ldy #0
.d8c0						_loop:
.d8c0		b1 26		lda ($26),y	                lda (tmp3),y
.d8c2		f0 06		beq $d8ca	                beq _done               ; strings are zero-terminated
.d8c4		20 db 8d	jsr $8ddb	                jsr emit_a              ; allows vectoring via output
.d8c7		c8		iny		                iny
.d8c8		80 f6		bra $d8c0	                bra _loop
.d8ca						_done:
.d8ca		60		rts		                rts
.d8cb						print_error:
.d8cb		0a		asl a		                asl
.d8cc		a8		tay		                tay
.d8cd		b9 e5 d4	lda $d4e5,y	                lda error_table,y
.d8d0		85 26		sta $26		                sta tmp3                ; LSB
.d8d2		c8		iny		                iny
.d8d3		b9 e5 d4	lda $d4e5,y	                lda error_table,y
.d8d6		85 27		sta $27		                sta tmp3+1              ; MSB
.d8d8		20 be d8	jsr $d8be	                jsr print_common
.d8db		60		rts		                rts
.d8dc						print_string:
.d8dc		20 b1 d8	jsr $d8b1	                jsr print_string_no_lf
.d8df		4c 2a 89	jmp $892a	                jmp xt_cr               ; JSR/RTS because never compiled
.d8e2						print_u:
.d8e2		20 56 a7	jsr $a756	                jsr xt_zero                     ; 0
.d8e5		20 3b 93	jsr $933b	                jsr xt_less_number_sign         ; <#
.d8e8		20 c2 97	jsr $97c2	                jsr xt_number_sign_s            ; #S
.d8eb		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater      ; #>
.d8ee		4c a7 a4	jmp $a4a7	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010						v_nmi:
.f010						v_reset:
.f010						v_irq:
.f010						kernel_init:
.f010		78		sei		                sei             ; Disable interrupts
.f011		a2 00		ldx #$00	                ldx #0
.f013		bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016		f0 06		beq $f01e	                beq _done
.f018		20 27 f0	jsr $f027	                jsr kernel_putc
.f01b		e8		inx		                inx
.f01c		80 f5		bra $f013	                bra -
.f01e						_done:
.f01e		4c 00 80	jmp $8000	                jmp forth
.f021						kernel_getc:
.f021						_loop:
.f021		ad 04 f0	lda $f004	                lda $f004
.f024		f0 fb		beq $f021	                beq _loop
.f026		60		rts		                rts
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta $f001
.f02a		60		rts		                rts
.f02b						platform_bye:
.f02b		00		brk #		                brk
.f02c						s_kernel_id:
>f02c		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		10 f0				.word v_nmi
>fffc		10 f0				.word v_reset
>fffe		10 f0				.word v_irq

;******  End of listing
