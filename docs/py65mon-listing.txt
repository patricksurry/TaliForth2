
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Sun Apr 21 10:12:56 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../native_words.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 57 a7	lda $a757,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 57 a7	lda $a757	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 75 a7	lda $a775,y	                lda cold_user_table,y
.8024		91 08		sta ($08),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad 75 a7	lda $a775	                lda cold_user_table
.802c		92 08		sta ($08)	                sta (up)
.802e		20 d5 88	jsr $88d5	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 3f		lda #$3f	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 ba		lda #$ba	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 eb 8f	jsr $8feb	                jsr xt_evaluate
.8048		9c 00 7c	stz $7c00	                stz hist_buff
.804b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057		9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060						xt_abort:
.8060		a2 78		ldx #$78	                ldx #dsp0
.8062						xt_quit:
.8062		8a		txa		                txa             ; Save the DSP that we just defined
.8063		a2 ff		ldx #$ff	                ldx #rsp0
.8065		9a		txs		                txs
.8066		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067		64 04		stz $04		                stz ip
.8069		64 05		stz $05		                stz ip+1
.806b		64 0a		stz $0a		                stz insrc
.806d		64 0b		stz $0b		                stz insrc+1
.806f		a9 00		lda #$00	                lda #0
.8071		a0 04		ldy #$04	                ldy #blk_offset
.8073		91 08		sta ($08),y	                sta (up),y
.8075		c8		iny		                iny
.8076		91 08		sta ($08),y	                sta (up),y
.8078		a9 fc		lda #$fc	                lda #(256-4)
.807a		85 1f		sta $1f		                sta loopctrl
.807c		64 1a		stz $1a		                stz state
.807e		64 1b		stz $1b		                stz state+1
.8080						_get_line:
.8080		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8082		85 0c		sta $0c		                sta cib
.8084		a9 02		lda #$02	                lda #>buffer0
.8086		85 0d		sta $0d		                sta cib+1
.8088		64 0e		stz $0e		                stz ciblen
.808a		64 0f		stz $0f		                stz ciblen+1
.808c		20 19 9a	jsr $9a19	                jsr xt_refill           ; ( -- f )
.808f		b5 00		lda $00,x	                lda 0,x
.8091		d0 05		bne $8098	                bne _success
.8093		a9 06		lda #$06	                lda #err_refill
.8095		4c 92 d7	jmp $d792	                jmp error
.8098						_success:
.8098		e8		inx		                inx                     ; drop
.8099		e8		inx		                inx
.809a		20 e9 d6	jsr $d6e9	                jsr interpret
.809d		e0 78		cpx #$78	                cpx #dsp0
.809f		f0 05		beq $80a6	                beq _stack_ok
.80a1		90 03		bcc $80a6	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a3		4c 90 d7	jmp $d790	                jmp underflow_error
.80a6						_stack_ok:
.80a6		a5 1a		lda $1a		                lda state
.80a8		f0 02		beq $80ac	                beq _print
.80aa		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80ac						_print:
.80ac		20 e3 d7	jsr $d7e3	                jsr print_string
.80af		80 cf		bra $8080	                bra _get_line
.80b1						z_cold:
.80b1						z_abort:
.80b1						z_quit:
.80b1						xt_abort_quote:
.80b1		20 fc 9b	jsr $9bfc	                jsr xt_s_quote          ; S"
.80b4		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b6		a9 bc		lda #$bc	                lda #<abort_quote_runtime
.80b8		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80bb		60		rts		z_abort_quote:  rts
.80bc						abort_quote_runtime:
.80bc		b5 04		lda $04,x	                lda 4,x
.80be		15 05		ora $05,x	                ora 5,x
.80c0		f0 09		beq $80cb	                beq _done       ; if FALSE, we're done
.80c2		20 2e a3	jsr $a32e	                jsr xt_type
.80c5		20 d5 88	jsr $88d5	                jsr xt_cr
.80c8		4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.80cb						_done:
.80cb		8a		txa		                txa
.80cc		18		clc		                clc
.80cd		69 06		adc #$06	                adc #6
.80cf		aa		tax		                tax
.80d0		60		rts		                rts
.80d1						xt_abs:
.80d1		20 7c d7	jsr $d77c	                jsr underflow_1
.80d4		b5 01		lda $01,x	                lda 1,x
.80d6		10 0d		bpl $80e5	                bpl _done       ; positive number, easy money!
.80d8		38		sec		                sec
.80d9		a9 00		lda #$00	                lda #0
.80db		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80dd		95 00		sta $00,x	                sta 0,x
.80df		a9 00		lda #$00	                lda #0          ; MSB
.80e1		f5 01		sbc $01,x	                sbc 1,x
.80e3		95 01		sta $01,x	                sta 1,x
.80e5						_done:
.80e5		60		rts		z_abs:          rts
.80e6						xt_accept:
.80e6		20 81 d7	jsr $d781	                jsr underflow_2
.80e9		b5 00		lda $00,x	                lda 0,x
.80eb		15 01		ora $01,x	                ora 1,x
.80ed		d0 09		bne $80f8	                bne _not_zero
.80ef		e8		inx		                inx
.80f0		e8		inx		                inx
.80f1		74 00		stz $00,x	                stz 0,x
.80f3		74 01		stz $01,x	                stz 1,x
.80f5		4c c4 81	jmp $81c4	                jmp accept_done
.80f8						_not_zero:
.80f8		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80fa		85 27		sta $27		                sta tmp2
.80fc		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fe		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8100		85 25		sta $25		                sta tmp1
.8102		b5 03		lda $03,x	                lda 3,x
.8104		85 26		sta $26		                sta tmp1+1
.8106		e8		inx		                inx
.8107		e8		inx		                inx
.8108		a0 00		ldy #$00	                ldy #0
.810a		a5 1c		lda $1c		                lda status
.810c		29 f7		and #$f7	                and #$F7
.810e		1a		inc a		               ina
.810f		09 08		ora #$08	                ora #%00001000
.8111		85 1c		sta $1c		                sta status
.8113						accept_loop:
.8113		20 45 92	jsr $9245	                jsr key_a
.8116		c9 0a		cmp #$0a	                cmp #AscLF
.8118		f0 20		beq $813a	                beq _eol
.811a		c9 0d		cmp #$0d	                cmp #AscCR
.811c		f0 1c		beq $813a	                beq _eol
.811e		c9 08		cmp #$08	                cmp #AscBS
.8120		f0 22		beq $8144	                beq _backspace
.8122		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8124		f0 1e		beq $8144	                beq _backspace
.8126		c9 10		cmp #$10	                cmp #AscCP
.8128		f0 36		beq $8160	                beq _ctrl_p
.812a		c9 0e		cmp #$0e	                cmp #AscCN
.812c		f0 44		beq $8172	                beq _ctrl_n
.812e		91 25		sta ($25),y	                sta (tmp1),y
.8130		c8		iny		                iny
.8131		20 7b 8d	jsr $8d7b	                jsr emit_a
.8134		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8136		d0 db		bne $8113	                bne accept_loop       ; fall through if buffer limit reached
.8138		80 03		bra $813d	                bra _buffer_full
.813a						_eol:
.813a		20 7b 9f	jsr $9f7b	                jsr xt_space    ; print final space
.813d						_buffer_full:
.813d		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813f		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.8141		4c c4 81	jmp $81c4	                jmp accept_done
.8144						_backspace:
.8144		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8146		d0 06		bne $814e	                bne +
.8148		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.814a		20 7b 8d	jsr $8d7b	                jsr emit_a
.814d		c8		iny		                iny
.814e						+
.814e		88		dey		                dey
.814f		a9 08		lda #$08	                lda #AscBS      ; move back one
.8151		20 7b 8d	jsr $8d7b	                jsr emit_a
.8154		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8156		20 7b 8d	jsr $8d7b	                jsr emit_a
.8159		a9 08		lda #$08	                lda #AscBS      ; move back over space
.815b		20 7b 8d	jsr $8d7b	                jsr emit_a
.815e		80 b3		bra $8113	                bra accept_loop
.8160						_ctrl_p:
.8160		a5 1c		lda $1c		                lda status
.8162		29 07		and #$07	                and #7
.8164		d0 08		bne $816e	                bne _ctrl_p_dec
.8166		a5 1c		lda $1c		                lda status
.8168		09 07		ora #$07	                ora #7
.816a		85 1c		sta $1c		                sta status
.816c		80 11		bra $817f	                bra _recall_history
.816e						_ctrl_p_dec:
.816e		c6 1c		dec $1c		                dec status
.8170		80 0d		bra $817f	                bra _recall_history
.8172						_ctrl_n:
.8172		a9 08		lda #$08	                lda #$8
.8174		24 1c		bit $1c		                bit status
.8176		d0 07		bne $817f	                bne _recall_history
.8178		a5 1c		lda $1c		                lda status
.817a		29 f7		and #$f7	                and #$F7
.817c		1a		inc a		               ina
.817d		85 1c		sta $1c		                sta status
.817f						_recall_history:
.817f		a9 08		lda #$08	                lda #%00001000
.8181		14 1c		trb $1c		                trb status
.8183		20 df 81	jsr $81df	                jsr accept_total_recall
.8186		a9 0d		lda #$0d	                lda #AscCR
.8188		20 7b 8d	jsr $8d7b	                jsr emit_a
.818b						input_clear:
.818b		c0 00		cpy #$00	                cpy #0
.818d		f0 08		beq $8197	                beq input_cleared
.818f		a9 20		lda #$20	                lda #AscSP
.8191		20 7b 8d	jsr $8d7b	                jsr emit_a
.8194		88		dey		                dey
.8195		80 f4		bra $818b	                bra input_clear
.8197						input_cleared:
.8197		a9 0d		lda #$0d	                lda #AscCR
.8199		20 7b 8d	jsr $8d7b	                jsr emit_a
.819c		b1 29		lda ($29),y	                lda (tmp3),y
.819e		85 1d		sta $1d		                sta status+1
.81a0		e6 29		inc $29		                inc tmp3
.81a2		d0 02		bne $81a6	                bne +           ; Increment the upper byte on carry.
.81a4		e6 2a		inc $2a		                inc tmp3+1
.81a6						+
.81a6		a9 0d		lda #$0d	                lda #AscCR
.81a8		20 7b 8d	jsr $8d7b	                jsr emit_a
.81ab						_history_loop:
.81ab		c4 1d		cpy $1d		                cpy status+1
.81ad		d0 03		bne $81b2	                bne +
.81af		4c 13 81	jmp $8113	                jmp accept_loop       ; Needs a long jump
.81b2						+
.81b2		c4 27		cpy $27		                cpy tmp2
.81b4		f0 0a		beq $81c0	                beq _hist_filled_buffer
.81b6		b1 29		lda ($29),y	                lda (tmp3),y
.81b8		91 25		sta ($25),y	                sta (tmp1),y
.81ba		20 7b 8d	jsr $8d7b	                jsr emit_a
.81bd		c8		iny		                iny
.81be		80 eb		bra $81ab	                bra _history_loop
.81c0						_hist_filled_buffer:
.81c0		88		dey		                dey
.81c1		4c 13 81	jmp $8113	                jmp accept_loop
.81c4						accept_done:
.81c4		20 df 81	jsr $81df	                jsr accept_total_recall
.81c7		85 1d		sta $1d		                sta status+1
.81c9		a0 00		ldy #$00	                ldy #0
.81cb		91 29		sta ($29),y	                sta (tmp3),y
.81cd		e6 29		inc $29		                inc tmp3
.81cf		d0 02		bne $81d3	                bne +           ; Increment the upper byte on carry.
.81d1		e6 2a		inc $2a		                inc tmp3+1
.81d3						+
.81d3						_save_history_loop:
.81d3		c4 1d		cpy $1d		                cpy status+1
.81d5		f0 07		beq $81de	                beq _save_history_done
.81d7		b1 25		lda ($25),y	                lda (tmp1),y
.81d9		91 29		sta ($29),y	                sta (tmp3),y
.81db		c8		iny		                iny
.81dc		80 f5		bra $81d3	                bra _save_history_loop
.81de						_save_history_done:
.81de						z_accept:
.81de		60		rts		                rts
.81df						accept_total_recall:
.81df		a9 00		lda #$00	                lda #<hist_buff
.81e1		85 29		sta $29		                sta tmp3
.81e3		a9 7c		lda #$7c	                lda #>hist_buff
.81e5		85 2a		sta $2a		                sta tmp3+1
.81e7		a5 1c		lda $1c		                lda status
.81e9		6a		ror a		                ror
.81ea		29 03		and #$03	                and #3
.81ec		18		clc		                clc
.81ed		65 2a		adc $2a		                adc tmp3+1
.81ef		85 2a		sta $2a		                sta tmp3+1
.81f1		a5 1c		lda $1c		                lda status
.81f3		6a		ror a		                ror             ; Rotate through carry into msb.
.81f4		6a		ror a		                ror
.81f5		29 80		and #$80	                and #$80
.81f7		18		clc		                clc
.81f8		65 29		adc $29		                adc tmp3
.81fa		85 29		sta $29		                sta tmp3
.81fc		90 02		bcc $8200	                bcc +           ; Increment the upper byte on carry.
.81fe		e6 2a		inc $2a		                inc tmp3+1
.8200						+
.8200		98		tya		                tya
.8201		c9 80		cmp #$80	                cmp #$80
.8203		90 02		bcc $8207	                bcc +
.8205		a9 7f		lda #$7f	                lda #$7F
.8207						+
.8207		60		rts		                rts
.8208						xt_action_of:
.8208		a5 1a		lda $1a		                lda state
.820a		05 1b		ora $1b		                ora state+1
.820c		f0 0c		beq $821a	                beq _interpreting
.820e						_compiling:
.820e		20 24 85	jsr $8524	                jsr xt_bracket_tick
.8211		a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.8213		a9 50		lda #$50	                lda #<xt_defer_fetch
.8215		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.8218		80 06		bra $8220	                bra _done
.821a						_interpreting:
.821a		20 5e a0	jsr $a05e	                jsr xt_tick
.821d		20 50 8a	jsr $8a50	                jsr xt_defer_fetch
.8220						_done:
.8220		60		rts		z_action_of:           rts
.8221						xt_again:
.8221		20 7c d7	jsr $d77c	                jsr underflow_1
.8224		b5 01		lda $01,x	                lda 1,x
.8226		a8		tay		                tay
.8227		b5 00		lda $00,x	                lda 0,x         ; A=LSB, Y=MSB
.8229		20 be d5	jsr $d5be	                jsr cmpl_jump
.822c		e8		inx		                inx
.822d		e8		inx		                inx
.822e		60		rts		z_again:        rts
.822f						xt_align:
.822f						xt_aligned:
.822f						z_align:
.822f		60		rts		z_aligned:      rts             ; stripped out during native compile
.8230						xt_allot:
.8230		20 7c d7	jsr $d77c	                jsr underflow_1
.8233		b5 01		lda $01,x	                lda 1,x
.8235		30 22		bmi $8259	                bmi _release
.8237		18		clc		                clc
.8238		a5 00		lda $00		                lda cp
.823a		75 00		adc $00,x	                adc 0,x
.823c		85 00		sta $00		                sta cp
.823e		a5 01		lda $01		                lda cp+1
.8240		75 01		adc $01,x	                adc 1,x
.8242		85 01		sta $01		                sta cp+1
.8244		a0 00		ldy #$00	                ldy #<cp_end
.8246		c4 00		cpy $00		                cpy cp
.8248		a9 7c		lda #$7c	                lda #>cp_end
.824a		e5 01		sbc $01		                sbc cp+1
.824c		b0 48		bcs $8296	                bcs _done               ; we're fine.
.824e		84 00		sty $00		                sty cp                  ; still #<cp_end
.8250		a9 7c		lda #$7c	                lda #>cp_end
.8252		85 01		sta $01		                sta cp+1
.8254		a9 00		lda #$00	                lda #err_allot
.8256		4c 92 d7	jmp $d792	                jmp error
.8259						_release:
.8259		ca		dex		                dex
.825a		ca		dex		                dex
.825b		a5 00		lda $00		                lda cp
.825d		95 00		sta $00,x	                sta 0,x
.825f		a5 01		lda $01		                lda cp+1
.8261		95 01		sta $01,x	                sta 1,x
.8263		20 04 99	jsr $9904	                jsr xt_plus                     ; new CP is now TOS
.8266		ca		dex		                dex
.8267		ca		dex		                dex                             ; new CP now NOS
.8268		a9 00		lda #$00	                lda #<cp0
.826a		95 00		sta $00,x	                sta 0,x
.826c		a9 03		lda #$03	                lda #>cp0
.826e		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8270		20 a8 d6	jsr $d6a8	                jsr compare_16bit               ; still ( CP CP0 )
.8273		f0 17		beq $828c	                beq _nega_done
.8275		30 15		bmi $828c	                bmi _nega_done
.8277		a9 00		lda #$00	                lda #<cp0
.8279		85 00		sta $00		                sta cp
.827b		a9 03		lda #$03	                lda #>cp0
.827d		85 01		sta $01		                sta cp+1
.827f		a9 21		lda #$21	                lda #<dictionary_start
.8281		85 02		sta $02		                sta dp
.8283		a9 bb		lda #$bb	                lda #>dictionary_start
.8285		85 03		sta $03		                sta dp+1
.8287		a9 0a		lda #$0a	                lda #err_negallot
.8289		4c 92 d7	jmp $d792	                jmp error
.828c						_nega_done:
.828c		b5 02		lda $02,x	                lda 2,x
.828e		85 00		sta $00		                sta cp
.8290		b5 03		lda $03,x	                lda 3,x
.8292		85 01		sta $01		                sta cp+1
.8294		e8		inx		                inx
.8295		e8		inx		                inx                     ; drop through to _done
.8296						_done:
.8296		e8		inx		                inx
.8297		e8		inx		                inx
.8298						z_allot:
.8298		60		rts		                rts
.8299						xt_allow_native:
.8299		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.829c		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.829e		b1 02		lda ($02),y	                lda (dp),y
.82a0		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.82a2		91 02		sta ($02),y	                sta (dp),y
.82a4						z_allow_native:
.82a4		60		rts		                rts
.82a5						xt_also:
.82a5		20 4a 90	jsr $904a	                jsr xt_get_order
.82a8		20 b6 97	jsr $97b6	                jsr xt_over
.82ab		20 05 a0	jsr $a005	                jsr xt_swap
.82ae		20 40 97	jsr $9740	                jsr xt_one_plus
.82b1		20 c8 9b	jsr $9bc8	                jsr xt_set_order
.82b4		60		rts		z_also:         rts
.82b5						xt_always_native:
.82b5		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.82b8		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82ba		b1 02		lda ($02),y	                lda (dp),y
.82bc		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.82be		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.82c0		91 02		sta ($02),y	                sta (dp),y
.82c2						z_always_native:
.82c2		60		rts		                rts
.82c3						xt_and:
.82c3		20 81 d7	jsr $d781	                jsr underflow_2
.82c6		b5 00		lda $00,x	                lda 0,x
.82c8		35 02		and $02,x	                and 2,x
.82ca		95 02		sta $02,x	                sta 2,x
.82cc		b5 01		lda $01,x	                lda 1,x
.82ce		35 03		and $03,x	                and 3,x
.82d0		95 03		sta $03,x	                sta 3,x
.82d2		e8		inx		                inx
.82d3		e8		inx		                inx
.82d4		60		rts		z_and:          rts
.82d5						xt_at_xy:
.82d5		20 81 d7	jsr $d781	                jsr underflow_2
.82d8		a5 18		lda $18		                lda base
.82da		48		pha		                pha
.82db		a9 0a		lda #$0a	                lda #10
.82dd		85 18		sta $18		                sta base
.82df		a9 1b		lda #$1b	                lda #AscESC
.82e1		20 7b 8d	jsr $8d7b	                jsr emit_a
.82e4		a9 5b		lda #$5b	                lda #'['
.82e6		20 7b 8d	jsr $8d7b	                jsr emit_a
.82e9		20 40 97	jsr $9740	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82ec		20 e9 d7	jsr $d7e9	                jsr print_u
.82ef		a9 3b		lda #$3b	                lda #';'
.82f1		20 7b 8d	jsr $8d7b	                jsr emit_a
.82f4		20 40 97	jsr $9740	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82f7		20 e9 d7	jsr $d7e9	                jsr print_u
.82fa		a9 48		lda #$48	                lda #'H'
.82fc		20 7b 8d	jsr $8d7b	                jsr emit_a
.82ff		68		pla		                pla
.8300		85 18		sta $18		                sta base
.8302		60		rts		z_at_xy:        rts
.8303						xt_backslash:
.8303		a0 04		ldy #$04	                ldy #blk_offset
.8305		b1 08		lda ($08),y	                lda (up),y
.8307		c8		iny		                iny
.8308		11 08		ora ($08),y	                ora (up),y
.830a		f0 19		beq $8325	                beq backslash_not_block
.830c		a5 10		lda $10		                lda toin
.830e		29 3f		and #$3f	                and #$3F
.8310		f0 1b		beq $832d	                beq z_backslash
.8312		c9 01		cmp #$01	                cmp #$1
.8314		f0 17		beq $832d	                beq z_backslash
.8316		a5 10		lda $10		                lda toin
.8318		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.831a		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.831b		69 40		adc #$40	                adc #$40
.831d		85 10		sta $10		                sta toin
.831f		90 0c		bcc $832d	                bcc z_backslash
.8321		e6 11		inc $11		                inc toin+1
.8323		80 08		bra $832d	                bra z_backslash
.8325						backslash_not_block:
.8325		a5 0e		lda $0e		                lda ciblen
.8327		85 10		sta $10		                sta toin
.8329		a5 0f		lda $0f		                lda ciblen+1
.832b		85 11		sta $11		                sta toin+1
.832d		60		rts		z_backslash:    rts
.832e						xt_base:
.832e		ca		dex		                dex
.832f		ca		dex		                dex
.8330		a9 18		lda #$18	                lda #<base
.8332		95 00		sta $00,x	                sta 0,x         ; LSB
.8334		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8336		60		rts		z_base:         rts
.8337						xt_begin:
.8337		20 88 90	jsr $9088	                jsr xt_here
.833a		60		rts		z_begin:        rts
.833b						xt_bell:
.833b		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.833d		20 7b 8d	jsr $8d7b	                jsr emit_a
.8340		60		rts		z_bell:         rts
.8341						xt_bl:
.8341		ca		dex		                dex
.8342		ca		dex		                dex
.8343		a9 20		lda #$20	                lda #AscSP
.8345		95 00		sta $00,x	                sta 0,x
.8347		74 01		stz $01,x	                stz 1,x
.8349		60		rts		z_bl:           rts
.834a						xt_blk:
.834a		a9 04		lda #$04	                lda #blk_offset
.834c		4c 26 d6	jmp $d626	                jmp push_upvar_tos
.834f						z_blk:
.834f						xt_blkbuffer:
.834f		ca		dex		                dex
.8350		ca		dex		                dex
.8351		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.8353		b1 08		lda ($08),y	                lda (up),y
.8355		95 00		sta $00,x	                sta 0,x
.8357		c8		iny		                iny             ; Move along to the next byte
.8358		b1 08		lda ($08),y	                lda (up),y
.835a		95 01		sta $01,x	                sta 1,x
.835c		60		rts		z_blkbuffer:    rts
.835d						xt_block:
.835d		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.835f		b1 08		lda ($08),y	                lda (up),y
.8361		d5 00		cmp $00,x	                cmp 0,x
.8363		d0 0f		bne $8374	                bne _not_in_buffer
.8365		c8		iny		                iny
.8366		b1 08		lda ($08),y	                lda (up),y
.8368		d5 01		cmp $01,x	                cmp 1,x
.836a		d0 08		bne $8374	                bne _not_in_buffer
.836c		a0 30		ldy #$30	                ldy #buffstatus_offset
.836e		b1 08		lda ($08),y	                lda (up),y
.8370		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.8372		d0 30		bne $83a4	                bne _done       ; It's already in the buffer and in use.
.8374						_not_in_buffer:
.8374		a0 30		ldy #$30	                ldy #buffstatus_offset
.8376		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.8378		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.837a		d0 0c		bne $8388	                bne _buffer_available ; Unused or not dirty = available
.837c		20 4f 83	jsr $834f	                jsr xt_blkbuffer
.837f		20 2b 85	jsr $852b	                jsr xt_buffblocknum
.8382		20 fe 8e	jsr $8efe	                jsr xt_fetch
.8385		20 f1 84	jsr $84f1	                jsr xt_block_write
.8388						_buffer_available:
.8388		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.838a		b5 00		lda $00,x	                lda 0,x
.838c		91 08		sta ($08),y	                sta (up),y
.838e		c8		iny		                iny
.838f		b5 01		lda $01,x	                lda 1,x
.8391		91 08		sta ($08),y	                sta (up),y
.8393		20 4f 83	jsr $834f	                jsr xt_blkbuffer
.8396		20 05 a0	jsr $a005	                jsr xt_swap
.8399		20 d9 84	jsr $84d9	                jsr xt_block_read
.839c		a9 01		lda #$01	                lda #1
.839e		a0 30		ldy #$30	                ldy #buffstatus_offset
.83a0		91 08		sta ($08),y	                sta (up),y
.83a2		ca		dex		                dex
.83a3		ca		dex		                dex
.83a4						_done:
.83a4		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.83a6		b1 08		lda ($08),y	                lda (up),y
.83a8		95 00		sta $00,x	                sta 0,x
.83aa		c8		iny		                iny
.83ab		b1 08		lda ($08),y	                lda (up),y
.83ad		95 01		sta $01,x	                sta 1,x
.83af		60		rts		z_block:        rts
.83b0						xt_block_ramdrive_init:
.83b0		20 7c d7	jsr $d77c	                jsr underflow_1
.83b3		4c ce 84	jmp $84ce	                jmp _after_ramdrive_code
.83b6						_ramdrive_code:
>83b6		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>83be		77 61 70 20 64 65 63 69 6d 61 6c
>83c9		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>83d0		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>83d4		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>83dc		20 72 61 6d 64 72 69 76 65
>83e5		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>83ed		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>83fb		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8403		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8413		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8423		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>842b		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>843a		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>8442		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8452		31 30 32 34 20 6d 6f 76 65 20 3b
>845d		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>8465		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>8475		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>8485		20 21
>8487		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>848f		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>849f		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>84af		6f 72 20 21
>84b3		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>84bb		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>84cb		65 20 21
.84ce						_after_ramdrive_code:
.84ce		20 06 9f	jsr $9f06	                jsr sliteral_runtime
>84d1		b6 83 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.84d5		20 eb 8f	jsr $8feb	                jsr xt_evaluate
.84d8						z_block_ramdrive_init:
.84d8		60		rts		                rts
.84d9						xt_block_read:
.84d9		a0 32		ldy #$32	                ldy #blockread_offset
.84db		b1 08		lda ($08),y	                lda (up),y
.84dd		85 25		sta $25		                sta tmp1
.84df		c8		iny		                iny
.84e0		b1 08		lda ($08),y	                lda (up),y
.84e2		85 26		sta $26		                sta tmp1+1
.84e4		6c 25 00	jmp ($0025)	                jmp (tmp1)
.84e7						z_block_read:
.84e7						xt_block_read_vector:
.84e7		a9 32		lda #$32	                lda #blockread_offset
.84e9		4c 26 d6	jmp $d626	                jmp push_upvar_tos
.84ec						z_block_read_vector:
.84ec						xt_block_word_error:
.84ec		a9 0c		lda #$0c	                lda #err_blockwords
.84ee		4c 92 d7	jmp $d792	                jmp error       ; no RTS needed
.84f1						z_block_word_error:
.84f1						xt_block_write:
.84f1		a0 34		ldy #$34	                ldy #blockwrite_offset
.84f3		b1 08		lda ($08),y	                lda (up),y
.84f5		85 25		sta $25		                sta tmp1
.84f7		c8		iny		                iny
.84f8		b1 08		lda ($08),y	                lda (up),y
.84fa		85 26		sta $26		                sta tmp1+1
.84fc		6c 25 00	jmp ($0025)	                jmp (tmp1)
.84ff						z_block_write:
.84ff						xt_block_write_vector:
.84ff		a9 34		lda #$34	                lda #blockwrite_offset
.8501		4c 26 d6	jmp $d626	                jmp push_upvar_tos
.8504						z_block_write_vector:
.8504						xt_bounds:
.8504		20 81 d7	jsr $d781	                jsr underflow_2
.8507		18		clc		                clc
.8508		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.850a		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.850c		75 02		adc $02,x	                adc 2,x
.850e		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8510		94 00		sty $00,x	                sty 0,x
.8512		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.8514		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8516		75 03		adc $03,x	                adc 3,x
.8518		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.851a		94 01		sty $01,x	                sty 1,x
.851c		60		rts		z_bounds:       rts
.851d						xt_bracket_char:
.851d		20 a1 85	jsr $85a1	                jsr xt_char
.8520		20 a8 92	jsr $92a8	                jsr xt_literal
.8523		60		rts		z_bracket_char: rts
.8524						xt_bracket_tick:
.8524		20 5e a0	jsr $a05e	                jsr xt_tick
.8527		20 a8 92	jsr $92a8	                jsr xt_literal
.852a		60		rts		z_bracket_tick: rts
.852b						xt_buffblocknum:
.852b		a9 2e		lda #$2e	                lda #buffblocknum_offset
.852d		4c 26 d6	jmp $d626	                jmp push_upvar_tos
.8530						z_buffblocknum:
.8530						xt_buffer:
.8530		a0 30		ldy #$30	                ldy #buffstatus_offset
.8532		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.8534		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8536		d0 0c		bne $8544	                bne _buffer_available ; Unused or not dirty = available
.8538		20 4f 83	jsr $834f	                jsr xt_blkbuffer
.853b		20 2b 85	jsr $852b	                jsr xt_buffblocknum
.853e		20 fe 8e	jsr $8efe	                jsr xt_fetch
.8541		20 f1 84	jsr $84f1	                jsr xt_block_write
.8544						_buffer_available:
.8544		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.8546		b5 00		lda $00,x	                lda 0,x
.8548		91 08		sta ($08),y	                sta (up),y
.854a		c8		iny		                iny
.854b		b5 01		lda $01,x	                lda 1,x
.854d		91 08		sta ($08),y	                sta (up),y
.854f		a9 01		lda #$01	                lda #1
.8551		a0 30		ldy #$30	                ldy #buffstatus_offset
.8553		91 08		sta ($08),y	                sta (up),y
.8555						_done:
.8555		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.8557		b1 08		lda ($08),y	                lda (up),y
.8559		95 00		sta $00,x	                sta 0,x
.855b		c8		iny		                iny
.855c		b1 08		lda ($08),y	                lda (up),y
.855e		95 01		sta $01,x	                sta 1,x
.8560		60		rts		z_buffer:       rts
.8561						xt_buffer_colon:
.8561		20 db 88	jsr $88db	                jsr xt_create
.8564		20 30 82	jsr $8230	                jsr xt_allot
.8567		60		rts		z_buffer_colon: rts
.8568						xt_buffstatus:
.8568		a9 30		lda #$30	                lda #buffstatus_offset
.856a		4c 26 d6	jmp $d626	                jmp push_upvar_tos
.856d						z_buffstatus:
.856d						xt_bye:
.856d		4c 2b f0	jmp $f02b	                jmp platform_bye
.8570						z_bye:
.8570						xt_c_comma:
.8570		20 7c d7	jsr $d77c	                jsr underflow_1
.8573		b5 00		lda $00,x	                lda 0,x
.8575		20 c9 d5	jsr $d5c9	                jsr cmpl_a
.8578		e8		inx		                inx
.8579		e8		inx		                inx
.857a		60		rts		z_c_comma:      rts
.857b						xt_c_fetch:
.857b		20 7c d7	jsr $d77c	                jsr underflow_1
.857e		a1 00		lda ($00,x)	                lda (0,x)
.8580		95 00		sta $00,x	                sta 0,x
.8582		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8584		60		rts		z_c_fetch:      rts
.8585						xt_c_store:
.8585		20 81 d7	jsr $d781	                jsr underflow_2
.8588		b5 02		lda $02,x	                lda 2,x
.858a		81 00		sta ($00,x)	                sta (0,x)
.858c		e8		inx		                inx
.858d		e8		inx		                inx
.858e		e8		inx		                inx
.858f		e8		inx		                inx
.8590		60		rts		z_c_store:      rts
.8591						xt_cell_plus:
.8591		20 7c d7	jsr $d77c	                jsr underflow_1
.8594		f6 00		inc $00,x	                inc 0,x
.8596		d0 02		bne $859a	                bne +
.8598		f6 01		inc $01,x	                inc 1,x
.859a						+
.859a		f6 00		inc $00,x	                inc 0,x
.859c		d0 02		bne $85a0	                bne _done
.859e		f6 01		inc $01,x	                inc 1,x
.85a0						_done:
.85a0		60		rts		z_cell_plus:    rts
.85a1						xt_char:
.85a1		20 02 98	jsr $9802	                jsr xt_parse_name
.85a4		b5 00		lda $00,x	                lda 0,x
.85a6		15 01		ora $01,x	                ora 1,x
.85a8		d0 05		bne $85af	                bne _not_empty
.85aa		a9 05		lda #$05	                lda #err_noname
.85ac		4c 92 d7	jmp $d792	                jmp error
.85af						_not_empty:
.85af		e8		inx		                inx             ; drop number of characters, leave addr
.85b0		e8		inx		                inx
.85b1		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.85b3		95 00		sta $00,x	                sta 0,x
.85b5		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.85b7		60		rts		z_char:         rts
.85b8						xt_chars:
.85b8		20 7c d7	jsr $d77c	                jsr underflow_1
.85bb		60		rts		z_chars:        rts
.85bc						xt_cleave:
.85bc		20 81 d7	jsr $d781	                jsr underflow_2
.85bf		20 92 94	jsr $9492	                jsr xt_minus_leading    ; -LEADING ( addr u )
.85c2		20 71 91	jsr $9171	                jsr xt_input_to_r       ; save old imput state
.85c5		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.85c7		85 0e		sta $0e		                sta ciblen
.85c9		b5 01		lda $01,x	                lda 1,x
.85cb		85 0f		sta $0f		                sta ciblen+1
.85cd		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.85cf		85 0c		sta $0c		                sta cib
.85d1		b5 03		lda $03,x	                lda 3,x
.85d3		85 0d		sta $0d		                sta cib+1
.85d5		64 10		stz $10		                stz toin        ; >IN pointer is zero
.85d7		64 11		stz $11		                stz toin+1
.85d9		20 02 98	jsr $9802	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.85dc		b5 00		lda $00,x	                lda 0,x
.85de		15 01		ora $01,x	                ora 1,x
.85e0		f0 23		beq $8605	                beq _done
.85e2		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.85e4		38		sec		                sec
.85e5		f5 00		sbc $00,x	                sbc 0,x
.85e7		95 04		sta $04,x	                sta 4,x
.85e9		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.85eb		f5 01		sbc $01,x	                sbc 1,x
.85ed		95 05		sta $05,x	                sta 5,x
.85ef		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.85f1		18		clc		                clc
.85f2		75 00		adc $00,x	                adc 0,x
.85f4		95 06		sta $06,x	                sta 6,x
.85f6		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.85f8		75 01		adc $01,x	                adc 1,x
.85fa		95 07		sta $07,x	                sta 7,x
.85fc		20 a9 a2	jsr $a2a9	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.85ff		20 92 94	jsr $9492	                jsr xt_minus_leading
.8602		20 a9 a2	jsr $a2a9	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.8605						_done:
.8605		20 c4 99	jsr $99c4	                jsr xt_r_to_input
.8608		60		rts		z_cleave:       rts
.8609						xt_cmove:
.8609		20 86 d7	jsr $d786	                jsr underflow_3
.860c		b5 02		lda $02,x	                lda 2,x
.860e		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.8610		b5 03		lda $03,x	                lda 3,x
.8612		85 28		sta $28		                sta tmp2+1
.8614		b5 04		lda $04,x	                lda 4,x
.8616		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.8618		b5 05		lda $05,x	                lda 5,x
.861a		85 26		sta $26		                sta tmp1+1
.861c		a0 00		ldy #$00	                ldy #0
.861e		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.8620		f0 0f		beq $8631	                beq _dopartial
.8622						_page:
.8622		b1 25		lda ($25),y	                lda (tmp1),y
.8624		91 27		sta ($27),y	                sta (tmp2),y
.8626		c8		iny		                iny
.8627		d0 f9		bne $8622	                bne _page
.8629		e6 26		inc $26		                inc tmp1+1
.862b		e6 28		inc $28		                inc tmp2+1
.862d		d6 01		dec $01,x	                dec 1,x
.862f		d0 f1		bne $8622	                bne _page
.8631						_dopartial:
.8631		b5 00		lda $00,x	                lda 0,x         ; length of last page
.8633		f0 09		beq $863e	                beq _done
.8635						_partial:
.8635		b1 25		lda ($25),y	                lda (tmp1),y
.8637		91 27		sta ($27),y	                sta (tmp2),y
.8639		c8		iny		                iny
.863a		d6 00		dec $00,x	                dec 0,x
.863c		d0 f7		bne $8635	                bne _partial
.863e						_done:
.863e		8a		txa		                txa
.863f		18		clc		                clc
.8640		69 06		adc #$06	                adc #6
.8642		aa		tax		                tax
.8643		60		rts		z_cmove:        rts
.8644						xt_cmove_up:
.8644		20 86 d7	jsr $d786	                jsr underflow_3
.8647		b5 02		lda $02,x	                lda 2,x
.8649		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.864b		b5 03		lda $03,x	                lda 3,x
.864d		18		clc		                clc
.864e		75 01		adc $01,x	                adc 1,x
.8650		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.8652		b5 04		lda $04,x	                lda 4,x
.8654		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.8656		b5 05		lda $05,x	                lda 5,x
.8658		18		clc		                clc
.8659		75 01		adc $01,x	                adc 1,x
.865b		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.865d		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.865f		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.8661		f0 0e		beq $8671	                beq _nopartial
.8663						_outerloop:
.8663		88		dey		                dey
.8664		f0 07		beq $866d	                beq _finishpage
.8666						_innerloop:
.8666		b1 25		lda ($25),y	                lda (tmp1),y
.8668		91 27		sta ($27),y	                sta (tmp2),y
.866a		88		dey		                dey
.866b		d0 f9		bne $8666	                bne _innerloop
.866d						_finishpage:
.866d		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.866f		92 27		sta ($27)	                sta (tmp2)
.8671						_nopartial:
.8671		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.8673		c6 28		dec $28		                dec tmp2+1
.8675		d6 01		dec $01,x	                dec 1,x
.8677		d0 ea		bne $8663	                bne _outerloop
.8679						_done:
.8679		8a		txa		                txa
.867a		18		clc		                clc
.867b		69 06		adc #$06	                adc #6
.867d		aa		tax		                tax
.867e		60		rts		z_cmove_up:     rts
.867f						xt_colon:
.867f		a5 1a		lda $1a		                lda state
.8681		05 1b		ora $1b		                ora state+1
.8683		f0 05		beq $868a	                beq +
.8685		a9 07		lda #$07	                lda #err_state
.8687		4c 92 d7	jmp $d792	                jmp error
.868a						+
.868a		c6 1a		dec $1a		                dec state
.868c		c6 1b		dec $1b		                dec state+1
.868e		a9 40		lda #$40	                lda #%01000000
.8690		04 1c		tsb $1c		                tsb status
.8692		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.8695		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8697		48		pha		                pha
.8698		a5 02		lda $02		                lda dp
.869a		48		pha		                pha
.869b		a9 80		lda #$80	                lda #%10000000
.869d		04 1c		tsb $1c		                tsb status
.869f		20 db 88	jsr $88db	                jsr xt_create
.86a2		20 c3 d6	jsr $d6c3	                jsr current_to_dp   ; This might be able to be omitted
.86a5		a5 02		lda $02		                lda dp
.86a7		85 06		sta $06		                sta workword
.86a9		a5 03		lda $03		                lda dp+1
.86ab		85 07		sta $07		                sta workword+1
.86ad		68		pla		                pla
.86ae		85 02		sta $02		                sta dp
.86b0		68		pla		                pla
.86b1		85 03		sta $03		                sta dp+1
.86b3		20 d6 d6	jsr $d6d6	                jsr dp_to_current
.86b6		a5 00		lda $00		                lda cp
.86b8		38		sec		                sec
.86b9		e9 03		sbc #$03	                sbc #3
.86bb		85 00		sta $00		                sta cp
.86bd		b0 02		bcs $86c1	                bcs _done
.86bf		c6 01		dec $01		                dec cp+1
.86c1						_done:
.86c1		60		rts		z_colon:        rts
.86c2						xt_colon_noname:
.86c2		a5 1a		lda $1a		                lda state
.86c4		05 1b		ora $1b		                ora state+1
.86c6		f0 05		beq $86cd	                beq +
.86c8		a9 07		lda #$07	                lda #err_state
.86ca		4c 92 d7	jmp $d792	                jmp error
.86cd						+
.86cd		c6 1a		dec $1a		                dec state
.86cf		c6 1b		dec $1b		                dec state+1
.86d1		a9 40		lda #$40	                lda #%01000000
.86d3		14 1c		trb $1c		                trb status
.86d5		a5 00		lda $00		                lda cp
.86d7		85 06		sta $06		                sta workword
.86d9		a5 01		lda $01		                lda cp+1
.86db		85 07		sta $07		                sta workword+1
.86dd						_done:
.86dd		60		rts		z_colon_noname:        rts
.86de						xt_comma:
.86de		20 7c d7	jsr $d77c	                jsr underflow_1
.86e1		b5 00		lda $00,x	                lda 0,x
.86e3		92 00		sta ($00)	                sta (cp)
.86e5		e6 00		inc $00		                inc cp
.86e7		d0 02		bne $86eb	                bne +
.86e9		e6 01		inc $01		                inc cp+1
.86eb						+
.86eb		b5 01		lda $01,x	                lda 1,x
.86ed		92 00		sta ($00)	                sta (cp)
.86ef		e6 00		inc $00		                inc cp
.86f1		d0 02		bne $86f5	                bne _done
.86f3		e6 01		inc $01		                inc cp+1
.86f5						_done:
.86f5		e8		inx		                inx
.86f6		e8		inx		                inx
.86f7		60		rts		z_comma:        rts
.86f8						xt_compare:
.86f8		20 8b d7	jsr $d78b	                jsr underflow_4
.86fb		b5 02		lda $02,x	                lda 2,x
.86fd		85 27		sta $27		                sta tmp2
.86ff		b5 03		lda $03,x	                lda 3,x
.8701		85 28		sta $28		                sta tmp2+1
.8703		b5 06		lda $06,x	                lda 6,x
.8705		85 25		sta $25		                sta tmp1
.8707		b5 07		lda $07,x	                lda 7,x
.8709		85 26		sta $26		                sta tmp1+1
.870b						_compare_loop:
.870b		b5 04		lda $04,x	                lda 4,x
.870d		15 05		ora $05,x	                ora 5,x
.870f		f0 2c		beq $873d	                beq _str1_done
.8711		b5 00		lda $00,x	                lda 0,x
.8713		15 01		ora $01,x	                ora 1,x
.8715		f0 3a		beq $8751	                beq _greater    ; Str2 empty first
.8717						_check_letter:
.8717		b2 25		lda ($25)	                lda (tmp1)
.8719		d2 27		cmp ($27)	                cmp (tmp2)
.871b		90 26		bcc $8743	                bcc _less
.871d		d0 32		bne $8751	                bne _greater
.871f						_next_letter:
.871f		e6 25		inc $25		                inc tmp1
.8721		d0 02		bne $8725	                bne +
.8723		e6 26		inc $26		                inc tmp1+1
.8725						+
.8725		e6 27		inc $27		                inc tmp2
.8727		d0 02		bne $872b	                bne +
.8729		e6 28		inc $28		                inc tmp2+1
.872b						+
.872b		b5 04		lda $04,x	                lda 4,x
.872d		d0 02		bne $8731	                bne +
.872f		d6 05		dec $05,x	                dec 5,x
.8731						+
.8731		d6 04		dec $04,x	                dec 4,x
.8733		b5 00		lda $00,x	                lda 0,x
.8735		d0 02		bne $8739	                bne +
.8737		d6 01		dec $01,x	                dec 1,x
.8739						+
.8739		d6 00		dec $00,x	                dec 0,x
.873b		80 ce		bra $870b	                bra _compare_loop
.873d						_str1_done:
.873d		b5 00		lda $00,x	                lda 0,x
.873f		15 01		ora $01,x	                ora 1,x
.8741		f0 08		beq $874b	                beq _equal      ; Both out of letters
.8743						_less:
.8743		a9 ff		lda #$ff	                lda #$FF
.8745		95 06		sta $06,x	                sta 6,x
.8747		95 07		sta $07,x	                sta 7,x
.8749		80 0c		bra $8757	                bra _done
.874b						_equal:
.874b		74 06		stz $06,x	                stz 6,x
.874d		74 07		stz $07,x	                stz 7,x
.874f		80 06		bra $8757	                bra _done
.8751						_greater:
.8751		a9 01		lda #$01	                lda #1
.8753		95 06		sta $06,x	                sta 6,x
.8755		74 07		stz $07,x	                stz 7,x
.8757						_done:
.8757		8a		txa		                txa
.8758		18		clc		                clc
.8759		69 06		adc #$06	                adc #6
.875b		aa		tax		                tax
.875c		60		rts		z_compare:      rts
.875d						xt_compile_comma:
.875d		20 7c d7	jsr $d77c	                jsr underflow_1
.8760		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8762		48		pha		                pha
.8763		b5 00		lda $00,x	                lda 0,x
.8765		48		pha		                pha                     ; LSB
.8766		20 87 91	jsr $9187	                jsr xt_int_to_name      ; ( xt -- nt )
.8769		b5 00		lda $00,x	                lda 0,x
.876b		15 01		ora $01,x	                ora 1,x
.876d		d0 03		bne $8772	                bne _check_nt
.876f		4c 6f 88	jmp $886f	                jmp compile_as_jump
.8772						_check_nt:
.8772		b5 00		lda $00,x	                lda 0,x
.8774		85 23		sta $23		                sta tmptos
.8776		b5 01		lda $01,x	                lda 1,x
.8778		85 24		sta $24		                sta tmptos+1
.877a		f6 00		inc $00,x	                inc 0,x
.877c		d0 02		bne $8780	                bne +
.877e		f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.8780						+
.8780		a1 00		lda ($00,x)	                lda (0,x)
.8782		85 29		sta $29		                sta tmp3                ; keep copy of status byte for NN
.8784		29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8786		f0 0d		beq $8795	                beq _compile_check
.8788		a5 23		lda $23		                lda tmptos
.878a		95 00		sta $00,x	                sta 0,x
.878c		a5 24		lda $24		                lda tmptos+1
.878e		95 01		sta $01,x	                sta 1,x
.8790		20 b1 a5	jsr $a5b1	                jsr xt_wordsize         ; ( nt -- u )
.8793		80 28		bra $87bd	                bra _compile_as_code
.8795						_compile_check:
.8795		a5 29		lda $29		                lda tmp3
.8797		29 08		and #$08	                and #NN
.8799		f0 03		beq $879e	                beq _check_size_limit
.879b		4c 6f 88	jmp $886f	                jmp compile_as_jump    ; too far for BRA
.879e						_check_size_limit:
.879e		a5 23		lda $23		                lda tmptos
.87a0		95 00		sta $00,x	                sta 0,x
.87a2		a5 24		lda $24		                lda tmptos+1
.87a4		95 01		sta $01,x	                sta 1,x
.87a6		20 b1 a5	jsr $a5b1	                jsr xt_wordsize         ; ( nt -- u )
.87a9		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.87ab		b5 01		lda $01,x	                lda 1,x
.87ad		d1 08		cmp ($08),y	                cmp (up),y
.87af		90 0c		bcc $87bd	                bcc _compile_as_code    ; user-defined limit MSB
.87b1		d0 07		bne $87ba	                bne _jumpto_compile_as_jump
.87b3		88		dey		                dey
.87b4		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.87b6		d5 00		cmp $00,x	                cmp 0,x
.87b8		10 03		bpl $87bd	                bpl _compile_as_code    ; Allow native compiling for less
.87ba						_jumpto_compile_as_jump:
.87ba		4c 6f 88	jmp $886f	                jmp compile_as_jump    ; too far for BRA
.87bd						_compile_as_code:
.87bd		ca		dex		                dex
.87be		ca		dex		                dex                     ; ( -- u ? )
.87bf		ca		dex		                dex
.87c0		ca		dex		                dex                     ; ( -- u ? ? )
.87c1		b5 04		lda $04,x	                lda 4,x
.87c3		95 00		sta $00,x	                sta 0,x                 ; LSB of u
.87c5		b5 05		lda $05,x	                lda 5,x
.87c7		95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.87c9		68		pla		                pla
.87ca		95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.87cc		68		pla		                pla
.87cd		95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.87cf		a5 00		lda $00		                lda cp                  ; LSB of cp
.87d1		95 02		sta $02,x	                sta 2,x
.87d3		a5 01		lda $01		                lda cp+1
.87d5		95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.87d7		a0 00		ldy #$00	                ldy #0
.87d9						_strip_loop:
.87d9		b9 5d 88	lda $885d,y	                lda strip_table,y      ; LSB of first word
.87dc		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.87de		d0 07		bne $87e7	                bne _next_entry
.87e0		b9 5e 88	lda $885e,y	                lda strip_table+1,y
.87e3		d5 05		cmp $05,x	                cmp 5,x
.87e5		f0 0c		beq $87f3	                beq _found_entry
.87e7						_next_entry:
.87e7		b9 5d 88	lda $885d,y	                lda strip_table,y      ; pointing to LSB
.87ea		19 5e 88	ora $885e,y	                ora strip_table+1,y    ; get MSB
.87ed		f0 22		beq $8811	                beq _underflow_strip    ; table done, let's get out of here
.87ef		c8		iny		                iny
.87f0		c8		iny		                iny
.87f1		80 e6		bra $87d9	                bra _strip_loop
.87f3						_found_entry:
.87f3		98		tya		                tya
.87f4		4a		lsr a		                lsr
.87f5		a8		tay		                tay
.87f6		b9 69 88	lda $8869,y	                lda strip_size,y
.87f9		85 23		sta $23		                sta tmptos              ; save a copy
.87fb		18		clc		                clc
.87fc		75 04		adc $04,x	                adc 4,x
.87fe		95 04		sta $04,x	                sta 4,x
.8800		90 02		bcc $8804	                bcc+
.8802		f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8804						+
.8804		06 23		asl $23		                asl tmptos
.8806		38		sec		                sec
.8807		b5 00		lda $00,x	                lda 0,x
.8809		e5 23		sbc $23		                sbc tmptos
.880b		95 00		sta $00,x	                sta 0,x
.880d		b0 02		bcs $8811	                bcs +
.880f		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8811						+
.8811						_underflow_strip:
.8811		a0 02		ldy #$02	                ldy #uf_strip_offset
.8813		b1 08		lda ($08),y	                lda (up),y
.8815		c8		iny		                iny
.8816		11 08		ora ($08),y	                ora (up),y
.8818		f0 1c		beq $8836	                beq cmpl_inline
.881a		a5 29		lda $29		                lda tmp3
.881c		29 10		and #$10	                and #UF
.881e		f0 16		beq $8836	                beq cmpl_inline
.8820		18		clc		                clc
.8821		b5 04		lda $04,x	                lda 4,x
.8823		69 03		adc #$03	                adc #3
.8825		95 04		sta $04,x	                sta 4,x
.8827		90 02		bcc $882b	                bcc +
.8829		f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.882b						+
.882b		38		sec		                sec
.882c		b5 00		lda $00,x	                lda 0,x
.882e		e9 03		sbc #$03	                sbc #3
.8830		95 00		sta $00,x	                sta 0,x
.8832		b0 02		bcs $8836	                bcs +
.8834		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.8836						+
.8836						cmpl_inline:
.8836		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8838		48		pha		                pha
.8839		b5 00		lda $00,x	                lda 0,x                 ; LSB
.883b		48		pha		                pha
.883c		20 f1 94	jsr $94f1	                jsr xt_move
.883f		18		clc		                clc
.8840		68		pla		                pla                     ; LSB
.8841		65 00		adc $00		                adc cp
.8843		85 00		sta $00		                sta cp
.8845		68		pla		                pla                     ; MSB
.8846		65 01		adc $01		                adc cp+1
.8848		85 01		sta $01		                sta cp+1
.884a		60		rts		                rts
.884b						cmpl_inline_y:
.884b		ca		dex		                dex             ; set up stack as ( src dst n -- )
.884c		ca		dex		                dex
.884d		ca		dex		                dex
.884e		ca		dex		                dex
.884f		94 00		sty $00,x	                sty 0,x
.8851		74 01		stz $01,x	                stz 1,x             ; assume < 256 bytes
.8853		a5 00		lda $00		                lda cp
.8855		95 02		sta $02,x	                sta 2,x
.8857		a5 01		lda $01		                lda cp+1
.8859		95 03		sta $03,x	                sta 3,x
.885b		80 d9		bra $8836	                bra cmpl_inline
.885d						strip_table:
>885d		b3 99 9e 99 9b a1		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>8863		cd a2 53 a2 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.8869						strip_size:
>8869		04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.886f						compile_as_jump:
.886f		68		pla		                pla             ; LSB
.8870		7a		ply		                ply             ; MSB
.8871		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.8874		e8		inx		                inx             ; drop xt
.8875		e8		inx		                inx
.8876						z_compile_comma:
.8876		60		rts		                rts
.8877						xt_compile_only:
.8877		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.887a		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.887c		b1 02		lda ($02),y	                lda (dp),y
.887e		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.8880		91 02		sta ($02),y	                sta (dp),y
.8882		60		rts		z_compile_only: rts
.8883						xt_value:
.8883						xt_constant:
.8883		20 7c d7	jsr $d77c	                jsr underflow_1
.8886		20 db 88	jsr $88db	                jsr xt_create
.8889		38		sec		                sec
.888a		a5 00		lda $00		                lda cp
.888c		e9 02		sbc #$02	                sbc #2
.888e		85 25		sta $25		                sta tmp1
.8890		a5 01		lda $01		                lda cp+1
.8892		e9 00		sbc #$00	                sbc #0
.8894		85 26		sta $26		                sta tmp1+1
.8896		a9 d2		lda #$d2	                lda #<doconst           ; LSB of DOCONST
.8898		92 25		sta ($25)	                sta (tmp1)
.889a		a0 01		ldy #$01	                ldy #1
.889c		a9 d5		lda #$d5	                lda #>doconst           ; MSB of DOCONST
.889e		91 25		sta ($25),y	                sta (tmp1),y
.88a0		20 de 86	jsr $86de	                jsr xt_comma            ; drop through to adjust_z
.88a3						adjust_z:
.88a3		20 48 92	jsr $9248	                jsr xt_latestnt         ; gives us ( -- nt )
.88a6		b5 00		lda $00,x	                lda 0,x
.88a8		85 25		sta $25		                sta tmp1
.88aa		b5 01		lda $01,x	                lda 1,x
.88ac		85 26		sta $26		                sta tmp1+1
.88ae		a0 06		ldy #$06	                ldy #6
.88b0		b1 25		lda ($25),y	                lda (tmp1),y
.88b2		18		clc		                clc
.88b3		69 02		adc #$02	                adc #2
.88b5		91 25		sta ($25),y	                sta (tmp1),y
.88b7		c8		iny		                iny
.88b8		b1 25		lda ($25),y	                lda (tmp1),y
.88ba		69 00		adc #$00	                adc #0                  ; only need carry
.88bc		91 25		sta ($25),y	                sta (tmp1),y
.88be		e8		inx		                inx
.88bf		e8		inx		                inx
.88c0						z_value:
.88c0		60		rts		z_constant:     rts
.88c1						xt_count:
.88c1		20 7c d7	jsr $d77c	                jsr underflow_1
.88c4		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.88c6		a8		tay		                tay
.88c7		f6 00		inc $00,x	                inc 0,x         ; LSB
.88c9		d0 02		bne $88cd	                bne +
.88cb		f6 01		inc $01,x	                inc 1,x         ; MSB
.88cd		98		tya		+               tya
.88ce		ca		dex		                dex
.88cf		ca		dex		                dex
.88d0		95 00		sta $00,x	                sta 0,x         ; LSB
.88d2		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.88d4		60		rts		z_count:        rts
.88d5						xt_cr:
.88d5		a9 0a		lda #$0a	                lda #AscLF
.88d7		20 7b 8d	jsr $8d7b	                jsr emit_a
.88da		60		rts		z_cr:           rts
.88db						xt_create:
.88db		20 02 98	jsr $9802	                jsr xt_parse_name       ; ( addr u )
.88de		b5 00		lda $00,x	                lda 0,x
.88e0		15 01		ora $01,x	                ora 1,x
.88e2		d0 05		bne $88e9	                bne _got_name
.88e4		a9 05		lda #$05	                lda #err_noname
.88e6		4c 92 d7	jmp $d792	                jmp error
.88e9						_got_name:
.88e9		74 01		stz $01,x	                stz 1,x
.88eb		20 e3 a1	jsr $a1e3	                jsr xt_two_dup          ; ( addr u addr u )
.88ee		20 59 8f	jsr $8f59	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.88f1		b5 00		lda $00,x	                lda 0,x
.88f3		15 01		ora $01,x	                ora 1,x
.88f5		f0 1e		beq $8915	                beq _new_name           ; We haven't seen this one before.
.88f7		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.88f8		e8		inx		                inx
.88f9		24 1c		bit $1c		                bit status
.88fb		10 08		bpl $8905	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.88fd		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.88ff		05 1c		ora $1c		                ora status
.8901		85 1c		sta $1c		                sta status
.8903		80 18		bra $891d	                bra _process_name
.8905						_redefined_name:
.8905		a9 02		lda #$02	                lda #str_redefined
.8907		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.890a		20 e3 a1	jsr $a1e3	                jsr xt_two_dup           ; ( addr u addr u )
.890d		20 2e a3	jsr $a32e	                jsr xt_type
.8910		20 7b 9f	jsr $9f7b	                jsr xt_space
.8913		80 08		bra $891d	                bra _process_name
.8915						_new_name:
.8915		e8		inx		                inx                     ; Drop flag (0) from find-name.
.8916		e8		inx		                inx
.8917		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.8919		25 1c		and $1c		                and status
.891b		85 1c		sta $1c		                sta status
.891d						_process_name:
.891d		b5 00		lda $00,x	                lda 0,x
.891f		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8921		a5 00		lda $00		                lda cp
.8923		85 25		sta $25		                sta tmp1
.8925		a5 01		lda $01		                lda cp+1
.8927		85 26		sta $26		                sta tmp1+1
.8929		b5 00		lda $00,x	                lda 0,x
.892b		18		clc		                clc
.892c		69 08		adc #$08	                adc #8
.892e		85 29		sta $29		                sta tmp3                ; total header length
.8930		18		clc		                clc
.8931		69 03		adc #$03	                adc #3
.8933		95 00		sta $00,x	                sta 0,x
.8935		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.8937		20 30 82	jsr $8230	                jsr xt_allot    ; ( addr )
.893a		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.893d		a0 00		ldy #$00	                ldy #0
.893f		a5 27		lda $27		                lda tmp2
.8941		91 25		sta ($25),y	                sta (tmp1),y
.8943		a9 08		lda #$08	                lda #NN
.8945		09 20		ora #$20	                ora #HC
.8947		c8		iny		                iny
.8948		91 25		sta ($25),y	                sta (tmp1),y
.894a		c8		iny		                iny
.894b		a5 02		lda $02		                lda dp
.894d		91 25		sta ($25),y	                sta (tmp1),y
.894f		c8		iny		                iny
.8950		a5 03		lda $03		                lda dp+1
.8952		91 25		sta ($25),y	                sta (tmp1),y
.8954		c8		iny		                iny
.8955		a5 26		lda $26		                lda tmp1+1
.8957		85 03		sta $03		                sta dp+1
.8959		a5 25		lda $25		                lda tmp1
.895b		85 02		sta $02		                sta dp
.895d		18		clc		                clc
.895e		65 29		adc $29		                adc tmp3        ; add total header length
.8960		91 25		sta ($25),y	                sta (tmp1),y
.8962		48		pha		                pha             ; we need this in the next step
.8963		c8		iny		                iny
.8964		a5 26		lda $26		                lda tmp1+1
.8966		69 00		adc #$00	                adc #0          ; only need the carry
.8968		91 25		sta ($25),y	                sta (tmp1),y
.896a		c8		iny		                iny
.896b		68		pla		                pla             ; LSB of "z_" address
.896c		18		clc		                clc
.896d		69 03		adc #$03	                adc #3
.896f		91 25		sta ($25),y	                sta (tmp1),y
.8971		88		dey		                dey             ; get the MSB of xt back
.8972		b1 25		lda ($25),y	                lda (tmp1),y
.8974		69 00		adc #$00	                adc #0          ; only need the carry
.8976		c8		iny		                iny
.8977		c8		iny		                iny
.8978		91 25		sta ($25),y	                sta (tmp1),y
.897a		c8		iny		                iny
.897b		b5 00		lda $00,x	                lda 0,x
.897d		38		sec		                sec
.897e		e9 08		sbc #$08	                sbc #8
.8980		85 23		sta $23		                sta tmptos
.8982		b5 01		lda $01,x	                lda 1,x
.8984		e9 00		sbc #$00	                sbc #0          ; only need carry
.8986		85 24		sta $24		                sta tmptos+1
.8988						_name_loop:
.8988		b1 23		lda ($23),y	                lda (tmptos),y
.898a		c9 5b		cmp #$5b	                cmp #'Z'+1
.898c		b0 06		bcs $8994	                bcs _store_name
.898e		c9 41		cmp #$41	                cmp #'A'
.8990		90 02		bcc $8994	                bcc _store_name
.8992		09 20		ora #$20	                ora #$20
.8994						_store_name:
.8994		91 25		sta ($25),y	                sta (tmp1),y
.8996		c8		iny		                iny
.8997		c6 27		dec $27		                dec tmp2
.8999		d0 ed		bne $8988	                bne _name_loop
.899b		a9 20		lda #$20	                lda #OpJSR
.899d		91 25		sta ($25),y	                sta (tmp1),y
.899f		c8		iny		                iny
.89a0		a9 18		lda #$18	                lda #<dovar
.89a2		91 25		sta ($25),y	                sta (tmp1),y
.89a4		c8		iny		                iny
.89a5		a9 d6		lda #$d6	                lda #>dovar
.89a7		91 25		sta ($25),y	                sta (tmp1),y
.89a9		20 d6 d6	jsr $d6d6	                jsr dp_to_current
.89ac		e8		inx		                inx
.89ad		e8		inx		                inx
.89ae		60		rts		z_create:       rts
.89af						xt_d_minus:
.89af		20 8b d7	jsr $d78b	                jsr underflow_4 ; two double numbers
.89b2		38		sec		                sec
.89b3		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.89b5		f5 02		sbc $02,x	                sbc 2,x
.89b7		95 06		sta $06,x	                sta 6,x
.89b9		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.89bb		f5 03		sbc $03,x	                sbc 3,x
.89bd		95 07		sta $07,x	                sta 7,x
.89bf		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.89c1		f5 00		sbc $00,x	                sbc 0,x
.89c3		95 04		sta $04,x	                sta 4,x
.89c5		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.89c7		f5 01		sbc $01,x	                sbc 1,x
.89c9		95 05		sta $05,x	                sta 5,x
.89cb		e8		inx		                inx
.89cc		e8		inx		                inx
.89cd		e8		inx		                inx
.89ce		e8		inx		                inx
.89cf		60		rts		z_d_minus:      rts
.89d0						xt_d_plus:
.89d0		20 8b d7	jsr $d78b	                jsr underflow_4 ; two double numbers
.89d3		18		clc		                clc
.89d4		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.89d6		75 06		adc $06,x	                adc 6,x
.89d8		95 06		sta $06,x	                sta 6,x
.89da		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.89dc		75 07		adc $07,x	                adc 7,x
.89de		95 07		sta $07,x	                sta 7,x
.89e0		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.89e2		75 04		adc $04,x	                adc 4,x
.89e4		95 04		sta $04,x	                sta 4,x
.89e6		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.89e8		75 05		adc $05,x	                adc 5,x
.89ea		95 05		sta $05,x	                sta 5,x
.89ec		e8		inx		                inx
.89ed		e8		inx		                inx
.89ee		e8		inx		                inx
.89ef		e8		inx		                inx
.89f0		60		rts		z_d_plus:       rts
.89f1						xt_d_to_s:
.89f1		20 81 d7	jsr $d781	                jsr underflow_2
.89f4		e8		inx		                inx
.89f5		e8		inx		                inx
.89f6		60		rts		z_d_to_s:       rts
.89f7						xt_dabs:
.89f7		20 81 d7	jsr $d781	                jsr underflow_2 ; double number
.89fa		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.89fc		10 17		bpl $8a15	                bpl _done       ; positive, we get off light
.89fe		a0 00		ldy #$00	                ldy #0
.8a00		38		sec		                sec
.8a01		98		tya		                tya
.8a02		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a04		95 02		sta $02,x	                sta 2,x
.8a06		98		tya		                tya
.8a07		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a09		95 03		sta $03,x	                sta 3,x
.8a0b		98		tya		                tya
.8a0c		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a0e		95 00		sta $00,x	                sta 0,x
.8a10		98		tya		                tya
.8a11		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a13		95 01		sta $01,x	                sta 1,x
.8a15						_done:
.8a15		60		rts		z_dabs:         rts
.8a16						xt_decimal:
.8a16		a9 0a		lda #$0a	                lda #10
.8a18		85 18		sta $18		                sta base
.8a1a		64 19		stz $19		                stz base+1              ; paranoid
.8a1c		60		rts		z_decimal:      rts
.8a1d						xt_defer:
.8a1d		20 db 88	jsr $88db	                jsr xt_create
.8a20		a5 00		lda $00		                lda cp          ; LSB
.8a22		38		sec		                sec
.8a23		e9 02		sbc #$02	                sbc #2
.8a25		85 25		sta $25		                sta tmp1
.8a27		a5 01		lda $01		                lda cp+1        ; MSB
.8a29		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8a2b		85 26		sta $26		                sta tmp1+1
.8a2d		a0 00		ldy #$00	                ldy #0
.8a2f		a9 e6		lda #$e6	                lda #<dodefer   ; LSB
.8a31		91 25		sta ($25),y	                sta (tmp1),y
.8a33		c8		iny		                iny
.8a34		a9 d5		lda #$d5	                lda #>dodefer   ; MSB
.8a36		91 25		sta ($25),y	                sta (tmp1),y
.8a38		a9 fa		lda #$fa	                lda #<defer_error
.8a3a		92 00		sta ($00)	                sta (cp)
.8a3c		e6 00		inc $00		                inc cp
.8a3e		d0 02		bne $8a42	                bne +
.8a40		e6 01		inc $01		                inc cp+1
.8a42						+
.8a42		a9 d5		lda #$d5	                lda #>defer_error
.8a44		92 00		sta ($00)	                sta (cp)
.8a46		e6 00		inc $00		                inc cp
.8a48		d0 02		bne $8a4c	                bne +
.8a4a		e6 01		inc $01		                inc cp+1
.8a4c						+
.8a4c		20 a3 88	jsr $88a3	                jsr adjust_z    ; adjust header to correct length
.8a4f		60		rts		z_defer:        rts
.8a50						xt_defer_fetch:
.8a50		20 ba a0	jsr $a0ba	                jsr xt_to_body
.8a53		20 fe 8e	jsr $8efe	                jsr xt_fetch
.8a56		60		rts		z_defer_fetch:  rts
.8a57						xt_defer_store:
.8a57		20 ba a0	jsr $a0ba	                jsr xt_to_body
.8a5a		20 ea 9f	jsr $9fea	                jsr xt_store
.8a5d		60		rts		z_defer_store:  rts
.8a5e						xt_definitions:
.8a5e		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.8a60		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8a62		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.8a64		91 08		sta ($08),y	                sta (up),y
.8a66		60		rts		z_definitions:  rts
.8a67						xt_depth:
.8a67		a9 78		lda #$78	                lda #dsp0
.8a69		86 1e		stx $1e		                stx tmpdsp
.8a6b		38		sec		                sec
.8a6c		e5 1e		sbc $1e		                sbc tmpdsp
.8a6e		4a		lsr a		                lsr
.8a6f		ca		dex		                dex
.8a70		ca		dex		                dex
.8a71		95 00		sta $00,x	                sta 0,x
.8a73		74 01		stz $01,x	                stz 1,x
.8a75		60		rts		z_depth:        rts
.8a76						xt_digit_question:
.8a76		20 7c d7	jsr $d77c	                jsr underflow_1
.8a79		ca		dex		                dex
.8a7a		ca		dex		                dex
.8a7b		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8a7d		74 01		stz $01,x	                stz 1,x
.8a7f		74 03		stz $03,x	                stz 3,x                 ; paranoid
.8a81		b5 02		lda $02,x	                lda 2,x
.8a83		c9 30		cmp #$30	                cmp #'0'
.8a85		90 23		bcc $8aaa	                bcc _done               ; failure flag already set
.8a87		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8a89		90 12		bcc $8a9d	                bcc _checkbase
.8a8b		c9 41		cmp #$41	                cmp #'A'
.8a8d		90 1b		bcc $8aaa	                bcc _done               ; failure flag is already set
.8a8f		c9 61		cmp #$61	                cmp #'a'
.8a91		90 07		bcc $8a9a	                bcc _case_done          ; not lower case, too low
.8a93		c9 7b		cmp #$7b	                cmp #'z'+1
.8a95		b0 03		bcs $8a9a	                bcs _case_done          ; not lower case, too high
.8a97		18		clc		                clc                     ; just right
.8a98		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.8a9a						_case_done:
.8a9a		38		sec		                sec
.8a9b		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8a9d						_checkbase:
.8a9d		38		sec		                sec
.8a9e		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8aa0		c5 18		cmp $18		                cmp base
.8aa2		b0 06		bcs $8aaa	                bcs _done               ; already have false flag
.8aa4		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8aa6		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8aa8		d6 01		dec $01,x	                dec 1,x
.8aaa						_done:
.8aaa						z_digit_question:
.8aaa		60		rts		                rts
.8aab						xt_disasm:
.8aab		20 81 d7	jsr $d781	                jsr underflow_2
.8aae		20 61 ab	jsr $ab61	                jsr disassembler
.8ab1		60		rts		z_disasm:       rts
.8ab2						xt_dnegate:
.8ab2		20 81 d7	jsr $d781	                jsr underflow_2 ; double number
.8ab5		a0 00		ldy #$00	     		ldy #0
.8ab7		38		sec		                sec
.8ab8		98		tya		                tya
.8ab9		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8abb		95 02		sta $02,x	                sta 2,x
.8abd		98		tya		                tya
.8abe		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8ac0		95 03		sta $03,x	                sta 3,x
.8ac2		98		tya		                tya
.8ac3		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8ac5		95 00		sta $00,x	                sta 0,x
.8ac7		98		tya		                tya
.8ac8		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8aca		95 01		sta $01,x	                sta 1,x
.8acc		60		rts		z_dnegate:      rts
.8acd						xt_question_do:
.8acd		a0 01		ldy #$01	                ldy #1                  ; 1 is ?DO, jump to common code
.8acf		80 02		bra $8ad3	                bra do_common           ; skip flag for DO
.8ad1						xt_do:
.8ad1		a0 00		ldy #$00	                ldy #0                ; 0 is DO, drop through to DO_COMMON
.8ad3						do_common:
.8ad3		f0 18		beq $8aed	                beq _compile_do
.8ad5		ca		dex		                dex
.8ad6		ca		dex		                dex
.8ad7		a9 0a		lda #$0a	                lda #<question_do_runtime
.8ad9		95 00		sta $00,x	                sta 0,x
.8adb		a9 8b		lda #$8b	                lda #>question_do_runtime
.8add		95 01		sta $01,x	                sta 1,x
.8adf		a0 10		ldy #$10	                ldy #question_do_runtime_end-question_do_runtime
.8ae1		20 4b 88	jsr $884b	                jsr cmpl_inline_y
.8ae4		a5 00		lda $00		                lda cp
.8ae6		a4 01		ldy $01		                ldy cp+1
.8ae8		48		pha		                pha
.8ae9		20 c5 d5	jsr $d5c5	                jsr cmpl_word      ; write two arbitrary placeholder bytes
.8aec		68		pla		                pla
.8aed						_compile_do:
.8aed		ca		dex		                dex
.8aee		ca		dex		                dex
.8aef		95 00		sta $00,x	                sta 0,x
.8af1		98		tya		                tya
.8af2		95 01		sta $01,x	                sta 1,x
.8af4		ca		dex		                dex
.8af5		ca		dex		                dex
.8af6		a5 21		lda $21		                lda loopleave
.8af8		95 00		sta $00,x	                sta 0,x
.8afa		a5 22		lda $22		                lda loopleave+1
.8afc		95 01		sta $01,x	                sta 1,x
.8afe		64 22		stz $22		                stz loopleave+1
.8b00		a0 8b		ldy #$8b	                ldy #>do_runtime
.8b02		a9 1a		lda #$1a	                lda #<do_runtime
.8b04		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.8b07		4c 88 90	jmp $9088	                jmp xt_here
.8b0a						z_question_do:
.8b0a						z_do:
.8b0a						question_do_runtime:
.8b0a		20 e3 a1	jsr $a1e3	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8b0d		20 53 8e	jsr $8e53	                jsr xt_equal            ; ( -- n1 n2 f )
.8b10		20 25 91	jsr $9125	                jsr zero_test_runtime   ; consume f, setting Z
.8b13		f0 07		beq $8b1c	                beq question_do_runtime_end+2
.8b15		e8		inx		                inx                     ; drop loop limits
.8b16		e8		inx		                inx
.8b17		e8		inx		                inx
.8b18		e8		inx		                inx
>8b19		4c				                .byte OpJMP             ; jmp
.8b1a						question_do_runtime_end:
.8b1a						do_runtime:
.8b1a		a4 1f		ldy $1f		                ldy loopctrl
.8b1c		30 05		bmi $8b23	                bmi +                   ; is this the first LCB?
.8b1e		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.8b20		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.8b23						+
.8b23		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.8b24		c8		iny		                iny
.8b25		c8		iny		                iny
.8b26		c8		iny		                iny
.8b27		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.8b29		38		sec		                sec
.8b2a		a9 00		lda #$00	                lda #0
.8b2c		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.8b2e		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.8b31		a9 80		lda #$80	                lda #$80
.8b33		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.8b35		99 03 01	sta $0103,y	                sta loopfufa+1,y
.8b38		18		clc		                clc
.8b39		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.8b3b		79 02 01	adc $0102,y	                adc loopfufa,y
.8b3e		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.8b40		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.8b42		79 03 01	adc $0103,y	                adc loopfufa+1,y
.8b45		99 01 01	sta $0101,y	                sta loopindex+1,y
.8b48		e8		inx		                inx                 ; clean up the stack
.8b49		e8		inx		                inx
.8b4a		e8		inx		                inx
.8b4b		e8		inx		                inx
.8b4c		60		rts		                rts
.8b4d						xt_does:
.8b4d		a0 8b		ldy #$8b	                ldy #>does_runtime
.8b4f		a9 5c		lda #$5c	                lda #<does_runtime
.8b51		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.8b54		a0 d5		ldy #$d5	                ldy #>dodoes
.8b56		a9 ff		lda #$ff	                lda #<dodoes
.8b58		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.8b5b		60		rts		z_does:         rts
.8b5c						does_runtime:
.8b5c		7a		ply		                ply             ; LSB
.8b5d		68		pla		                pla             ; MSB
.8b5e		c8		iny		                iny
.8b5f		d0 01		bne $8b62	                bne +
.8b61		1a		inc a		                ina
.8b62						+
.8b62		84 25		sty $25		                sty tmp1
.8b64		85 26		sta $26		                sta tmp1+1
.8b66		20 c3 d6	jsr $d6c3	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8b69		a5 02		lda $02		                lda dp
.8b6b		18		clc		                clc
.8b6c		69 04		adc #$04	                adc #4
.8b6e		85 27		sta $27		                sta tmp2
.8b70		a5 03		lda $03		                lda dp+1
.8b72		69 00		adc #$00	                adc #0          ; we only care about the carry
.8b74		85 28		sta $28		                sta tmp2+1
.8b76		b2 27		lda ($27)	                lda (tmp2)
.8b78		18		clc		                clc
.8b79		69 01		adc #$01	                adc #1
.8b7b		85 29		sta $29		                sta tmp3
.8b7d		a0 01		ldy #$01	                ldy #1
.8b7f		b1 27		lda ($27),y	                lda (tmp2),y
.8b81		69 00		adc #$00	                adc #0          ; we only care about the carry
.8b83		85 2a		sta $2a		                sta tmp3+1
.8b85		a5 25		lda $25		                lda tmp1        ; LSB
.8b87		92 29		sta ($29)	                sta (tmp3)
.8b89		a5 26		lda $26		                lda tmp1+1
.8b8b		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.8b8d		60		rts		                rts
.8b8e						xt_dot:
.8b8e		20 7c d7	jsr $d77c	                jsr underflow_1
.8b91		20 07 8d	jsr $8d07	                jsr xt_dup                      ; ( n n )
.8b94		20 d1 80	jsr $80d1	                jsr xt_abs                      ; ( n u )
.8b97		20 e4 a5	jsr $a5e4	                jsr xt_zero                     ; ( n u 0 )
.8b9a		20 78 92	jsr $9278	                jsr xt_less_number_sign         ; ( n u 0 )
.8b9d		20 01 97	jsr $9701	                jsr xt_number_sign_s            ; ( n ud )
.8ba0		20 71 9a	jsr $9a71	                jsr xt_rot                      ; ( ud n )
.8ba3		20 4c 9e	jsr $9e4c	                jsr xt_sign                     ; ( ud )
.8ba6		20 df 96	jsr $96df	                jsr xt_number_sign_greater      ; ( addr u )
.8ba9		20 2e a3	jsr $a32e	                jsr xt_type
.8bac		20 7b 9f	jsr $9f7b	                jsr xt_space
.8baf		60		rts		z_dot:          rts
.8bb0						xt_dot_paren:
.8bb0		ca		dex		                dex
.8bb1		ca		dex		                dex
.8bb2		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8bb4		95 00		sta $00,x	                sta 0,x
.8bb6		74 01		stz $01,x	                stz 1,x
.8bb8		20 5d 98	jsr $985d	                jsr xt_parse
.8bbb		20 2e a3	jsr $a32e	                jsr xt_type
.8bbe		60		rts		z_dot_paren:    rts
.8bbf						xt_dot_quote:
.8bbf		20 fc 9b	jsr $9bfc	                jsr xt_s_quote
.8bc2		a0 a3		ldy #$a3	                ldy #>xt_type
.8bc4		a9 2e		lda #$2e	                lda #<xt_type
.8bc6		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.8bc9		60		rts		z_dot_quote:    rts
.8bca						xt_dot_r:
.8bca		20 81 d7	jsr $d781	                jsr underflow_2
.8bcd		20 9b a1	jsr $a19b	                jsr xt_to_r
.8bd0		20 07 8d	jsr $8d07	                jsr xt_dup
.8bd3		20 d1 80	jsr $80d1	                jsr xt_abs
.8bd6		20 e4 a5	jsr $a5e4	                jsr xt_zero
.8bd9		20 78 92	jsr $9278	                jsr xt_less_number_sign
.8bdc		20 01 97	jsr $9701	                jsr xt_number_sign_s
.8bdf		20 71 9a	jsr $9a71	                jsr xt_rot
.8be2		20 4c 9e	jsr $9e4c	                jsr xt_sign
.8be5		20 df 96	jsr $96df	                jsr xt_number_sign_greater
.8be8		20 b3 99	jsr $99b3	                jsr xt_r_from
.8beb		20 b6 97	jsr $97b6	                jsr xt_over
.8bee		20 7f 94	jsr $947f	                jsr xt_minus
.8bf1		20 81 9f	jsr $9f81	                jsr xt_spaces
.8bf4		20 2e a3	jsr $a32e	                jsr xt_type
.8bf7		60		rts		z_dot_r:        rts
.8bf8						xt_dot_s:
.8bf8		20 67 8a	jsr $8a67	                jsr xt_depth    ; ( -- u )
.8bfb		a9 3c		lda #$3c	                lda #'<'
.8bfd		20 7b 8d	jsr $8d7b	                jsr emit_a
.8c00		b5 00		lda $00,x	                lda 0,x
.8c02		48		pha		                pha
.8c03		ca		dex		                dex             ; DUP
.8c04		ca		dex		                dex
.8c05		95 00		sta $00,x	                sta 0,x
.8c07		74 01		stz $01,x	                stz 1,x
.8c09		20 e9 d7	jsr $d7e9	                jsr print_u
.8c0c		a9 3e		lda #$3e	                lda #'>'
.8c0e		20 7b 8d	jsr $8d7b	                jsr emit_a
.8c11		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8c13		20 7b 8d	jsr $8d7b	                jsr emit_a
.8c16		e8		inx		                inx
.8c17		e8		inx		                inx
.8c18		e0 78		cpx #$78	                cpx #dsp0
.8c1a		f0 1e		beq $8c3a	                beq _done
.8c1c						_have_stack:
.8c1c		7a		ply		                ply
.8c1d		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8c1f		85 29		sta $29		                sta tmp3
.8c21		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.8c23						_loop:
.8c23		ca		dex		                dex
.8c24		ca		dex		                dex
.8c25		b2 29		lda ($29)	                lda (tmp3)
.8c27		95 01		sta $01,x	                sta 1,x
.8c29		c6 29		dec $29		                dec tmp3
.8c2b		b2 29		lda ($29)	                lda (tmp3)
.8c2d		95 00		sta $00,x	                sta 0,x
.8c2f		c6 29		dec $29		                dec tmp3
.8c31		5a		phy		                phy
.8c32		20 8e 8b	jsr $8b8e	                jsr xt_dot
.8c35		7a		ply		                ply
.8c36		88		dey		                dey
.8c37		d0 ea		bne $8c23	                bne _loop
.8c39		48		pha		                pha             ; dummy to balance stack
.8c3a						_done:
.8c3a		68		pla		                pla
.8c3b		60		rts		z_dot_s:        rts
.8c3c						xt_d_dot:
.8c3c		20 81 d7	jsr $d781	                jsr underflow_2
.8c3f		20 b8 a1	jsr $a1b8	                jsr xt_tuck
.8c42		20 f7 89	jsr $89f7	                jsr xt_dabs
.8c45		20 78 92	jsr $9278	                jsr xt_less_number_sign
.8c48		20 01 97	jsr $9701	                jsr xt_number_sign_s
.8c4b		20 71 9a	jsr $9a71	                jsr xt_rot
.8c4e		20 4c 9e	jsr $9e4c	                jsr xt_sign
.8c51		20 df 96	jsr $96df	                jsr xt_number_sign_greater
.8c54		20 2e a3	jsr $a32e	                jsr xt_type
.8c57		20 7b 9f	jsr $9f7b	                jsr xt_space
.8c5a		60		rts		z_d_dot:        rts
.8c5b						xt_d_dot_r:
.8c5b		20 86 d7	jsr $d786	                jsr underflow_3
.8c5e		20 9b a1	jsr $a19b	                jsr xt_to_r
.8c61		20 b8 a1	jsr $a1b8	                jsr xt_tuck
.8c64		20 f7 89	jsr $89f7	                jsr xt_dabs
.8c67		20 78 92	jsr $9278	                jsr xt_less_number_sign
.8c6a		20 01 97	jsr $9701	                jsr xt_number_sign_s
.8c6d		20 71 9a	jsr $9a71	                jsr xt_rot
.8c70		20 4c 9e	jsr $9e4c	                jsr xt_sign
.8c73		20 df 96	jsr $96df	                jsr xt_number_sign_greater
.8c76		20 b3 99	jsr $99b3	                jsr xt_r_from
.8c79		20 b6 97	jsr $97b6	                jsr xt_over
.8c7c		20 7f 94	jsr $947f	                jsr xt_minus
.8c7f		20 81 9f	jsr $9f81	                jsr xt_spaces
.8c82		20 2e a3	jsr $a32e	                jsr xt_type
.8c85		60		rts		z_d_dot_r:      rts
.8c86						xt_drop:
.8c86		20 7c d7	jsr $d77c	                jsr underflow_1
.8c89		e8		inx		                inx
.8c8a		e8		inx		                inx
.8c8b		60		rts		z_drop:         rts
.8c8c						xt_dump:
.8c8c		20 81 d7	jsr $d781	                jsr underflow_2
.8c8f						_row:
.8c8f		a0 10		ldy #$10	                ldy #16
.8c91		64 27		stz $27		                stz tmp2
.8c93		20 d5 88	jsr $88d5	                jsr xt_cr
.8c96		b5 03		lda $03,x	                lda 3,x
.8c98		20 35 d6	jsr $d635	                jsr byte_to_ascii
.8c9b		b5 02		lda $02,x	                lda 2,x
.8c9d		20 35 d6	jsr $d635	                jsr byte_to_ascii
.8ca0		20 7b 9f	jsr $9f7b	                jsr xt_space
.8ca3		20 7b 9f	jsr $9f7b	                jsr xt_space
.8ca6						_loop:
.8ca6		b5 00		lda $00,x	                lda 0,x
.8ca8		15 01		ora $01,x	                ora 1,x
.8caa		f0 39		beq $8ce5	                beq _all_printed
.8cac		a1 02		lda ($02,x)	                lda (2,x)
.8cae		48		pha		                pha                     ; byte_to_ascii destroys A
.8caf		20 35 d6	jsr $d635	                jsr byte_to_ascii
.8cb2		20 7b 9f	jsr $9f7b	                jsr xt_space
.8cb5		68		pla		                pla
.8cb6		20 62 d7	jsr $d762	                jsr is_printable
.8cb9		b0 02		bcs $8cbd	                bcs _printable
.8cbb		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8cbd						_printable:
.8cbd		5a		phy		                phy                     ; save counter
.8cbe		a4 27		ldy $27		                ldy tmp2
.8cc0		91 00		sta ($00),y	                sta (cp),y
.8cc2		e6 27		inc $27		                inc tmp2
.8cc4		7a		ply		                ply
.8cc5		c0 09		cpy #$09	                cpy #9
.8cc7		d0 03		bne $8ccc	                bne _next_char
.8cc9		20 7b 9f	jsr $9f7b	                jsr xt_space
.8ccc						_next_char:
.8ccc		f6 02		inc $02,x	                inc 2,x
.8cce		d0 02		bne $8cd2	                bne _counter
.8cd0		f6 03		inc $03,x	                inc 3,x
.8cd2						_counter:
.8cd2		b5 00		lda $00,x	                lda 0,x
.8cd4		d0 02		bne $8cd8	                bne +
.8cd6		d6 01		dec $01,x	                dec 1,x
.8cd8						+
.8cd8		d6 00		dec $00,x	                dec 0,x
.8cda		88		dey		                dey
.8cdb		d0 c9		bne $8ca6	                bne _loop               ; next byte
.8cdd		20 7b 9f	jsr $9f7b	                jsr xt_space
.8ce0		20 f3 8c	jsr $8cf3	                jsr dump_print_ascii
.8ce3		80 aa		bra $8c8f	                bra _row                ; new row
.8ce5						_all_printed:
.8ce5		a5 27		lda $27		                lda tmp2
.8ce7		f0 06		beq $8cef	                beq _done
.8ce9		20 7b 9f	jsr $9f7b	                jsr xt_space
.8cec		20 f3 8c	jsr $8cf3	                jsr dump_print_ascii
.8cef						_done:
.8cef		20 db a1	jsr $a1db	                jsr xt_two_drop         ; one byte less than 4x INX
.8cf2		60		rts		z_dump:         rts
.8cf3						dump_print_ascii:
.8cf3		a0 00		ldy #$00	                ldy #0
.8cf5						_ascii_loop:
.8cf5		b1 00		lda ($00),y	                lda (cp),y
.8cf7		20 7b 8d	jsr $8d7b	                jsr emit_a
.8cfa		c8		iny		                iny
.8cfb		c0 08		cpy #$08	                cpy #8
.8cfd		d0 03		bne $8d02	                bne +
.8cff		20 7b 9f	jsr $9f7b	                jsr xt_space
.8d02						+
.8d02		c6 27		dec $27		                dec tmp2
.8d04		d0 ef		bne $8cf5	                bne _ascii_loop
.8d06		60		rts		                rts
.8d07						xt_dup:
.8d07		20 7c d7	jsr $d77c	                jsr underflow_1
.8d0a		ca		dex		                dex
.8d0b		ca		dex		                dex
.8d0c		b5 02		lda $02,x	                lda 2,x         ; LSB
.8d0e		95 00		sta $00,x	                sta 0,x
.8d10		b5 03		lda $03,x	                lda 3,x         ; MSB
.8d12		95 01		sta $01,x	                sta 1,x
.8d14		60		rts		z_dup:          rts
.8d15						xt_ed:
.8d15		20 50 b4	jsr $b450	                jsr ed6502      ; kept in separate file
.8d18		60		rts		z_ed:           rts
.8d19						xt_else:
.8d19						xt_endof:
.8d19		20 88 90	jsr $9088	                jsr xt_here
.8d1c		20 40 97	jsr $9740	                jsr xt_one_plus
.8d1f		20 be d5	jsr $d5be	                jsr cmpl_jump
.8d22		20 05 a0	jsr $a005	                jsr xt_swap         ; ( target orig )
.8d25						xt_then:
.8d25		20 88 90	jsr $9088	                jsr xt_here
.8d28		a1 02		lda ($02,x)	                lda (2,x)           ; get LSB at orig
.8d2a		1a		inc a		                ina                 ; was LSB $FF?  (only check for $XXFF)
.8d2b		d0 3b		bne $8d68	                bne _no_opt
.8d2d		20 e3 a1	jsr $a1e3	                jsr xt_two_dup
.8d30		20 05 a0	jsr $a005	                jsr xt_swap
.8d33		20 7f 94	jsr $947f	                jsr xt_minus        ; ( C: orig here offset )
.8d36		b5 01		lda $01,x	                lda 1,x
.8d38		d0 2c		bne $8d66	                bne _too_far        ; MSB must be zero
.8d3a		b5 00		lda $00,x	                lda 0,x
.8d3c		3a		dec a		                dea                 ; we want here - orig - 2
.8d3d		3a		dec a		                dea                 ; don't care about carry
.8d3e		30 26		bmi $8d66	                bmi _too_far        ; up to 127 is ok
.8d40		95 00		sta $00,x	                sta 0,x             ; stash offset - 2
.8d42		38		sec		                sec                 ; put orig - 2 in tmp1
.8d43		b5 04		lda $04,x	                lda 4,x
.8d45		e9 02		sbc #$02	                sbc #2
.8d47		85 25		sta $25		                sta tmp1
.8d49		b5 05		lda $05,x	                lda 5,x
.8d4b		e9 00		sbc #$00	                sbc #0
.8d4d		85 26		sta $26		                sta tmp1+1
.8d4f		a0 00		ldy #$00	                ldy #0
.8d51						-
.8d51		b9 70 8d	lda $8d70,y	                lda beq_opt+1,y               ; skip the jsr
.8d54		91 25		sta ($25),y	                sta (tmp1),y
.8d56		c8		iny		                iny
.8d57		c0 03		cpy #$03	                cpy #(beq_opt_end-beq_opt-2)  ; three bytes, skip jsr and offset
.8d59		d0 f6		bne $8d51	                bne -
.8d5b		b5 00		lda $00,x	                lda 0,x             ; write the offset
.8d5d		91 25		sta ($25),y	                sta (tmp1),y
.8d5f		e8		inx		                inx                 ; clear the stack
.8d60		e8		inx		                inx
.8d61		e8		inx		                inx
.8d62		e8		inx		                inx
.8d63		e8		inx		                inx
.8d64		e8		inx		                inx
.8d65		60		rts		                rts                 ; all done
.8d66						_too_far:
.8d66		e8		inx		                inx                 ; discard the offset we calculated
.8d67		e8		inx		                inx
.8d68						_no_opt:
.8d68		20 05 a0	jsr $a005	                jsr xt_swap
.8d6b		20 ea 9f	jsr $9fea	                jsr xt_store
.8d6e						z_else:
.8d6e						z_endof:
.8d6e		60		rts		z_then:         rts
.8d6f						beq_opt:
.8d6f		20 25 91	jsr $9125	                jsr zero_test_runtime       ; replaces jsr zero_branch_runtime
.8d72		f0 00		beq $8d74	                beq beq_opt_end             ; the beq overwrites the placeholder
.8d74						beq_opt_end:
.8d74						xt_emit:
.8d74		20 7c d7	jsr $d77c	                jsr underflow_1
.8d77		b5 00		lda $00,x	                lda 0,x
.8d79		e8		inx		                inx
.8d7a		e8		inx		                inx
.8d7b						emit_a:
.8d7b		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.8d7e						z_emit:
.8d7e						xt_empty_buffers:
.8d7e		a0 30		ldy #$30	                ldy #buffstatus_offset
.8d80		a9 00		lda #$00	                lda #0
.8d82		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.8d84						z_empty_buffers:
.8d84		60		rts		                rts
.8d85						xt_endcase:
.8d85		a0 8c		ldy #$8c	                ldy #>xt_drop
.8d87		a9 86		lda #$86	                lda #<xt_drop
.8d89		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.8d8c						_endcase_loop:
.8d8c		b5 00		lda $00,x	                lda 0,x
.8d8e		15 01		ora $01,x	                ora 1,x
.8d90		f0 05		beq $8d97	                beq _done
.8d92		20 25 8d	jsr $8d25	                jsr xt_then
.8d95		80 f5		bra $8d8c	                bra _endcase_loop
.8d97						_done:
.8d97		e8		inx		                inx
.8d98		e8		inx		                inx
.8d99		60		rts		z_endcase:      rts
.8d9a						xt_environment_q:
.8d9a		20 7c d7	jsr $d77c	                jsr underflow_1
.8d9d		a0 00		ldy #$00	                ldy #00                 ; counter for table
.8d9f		5a		phy		                phy
.8da0						_table_loop:
.8da0		20 e3 a1	jsr $a1e3	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8da3		ca		dex		                dex
.8da4		ca		dex		                dex                     ; ( addr u addr u ? )
.8da5		b9 17 8e	lda $8e17,y	                lda env_table_single,y
.8da8		95 00		sta $00,x	                sta 0,x
.8daa		c8		iny		                iny
.8dab		b9 17 8e	lda $8e17,y	                lda env_table_single,y
.8dae		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8db0		c8		iny		                iny
.8db1		15 00		ora $00,x	                ora 0,x
.8db3		f0 4d		beq $8e02	                beq _table_done
.8db5		5a		phy		                phy                     ; save Y, which is used by COUNT
.8db6		20 c1 88	jsr $88c1	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8db9		20 f8 86	jsr $86f8	                jsr xt_compare          ; ( addr u f )
.8dbc		7a		ply		                ply
.8dbd		b5 00		lda $00,x	                lda 0,x
.8dbf		15 01		ora $01,x	                ora 1,x
.8dc1		f0 04		beq $8dc7	                beq _got_result
.8dc3		e8		inx		                inx                     ; DROP, now ( addr u )
.8dc4		e8		inx		                inx
.8dc5		80 d9		bra $8da0	                bra _table_loop
.8dc7						_got_result:
.8dc7		e8		inx		                inx                     ; drop flag, now ( addr u )
.8dc8		e8		inx		                inx
.8dc9		88		dey		                dey                     ; go back to index we had
.8dca		88		dey		                dey
.8dcb		68		pla		                pla
.8dcc		d0 0d		bne $8ddb	                bne _double_result
.8dce		b9 35 8e	lda $8e35,y	                lda env_results_single,y
.8dd1		95 02		sta $02,x	                sta 2,x
.8dd3		c8		iny		                iny
.8dd4		b9 35 8e	lda $8e35,y	                lda env_results_single,y
.8dd7		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8dd9		80 1f		bra $8dfa	                bra _set_flag
.8ddb						_double_result:
.8ddb		ca		dex		                dex                     ; ( addr u ? )
.8ddc		ca		dex		                dex
.8ddd		98		tya		                tya
.8dde		38		sec		                sec
.8ddf		e9 18		sbc #$18	                sbc #24
.8de1		0a		asl a		                asl
.8de2		a8		tay		                tay
.8de3		b9 4b 8e	lda $8e4b,y	                lda env_results_double,y
.8de6		95 02		sta $02,x	                sta 2,x
.8de8		c8		iny		                iny
.8de9		b9 4b 8e	lda $8e4b,y	                lda env_results_double,y
.8dec		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8dee		c8		iny		                iny
.8def		b9 4b 8e	lda $8e4b,y	                lda env_results_double,y
.8df2		95 04		sta $04,x	                sta 4,x
.8df4		c8		iny		                iny
.8df5		b9 4b 8e	lda $8e4b,y	                lda env_results_double,y
.8df8		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8dfa						_set_flag:
.8dfa		a9 ff		lda #$ff	                lda #$FF
.8dfc		95 00		sta $00,x	                sta 0,x
.8dfe		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e00		80 14		bra $8e16	                bra _done
.8e02						_table_done:
.8e02		68		pla		                pla
.8e03		d0 09		bne $8e0e	                bne _no_match
.8e05		1a		inc a		                ina
.8e06		48		pha		                pha
.8e07		8a		txa		                txa
.8e08		18		clc		                clc
.8e09		69 06		adc #$06	                adc #6                  ; skip six bytes
.8e0b		aa		tax		                tax                     ; ( addr u )
.8e0c		80 92		bra $8da0	                bra _table_loop
.8e0e						_no_match:
.8e0e		8a		txa		                txa
.8e0f		18		clc		                clc
.8e10		69 0a		adc #$0a	                adc #10
.8e12		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e13		20 e4 a5	jsr $a5e4	                jsr xt_false
.8e16						_done:
.8e16						z_environment_q:
.8e16		60		rts		                rts
.8e17						env_table_single:
>8e17		39 d5 49 d5 4f d5 54 d5		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e1f		66 d5
>8e21		6e d5 77 d5 7d d5 83 d5		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e29		96 d5 a2 d5 00 00		        .word envs_sc, envs_wl, 0000
.8e2f						env_table_double:
>8e2f		ac d5 b2 d5 00 00		        .word envs_max_d, envs_max_ud, 0000
.8e35						env_results_single:
>8e35		ff 00				        .word $00FF     ; /COUNTED-STRING
>8e37		ff 00				        .word $00FF     ; /HOLD
>8e39		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8e3b		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8e3d		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8e3f		ff 00				        .word $00FF     ; MAX-CHAR
>8e41		ff 7f				        .word $7FFF     ; MAX-N
>8e43		ff ff				        .word $FFFF     ; MAX-U
>8e45		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8e47		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8e49		09 00				        .word $0009     ; WORDLISTS
.8e4b						env_results_double:
>8e4b		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8e4f		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8e53						xt_equal:
.8e53		20 81 d7	jsr $d781	                jsr underflow_2
.8e56		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8e58		d5 02		cmp $02,x	                cmp 2,x
.8e5a		d0 0a		bne $8e66	                bne _false
.8e5c		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8e5e		d5 03		cmp $03,x	                cmp 3,x
.8e60		d0 04		bne $8e66	                bne _false
.8e62		a9 ff		lda #$ff	                lda #$FF
.8e64		80 02		bra $8e68	                bra _done
.8e66		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8e68		95 02		sta $02,x	_done:          sta 2,x
.8e6a		95 03		sta $03,x	                sta 3,x
.8e6c		e8		inx		                inx
.8e6d		e8		inx		                inx
.8e6e		60		rts		z_equal:        rts
.8e6f						xt_blank:
.8e6f		ca		dex		                dex
.8e70		ca		dex		                dex
.8e71		a9 20		lda #$20	                lda #AscSP
.8e73		95 00		sta $00,x	                sta 0,x
.8e75		74 01		stz $01,x	                stz 1,x
.8e77		80 06		bra $8e7f	                bra xt_fill     ; skip over code for ERASE
.8e79						xt_erase:
.8e79		ca		dex		                dex
.8e7a		ca		dex		                dex
.8e7b		74 00		stz $00,x	                stz 0,x
.8e7d		74 01		stz $01,x	                stz 1,x
.8e7f						xt_fill:
.8e7f		20 86 d7	jsr $d786	                jsr underflow_3
.8e82		b5 04		lda $04,x	                lda 4,x         ; LSB
.8e84		85 25		sta $25		                sta tmp1
.8e86		b5 05		lda $05,x	                lda 5,x
.8e88		85 26		sta $26		                sta tmp1+1
.8e8a		b5 02		lda $02,x	                lda 2,x
.8e8c		85 27		sta $27		                sta tmp2
.8e8e		b5 03		lda $03,x	                lda 3,x
.8e90		85 28		sta $28		                sta tmp2+1
.8e92		b5 00		lda $00,x	                lda 0,x
.8e94		a8		tay		                tay
.8e95						_loop:
.8e95		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8e97		c5 26		cmp $26		                cmp tmp1+1
.8e99		90 21		bcc $8ebc	                bcc _done               ; RAM_END < TMP1, so leave
.8e9b		d0 06		bne $8ea3	                bne _check_counter      ; RAM_END is not smaller and not equal
.8e9d		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8e9f		c5 25		cmp $25		                cmp tmp1
.8ea1		90 19		bcc $8ebc	                bcc _done               ; RAM_END < TMP1, so leave
.8ea3						_check_counter:
.8ea3		a5 27		lda $27		                lda tmp2
.8ea5		05 28		ora $28		                ora tmp2+1
.8ea7		f0 13		beq $8ebc	                beq _done
.8ea9		98		tya		                tya
.8eaa		92 25		sta ($25)	                sta (tmp1)
.8eac		a5 27		lda $27		                lda tmp2
.8eae		d0 02		bne $8eb2	                bne +
.8eb0		c6 28		dec $28		                dec tmp2+1
.8eb2		c6 27		dec $27		+               dec tmp2
.8eb4		e6 25		inc $25		                inc tmp1
.8eb6		d0 dd		bne $8e95	                bne _loop
.8eb8		e6 26		inc $26		                inc tmp1+1
.8eba		80 d9		bra $8e95	                bra _loop
.8ebc						_done:
.8ebc		8a		txa		                txa
.8ebd		18		clc		                clc
.8ebe		69 06		adc #$06	                adc #6
.8ec0		aa		tax		                tax
.8ec1						z_blank:
.8ec1						z_erase:
.8ec1		60		rts		z_fill:         rts
.8ec2						xt_execute:
.8ec2		20 7c d7	jsr $d77c	                jsr underflow_1
.8ec5		20 c9 8e	jsr $8ec9	                jsr doexecute   ; do not combine to JMP (native coding)
.8ec8		60		rts		z_execute:      rts
.8ec9						doexecute:
.8ec9		b5 00		lda $00,x	                lda 0,x
.8ecb		85 04		sta $04		                sta ip
.8ecd		b5 01		lda $01,x	                lda 1,x
.8ecf		85 05		sta $05		                sta ip+1
.8ed1		e8		inx		                inx
.8ed2		e8		inx		                inx
.8ed3		6c 04 00	jmp ($0004)	                jmp (ip)
.8ed6						xt_execute_parsing:
.8ed6		20 86 d7	jsr $d786	                jsr underflow_3
.8ed9		20 71 91	jsr $9171	                jsr xt_input_to_r       ; save normal input for later
.8edc		20 94 95	jsr $9594	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8edf		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8ee1		85 0e		sta $0e		                sta ciblen
.8ee3		b5 01		lda $01,x	                lda 1,x
.8ee5		85 0f		sta $0f		                sta ciblen+1
.8ee7		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8ee9		85 0c		sta $0c		                sta cib
.8eeb		b5 03		lda $03,x	                lda 3,x
.8eed		85 0d		sta $0d		                sta cib+1
.8eef		64 10		stz $10		                stz toin                ; Set >IN to zero
.8ef1		64 11		stz $11		                stz toin+1
.8ef3		20 db a1	jsr $a1db	                jsr xt_two_drop         ; 2DROP ( xt )
.8ef6		20 c2 8e	jsr $8ec2	                jsr xt_execute
.8ef9		20 c4 99	jsr $99c4	                jsr xt_r_to_input
.8efc						z_execute_parsing:
.8efc		60		rts		                rts
.8efd						xt_exit:
.8efd		60		rts		                rts             ; keep before z_exit
.8efe						z_exit:
.8efe						xt_fetch:
.8efe		20 7c d7	jsr $d77c	                jsr underflow_1
.8f01		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f03		a8		tay		                tay
.8f04		f6 00		inc $00,x	                inc 0,x
.8f06		d0 02		bne $8f0a	                bne +
.8f08		f6 01		inc $01,x	                inc 1,x
.8f0a						+
.8f0a		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f0c		95 01		sta $01,x	                sta 1,x
.8f0e		94 00		sty $00,x	                sty 0,x
.8f10		60		rts		z_fetch:        rts
.8f11						xt_find:
.8f11		20 7c d7	jsr $d77c	                jsr underflow_1
.8f14		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f16		48		pha		                pha
.8f17		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f19		48		pha		                pha
.8f1a		20 c1 88	jsr $88c1	                jsr xt_count            ; ( caddr -- addr u )
.8f1d		20 59 8f	jsr $8f59	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f20		b5 00		lda $00,x	                lda 0,x
.8f22		15 01		ora $01,x	                ora 1,x
.8f24		d0 0b		bne $8f31	                bne _found_word
.8f26		20 e4 a5	jsr $a5e4	                jsr xt_false            ; ( 0 0 )
.8f29		68		pla		                pla                     ; LSB of address
.8f2a		95 02		sta $02,x	                sta 2,x
.8f2c		68		pla		                pla
.8f2d		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8f2f		80 27		bra $8f58	                bra _done               ; ( addr 0 )
.8f31						_found_word:
.8f31		68		pla		                pla
.8f32		68		pla		                pla
.8f33		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( nt nt )
.8f36		20 10 95	jsr $9510	                jsr xt_name_to_int      ; ( nt xt )
.8f39		20 05 a0	jsr $a005	                jsr xt_swap             ; ( xt nt )
.8f3c		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8f3e		f6 00		inc $00,x	                inc 0,x
.8f40		d0 02		bne $8f44	                bne +
.8f42		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8f44						+
.8f44		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8f46		29 04		and #$04	                and #IM
.8f48		d0 08		bne $8f52	                bne _immediate          ; bit set, we're immediate
.8f4a		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8f4c		95 00		sta $00,x	                sta 0,x
.8f4e		95 01		sta $01,x	                sta 1,x
.8f50		80 06		bra $8f58	                bra _done
.8f52						_immediate:
.8f52		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8f54		95 00		sta $00,x	                sta 0,x
.8f56		74 01		stz $01,x	                stz 1,x
.8f58						_done:
.8f58		60		rts		z_find:         rts
.8f59						xt_find_name:
.8f59		20 81 d7	jsr $d781	                jsr underflow_2
.8f5c		b5 00		lda $00,x	                lda 0,x
.8f5e		15 01		ora $01,x	                ora 1,x
.8f60		d0 03		bne $8f65	                bne _nonempty
.8f62		4c 96 8f	jmp $8f96	                jmp _fail_done
.8f65						_nonempty:
.8f65		64 29		stz $29		                stz tmp3                ; Start at the beginning
.8f67						_wordlist_loop:
.8f67		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8f69		a5 29		lda $29		                lda tmp3
.8f6b		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.8f6d		f0 27		beq $8f96	                beq _fail_done
.8f6f		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8f70		69 23		adc #$23	                adc #search_order_offset
.8f72		a8		tay		                tay
.8f73		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.8f75		0a		asl a		                asl                     ; Turn offset into cells offset.
.8f76		18		clc		                clc
.8f77		69 0a		adc #$0a	                adc #wordlists_offset
.8f79		a8		tay		                tay
.8f7a		b1 08		lda ($08),y	                lda (up),y
.8f7c		85 25		sta $25		                sta tmp1
.8f7e		c8		iny		                iny
.8f7f		b1 08		lda ($08),y	                lda (up),y
.8f81		85 26		sta $26		                sta tmp1+1
.8f83		20 4c d6	jsr $d64c	                jsr find_header_name
.8f86		d0 04		bne $8f8c	                bne _success
.8f88		e6 29		inc $29		                inc tmp3
.8f8a		80 db		bra $8f67	                bra _wordlist_loop
.8f8c						_success:
.8f8c		a5 25		lda $25		                lda tmp1
.8f8e		95 02		sta $02,x	                sta 2,x
.8f90		a5 26		lda $26		                lda tmp1+1
.8f92		95 03		sta $03,x	                sta 3,x
.8f94		80 04		bra $8f9a	                bra _done
.8f96						_fail_done:
.8f96		74 02		stz $02,x	                stz 2,x         ; failure flag
.8f98		74 03		stz $03,x	                stz 3,x
.8f9a						_done:
.8f9a		e8		inx		                inx
.8f9b		e8		inx		                inx
.8f9c		60		rts		z_find_name:    rts
.8f9d						xt_flush:
.8f9d		20 2e 9d	jsr $9d2e	                jsr xt_save_buffers
.8fa0		a0 30		ldy #$30	                ldy #buffstatus_offset
.8fa2		a9 00		lda #$00	                lda #0
.8fa4		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.8fa6						z_flush:
.8fa6		60		rts		                rts
.8fa7						xt_fm_slash_mod:
.8fa7		20 86 d7	jsr $d786	                jsr underflow_3
.8faa		64 27		stz $27		                stz tmp2        ; default: n is positive
.8fac		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8fae		10 0e		bpl $8fbe	                bpl _check_d
.8fb0		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8fb2		20 49 95	jsr $9549	                jsr xt_negate   ; NEGATE
.8fb5		20 9b a1	jsr $a19b	                jsr xt_to_r     ; >R
.8fb8		20 b2 8a	jsr $8ab2	                jsr xt_dnegate  ; DNEGATE
.8fbb		20 b3 99	jsr $99b3	                jsr xt_r_from   ; R>
.8fbe						_check_d:
.8fbe		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.8fc0		10 0d		bpl $8fcf	                bpl _multiply
.8fc2		18		clc		                clc
.8fc3		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.8fc5		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8fc7		95 02		sta $02,x	                sta 2,x
.8fc9		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8fcb		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.8fcd		95 03		sta $03,x	                sta 3,x
.8fcf						_multiply:
.8fcf		20 e5 a3	jsr $a3e5	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.8fd2		a5 27		lda $27		                lda tmp2
.8fd4		f0 07		beq $8fdd	                beq _done
.8fd6		e8		inx		                inx             ; pretend that we SWAP
.8fd7		e8		inx		                inx
.8fd8		20 49 95	jsr $9549	                jsr xt_negate
.8fdb		ca		dex		                dex
.8fdc		ca		dex		                dex
.8fdd						_done:
.8fdd		60		rts		z_fm_slash_mod: rts
.8fde						xt_forth:
.8fde		a0 23		ldy #$23	                ldy #search_order_offset
.8fe0		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.8fe2		91 08		sta ($08),y	                sta (up),y
.8fe4						z_forth:
.8fe4		60		rts		                rts
.8fe5						load_evaluate:
.8fe5		a9 ff		lda #$ff	                lda #$FF
.8fe7		85 25		sta $25		                sta tmp1
.8fe9		80 11		bra $8ffc	                bra load_evaluate_start
.8feb						xt_evaluate:
.8feb		20 81 d7	jsr $d781	                jsr underflow_2
.8fee		64 25		stz $25		                stz tmp1
.8ff0		b5 00		lda $00,x	                lda 0,x
.8ff2		15 01		ora $01,x	                ora 1,x
.8ff4		d0 06		bne $8ffc	                bne evaluate_got_work
.8ff6		e8		inx		                inx
.8ff7		e8		inx		                inx
.8ff8		e8		inx		                inx
.8ff9		e8		inx		                inx
.8ffa		80 42		bra $903e	                bra evaluate_done
.8ffc						load_evaluate_start:
.8ffc						evaluate_got_work:
.8ffc		a0 05		ldy #$05	                ldy #blk_offset+1
.8ffe		b1 08		lda ($08),y	                lda (up),y
.9000		48		pha		                pha
.9001		88		dey		                dey
.9002		b1 08		lda ($08),y	                lda (up),y
.9004		48		pha		                pha
.9005		a5 25		lda $25		                lda tmp1
.9007		d0 05		bne $900e	                bne _nozero
.9009		91 08		sta ($08),y	                sta (up),y
.900b		c8		iny		                iny
.900c		91 08		sta ($08),y	                sta (up),y
.900e						_nozero:
.900e		20 71 91	jsr $9171	                jsr xt_input_to_r
.9011		a9 ff		lda #$ff	                lda #$FF
.9013		85 0a		sta $0a		                sta insrc
.9015		85 0b		sta $0b		                sta insrc+1
.9017		64 10		stz $10		                stz toin
.9019		64 11		stz $11		                stz toin+1
.901b		b5 00		lda $00,x	                lda 0,x
.901d		85 0e		sta $0e		                sta ciblen
.901f		b5 01		lda $01,x	                lda 1,x
.9021		85 0f		sta $0f		                sta ciblen+1
.9023		b5 02		lda $02,x	                lda 2,x
.9025		85 0c		sta $0c		                sta cib
.9027		b5 03		lda $03,x	                lda 3,x
.9029		85 0d		sta $0d		                sta cib+1
.902b		e8		inx		                inx             ; A clean stack is a clean mind
.902c		e8		inx		                inx
.902d		e8		inx		                inx
.902e		e8		inx		                inx
.902f		20 e9 d6	jsr $d6e9	                jsr interpret   ; ( -- )
.9032		20 c4 99	jsr $99c4	                jsr xt_r_to_input
.9035		a0 04		ldy #$04	                ldy #blk_offset
.9037		68		pla		                pla
.9038		91 08		sta ($08),y	                sta (up),y
.903a		c8		iny		                iny
.903b		68		pla		                pla
.903c		91 08		sta ($08),y	                sta (up),y
.903e						evaluate_done:
.903e		60		rts		z_evaluate:     rts
.903f						xt_get_current:
.903f		ca		dex		                dex
.9040		ca		dex		                dex
.9041		a0 08		ldy #$08	                ldy #current_offset
.9043		b1 08		lda ($08),y	                lda (up),y
.9045		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.9047		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.9049		60		rts		z_get_current:  rts
.904a						xt_get_order:
.904a		a0 22		ldy #$22	                ldy #num_order_offset
.904c		b1 08		lda ($08),y	                lda (up),y
.904e		85 25		sta $25		                sta tmp1
.9050		f0 16		beq $9068	                beq _done       ; If zero, there are no wordlists.
.9052						_loop:
.9052		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.9054		a9 23		lda #$23	                lda #search_order_offset
.9056		18		clc		                clc
.9057		65 25		adc $25		                adc tmp1
.9059		a8		tay		                tay
.905a		ca		dex		                dex
.905b		ca		dex		                dex
.905c		b1 08		lda ($08),y	                lda (up),y
.905e		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.9060		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.9062		a9 00		lda #$00	                lda #0
.9064		c5 25		cmp $25		                cmp tmp1
.9066		d0 ea		bne $9052	                bne _loop
.9068						_done:
.9068		ca		dex		                dex
.9069		ca		dex		                dex
.906a		a0 22		ldy #$22	                ldy #num_order_offset
.906c		b1 08		lda ($08),y	                lda (up),y
.906e		95 00		sta $00,x	                sta 0,x
.9070		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.9072		60		rts		z_get_order:    rts
.9073						xt_greater_than:
.9073		20 81 d7	jsr $d781	                jsr underflow_2
.9076		a0 00		ldy #$00	                ldy #0          ; default false
.9078		20 a8 d6	jsr $d6a8	                jsr compare_16bit
.907b		f0 03		beq $9080	                beq _false
.907d		10 01		bpl $9080	                bpl _false
.907f		88		dey		                dey
.9080						_false:
.9080		98		tya		                tya
.9081		e8		inx		                inx
.9082		e8		inx		                inx
.9083		95 00		sta $00,x	                sta 0,x
.9085		95 01		sta $01,x	                sta 1,x
.9087		60		rts		z_greater_than: rts
.9088						xt_here:
.9088						xt_asm_arrow:
.9088		ca		dex		                dex
.9089		ca		dex		                dex
.908a		a5 00		lda $00		                lda cp
.908c		95 00		sta $00,x	                sta 0,x
.908e		a5 01		lda $01		                lda cp+1
.9090		95 01		sta $01,x	                sta 1,x
.9092						z_asm_arrow:
.9092		60		rts		z_here:         rts
.9093						xt_hex:
.9093		a9 10		lda #$10	                lda #16
.9095		85 18		sta $18		                sta base
.9097		64 19		stz $19		                stz base+1              ; paranoid
.9099		60		rts		z_hex:          rts
.909a						xt_hexstore:
.909a		20 86 d7	jsr $d786	                jsr underflow_3
.909d		20 07 8d	jsr $8d07	                jsr xt_dup              ; Save copy of original address
.90a0		20 cd a2	jsr $a2cd	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.90a3						_loop:
.90a3		b5 00		lda $00,x	                lda 0,x
.90a5		15 01		ora $01,x	                ora 1,x
.90a7		f0 36		beq $90df	                beq _done
.90a9		20 bc 85	jsr $85bc	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.90ac		20 cd a2	jsr $a2cd	                jsr xt_two_to_r
.90af		20 e4 a5	jsr $a5e4	                jsr xt_zero
.90b2		20 e4 a5	jsr $a5e4	                jsr xt_zero
.90b5		20 53 a2	jsr $a253	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.90b8		20 e8 a0	jsr $a0e8	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.90bb		b5 00		lda $00,x	                lda 0,x
.90bd		15 01		ora $01,x	                ora 1,x
.90bf		d0 17		bne $90d8	                bne _have_chars_left
.90c1		20 db a1	jsr $a1db	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.90c4		20 f1 89	jsr $89f1	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.90c7		20 9e 99	jsr $999e	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.90ca		20 85 85	jsr $8585	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.90cd		20 b3 99	jsr $99b3	                jsr xt_r_from           ; R>
.90d0		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+
.90d3		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.90d6		80 cb		bra $90a3	                bra _loop
.90d8						_have_chars_left:
.90d8		8a		txa		                txa
.90d9		18		clc		                clc
.90da		69 08		adc #$08	                adc #8
.90dc		aa		tax		                tax
.90dd		80 c4		bra $90a3	                bra _loop
.90df						_done:
.90df		e8		inx		                inx
.90e0		e8		inx		                inx
.90e1		e8		inx		                inx
.90e2		e8		inx		                inx                     ; 2DROP
.90e3		20 53 a2	jsr $a253	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.90e6		20 05 a0	jsr $a005	                jsr xt_swap
.90e9		20 7f 94	jsr $947f	                jsr xt_minus            ; ( n )
.90ec		60		rts		z_hexstore:     rts
.90ed						xt_hold:
.90ed		20 7c d7	jsr $d77c	                jsr underflow_1
.90f0		a5 2b		lda $2b		                lda tohold
.90f2		d0 02		bne $90f6	                bne +
.90f4		c6 2c		dec $2c		                dec tohold+1
.90f6						+
.90f6		c6 2b		dec $2b		                dec tohold
.90f8		b5 00		lda $00,x	                lda 0,x
.90fa		92 2b		sta ($2b)	                sta (tohold)
.90fc		e8		inx		                inx
.90fd		e8		inx		                inx
.90fe		60		rts		z_hold:         rts
.90ff						xt_i:
.90ff		ca		dex		                dex
.9100		ca		dex		                dex
.9101		a4 1f		ldy $1f		                ldy loopctrl
.9103		38		sec		                sec
.9104		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.9106		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.9109		95 00		sta $00,x	                sta 0,x
.910b		b9 01 01	lda $0101,y	                lda loopindex+1,y
.910e		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.9111		95 01		sta $01,x	                sta 1,x
.9113		60		rts		z_i:            rts
.9114						xt_if:
.9114		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.9116		a9 2f		lda #$2f	                lda #<zero_branch_runtime
.9118		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.911b		20 88 90	jsr $9088	                jsr xt_here
.911e		a9 ff		lda #$ff	                lda #$FF
.9120		a8		tay		                tay
.9121		20 c5 d5	jsr $d5c5	                jsr cmpl_word
.9124		60		rts		z_if:           rts
.9125						zero_test_runtime:
.9125		e8		inx		                inx
.9126		e8		inx		                inx
.9127		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.9129		15 ff		ora $ff,x	                ora $FF,x
.912b		60		rts		                rts
.912c		d0 03		bne $9131	                bne zero_test_footer_end+2  ; branch fwd if non-zero
>912e		4c				                .byte OpJMP                 ; else JMP back
.912f						zero_test_footer_end:
.912f						zero_branch_runtime:
.912f		68		pla		                pla
.9130		85 25		sta $25		                sta tmp1
.9132		68		pla		                pla
.9133		85 26		sta $26		                sta tmp1+1
.9135		b5 00		lda $00,x	                lda 0,x
.9137		15 01		ora $01,x	                ora 1,x
.9139		f0 0d		beq $9148	                beq _zero
.913b		a5 25		lda $25		                lda tmp1        ; LSB
.913d		18		clc		                clc
.913e		69 03		adc #$03	                adc #3          ; add one to RTS address plus two address bytes
.9140		85 25		sta $25		                sta tmp1
.9142		90 11		bcc $9155	                bcc _jump
.9144		e6 26		inc $26		                inc tmp1+1      ; MSB
.9146		80 0d		bra $9155	                bra _jump
.9148						_zero:
.9148		a0 01		ldy #$01	                ldy #1
.914a		b1 25		lda ($25),y	                lda (tmp1),y
.914c		48		pha		                pha
.914d		c8		iny		                iny
.914e		b1 25		lda ($25),y	                lda (tmp1),y
.9150		85 26		sta $26		                sta tmp1+1
.9152		68		pla		                pla
.9153		85 25		sta $25		                sta tmp1
.9155						_jump:
.9155		e8		inx		                inx
.9156		e8		inx		                inx
.9157		6c 25 00	jmp ($0025)	                jmp (tmp1)
.915a						xt_immediate:
.915a		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.915d		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.915f		b1 02		lda ($02),y	                lda (dp),y
.9161		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9163		91 02		sta ($02),y	                sta (dp),y
.9165		60		rts		z_immediate:    rts
.9166						xt_input:
.9166		ca		dex		                dex
.9167		ca		dex		                dex
.9168		a9 14		lda #$14	                lda #<input
.916a		95 00		sta $00,x	                sta 0,x
.916c		a9 00		lda #$00	                lda #>input
.916e		95 01		sta $01,x	                sta 1,x
.9170		60		rts		z_input:        rts
.9171						xt_input_to_r:
.9171		68		pla		                pla
.9172		85 25		sta $25		                sta tmp1
.9174		68		pla		                pla
.9175		85 26		sta $26		                sta tmp1+1
.9177		a0 07		ldy #$07	                ldy #7
.9179						_loop:
.9179		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.917c		48		pha		                pha
.917d		88		dey		                dey
.917e		10 f9		bpl $9179	                bpl _loop
.9180		a5 26		lda $26		                lda tmp1+1
.9182		48		pha		                pha
.9183		a5 25		lda $25		                lda tmp1
.9185		48		pha		                pha
.9186		60		rts		z_input_to_r: 	rts
.9187						xt_int_to_name:
.9187		20 7c d7	jsr $d77c	                jsr underflow_1
.918a		ca		dex		                dex
.918b		ca		dex		                dex
.918c		74 00		stz $00,x	                stz 0,x
.918e		74 01		stz $01,x	                stz 1,x
.9190						_wordlist_loop:
.9190		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9192		0a		asl a		                asl                     ; Turn offset into cells offset.
.9193		18		clc		                clc
.9194		69 0a		adc #$0a	                adc #wordlists_offset
.9196		a8		tay		                tay
.9197		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9199		85 27		sta $27		                sta tmp2                ; into tmp2
.919b		c8		iny		                iny
.919c		b1 08		lda ($08),y	                lda (up),y
.919e		85 28		sta $28		                sta tmp2+1
.91a0		a5 27		lda $27		                lda tmp2
.91a2		05 28		ora $28		                ora tmp2+1
.91a4		f0 36		beq $91dc	                beq _next_wordlist
.91a6		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.91a8		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.91aa		b5 03		lda $03,x	                lda 3,x
.91ac		85 2a		sta $2a		                sta tmp3+1
.91ae						_loop:
.91ae		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.91b0		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.91b2		c5 29		cmp $29		                cmp tmp3
.91b4		d0 07		bne $91bd	                bne _no_match
.91b6		c8		iny		                iny
.91b7		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.91b9		c5 2a		cmp $2a		                cmp tmp3+1
.91bb		f0 30		beq $91ed	                beq _match
.91bd						_no_match:
.91bd		18		clc		                clc
.91be		a5 27		lda $27		                lda tmp2
.91c0		69 02		adc #$02	                adc #2
.91c2		85 27		sta $27		                sta tmp2
.91c4		90 02		bcc $91c8	                bcc +
.91c6		e6 28		inc $28		                inc tmp2+1
.91c8						+
.91c8		a0 00		ldy #$00	                ldy #0
.91ca		b1 27		lda ($27),y	                lda (tmp2),y
.91cc		48		pha		                pha
.91cd		c8		iny		                iny
.91ce		11 27		ora ($27),y	                ora (tmp2),y
.91d0		f0 09		beq $91db	                beq _zero
.91d2		b1 27		lda ($27),y	                lda (tmp2),y
.91d4		85 28		sta $28		                sta tmp2+1
.91d6		68		pla		                pla
.91d7		85 27		sta $27		                sta tmp2
.91d9		80 d3		bra $91ae	                bra _loop
.91db						_zero:
.91db		68		pla		                pla             ; Leftover from above loop
.91dc						_next_wordlist:
.91dc		b5 00		lda $00,x	                lda 0,x
.91de		1a		inc a		                ina
.91df		95 00		sta $00,x	                sta 0,x
.91e1		c9 0c		cmp #$0c	                cmp #max_wordlists
.91e3		d0 ab		bne $9190	                bne _wordlist_loop
.91e5		e8		inx		                inx
.91e6		e8		inx		                inx
.91e7		74 00		stz $00,x	                stz 0,x
.91e9		74 01		stz $01,x	                stz 1,x
.91eb		80 0a		bra $91f7	                bra z_int_to_name
.91ed						_match:
.91ed		e8		inx		                inx
.91ee		e8		inx		                inx
.91ef		a5 27		lda $27		                lda tmp2
.91f1		95 00		sta $00,x	                sta 0,x
.91f3		a5 28		lda $28		                lda tmp2+1
.91f5		95 01		sta $01,x	                sta 1,x
.91f7		60		rts		z_int_to_name:  rts
.91f8						xt_invert:
.91f8		20 7c d7	jsr $d77c	                jsr underflow_1
.91fb		a9 ff		lda #$ff	                lda #$FF
.91fd		55 00		eor $00,x	                eor 0,x         ; LSB
.91ff		95 00		sta $00,x	                sta 0,x
.9201		a9 ff		lda #$ff	                lda #$FF
.9203		55 01		eor $01,x	                eor 1,x         ; MSB
.9205		95 01		sta $01,x	                sta 1,x
.9207		60		rts		z_invert:       rts
.9208						xt_is:
.9208		a5 1a		lda $1a		                lda state
.920a		05 1b		ora $1b		                ora state+1
.920c		f0 0c		beq $921a	                beq _interpreting
.920e						_compiling:
.920e		20 24 85	jsr $8524	                jsr xt_bracket_tick
.9211		a0 8a		ldy #$8a	                ldy #>xt_defer_store
.9213		a9 57		lda #$57	                lda #<xt_defer_store
.9215		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.9218		80 06		bra $9220	                bra _done
.921a						_interpreting:
.921a		20 5e a0	jsr $a05e	                jsr xt_tick
.921d		20 57 8a	jsr $8a57	                jsr xt_defer_store
.9220						_done:
.9220		60		rts		z_is:           rts
.9221						xt_j:
.9221		ca		dex		                dex                 ; make space on the stack
.9222		ca		dex		                dex
.9223		a5 1f		lda $1f		                lda loopctrl
.9225		38		sec		                sec
.9226		e9 04		sbc #$04	                sbc #4
.9228		a8		tay		                tay
.9229		38		sec		                sec
.922a		b9 00 01	lda $0100,y	                lda loopindex,y
.922d		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.9230		95 00		sta $00,x	                sta 0,x
.9232		b9 01 01	lda $0101,y	                lda loopindex+1,y
.9235		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.9238		95 01		sta $01,x	                sta 1,x
.923a		60		rts		z_j:            rts
.923b						xt_key:
.923b		20 45 92	jsr $9245	                jsr key_a               ; returns char in A
.923e		ca		dex		                dex
.923f		ca		dex		                dex
.9240		95 00		sta $00,x	                sta 0,x
.9242		74 01		stz $01,x	                stz 1,x
.9244		60		rts		z_key:          rts
.9245						key_a:
.9245		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.9248						xt_latestnt:
.9248		ca		dex		                dex
.9249		ca		dex		                dex
.924a		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.924d		a5 02		lda $02		                lda dp
.924f		95 00		sta $00,x	                sta 0,x
.9251		a5 03		lda $03		                lda dp+1
.9253		95 01		sta $01,x	                sta 1,x
.9255		60		rts		z_latestnt:     rts
.9256						xt_latestxt:
.9256		20 48 92	jsr $9248	                jsr xt_latestnt         ; ( nt )
.9259		20 10 95	jsr $9510	                jsr xt_name_to_int      ; ( xt )
.925c		60		rts		z_latestxt:     rts
.925d						xt_leave:
.925d		a5 21		lda $21		                lda loopleave
.925f		a4 22		ldy $22		                ldy loopleave+1
.9261		20 be d5	jsr $d5be	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.9264		38		sec		                sec
.9265		a5 00		lda $00		                lda cp
.9267		e9 02		sbc #$02	                sbc #2
.9269		85 21		sta $21		                sta loopleave
.926b		a5 01		lda $01		                lda cp+1
.926d		b0 01		bcs $9270	                bcs +
.926f		3a		dec a		                dea
.9270		85 22		sta $22		+               sta loopleave+1
.9272						z_leave:
.9272		60		rts		                rts
.9273						xt_left_bracket:
.9273		64 1a		stz $1a		                stz state
.9275		64 1b		stz $1b		                stz state+1
.9277		60		rts		z_left_bracket: rts
.9278						xt_less_number_sign:
.9278		20 c4 97	jsr $97c4	                jsr xt_pad      ; ( addr )
.927b		b5 00		lda $00,x	                lda 0,x
.927d		85 2b		sta $2b		                sta tohold
.927f		b5 01		lda $01,x	                lda 1,x
.9281		85 2c		sta $2c		                sta tohold+1
.9283		e8		inx		                inx
.9284		e8		inx		                inx
.9285						z_less_number_sign:
.9285		60		rts		                rts
.9286						xt_less_than:
.9286		20 81 d7	jsr $d781	                jsr underflow_2
.9289		a0 00		ldy #$00	                ldy #0          ; default false
.928b		20 a8 d6	jsr $d6a8	                jsr compare_16bit
.928e		f0 03		beq $9293	                beq _false
.9290		30 01		bmi $9293	                bmi _false
.9292		88		dey		                dey
.9293						_false:
.9293		98		tya		                tya
.9294		e8		inx		                inx
.9295		e8		inx		                inx
.9296		95 00		sta $00,x	                sta 0,x
.9298		95 01		sta $01,x	                sta 1,x
.929a		60		rts		z_less_than:    rts
.929b						xt_list:
.929b		20 7c d7	jsr $d77c	                jsr underflow_1
.929e		20 49 9d	jsr $9d49	                jsr xt_scr
.92a1		20 ea 9f	jsr $9fea	                jsr xt_store
.92a4		20 7e a6	jsr $a67e	                jsr xt_editor_l
.92a7		60		rts		z_list:         rts
.92a8						xt_literal:
.92a8		20 7c d7	jsr $d77c	                jsr underflow_1
.92ab		a0 92		ldy #$92	                ldy #>literal_runtime
.92ad		a9 b6		lda #$b6	                lda #<literal_runtime
.92af		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.92b2		20 de 86	jsr $86de	                jsr xt_comma
.92b5		60		rts		z_literal:      rts
.92b6						literal_runtime:
.92b6		ca		dex		                dex
.92b7		ca		dex		                dex
.92b8		68		pla		                pla             ; LSB
.92b9		85 25		sta $25		                sta tmp1
.92bb		68		pla		                pla             ; MSB
.92bc		85 26		sta $26		                sta tmp1+1
.92be		a0 01		ldy #$01	                ldy #1
.92c0		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.92c2		95 00		sta $00,x	                sta 0,x
.92c4		c8		iny		                iny
.92c5		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.92c7		95 01		sta $01,x	                sta 1,x
.92c9		98		tya		                tya
.92ca		18		clc		                clc
.92cb		65 25		adc $25		                adc tmp1
.92cd		a8		tay		                tay
.92ce		a5 26		lda $26		                lda tmp1+1
.92d0		69 00		adc #$00	                adc #0
.92d2		48		pha		                pha
.92d3		5a		phy		                phy
.92d4		60		rts		                rts
.92d5						xt_load:
.92d5		20 7c d7	jsr $d77c	                jsr underflow_1
.92d8		a0 05		ldy #$05	                ldy #blk_offset+1
.92da		b1 08		lda ($08),y	                lda (up),y
.92dc		48		pha		                pha
.92dd		88		dey		                dey
.92de		b1 08		lda ($08),y	                lda (up),y
.92e0		48		pha		                pha
.92e1		b5 00		lda $00,x	                lda 0,x
.92e3		91 08		sta ($08),y	                sta (up),y
.92e5		c8		iny		                iny
.92e6		b5 01		lda $01,x	                lda 1,x
.92e8		91 08		sta ($08),y	                sta (up),y
.92ea		20 5d 83	jsr $835d	                jsr xt_block
.92ed		ca		dex		                dex
.92ee		ca		dex		                dex
.92ef		a9 04		lda #$04	                lda #4
.92f1		95 01		sta $01,x	                sta 1,x
.92f3		74 00		stz $00,x	                stz 0,x
.92f5		20 e5 8f	jsr $8fe5	                jsr load_evaluate
.92f8		a0 04		ldy #$04	                ldy #blk_offset
.92fa		68		pla		                pla
.92fb		91 08		sta ($08),y	                sta (up),y
.92fd		c8		iny		                iny
.92fe		68		pla		                pla
.92ff		91 08		sta ($08),y	                sta (up),y
.9301		88		dey		                dey
.9302		11 08		ora ($08),y	                ora (up),y
.9304		f0 12		beq $9318	                beq _done
.9306		ca		dex		                dex
.9307		ca		dex		                dex
.9308		a0 04		ldy #$04	                ldy #blk_offset
.930a		b1 08		lda ($08),y	                lda (up),y
.930c		95 00		sta $00,x	                sta 0,x
.930e		c8		iny		                iny
.930f		b1 08		lda ($08),y	                lda (up),y
.9311		95 01		sta $01,x	                sta 1,x
.9313		20 5d 83	jsr $835d	                jsr xt_block
.9316		e8		inx		                inx
.9317		e8		inx		                inx
.9318						_done:
.9318		60		rts		z_load:         rts
.9319						xt_loop:
.9319		ca		dex		                dex
.931a		ca		dex		                dex
.931b		a9 7c		lda #$7c	                lda #<loop_runtime
.931d		95 00		sta $00,x	                sta 0,x
.931f		a9 93		lda #$93	                lda #>loop_runtime
.9321		95 01		sta $01,x	                sta 1,x
.9323		a0 12		ldy #$12	                ldy #loop_runtime_end-loop_runtime
.9325		20 4b 88	jsr $884b	                jsr cmpl_inline_y
.9328		80 0f		bra $9339	                bra xt_loop_common
.932a						xt_plus_loop:
.932a		ca		dex		                dex
.932b		ca		dex		                dex
.932c		a9 8e		lda #$8e	                lda #<plus_loop_runtime
.932e		95 00		sta $00,x	                sta 0,x
.9330		a9 93		lda #$93	                lda #>plus_loop_runtime
.9332		95 01		sta $01,x	                sta 1,x
.9334		a0 1b		ldy #$1b	                ldy #plus_loop_runtime_end-plus_loop_runtime
.9336		20 4b 88	jsr $884b	                jsr cmpl_inline_y
.9339						xt_loop_common:
.9339		20 de 86	jsr $86de	                jsr xt_comma
.933c		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.933e		f0 19		beq $9359	                beq _noleave
.9340						_next:
.9340		a0 01		ldy #$01	                ldy #1
.9342		b1 21		lda ($21),y	                lda (loopleave),y
.9344		48		pha		                pha
.9345		a5 01		lda $01		                lda cp+1
.9347		91 21		sta ($21),y	                sta (loopleave),y
.9349		88		dey		                dey
.934a		b1 21		lda ($21),y	                lda (loopleave),y
.934c		48		pha		                pha
.934d		a5 00		lda $00		                lda cp
.934f		91 21		sta ($21),y	                sta (loopleave),y
.9351		68		pla		                pla
.9352		85 21		sta $21		                sta loopleave
.9354		68		pla		                pla
.9355		85 22		sta $22		                sta loopleave+1
.9357		d0 e7		bne $9340	                bne _next
.9359						_noleave:
.9359		b5 00		lda $00,x	                lda 0,x
.935b		85 21		sta $21		                sta loopleave
.935d		b5 01		lda $01,x	                lda 1,x
.935f		85 22		sta $22		                sta loopleave+1
.9361		a9 6d		lda #$6d	                lda #<xt_unloop
.9363		95 00		sta $00,x	                sta 0,x
.9365		a9 a4		lda #$a4	                lda #>xt_unloop
.9367		95 01		sta $01,x	                sta 1,x
.9369		20 5d 87	jsr $875d	                jsr xt_compile_comma
.936c		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.936e		f0 09		beq $9379	                beq +
.9370		20 88 90	jsr $9088	                jsr xt_here
.9373		20 05 a0	jsr $a005	                jsr xt_swap
.9376		4c ea 9f	jmp $9fea	                jmp xt_store            ; write here as ?DO jmp target and return
.9379		e8		inx		+               inx                     ; drop the ignored word for DO
.937a		e8		inx		                inx
.937b						z_loop:
.937b		60		rts		z_plus_loop:    rts
.937c						loop_runtime:
.937c		e6 20		inc $20		                inc loopidx0        ; increment the LSB of loopindex
.937e		d0 0d		bne $938d	                bne _repeat         ; avoid expensive test most of the time
.9380		a4 1f		ldy $1f		                ldy loopctrl
.9382		b9 01 01	lda $0101,y	_chkv:          lda loopindex+1,y
.9385		1a		inc a		                ina
.9386		c9 80		cmp #$80	                cmp #$80
.9388		f0 06		beq $9390	                beq _repeat+3       ; done?  skip jmp back
.938a		99 01 01	sta $0101,y	                sta loopindex+1,y
.938d						_repeat:
>938d		4c				                .byte OpJMP
.938e						loop_runtime_end:
.938e						plus_loop_runtime:
.938e		18		clc		                clc
.938f		b5 00		lda $00,x	                lda 0,x             ; LSB of step
.9391		65 20		adc $20		                adc loopidx0
.9393		85 20		sta $20		                sta loopidx0
.9395		e8		inx		                inx                 ; dump step from TOS before MSB test
.9396		e8		inx		                inx                 ; since we might skip it
.9397		b5 ff		lda $ff,x	                lda $FF,x           ; MSB of step since 1,x == -1,x+2
.9399		d0 02		bne $939d	                bne _chkv           ; if it's non-zero we have to check
.939b		90 0b		bcc $93a8	                bcc _repeat         ; but if 0 and no carry, we're good
.939d		b8		clv		_chkv:          clv
.939e		a4 1f		ldy $1f		                ldy loopctrl        ; get LCB offset
.93a0		79 01 01	adc $0101,y	                adc loopindex+1,y   ; MSB of index
.93a3		99 01 01	sta $0101,y	                sta loopindex+1,y   ; put MSB of index back on stack
.93a6		70 03		bvs $93ab	                bvs _repeat+3     ; skip over JMP instruction
.93a8						_repeat:
>93a8		4c				                .byte OpJMP
.93a9						plus_loop_runtime_end:
.93a9						xt_lshift:
.93a9		20 81 d7	jsr $d781	                jsr underflow_2
.93ac		b5 00		lda $00,x	                lda 0,x
.93ae		29 0f		and #$0f	                and #%00001111
.93b0		f0 08		beq $93ba	                beq _done
.93b2		a8		tay		                tay
.93b3						_loop:
.93b3		16 02		asl $02,x	                asl 2,x
.93b5		36 03		rol $03,x	                rol 3,x
.93b7		88		dey		                dey
.93b8		d0 f9		bne $93b3	                bne _loop
.93ba						_done:
.93ba		e8		inx		                inx
.93bb		e8		inx		                inx
.93bc		60		rts		z_lshift:       rts
.93bd						xt_m_star:
.93bd		20 81 d7	jsr $d781	                jsr underflow_2
.93c0		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.93c2		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.93c4		48		pha		                pha
.93c5		20 d1 80	jsr $80d1	                jsr xt_abs
.93c8		20 05 a0	jsr $a005	                jsr xt_swap
.93cb		20 d1 80	jsr $80d1	                jsr xt_abs
.93ce		20 27 a4	jsr $a427	                jsr xt_um_star          ; ( d )
.93d1		68		pla		                pla
.93d2		10 03		bpl $93d7	                bpl _done
.93d4		20 b2 8a	jsr $8ab2	                jsr xt_dnegate
.93d7						_done:
.93d7		60		rts		z_m_star:       rts
.93d8						xt_marker:
.93d8		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.93db		a5 02		lda $02		                lda dp
.93dd		48		pha		                pha
.93de		a5 03		lda $03		                lda dp+1
.93e0		48		pha		                pha
.93e1		a5 00		lda $00		                lda cp
.93e3		48		pha		                pha
.93e4		a5 01		lda $01		                lda cp+1
.93e6		48		pha		                pha
.93e7		20 db 88	jsr $88db	                jsr xt_create
.93ea		a5 00		lda $00		                lda cp          ; LSB
.93ec		38		sec		                sec
.93ed		e9 02		sbc #$02	                sbc #2
.93ef		85 00		sta $00		                sta cp
.93f1		a5 01		lda $01		                lda cp+1        ; MSB
.93f3		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.93f5		85 01		sta $01		                sta cp+1
.93f7		a0 94		ldy #$94	                ldy #>marker_runtime
.93f9		a9 16		lda #$16	                lda #<marker_runtime
.93fb		20 c5 d5	jsr $d5c5	                jsr cmpl_word
.93fe		7a		ply		                ply                     ; MSB
.93ff		68		pla		                pla                     ; LSB
.9400		20 c5 d5	jsr $d5c5	                jsr cmpl_word
.9403		7a		ply		                ply                     ; MSB
.9404		68		pla		                pla                     ; LSB
.9405		20 c5 d5	jsr $d5c5	                jsr cmpl_word
.9408		a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.940a						_marker_loop:
.940a		b1 08		lda ($08),y	                lda (up),y
.940c		20 c9 d5	jsr $d5c9	                jsr cmpl_a
.940f		c8		iny		                iny
.9410		98		tya		                tya
.9411		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.9413		d0 f5		bne $940a	                bne _marker_loop
.9415		60		rts		z_marker:       rts
.9416						marker_runtime:
.9416		68		pla		                pla
.9417		85 25		sta $25		                sta tmp1        ; LSB of address
.9419		68		pla		                pla
.941a		85 26		sta $26		                sta tmp1+1      ; MSB of address
.941c		e6 25		inc $25		                inc tmp1
.941e		d0 02		bne $9422	                bne +
.9420		e6 26		inc $26		                inc tmp1+1
.9422						+
.9422		a0 00		ldy #$00	                ldy #0
.9424		b1 25		lda ($25),y	                lda (tmp1),y
.9426		85 00		sta $00		                sta cp
.9428		c8		iny		                iny
.9429		b1 25		lda ($25),y	                lda (tmp1),y
.942b		85 01		sta $01		                sta cp+1
.942d		c8		iny		                iny
.942e		b1 25		lda ($25),y	                lda (tmp1),y
.9430		85 02		sta $02		                sta dp
.9432		c8		iny		                iny
.9433		b1 25		lda ($25),y	                lda (tmp1),y
.9435		85 03		sta $03		                sta dp+1
.9437		a0 04		ldy #$04	                ldy #4
.9439						_marker_restore_loop:
.9439		b1 25		lda ($25),y	                lda (tmp1), y
.943b		91 08		sta ($08),y	                sta (up), y
.943d		c8		iny		                iny
.943e		98		tya		                tya
.943f		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.9441		d0 f6		bne $9439	                bne _marker_restore_loop
.9443		20 d6 d6	jsr $d6d6	                jsr dp_to_current       ; Move the CURRENT DP back.
.9446		60		rts		                rts
.9447						xt_max:
.9447		20 81 d7	jsr $d781	                jsr underflow_2
.944a		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.944c		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.944e		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9450		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9452		50 02		bvc $9456	                bvc _no_overflow
.9454		49 80		eor #$80	                eor #$80        ; complement negative flag
.9456						_no_overflow:
.9456		30 08		bmi $9460	                bmi _keep_nos
.9458		b5 00		lda $00,x	                lda 0,x
.945a		95 02		sta $02,x	                sta 2,x
.945c		b5 01		lda $01,x	                lda 1,x
.945e		95 03		sta $03,x	                sta 3,x
.9460						_keep_nos:
.9460		e8		inx		                inx
.9461		e8		inx		                inx
.9462		60		rts		z_max:          rts
.9463						xt_min:
.9463		20 81 d7	jsr $d781	                jsr underflow_2
.9466		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9468		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.946a		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.946c		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.946e		50 02		bvc $9472	                bvc _no_overflow
.9470		49 80		eor #$80	                eor #$80
.9472						_no_overflow:
.9472		10 08		bpl $947c	                bpl _keep_nos
.9474		b5 00		lda $00,x	                lda 0,x
.9476		95 02		sta $02,x	                sta 2,x
.9478		b5 01		lda $01,x	                lda 1,x
.947a		95 03		sta $03,x	                sta 3,x
.947c						_keep_nos:
.947c		e8		inx		                inx
.947d		e8		inx		                inx
.947e		60		rts		z_min:          rts
.947f						xt_minus:
.947f		20 81 d7	jsr $d781	                jsr underflow_2
.9482		38		sec		                sec
.9483		b5 02		lda $02,x	                lda 2,x         ; LSB
.9485		f5 00		sbc $00,x	                sbc 0,x
.9487		95 02		sta $02,x	                sta 2,x
.9489		b5 03		lda $03,x	                lda 3,x         ; MSB
.948b		f5 01		sbc $01,x	                sbc 1,x
.948d		95 03		sta $03,x	                sta 3,x
.948f		e8		inx		                inx
.9490		e8		inx		                inx
.9491		60		rts		z_minus:        rts
.9492						xt_minus_leading:
.9492		20 81 d7	jsr $d781	                jsr underflow_2
.9495						_loop:
.9495		b5 00		lda $00,x	                lda 0,x
.9497		15 01		ora $01,x	                ora 1,x
.9499		f0 0f		beq $94aa	                beq _done
.949b		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.949d		20 6f d7	jsr $d76f	                jsr is_whitespace
.94a0		90 08		bcc $94aa	                bcc _done
.94a2		20 2b 97	jsr $972b	                jsr xt_one              ; ( addr u 1 )
.94a5		20 7e 9e	jsr $9e7e	                jsr xt_slash_string     ; ( addr+ u-1 )
.94a8		80 eb		bra $9495	                bra _loop
.94aa						_done:
.94aa						z_minus_leading:
.94aa		60		rts		                rts
.94ab						xt_minus_trailing:
.94ab		20 81 d7	jsr $d781	                jsr underflow_2
.94ae		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.94b0		15 01		ora $01,x	                ora 1,x         ; MSB of n
.94b2		f0 33		beq $94e7	                beq _done
.94b4		18		clc		                clc
.94b5		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.94b7		75 00		adc $00,x	                adc 0,x
.94b9		85 25		sta $25		                sta tmp1
.94bb		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.94bd		75 01		adc $01,x	                adc 1,x
.94bf		85 26		sta $26		                sta tmp1+1
.94c1		a5 25		lda $25		                lda tmp1
.94c3		d0 02		bne $94c7	                bne +
.94c5		c6 26		dec $26		                dec tmp1+1
.94c7						+
.94c7		c6 25		dec $25		                dec tmp1
.94c9						_loop:
.94c9		b2 25		lda ($25)	                lda (tmp1)
.94cb		c9 20		cmp #$20	                cmp #AscSP
.94cd		d0 18		bne $94e7	                bne _done
.94cf		a5 25		lda $25		                lda tmp1
.94d1		d0 02		bne $94d5	                bne +
.94d3		c6 26		dec $26		                dec tmp1+1
.94d5						+
.94d5		c6 25		dec $25		                dec tmp1
.94d7		b5 00		lda $00,x	                lda 0,x
.94d9		d0 02		bne $94dd	                bne +
.94db		d6 01		dec $01,x	                dec 1,x
.94dd						+
.94dd		d6 00		dec $00,x	                dec 0,x
.94df		b5 00		lda $00,x	                lda 0,x
.94e1		15 01		ora $01,x	                ora 1,x
.94e3		f0 02		beq $94e7	                beq _done       ; Count has reached zero - we're done!
.94e5		80 e2		bra $94c9	                bra _loop
.94e7						_done:
.94e7						z_minus_trailing:
.94e7		60		rts		                rts
.94e8						xt_mod:
.94e8		20 81 d7	jsr $d781	                jsr underflow_2
.94eb		20 66 9e	jsr $9e66	                jsr xt_slash_mod
.94ee		e8		inx		                inx             ; DROP
.94ef		e8		inx		                inx
.94f0						z_mod:
.94f0		60		rts		                rts
.94f1						xt_move:
.94f1		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.94f3		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.94f5		f0 05		beq $94fc	                beq _lsb                ; wasn't helpful, move to LSB
.94f7		b0 0e		bcs $9507	                bcs _to_move_up         ; we want CMOVE>
.94f9		4c 09 86	jmp $8609	                jmp xt_cmove            ; JSR/RTS
.94fc						_lsb:
.94fc		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.94fe		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.9500		f0 08		beq $950a	                beq _equal              ; LSB is equal as well
.9502		b0 03		bcs $9507	                bcs _to_move_up         ; we want CMOVE>
.9504		4c 09 86	jmp $8609	                jmp xt_cmove            ; JSR/RTS
.9507						_to_move_up:
.9507		4c 44 86	jmp $8644	                jmp xt_cmove_up         ; JSR/RTS
.950a						_equal:
.950a		8a		txa		                txa
.950b		18		clc		                clc
.950c		69 06		adc #$06	                adc #6
.950e		aa		tax		                tax
.950f		60		rts		z_move:         rts
.9510						xt_name_to_int:
.9510		20 7c d7	jsr $d77c	                jsr underflow_1
.9513		b5 00		lda $00,x	                lda 0,x
.9515		18		clc		                clc
.9516		69 04		adc #$04	                adc #4
.9518		85 29		sta $29		                sta tmp3
.951a		b5 01		lda $01,x	                lda 1,x
.951c		90 01		bcc $951f	                bcc _done
.951e		1a		inc a		                ina
.951f						_done:
.951f		85 2a		sta $2a		                sta tmp3+1
.9521		a0 00		ldy #$00	                ldy #0
.9523		b1 29		lda ($29),y	                lda (tmp3),y
.9525		95 00		sta $00,x	                sta 0,x
.9527		c8		iny		                iny
.9528		b1 29		lda ($29),y	                lda (tmp3),y
.952a		95 01		sta $01,x	                sta 1,x
.952c		60		rts		z_name_to_int:  rts
.952d						xt_name_to_string:
.952d		20 7c d7	jsr $d77c	                jsr underflow_1
.9530		ca		dex		                dex
.9531		ca		dex		                dex
.9532		a1 02		lda ($02,x)	                lda (2,x)
.9534		95 00		sta $00,x	                sta 0,x
.9536		74 01		stz $01,x	                stz 1,x
.9538		b5 02		lda $02,x	                lda 2,x         ; LSB
.953a		18		clc		                clc
.953b		69 08		adc #$08	                adc #8
.953d		95 02		sta $02,x	                sta 2,x
.953f		90 02		bcc $9543	                bcc z_name_to_string
.9541		f6 03		inc $03,x	                inc 3,x         ; MSB
.9543						z_name_to_string:
.9543		60		rts		                rts
.9544						xt_nc_limit:
.9544		a9 00		lda #$00	                lda #nc_limit_offset
.9546		4c 26 d6	jmp $d626	                jmp push_upvar_tos
.9549						z_nc_limit:
.9549						xt_negate:
.9549		20 7c d7	jsr $d77c	                jsr underflow_1
.954c		a9 00		lda #$00	        	lda #0
.954e		38		sec		                sec
.954f		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.9551		95 00		sta $00,x	                sta 0,x
.9553		a9 00		lda #$00	                lda #0
.9555		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9557		95 01		sta $01,x	                sta 1,x
.9559		60		rts		z_negate:       rts
.955a						xt_never_native:
.955a		20 c3 d6	jsr $d6c3	                jsr current_to_dp
.955d		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.955f		b1 02		lda ($02),y	                lda (dp),y
.9561		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9563		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9565		91 02		sta ($02),y	                sta (dp),y
.9567						z_never_native:
.9567		60		rts		                rts
.9568						xt_nip:
.9568		20 81 d7	jsr $d781	                jsr underflow_2
.956b		b5 00		lda $00,x	                lda 0,x         ; LSB
.956d		95 02		sta $02,x	                sta 2,x
.956f		b5 01		lda $01,x	                lda 1,x         ; MSB
.9571		95 03		sta $03,x	                sta 3,x
.9573		e8		inx		                inx
.9574		e8		inx		                inx
.9575		60		rts		z_nip:          rts
.9576						xt_not_equals:
.9576		20 81 d7	jsr $d781	                jsr underflow_2
.9579		a0 00		ldy #$00	                ldy #0                  ; default is true
.957b		b5 00		lda $00,x	                lda 0,x                 ; LSB
.957d		d5 02		cmp $02,x	                cmp 2,x
.957f		d0 0a		bne $958b	                bne _not_equal
.9581		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9583		d5 03		cmp $03,x	                cmp 3,x
.9585		d0 04		bne $958b	                bne _not_equal
.9587		a9 ff		lda #$ff	                lda #$FF
.9589		80 01		bra $958c	                bra _done
.958b						_not_equal:
.958b		88		dey		                dey                     ; drop thru to done
.958c						_done:
.958c		98		tya		                tya
.958d		e8		inx		                inx
.958e		e8		inx		                inx
.958f		95 00		sta $00,x	                sta 0,x
.9591		95 01		sta $01,x	                sta 1,x
.9593		60		rts		z_not_equals:   rts
.9594						xt_not_rote:
.9594		20 86 d7	jsr $d786	                jsr underflow_3
.9597		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9599		b5 03		lda $03,x	                lda 3,x
.959b		95 01		sta $01,x	                sta 1,x
.959d		b5 05		lda $05,x	                lda 5,x
.959f		95 03		sta $03,x	                sta 3,x
.95a1		94 05		sty $05,x	                sty 5,x
.95a3		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.95a5		b5 02		lda $02,x	                lda 2,x
.95a7		95 00		sta $00,x	                sta 0,x
.95a9		b5 04		lda $04,x	                lda 4,x
.95ab		95 02		sta $02,x	                sta 2,x
.95ad		94 04		sty $04,x	                sty 4,x
.95af		60		rts		z_not_rote:     rts
.95b0						xt_number:
.95b0		20 81 d7	jsr $d781	                jsr underflow_2
.95b3		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.95b5		a5 18		lda $18		                lda base
.95b7		48		pha		                pha
.95b8		20 e3 a1	jsr $a1e3	                jsr xt_two_dup
.95bb		a1 02		lda ($02,x)	                lda (2,x)
.95bd						_check_dec:
.95bd		c9 23		cmp #$23	                cmp #'#'
.95bf		d0 04		bne $95c5	                bne _check_hex
.95c1		a9 0a		lda #$0a	                lda #10
.95c3		80 42		bra $9607	                bra _base_changed
.95c5						_check_hex:
.95c5		c9 24		cmp #$24	                cmp #'$'
.95c7		d0 04		bne $95cd	                bne _check_binary
.95c9		a9 10		lda #$10	                lda #16
.95cb		80 3a		bra $9607	                bra _base_changed
.95cd						_check_binary:
.95cd		c9 25		cmp #$25	                cmp #'%'
.95cf		d0 04		bne $95d5	                bne _check_char
.95d1		a9 02		lda #$02	                lda #2
.95d3		80 32		bra $9607	                bra _base_changed
.95d5						_check_char:
.95d5		c9 27		cmp #$27	                cmp #"'"
.95d7		d0 3a		bne $9613	                bne _check_minus
.95d9		b5 00		lda $00,x	                lda 0,x         ; Get the length
.95db		c9 03		cmp #$03	                cmp #3
.95dd		d0 26		bne $9605	                bne _not_a_char
.95df		b5 01		lda $01,x	                lda 1,x
.95e1		d0 22		bne $9605	                bne _not_a_char ; No compare needed to check for non-zero.
.95e3		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.95e5		18		clc		                clc
.95e6		69 02		adc #$02	                adc #2          ; length of string
.95e8		85 23		sta $23		                sta tmptos
.95ea		b5 03		lda $03,x	                lda 3,x
.95ec		69 00		adc #$00	                adc #0          ; only need carry
.95ee		85 24		sta $24		                sta tmptos+1
.95f0		b2 23		lda ($23)	                lda (tmptos)
.95f2		c9 27		cmp #$27	                cmp #"'"
.95f4		d0 0f		bne $9605	                bne _not_a_char
.95f6		f6 02		inc $02,x	                inc 2,x
.95f8		d0 02		bne $95fc	                bne +
.95fa		f6 03		inc $03,x	                inc 3,x
.95fc						+
.95fc		a1 02		lda ($02,x)	                lda (2,x)
.95fe		95 02		sta $02,x	                sta 2,x
.9600		74 03		stz $03,x	                stz 3,x
.9602		4c 85 96	jmp $9685	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9605						_not_a_char:
.9605		80 5c		bra $9663	                bra _number_error
.9607						_base_changed:
.9607		85 18		sta $18		                sta base        ; Switch to the new base
.9609		f6 02		inc $02,x	                inc 2,x         ; start one character later
.960b		d0 02		bne $960f	                bne +
.960d		f6 03		inc $03,x	                inc 3,x
.960f						+
.960f		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9611		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9613						_check_minus:
.9613		c9 2d		cmp #$2d	                cmp #'-'
.9615		d0 0c		bne $9623	                bne _check_dot
.9617		a9 80		lda #$80	                lda #$80
.9619		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.961b		f6 02		inc $02,x	                inc 2,x         ; start one character later
.961d		d0 02		bne $9621	                bne +
.961f		f6 03		inc $03,x	                inc 3,x
.9621						+
.9621		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9623						_check_dot:
.9623		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9625		18		clc		                clc
.9626		75 00		adc $00,x	                adc 0,x         ; length of string
.9628		85 23		sta $23		                sta tmptos
.962a		b5 03		lda $03,x	                lda 3,x
.962c		69 00		adc #$00	                adc #0          ; only need carry
.962e		85 24		sta $24		                sta tmptos+1
.9630		a5 23		lda $23		                lda tmptos
.9632		d0 02		bne $9636	                bne +
.9634		c6 24		dec $24		                dec tmptos+1
.9636						+
.9636		c6 23		dec $23		                dec tmptos
.9638		b2 23		lda ($23)	                lda (tmptos)
.963a		c9 2e		cmp #$2e	                cmp #'.'
.963c		d0 04		bne $9642	                bne _main
.963e		e6 1e		inc $1e		                inc tmpdsp
.9640		d6 00		dec $00,x	                dec 0,x
.9642						_main:
.9642		ca		dex		                dex
.9643		ca		dex		                dex
.9644		ca		dex		                dex
.9645		ca		dex		                dex
.9646		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9648		95 00		sta $00,x	                sta 0,x
.964a		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.964c		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.964e		95 02		sta $02,x	                sta 2,x
.9650		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9652		95 03		sta $03,x	                sta 3,x
.9654		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9656		74 05		stz $05,x	                stz 5,x
.9658		74 06		stz $06,x	                stz 6,x
.965a		74 07		stz $07,x	                stz 7,x
.965c		20 e8 a0	jsr $a0e8	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.965f		b5 00		lda $00,x	                lda 0,x
.9661		f0 1e		beq $9681	                beq _all_converted
.9663						_number_error:
.9663		20 db a1	jsr $a1db	                jsr xt_two_drop ; >NUMBER modified addr u
.9666		20 db a1	jsr $a1db	                jsr xt_two_drop ; ud   (partially converted number)
.9669		a9 3e		lda #$3e	                lda #'>'
.966b		20 7b 8d	jsr $8d7b	                jsr emit_a
.966e		20 2e a3	jsr $a32e	                jsr xt_type
.9671		a9 3c		lda #$3c	                lda #'<'
.9673		20 7b 8d	jsr $8d7b	                jsr emit_a
.9676		20 7b 9f	jsr $9f7b	                jsr xt_space
.9679		68		pla		                pla
.967a		85 18		sta $18		                sta base
.967c		a9 08		lda #$08	                lda #err_syntax
.967e		4c 92 d7	jmp $d792	                jmp error
.9681						_all_converted:
.9681		e8		inx		                inx ; Drop the current addr u
.9682		e8		inx		                inx
.9683		e8		inx		                inx
.9684		e8		inx		                inx
.9685						_drop_original_string:
.9685		20 a9 a2	jsr $a2a9	                jsr xt_two_swap  ; Drop the original addr u
.9688		20 db a1	jsr $a1db	                jsr xt_two_drop  ; (was saved for unknown word error message)
.968b		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.968d		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.968f		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9690		f0 0a		beq $969c	                beq _single
.9692		98		tya		                tya
.9693		04 1c		tsb $1c		                tsb status
.9695		90 0f		bcc $96a6	                bcc _done       ; no minus, all done
.9697		20 b2 8a	jsr $8ab2	                jsr xt_dnegate
.969a		80 0a		bra $96a6	                bra _done
.969c						_single:
.969c		e8		inx		                inx
.969d		e8		inx		                inx
.969e		98		tya		                tya
.969f		14 1c		trb $1c		                trb status
.96a1		90 03		bcc $96a6	                bcc _done       ; no minus, all done
.96a3		20 49 95	jsr $9549	                jsr xt_negate
.96a6						_done:
.96a6		68		pla		                pla
.96a7		85 18		sta $18		                sta base
.96a9		60		rts		z_number:       rts
.96aa						xt_number_sign:
.96aa		20 81 d7	jsr $d781	                jsr underflow_2         ; double number
.96ad		20 2e 83	jsr $832e	                jsr xt_base
.96b0		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; ( ud1 base )
.96b3		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >r
.96b6		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; 0
.96b9		20 9e 99	jsr $999e	                jsr xt_r_fetch          ; r@
.96bc		20 e5 a3	jsr $a3e5	                jsr xt_um_slash_mod     ; um/mod
.96bf		20 71 9a	jsr $9a71	                jsr xt_rot              ; rot
.96c2		20 71 9a	jsr $9a71	                jsr xt_rot              ; rot
.96c5		20 b3 99	jsr $99b3	                jsr xt_r_from           ; r>
.96c8		20 e5 a3	jsr $a3e5	                jsr xt_um_slash_mod     ; um/mod
.96cb		20 71 9a	jsr $9a71	                jsr xt_rot              ; rot
.96ce		20 71 9a	jsr $9a71	                jsr xt_rot              ; ( ud rem )
.96d1		b5 00		lda $00,x	                lda 0,x
.96d3		a8		tay		                tay
.96d4		b9 dd d2	lda $d2dd,y	                lda s_abc_upper,y
.96d7		95 00		sta $00,x	                sta 0,x
.96d9		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.96db		20 ed 90	jsr $90ed	                jsr xt_hold
.96de						z_number_sign:
.96de		60		rts		                rts
.96df						xt_number_sign_greater:
.96df		20 81 d7	jsr $d781	                jsr underflow_2         ; double number
.96e2		a5 2b		lda $2b		                lda tohold
.96e4		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.96e6		95 02		sta $02,x	                sta 2,x
.96e8		a5 2c		lda $2c		                lda tohold+1
.96ea		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.96ec		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.96ee		20 c4 97	jsr $97c4	                jsr xt_pad      ; ( addr addr pad )
.96f1		38		sec		                sec
.96f2		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.96f4		f5 02		sbc $02,x	                sbc 2,x
.96f6		95 02		sta $02,x	                sta 2,x
.96f8		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.96fa		f5 03		sbc $03,x	                sbc 3,x
.96fc		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.96fe		e8		inx		                inx
.96ff		e8		inx		                inx
.9700						z_number_sign_greater:
.9700		60		rts		                rts
.9701						xt_number_sign_s:
.9701		20 81 d7	jsr $d781	                jsr underflow_2
.9704						_loop:
.9704		20 aa 96	jsr $96aa	                jsr xt_number_sign
.9707		b5 00		lda $00,x	                lda 0,x
.9709		15 01		ora $01,x	                ora 1,x
.970b		15 02		ora $02,x	                ora 2,x
.970d		15 03		ora $03,x	                ora 3,x
.970f		d0 f3		bne $9704	                bne _loop
.9711						z_number_sign_s:
.9711		60		rts		                rts
.9712						xt_of:
.9712		a0 97		ldy #$97	                ldy #>xt_over
.9714		a9 b6		lda #$b6	                lda #<xt_over
.9716		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.9719		a0 8e		ldy #$8e	                ldy #>xt_equal
.971b		a9 53		lda #$53	                lda #<xt_equal
.971d		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.9720		20 14 91	jsr $9114	                jsr xt_if
.9723		a0 8c		ldy #$8c	                ldy #>xt_drop
.9725		a9 86		lda #$86	                lda #<xt_drop
.9727		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.972a		60		rts		z_of:           rts
.972b						xt_editor_wordlist:
.972b						xt_one:
.972b		ca		dex		                dex
.972c		ca		dex		                dex
.972d		a9 01		lda #$01	                lda #1
.972f		95 00		sta $00,x	                sta 0,x
.9731		74 01		stz $01,x	                stz 1,x
.9733						z_editor_wordlist:
.9733						z_one:
.9733		60		rts		                rts
.9734						xt_one_minus:
.9734		20 7c d7	jsr $d77c	                jsr underflow_1
.9737		b5 00		lda $00,x	                lda 0,x
.9739		d0 02		bne $973d	                bne +
.973b		d6 01		dec $01,x	                dec 1,x
.973d						+
.973d		d6 00		dec $00,x	                dec 0,x
.973f		60		rts		z_one_minus:    rts
.9740						xt_char_plus:
.9740						xt_one_plus:
.9740		20 7c d7	jsr $d77c	                jsr underflow_1
.9743		f6 00		inc $00,x	                inc 0,x
.9745		d0 02		bne $9749	                bne _done
.9747		f6 01		inc $01,x	                inc 1,x
.9749						_done:
.9749						z_char_plus:
.9749		60		rts		z_one_plus:     rts
.974a						xt_only:
.974a		ca		dex		                dex
.974b		ca		dex		                dex
.974c		a9 ff		lda #$ff	                lda #$FF
.974e		95 00		sta $00,x	                sta 0,x
.9750		95 01		sta $01,x	                sta 1,x
.9752		20 c8 9b	jsr $9bc8	                jsr xt_set_order
.9755		60		rts		z_only:         rts
.9756						xt_or:
.9756		20 81 d7	jsr $d781	                jsr underflow_2
.9759		b5 00		lda $00,x	                lda 0,x
.975b		15 02		ora $02,x	                ora 2,x
.975d		95 02		sta $02,x	                sta 2,x
.975f		b5 01		lda $01,x	                lda 1,x
.9761		15 03		ora $03,x	                ora 3,x
.9763		95 03		sta $03,x	                sta 3,x
.9765		e8		inx		                inx
.9766		e8		inx		                inx
.9767		60		rts		z_or:           rts
.9768						xt_order:
.9768		20 d5 88	jsr $88d5	                jsr xt_cr
.976b		20 4a 90	jsr $904a	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.976e		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9770		f0 1e		beq $9790	                beq _drop_done
.9772						_have_wordlists:
.9772		a8		tay		                tay
.9773						_loop:
.9773		e8		inx		                inx
.9774		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9775		b5 00		lda $00,x	                lda 0,x
.9777		5a		phy		                phy
.9778		20 93 97	jsr $9793	                jsr order_print_wid_string   ; internal helper function
.977b		7a		ply		                ply
.977c		88		dey		                dey
.977d		d0 f4		bne $9773	                bne _loop
.977f		20 7b 9f	jsr $9f7b	                jsr xt_space
.9782		20 7b 9f	jsr $9f7b	                jsr xt_space
.9785		20 3f 90	jsr $903f	                jsr xt_get_current      ; ( wid )
.9788		b5 00		lda $00,x	                lda 0,x
.978a		20 93 97	jsr $9793	                jsr order_print_wid_string
.978d		20 d5 88	jsr $88d5	                jsr xt_cr
.9790						_drop_done:
.9790		e8		inx		                inx
.9791		e8		inx		                inx
.9792						z_order:
.9792		60		rts		                rts
.9793						order_print_wid_string:
.9793		c9 04		cmp #$04	                cmp #4
.9795		90 09		bcc $97a0	                bcc _output_string      ; less than 4, print a real string
.9797		ca		dex		                dex
.9798		ca		dex		                dex
.9799		95 00		sta $00,x	                sta 0,x
.979b		74 01		stz $01,x	                stz 1,x
.979d		4c 59 a3	jmp $a359	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.97a0						_output_string:
.97a0		a8		tay		                tay
.97a1		b9 a7 97	lda $97a7,y	                lda _wid_data,y
.97a4		4c b8 d7	jmp $d7b8	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.97a7						_wid_data:
>97a7		04				        .byte str_wid_forth            ; WID 0: "Forth"
>97a8		05				        .byte str_wid_editor           ; WID 1: "Editor"
>97a9		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>97aa		07				        .byte str_wid_root             ; WID 3: "Root"
.97ab						xt_output:
.97ab		ca		dex		                dex
.97ac		ca		dex		                dex
.97ad		a9 12		lda #$12	                lda #<output
.97af		95 00		sta $00,x	                sta 0,x
.97b1		a9 00		lda #$00	                lda #>output
.97b3		95 01		sta $01,x	                sta 1,x
.97b5		60		rts		z_output:       rts
.97b6						xt_over:
.97b6		20 81 d7	jsr $d781	                jsr underflow_2
.97b9		ca		dex		                dex
.97ba		ca		dex		                dex
.97bb		b5 04		lda $04,x	                lda 4,x         ; LSB
.97bd		95 00		sta $00,x	                sta 0,x
.97bf		b5 05		lda $05,x	                lda 5,x         ; MSB
.97c1		95 01		sta $01,x	                sta 1,x
.97c3		60		rts		z_over:         rts
.97c4						xt_pad:
.97c4		ca		dex		                dex
.97c5		ca		dex		                dex
.97c6		a5 00		lda $00		                lda cp
.97c8		18		clc		                clc
.97c9		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.97cb		95 00		sta $00,x	                sta 0,x
.97cd		a5 01		lda $01		                lda cp+1
.97cf		69 00		adc #$00	                adc #0          ; only need carry
.97d1		95 01		sta $01,x	                sta 1,x
.97d3		60		rts		z_pad:          rts
.97d4						xt_page:
.97d4		a9 1b		lda #$1b	                lda #AscESC
.97d6		20 7b 8d	jsr $8d7b	                jsr emit_a
.97d9		a9 5b		lda #$5b	                lda #'['
.97db		20 7b 8d	jsr $8d7b	                jsr emit_a
.97de		a9 32		lda #$32	                lda #'2'
.97e0		20 7b 8d	jsr $8d7b	                jsr emit_a
.97e3		a9 4a		lda #$4a	                lda #'J'
.97e5		20 7b 8d	jsr $8d7b	                jsr emit_a
.97e8		20 e4 a5	jsr $a5e4	                jsr xt_zero
.97eb		20 e4 a5	jsr $a5e4	                jsr xt_zero
.97ee		20 d5 82	jsr $82d5	                jsr xt_at_xy
.97f1		60		rts		z_page:         rts
.97f2						xt_paren:
.97f2		ca		dex		                dex
.97f3		ca		dex		                dex
.97f4		a9 29		lda #$29	                lda #41     ; Right parenthesis
.97f6		95 00		sta $00,x	                sta 0,x
.97f8		74 01		stz $01,x	                stz 1,x
.97fa		20 5d 98	jsr $985d	                jsr xt_parse
.97fd		e8		inx		                inx
.97fe		e8		inx		                inx
.97ff		e8		inx		                inx
.9800		e8		inx		                inx
.9801		60		rts		z_paren:        rts
.9802						xt_parse_name:
.9802		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.9804		38		sec		                sec
.9805		e5 10		sbc $10		                sbc toin
.9807		85 25		sta $25		                sta tmp1
.9809		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.980b		e5 11		sbc $11		                sbc toin+1
.980d		85 26		sta $26		                sta tmp1+1
.980f		a5 25		lda $25		                lda tmp1
.9811		05 26		ora $26		                ora tmp1+1
.9813		f0 28		beq $983d	                beq _empty_line
.9815		a5 0c		lda $0c		                lda cib
.9817		18		clc		                clc
.9818		65 10		adc $10		                adc toin
.981a		85 27		sta $27		                sta tmp2                ; LSB of first character
.981c		a5 0d		lda $0d		                lda cib+1
.981e		65 11		adc $11		                adc toin+1
.9820		85 28		sta $28		                sta tmp2+1              ; MSB
.9822						_skip_loop:
.9822		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.9824		20 6f d7	jsr $d76f	                jsr is_whitespace
.9827		90 1f		bcc $9848	                bcc _char_found
.9829		e6 27		inc $27		                inc tmp2
.982b		d0 02		bne $982f	                bne +
.982d		e6 28		inc $28		                inc tmp2+1
.982f						+
.982f		a5 25		lda $25		                lda tmp1
.9831		d0 02		bne $9835	                bne +
.9833		c6 26		dec $26		                dec tmp1+1
.9835		c6 25		dec $25		+               dec tmp1
.9837		a5 25		lda $25		                lda tmp1
.9839		05 26		ora $26		                ora tmp1+1
.983b		d0 e5		bne $9822	                bne _skip_loop          ; fall through if empty line
.983d						_empty_line:
.983d		ca		dex		                dex
.983e		ca		dex		                dex
.983f		ca		dex		                dex
.9840		ca		dex		                dex
.9841		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.9843		74 01		stz $01,x	                stz 1,x
.9845		4c f2 98	jmp $98f2	                jmp z_parse_name        ; skip over PARSE
.9848						_char_found:
.9848		a5 27		lda $27		                lda tmp2
.984a		38		sec		                sec
.984b		e5 0c		sbc $0c		                sbc cib
.984d		85 10		sta $10		                sta toin
.984f		a5 28		lda $28		                lda tmp2+1
.9851		e5 0d		sbc $0d		                sbc cib+1
.9853		85 11		sta $11		                sta toin+1
.9855		ca		dex		                dex
.9856		ca		dex		                dex
.9857		a9 20		lda #$20	                lda #AscSP
.9859		95 00		sta $00,x	                sta 0,x
.985b		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.985d						xt_parse:
.985d		20 7c d7	jsr $d77c	                jsr underflow_1
.9860		a5 0e		lda $0e		                lda ciblen
.9862		05 0f		ora $0f		                ora ciblen+1
.9864		f0 0c		beq $9872	                beq _abort_parse
.9866		a5 11		lda $11		                lda toin+1              ; MSB
.9868		c5 0f		cmp $0f		                cmp ciblen+1
.986a		90 0e		bcc $987a	                bcc _go_parse           ; unsigned comparison
.986c		a5 10		lda $10		                lda toin                ; LSB
.986e		c5 0e		cmp $0e		                cmp ciblen
.9870		90 08		bcc $987a	                bcc _go_parse
.9872						_abort_parse:
.9872		ca		dex		                dex
.9873		ca		dex		                dex
.9874		74 00		stz $00,x	                stz 0,x
.9876		74 01		stz $01,x	                stz 1,x
.9878		80 78		bra $98f2	                bra _done
.987a						_go_parse:
.987a		b5 00		lda $00,x	                lda 0,x
.987c		85 23		sta $23		                sta tmptos
.987e		ca		dex		                dex
.987f		ca		dex		                dex
.9880		a5 0c		lda $0c		                lda cib
.9882		18		clc		                clc
.9883		65 10		adc $10		                adc toin        ; LSB
.9885		85 25		sta $25		                sta tmp1
.9887		85 27		sta $27		                sta tmp2
.9889		95 02		sta $02,x	                sta 2,x
.988b		a5 0d		lda $0d		                lda cib+1
.988d		65 11		adc $11		                adc toin+1      ; MSB
.988f		85 26		sta $26		                sta tmp1+1
.9891		85 28		sta $28		                sta tmp2+1
.9893		95 03		sta $03,x	                sta 3,x
.9895		a5 0c		lda $0c		                lda cib
.9897		18		clc		                clc
.9898		65 0e		adc $0e		                adc ciblen
.989a		85 29		sta $29		                sta tmp3
.989c		a5 0d		lda $0d		                lda cib+1
.989e		65 0f		adc $0f		                adc ciblen+1
.98a0		85 2a		sta $2a		                sta tmp3+1
.98a2		64 24		stz $24		                stz tmptos+1
.98a4						_loop:
.98a4		a5 27		lda $27		                lda tmp2
.98a6		c5 29		cmp $29		                cmp tmp3
.98a8		d0 06		bne $98b0	                bne _not_empty
.98aa		a5 28		lda $28		                lda tmp2+1
.98ac		c5 2a		cmp $2a		                cmp tmp3+1
.98ae		f0 1d		beq $98cd	                beq _eol
.98b0						_not_empty:
.98b0		b2 27		lda ($27)	                lda (tmp2)
.98b2		a4 23		ldy $23		                ldy tmptos
.98b4		c0 20		cpy #$20	                cpy #AscSP
.98b6		d0 07		bne $98bf	                bne _not_whitespace
.98b8		20 6f d7	jsr $d76f	                jsr is_whitespace
.98bb		90 02		bcc $98bf	                bcc _not_whitespace
.98bd		80 0c		bra $98cb	                bra _found_delimiter
.98bf						_not_whitespace:
.98bf		c5 23		cmp $23		                cmp tmptos
.98c1		f0 08		beq $98cb	                beq _found_delimiter
.98c3		e6 27		inc $27		                inc tmp2
.98c5		d0 dd		bne $98a4	                bne _loop
.98c7		e6 28		inc $28		                inc tmp2+1
.98c9		80 d9		bra $98a4	                bra _loop
.98cb						_found_delimiter:
.98cb		e6 24		inc $24		                inc tmptos+1
.98cd						_eol:
.98cd		a5 27		lda $27		                lda tmp2
.98cf		38		sec		                sec
.98d0		e5 25		sbc $25		                sbc tmp1
.98d2		95 00		sta $00,x	                sta 0,x
.98d4		a5 28		lda $28		                lda tmp2+1
.98d6		e5 26		sbc $26		                sbc tmp1+1
.98d8		95 01		sta $01,x	                sta 1,x
.98da		a5 27		lda $27		                lda tmp2
.98dc		38		sec		                sec
.98dd		e5 0c		sbc $0c		                sbc cib
.98df		85 10		sta $10		                sta toin
.98e1		a5 28		lda $28		                lda tmp2+1
.98e3		e5 0d		sbc $0d		                sbc cib+1
.98e5		85 11		sta $11		                sta toin+1
.98e7		a5 10		lda $10		                lda toin
.98e9		18		clc		                clc
.98ea		65 24		adc $24		                adc tmptos+1
.98ec		85 10		sta $10		                sta toin
.98ee		90 02		bcc $98f2	                bcc +
.98f0		e6 11		inc $11		                inc toin+1
.98f2						+
.98f2						_done:
.98f2						z_parse_name:
.98f2		60		rts		z_parse:        rts
.98f3						xt_pick:
.98f3		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.98f5		8a		txa		                txa
.98f6		75 00		adc $00,x	                adc 0,x
.98f8		a8		tay		                tay
.98f9		b9 02 00	lda $0002,y	                lda 0002,y
.98fc		95 00		sta $00,x	                sta 0,x
.98fe		b9 03 00	lda $0003,y	                lda 0003,y
.9901		95 01		sta $01,x	                sta 1,x
.9903		60		rts		z_pick:         rts
.9904						xt_plus:
.9904		20 81 d7	jsr $d781	                jsr underflow_2
.9907		18		clc		                clc
.9908		b5 00		lda $00,x	                lda 0,x         ; LSB
.990a		75 02		adc $02,x	                adc 2,x
.990c		95 02		sta $02,x	                sta 2,x
.990e		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.9910		75 03		adc $03,x	                adc 3,x
.9912		95 03		sta $03,x	                sta 3,x
.9914		e8		inx		                inx
.9915		e8		inx		                inx
.9916		60		rts		z_plus:         rts
.9917						xt_plus_store:
.9917		20 81 d7	jsr $d781	                jsr underflow_2
.991a		b5 00		lda $00,x	                lda 0,x
.991c		85 25		sta $25		                sta tmp1
.991e		b5 01		lda $01,x	                lda 1,x
.9920		85 26		sta $26		                sta tmp1+1
.9922		a0 00		ldy #$00	                ldy #0          ; LSB
.9924		b1 25		lda ($25),y	                lda (tmp1),y
.9926		18		clc		                clc
.9927		75 02		adc $02,x	                adc 2,x
.9929		91 25		sta ($25),y	                sta (tmp1),y
.992b		c8		iny		                iny             ; MSB
.992c		b1 25		lda ($25),y	                lda (tmp1),y
.992e		75 03		adc $03,x	                adc 3,x
.9930		91 25		sta ($25),y	                sta (tmp1),y
.9932		e8		inx		                inx
.9933		e8		inx		                inx
.9934		e8		inx		                inx
.9935		e8		inx		                inx
.9936		60		rts		z_plus_store:   rts
.9937						xt_postpone:
.9937		20 02 98	jsr $9802	                jsr xt_parse_name               ; ( -- addr n )
.993a		b5 00		lda $00,x	                lda 0,x
.993c		15 01		ora $01,x	                ora 1,x
.993e		d0 05		bne $9945	                bne +
.9940		a9 05		lda #$05	                lda #err_noname
.9942		4c 92 d7	jmp $d792	                jmp error
.9945						+
.9945		20 59 8f	jsr $8f59	                jsr xt_find_name                ; ( -- nt | 0 )
.9948		d0 05		bne $994f	                bne +
.994a		a9 05		lda #$05	                lda #err_noname
.994c		4c 92 d7	jmp $d792	                jmp error
.994f						+
.994f		b5 00		lda $00,x	                lda 0,x
.9951		85 25		sta $25		                sta tmp1
.9953		b5 01		lda $01,x	                lda 1,x
.9955		85 26		sta $26		                sta tmp1+1
.9957		20 10 95	jsr $9510	                jsr xt_name_to_int              ; ( nt -- xt )
.995a		e6 25		inc $25		                inc tmp1
.995c		d0 02		bne $9960	                bne +
.995e		e6 26		inc $26		                inc tmp1+1
.9960						+
.9960		b2 25		lda ($25)	                lda (tmp1)
.9962		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9964		f0 05		beq $996b	                beq _not_immediate
.9966		20 5d 87	jsr $875d	                jsr xt_compile_comma
.9969		80 0a		bra $9975	                bra _done
.996b						_not_immediate:
.996b		20 a8 92	jsr $92a8	                jsr xt_literal
.996e		a0 87		ldy #$87	                ldy #>xt_compile_comma
.9970		a9 5d		lda #$5d	                lda #<xt_compile_comma
.9972		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.9975						_done:
.9975		60		rts		z_postpone:     rts
.9976						xt_previous:
.9976		20 4a 90	jsr $904a	                jsr xt_get_order
.9979		20 68 95	jsr $9568	                jsr xt_nip
.997c		20 34 97	jsr $9734	                jsr xt_one_minus
.997f		20 c8 9b	jsr $9bc8	                jsr xt_set_order
.9982		60		rts		z_previous:     rts
.9983						xt_question:
.9983		20 fe 8e	jsr $8efe	                jsr xt_fetch
.9986		20 8e 8b	jsr $8b8e	                jsr xt_dot
.9989		60		rts		z_question:     rts
.998a						xt_question_dup:
.998a		20 7c d7	jsr $d77c	                jsr underflow_1
.998d		b5 00		lda $00,x	                lda 0,x
.998f		15 01		ora $01,x	                ora 1,x
.9991		f0 0a		beq $999d	                beq _done
.9993		ca		dex		                dex
.9994		ca		dex		                dex
.9995		b5 02		lda $02,x	                lda 2,x
.9997		95 00		sta $00,x	                sta 0,x
.9999		b5 03		lda $03,x	                lda 3,x
.999b		95 01		sta $01,x	                sta 1,x
.999d						_done:
.999d		60		rts		z_question_dup: rts
.999e						xt_r_fetch:
.999e		7a		ply		                ply             ; LSB
.999f		84 25		sty $25		                sty tmp1
.99a1		7a		ply		                ply             ; MSB
.99a2		ca		dex		                dex
.99a3		ca		dex		                dex
.99a4		68		pla		                pla             ; LSB
.99a5		95 00		sta $00,x	                sta 0,x
.99a7		68		pla		                pla             ; MSB
.99a8		95 01		sta $01,x	                sta 1,x
.99aa		48		pha		                pha
.99ab		b5 00		lda $00,x	                lda 0,x
.99ad		48		pha		                pha
.99ae		5a		phy		                phy             ; MSB
.99af		a4 25		ldy $25		                ldy tmp1
.99b1		5a		phy		                phy             ; LSB
.99b2		60		rts		z_r_fetch:      rts
.99b3						xt_r_from:
.99b3		68		pla		                pla             ; LSB
.99b4		85 23		sta $23		                sta tmptos
.99b6		7a		ply		                ply             ; MSB
.99b7		ca		dex		                dex
.99b8		ca		dex		                dex
.99b9		68		pla		                pla             ; LSB
.99ba		95 00		sta $00,x	                sta 0,x
.99bc		68		pla		                pla             ; MSB
.99bd		95 01		sta $01,x	                sta 1,x
.99bf		5a		phy		                phy             ; MSB
.99c0		a5 23		lda $23		                lda tmptos
.99c2		48		pha		                pha             ; LSB
.99c3		60		rts		z_r_from:       rts
.99c4						xt_r_to_input:
.99c4		68		pla		                pla
.99c5		85 25		sta $25		                sta tmp1
.99c7		68		pla		                pla
.99c8		85 26		sta $26		                sta tmp1+1
.99ca		a0 00		ldy #$00	                ldy #0
.99cc						_loop:
.99cc		68		pla		                pla
.99cd		99 0a 00	sta $000a,y	                sta insrc,y
.99d0		c8		iny		                iny
.99d1		c0 08		cpy #$08	                cpy #8
.99d3		d0 f7		bne $99cc	                bne _loop
.99d5		a5 26		lda $26		                lda tmp1+1
.99d7		48		pha		                pha
.99d8		a5 25		lda $25		                lda tmp1
.99da		48		pha		                pha
.99db		60		rts		z_r_to_input: 	rts
.99dc						xt_recurse:
.99dc		a0 00		ldy #$00	                ldy #0
.99de		a9 20		lda #$20	                lda #OpJSR
.99e0		91 00		sta ($00),y	                sta (cp),y
.99e2		c8		iny		                iny
.99e3		24 1c		bit $1c		                bit status
.99e5		70 0c		bvs $99f3	                bvs _nt_in_workword
.99e7		a5 06		lda $06		                lda workword
.99e9		91 00		sta ($00),y	                sta (cp),y
.99eb		c8		iny		                iny
.99ec		a5 07		lda $07		                lda workword+1
.99ee		91 00		sta ($00),y	                sta (cp),y
.99f0		c8		iny		                iny
.99f1		80 1b		bra $9a0e	                bra _update_cp
.99f3						_nt_in_workword:
.99f3		a5 06		lda $06		                lda workword            ; LSB
.99f5		18		clc		                clc
.99f6		69 04		adc #$04	                adc #4
.99f8		85 25		sta $25		                sta tmp1
.99fa		a5 07		lda $07		                lda workword+1          ; MSB
.99fc		69 00		adc #$00	                adc #0
.99fe		85 26		sta $26		                sta tmp1+1
.9a00		b2 25		lda ($25)	                lda (tmp1)
.9a02		91 00		sta ($00),y	                sta (cp),y
.9a04		5a		phy		                phy
.9a05		a0 01		ldy #$01	                ldy #1
.9a07		b1 25		lda ($25),y	                lda (tmp1),y
.9a09		7a		ply		                ply
.9a0a		c8		iny		                iny
.9a0b		91 00		sta ($00),y	                sta (cp),y
.9a0d		c8		iny		                iny
.9a0e						_update_cp:
.9a0e		98		tya		                tya
.9a0f		18		clc		                clc
.9a10		65 00		adc $00		                adc cp
.9a12		85 00		sta $00		                sta cp
.9a14		90 02		bcc $9a18	                bcc _done
.9a16		e6 01		inc $01		                inc cp+1
.9a18						_done:
.9a18		60		rts		z_recurse:      rts
.9a19						xt_refill:
.9a19		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.9a1b		d0 2d		bne $9a4a	                bne _src_not_kbd
.9a1d		ca		dex		                dex
.9a1e		ca		dex		                dex
.9a1f		ca		dex		                dex
.9a20		ca		dex		                dex
.9a21		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.9a23		95 02		sta $02,x	                sta 2,x
.9a25		a5 0d		lda $0d		                lda cib+1
.9a27		95 03		sta $03,x	                sta 3,x
.9a29		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.9a2b		64 0f		stz $0f		                stz ciblen+1
.9a2d		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9a2f		95 00		sta $00,x	                sta 0,x
.9a31		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9a33		20 e6 80	jsr $80e6	                jsr xt_accept           ; ( addr n1 -- n2)
.9a36		b5 00		lda $00,x	                lda 0,x
.9a38		85 0e		sta $0e		                sta ciblen
.9a3a		b5 01		lda $01,x	                lda 1,x
.9a3c		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.9a3e		64 10		stz $10		                stz toin
.9a40		64 11		stz $11		                stz toin+1
.9a42		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9a44		95 00		sta $00,x	                sta 0,x
.9a46		95 01		sta $01,x	                sta 1,x
.9a48		80 10		bra $9a5a	                bra _done
.9a4a						_src_not_kbd:
.9a4a		1a		inc a		                ina
.9a4b		d0 08		bne $9a55	                bne _src_not_string
.9a4d		ca		dex		                dex
.9a4e		ca		dex		                dex
.9a4f		74 00		stz $00,x	                stz 0,x
.9a51		74 01		stz $01,x	                stz 1,x
.9a53		80 05		bra $9a5a	                bra z_refill
.9a55						_src_not_string:
.9a55		a9 01		lda #$01	                lda #err_badsource
.9a57		4c 92 d7	jmp $d792	                jmp error
.9a5a						_done:
.9a5a		60		rts		z_refill:       rts
.9a5b						xt_repeat:
.9a5b		20 21 82	jsr $8221	                jsr xt_again
.9a5e		4c 25 8d	jmp $8d25	                jmp xt_then
.9a61						z_repeat:
.9a61						xt_right_bracket:
.9a61		a9 ff		lda #$ff	                lda #$FF
.9a63		85 1a		sta $1a		                sta state
.9a65		85 1b		sta $1b		                sta state+1
.9a67						z_right_bracket:
.9a67		60		rts		                rts
.9a68						xt_root_wordlist:
.9a68		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9a69		ca		dex		                dex
.9a6a		a9 03		lda #$03	                lda #3
.9a6c		95 00		sta $00,x	                sta 0,x
.9a6e		74 01		stz $01,x	                stz 1,x
.9a70						z_root_wordlist:
.9a70		60		rts		                rts
.9a71						xt_rot:
.9a71		20 86 d7	jsr $d786	                jsr underflow_3
.9a74		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9a76		b5 03		lda $03,x	                lda 3,x
.9a78		95 05		sta $05,x	                sta 5,x
.9a7a		b5 01		lda $01,x	                lda 1,x
.9a7c		95 03		sta $03,x	                sta 3,x
.9a7e		94 01		sty $01,x	                sty 1,x
.9a80		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9a82		b5 02		lda $02,x	                lda 2,x
.9a84		95 04		sta $04,x	                sta 4,x
.9a86		b5 00		lda $00,x	                lda 0,x
.9a88		95 02		sta $02,x	                sta 2,x
.9a8a		94 00		sty $00,x	                sty 0,x
.9a8c		60		rts		z_rot:          rts
.9a8d						xt_rshift:
.9a8d		20 81 d7	jsr $d781	                jsr underflow_2
.9a90		b5 00		lda $00,x	                lda 0,x
.9a92		29 0f		and #$0f	                and #%00001111
.9a94		f0 08		beq $9a9e	                beq _done               ; if 0 shifts, quit
.9a96		a8		tay		                tay
.9a97						_loop:
.9a97		56 03		lsr $03,x	                lsr 3,x
.9a99		76 02		ror $02,x	                ror 2,x
.9a9b		88		dey		                dey
.9a9c		d0 f9		bne $9a97	                bne _loop
.9a9e						_done:
.9a9e		e8		inx		                inx
.9a9f		e8		inx		                inx
.9aa0		60		rts		z_rshift:       rts
.9aa1						xt_s_backslash_quote:
.9aa1		a9 ff		lda #$ff	                lda #$FF
.9aa3		85 27		sta $27		                sta tmp2
.9aa5		64 28		stz $28		                stz tmp2+1
.9aa7		20 00 9c	jsr $9c00	                jsr s_quote_start
.9aaa						_done:
.9aaa						z_s_backslash_quote:
.9aaa		60		rts		                rts
.9aab						convert_hex_value:
.9aab		c9 41		cmp #$41	        cmp #'A'
.9aad		90 07		bcc $9ab6	        bcc _digit
.9aaf		29 df		and #$df	        and #$DF                ; Make it uppercase.
.9ab1		38		sec		        sec
.9ab2		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.9ab4		80 03		bra $9ab9	        bra _done
.9ab6						_digit:
.9ab6		38		sec		        sec
.9ab7		e9 30		sbc #$30	        sbc #'0'
.9ab9						_done:
.9ab9		60		rts		        rts
.9aba						xt_search_wordlist:
.9aba		20 86 d7	jsr $d786	                jsr underflow_3
.9abd		a5 08		lda $08		                lda up
.9abf		18		clc		                clc
.9ac0		69 0a		adc #$0a	                adc #wordlists_offset
.9ac2		85 27		sta $27		                sta tmp2
.9ac4		a5 09		lda $09		                lda up+1
.9ac6		69 00		adc #$00	                adc #0          ; Adding carry
.9ac8		85 28		sta $28		                sta tmp2+1
.9aca		b5 00		lda $00,x	                lda 0,x
.9acc		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9acd		65 27		adc $27		                adc tmp2
.9acf		85 27		sta $27		                sta tmp2
.9ad1		90 02		bcc $9ad5	                bcc +
.9ad3		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.9ad5						+
.9ad5		e8		inx		                inx
.9ad6		e8		inx		                inx
.9ad7		b5 00		lda $00,x	                lda 0,x
.9ad9		15 01		ora $01,x	                ora 1,x
.9adb		f0 4e		beq $9b2b	                beq _done
.9add		a5 27		lda $27		                lda tmp2
.9adf		05 28		ora $28		                ora tmp2+1
.9ae1		f0 48		beq $9b2b	                beq _done
.9ae3		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.9ae5		85 25		sta $25		                sta tmp1
.9ae7		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.9ae9		d0 02		bne $9aed	                bne +
.9aeb		e6 28		inc $28		                inc tmp2+1
.9aed						+
.9aed		b2 27		lda ($27)	                lda (tmp2)
.9aef		85 26		sta $26		                sta tmp1+1
.9af1		20 4c d6	jsr $d64c	                jsr find_header_name
.9af4		f0 31		beq $9b27	                beq _fail_done
.9af6		e8		inx		                inx
.9af7		e8		inx		                inx
.9af8		a5 25		lda $25		                lda tmp1
.9afa		95 00		sta $00,x	                sta 0,x
.9afc		a5 26		lda $26		                lda tmp1+1
.9afe		95 01		sta $01,x	                sta 1,x
.9b00		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( nt nt )
.9b03		20 10 95	jsr $9510	                jsr xt_name_to_int      ; ( nt xt )
.9b06		20 05 a0	jsr $a005	                jsr xt_swap             ; ( xt nt )
.9b09		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9b0b		f6 00		inc $00,x	                inc 0,x
.9b0d		d0 02		bne $9b11	                bne +
.9b0f		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9b11						+
.9b11		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9b13		29 04		and #$04	                and #IM
.9b15		d0 08		bne $9b1f	                bne _immediate          ; bit set, we're immediate
.9b17		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9b19		95 00		sta $00,x	                sta 0,x
.9b1b		95 01		sta $01,x	                sta 1,x
.9b1d		80 0e		bra $9b2d	                bra _done_nodrop
.9b1f						_immediate:
.9b1f		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9b21		95 00		sta $00,x	                sta 0,x
.9b23		74 01		stz $01,x	                stz 1,x
.9b25		80 06		bra $9b2d	                bra _done_nodrop
.9b27						_fail_done:
.9b27		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b29		74 03		stz $03,x	                stz 3,x
.9b2b						_done:
.9b2b		e8		inx		                inx
.9b2c		e8		inx		                inx
.9b2d						_done_nodrop:
.9b2d						z_search_wordlist:
.9b2d		60		rts		                rts
.9b2e						xt_see:
.9b2e		20 02 98	jsr $9802	                jsr xt_parse_name       ; ( addr u )
.9b31		20 59 8f	jsr $8f59	                jsr xt_find_name        ; ( nt | 0 )
.9b34		b5 00		lda $00,x	                lda 0,x
.9b36		15 01		ora $01,x	                ora 1,x
.9b38		d0 05		bne $9b3f	                bne +
.9b3a		a9 05		lda #$05	                lda #err_noname
.9b3c		4c 92 d7	jmp $d792	                jmp error
.9b3f						+
.9b3f		20 d5 88	jsr $88d5	                jsr xt_cr
.9b42		a5 18		lda $18		                lda base
.9b44		48		pha		                pha
.9b45		20 93 90	jsr $9093	                jsr xt_hex
.9b48		a9 09		lda #$09	                lda #str_see_nt
.9b4a		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.9b4d		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( nt nt )
.9b50		20 59 a3	jsr $a359	                jsr xt_u_dot
.9b53		20 7b 9f	jsr $9f7b	                jsr xt_space            ; ( nt )
.9b56		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( nt nt )
.9b59		20 10 95	jsr $9510	                jsr xt_name_to_int      ; ( nt xt )
.9b5c		a9 0a		lda #$0a	                lda #str_see_xt
.9b5e		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.9b61		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( nt xt xt )
.9b64		20 59 a3	jsr $a359	                jsr xt_u_dot
.9b67		20 d5 88	jsr $88d5	                jsr xt_cr               ; ( nt xt )
.9b6a		a9 08		lda #$08	                lda #str_see_flags
.9b6c		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.9b6f		20 b6 97	jsr $97b6	                jsr xt_over             ; ( nt xt nt )
.9b72		20 40 97	jsr $9740	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9b75		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; ( nt xt flags )
.9b78		b5 00		lda $00,x	                lda 0,x
.9b7a		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9b7c						_flag_loop:
.9b7c		48		pha		                pha
.9b7d		29 01		and #$01	                and #%00000001
.9b7f		18		clc		                clc
.9b80		69 30		adc #$30	                adc #'0'
.9b82		20 7b 8d	jsr $8d7b	                jsr emit_a
.9b85		20 7b 9f	jsr $9f7b	                jsr xt_space
.9b88		68		pla		                pla
.9b89		6a		ror a		                ror                     ; Next flag
.9b8a		88		dey		                dey
.9b8b		d0 ef		bne $9b7c	                bne _flag_loop
.9b8d		20 d5 88	jsr $88d5	                jsr xt_cr
.9b90		e8		inx		                inx
.9b91		e8		inx		                inx                     ; ( nt xt )
.9b92		a9 0b		lda #$0b	                lda #str_see_size
.9b94		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.9b97		20 05 a0	jsr $a005	                jsr xt_swap             ; ( xt nt )
.9b9a		20 b1 a5	jsr $a5b1	                jsr xt_wordsize         ; ( xt u )
.9b9d		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9ba0		20 16 8a	jsr $8a16	                jsr xt_decimal
.9ba3		20 59 a3	jsr $a359	                jsr xt_u_dot            ; ( xt u )
.9ba6		20 93 90	jsr $9093	                jsr xt_hex
.9ba9		20 d5 88	jsr $88d5	                jsr xt_cr
.9bac		20 e3 a1	jsr $a1e3	                jsr xt_two_dup          ; ( xt u xt u )
.9baf		20 8c 8c	jsr $8c8c	                jsr xt_dump
.9bb2		20 d5 88	jsr $88d5	                jsr xt_cr
.9bb5		20 ab 8a	jsr $8aab	                jsr xt_disasm
.9bb8		68		pla		                pla
.9bb9		85 18		sta $18		                sta base
.9bbb		60		rts		z_see:          rts
.9bbc						xt_set_current:
.9bbc		20 7c d7	jsr $d77c	                jsr underflow_1
.9bbf		a0 08		ldy #$08	                ldy #current_offset
.9bc1		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9bc3		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.9bc5		e8		inx		                inx
.9bc6		e8		inx		                inx
.9bc7		60		rts		z_set_current:  rts
.9bc8						xt_set_order:
.9bc8		a9 ff		lda #$ff	                lda #$FF
.9bca		d5 01		cmp $01,x	                cmp 1,x
.9bcc		d0 12		bne $9be0	                bne _start
.9bce		d5 00		cmp $00,x	                cmp 0,x
.9bd0		d0 0e		bne $9be0	                bne _start
.9bd2		ca		dex		                dex             ; Make room for the count.
.9bd3		ca		dex		                dex
.9bd4		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9bd6		a9 03		lda #$03	                lda #3
.9bd8		95 02		sta $02,x	                sta 2,x
.9bda		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9bdc		a9 01		lda #$01	                lda #1
.9bde		95 00		sta $00,x	                sta 0,x
.9be0						_start:
.9be0		a0 22		ldy #$22	                ldy #num_order_offset
.9be2		b5 00		lda $00,x	                lda 0,x
.9be4		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.9be6		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.9be8		e8		inx		                inx             ; Drop the count off the data stack.
.9be9		e8		inx		                inx
.9bea		a5 25		lda $25		                lda tmp1
.9bec		f0 0d		beq $9bfb	                beq _done       ; If zero, there are no wordlists.
.9bee		a0 23		ldy #$23	                ldy #search_order_offset
.9bf0						_loop:
.9bf0		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9bf2		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.9bf4		c8		iny		                iny
.9bf5		e8		inx		                inx
.9bf6		e8		inx		                inx
.9bf7		c6 25		dec $25		                dec tmp1
.9bf9		d0 f5		bne $9bf0	                bne _loop
.9bfb						_done:
.9bfb		60		rts		z_set_order:    rts
.9bfc						xt_s_quote:
.9bfc		64 27		stz $27		                stz tmp2
.9bfe		64 28		stz $28		                stz tmp2+1
.9c00						s_quote_start:
.9c00		ca		dex		                dex
.9c01		ca		dex		                dex
.9c02		ca		dex		                dex
.9c03		ca		dex		                dex
.9c04		20 be d5	jsr $d5be	                jsr cmpl_jump
.9c07		a5 00		lda $00		                lda cp
.9c09		95 02		sta $02,x	                sta 2,x
.9c0b		a5 01		lda $01		                lda cp+1
.9c0d		95 03		sta $03,x	                sta 3,x
.9c0f						_savechars_loop:
.9c0f		a5 11		lda $11		                lda toin+1              ; MSB
.9c11		c5 0f		cmp $0f		                cmp ciblen+1
.9c13		90 2a		bcc $9c3f	                bcc _input_fine         ; unsigned comparison
.9c15		a5 10		lda $10		                lda toin                ; LSB
.9c17		c5 0e		cmp $0e		                cmp ciblen
.9c19		90 24		bcc $9c3f	                bcc _input_fine
.9c1b		a5 27		lda $27		                lda tmp2
.9c1d		48		pha		                pha
.9c1e		a5 28		lda $28		                lda tmp2+1
.9c20		48		pha		                pha
.9c21		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9c23		48		pha		                pha
.9c24		20 19 9a	jsr $9a19	                jsr xt_refill           ; ( -- f )
.9c27		68		pla		                pla
.9c28		85 29		sta $29		                sta tmp3
.9c2a		68		pla		                pla
.9c2b		85 28		sta $28		                sta tmp2+1
.9c2d		68		pla		                pla
.9c2e		85 27		sta $27		                sta tmp2
.9c30		b5 00		lda $00,x	                lda 0,x
.9c32		15 01		ora $01,x	                ora 1,x
.9c34		d0 05		bne $9c3b	                bne _refill_ok
.9c36		a9 06		lda #$06	                lda #err_refill
.9c38		4c 92 d7	jmp $d792	                jmp error
.9c3b						_refill_ok:
.9c3b		e8		inx		                inx
.9c3c		e8		inx		                inx
.9c3d		80 d0		bra $9c0f	                bra _savechars_loop
.9c3f						_input_fine:
.9c3f		a5 0c		lda $0c		                lda cib
.9c41		18		clc		                clc
.9c42		65 10		adc $10		                adc toin        ; LSB
.9c44		85 25		sta $25		                sta tmp1
.9c46		a5 0d		lda $0d		                lda cib+1
.9c48		65 11		adc $11		                adc toin+1      ; MSB
.9c4a		85 26		sta $26		                sta tmp1+1
.9c4c		b2 25		lda ($25)	                lda (tmp1)
.9c4e		24 27		bit $27		                bit tmp2
.9c50		30 03		bmi $9c55	                bmi _handle_escapes    ; Only checking bit 7
.9c52		4c d8 9c	jmp $9cd8	                jmp _regular_char
.9c55						_handle_escapes:
.9c55		24 28		bit $28		                bit tmp2+1
.9c57		30 03		bmi $9c5c	                bmi _escaped
.9c59		4c ce 9c	jmp $9cce	                jmp _not_escaped
.9c5c						_escaped:
.9c5c		70 3c		bvs $9c9a	                bvs _check_esc_chars
.9c5e		a9 01		lda #$01	                lda #1
.9c60		24 28		bit $28		                bit tmp2+1
.9c62		d0 10		bne $9c74	                bne _esc_x_second_digit
.9c64		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.9c66		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.9c68		20 ab 9a	jsr $9aab	                jsr convert_hex_value
.9c6b		0a		asl a		                asl
.9c6c		0a		asl a		                asl
.9c6d		0a		asl a		                asl
.9c6e		0a		asl a		                asl
.9c6f		85 29		sta $29		                sta tmp3    ; Save it for later.
.9c71		4c df 9c	jmp $9cdf	                jmp _next_character
.9c74						_esc_x_second_digit:
.9c74		64 28		stz $28		                stz tmp2+1
.9c76		b2 25		lda ($25)	                lda (tmp1)
.9c78		20 ab 9a	jsr $9aab	                jsr convert_hex_value
.9c7b		05 29		ora $29		                ora tmp3
.9c7d		4c dc 9c	jmp $9cdc	                jmp _save_character
.9c80						_esc_tr_table:
>9c80		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9c81		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9c82		00 00				    .byte   0,0             ; c, d no escape
>9c84		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9c85		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9c86		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9c8b		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9c8c		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9c8d		0a				    .byte   10              ; n behaves like l --> lf
>9c8e		00 00				    .byte   0,0             ; o,p
>9c90		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9c91		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9c92		00				    .byte   0               ; s
>9c93		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9c94		00				    .byte   0               ; u
>9c95		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9c96		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9c99		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9c9a						_check_esc_chars:
.9c9a		64 28		stz $28		                stz tmp2+1
.9c9c		c9 61		cmp #$61	                cmp #'a'
.9c9e		30 1a		bmi $9cba	                bmi _check_esc_quote
.9ca0		c9 7b		cmp #$7b	                cmp #'z'+1
.9ca2		10 16		bpl $9cba	                bpl _check_esc_quote
.9ca4		a8		tay		                tay
.9ca5		b9 1f 9c	lda $9c1f,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9ca8		d0 03		bne $9cad	                bne _esc_replace
.9caa		98		tya		                tya                     ; revert if no translation
.9cab		80 0d		bra $9cba	                bra _check_esc_quote
.9cad		10 2d		bpl $9cdc	_esc_replace:   bpl _save_character     ; simple replacement
.9caf		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9cb1		f0 29		beq $9cdc	                beq _save_character     ; NUL we can just output
.9cb3		20 c9 d5	jsr $d5c9	                jsr cmpl_a              ; else output first char (CR)
.9cb6		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9cb8		80 22		bra $9cdc	                bra _save_character
.9cba						_check_esc_quote:
.9cba		c9 22		cmp #$22	                cmp #'"'
.9cbc		f0 1e		beq $9cdc	                beq _save_character
.9cbe						_check_esc_x:
.9cbe		c9 78		cmp #$78	                cmp #'x'
.9cc0		d0 06		bne $9cc8	                bne _check_esc_backslash
.9cc2		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.9cc4		85 28		sta $28		                sta tmp2+1
.9cc6		80 17		bra $9cdf	                bra _next_character
.9cc8						_check_esc_backslash:
.9cc8		c9 5c		cmp #$5c	                cmp #'\'
.9cca		d0 0c		bne $9cd8	                bne _regular_char
.9ccc		80 0e		bra $9cdc	                bra _save_character
.9cce						_not_escaped:
.9cce		c9 5c		cmp #$5c	                cmp #'\'
.9cd0		d0 06		bne $9cd8	                bne _regular_char
.9cd2		a9 ff		lda #$ff	                lda #$FF
.9cd4		85 28		sta $28		                sta tmp2+1
.9cd6		80 07		bra $9cdf	                bra _next_character
.9cd8						_regular_char:
.9cd8		c9 22		cmp #$22	                cmp #'"'
.9cda		f0 0c		beq $9ce8	                beq _found_string_end
.9cdc						_save_character:
.9cdc		20 c9 d5	jsr $d5c9	                jsr cmpl_a
.9cdf						_next_character:
.9cdf		e6 10		inc $10		                inc toin
.9ce1		d0 02		bne $9ce5	                bne _savechars_loop_longjump
.9ce3		e6 11		inc $11		                inc toin+1
.9ce5						_savechars_loop_longjump:
.9ce5		4c 0f 9c	jmp $9c0f	                jmp _savechars_loop
.9ce8						_found_string_end:
.9ce8		e6 10		inc $10		                inc toin
.9cea		d0 02		bne $9cee	                bne +
.9cec		e6 11		inc $11		                inc toin+1
.9cee						+
.9cee		a5 00		lda $00		                lda cp
.9cf0		38		sec		                sec
.9cf1		f5 02		sbc $02,x	                sbc 2,x
.9cf3		95 00		sta $00,x	                sta 0,x         ; LSB
.9cf5		a5 01		lda $01		                lda cp+1
.9cf7		f5 03		sbc $03,x	                sbc 3,x
.9cf9		95 01		sta $01,x	                sta 1,x         ; MSB
.9cfb		b5 02		lda $02,x	                lda 2,x
.9cfd		38		sec		                sec
.9cfe		e9 02		sbc #$02	                sbc #2
.9d00		85 25		sta $25		                sta tmp1
.9d02		b5 03		lda $03,x	                lda 3,x
.9d04		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9d06		85 26		sta $26		                sta tmp1+1
.9d08		a5 00		lda $00		                lda cp
.9d0a		92 25		sta ($25)	                sta (tmp1)
.9d0c		a0 01		ldy #$01	                ldy #1
.9d0e		a5 01		lda $01		                lda cp+1
.9d10		91 25		sta ($25),y	                sta (tmp1),y
.9d12		a5 1a		lda $1a		                lda state
.9d14		05 1b		ora $1b		                ora state+1             ; paranoid
.9d16		f0 03		beq $9d1b	                beq _done
.9d18		20 ec 9e	jsr $9eec	                jsr sliteral_const_str         ; ( addr u -- )
.9d1b						_done:
.9d1b		60		rts		z_s_quote:      rts
.9d1c						xt_s_to_d:
.9d1c		20 7c d7	jsr $d77c	                jsr underflow_1
.9d1f		ca		dex		                dex
.9d20		ca		dex		                dex
.9d21		74 00		stz $00,x	                stz 0,x
.9d23		74 01		stz $01,x	                stz 1,x
.9d25		b5 03		lda $03,x	                lda 3,x
.9d27		10 04		bpl $9d2d	                bpl _done
.9d29		d6 00		dec $00,x	                dec 0,x
.9d2b		d6 01		dec $01,x	                dec 1,x
.9d2d						_done:
.9d2d		60		rts		z_s_to_d:       rts
.9d2e						xt_save_buffers:
.9d2e		a0 30		ldy #$30	                ldy #buffstatus_offset
.9d30		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9d32		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9d34		d0 12		bne $9d48	                bne _done       ; Either not used or not dirty = done!
.9d36		20 4f 83	jsr $834f	                jsr xt_blkbuffer
.9d39		20 2b 85	jsr $852b	                jsr xt_buffblocknum
.9d3c		20 fe 8e	jsr $8efe	                jsr xt_fetch
.9d3f		20 f1 84	jsr $84f1	                jsr xt_block_write
.9d42		a9 01		lda #$01	                lda #1
.9d44		a0 30		ldy #$30	                ldy #buffstatus_offset
.9d46		91 08		sta ($08),y	                sta (up),y
.9d48						_done:
.9d48		60		rts		z_save_buffers: rts
.9d49						xt_scr:
.9d49		a9 06		lda #$06	                lda #scr_offset
.9d4b		4c 26 d6	jmp $d626	                jmp push_upvar_tos
.9d4e						z_scr:
.9d4e						xt_search:
.9d4e		20 8b d7	jsr $d78b	                jsr underflow_4
.9d51		b5 00		lda $00,x	                lda 0,x
.9d53		15 01		ora $01,x	                ora 1,x
.9d55		d0 0b		bne $9d62	                bne _start_search
.9d57		e8		inx		                inx             ; Remove u2
.9d58		e8		inx		                inx
.9d59		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9d5b		95 00		sta $00,x	                sta 0,x
.9d5d		95 01		sta $01,x	                sta 1,x
.9d5f		4c ec 9d	jmp $9dec	                jmp z_search
.9d62						_start_search:
.9d62		20 e4 a5	jsr $a5e4	                jsr xt_zero
.9d65						_search_loop:
.9d65		18		clc		                clc
.9d66		b5 00		lda $00,x	                lda 0,x
.9d68		75 02		adc $02,x	                adc 2,x
.9d6a		85 25		sta $25		                sta tmp1
.9d6c		b5 01		lda $01,x	                lda 1,x
.9d6e		75 03		adc $03,x	                adc 3,x
.9d70		d5 07		cmp $07,x	                cmp 7,x
.9d72		90 12		bcc $9d86	                bcc _init_comparison ; Obviously less
.9d74		d0 06		bne $9d7c	                bne _not_found
.9d76		b5 06		lda $06,x	                lda 6,x
.9d78		c5 25		cmp $25		                cmp tmp1
.9d7a		b0 0a		bcs $9d86	                bcs _init_comparison
.9d7c						_not_found:
.9d7c		e8		inx		                inx             ; Remove offset
.9d7d		e8		inx		                inx
.9d7e		e8		inx		                inx             ; Remove u2
.9d7f		e8		inx		                inx
.9d80		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9d82		74 01		stz $01,x	                stz 1,x
.9d84		80 66		bra $9dec	                bra z_search
.9d86						_init_comparison:
.9d86		18		clc		                clc
.9d87		b5 08		lda $08,x	                lda 8,x
.9d89		75 00		adc $00,x	                adc 0,x
.9d8b		85 25		sta $25		                sta tmp1
.9d8d		b5 09		lda $09,x	                lda 9,x
.9d8f		75 01		adc $01,x	                adc 1,x
.9d91		85 26		sta $26		                sta tmp1+1
.9d93		b5 04		lda $04,x	                lda 4,x
.9d95		85 27		sta $27		                sta tmp2
.9d97		b5 05		lda $05,x	                lda 5,x
.9d99		85 28		sta $28		                sta tmp2+1
.9d9b		b5 02		lda $02,x	                lda 2,x
.9d9d		85 29		sta $29		                sta tmp3
.9d9f		b5 03		lda $03,x	                lda 3,x
.9da1		85 2a		sta $2a		                sta tmp3+1
.9da3						_comparison_loop:
.9da3		b2 25		lda ($25)	                lda (tmp1)
.9da5		d2 27		cmp ($27)	                cmp (tmp2)
.9da7		f0 05		beq $9dae	                beq _letters_match
.9da9		20 40 97	jsr $9740	                jsr xt_one_plus
.9dac		80 b7		bra $9d65	                bra _search_loop
.9dae						_letters_match:
.9dae		e6 25		inc $25		                inc tmp1
.9db0		d0 02		bne $9db4	                bne +
.9db2		e6 26		inc $26		                inc tmp1+1
.9db4						+
.9db4		e6 27		inc $27		                inc tmp2
.9db6		d0 02		bne $9dba	                bne +
.9db8		e6 28		inc $28		                inc tmp2+1
.9dba						+
.9dba		a5 29		lda $29		                lda tmp3
.9dbc		d0 02		bne $9dc0	                bne +
.9dbe		c6 2a		dec $2a		                dec tmp3+1
.9dc0						+
.9dc0		c6 29		dec $29		                dec tmp3
.9dc2		a5 29		lda $29		                lda tmp3
.9dc4		05 2a		ora $2a		                ora tmp3+1
.9dc6		d0 db		bne $9da3	                bne _comparison_loop ; Check the next letter
.9dc8		18		clc		                clc
.9dc9		b5 00		lda $00,x	                lda 0,x
.9dcb		75 08		adc $08,x	                adc 8,x
.9dcd		95 08		sta $08,x	                sta 8,x
.9dcf		b5 01		lda $01,x	                lda 1,x
.9dd1		75 09		adc $09,x	                adc 9,x
.9dd3		95 09		sta $09,x	                sta 9,x
.9dd5		38		sec		                sec
.9dd6		b5 06		lda $06,x	                lda 6,x
.9dd8		f5 00		sbc $00,x	                sbc 0,x
.9dda		95 06		sta $06,x	                sta 6,x
.9ddc		b5 07		lda $07,x	                lda 7,x
.9dde		f5 01		sbc $01,x	                sbc 1,x
.9de0		95 07		sta $07,x	                sta 7,x
.9de2		e8		inx		                inx             ; drop offset
.9de3		e8		inx		                inx
.9de4		e8		inx		                inx             ; drop u2
.9de5		e8		inx		                inx
.9de6		a9 ff		lda #$ff	                lda #$FF
.9de8		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9dea		95 01		sta $01,x	                sta 1,x
.9dec		60		rts		z_search:       rts
.9ded						xt_semicolon:
.9ded		24 1c		bit $1c		                bit status
.9def		70 11		bvs $9e02	                bvs _colonword
.9df1		a9 60		lda #$60	                lda #OpRTS
.9df3		20 c9 d5	jsr $d5c9	                jsr cmpl_a
.9df6		ca		dex		                dex
.9df7		ca		dex		                dex
.9df8		a5 06		lda $06		                lda workword
.9dfa		95 00		sta $00,x	                sta 0,x
.9dfc		a5 07		lda $07		                lda workword+1
.9dfe		95 01		sta $01,x	                sta 1,x
.9e00		80 45		bra $9e47	                bra _semicolon_done
.9e02						_colonword:
.9e02		a0 06		ldy #$06	                ldy #6
.9e04		a5 00		lda $00		                lda cp
.9e06		91 06		sta ($06),y	                sta (workword),y
.9e08		c8		iny		                iny
.9e09		a5 01		lda $01		                lda cp+1
.9e0b		91 06		sta ($06),y	                sta (workword),y
.9e0d		a9 60		lda #$60	                lda #OpRTS
.9e0f		20 c9 d5	jsr $d5c9	                jsr cmpl_a
.9e12		24 1c		bit $1c		                bit status
.9e14		10 26		bpl $9e3c	                bpl _new_word   ; Bit 7 is clear = new word
.9e16		ca		dex		                dex
.9e17		ca		dex		                dex
.9e18		ca		dex		                dex
.9e19		ca		dex		                dex
.9e1a		b2 06		lda ($06)	                lda (workword)
.9e1c		95 00		sta $00,x	                sta 0,x
.9e1e		74 01		stz $01,x	                stz 1,x
.9e20		a5 06		lda $06		                lda workword
.9e22		18		clc		                clc
.9e23		69 08		adc #$08	                adc #8
.9e25		95 02		sta $02,x	                sta 2,x
.9e27		a5 07		lda $07		                lda workword+1
.9e29		69 00		adc #$00	                adc #0                  ; only want carry
.9e2b		95 03		sta $03,x	                sta 3,x
.9e2d		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9e2f		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.9e32		20 2e a3	jsr $a32e	                jsr xt_type
.9e35		20 7b 9f	jsr $9f7b	                jsr xt_space
.9e38		a9 80		lda #$80	                lda #%10000000
.9e3a		14 1c		trb $1c		                trb status
.9e3c						_new_word:
.9e3c		a5 06		lda $06		                lda workword
.9e3e		85 02		sta $02		                sta dp
.9e40		a5 07		lda $07		                lda workword+1
.9e42		85 03		sta $03		                sta dp+1
.9e44		20 d6 d6	jsr $d6d6	                jsr dp_to_current       ; Save the updated DP to the
.9e47						_semicolon_done:
.9e47		64 1a		stz $1a		                stz state
.9e49		64 1b		stz $1b		                stz state+1
.9e4b		60		rts		z_semicolon:    rts
.9e4c						xt_sign:
.9e4c		20 7c d7	jsr $d77c	                jsr underflow_1
.9e4f		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9e51		30 04		bmi $9e57	                bmi _minus
.9e53		e8		inx		                inx
.9e54		e8		inx		                inx
.9e55		80 09		bra $9e60	                bra _done
.9e57						_minus:
.9e57		a9 2d		lda #$2d	                lda #'-'
.9e59		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9e5b		74 01		stz $01,x	                stz 1,x         ; paranoid
.9e5d		20 ed 90	jsr $90ed	                jsr xt_hold
.9e60						_done:
.9e60		60		rts		z_sign:         rts
.9e61						xt_slash:
.9e61		a9 00		lda #$00	                lda #0
.9e63		48		pha		                pha
.9e64		80 03		bra $9e69	                bra slashmod_common
.9e66						xt_slash_mod:
.9e66		a9 ff		lda #$ff	                lda #$FF
.9e68		48		pha		                pha             ; falls through to _common
.9e69						slashmod_common:
.9e69		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >R
.9e6c		20 1c 9d	jsr $9d1c	                jsr xt_s_to_d           ; S>D
.9e6f		20 b3 99	jsr $99b3	                jsr xt_r_from           ; R>
.9e72		20 32 9f	jsr $9f32	                jsr xt_sm_slash_rem     ; SM/REM
.9e75		68		pla		                pla
.9e76		d0 05		bne $9e7d	                bne _done
.9e78		20 05 a0	jsr $a005	                jsr xt_swap
.9e7b		e8		inx		                inx             ; DROP
.9e7c		e8		inx		                inx
.9e7d						_done:
.9e7d						z_slash_mod:
.9e7d		60		rts		z_slash:        rts
.9e7e						xt_slash_string:
.9e7e		20 86 d7	jsr $d786	                jsr underflow_3
.9e81		18		clc		                clc             ; 3OS+TOS
.9e82		b5 00		lda $00,x	                lda 0,x
.9e84		75 04		adc $04,x	                adc 4,x
.9e86		95 04		sta $04,x	                sta 4,x
.9e88		b5 01		lda $01,x	                lda 1,x
.9e8a		75 05		adc $05,x	                adc 5,x
.9e8c		95 05		sta $05,x	                sta 5,x
.9e8e		38		sec		                sec             ; NOS-TOS
.9e8f		b5 02		lda $02,x	                lda 2,x
.9e91		f5 00		sbc $00,x	                sbc 0,x
.9e93		95 02		sta $02,x	                sta 2,x
.9e95		b5 03		lda $03,x	                lda 3,x
.9e97		f5 01		sbc $01,x	                sbc 1,x
.9e99		95 03		sta $03,x	                sta 3,x
.9e9b		e8		inx		                inx
.9e9c		e8		inx		                inx
.9e9d		60		rts		z_slash_string: rts
.9e9e						xt_sliteral:
.9e9e		20 81 d7	jsr $d781	                jsr underflow_2
.9ea1		20 be d5	jsr $d5be	                jsr cmpl_jump
.9ea4		8a		txa		                txa
.9ea5		38		sec		                sec
.9ea6		e9 06		sbc #$06	                sbc #6
.9ea8		aa		tax		                tax
.9ea9		b5 08		lda $08,x	                lda 8,x
.9eab		95 04		sta $04,x	                sta 4,x
.9ead		b5 09		lda $09,x	                lda 9,x
.9eaf		95 05		sta $05,x	                sta 5,x
.9eb1		b5 06		lda $06,x	                lda 6,x
.9eb3		95 00		sta $00,x	                sta 0,x
.9eb5		b5 07		lda $07,x	                lda 7,x
.9eb7		95 01		sta $01,x	                sta 1,x
.9eb9		a5 00		lda $00		                lda cp
.9ebb		95 08		sta $08,x	                sta 8,x
.9ebd		95 02		sta $02,x	                sta 2,x
.9ebf		a5 01		lda $01		                lda cp+1
.9ec1		95 09		sta $09,x	                sta 9,x
.9ec3		95 03		sta $03,x	                sta 3,x
.9ec5		20 f1 94	jsr $94f1	                jsr xt_move
.9ec8		18		clc		                clc
.9ec9		a5 00		lda $00		                lda cp
.9ecb		75 00		adc $00,x	                adc 0,x
.9ecd		85 00		sta $00		                sta cp
.9ecf		a5 01		lda $01		                lda cp+1
.9ed1		75 01		adc $01,x	                adc 1,x
.9ed3		85 01		sta $01		                sta cp+1
.9ed5		b5 02		lda $02,x	                lda 2,x
.9ed7		38		sec		                sec
.9ed8		e9 02		sbc #$02	                sbc #2
.9eda		85 25		sta $25		                sta tmp1
.9edc		b5 03		lda $03,x	                lda 3,x
.9ede		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9ee0		85 26		sta $26		                sta tmp1+1
.9ee2		a5 00		lda $00		                lda cp
.9ee4		92 25		sta ($25)	                sta (tmp1)
.9ee6		a0 01		ldy #$01	                ldy #1
.9ee8		a5 01		lda $01		                lda cp+1
.9eea		91 25		sta ($25),y	                sta (tmp1),y
.9eec						sliteral_const_str:
.9eec		a0 9f		ldy #$9f	                ldy #>sliteral_runtime
.9eee		a9 06		lda #$06	                lda #<sliteral_runtime
.9ef0		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.9ef3		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.9ef5		b5 02		lda $02,x	                lda 2,x                ; address LSB
.9ef7		20 c5 d5	jsr $d5c5	                jsr cmpl_word
.9efa		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.9efc		b5 00		lda $00,x	                lda 0,x                ; length LSB
.9efe		20 c5 d5	jsr $d5c5	                jsr cmpl_word
.9f01		e8		inx		                inx
.9f02		e8		inx		                inx
.9f03		e8		inx		                inx
.9f04		e8		inx		                inx
.9f05		60		rts		z_sliteral:     rts
.9f06						sliteral_runtime:
.9f06		ca		dex		                dex
.9f07		ca		dex		                dex
.9f08		ca		dex		                dex
.9f09		ca		dex		                dex
.9f0a		68		pla		                pla
.9f0b		85 25		sta $25		                sta tmp1        ; LSB of address
.9f0d		68		pla		                pla
.9f0e		85 26		sta $26		                sta tmp1+1      ; MSB of address
.9f10		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.9f12		b1 25		lda ($25),y	                lda (tmp1),y
.9f14		95 02		sta $02,x	                sta 2,x         ; LSB of address
.9f16		c8		iny		                iny
.9f17		b1 25		lda ($25),y	                lda (tmp1),y
.9f19		95 03		sta $03,x	                sta 3,x         ; MSB of address
.9f1b		c8		iny		                iny
.9f1c		b1 25		lda ($25),y	                lda (tmp1),y
.9f1e		95 00		sta $00,x	                sta 0,x         ; LSB of length
.9f20		c8		iny		                iny
.9f21		b1 25		lda ($25),y	                lda (tmp1),y
.9f23		95 01		sta $01,x	                sta 1,x         ; MSB of length
.9f25		18		clc		                clc
.9f26		a5 25		lda $25		                lda tmp1
.9f28		69 04		adc #$04	                adc #4
.9f2a		a8		tay		                tay             ; LSB
.9f2b		a5 26		lda $26		                lda tmp1+1
.9f2d		69 00		adc #$00	                adc #0          ; we only need carry
.9f2f		48		pha		                pha             ; MSB
.9f30		5a		phy		                phy
.9f31		60		rts		                rts
.9f32						xt_sm_slash_rem:
.9f32		20 86 d7	jsr $d786	                jsr underflow_3 ; contains double number
.9f35		b5 03		lda $03,x	                lda 3,x
.9f37		48		pha		                pha
.9f38		b5 01		lda $01,x	                lda 1,x
.9f3a		55 03		eor $03,x	                eor 3,x
.9f3c		48		pha		                pha
.9f3d		20 d1 80	jsr $80d1	                jsr xt_abs
.9f40		e8		inx		                inx             ; pretend we pushed n1 to R
.9f41		e8		inx		                inx
.9f42		20 f7 89	jsr $89f7	                jsr xt_dabs
.9f45		ca		dex		                dex
.9f46		ca		dex		                dex
.9f47		20 e5 a3	jsr $a3e5	                jsr xt_um_slash_mod     ; UM/MOD
.9f4a		68		pla		                pla
.9f4b		10 03		bpl $9f50	                bpl +
.9f4d		20 49 95	jsr $9549	                jsr xt_negate
.9f50						+
.9f50		68		pla		                pla
.9f51		10 07		bpl $9f5a	                bpl _done
.9f53		e8		inx		                inx             ; pretend we pushed quotient to R
.9f54		e8		inx		                inx
.9f55		20 49 95	jsr $9549	                jsr xt_negate
.9f58		ca		dex		                dex
.9f59		ca		dex		                dex
.9f5a						_done:
.9f5a		60		rts		z_sm_slash_rem: rts
.9f5b						xt_source:
.9f5b		ca		dex		                dex
.9f5c		ca		dex		                dex
.9f5d		a5 0c		lda $0c		                lda cib
.9f5f		95 00		sta $00,x	                sta 0,x
.9f61		a5 0d		lda $0d		                lda cib+1
.9f63		95 01		sta $01,x	                sta 1,x
.9f65		ca		dex		                dex
.9f66		ca		dex		                dex
.9f67		a5 0e		lda $0e		                lda ciblen
.9f69		95 00		sta $00,x	                sta 0,x
.9f6b		a5 0f		lda $0f		                lda ciblen+1
.9f6d		95 01		sta $01,x	                sta 1,x
.9f6f		60		rts		z_source:       rts
.9f70						xt_source_id:
.9f70		ca		dex		                dex
.9f71		ca		dex		                dex
.9f72		a5 0a		lda $0a		                lda insrc
.9f74		95 00		sta $00,x	                sta 0,x
.9f76		a5 0b		lda $0b		                lda insrc+1
.9f78		95 01		sta $01,x	                sta 1,x
.9f7a		60		rts		z_source_id:    rts
.9f7b						xt_space:
.9f7b		a9 20		lda #$20	                lda #AscSP
.9f7d		20 7b 8d	jsr $8d7b	                jsr emit_a
.9f80		60		rts		z_space:        rts
.9f81						xt_spaces:
.9f81		20 7c d7	jsr $d77c	                jsr underflow_1
.9f84		20 e4 a5	jsr $a5e4	                jsr xt_zero
.9f87		20 47 94	jsr $9447	                jsr xt_max
.9f8a		b5 00		lda $00,x	                lda 0,x
.9f8c		15 01		ora $01,x	                ora 1,x
.9f8e		f0 2a		beq $9fba	                beq _done
.9f90		b4 01		ldy $01,x	                ldy 1,x
.9f92		d0 0c		bne $9fa0	                bne _lots_of_spaces
.9f94		b4 00		ldy $00,x	                ldy 0,x
.9f96						_quick_loop:
.9f96		a9 20		lda #$20	                lda #AscSP
.9f98		20 7b 8d	jsr $8d7b	                jsr emit_a
.9f9b		88		dey		                dey
.9f9c		f0 1c		beq $9fba	                beq _done
.9f9e		80 f6		bra $9f96	                bra _quick_loop
.9fa0						_lots_of_spaces:
.9fa0		b4 00		ldy $00,x	                ldy 0,x
.9fa2						_first_slow_loop:
.9fa2		f0 08		beq $9fac	                beq _slow_outer_loop
.9fa4		a9 20		lda #$20	                lda #AscSP
.9fa6		20 7b 8d	jsr $8d7b	                jsr emit_a
.9fa9		88		dey		                dey
.9faa		80 f6		bra $9fa2	                bra _first_slow_loop
.9fac						_slow_outer_loop:
.9fac		a0 00		ldy #$00	                ldy #00
.9fae						_slow_inner_loop:
.9fae		a9 20		lda #$20	                lda #AscSP
.9fb0		20 7b 8d	jsr $8d7b	                jsr emit_a
.9fb3		88		dey		                dey
.9fb4		d0 f8		bne $9fae	                bne _slow_inner_loop
.9fb6		d6 01		dec $01,x	                dec 1,x
.9fb8		d0 f2		bne $9fac	                bne _slow_outer_loop
.9fba						_done:
.9fba		e8		inx		                inx             ; drop
.9fbb		e8		inx		                inx
.9fbc		60		rts		z_spaces:       rts
.9fbd						xt_star:
.9fbd		20 81 d7	jsr $d781	                jsr underflow_2
.9fc0		20 27 a4	jsr $a427	                jsr xt_um_star
.9fc3		e8		inx		                inx
.9fc4		e8		inx		                inx
.9fc5		60		rts		z_star:         rts
.9fc6						xt_star_slash:
.9fc6		20 cf 9f	jsr $9fcf	                jsr xt_star_slash_mod
.9fc9		20 05 a0	jsr $a005	                jsr xt_swap
.9fcc		e8		inx		                inx
.9fcd		e8		inx		                inx
.9fce						z_star_slash:
.9fce		60		rts		                rts
.9fcf						xt_star_slash_mod:
.9fcf		20 86 d7	jsr $d786	                jsr underflow_3
.9fd2		20 9b a1	jsr $a19b	                jsr xt_to_r
.9fd5		20 bd 93	jsr $93bd	                jsr xt_m_star
.9fd8		20 b3 99	jsr $99b3	                jsr xt_r_from
.9fdb		20 32 9f	jsr $9f32	                jsr xt_sm_slash_rem
.9fde						z_star_slash_mod:
.9fde		60		rts		                rts
.9fdf						xt_state:
.9fdf		ca		dex		                dex
.9fe0		ca		dex		                dex
.9fe1		a9 1a		lda #$1a	                lda #<state
.9fe3		95 00		sta $00,x	                sta 0,x
.9fe5		a9 00		lda #$00	                lda #>state
.9fe7		95 01		sta $01,x	                sta 1,x
.9fe9		60		rts		z_state:        rts
.9fea						xt_store:
.9fea		20 81 d7	jsr $d781	                jsr underflow_2
.9fed		b5 02		lda $02,x	                lda 2,x         ; LSB
.9fef		81 00		sta ($00,x)	                sta (0,x)
.9ff1		f6 00		inc $00,x	                inc 0,x
.9ff3		d0 02		bne $9ff7	                bne +
.9ff5		f6 01		inc $01,x	                inc 1,x
.9ff7						+
.9ff7		b5 03		lda $03,x	                lda 3,x         ; MSB
.9ff9		81 00		sta ($00,x)	                sta (0,x)
.9ffb		e8		inx		                inx             ; 2DROP
.9ffc		e8		inx		                inx
.9ffd		e8		inx		                inx
.9ffe		e8		inx		                inx
.9fff		60		rts		z_store:        rts
.a000						xt_strip_underflow:
.a000		a9 02		lda #$02	                lda #uf_strip_offset
.a002		4c 26 d6	jmp $d626	                jmp push_upvar_tos
.a005						z_strip_underflow:
.a005						xt_swap:
.a005		20 81 d7	jsr $d781	                jsr underflow_2
.a008		b5 00		lda $00,x	                lda 0,x         ; LSB
.a00a		b4 02		ldy $02,x	                ldy 2,x
.a00c		95 02		sta $02,x	                sta 2,x
.a00e		94 00		sty $00,x	                sty 0,x
.a010		b5 01		lda $01,x	                lda 1,x         ; MSB
.a012		b4 03		ldy $03,x	                ldy 3,x
.a014		95 03		sta $03,x	                sta 3,x
.a016		94 01		sty $01,x	                sty 1,x
.a018		60		rts		z_swap:         rts
.a019						xt_thru:
.a019		20 81 d7	jsr $d781	                jsr underflow_2
.a01c		b5 01		lda $01,x	                lda 1,x
.a01e		48		pha		                pha
.a01f		b5 00		lda $00,x	                lda 0,x
.a021		48		pha		                pha
.a022		e8		inx		                inx
.a023		e8		inx		                inx
.a024						_thru_loop:
.a024		b5 01		lda $01,x	                lda 1,x
.a026		48		pha		                pha
.a027		b5 00		lda $00,x	                lda 0,x
.a029		48		pha		                pha
.a02a		20 d5 92	jsr $92d5	                jsr xt_load
.a02d		68		pla		                pla
.a02e		85 25		sta $25		                sta tmp1
.a030		68		pla		                pla
.a031		85 26		sta $26		                sta tmp1+1
.a033		68		pla		                pla
.a034		85 27		sta $27		                sta tmp2
.a036		68		pla		                pla
.a037		85 28		sta $28		                sta tmp2+1
.a039		c5 26		cmp $26		                cmp tmp1+1
.a03b		d0 08		bne $a045	                bne _next_screen
.a03d		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.a03f		c5 25		cmp $25		                cmp tmp1
.a041		d0 02		bne $a045	                bne _next_screen
.a043		80 18		bra $a05d	                bra _done       ; We just did the last screen.
.a045						_next_screen:
.a045		a5 28		lda $28		                lda tmp2+1
.a047		48		pha		                pha
.a048		a5 27		lda $27		                lda tmp2
.a04a		48		pha		                pha
.a04b		e6 25		inc $25		                inc tmp1
.a04d		d0 02		bne $a051	                bne +
.a04f		e6 26		inc $26		                inc tmp1+1
.a051						+
.a051		ca		dex		                dex
.a052		ca		dex		                dex
.a053		a5 25		lda $25		                lda tmp1
.a055		95 00		sta $00,x	                sta 0,x
.a057		a5 26		lda $26		                lda tmp1+1
.a059		95 01		sta $01,x	                sta 1,x
.a05b		80 c7		bra $a024	                bra _thru_loop
.a05d						_done:
.a05d		60		rts		z_thru:         rts
.a05e						xt_tick:
.a05e		20 02 98	jsr $9802	                jsr xt_parse_name       ; ( -- addr u )
.a061		b5 00		lda $00,x	                lda 0,x
.a063		15 01		ora $01,x	                ora 1,x
.a065		d0 05		bne $a06c	                bne +
.a067		a9 05		lda #$05	                lda #err_noname
.a069		4c 92 d7	jmp $d792	                jmp error
.a06c						+
.a06c		20 59 8f	jsr $8f59	                jsr xt_find_name        ; ( addr u -- nt )
.a06f		b5 00		lda $00,x	                lda 0,x
.a071		15 01		ora $01,x	                ora 1,x
.a073		d0 05		bne $a07a	                bne +
.a075		a9 08		lda #$08	                lda #err_syntax
.a077		4c 92 d7	jmp $d792	                jmp error
.a07a						+
.a07a		20 10 95	jsr $9510	                jsr xt_name_to_int      ; ( nt -- xt )
.a07d		60		rts		z_tick:         rts
.a07e						xt_to:
.a07e		20 5e a0	jsr $a05e	                jsr xt_tick             ; ( [n] xt )
.a081		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a083		18		clc		                clc
.a084		69 03		adc #$03	                adc #3
.a086		85 25		sta $25		                sta tmp1
.a088		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a08a		69 00		adc #$00	                adc #0                  ; we just want the carry
.a08c		85 26		sta $26		                sta tmp1+1
.a08e		a5 1a		lda $1a		                lda state
.a090		05 1b		ora $1b		                ora state+1
.a092		f0 14		beq $a0a8	                beq _interpret
.a094		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.a096		95 00		sta $00,x	                sta 0,x
.a098		a5 26		lda $26		                lda tmp1+1
.a09a		95 01		sta $01,x	                sta 1,x
.a09c		20 a8 92	jsr $92a8	                jsr xt_literal      ; generate the runtime for LITERAL tmp1
.a09f		a0 9f		ldy #$9f	                ldy #>xt_store      ; write the runtime for !
.a0a1		a9 ea		lda #$ea	                lda #<xt_store
.a0a3		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.a0a6		80 11		bra $a0b9	                bra _done
.a0a8						_interpret:
.a0a8		20 81 d7	jsr $d781	                jsr underflow_2
.a0ab		e8		inx		                inx
.a0ac		e8		inx		                inx                     ; leaving just ( n )
.a0ad		b5 00		lda $00,x	                lda 0,x
.a0af		92 25		sta ($25)	                sta (tmp1)              ; LSB
.a0b1		a0 01		ldy #$01	                ldy #1
.a0b3		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a0b5		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.a0b7		e8		inx		                inx                     ; DROP
.a0b8		e8		inx		                inx
.a0b9						_done:
.a0b9		60		rts		z_to:           rts
.a0ba						xt_to_body:
.a0ba		20 7c d7	jsr $d77c	                jsr underflow_1
.a0bd		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( xt xt )
.a0c0		20 87 91	jsr $9187	                jsr xt_int_to_name      ; ( xt nt )
.a0c3		f6 00		inc $00,x	                inc 0,x
.a0c5		d0 02		bne $a0c9	                bne +
.a0c7		f6 01		inc $01,x	                inc 1,x
.a0c9						+
.a0c9		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a0cb		29 20		and #$20	                and #HC
.a0cd		f0 0b		beq $a0da	                beq _no_cfa
.a0cf		18		clc		                clc
.a0d0		b5 02		lda $02,x	                lda 2,x         ; LSB
.a0d2		69 03		adc #$03	                adc #3
.a0d4		95 02		sta $02,x	                sta 2,x
.a0d6		90 02		bcc $a0da	                bcc _no_cfa
.a0d8		f6 03		inc $03,x	                inc 3,x         ; MSB
.a0da						_no_cfa:
.a0da		e8		inx		                inx             ; get rid of the nt
.a0db		e8		inx		                inx
.a0dc						_done:
.a0dc		60		rts		z_to_body:      rts
.a0dd						xt_to_in:
.a0dd		ca		dex		                dex
.a0de		ca		dex		                dex
.a0df		a9 10		lda #$10	                lda #<toin
.a0e1		95 00		sta $00,x	                sta 0,x
.a0e3		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a0e5		95 01		sta $01,x	                sta 1,x
.a0e7		60		rts		z_to_in:        rts
.a0e8						xt_to_number:
.a0e8		20 8b d7	jsr $d78b	                jsr underflow_4
.a0eb		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a0ed		85 2d		sta $2d		                sta scratch
.a0ef		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a0f1		85 2e		sta $2e		                sta scratch+1
.a0f3		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a0f5		85 2f		sta $2f		                sta scratch+2
.a0f7		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a0f9		85 30		sta $30		                sta scratch+3
.a0fb		ca		dex		                dex
.a0fc		ca		dex		                dex
.a0fd						_loop:
.a0fd		a1 04		lda ($04,x)	                lda (4,x)
.a0ff		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a101		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a103		20 76 8a	jsr $8a76	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a106		b5 00		lda $00,x	                lda 0,x
.a108		d0 04		bne $a10e	                bne _digit_ok
.a10a		e8		inx		                inx
.a10b		e8		inx		                inx
.a10c		80 67		bra $a175	                bra _done       ; ( ud-lo ud-hi addr u char )
.a10e						_digit_ok:
.a10e		b5 02		lda $02,x	                lda 2,x
.a110		85 31		sta $31		                sta scratch+4
.a112		b5 03		lda $03,x	                lda 3,x
.a114		85 32		sta $32		                sta scratch+5
.a116		a5 2f		lda $2f		                lda scratch+2
.a118		95 02		sta $02,x	                sta 2,x         ; NOS
.a11a		a5 30		lda $30		                lda scratch+3
.a11c		95 03		sta $03,x	                sta 3,x
.a11e		a5 18		lda $18		                lda base
.a120		95 00		sta $00,x	                sta 0,x         ; TOS
.a122		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a124		20 27 a4	jsr $a427	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a127		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a129		85 33		sta $33		                sta scratch+6
.a12b		b5 03		lda $03,x	                lda 3,x
.a12d		85 34		sta $34		                sta scratch+7
.a12f		a5 2d		lda $2d		                lda scratch
.a131		95 02		sta $02,x	                sta 2,x
.a133		a5 2e		lda $2e		                lda scratch+1
.a135		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a137		a5 18		lda $18		                lda base
.a139		95 00		sta $00,x	                sta 0,x
.a13b		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a13d		20 27 a4	jsr $a427	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a140		b5 00		lda $00,x	                lda 0,x
.a142		85 2f		sta $2f		                sta scratch+2
.a144		b5 01		lda $01,x	                lda 1,x
.a146		85 30		sta $30		                sta scratch+3
.a148		b5 02		lda $02,x	                lda 2,x
.a14a		85 2d		sta $2d		                sta scratch
.a14c		b5 03		lda $03,x	                lda 3,x
.a14e		85 2e		sta $2e		                sta scratch+1
.a150		18		clc		                clc
.a151		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.a153		65 31		adc $31		                adc scratch+4   ; n LSB
.a155		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.a157		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.a159		65 32		adc $32		                adc scratch+5   ; n MSB
.a15b		85 2e		sta $2e		                sta scratch+1
.a15d		a5 2f		lda $2f		                lda scratch+2   ; LSB
.a15f		65 33		adc $33		                adc scratch+6
.a161		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.a163		a5 30		lda $30		                lda scratch+3   ; MSB
.a165		65 34		adc $34		                adc scratch+7
.a167		85 30		sta $30		                sta scratch+3
.a169		e8		inx		                inx
.a16a		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a16b		f6 04		inc $04,x	                inc 4,x
.a16d		d0 02		bne $a171	                bne +
.a16f		f6 05		inc $05,x	                inc 5,x
.a171						+
.a171		d6 02		dec $02,x	                dec 2,x
.a173		d0 88		bne $a0fd	                bne _loop
.a175						_done:
.a175		e8		inx		                inx
.a176		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a177		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.a179		95 06		sta $06,x	                sta 6,x
.a17b		a5 2e		lda $2e		                lda scratch+1
.a17d		95 07		sta $07,x	                sta 7,x
.a17f		a5 2f		lda $2f		                lda scratch+2
.a181		95 04		sta $04,x	                sta 4,x
.a183		a5 30		lda $30		                lda scratch+3
.a185		95 05		sta $05,x	                sta 5,x
.a187		60		rts		z_to_number:    rts
.a188						xt_to_order:
.a188		20 9b a1	jsr $a19b	                jsr xt_to_r
.a18b		20 4a 90	jsr $904a	                jsr xt_get_order
.a18e		20 b3 99	jsr $99b3	                jsr xt_r_from
.a191		20 05 a0	jsr $a005	                jsr xt_swap
.a194		20 40 97	jsr $9740	                jsr xt_one_plus
.a197		20 c8 9b	jsr $9bc8	                jsr xt_set_order
.a19a		60		rts		z_to_order:     rts
.a19b						xt_to_r:
.a19b		68		pla		                pla             ; LSB
.a19c		85 23		sta $23		                sta tmptos
.a19e		7a		ply		                ply             ; MSB
.a19f		20 7c d7	jsr $d77c	                jsr underflow_1
.a1a2		b5 01		lda $01,x	                lda 1,x         ; MSB
.a1a4		48		pha		                pha
.a1a5		b5 00		lda $00,x	                lda 0,x         ; LSB
.a1a7		48		pha		                pha
.a1a8		e8		inx		                inx
.a1a9		e8		inx		                inx
.a1aa		5a		phy		                phy             ; MSB
.a1ab		a5 23		lda $23		                lda tmptos
.a1ad		48		pha		                pha             ; LSB
.a1ae		60		rts		z_to_r:         rts
.a1af						xt_true:
.a1af		ca		dex		                dex
.a1b0		ca		dex		                dex
.a1b1		a9 ff		lda #$ff	                lda #$FF
.a1b3		95 00		sta $00,x	                sta 0,x
.a1b5		95 01		sta $01,x	                sta 1,x
.a1b7		60		rts		z_true:         rts
.a1b8						xt_tuck:
.a1b8		20 81 d7	jsr $d781	                jsr underflow_2
.a1bb		ca		dex		                dex
.a1bc		ca		dex		                dex
.a1bd		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a1bf		b5 02		lda $02,x	                lda 2,x
.a1c1		95 04		sta $04,x	                sta 4,x
.a1c3		94 02		sty $02,x	                sty 2,x
.a1c5		95 00		sta $00,x	                sta 0,x
.a1c7		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a1c9		b5 03		lda $03,x	                lda 3,x
.a1cb		95 05		sta $05,x	                sta 5,x
.a1cd		94 03		sty $03,x	                sty 3,x         ; bba
.a1cf		95 01		sta $01,x	                sta 1,x         ; baa
.a1d1		60		rts		z_tuck:         rts
.a1d2						xt_assembler_wordlist:
.a1d2						xt_two:
.a1d2		ca		dex		                dex
.a1d3		ca		dex		                dex
.a1d4		a9 02		lda #$02	                lda #2
.a1d6		95 00		sta $00,x	                sta 0,x
.a1d8		74 01		stz $01,x	                stz 1,x
.a1da						z_assembler_wordlist:
.a1da		60		rts		z_two:          rts
.a1db						xt_two_drop:
.a1db		20 81 d7	jsr $d781	                jsr underflow_2
.a1de		e8		inx		                inx
.a1df		e8		inx		                inx
.a1e0		e8		inx		                inx
.a1e1		e8		inx		                inx
.a1e2		60		rts		z_two_drop:     rts
.a1e3						xt_two_dup:
.a1e3		20 81 d7	jsr $d781	                jsr underflow_2
.a1e6		ca		dex		                dex
.a1e7		ca		dex		                dex
.a1e8		ca		dex		                dex
.a1e9		ca		dex		                dex
.a1ea		b5 04		lda $04,x	                lda 4,x         ; TOS
.a1ec		95 00		sta $00,x	                sta 0,x
.a1ee		b5 05		lda $05,x	                lda 5,x
.a1f0		95 01		sta $01,x	                sta 1,x
.a1f2		b5 06		lda $06,x	                lda 6,x         ; NOS
.a1f4		95 02		sta $02,x	                sta 2,x
.a1f6		b5 07		lda $07,x	                lda 7,x
.a1f8		95 03		sta $03,x	                sta 3,x
.a1fa		60		rts		z_two_dup:      rts
.a1fb						xt_two_fetch:
.a1fb		20 7c d7	jsr $d77c	                jsr underflow_1
.a1fe		b5 00		lda $00,x	                lda 0,x
.a200		85 25		sta $25		                sta tmp1
.a202		b4 01		ldy $01,x	                ldy 1,x
.a204		84 26		sty $26		                sty tmp1+1
.a206		ca		dex		                dex             ; reuse one stack element
.a207		ca		dex		                dex
.a208		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.a20a		95 00		sta $00,x	                sta 0,x
.a20c		a0 01		ldy #$01	                ldy #1          ; copy next
.a20e		b1 25		lda ($25),y	                lda (tmp1),y
.a210		95 01		sta $01,x	                sta 1,x
.a212		c8		iny		                iny             ; copy next
.a213		b1 25		lda ($25),y	                lda (tmp1),y
.a215		95 02		sta $02,x	                sta 2,x
.a217		c8		iny		                iny             ; copy next
.a218		b1 25		lda ($25),y	                lda (tmp1),y
.a21a		95 03		sta $03,x	                sta 3,x
.a21c		60		rts		z_two_fetch:    rts
.a21d						xt_two_over:
.a21d		20 8b d7	jsr $d78b	                jsr underflow_4
.a220		ca		dex		                dex
.a221		ca		dex		                dex
.a222		ca		dex		                dex
.a223		ca		dex		                dex
.a224		b5 08		lda $08,x	                lda 8,x
.a226		95 00		sta $00,x	                sta 0,x
.a228		b5 09		lda $09,x	                lda 9,x
.a22a		95 01		sta $01,x	                sta 1,x
.a22c		b5 0a		lda $0a,x	                lda 10,x
.a22e		95 02		sta $02,x	                sta 2,x
.a230		b5 0b		lda $0b,x	                lda 11,x
.a232		95 03		sta $03,x	                sta 3,x
.a234		60		rts		z_two_over:     rts
.a235						xt_two_r_fetch:
.a235		ca		dex		                dex
.a236		ca		dex		                dex
.a237		ca		dex		                dex
.a238		ca		dex		                dex
.a239		8a		txa		                txa
.a23a		ba		tsx		                tsx
.a23b		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a23c		7a		ply		                ply
.a23d		aa		tax		                tax
.a23e		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a241		95 00		sta $00,x	                sta 0,x
.a243		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a246		95 01		sta $01,x	                sta 1,x
.a248		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a24b		95 02		sta $02,x	                sta 2,x
.a24d		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a250		95 03		sta $03,x	                sta 3,x
.a252		60		rts		z_two_r_fetch:  rts
.a253						xt_two_r_from:
.a253		68		pla		                pla                     ; LSB
.a254		85 25		sta $25		                sta tmp1
.a256		68		pla		                pla                     ; MSB
.a257		85 26		sta $26		                sta tmp1+1
.a259		ca		dex		                dex
.a25a		ca		dex		                dex
.a25b		ca		dex		                dex
.a25c		ca		dex		                dex
.a25d		68		pla		                pla                     ; LSB
.a25e		95 00		sta $00,x	                sta 0,x
.a260		68		pla		                pla                     ; MSB
.a261		95 01		sta $01,x	                sta 1,x
.a263		68		pla		                pla                     ; LSB
.a264		95 02		sta $02,x	                sta 2,x
.a266		68		pla		                pla                     ; MSB
.a267		95 03		sta $03,x	                sta 3,x
.a269		a5 26		lda $26		                lda tmp1+1              ; MSB
.a26b		48		pha		                pha
.a26c		a5 25		lda $25		                lda tmp1                ; LSB
.a26e		48		pha		                pha
.a26f		60		rts		z_two_r_from:   rts
.a270						xt_two_slash:
.a270		20 7c d7	jsr $d77c	                jsr underflow_1
.a273		b5 01		lda $01,x	                lda 1,x
.a275		0a		asl a		                asl                     ; save the sign
.a276		76 01		ror $01,x	                ror 1,x
.a278		76 00		ror $00,x	                ror 0,x
.a27a		60		rts		z_two_slash:    rts
.a27b						xt_two_star:
.a27b						xt_cells:
.a27b		20 7c d7	jsr $d77c	                jsr underflow_1
.a27e		16 00		asl $00,x	                asl 0,x
.a280		36 01		rol $01,x	                rol 1,x
.a282						z_cells:
.a282		60		rts		z_two_star:     rts
.a283						xt_two_store:
.a283		20 86 d7	jsr $d786	                jsr underflow_3
.a286		b5 00		lda $00,x	                lda 0,x
.a288		85 25		sta $25		                sta tmp1
.a28a		b4 01		ldy $01,x	                ldy 1,x
.a28c		84 26		sty $26		                sty tmp1+1
.a28e		e8		inx		                inx
.a28f		e8		inx		                inx
.a290		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a292		92 25		sta ($25)	                sta (tmp1)
.a294		b5 01		lda $01,x	                lda 1,x         ; copy next
.a296		a0 01		ldy #$01	                ldy #1
.a298		91 25		sta ($25),y	                sta (tmp1),y
.a29a		b5 02		lda $02,x	                lda 2,x         ; copy next
.a29c		c8		iny		                iny
.a29d		91 25		sta ($25),y	                sta (tmp1),y
.a29f		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a2a1		c8		iny		                iny
.a2a2		91 25		sta ($25),y	                sta (tmp1),y
.a2a4		e8		inx		                inx             ; 2DROP
.a2a5		e8		inx		                inx
.a2a6		e8		inx		                inx
.a2a7		e8		inx		                inx
.a2a8		60		rts		z_two_store:    rts
.a2a9						xt_two_swap:
.a2a9		20 8b d7	jsr $d78b	                jsr underflow_4
.a2ac		b5 00		lda $00,x	                lda 0,x
.a2ae		b4 04		ldy $04,x	                ldy 4,x
.a2b0		95 04		sta $04,x	                sta 4,x
.a2b2		94 00		sty $00,x	                sty 0,x
.a2b4		b5 01		lda $01,x	                lda 1,x
.a2b6		b4 05		ldy $05,x	                ldy 5,x
.a2b8		95 05		sta $05,x	                sta 5,x
.a2ba		94 01		sty $01,x	                sty 1,x
.a2bc		b5 02		lda $02,x	                lda 2,x
.a2be		b4 06		ldy $06,x	                ldy 6,x
.a2c0		95 06		sta $06,x	                sta 6,x
.a2c2		94 02		sty $02,x	                sty 2,x
.a2c4		b5 03		lda $03,x	                lda 3,x
.a2c6		b4 07		ldy $07,x	                ldy 7,x
.a2c8		95 07		sta $07,x	                sta 7,x
.a2ca		94 03		sty $03,x	                sty 3,x
.a2cc		60		rts		z_two_swap:     rts
.a2cd						xt_two_to_r:
.a2cd		68		pla		                pla             ; LSB
.a2ce		85 25		sta $25		                sta tmp1
.a2d0		68		pla		                pla             ; MSB
.a2d1		85 26		sta $26		                sta tmp1+1
.a2d3		20 81 d7	jsr $d781	                jsr underflow_2
.a2d6		b5 03		lda $03,x	                lda 3,x         ; MSB
.a2d8		48		pha		                pha
.a2d9		b5 02		lda $02,x	                lda 2,x         ; LSB
.a2db		48		pha		                pha
.a2dc		b5 01		lda $01,x	                lda 1,x         ; MSB
.a2de		48		pha		                pha
.a2df		b5 00		lda $00,x	                lda 0,x         ; LSB
.a2e1		48		pha		                pha
.a2e2		e8		inx		                inx
.a2e3		e8		inx		                inx
.a2e4		e8		inx		                inx
.a2e5		e8		inx		                inx
.a2e6		a5 26		lda $26		                lda tmp1+1      ; MSB
.a2e8		48		pha		                pha
.a2e9		a5 25		lda $25		                lda tmp1        ; LSB
.a2eb		48		pha		                pha
.a2ec		60		rts		z_two_to_r:     rts
.a2ed						xt_two_constant:
.a2ed		20 81 d7	jsr $d781	                jsr underflow_2
.a2f0		20 db 88	jsr $88db	                jsr xt_create
.a2f3		20 05 a0	jsr $a005	                jsr xt_swap
.a2f6		20 de 86	jsr $86de	                jsr xt_comma
.a2f9		20 de 86	jsr $86de	                jsr xt_comma
.a2fc		20 5c 8b	jsr $8b5c	                jsr does_runtime    ; does> turns into these two routines.
.a2ff		20 ff d5	jsr $d5ff	                jsr dodoes
.a302		20 07 8d	jsr $8d07	                jsr xt_dup
.a305		20 fe 8e	jsr $8efe	                jsr xt_fetch
.a308		20 05 a0	jsr $a005	                jsr xt_swap
.a30b		20 91 85	jsr $8591	                jsr xt_cell_plus
.a30e		20 fe 8e	jsr $8efe	                jsr xt_fetch
.a311		60		rts		z_two_constant: rts
.a312						xt_two_literal:
.a312		20 81 d7	jsr $d781	                jsr underflow_2 ; double number
.a315		20 05 a0	jsr $a005	                jsr xt_swap
.a318		20 a8 92	jsr $92a8	                jsr xt_literal
.a31b		20 a8 92	jsr $92a8	                jsr xt_literal
.a31e		60		rts		z_two_literal:  rts
.a31f						xt_two_variable:
.a31f		20 db 88	jsr $88db	                jsr xt_create
.a322		ca		dex		                dex
.a323		ca		dex		                dex
.a324		a9 04		lda #$04	                lda #4
.a326		95 00		sta $00,x	                sta 0,x
.a328		74 01		stz $01,x	                stz 1,x
.a32a		20 30 82	jsr $8230	                jsr xt_allot
.a32d		60		rts		z_two_variable: rts
.a32e						xt_type:
.a32e		20 81 d7	jsr $d781	                jsr underflow_2
.a331		b5 02		lda $02,x	                lda 2,x
.a333		85 25		sta $25		                sta tmp1
.a335		b5 03		lda $03,x	                lda 3,x
.a337		85 26		sta $26		                sta tmp1+1
.a339						_loop:
.a339		b5 00		lda $00,x	                lda 0,x
.a33b		15 01		ora $01,x	                ora 1,x
.a33d		f0 15		beq $a354	                beq _done
.a33f		b2 25		lda ($25)	                lda (tmp1)
.a341		20 7b 8d	jsr $8d7b	                jsr emit_a      ; avoids stack foolery
.a344		e6 25		inc $25		                inc tmp1
.a346		d0 02		bne $a34a	                bne +
.a348		e6 26		inc $26		                inc tmp1+1
.a34a						+
.a34a		b5 00		lda $00,x	                lda 0,x
.a34c		d0 02		bne $a350	                bne +
.a34e		d6 01		dec $01,x	                dec 1,x
.a350						+
.a350		d6 00		dec $00,x	                dec 0,x
.a352		80 e5		bra $a339	                bra _loop
.a354						_done:
.a354		e8		inx		                inx
.a355		e8		inx		                inx
.a356		e8		inx		                inx
.a357		e8		inx		                inx
.a358		60		rts		z_type:         rts
.a359						xt_u_dot:
.a359		20 7c d7	jsr $d77c	                jsr underflow_1
.a35c		20 e9 d7	jsr $d7e9	                jsr print_u
.a35f		a9 20		lda #$20	                lda #AscSP
.a361		20 7b 8d	jsr $8d7b	                jsr emit_a
.a364		60		rts		z_u_dot:        rts
.a365						xt_u_dot_r:
.a365		20 81 d7	jsr $d781	                jsr underflow_2
.a368		20 9b a1	jsr $a19b	                jsr xt_to_r
.a36b		20 e4 a5	jsr $a5e4	                jsr xt_zero
.a36e		20 78 92	jsr $9278	                jsr xt_less_number_sign
.a371		20 01 97	jsr $9701	                jsr xt_number_sign_s
.a374		20 df 96	jsr $96df	                jsr xt_number_sign_greater
.a377		20 b3 99	jsr $99b3	                jsr xt_r_from
.a37a		20 b6 97	jsr $97b6	                jsr xt_over
.a37d		20 7f 94	jsr $947f	                jsr xt_minus
.a380		20 81 9f	jsr $9f81	                jsr xt_spaces
.a383		20 2e a3	jsr $a32e	                jsr xt_type
.a386		60		rts		z_u_dot_r:      rts
.a387						xt_u_greater_than:
.a387		20 81 d7	jsr $d781	                jsr underflow_2
.a38a		b5 00		lda $00,x	                lda 0,x
.a38c		d5 02		cmp $02,x	                cmp 2,x
.a38e		b5 01		lda $01,x	                lda 1,x
.a390		f5 03		sbc $03,x	                sbc 3,x
.a392		e8		inx		                inx
.a393		e8		inx		                inx
.a394		a9 00		lda #$00	                lda #0
.a396		69 ff		adc #$ff	                adc #$FF
.a398		95 00		sta $00,x	                sta 0,x         ; store flag
.a39a		95 01		sta $01,x	                sta 1,x
.a39c		60		rts		z_u_greater_than:    rts
.a39d						xt_u_less_than:
.a39d		20 81 d7	jsr $d781	                jsr underflow_2
.a3a0		b5 02		lda $02,x	                lda 2,x
.a3a2		d5 00		cmp $00,x	                cmp 0,x
.a3a4		b5 03		lda $03,x	                lda 3,x
.a3a6		f5 01		sbc $01,x	                sbc 1,x
.a3a8		e8		inx		                inx
.a3a9		e8		inx		                inx
.a3aa		a9 00		lda #$00	                lda #0
.a3ac		69 ff		adc #$ff	                adc #$FF
.a3ae		95 00		sta $00,x	                sta 0,x         ; store flag
.a3b0		95 01		sta $01,x	                sta 1,x
.a3b2		60		rts		z_u_less_than:    rts
.a3b3						xt_ud_dot:
.a3b3		20 81 d7	jsr $d781	                jsr underflow_2 ; double number
.a3b6		20 78 92	jsr $9278	                jsr xt_less_number_sign
.a3b9		20 01 97	jsr $9701	                jsr xt_number_sign_s
.a3bc		20 df 96	jsr $96df	                jsr xt_number_sign_greater
.a3bf		20 2e a3	jsr $a32e	                jsr xt_type
.a3c2		20 7b 9f	jsr $9f7b	                jsr xt_space
.a3c5		60		rts		z_ud_dot:        rts
.a3c6						xt_ud_dot_r:
.a3c6		20 86 d7	jsr $d786	                jsr underflow_3
.a3c9		20 9b a1	jsr $a19b	                jsr xt_to_r
.a3cc		20 78 92	jsr $9278	                jsr xt_less_number_sign
.a3cf		20 01 97	jsr $9701	                jsr xt_number_sign_s
.a3d2		20 df 96	jsr $96df	                jsr xt_number_sign_greater
.a3d5		20 b3 99	jsr $99b3	                jsr xt_r_from
.a3d8		20 b6 97	jsr $97b6	                jsr xt_over
.a3db		20 7f 94	jsr $947f	                jsr xt_minus
.a3de		20 81 9f	jsr $9f81	                jsr xt_spaces
.a3e1		20 2e a3	jsr $a32e	                jsr xt_type
.a3e4		60		rts		z_ud_dot_r:      rts
.a3e5						xt_um_slash_mod:
.a3e5		20 86 d7	jsr $d786	                jsr underflow_3
.a3e8		b5 00		lda $00,x	                lda 0,x
.a3ea		15 01		ora $01,x	                ora 1,x
.a3ec		d0 05		bne $a3f3	                bne _not_zero
.a3ee		a9 04		lda #$04	                lda #err_divzero
.a3f0		4c 92 d7	jmp $d792	                jmp error
.a3f3						_not_zero:
.a3f3		a9 11		lda #$11	                lda #17
.a3f5		85 23		sta $23		                sta tmptos
.a3f7						_loop:
.a3f7		36 04		rol $04,x	                rol 4,x
.a3f9		36 05		rol $05,x	                rol 5,x
.a3fb		c6 23		dec $23		                dec tmptos
.a3fd		f0 22		beq $a421	                beq _done
.a3ff		36 02		rol $02,x	                rol 2,x
.a401		36 03		rol $03,x	                rol 3,x
.a403		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a405		26 25		rol $25		                rol tmp1
.a407		38		sec		                sec
.a408		b5 02		lda $02,x	                lda 2,x
.a40a		f5 00		sbc $00,x	                sbc 0,x
.a40c		85 26		sta $26		                sta tmp1+1
.a40e		b5 03		lda $03,x	                lda 3,x
.a410		f5 01		sbc $01,x	                sbc 1,x
.a412		a8		tay		                tay
.a413		a5 25		lda $25		                lda tmp1
.a415		e9 00		sbc #$00	                sbc #0
.a417		90 de		bcc $a3f7	                bcc _loop
.a419		a5 26		lda $26		                lda tmp1+1
.a41b		95 02		sta $02,x	                sta 2,x
.a41d		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a41f		80 d6		bra $a3f7	                bra _loop
.a421						_done:
.a421		e8		inx		                inx
.a422		e8		inx		                inx
.a423		20 05 a0	jsr $a005	                jsr xt_swap
.a426		60		rts		z_um_slash_mod: rts
.a427						xt_um_star:
.a427		20 81 d7	jsr $d781	                jsr underflow_2
.a42a		18		clc		                clc
.a42b		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a42d		e9 00		sbc #$00	                sbc #0
.a42f		85 27		sta $27		                sta tmp2
.a431		b5 01		lda $01,x	                lda 1,x
.a433		e9 00		sbc #$00	                sbc #0
.a435		90 31		bcc $a468	                bcc _zero       ; is TOS zero?
.a437		85 28		sta $28		                sta tmp2+1
.a439		a9 00		lda #$00	                lda #0
.a43b		85 25		sta $25		                sta tmp1
.a43d		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.a43f		ca		dex		                dex
.a440		ca		dex		                dex
.a441						_outer_loop:
.a441		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a443		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a445						_inner_loop:
.a445		90 0c		bcc $a453	                bcc _no_add
.a447		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.a449		a5 25		lda $25		                lda tmp1
.a44b		65 27		adc $27		                adc tmp2
.a44d		85 25		sta $25		                sta tmp1
.a44f		a5 26		lda $26		                lda tmp1+1
.a451		65 28		adc $28		                adc tmp2+1
.a453						_no_add:
.a453		6a		ror a		                ror
.a454		66 25		ror $25		                ror tmp1
.a456		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a458		88		dey		                dey
.a459		d0 ea		bne $a445	                bne _inner_loop ; go back for one more shift?
.a45b		e8		inx		                inx
.a45c		e4 29		cpx $29		                cpx tmp3
.a45e		d0 e1		bne $a441	                bne _outer_loop ; go back for eight more shifts?
.a460		95 01		sta $01,x	                sta 1,x
.a462		a5 25		lda $25		                lda tmp1
.a464		95 00		sta $00,x	                sta 0,x
.a466		80 04		bra $a46c	                bra _done
.a468						_zero:
.a468		74 02		stz $02,x	                stz 2,x
.a46a		74 03		stz $03,x	                stz 3,x
.a46c						_done:
.a46c		60		rts		z_um_star:      rts
.a46d						xt_unloop:
.a46d		a4 1f		ldy $1f		                ldy loopctrl
.a46f		88		dey		                dey
.a470		88		dey		                dey
.a471		88		dey		                dey
.a472		88		dey		                dey
.a473		84 1f		sty $1f		                sty loopctrl
.a475		30 05		bmi $a47c	                bmi z_unloop            ; no active loops?
.a477		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.a47a		85 20		sta $20		                sta loopidx0
.a47c		60		rts		z_unloop:       rts
.a47d						xt_until:
.a47d		a0 00		ldy #$00	                ldy #0
.a47f						-
.a47f		b9 25 91	lda $9125,y	                lda zero_test_runtime,y
.a482		c9 60		cmp #$60	                cmp #OpRTS
.a484		f0 03		beq $a489	                beq +
.a486		20 c9 d5	jsr $d5c9	                jsr cmpl_a
.a489						+
.a489		c8		iny		                iny
.a48a		c0 0a		cpy #$0a	                cpy #(zero_test_footer_end - zero_test_runtime)
.a48c		d0 f1		bne $a47f	                bne -
.a48e		20 de 86	jsr $86de	                jsr xt_comma
.a491		60		rts		z_until:        rts
.a492						xt_unused:
.a492		ca		dex		                dex
.a493		ca		dex		                dex
.a494		a9 00		lda #$00	                lda #<cp_end
.a496		38		sec		                sec
.a497		e5 00		sbc $00		                sbc cp
.a499		95 00		sta $00,x	                sta 0,x
.a49b		a9 7c		lda #$7c	                lda #>cp_end
.a49d		e5 01		sbc $01		                sbc cp+1
.a49f		95 01		sta $01,x	                sta 1,x
.a4a1		60		rts		z_unused:       rts
.a4a2						xt_update:
.a4a2		a0 30		ldy #$30	                ldy #buffstatus_offset
.a4a4		b1 08		lda ($08),y	                lda (up),y
.a4a6		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a4a8		91 08		sta ($08),y	                sta (up),y
.a4aa		60		rts		z_update:       rts
.a4ab						xt_useraddr:
.a4ab		ca		dex		                dex
.a4ac		ca		dex		                dex
.a4ad		a9 08		lda #$08	                lda #<up
.a4af		95 00		sta $00,x	                sta 0,x
.a4b1		a9 00		lda #$00	                lda #>up
.a4b3		95 01		sta $01,x	                sta 1,x
.a4b5		60		rts		z_useraddr:     rts
.a4b6						xt_variable:
.a4b6		20 db 88	jsr $88db	                jsr xt_create
.a4b9		a9 00		lda #$00	                lda #0
.a4bb		92 00		sta ($00)	                sta (cp)
.a4bd		e6 00		inc $00		                inc cp
.a4bf		d0 02		bne $a4c3	                bne +
.a4c1		e6 01		inc $01		                inc cp+1
.a4c3						+
.a4c3		92 00		sta ($00)	                sta (cp)
.a4c5		e6 00		inc $00		                inc cp
.a4c7		d0 02		bne $a4cb	                bne +
.a4c9		e6 01		inc $01		                inc cp+1
.a4cb						+
.a4cb		20 a3 88	jsr $88a3	                jsr adjust_z
.a4ce		60		rts		z_variable:     rts
.a4cf						xt_while:
.a4cf		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.a4d1		a9 2f		lda #$2f	                lda #<zero_branch_runtime
.a4d3		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.a4d6		20 88 90	jsr $9088	                jsr xt_here
.a4d9		a9 ff		lda #$ff	                lda #$FF
.a4db		a8		tay		                tay
.a4dc		20 c5 d5	jsr $d5c5	                jsr cmpl_word
.a4df		20 05 a0	jsr $a005	                jsr xt_swap
.a4e2		60		rts		z_while:        rts
.a4e3						xt_within:
.a4e3		20 86 d7	jsr $d786	                jsr underflow_3
.a4e6		20 b6 97	jsr $97b6	                jsr xt_over
.a4e9		20 7f 94	jsr $947f	                jsr xt_minus
.a4ec		20 9b a1	jsr $a19b	                jsr xt_to_r
.a4ef		20 7f 94	jsr $947f	                jsr xt_minus
.a4f2		20 b3 99	jsr $99b3	                jsr xt_r_from
.a4f5		20 9d a3	jsr $a39d	                jsr xt_u_less_than
.a4f8		60		rts		z_within:       rts
.a4f9						xt_word:
.a4f9		20 7c d7	jsr $d77c	                jsr underflow_1
.a4fc		a4 10		ldy $10		                ldy toin                ; >IN
.a4fe						_loop:
.a4fe		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.a500		f0 09		beq $a50b	                beq _found_char
.a502		b1 0c		lda ($0c),y	                lda (cib),y
.a504		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a506		d0 03		bne $a50b	                bne _found_char
.a508		c8		iny		                iny
.a509		80 f3		bra $a4fe	                bra _loop
.a50b						_found_char:
.a50b		84 10		sty $10		                sty toin
.a50d		20 5d 98	jsr $985d	                jsr xt_parse            ; Returns ( addr u )
.a510		b5 00		lda $00,x	                lda 0,x
.a512		92 00		sta ($00)	                sta (cp)                ; Save length of string
.a514		48		pha		                pha                     ; Keep copy of length for later
.a515		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( addr u u )
.a518		a5 00		lda $00		                lda cp
.a51a		18		clc		                clc
.a51b		69 01		adc #$01	                adc #1
.a51d		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a51f		a5 01		lda $01		                lda cp+1
.a521		69 00		adc #$00	                adc #0
.a523		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a525		20 f1 94	jsr $94f1	                jsr xt_move
.a528		ca		dex		                dex
.a529		ca		dex		                dex
.a52a		a5 00		lda $00		                lda cp
.a52c		95 00		sta $00,x	                sta 0,x
.a52e		a5 01		lda $01		                lda cp+1
.a530		95 01		sta $01,x	                sta 1,x
.a532		68		pla		                pla                     ; length of string
.a533		18		clc		                clc
.a534		65 00		adc $00		                adc cp
.a536		85 00		sta $00		                sta cp
.a538		90 02		bcc $a53c	                bcc z_word
.a53a		e6 01		inc $01		                inc cp+1
.a53c		60		rts		z_word:         rts
.a53d						xt_wordlist:
.a53d		a0 09		ldy #$09	                ldy #num_wordlists_offset
.a53f		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.a541		c9 0c		cmp #$0c	                cmp #max_wordlists
.a543		d0 05		bne $a54a	                bne _ok
.a545		a9 0b		lda #$0b	                lda #err_wordlist
.a547		4c 92 d7	jmp $d792	                jmp error
.a54a						_ok:
.a54a		1a		inc a		                ina             ; Increment the wordlist#
.a54b		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.a54d		ca		dex		                dex             ; and put it on the stack.
.a54e		ca		dex		                dex
.a54f		95 00		sta $00,x	                sta 0,x
.a551		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a553		60		rts		z_wordlist:     rts
.a554						xt_words:
.a554		20 d5 88	jsr $88d5	                jsr xt_cr
.a557		a9 00		lda #$00	                lda #0
.a559		48		pha		                pha
.a55a		ca		dex		                dex                     ; Make room on the stack for
.a55b		ca		dex		                dex                     ; a dictionary pointer.
.a55c		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.a55e						_wordlist_loop:
.a55e		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a560		a5 29		lda $29		                lda tmp3
.a562		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.a564		d0 02		bne $a568	                bne _have_wordlist
.a566		80 45		bra $a5ad	                bra _words_done
.a568						_have_wordlist:
.a568		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a569		69 23		adc #$23	                adc #search_order_offset
.a56b		a8		tay		                tay
.a56c		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.a56e		0a		asl a		                asl                     ; Turn offset into cells offset.
.a56f		18		clc		                clc
.a570		69 0a		adc #$0a	                adc #wordlists_offset
.a572		a8		tay		                tay
.a573		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.a575		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a577		c8		iny		                iny
.a578		b1 08		lda ($08),y	                lda (up),y
.a57a		95 01		sta $01,x	                sta 1,x
.a57c						_loop:
.a57c		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( nt nt )
.a57f		20 2d 95	jsr $952d	                jsr xt_name_to_string   ; ( nt addr u )
.a582		68		pla		                pla
.a583		18		clc		                clc
.a584		75 00		adc $00,x	                adc 0,x
.a586		1a		inc a		                ina                     ; don't forget the space between words
.a587		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a589		90 06		bcc $a591	                bcc +
.a58b		20 d5 88	jsr $88d5	                jsr xt_cr
.a58e		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a590		1a		inc a		                ina                     ; with length of this word.
.a591						+
.a591		48		pha		                pha
.a592		20 2e a3	jsr $a32e	                jsr xt_type             ; ( nt )
.a595		a9 20		lda #$20	                lda #AscSP
.a597		20 7b 8d	jsr $8d7b	                jsr emit_a
.a59a		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+
.a59d		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+
.a5a0		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; @ ( nt+1 )
.a5a3		b5 00		lda $00,x	                lda 0,x
.a5a5		15 01		ora $01,x	                ora 1,x
.a5a7		d0 d3		bne $a57c	                bne _loop
.a5a9		e6 29		inc $29		                inc tmp3
.a5ab		80 b1		bra $a55e	                bra _wordlist_loop
.a5ad						_words_done:
.a5ad		68		pla		                pla                     ; dump counter
.a5ae		e8		inx		                inx
.a5af		e8		inx		                inx
.a5b0		60		rts		z_words:        rts
.a5b1						xt_wordsize:
.a5b1		20 7c d7	jsr $d77c	                jsr underflow_1
.a5b4		b5 00		lda $00,x	                lda 0,x
.a5b6		85 25		sta $25		                sta tmp1
.a5b8		b5 01		lda $01,x	                lda 1,x
.a5ba		85 26		sta $26		                sta tmp1+1
.a5bc		a0 06		ldy #$06	                ldy #6
.a5be		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.a5c0		88		dey		                dey
.a5c1		88		dey		                dey
.a5c2		38		sec		                sec
.a5c3		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.a5c5		95 00		sta $00,x	                sta 0,x
.a5c7		a0 07		ldy #$07	                ldy #7
.a5c9		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.a5cb		88		dey		                dey
.a5cc		88		dey		                dey
.a5cd		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.a5cf		95 01		sta $01,x	                sta 1,x
.a5d1		60		rts		z_wordsize:     rts
.a5d2						xt_xor:
.a5d2		20 81 d7	jsr $d781	                jsr underflow_2
.a5d5		b5 00		lda $00,x	                lda 0,x
.a5d7		55 02		eor $02,x	                eor 2,x
.a5d9		95 02		sta $02,x	                sta 2,x
.a5db		b5 01		lda $01,x	                lda 1,x
.a5dd		55 03		eor $03,x	                eor 3,x
.a5df		95 03		sta $03,x	                sta 3,x
.a5e1		e8		inx		                inx
.a5e2		e8		inx		                inx
.a5e3		60		rts		z_xor:          rts
.a5e4						xt_case:
.a5e4						xt_false:
.a5e4						xt_forth_wordlist:
.a5e4						xt_zero:
.a5e4		ca		dex		                dex             ; push
.a5e5		ca		dex		                dex
.a5e6		74 00		stz $00,x	                stz 0,x
.a5e8		74 01		stz $01,x	                stz 1,x
.a5ea						z_case:
.a5ea						z_false:
.a5ea						z_forth_wordlist:
.a5ea						z_zero:
.a5ea		60		rts		                rts
.a5eb						xt_zero_equal:
.a5eb		20 7c d7	jsr $d77c	                jsr underflow_1
.a5ee		b5 00		lda $00,x	                lda 0,x
.a5f0		15 01		ora $01,x	                ora 1,x
.a5f2		f0 02		beq $a5f6	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.a5f4		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.a5f6						_zero:
.a5f6		49 ff		eor #$ff	                eor #$FF        ; now just invert
.a5f8						_store:
.a5f8		95 00		sta $00,x	                sta 0,x
.a5fa		95 01		sta $01,x	                sta 1,x
.a5fc		60		rts		z_zero_equal:   rts
.a5fd						xt_zero_greater:
.a5fd		20 7c d7	jsr $d77c	                jsr underflow_1
.a600		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a602		b5 01		lda $01,x	                lda 1,x         ; MSB
.a604		30 05		bmi $a60b	                bmi _done       ; TOS is negative, keep FLASE
.a606		15 00		ora $00,x	                ora 0,x
.a608		f0 01		beq $a60b	                beq _done       ; TOS is zero, keep FALSE
.a60a		88		dey		                dey             ; TOS is postive, make true
.a60b						_done:
.a60b		98		tya		                tya
.a60c		95 00		sta $00,x	                sta 0,x
.a60e		95 01		sta $01,x	                sta 1,x
.a610		60		rts		z_zero_greater: rts
.a611						xt_zero_less:
.a611		20 7c d7	jsr $d77c	                jsr underflow_1
.a614		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a616		b5 01		lda $01,x	                lda 1,x         ; MSB
.a618		10 01		bpl $a61b	                bpl _done       ; TOS is positive, so keep FALSE
.a61a		88		dey		                dey             ; TOS is negative, make TRUE
.a61b						_done:
.a61b		98		tya		                tya
.a61c		95 00		sta $00,x	                sta 0,x
.a61e		95 01		sta $01,x	                sta 1,x
.a620		60		rts		z_zero_less:    rts
.a621						xt_zero_unequal:
.a621		20 7c d7	jsr $d77c	                jsr underflow_1
.a624		b5 00		lda $00,x	                lda 0,x
.a626		15 01		ora $01,x	                ora 1,x
.a628		f0 02		beq $a62c	                beq _zero
.a62a		a9 ff		lda #$ff	                lda #$FF
.a62c						_zero:
.a62c		95 00		sta $00,x	                sta 0,x
.a62e		95 01		sta $01,x	                sta 1,x
.a630		60		rts		z_zero_unequal: rts
.a631						xt_editor_screen_helper:
.a631		20 07 8d	jsr $8d07	                jsr xt_dup
.a634		20 49 9d	jsr $9d49	                jsr xt_scr
.a637		20 ea 9f	jsr $9fea	                jsr xt_store
.a63a		20 30 85	jsr $8530	                jsr xt_buffer
.a63d						z_editor_screen_helper:
.a63d		60		rts		                rts
.a63e						xt_editor_enter_screen:
.a63e		20 31 a6	jsr $a631	                jsr xt_editor_screen_helper
.a641		20 86 8c	jsr $8c86	                jsr xt_drop
.a644		64 35		stz $35		                stz ed_head
.a646						_prompt_loop:
.a646		ca		dex		                dex
.a647		ca		dex		                dex
.a648		a5 35		lda $35		                lda ed_head
.a64a		95 00		sta $00,x	                sta 0,x
.a64c		74 01		stz $01,x	                stz 1,x
.a64e		20 11 a7	jsr $a711	                jsr xt_editor_o
.a651		e6 35		inc $35		                inc ed_head
.a653		a9 10		lda #$10	                lda #16
.a655		c5 35		cmp $35		                cmp ed_head
.a657		d0 ed		bne $a646	                bne _prompt_loop
.a659						z_editor_enter_screen:
.a659		60		rts		                rts
.a65a						xt_editor_erase_screen:
.a65a		20 31 a6	jsr $a631	                jsr xt_editor_screen_helper
.a65d		ca		dex		                dex
.a65e		ca		dex		                dex
.a65f		74 00		stz $00,x	                stz 0,x
.a661		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a663		95 01		sta $01,x	                sta 1,x
.a665		20 6f 8e	jsr $8e6f	                jsr xt_blank
.a668		20 a2 a4	jsr $a4a2	                jsr xt_update
.a66b						z_editor_erase_screen:
.a66b		60		rts		                rts
.a66c						xt_editor_el:
.a66c		20 f8 a6	jsr $a6f8	                jsr xt_editor_line
.a66f		ca		dex		                dex
.a670		ca		dex		                dex
.a671		a9 40		lda #$40	                lda #64
.a673		95 00		sta $00,x	                sta 0,x
.a675		74 01		stz $01,x	                stz 1,x
.a677		20 6f 8e	jsr $8e6f	                jsr xt_blank
.a67a		20 a2 a4	jsr $a4a2	                jsr xt_update
.a67d		60		rts		z_editor_el:    rts
.a67e						xt_editor_l:
.a67e		ca		dex		                dex             ; Put SCR on the stack.
.a67f		ca		dex		                dex
.a680		a0 06		ldy #$06	                ldy #scr_offset
.a682		b1 08		lda ($08),y	                lda (up),y
.a684		95 00		sta $00,x	                sta 0,x
.a686		c8		iny		                iny
.a687		b1 08		lda ($08),y	                lda (up),y
.a689		95 01		sta $01,x	                sta 1,x
.a68b		20 5d 83	jsr $835d	                jsr xt_block    ; Get the current screen.
.a68e		20 d5 88	jsr $88d5	                jsr xt_cr
.a691		80 08		bra $a69b	                bra _after_screen_msg
.a693						_screen_msg:
>a693		53 63 72 65 65 6e 20 23		                .text "Screen #"
.a69b						_after_screen_msg:
.a69b		20 06 9f	jsr $9f06	                jsr sliteral_runtime
>a69e		93 a6 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a6a2		20 2e a3	jsr $a32e	                jsr xt_type
.a6a5		20 49 9d	jsr $9d49	                jsr xt_scr
.a6a8		20 fe 8e	jsr $8efe	                jsr xt_fetch
.a6ab		ca		dex		                dex
.a6ac		ca		dex		                dex
.a6ad		a9 04		lda #$04	                lda #4          ; four spaces
.a6af		95 00		sta $00,x	                sta 0,x
.a6b1		74 01		stz $01,x	                stz 1,x
.a6b3		20 65 a3	jsr $a365	                jsr xt_u_dot_r
.a6b6		64 29		stz $29		                stz tmp3
.a6b8						_line_loop:
.a6b8		20 d5 88	jsr $88d5	                jsr xt_cr
.a6bb		ca		dex		                dex
.a6bc		ca		dex		                dex
.a6bd		ca		dex		                dex
.a6be		ca		dex		                dex
.a6bf		74 03		stz $03,x	                stz 3,x
.a6c1		a5 29		lda $29		                lda tmp3
.a6c3		95 02		sta $02,x	                sta 2,x
.a6c5		74 01		stz $01,x	                stz 1,x
.a6c7		a9 02		lda #$02	                lda #2
.a6c9		95 00		sta $00,x	                sta 0,x
.a6cb		20 65 a3	jsr $a365	                jsr xt_u_dot_r
.a6ce		20 7b 9f	jsr $9f7b	                jsr xt_space
.a6d1		20 07 8d	jsr $8d07	                jsr xt_dup
.a6d4		ca		dex		                dex
.a6d5		ca		dex		                dex
.a6d6		a9 40		lda #$40	                lda #64
.a6d8		95 00		sta $00,x	                sta 0,x
.a6da		74 01		stz $01,x	                stz 1,x
.a6dc		20 2e a3	jsr $a32e	                jsr xt_type
.a6df		18		clc		                clc
.a6e0		a9 40		lda #$40	                lda #64
.a6e2		75 00		adc $00,x	                adc 0,x
.a6e4		95 00		sta $00,x	                sta 0,x
.a6e6		90 02		bcc $a6ea	                bcc +
.a6e8		f6 01		inc $01,x	                inc 1,x
.a6ea						+
.a6ea		e6 29		inc $29		                inc tmp3
.a6ec		a5 29		lda $29		                lda tmp3
.a6ee		c9 10		cmp #$10	                cmp #16
.a6f0		d0 c6		bne $a6b8	                bne _line_loop
.a6f2		20 d5 88	jsr $88d5	                jsr xt_cr
.a6f5		e8		inx		                inx
.a6f6		e8		inx		                inx
.a6f7		60		rts		z_editor_l:            rts
.a6f8						xt_editor_line:
.a6f8		20 7c d7	jsr $d77c	                jsr underflow_1
.a6fb		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a6fd						_shift_tos_left:
.a6fd		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a6ff		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a701		88		dey		                dey
.a702		d0 f9		bne $a6fd	                bne _shift_tos_left
.a704		20 49 9d	jsr $9d49	                jsr xt_scr
.a707		20 fe 8e	jsr $8efe	                jsr xt_fetch
.a70a		20 5d 83	jsr $835d	                jsr xt_block
.a70d		20 04 99	jsr $9904	                jsr xt_plus
.a710		60		rts		z_editor_line:  rts
.a711						xt_editor_o:
.a711		20 d5 88	jsr $88d5	                jsr xt_cr
.a714		20 07 8d	jsr $8d07	                jsr xt_dup
.a717		20 d2 a1	jsr $a1d2	                jsr xt_two
.a71a		20 65 a3	jsr $a365	                jsr xt_u_dot_r
.a71d		20 7b 9f	jsr $9f7b	                jsr xt_space
.a720		a9 2a		lda #$2a	                lda #'*'
.a722		20 7b 8d	jsr $8d7b	                jsr emit_a
.a725		20 7b 9f	jsr $9f7b	                jsr xt_space
.a728		20 f8 a6	jsr $a6f8	                jsr xt_editor_line
.a72b		20 07 8d	jsr $8d07	                jsr xt_dup      ; Save a copy of the line address for later.
.a72e		ca		dex		                dex
.a72f		ca		dex		                dex
.a730		a9 40		lda #$40	                lda #64         ; chars/line
.a732		95 00		sta $00,x	                sta 0,x
.a734		74 01		stz $01,x	                stz 1,x
.a736		20 e6 80	jsr $80e6	                jsr xt_accept
.a739		20 07 8d	jsr $8d07	                jsr xt_dup
.a73c		20 94 95	jsr $9594	                jsr xt_not_rote ; -rot
.a73f		20 04 99	jsr $9904	                jsr xt_plus
.a742		ca		dex		                dex
.a743		ca		dex		                dex
.a744		a9 40		lda #$40	                lda #64         ; chars/line
.a746		95 00		sta $00,x	                sta 0,x
.a748		74 01		stz $01,x	                stz 1,x
.a74a		20 71 9a	jsr $9a71	                jsr xt_rot
.a74d		20 7f 94	jsr $947f	                jsr xt_minus
.a750		20 6f 8e	jsr $8e6f	                jsr xt_blank
.a753		20 a2 a4	jsr $a4a2	                jsr xt_update
.a756		60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.a757						cold_zp_table:
>a757	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>a759	0002	21 bb				dp:         .word dictionary_start  ; Dictionary Pointer
>a75b	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>a75d	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>a75f	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>a761	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>a763	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>a765	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>a767	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>a769	0012	27 f0				output:     .word kernel_putc       ; vector for EMIT
>a76b	0014	21 f0				input:      .word kernel_getc       ; vector for KEY
>a76d	0016	00 00				havekey:    .word 0                 ; vector for KEY?
>a76f	0018	0a 00				base:       .word 10                ; number radix, default decimal
>a771	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>a773	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>a775	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>a776	001f					loopctrl:   .byte ?         ; Offset and flags for DO/LOOP/+LOOP control.
>a777	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$100						lcbstack = $100
=256						loopindex = lcbstack+0      ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack+2      ; loop control block offset for limit fudge factor
>a778	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>a77a	0023					tmptos:     .word ?         ; temporary TOS storage
>a77c	0025					tmp1:       .word ?         ; temporary storage
>a77e	0027					tmp2:       .word ?         ; temporary storage
>a780	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>a782	002b					tohold:     .word ?         ; pointer for formatted output
>a784	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>a78c	0035					tmped:      .word ?,?,?     ; temporary for editors
.a775						cold_zp_table_end:
.a775						cold_user_table:
>a775	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>a777	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>a779	0004	00 00				blk_offset:             .word 0         ; BLK
>a77b	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
>a77d	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>a77e	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.a77f	000a					wordlists_offset:
>a77f	000a	21 bb				    .word dictionary_start              ; FORTH-WORDLIST
>a781	000c	6a c9				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>a783	000e	ba c9				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>a785	0010	29 c9				    .word root_dictionary_start         ; ROOT-WORDLIST
>a787	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>a78f	001a	00 00 00 00 00 00 00 00
>a797	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.a798	0023					search_order_offset:
>a798	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>a7a0	002b	00
>a7a1	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>a7a3	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>a7a5	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>a7a7	0032	ec 84				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>a7a9	0034	ec 84				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.a7ab						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a7ab						assembler:
.a7ab						xt_asm_adc_h:
.a7ab		a9 69		lda #$69	                lda #$69
.a7ad		4c 06 ab	jmp $ab06	                jmp asm_common
.a7b0						z_asm_adc_h:
.a7b0						xt_asm_adc_x:
.a7b0		a9 7d		lda #$7d	                lda #$7D
.a7b2		4c 06 ab	jmp $ab06	                jmp asm_common
.a7b5						z_asm_adc_x:
.a7b5						xt_asm_adc_y:
.a7b5		a9 79		lda #$79	                lda #$79
.a7b7		4c 06 ab	jmp $ab06	                jmp asm_common
.a7ba						z_asm_adc_y:
.a7ba						xt_asm_adc_z:
.a7ba		a9 65		lda #$65	                lda #$65
.a7bc		4c 06 ab	jmp $ab06	                jmp asm_common
.a7bf						z_asm_adc_z:
.a7bf						xt_asm_adc_zi:
.a7bf		a9 72		lda #$72	                lda #$72
.a7c1		4c 06 ab	jmp $ab06	                jmp asm_common
.a7c4						z_asm_adc_zi:
.a7c4						xt_asm_adc_ziy:
.a7c4		a9 71		lda #$71	                lda #$71
.a7c6		4c 06 ab	jmp $ab06	                jmp asm_common
.a7c9						z_asm_adc_ziy:
.a7c9						xt_asm_adc_zx:
.a7c9		a9 75		lda #$75	                lda #$75
.a7cb		4c 06 ab	jmp $ab06	                jmp asm_common
.a7ce						z_asm_adc_zx:
.a7ce						xt_asm_adc_zxi:
.a7ce		a9 61		lda #$61	                lda #$61
.a7d0		4c 06 ab	jmp $ab06	                jmp asm_common
.a7d3						z_asm_adc_zxi:
.a7d3						xt_asm_and:
.a7d3		a9 2d		lda #$2d	                lda #$2D
.a7d5		4c 06 ab	jmp $ab06	                jmp asm_common
.a7d8						z_asm_and:
.a7d8						xt_asm_and_h:
.a7d8		a9 29		lda #$29	                lda #$29
.a7da		4c 06 ab	jmp $ab06	                jmp asm_common
.a7dd						z_asm_and_h:
.a7dd						xt_asm_and_x:
.a7dd		a9 3d		lda #$3d	                lda #$3D
.a7df		4c 06 ab	jmp $ab06	                jmp asm_common
.a7e2						z_asm_and_x:
.a7e2						xt_asm_and_y:
.a7e2		a9 39		lda #$39	                lda #$39
.a7e4		4c 06 ab	jmp $ab06	                jmp asm_common
.a7e7						z_asm_and_y:
.a7e7						xt_asm_and_z:
.a7e7		a9 25		lda #$25	                lda #$25
.a7e9		4c 06 ab	jmp $ab06	                jmp asm_common
.a7ec						z_asm_and_z:
.a7ec						xt_asm_and_zi:
.a7ec		a9 32		lda #$32	                lda #$32
.a7ee		4c 06 ab	jmp $ab06	                jmp asm_common
.a7f1						z_asm_and_zi:
.a7f1						xt_asm_and_ziy:
.a7f1		a9 31		lda #$31	                lda #$31
.a7f3		4c 06 ab	jmp $ab06	                jmp asm_common
.a7f6						z_asm_and_ziy:
.a7f6						xt_asm_and_zx:
.a7f6		a9 35		lda #$35	                lda #$35
.a7f8		4c 06 ab	jmp $ab06	                jmp asm_common
.a7fb						z_asm_and_zx:
.a7fb						xt_asm_and_zxi:
.a7fb		a9 21		lda #$21	                lda #$21
.a7fd		4c 06 ab	jmp $ab06	                jmp asm_common
.a800						z_asm_and_zxi:
.a800						xt_asm_asl:
.a800		a9 0e		lda #$0e	                lda #$0E
.a802		4c 06 ab	jmp $ab06	                jmp asm_common
.a805						z_asm_asl:
.a805						xt_asm_asl_a:
.a805		a9 0a		lda #$0a	                lda #$0A
.a807		4c 06 ab	jmp $ab06	                jmp asm_common
.a80a						z_asm_asl_a:
.a80a						xt_asm_asl_x:
.a80a		a9 1e		lda #$1e	                lda #$1E
.a80c		4c 06 ab	jmp $ab06	                jmp asm_common
.a80f						z_asm_asl_x:
.a80f						xt_asm_asl_z:
.a80f		a9 06		lda #$06	                lda #$06
.a811		4c 06 ab	jmp $ab06	                jmp asm_common
.a814						z_asm_asl_z:
.a814						xt_asm_asl_zx:
.a814		a9 16		lda #$16	                lda #$16
.a816		4c 06 ab	jmp $ab06	                jmp asm_common
.a819						z_asm_asl_zx:
.a819						xt_asm_bcc:
.a819		a9 90		lda #$90	                lda #$90
.a81b		4c 06 ab	jmp $ab06	                jmp asm_common
.a81e						z_asm_bcc:
.a81e						xt_asm_bcs:
.a81e		a9 b0		lda #$b0	                lda #$B0
.a820		a0 02		ldy #$02	                ldy #2
.a822		4c 06 ab	jmp $ab06	                jmp asm_common
.a825						z_asm_bcs:
.a825						xt_asm_beq:
.a825		a9 f0		lda #$f0	                lda #$F0
.a827		4c 06 ab	jmp $ab06	                jmp asm_common
.a82a						z_asm_beq:
.a82a						xt_asm_bit:
.a82a		a9 2c		lda #$2c	                lda #$2C
.a82c		4c 06 ab	jmp $ab06	                jmp asm_common
.a82f						z_asm_bit:
.a82f						xt_asm_bit_h:
.a82f		a9 89		lda #$89	                lda #$89
.a831		4c 06 ab	jmp $ab06	                jmp asm_common
.a834						z_asm_bit_h:
.a834						xt_asm_bit_x:
.a834		a9 3c		lda #$3c	                lda #$3C
.a836		4c 06 ab	jmp $ab06	                jmp asm_common
.a839						z_asm_bit_x:
.a839						xt_asm_bit_z:
.a839		a9 24		lda #$24	                lda #$24
.a83b		4c 06 ab	jmp $ab06	                jmp asm_common
.a83e						z_asm_bit_z:
.a83e						xt_asm_bit_zx:
.a83e		a9 34		lda #$34	                lda #$34
.a840		4c 06 ab	jmp $ab06	                jmp asm_common
.a843						z_asm_bit_zx:
.a843						xt_asm_bmi:
.a843		a9 30		lda #$30	                lda #$30
.a845		4c 06 ab	jmp $ab06	                jmp asm_common
.a848						z_asm_bmi:
.a848						xt_asm_bne:
.a848		a9 d0		lda #$d0	                lda #$D0
.a84a		4c 06 ab	jmp $ab06	                jmp asm_common
.a84d						z_asm_bne:
.a84d						xt_asm_bpl:
.a84d		a9 10		lda #$10	                lda #$10
.a84f		4c 06 ab	jmp $ab06	                jmp asm_common
.a852						z_asm_bpl:
.a852						xt_asm_bra:
.a852		a9 80		lda #$80	                lda #$80
.a854		4c 06 ab	jmp $ab06	                jmp asm_common
.a857						z_asm_bra:
.a857						xt_asm_brk:
.a857		a9 00		lda #$00	                lda #$00
.a859		4c 06 ab	jmp $ab06	                jmp asm_common
.a85c						z_asm_brk:
.a85c						xt_asm_bvc:
.a85c		a9 50		lda #$50	                lda #$50
.a85e		4c 06 ab	jmp $ab06	                jmp asm_common
.a861						z_asm_bvc:
.a861						xt_asm_bvs:
.a861		a9 70		lda #$70	                lda #$70
.a863		4c 06 ab	jmp $ab06	                jmp asm_common
.a866						z_asm_bvs:
.a866						xt_asm_clc:
.a866		a9 18		lda #$18	                lda #$18
.a868		4c 06 ab	jmp $ab06	                jmp asm_common
.a86b						z_asm_clc:
.a86b						xt_asm_cld:
.a86b		a9 d8		lda #$d8	                lda #$D8
.a86d		4c 06 ab	jmp $ab06	                jmp asm_common
.a870						z_asm_cld:
.a870						xt_asm_cli:
.a870		a9 58		lda #$58	                lda #$58
.a872		4c 06 ab	jmp $ab06	                jmp asm_common
.a875						z_asm_cli:
.a875						xt_asm_clv:
.a875		a9 b8		lda #$b8	                lda #$B8
.a877		4c 06 ab	jmp $ab06	                jmp asm_common
.a87a						z_asm_clv:
.a87a						xt_asm_cmp:
.a87a		a9 cd		lda #$cd	                lda #$CD
.a87c		4c 06 ab	jmp $ab06	                jmp asm_common
.a87f						z_asm_cmp:
.a87f						xt_asm_cmp_h:
.a87f		a9 c9		lda #$c9	                lda #$C9
.a881		4c 06 ab	jmp $ab06	                jmp asm_common
.a884						z_asm_cmp_h:
.a884						xt_asm_cmp_x:
.a884		a9 dd		lda #$dd	                lda #$DD
.a886		4c 06 ab	jmp $ab06	                jmp asm_common
.a889						z_asm_cmp_x:
.a889						xt_asm_cmp_y:
.a889		a9 d9		lda #$d9	                lda #$D9
.a88b		4c 06 ab	jmp $ab06	                jmp asm_common
.a88e						z_asm_cmp_y:
.a88e						xt_asm_cmp_z:
.a88e		a9 c5		lda #$c5	                lda #$C5
.a890		4c 06 ab	jmp $ab06	                jmp asm_common
.a893						z_asm_cmp_z:
.a893						xt_asm_cmp_zi:
.a893		a9 d2		lda #$d2	                lda #$D2
.a895		4c 06 ab	jmp $ab06	                jmp asm_common
.a898						z_asm_cmp_zi:
.a898						xt_asm_cmp_ziy:
.a898		a9 d1		lda #$d1	                lda #$D1
.a89a		4c 06 ab	jmp $ab06	                jmp asm_common
.a89d						z_asm_cmp_ziy:
.a89d						xt_asm_cmp_zx:
.a89d		a9 d5		lda #$d5	                lda #$D5
.a89f		4c 06 ab	jmp $ab06	                jmp asm_common
.a8a2						z_asm_cmp_zx:
.a8a2						xt_asm_cmp_zxi:
.a8a2		a9 c1		lda #$c1	                lda #$C1
.a8a4		4c 06 ab	jmp $ab06	                jmp asm_common
.a8a7						z_asm_cmp_zxi:
.a8a7						xt_asm_cpx:
.a8a7		a9 ec		lda #$ec	                lda #$EC
.a8a9		4c 06 ab	jmp $ab06	                jmp asm_common
.a8ac						z_asm_cpx:
.a8ac						xt_asm_cpx_h:
.a8ac		a9 e0		lda #$e0	                lda #$E0
.a8ae		4c 06 ab	jmp $ab06	                jmp asm_common
.a8b1						z_asm_cpx_h:
.a8b1						xt_asm_cpx_z:
.a8b1		a9 e4		lda #$e4	                lda #$E4
.a8b3		4c 06 ab	jmp $ab06	                jmp asm_common
.a8b6						z_asm_cpx_z:
.a8b6						xt_asm_cpy:
.a8b6		a9 cc		lda #$cc	                lda #$CC
.a8b8		a0 03		ldy #$03	                ldy #3
.a8ba		4c 06 ab	jmp $ab06	                jmp asm_common
.a8bd						z_asm_cpy:
.a8bd						xt_asm_cpy_h:
.a8bd		a9 c0		lda #$c0	                lda #$C0
.a8bf		4c 06 ab	jmp $ab06	                jmp asm_common
.a8c2						z_asm_cpy_h:
.a8c2						xt_asm_cpy_z:
.a8c2		a9 c4		lda #$c4	                lda #$C4
.a8c4		4c 06 ab	jmp $ab06	                jmp asm_common
.a8c7						z_asm_cpy_z:
.a8c7						xt_asm_dec:
.a8c7		a9 ce		lda #$ce	                lda #$CE
.a8c9		4c 06 ab	jmp $ab06	                jmp asm_common
.a8cc						z_asm_dec:
.a8cc						xt_asm_dec_a:
.a8cc		a9 3a		lda #$3a	                lda #$3A
.a8ce		4c 06 ab	jmp $ab06	                jmp asm_common
.a8d1						z_asm_dec_a:
.a8d1						xt_asm_dec_x:
.a8d1		a9 de		lda #$de	                lda #$DE
.a8d3		4c 06 ab	jmp $ab06	                jmp asm_common
.a8d6						z_asm_dec_x:
.a8d6						xt_asm_dec_z:
.a8d6		a9 c6		lda #$c6	                lda #$C6
.a8d8		4c 06 ab	jmp $ab06	                jmp asm_common
.a8db						z_asm_dec_z:
.a8db						xt_asm_dec_zx:
.a8db		a9 d6		lda #$d6	                lda #$D6
.a8dd		4c 06 ab	jmp $ab06	                jmp asm_common
.a8e0						z_asm_dec_zx:
.a8e0						xt_asm_dex:
.a8e0		a9 ca		lda #$ca	                lda #$CA
.a8e2		4c 06 ab	jmp $ab06	                jmp asm_common
.a8e5						z_asm_dex:
.a8e5						xt_asm_dey:
.a8e5		a9 88		lda #$88	                lda #$88
.a8e7		4c 06 ab	jmp $ab06	                jmp asm_common
.a8ea						z_asm_dey:
.a8ea						xt_asm_eor:
.a8ea		a9 4d		lda #$4d	                lda #$4D
.a8ec		4c 06 ab	jmp $ab06	                jmp asm_common
.a8ef						z_asm_eor:
.a8ef						xt_asm_eor_h:
.a8ef		a9 49		lda #$49	                lda #$49
.a8f1		4c 06 ab	jmp $ab06	                jmp asm_common
.a8f4						z_asm_eor_h:
.a8f4						xt_asm_eor_x:
.a8f4		a9 5d		lda #$5d	                lda #$5D
.a8f6		4c 06 ab	jmp $ab06	                jmp asm_common
.a8f9						z_asm_eor_x:
.a8f9						xt_asm_eor_y:
.a8f9		a9 59		lda #$59	                lda #$59
.a8fb		4c 06 ab	jmp $ab06	                jmp asm_common
.a8fe						z_asm_eor_y:
.a8fe						xt_asm_eor_z:
.a8fe		a9 45		lda #$45	                lda #$45
.a900		4c 06 ab	jmp $ab06	                jmp asm_common
.a903						z_asm_eor_z:
.a903						xt_asm_eor_zi:
.a903		a9 52		lda #$52	                lda #$52
.a905		4c 06 ab	jmp $ab06	                jmp asm_common
.a908						z_asm_eor_zi:
.a908						xt_asm_eor_ziy:
.a908		a9 51		lda #$51	                lda #$51
.a90a		4c 06 ab	jmp $ab06	                jmp asm_common
.a90d						z_asm_eor_ziy:
.a90d						xt_asm_eor_zx:
.a90d		a9 55		lda #$55	                lda #$55
.a90f		4c 06 ab	jmp $ab06	                jmp asm_common
.a912						z_asm_eor_zx:
.a912						xt_asm_eor_zxi:
.a912		a9 41		lda #$41	                lda #$41
.a914		4c 06 ab	jmp $ab06	                jmp asm_common
.a917						z_asm_eor_zxi:
.a917						xt_asm_inc:
.a917		a9 ee		lda #$ee	                lda #$EE
.a919		4c 06 ab	jmp $ab06	                jmp asm_common
.a91c						z_asm_inc:
.a91c						xt_asm_inc_a:
.a91c		a9 1a		lda #$1a	                lda #$1A
.a91e		4c 06 ab	jmp $ab06	                jmp asm_common
.a921						z_asm_inc_a:
.a921						xt_asm_inc_x:
.a921		a9 fe		lda #$fe	                lda #$FE
.a923		4c 06 ab	jmp $ab06	                jmp asm_common
.a926						z_asm_inc_x:
.a926						xt_asm_inc_z:
.a926		a9 e6		lda #$e6	                lda #$E6
.a928		4c 06 ab	jmp $ab06	                jmp asm_common
.a92b						z_asm_inc_z:
.a92b						xt_asm_inc_zx:
.a92b		a9 f6		lda #$f6	                lda #$F6
.a92d		4c 06 ab	jmp $ab06	                jmp asm_common
.a930						z_asm_inc_zx:
.a930						xt_asm_inx:
.a930		a9 e8		lda #$e8	                lda #$E8
.a932		4c 06 ab	jmp $ab06	                jmp asm_common
.a935						z_asm_inx:
.a935						xt_asm_iny:
.a935		a9 c8		lda #$c8	                lda #$C8
.a937		4c 06 ab	jmp $ab06	                jmp asm_common
.a93a						z_asm_iny:
.a93a						xt_asm_jmp:
.a93a		a9 4c		lda #$4c	                lda #$4C
.a93c		4c 06 ab	jmp $ab06	                jmp asm_common
.a93f						z_asm_jmp:
.a93f						xt_asm_jmp_i:
.a93f		a9 6c		lda #$6c	                lda #$6C
.a941		4c 06 ab	jmp $ab06	                jmp asm_common
.a944						z_asm_jmp_i:
.a944						xt_asm_jmp_xi:
.a944		a9 7c		lda #$7c	                lda #$7C
.a946		4c 06 ab	jmp $ab06	                jmp asm_common
.a949						z_asm_jmp_xi:
.a949						xt_asm_jsr:
.a949		a9 20		lda #$20	                lda #$20
.a94b		4c 06 ab	jmp $ab06	                jmp asm_common
.a94e						z_asm_jsr:
.a94e						xt_asm_lda:
.a94e		a9 ad		lda #$ad	                lda #$AD
.a950		4c 06 ab	jmp $ab06	                jmp asm_common
.a953						z_asm_lda:
.a953						xt_asm_lda_h:
.a953		a9 a9		lda #$a9	                lda #$A9
.a955		4c 06 ab	jmp $ab06	                jmp asm_common
.a958						z_asm_lda_h:
.a958						xt_asm_lda_x:
.a958		a9 bd		lda #$bd	                lda #$BD
.a95a		4c 06 ab	jmp $ab06	                jmp asm_common
.a95d						z_asm_lda_x:
.a95d						xt_asm_lda_y:
.a95d		a9 b9		lda #$b9	                lda #$B9
.a95f		4c 06 ab	jmp $ab06	                jmp asm_common
.a962						z_asm_lda_y:
.a962						xt_asm_lda_z:
.a962		a9 a5		lda #$a5	                lda #$A5
.a964		4c 06 ab	jmp $ab06	                jmp asm_common
.a967						z_asm_lda_z:
.a967						xt_asm_lda_zi:
.a967		a9 b2		lda #$b2	                lda #$B2
.a969		4c 06 ab	jmp $ab06	                jmp asm_common
.a96c						z_asm_lda_zi:
.a96c						xt_asm_lda_ziy:
.a96c		a9 b1		lda #$b1	                lda #$B1
.a96e		4c 06 ab	jmp $ab06	                jmp asm_common
.a971						z_asm_lda_ziy:
.a971						xt_asm_lda_zx:
.a971		a9 b5		lda #$b5	                lda #$B5
.a973		4c 06 ab	jmp $ab06	                jmp asm_common
.a976						z_asm_lda_zx:
.a976						xt_asm_lda_zxi:
.a976		a9 a1		lda #$a1	                lda #$A1
.a978		4c 06 ab	jmp $ab06	                jmp asm_common
.a97b						z_asm_lda_zxi:
.a97b						xt_asm_ldx:
.a97b		a9 ae		lda #$ae	                lda #$AE
.a97d		4c 06 ab	jmp $ab06	                jmp asm_common
.a980						z_asm_ldx:
.a980						xt_asm_ldx_h:
.a980		a9 a2		lda #$a2	                lda #$A2
.a982		4c 06 ab	jmp $ab06	                jmp asm_common
.a985						z_asm_ldx_h:
.a985						xt_asm_ldx_y:
.a985		a9 be		lda #$be	                lda #$BE
.a987		4c 06 ab	jmp $ab06	                jmp asm_common
.a98a						z_asm_ldx_y:
.a98a						xt_asm_ldx_z:
.a98a		a9 a6		lda #$a6	                lda #$A6
.a98c		4c 06 ab	jmp $ab06	                jmp asm_common
.a98f						z_asm_ldx_z:
.a98f						xt_asm_ldx_zy:
.a98f		a9 b6		lda #$b6	                lda #$B6
.a991		4c 06 ab	jmp $ab06	                jmp asm_common
.a994						z_asm_ldx_zy:
.a994						xt_asm_ldy:
.a994		a9 ac		lda #$ac	                lda #$AC
.a996		4c 06 ab	jmp $ab06	                jmp asm_common
.a999						z_asm_ldy:
.a999						xt_asm_ldy_h:
.a999		a9 a0		lda #$a0	                lda #$A0
.a99b		4c 06 ab	jmp $ab06	                jmp asm_common
.a99e						z_asm_ldy_h:
.a99e						xt_asm_ldy_x:
.a99e		a9 bc		lda #$bc	                lda #$BC
.a9a0		4c 06 ab	jmp $ab06	                jmp asm_common
.a9a3						z_asm_ldy_x:
.a9a3						xt_asm_ldy_z:
.a9a3		a9 a4		lda #$a4	                lda #$A4
.a9a5		4c 06 ab	jmp $ab06	                jmp asm_common
.a9a8						z_asm_ldy_z:
.a9a8						xt_asm_ldy_zx:
.a9a8		a9 b4		lda #$b4	                lda #$B4
.a9aa		4c 06 ab	jmp $ab06	                jmp asm_common
.a9ad						z_asm_ldy_zx:
.a9ad						xt_asm_lsr:
.a9ad		a9 4e		lda #$4e	                lda #$4E
.a9af		4c 06 ab	jmp $ab06	                jmp asm_common
.a9b2						z_asm_lsr:
.a9b2						xt_asm_lsr_a:
.a9b2		a9 4a		lda #$4a	                lda #$4A
.a9b4		4c 06 ab	jmp $ab06	                jmp asm_common
.a9b7						z_asm_lsr_a:
.a9b7						xt_asm_lsr_x:
.a9b7		a9 5e		lda #$5e	                lda #$5E
.a9b9		4c 06 ab	jmp $ab06	                jmp asm_common
.a9bc						z_asm_lsr_x:
.a9bc						xt_asm_lsr_z:
.a9bc		a9 46		lda #$46	                lda #$46
.a9be		4c 06 ab	jmp $ab06	                jmp asm_common
.a9c1						z_asm_lsr_z:
.a9c1						xt_asm_lsr_zx:
.a9c1		a9 56		lda #$56	                lda #$56
.a9c3		4c 06 ab	jmp $ab06	                jmp asm_common
.a9c6						z_asm_lsr_zx:
.a9c6						xt_asm_nop:
.a9c6		a9 ea		lda #$ea	                lda #$EA
.a9c8		4c 06 ab	jmp $ab06	                jmp asm_common
.a9cb						z_asm_nop:
.a9cb						xt_asm_ora:
.a9cb		a9 0d		lda #$0d	                lda #$0D
.a9cd		4c 06 ab	jmp $ab06	                jmp asm_common
.a9d0						z_asm_ora:
.a9d0						xt_asm_ora_h:
.a9d0		a9 09		lda #$09	                lda #$09
.a9d2		4c 06 ab	jmp $ab06	                jmp asm_common
.a9d5						z_asm_ora_h:
.a9d5						xt_asm_ora_x:
.a9d5		a9 1d		lda #$1d	                lda #$1D
.a9d7		4c 06 ab	jmp $ab06	                jmp asm_common
.a9da						z_asm_ora_x:
.a9da						xt_asm_ora_y:
.a9da		a9 19		lda #$19	                lda #$19
.a9dc		4c 06 ab	jmp $ab06	                jmp asm_common
.a9df						z_asm_ora_y:
.a9df						xt_asm_ora_z:
.a9df		a9 05		lda #$05	                lda #$05
.a9e1		4c 06 ab	jmp $ab06	                jmp asm_common
.a9e4						z_asm_ora_z:
.a9e4						xt_asm_ora_zi:
.a9e4		a9 12		lda #$12	                lda #$12
.a9e6		a0 02		ldy #$02	                ldy #2
.a9e8		4c 06 ab	jmp $ab06	                jmp asm_common
.a9eb						z_asm_ora_zi:
.a9eb						xt_asm_ora_ziy:
.a9eb		a9 11		lda #$11	                lda #$11
.a9ed		4c 06 ab	jmp $ab06	                jmp asm_common
.a9f0						z_asm_ora_ziy:
.a9f0						xt_asm_ora_zx:
.a9f0		a9 15		lda #$15	                lda #$15
.a9f2		4c 06 ab	jmp $ab06	                jmp asm_common
.a9f5						z_asm_ora_zx:
.a9f5						xt_asm_ora_zxi:
.a9f5		a9 01		lda #$01	                lda #$01
.a9f7		4c 06 ab	jmp $ab06	                jmp asm_common
.a9fa						z_asm_ora_zxi:
.a9fa						xt_asm_pha:
.a9fa		a9 48		lda #$48	                lda #$48
.a9fc		4c 06 ab	jmp $ab06	                jmp asm_common
.a9ff						z_asm_pha:
.a9ff						xt_asm_php:
.a9ff		a9 08		lda #$08	                lda #$08
.aa01		4c 06 ab	jmp $ab06	                jmp asm_common
.aa04						z_asm_php:
.aa04						xt_asm_phx:
.aa04		a9 da		lda #$da	                lda #$DA
.aa06		4c 06 ab	jmp $ab06	                jmp asm_common
.aa09						z_asm_phx:
.aa09						xt_asm_phy:
.aa09		a9 5a		lda #$5a	                lda #$5A
.aa0b		4c 06 ab	jmp $ab06	                jmp asm_common
.aa0e						z_asm_phy:
.aa0e						xt_asm_pla:
.aa0e		a9 68		lda #$68	                lda #$68
.aa10		4c 06 ab	jmp $ab06	                jmp asm_common
.aa13						z_asm_pla:
.aa13						xt_asm_plp:
.aa13		a9 28		lda #$28	                lda #$28
.aa15		4c 06 ab	jmp $ab06	                jmp asm_common
.aa18						z_asm_plp:
.aa18						xt_asm_plx:
.aa18		a9 fa		lda #$fa	                lda #$FA
.aa1a		4c 06 ab	jmp $ab06	                jmp asm_common
.aa1d						z_asm_plx:
.aa1d						xt_asm_ply:
.aa1d		a9 7a		lda #$7a	                lda #$7A
.aa1f		4c 06 ab	jmp $ab06	                jmp asm_common
.aa22						z_asm_ply:
.aa22						xt_asm_rol:
.aa22		a9 2e		lda #$2e	                lda #$2E
.aa24		4c 06 ab	jmp $ab06	                jmp asm_common
.aa27						z_asm_rol:
.aa27						xt_asm_rol_a:
.aa27		a9 2a		lda #$2a	                lda #$2A
.aa29		4c 06 ab	jmp $ab06	                jmp asm_common
.aa2c						z_asm_rol_a:
.aa2c						xt_asm_rol_x:
.aa2c		a9 3e		lda #$3e	                lda #$3E
.aa2e		4c 06 ab	jmp $ab06	                jmp asm_common
.aa31						z_asm_rol_x:
.aa31						xt_asm_rol_z:
.aa31		a9 26		lda #$26	                lda #$26
.aa33		4c 06 ab	jmp $ab06	                jmp asm_common
.aa36						z_asm_rol_z:
.aa36						xt_asm_rol_zx:
.aa36		a9 36		lda #$36	                lda #$36
.aa38		4c 06 ab	jmp $ab06	                jmp asm_common
.aa3b						z_asm_rol_zx:
.aa3b						xt_asm_ror:
.aa3b		a9 6e		lda #$6e	                lda #$6E
.aa3d		4c 06 ab	jmp $ab06	                jmp asm_common
.aa40						z_asm_ror:
.aa40						xt_asm_ror_a:
.aa40		a9 6a		lda #$6a	                lda #$6A
.aa42		4c 06 ab	jmp $ab06	                jmp asm_common
.aa45						z_asm_ror_a:
.aa45						xt_asm_ror_x:
.aa45		a9 7e		lda #$7e	                lda #$7E
.aa47		4c 06 ab	jmp $ab06	                jmp asm_common
.aa4a						z_asm_ror_x:
.aa4a						xt_asm_ror_z:
.aa4a		a9 66		lda #$66	                lda #$66
.aa4c		4c 06 ab	jmp $ab06	                jmp asm_common
.aa4f						z_asm_ror_z:
.aa4f						xt_asm_ror_zx:
.aa4f		a9 76		lda #$76	                lda #$76
.aa51		4c 06 ab	jmp $ab06	                jmp asm_common
.aa54						z_asm_ror_zx:
.aa54						xt_asm_rti:
.aa54		a9 40		lda #$40	                lda #$40
.aa56		4c 06 ab	jmp $ab06	                jmp asm_common
.aa59						z_asm_rti:
.aa59						xt_asm_rts:
.aa59		a9 60		lda #$60	                lda #$60
.aa5b		4c 06 ab	jmp $ab06	                jmp asm_common
.aa5e						z_asm_rts:
.aa5e						xt_asm_sbc:
.aa5e		a9 ed		lda #$ed	                lda #$ED
.aa60		4c 06 ab	jmp $ab06	                jmp asm_common
.aa63						z_asm_sbc:
.aa63						xt_asm_sbc_h:
.aa63		a9 e9		lda #$e9	                lda #$E9
.aa65		4c 06 ab	jmp $ab06	                jmp asm_common
.aa68						z_asm_sbc_h:
.aa68						xt_asm_sbc_x:
.aa68		a9 fd		lda #$fd	                lda #$FD
.aa6a		4c 06 ab	jmp $ab06	                jmp asm_common
.aa6d						z_asm_sbc_x:
.aa6d						xt_asm_sbc_y:
.aa6d		a9 f9		lda #$f9	                lda #$F9
.aa6f		4c 06 ab	jmp $ab06	                jmp asm_common
.aa72						z_asm_sbc_y:
.aa72						xt_asm_sbc_z:
.aa72		a9 e5		lda #$e5	                lda #$E5
.aa74		4c 06 ab	jmp $ab06	                jmp asm_common
.aa77						z_asm_sbc_z:
.aa77						xt_asm_sbc_zi:
.aa77		a9 f2		lda #$f2	                lda #$F2
.aa79		4c 06 ab	jmp $ab06	                jmp asm_common
.aa7c						z_asm_sbc_zi:
.aa7c						xt_asm_sbc_ziy:
.aa7c		a9 f1		lda #$f1	                lda #$F1
.aa7e		4c 06 ab	jmp $ab06	                jmp asm_common
.aa81						z_asm_sbc_ziy:
.aa81						xt_asm_sbc_zx:
.aa81		a9 f5		lda #$f5	                lda #$F5
.aa83		4c 06 ab	jmp $ab06	                jmp asm_common
.aa86						z_asm_sbc_zx:
.aa86						xt_asm_sbc_zxi:
.aa86		a9 e1		lda #$e1	                lda #$E1
.aa88		80 7c		bra $ab06	                bra asm_common  ; <-- limit for BRA instead of JMP
.aa8a						z_asm_sbc_zxi:
.aa8a						xt_asm_sec:
.aa8a		a9 38		lda #$38	                lda #$38
.aa8c		80 78		bra $ab06	                bra asm_common
.aa8e						z_asm_sec:
.aa8e						xt_asm_sed:
.aa8e		a9 f8		lda #$f8	                lda #$F8
.aa90		80 74		bra $ab06	                bra asm_common
.aa92						z_asm_sed:
.aa92						xt_asm_sei:
.aa92		a9 78		lda #$78	                lda #$78
.aa94		80 70		bra $ab06	                bra asm_common
.aa96						z_asm_sei:
.aa96						xt_asm_sta:
.aa96		a9 8d		lda #$8d	                lda #$8D
.aa98		80 6c		bra $ab06	                bra asm_common
.aa9a						z_asm_sta:
.aa9a						xt_asm_sta_x:
.aa9a		a9 9d		lda #$9d	                lda #$9D
.aa9c		80 68		bra $ab06	                bra asm_common
.aa9e						z_asm_sta_x:
.aa9e						xt_asm_sta_y:
.aa9e		a9 99		lda #$99	                lda #$99
.aaa0		80 64		bra $ab06	                bra asm_common
.aaa2						z_asm_sta_y:
.aaa2						xt_asm_sta_z:
.aaa2		a9 85		lda #$85	                lda #$85
.aaa4		80 60		bra $ab06	                bra asm_common
.aaa6						z_asm_sta_z:
.aaa6						xt_asm_sta_zi:
.aaa6		a9 92		lda #$92	                lda #$92
.aaa8		80 5c		bra $ab06	                bra asm_common
.aaaa						z_asm_sta_zi:
.aaaa						xt_asm_sta_ziy:
.aaaa		a9 91		lda #$91	                lda #$91
.aaac		80 58		bra $ab06	                bra asm_common
.aaae						z_asm_sta_ziy:
.aaae						xt_asm_sta_zx:
.aaae		a9 95		lda #$95	                lda #$95
.aab0		80 54		bra $ab06	                bra asm_common
.aab2						z_asm_sta_zx:
.aab2						xt_asm_sta_zxi:
.aab2		a9 81		lda #$81	                lda #$81
.aab4		80 50		bra $ab06	                bra asm_common
.aab6						z_asm_sta_zxi:
.aab6						xt_asm_stx:
.aab6		a9 8e		lda #$8e	                lda #$8E
.aab8		80 4c		bra $ab06	                bra asm_common
.aaba						z_asm_stx:
.aaba						xt_asm_stx_z:
.aaba		a9 86		lda #$86	                lda #$86
.aabc		80 48		bra $ab06	                bra asm_common
.aabe						z_asm_stx_z:
.aabe						xt_asm_stx_zy:
.aabe		a9 96		lda #$96	                lda #$96
.aac0		80 44		bra $ab06	                bra asm_common
.aac2						z_asm_stx_zy:
.aac2						xt_asm_sty:
.aac2		a9 8c		lda #$8c	                lda #$8C
.aac4		80 40		bra $ab06	                bra asm_common
.aac6						z_asm_sty:
.aac6						xt_asm_sty_z:
.aac6		a9 84		lda #$84	                lda #$84
.aac8		80 3c		bra $ab06	                bra asm_common
.aaca						z_asm_sty_z:
.aaca						xt_asm_sty_zx:
.aaca		a9 94		lda #$94	                lda #$94
.aacc		80 38		bra $ab06	                bra asm_common
.aace						z_asm_sty_zx:
.aace						xt_asm_stz:
.aace		a9 9c		lda #$9c	                lda #$9C
.aad0		80 34		bra $ab06	                bra asm_common
.aad2						z_asm_stz:
.aad2						xt_asm_stz_x:
.aad2		a9 9e		lda #$9e	                lda #$9E
.aad4		80 30		bra $ab06	                bra asm_common
.aad6						z_asm_stz_x:
.aad6						xt_asm_stz_z:
.aad6		a9 64		lda #$64	                lda #$64
.aad8		80 2c		bra $ab06	                bra asm_common
.aada						z_asm_stz_z:
.aada						xt_asm_stz_zx:
.aada		a9 74		lda #$74	                lda #$74
.aadc		80 28		bra $ab06	                bra asm_common
.aade						z_asm_stz_zx:
.aade						xt_asm_tax:
.aade		a9 aa		lda #$aa	                lda #$AA
.aae0		80 24		bra $ab06	                bra asm_common
.aae2						z_asm_tax:
.aae2						xt_asm_tay:
.aae2		a9 a8		lda #$a8	                lda #$A8
.aae4		80 20		bra $ab06	                bra asm_common
.aae6						z_asm_tay:
.aae6						xt_asm_trb:
.aae6		a9 1c		lda #$1c	                lda #$1C
.aae8		80 1c		bra $ab06	                bra asm_common
.aaea						z_asm_trb:
.aaea						xt_asm_trb_z:
.aaea		a9 14		lda #$14	                lda #$14
.aaec		80 18		bra $ab06	                bra asm_common
.aaee						z_asm_trb_z:
.aaee						xt_asm_tsb:
.aaee		a9 0c		lda #$0c	                lda #$0C
.aaf0		80 14		bra $ab06	                bra asm_common
.aaf2						z_asm_tsb:
.aaf2						xt_asm_tsb_z:
.aaf2		a9 04		lda #$04	                lda #$04
.aaf4		80 10		bra $ab06	                bra asm_common
.aaf6						z_asm_tsb_z:
.aaf6						xt_asm_tsx:
.aaf6		a9 ba		lda #$ba	                lda #$BA
.aaf8		80 0c		bra $ab06	                bra asm_common
.aafa						z_asm_tsx:
.aafa						xt_asm_txa:
.aafa		a9 8a		lda #$8a	                lda #$8A
.aafc		80 08		bra $ab06	                bra asm_common
.aafe						z_asm_txa:
.aafe						xt_asm_txs:
.aafe		a9 9a		lda #$9a	                lda #$9A
.ab00		80 04		bra $ab06	                bra asm_common
.ab02						z_asm_txs:
.ab02						xt_asm_tya:
.ab02		a9 98		lda #$98	                lda #$98
.ab04		80 00		bra $ab06	                bra asm_common
.ab06						z_asm_tya:
.ab06						asm_common:
.ab06		a8		tay		                tay
.ab07		20 c9 d5	jsr $d5c9	                jsr cmpl_a
.ab0a		a9 b6		lda #$b6	                lda #<oc_index_table
.ab0c		85 27		sta $27		                sta tmp2
.ab0e		a9 ad		lda #$ad	                lda #>oc_index_table
.ab10		85 28		sta $28		                sta tmp2+1
.ab12		98		tya		                tya             ; retrieve opcode
.ab13		0a		asl a		                asl             ; times two for offset
.ab14		90 02		bcc $ab18	                bcc +
.ab16		e6 28		inc $28		                inc tmp2+1
.ab18						+
.ab18		a8		tay		                tay             ; use Y as the index
.ab19		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.ab1b		85 29		sta $29		                sta tmp3
.ab1d		c8		iny		                iny
.ab1e		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.ab20		85 2a		sta $2a		                sta tmp3+1
.ab22		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.ab24		2a		rol a		                rol
.ab25		2a		rol a		                rol
.ab26		2a		rol a		                rol             ; Three times because we go through Carry
.ab27		29 03		and #$03	                and #%00000011
.ab29		a8		tay		                tay
.ab2a		88		dey		                dey
.ab2b		f0 12		beq $ab3f	                beq _done
.ab2d		20 7c d7	jsr $d77c	                jsr underflow_1
.ab30		b5 00		lda $00,x	                lda 0,x
.ab32		20 c9 d5	jsr $d5c9	                jsr cmpl_a      ; does not use Y
.ab35		88		dey		                dey
.ab36		f0 05		beq $ab3d	                beq _done_drop
.ab38		b5 01		lda $01,x	                lda 1,x
.ab3a		20 c9 d5	jsr $d5c9	                jsr cmpl_a      ; Fall through to _done_drop
.ab3d						_done_drop:
.ab3d		e8		inx		                inx
.ab3e		e8		inx		                inx             ; Fall through to _done
.ab3f						_done:
.ab3f		60		rts		                rts             ; Returns to original caller
.ab40						xt_asm_push_a:
.ab40		a0 00		ldy #$00	                ldy #0
.ab42						_loop:
.ab42		b9 50 ab	lda $ab50,y	                lda asm_push_a_data,y
.ab45		c9 ff		cmp #$ff	                cmp #$FF
.ab47		f0 06		beq $ab4f	                beq _done
.ab49		20 c9 d5	jsr $d5c9	                jsr cmpl_a      ; does not change Y
.ab4c		c8		iny		                iny
.ab4d		80 f3		bra $ab42	                bra _loop
.ab4f						_done:
.ab4f						z_asm_push_a:
.ab4f		60		rts		                rts
.ab50						asm_push_a_data:
>ab50		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>ab56		ff				        .byte $FF               ; terminator
.ab57						xt_asm_back_jump:
.ab57						z_asm_back_jump:
.ab57		60		rts		                rts
.ab58						xt_asm_back_branch:
.ab58		20 88 90	jsr $9088	                jsr xt_here             ; ( addr-l addr-h )
.ab5b		20 7f 94	jsr $947f	                jsr xt_minus            ; ( offset )
.ab5e		3a		dec a		                dea
.ab5f		3a		dec a		                dea
.ab60						z_asm_back_branch:
.ab60		60		rts		                rts
.ab61						assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.ab61						disassembler:
.ab61		20 d5 88	jsr $88d5	                jsr xt_cr       ; ( addr u )
.ab64						_byte_loop:
.ab64		20 b6 97	jsr $97b6	                jsr xt_over     ; ( addr u addr )
.ab67		20 59 a3	jsr $a359	                jsr xt_u_dot    ; ( addr u )
.ab6a		20 7b 9f	jsr $9f7b	                jsr xt_space
.ab6d		a9 b6		lda #$b6	                lda #<oc_index_table
.ab6f		85 27		sta $27		                sta tmp2
.ab71		a9 ad		lda #$ad	                lda #>oc_index_table
.ab73		85 28		sta $28		                sta tmp2+1
.ab75		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.ab77		85 2d		sta $2d		                sta scratch     ; Save opcode
.ab79		0a		asl a		                asl             ; multiply by two for offset
.ab7a		90 02		bcc $ab7e	                bcc +
.ab7c		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.ab7e						+
.ab7e		a8		tay		                tay             ; use Y as the index
.ab7f		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.ab81		85 29		sta $29		                sta tmp3
.ab83		48		pha		                pha
.ab84		c8		iny		                iny
.ab85		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.ab87		85 2a		sta $2a		                sta tmp3+1
.ab89		48		pha		                pha
.ab8a		b2 29		lda ($29)	                lda (tmp3)
.ab8c		a8		tay		                tay                     ; save copy of lengths byte
.ab8d		10 3c		bpl $abcb	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.ab8f		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ab92		f6 04		inc $04,x	                inc 4,x
.ab94		d0 02		bne $ab98	                bne +
.ab96		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ab98						+
.ab98		b5 02		lda $02,x	                lda 2,x
.ab9a		d0 02		bne $ab9e	                bne +
.ab9c		d6 03		dec $03,x	                dec 3,x
.ab9e						+
.ab9e		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.aba0		a1 04		lda ($04,x)	                lda (4,x)
.aba2		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.aba4		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.aba6		98		tya		                tya                     ; retrieve copy of lengths byte
.aba7		2a		rol a		                rol                     ; shift bit 6 to bit 7
.aba8		10 14		bpl $abbe	                bpl _print_operand
.abaa		f6 04		inc $04,x	                inc 4,x
.abac		d0 02		bne $abb0	                bne +
.abae		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.abb0						+
.abb0		b5 02		lda $02,x	                lda 2,x
.abb2		d0 02		bne $abb6	                bne +
.abb4		d6 03		dec $03,x	                dec 3,x
.abb6						+
.abb6		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.abb8		a1 04		lda ($04,x)	                lda (4,x)
.abba		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.abbc		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.abbe						_print_operand:
.abbe		ca		dex		                dex
.abbf		ca		dex		                dex
.abc0		a9 05		lda #$05	                lda #5
.abc2		95 00		sta $00,x	                sta 0,x
.abc4		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.abc6		20 65 a3	jsr $a365	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.abc9		80 0b		bra $abd6	                bra _print_mnemonic
.abcb						_no_operand:
.abcb		ca		dex		                dex
.abcc		ca		dex		                dex
.abcd		a9 05		lda #$05	                lda #5
.abcf		95 00		sta $00,x	                sta 0,x
.abd1		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.abd3		20 81 9f	jsr $9f81	                jsr xt_spaces           ; ( addr u )
.abd6						_print_mnemonic:
.abd6		20 7b 9f	jsr $9f7b	                jsr xt_space
.abd9		ca		dex		                dex
.abda		ca		dex		                dex                     ; ( addr u ? )
.abdb		68		pla		                pla                     ; MSB
.abdc		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.abde		68		pla		                pla                     ; LSB
.abdf		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.abe1		20 c1 88	jsr $88c1	                jsr xt_count            ; ( addr u addr-o u-o )
.abe4		74 01		stz $01,x	                stz 1,x                 ; paranoid
.abe6		b5 00		lda $00,x	                lda 0,x
.abe8		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.abea		95 00		sta $00,x	                sta 0,x
.abec		20 2e a3	jsr $a32e	                jsr xt_type             ; ( addr u )
.abef		a5 2d		lda $2d		                lda scratch
.abf1		c9 20		cmp #$20	                cmp #OpJSR
.abf3		d0 4e		bne $ac43	                bne _not_jsr
.abf5		ca		dex		                dex
.abf6		ca		dex		                dex
.abf7		a9 05		lda #$05	                lda #5
.abf9		95 00		sta $00,x	                sta 0,x
.abfb		74 01		stz $01,x	                stz 1,x
.abfd		20 81 9f	jsr $9f81	                jsr xt_spaces
.ac00		a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.ac02		b9 2f ac	lda $ac2f,y	_check_handler: lda _special_handlers,y
.ac05		c5 2e		cmp $2e		                cmp scratch+1
.ac07		d0 07		bne $ac10	                bne _next_handler
.ac09		b9 30 ac	lda $ac30,y	                lda _special_handlers+1,y
.ac0c		c5 2f		cmp $2f		                cmp scratch+2
.ac0e		f0 0c		beq $ac1c	                beq _run_handler
.ac10		88		dey		_next_handler:  dey
.ac11		88		dey		                dey
.ac12		88		dey		                dey
.ac13		88		dey		                dey
.ac14		10 ec		bpl $ac02	                bpl _check_handler
.ac16						_not_special:
.ac16		20 66 ad	jsr $ad66	                jsr disasm_jsr
.ac19		4c ad ac	jmp $acad	                jmp _printing_done
.ac1c						_run_handler:
.ac1c		b9 31 ac	lda $ac31,y	                lda _special_handlers+2,y
.ac1f		85 30		sta $30		                sta scratch+3
.ac21		b9 32 ac	lda $ac32,y	                lda _special_handlers+3,y
.ac24		85 31		sta $31		                sta scratch+4
.ac26		20 2c ac	jsr $ac2c	                jsr _dispatch_handler
.ac29		4c ad ac	jmp $acad	                jmp _printing_done
.ac2c						_dispatch_handler:
.ac2c		6c 30 00	jmp ($0030)	                jmp (scratch+3)
.ac2f						_special_handlers:
>ac2f		b6 92 48 ad			    .word literal_runtime,      disasm_literal
>ac33		06 9f f3 ac			    .word sliteral_runtime,     disasm_sliteral
>ac37		2f 91 2a ad			    .word zero_branch_runtime,  disasm_0branch
>ac3b		25 91 36 ad			    .word zero_test_runtime,    disasm_0test
>ac3f		1a 8b 3e ad			    .word do_runtime,           disasm_do
.ac43						_end_handlers:
.ac43						_not_jsr:
.ac43		c9 4c		cmp #$4c	                cmp #OpJMP
.ac45		d0 2c		bne $ac73	                bne _not_jmp
.ac47		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.ac49		85 30		sta $30		                sta scratch+3
.ac4b		a5 2f		lda $2f		                lda scratch+2
.ac4d		85 31		sta $31		                sta scratch+4
.ac4f		b2 30		lda ($30)	                lda (scratch+3)
.ac51		c9 20		cmp #$20	                cmp #OpJSR ; check for JSR
.ac53		d0 58		bne $acad	                bne _printing_done
.ac55		e6 30		inc $30		                inc scratch+3
.ac57		d0 02		bne $ac5b	                bne +
.ac59		e6 31		inc $31		                inc scratch+4
.ac5b						+
.ac5b		b2 30		lda ($30)	                lda (scratch+3)
.ac5d		c9 06		cmp #$06	                cmp #<sliteral_runtime
.ac5f		d0 4c		bne $acad	                bne _printing_done
.ac61		e6 30		inc $30		                inc scratch+3
.ac63		d0 02		bne $ac67	                bne +
.ac65		e6 31		inc $31		                inc scratch+4
.ac67						+
.ac67		b2 30		lda ($30)	                lda (scratch+3)
.ac69		c9 9f		cmp #$9f	                cmp #>sliteral_runtime
.ac6b		d0 40		bne $acad	                bne _printing_done
.ac6d		20 c9 ac	jsr $acc9	                jsr disasm_sliteral_jump
.ac70		4c ad ac	jmp $acad	                jmp _printing_done
.ac73						_not_jmp:
.ac73		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.ac75		f0 06		beq $ac7d	                beq _is_rel
.ac77		29 1f		and #$1f	                and #$1F
.ac79		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.ac7b		d0 30		bne $acad	                bne _printing_done
.ac7d						_is_rel:
.ac7d		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.ac7f		ca		dex		                dex
.ac80		ca		dex		                dex
.ac81		74 01		stz $01,x	                stz 1,x
.ac83		a5 2e		lda $2e		                lda scratch+1
.ac85		95 00		sta $00,x	                sta 0,x
.ac87		10 04		bpl $ac8d	                bpl +
.ac89		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.ac8b		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.ac8d		38		sec		+               sec                 ; start counting from address after opcode
.ac8e		75 04		adc $04,x	                adc 4,x
.ac90		95 00		sta $00,x	                sta 0,x
.ac92		b5 01		lda $01,x	                lda 1,x
.ac94		75 05		adc $05,x	                adc 5,x
.ac96		95 01		sta $01,x	                sta 1,x
.ac98		5a		phy		                phy                 ; save the direction indicator
.ac99		ca		dex		                dex
.ac9a		ca		dex		                dex
.ac9b		a9 09		lda #$09	                lda #9
.ac9d		95 00		sta $00,x	                sta 0,x
.ac9f		74 01		stz $01,x	                stz 1,x
.aca1		20 65 a3	jsr $a365	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.aca4		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.aca6		20 7b 8d	jsr $8d7b	                jsr emit_a
.aca9		68		pla		                pla
.acaa		20 7b 8d	jsr $8d7b	                jsr emit_a
.acad						_printing_done:
.acad		20 d5 88	jsr $88d5	                jsr xt_cr
.acb0		f6 02		inc $02,x	                inc 2,x
.acb2		d0 02		bne $acb6	                bne +
.acb4		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.acb6						+
.acb6		20 34 97	jsr $9734	                jsr xt_one_minus        ; ( addr+1 u-1 )
.acb9		b5 00		lda $00,x	                lda 0,x                 ; All done?
.acbb		15 01		ora $01,x	                ora 1,x
.acbd		f0 07		beq $acc6	                beq _done
.acbf		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.acc1		30 03		bmi $acc6	                bmi _done
.acc3		4c 64 ab	jmp $ab64	                jmp _byte_loop          ; out of range for BRA
.acc6						_done:
.acc6		4c db a1	jmp $a1db	                jmp xt_two_drop         ; JSR/RTS
.acc9						disasm_sliteral_jump:
.acc9		20 05 a0	jsr $a005	                jsr xt_swap
.accc		ca		dex		                dex
.accd		ca		dex		                dex
.acce		a5 2e		lda $2e		                lda scratch+1
.acd0		95 00		sta $00,x	                sta 0,x
.acd2		a5 2f		lda $2f		                lda scratch+2
.acd4		95 01		sta $01,x	                sta 1,x
.acd6		20 05 a0	jsr $a005	                jsr xt_swap
.acd9		20 7f 94	jsr $947f	                jsr xt_minus
.acdc		20 34 97	jsr $9734	                jsr xt_one_minus
.acdf		20 7f 94	jsr $947f	                jsr xt_minus
.ace2		ca		dex		                dex
.ace3		ca		dex		                dex
.ace4		a5 2e		lda $2e		                lda scratch+1
.ace6		95 00		sta $00,x	                sta 0,x
.ace8		a5 2f		lda $2f		                lda scratch+2
.acea		95 01		sta $01,x	                sta 1,x
.acec		20 34 97	jsr $9734	                jsr xt_one_minus
.acef		20 05 a0	jsr $a005	                jsr xt_swap ; ( new_addr new_n )
.acf2		60		rts		                rts
.acf3						disasm_sliteral:
.acf3		a9 53		lda #$53	                lda #'S'
.acf5		20 7b 8d	jsr $8d7b	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.acf8		a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.acfa		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.acfd		20 05 a0	jsr $a005	                jsr xt_swap             ; switch to (u addr)
.ad00		20 40 97	jsr $9740	                jsr xt_one_plus
.ad03		20 07 8d	jsr $8d07	                jsr xt_dup
.ad06		20 fe 8e	jsr $8efe	                jsr xt_fetch
.ad09		20 59 a3	jsr $a359	                jsr xt_u_dot            ; Print the address of the string
.ad0c		20 d2 a1	jsr $a1d2	                jsr xt_two
.ad0f		20 04 99	jsr $9904	                jsr xt_plus
.ad12		20 07 8d	jsr $8d07	                jsr xt_dup
.ad15		20 83 99	jsr $9983	                jsr xt_question         ; Print the length of the string
.ad18		20 40 97	jsr $9740	                jsr xt_one_plus
.ad1b		20 05 a0	jsr $a005	                jsr xt_swap            ; ( addr+4 u )
.ad1e		ca		dex		                dex
.ad1f		ca		dex		                dex
.ad20		a9 04		lda #$04	                lda #4
.ad22		95 00		sta $00,x	                sta 0,x
.ad24		74 01		stz $01,x	                stz 1,x
.ad26		20 7f 94	jsr $947f	                jsr xt_minus            ; ( addr+4 u-4 )
.ad29		60		rts		                rts
.ad2a						disasm_0branch:
.ad2a		a9 30		lda #$30	                lda #'0'
.ad2c		20 7b 8d	jsr $8d7b	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ad2f						disasm_branch:
.ad2f		a9 0e		lda #$0e	                lda #str_disasm_bra
.ad31		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf ; "BRANCH "
.ad34		80 17		bra $ad4d	                bra disasm_print_literal
.ad36						disasm_0test:
.ad36		a9 0f		lda #$0f	                lda #str_disasm_0test
.ad38		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.ad3b		4c 7b 8d	jmp $8d7b	                jmp emit_a
.ad3e						disasm_do:
.ad3e		a9 44		lda #$44	                lda #'D'
.ad40		20 7b 8d	jsr $8d7b	                jsr emit_a
.ad43		a9 4f		lda #$4f	                lda #'O'
.ad45		4c 7b 8d	jmp $8d7b	                jmp emit_a
.ad48						disasm_literal:
.ad48		a9 0c		lda #$0c	                lda #str_disasm_lit
.ad4a		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf ; "LITERAL "
.ad4d						disasm_print_literal:
.ad4d		20 05 a0	jsr $a005	                jsr xt_swap ; switch to (u addr)
.ad50		20 40 97	jsr $9740	                jsr xt_one_plus
.ad53		20 07 8d	jsr $8d07	                jsr xt_dup
.ad56		20 83 99	jsr $9983	                jsr xt_question ; Print the value at the address
.ad59		20 40 97	jsr $9740	                jsr xt_one_plus
.ad5c		20 05 a0	jsr $a005	                jsr xt_swap ; (addr+2 u)
.ad5f		20 34 97	jsr $9734	                jsr xt_one_minus
.ad62		20 34 97	jsr $9734	                jsr xt_one_minus ; (addr+2 u-2)
.ad65		60		rts		                rts
.ad66						disasm_jsr:
.ad66		ca		dex		                dex
.ad67		ca		dex		                dex
.ad68		a5 2e		lda $2e		                lda scratch+1
.ad6a		95 00		sta $00,x	                sta 0,x
.ad6c		a5 2f		lda $2f		                lda scratch+2
.ad6e		95 01		sta $01,x	                sta 1,x
.ad70		20 87 91	jsr $9187	                jsr xt_int_to_name
.ad73		b5 00		lda $00,x	                lda 0,x
.ad75		15 01		ora $01,x	                ora 1,x
.ad77		f0 07		beq $ad80	                beq _disasm_no_nt
.ad79		20 2d 95	jsr $952d	                jsr xt_name_to_string
.ad7c		20 2e a3	jsr $a32e	                jsr xt_type
.ad7f		60		rts		                rts
.ad80						_disasm_no_nt:
.ad80		20 86 8c	jsr $8c86	                jsr xt_drop ; the 0 indicating no name token
.ad83		ca		dex		                dex
.ad84		ca		dex		                dex
.ad85		a5 2e		lda $2e		                lda scratch+1
.ad87		95 00		sta $00,x	                sta 0,x
.ad89		a5 2f		lda $2f		                lda scratch+2
.ad8b		95 01		sta $01,x	                sta 1,x
.ad8d		ca		dex		                dex
.ad8e		ca		dex		                dex
.ad8f		a9 7c		lda #$7c	                lda #<underflow_1
.ad91		95 00		sta $00,x	                sta 0,x
.ad93		a9 d7		lda #$d7	                lda #>underflow_1
.ad95		95 01		sta $01,x	                sta 1,x
.ad97		20 a8 d6	jsr $d6a8	                jsr compare_16bit
.ad9a		f0 02		beq $ad9e	                beq _disasm_jsr_uflow_check_upper
.ad9c		b0 14		bcs $adb2	                bcs _disasm_jsr_unknown
.ad9e						_disasm_jsr_uflow_check_upper:
.ad9e		a9 8b		lda #$8b	                lda #<underflow_4
.ada0		95 00		sta $00,x	                sta 0,x
.ada2		a9 d7		lda #$d7	                lda #>underflow_4
.ada4		95 01		sta $01,x	                sta 1,x
.ada6		20 a8 d6	jsr $d6a8	                jsr compare_16bit
.ada9		f0 02		beq $adad	                beq _disasm_jsr_soc
.adab		90 05		bcc $adb2	                bcc _disasm_jsr_unknown
.adad						_disasm_jsr_soc:
.adad		a9 0d		lda #$0d	                lda #str_disasm_sdc
.adaf		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.adb2						_disasm_jsr_unknown:
.adb2		20 db a1	jsr $a1db	                jsr xt_two_drop
.adb5		60		rts		                rts
.adb6						oc_index_table:
>adb6		b6 af ba af 4e b4 4e b4		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>adbe		c2 af c8 af ce af 4e b4
>adc6		d4 af d8 af de af 4e b4		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>adce		e4 af e8 af ec af f0 af
>add6		f5 af f9 af 01 b0 4e b4		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>adde		08 b0 0e b0 15 b0 1c b0
>ade6		23 b0 27 b0 2d b0 4e b4		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc__, oc1F
>adee		33 b0 37 b0 4e b4 3d b0
>adf6		43 b0 47 b0 4e b4 4e b4		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>adfe		4f b0 55 b0 5b b0 61 b0
>ae06		68 b0 6c b0 72 b0 4e b4		        .word oc28, oc29, oc2A, oc__, OC2C, oc2D, oc2E, oc2F
>ae0e		78 b0 7c b0 81 b0 85 b0
>ae16		8a b0 8e b0 96 b0 4e b4		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>ae1e		9d b0 a5 b0 ac b0 b3 b0
>ae26		ba b0 be b0 c4 b0 4e b4		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc0F
>ae2e		ca b0 d0 b0 d6 b0 f0 af
>ae36		e1 b0 e5 b0 4e b4 4e b4		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>ae3e		4e b4 ed b0 f3 b0 f9 b0
>ae46		00 b1 04 b1 0a b1 4e b4		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>ae4e		10 b1 14 b1 18 b1 1c b1
>ae56		21 b1 25 b1 2d b1 4e b4		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>ae5e		4e b4 34 b1 3b b1 42 b1
>ae66		49 b1 4d b1 53 b1 4e b4		        .word oc58, oc59, oc5A, oc__, oc__, oc__, oc5E, oc5F
>ae6e		4e b4 4e b4 5d b1 63 b1
>ae76		68 b1 6c b1 4e b4 4e b4		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>ae7e		74 b1 7a b1 80 b1 86 b1
>ae86		8d b1 91 b1 97 b1 4e b4		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>ae8e		9d b1 a3 b1 a7 b1 ab b1
>ae96		b0 b1 b4 b1 bc b1 4e b4		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>ae9e		c3 b1 ca b1 d1 b1 d8 b1
>aea6		df b1 e3 b1 e9 b1 4e b4		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>aeae		ed b1 f4 b1 fa b1 00 b2
>aeb6		05 b2 09 b2 4e b4 4e b4		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>aebe		11 b2 17 b2 1d b2 4e b4
>aec6		23 b2 27 b2 2d b2 4e b4		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>aece		31 b2 35 b2 39 b2 3d b2
>aed6		42 b2 46 b2 4e b2 4e b4		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>aede		55 b2 5c b2 63 b2 6a b2
>aee6		71 b2 75 b2 7b b2 4e b4		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>aeee		7f b2 83 b2 89 b2 8f b2
>aef6		94 b2 9a b2 a2 b2 4e b4		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>aefe		a8 b2 ae b2 b4 b2 ba b2
>af06		c1 b2 c5 b2 cb b2 4e b4		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>af0e		cf b2 d3 b2 d7 b2 db b2
>af16		e0 b2 e4 b2 ec b2 4e b4		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>af1e		f3 b2 fa b2 01 b3 08 b3
>af26		0f b3 13 b3 19 b3 4e b4		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>af2e		1d b3 23 b3 29 b3 2f b3
>af36		34 b3 3a b3 4e b4 4e b4		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>af3e		42 b3 48 b3 4e b3 54 b3
>af46		5b b3 5f b3 65 b3 4e b4		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>af4e		69 b3 6d b3 71 b3 75 b3
>af56		7a b3 7e b3 86 b3 4e b4		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>af5e		4e b4 8d b3 94 b3 9b b3
>af66		a2 b3 a6 b3 ac b3 4e b4		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>af6e		4e b4 b0 b3 b6 b3 bc b3
>af76		c1 b3 c7 b3 4e b4 4e b4		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>af7e		cf b3 d5 b3 db b3 e1 b3
>af86		e8 b3 ec b3 f2 b3 4e b4		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>af8e		f6 b3 fa b3 fe b3 02 b4
>af96		07 b4 0b b4 13 b4 4e b4		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>af9e		4e b4 1a b4 21 b4 28 b4
>afa6		2f b4 33 b4 39 b4 4e b4		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>afae		4e b4 3d b4 43 b4 49 b4
.afb6						oc_table:
>afb6		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>afba		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>afc2		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>afc8		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>afce		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>afd4		43 70 68 70				oc08:	.text 1*64+3, "php"
>afd8		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>afde		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>afe4		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>afe8		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>afec		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>aff0		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>aff5		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>aff9		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b001		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b008		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b00e		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b015		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b01c		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b023		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b027		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b02d		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b033		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b037		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b03d		c5 61 73 6c 2e 78			oc1F:	.text 3*64+5, "asl.x"
>b043		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b047		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b04f		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b055		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b05b		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b061		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b068		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b06c		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b072		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b078		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b07c		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b081		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b085		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b08a		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b08e		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b096		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b09d		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b0a5		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b0ac		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b0b3		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b0ba		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b0be		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b0c4		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b0ca		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b0d0		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b0d6		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b0dc		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b0e1		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b0e5		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b0ed		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b0f3		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b0f9		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b100		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b104		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b10a		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b110		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b114		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b118		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b11c		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b121		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b125		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b12d		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b134		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b13b		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b142		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b149		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b14d		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b153		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b157		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b15d		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b163		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b168		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b16c		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b174		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b17a		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b180		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b186		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b18d		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b191		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b197		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b19d		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b1a3		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b1a7		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b1ab		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b1b0		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b1b4		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b1bc		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b1c3		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b1ca		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b1d1		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b1d8		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b1df		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b1e3		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b1e9		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b1ed		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b1f4		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b1fa		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b200		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b205		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b209		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b211		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b217		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b21d		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b223		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b227		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b22d		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b231		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b235		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b239		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b23d		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b242		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b246		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b24e		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b255		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b25c		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b263		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b26a		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b271		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b275		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b27b		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b27f		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b283		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b289		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b28f		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b294		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b29a		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b2a2		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b2a8		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b2ae		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b2b4		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b2ba		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b2c1		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b2c5		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b2cb		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b2cf		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b2d3		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b2d7		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b2db		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b2e0		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b2e4		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b2ec		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b2f3		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b2fa		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b301		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b308		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b30f		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b313		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b319		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b31d		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b323		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b329		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b32f		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b334		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b33a		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b342		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b348		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b34e		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b354		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b35b		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b35f		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b365		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b369		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b36d		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b371		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b375		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b37a		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b37e		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b386		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b38d		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>b394		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>b39b		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>b3a2		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>b3a6		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>b3ac		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>b3b0		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>b3b6		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>b3bc		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>b3c1		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>b3c7		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>b3cf		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>b3d5		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>b3db		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>b3e1		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>b3e8		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>b3ec		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>b3f2		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>b3f6		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>b3fa		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>b3fe		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>b402		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>b407		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>b40b		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>b413		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>b41a		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>b421		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>b428		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>b42f		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>b433		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>b439		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>b43d		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>b443		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>b449		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>b44e		01 3f					oc__:	.text 1, "?"
.b450						disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.b450						ed6502:
.b450		a5 18		lda $18		                lda base
.b452		85 3a		sta $3a		                sta ed_base
.b454		a9 0a		lda #$0a	                lda #10
.b456		85 18		sta $18		                sta base
.b458		64 35		stz $35		                stz ed_head
.b45a		64 36		stz $36		                stz ed_head+1
.b45c		64 37		stz $37		                stz ed_cur
.b45e		64 38		stz $38		                stz ed_cur+1
.b460		64 39		stz $39		                stz ed_flags
.b462		20 e4 a5	jsr $a5e4	                jsr xt_zero
.b465		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; ( addr-t u-t )
.b468		20 d5 88	jsr $88d5	                jsr xt_cr
.b46b						ed_input_loop:
.b46b		a9 81		lda #$81	                lda #%10000001
.b46d		14 39		trb $39		                trb ed_flags
.b46f		20 4a b9	jsr $b94a	                jsr ed_get_input
.b472		a5 0e		lda $0e		                lda ciblen
.b474		d0 1f		bne $b495	                bne _command_mode
.b476		ca		dex		                dex
.b477		ca		dex		                dex                     ; ( addr-t u-t ? )
.b478		a5 37		lda $37		                lda ed_cur
.b47a		95 00		sta $00,x	                sta 0,x
.b47c		a5 38		lda $38		                lda ed_cur+1
.b47e		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b480		a9 80		lda #$80	                lda #%10000000
.b482		04 39		tsb $39		                tsb ed_flags
.b484		20 40 97	jsr $9740	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b487		20 66 b9	jsr $b966	                jsr ed_is_valid_line
.b48a		b0 03		bcs $b48f	                bcs +
.b48c		4c 3a b9	jmp $b93a	                jmp ed_error_1drop
.b48f						+
.b48f		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b492		4c 60 b5	jmp $b560	                jmp _line_number_only_from_external
.b495						_command_mode:
.b495		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b498		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b49b						_prefix_dot:
.b49b		b2 0c		lda ($0c)	                lda (cib)
.b49d		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.b49f		d0 3a		bne $b4db	                bne _prefix_dollar
.b4a1		20 5b b9	jsr $b95b	                jsr ed_have_text
.b4a4		a5 37		lda $37		                lda ed_cur
.b4a6		95 02		sta $02,x	                sta 2,x
.b4a8		a5 38		lda $38		                lda ed_cur+1
.b4aa		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b4ac		a9 80		lda #$80	                lda #%10000000
.b4ae		04 39		tsb $39		                tsb ed_flags
.b4b0		a5 0e		lda $0e		                lda ciblen
.b4b2		3a		dec a		                dea                     ; sets Z if A was 1
.b4b3		d0 03		bne $b4b8	                bne +
.b4b5		4c 60 b5	jmp $b560	                jmp _line_number_only_from_external
.b4b8						+
.b4b8		ca		dex		                dex
.b4b9		ca		dex		                dex
.b4ba		ca		dex		                dex
.b4bb		ca		dex		                dex
.b4bc		a5 0c		lda $0c		                lda cib
.b4be		95 02		sta $02,x	                sta 2,x
.b4c0		a5 0d		lda $0d		                lda cib+1
.b4c2		95 03		sta $03,x	                sta 3,x
.b4c4		a5 0e		lda $0e		                lda ciblen
.b4c6		95 00		sta $00,x	                sta 0,x
.b4c8		a5 0f		lda $0f		                lda ciblen+1
.b4ca		95 01		sta $01,x	                sta 1,x
.b4cc		20 34 97	jsr $9734	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b4cf		20 05 a0	jsr $a005	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b4d2		20 40 97	jsr $9740	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b4d5		20 05 a0	jsr $a005	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b4d8		4c b8 b5	jmp $b5b8	                jmp _check_for_para2
.b4db						_prefix_dollar:
.b4db		b2 0c		lda ($0c)	                lda (cib)
.b4dd		c9 24		cmp #$24	                cmp #'$'
.b4df		d0 1c		bne $b4fd	                bne _prefix_percent
.b4e1		20 5b b9	jsr $b95b	                jsr ed_have_text
.b4e4		e8		inx		                inx
.b4e5		e8		inx		                inx                     ; ( addr-t u-t 0 )
.b4e6		20 88 b9	jsr $b988	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b4e9		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b4ec		a9 80		lda #$80	                lda #%10000000
.b4ee		04 39		tsb $39		                tsb ed_flags
.b4f0		a5 0e		lda $0e		                lda ciblen
.b4f2		3a		dec a		                dea                     ; sets Z if A was 1
.b4f3		d0 03		bne $b4f8	                bne +
.b4f5		4c 60 b5	jmp $b560	                jmp _line_number_only_from_external
.b4f8						+
.b4f8		a0 01		ldy #$01	                ldy #01
.b4fa		4c 34 b6	jmp $b634	                jmp _check_command
.b4fd						_prefix_percent:
.b4fd		b2 0c		lda ($0c)	                lda (cib)
.b4ff		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.b501		f0 04		beq $b507	                beq _whole_text
.b503		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.b505		d0 17		bne $b51e	                bne _prefix_semicolon
.b507						_whole_text:
.b507		20 5b b9	jsr $b95b	                jsr ed_have_text
.b50a		a9 01		lda #$01	                lda #01
.b50c		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b50e		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b510						_semicolon_entry:
.b510		e8		inx		                inx
.b511		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b512		20 88 b9	jsr $b988	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b515		a9 80		lda #$80	                lda #%10000000
.b517		04 39		tsb $39		                tsb ed_flags
.b519		a0 01		ldy #$01	                ldy #01
.b51b		4c 34 b6	jmp $b634	                jmp _check_command
.b51e						_prefix_semicolon:
.b51e		b2 0c		lda ($0c)	                lda (cib)
.b520		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.b522		d0 0d		bne $b531	                bne _prefix_number
.b524		20 5b b9	jsr $b95b	                jsr ed_have_text
.b527		a5 37		lda $37		                lda ed_cur
.b529		95 02		sta $02,x	                sta 2,x
.b52b		a5 38		lda $38		                lda ed_cur+1
.b52d		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b52f		80 df		bra $b510	                bra _semicolon_entry
.b531						_prefix_number:
.b531		20 e4 a5	jsr $a5e4	                jsr xt_zero
.b534		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b537		ca		dex		                dex
.b538		ca		dex		                dex
.b539		ca		dex		                dex
.b53a		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b53b		a5 0c		lda $0c		                lda cib
.b53d		95 02		sta $02,x	                sta 2,x
.b53f		a5 0d		lda $0d		                lda cib+1
.b541		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b543		a5 0e		lda $0e		                lda ciblen
.b545		95 00		sta $00,x	                sta 0,x
.b547		a5 0f		lda $0f		                lda ciblen+1
.b549		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b54b		20 e8 a0	jsr $a0e8	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b54e		b5 00		lda $00,x	                lda 0,x
.b550		15 01		ora $01,x	                ora 1,x
.b552		d0 24		bne $b578	                bne _have_unconverted_chars
.b554		e8		inx		                inx
.b555		e8		inx		                inx
.b556		e8		inx		                inx
.b557		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b558		20 f1 89	jsr $89f1	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b55b		20 94 95	jsr $9594	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b55e		e8		inx		                inx
.b55f		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b560						_line_number_only_from_external:
.b560		20 05 a0	jsr $a005	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b563		20 66 b9	jsr $b966	                jsr ed_is_valid_line
.b566		b0 03		bcs $b56b	                bcs +
.b568		4c 38 b9	jmp $b938	                jmp ed_error_2drop
.b56b						+
.b56b		20 05 a0	jsr $a005	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b56e		20 f5 b9	jsr $b9f5	                jsr ed_para1_to_cur
.b571		a9 80		lda #$80	                lda #%10000000
.b573		04 39		tsb $39		                tsb ed_flags
.b575		4c 13 b8	jmp $b813	                jmp ed_cmd_p_from_external
.b578						_have_unconverted_chars:
.b578		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b57b		ca		dex		                dex
.b57c		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b57d		a5 0e		lda $0e		                lda ciblen
.b57f		95 00		sta $00,x	                sta 0,x
.b581		a5 0f		lda $0f		                lda ciblen+1
.b583		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b585		20 53 8e	jsr $8e53	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b588		b5 00		lda $00,x	                lda 0,x
.b58a		15 01		ora $01,x	                ora 1,x
.b58c		f0 0e		beq $b59c	                beq _no_command_yet
.b58e		8a		txa		                txa
.b58f		18		clc		                clc
.b590		69 0a		adc #$0a	                adc #10
.b592		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b593		a9 80		lda #$80	                lda #%10000000
.b595		14 39		trb $39		                trb ed_flags
.b597		a0 00		ldy #$00	                ldy #00
.b599		4c 34 b6	jmp $b634	                jmp _check_command
.b59c						_no_command_yet:
.b59c		e8		inx		                inx
.b59d		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b59e		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b5a1		20 94 95	jsr $9594	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b5a4		20 f1 89	jsr $89f1	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b5a7		b5 00		lda $00,x	                lda 0,x                 ; LSB
.b5a9		95 06		sta $06,x	                sta 6,x
.b5ab		b5 01		lda $01,x	                lda 1,x                 ; MSB
.b5ad		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b5af		e8		inx		                inx
.b5b0		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b5b1		20 b3 99	jsr $99b3	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b5b4		a9 80		lda #$80	                lda #%10000000
.b5b6		04 39		tsb $39		                tsb ed_flags
.b5b8						_check_for_para2:
.b5b8		a1 02		lda ($02,x)	                lda (2,x)
.b5ba		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.b5bc		f0 0d		beq $b5cb	                beq _got_comma
.b5be		38		sec		                sec
.b5bf		a5 0e		lda $0e		                lda ciblen
.b5c1		f5 00		sbc $00,x	                sbc 0,x
.b5c3		a8		tay		                tay
.b5c4		e8		inx		                inx
.b5c5		e8		inx		                inx
.b5c6		e8		inx		                inx
.b5c7		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b5c8		4c 34 b6	jmp $b634	                jmp _check_command
.b5cb						_got_comma:
.b5cb		f6 02		inc $02,x	                inc 2,x
.b5cd		d0 02		bne $b5d1	                bne +
.b5cf		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b5d1						+
.b5d1		b5 01		lda $01,x	                lda 1,x
.b5d3		f0 02		beq $b5d7	                beq +
.b5d5		d6 01		dec $01,x	                dec 1,x
.b5d7						+
.b5d7		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b5d9		a1 02		lda ($02,x)	                lda (2,x)
.b5db		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b5dd		d0 14		bne $b5f3	                bne _para2_not_dollar
.b5df		38		sec		                sec
.b5e0		a5 0e		lda $0e		                lda ciblen
.b5e2		f5 02		sbc $02,x	                sbc 2,x
.b5e4		a8		tay		                tay
.b5e5		c8		iny		                iny
.b5e6		5a		phy		                phy
.b5e7		8a		txa		                txa
.b5e8		18		clc		                clc
.b5e9		69 06		adc #$06	                adc #06
.b5eb		aa		tax		                tax                     ; ( addr-t u-t para1 )
.b5ec		20 88 b9	jsr $b988	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b5ef		7a		ply		                ply
.b5f0		4c 34 b6	jmp $b634	                jmp _check_command
.b5f3						_para2_not_dollar:
.b5f3		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b5f6		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b5f9		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b5fc		20 71 9a	jsr $9a71	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b5ff		20 b3 99	jsr $99b3	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b602		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b605		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b608		20 e8 a0	jsr $a0e8	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b60b		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b60e		20 b3 99	jsr $99b3	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b611		20 53 8e	jsr $8e53	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b614		b5 00		lda $00,x	                lda 0,x
.b616		15 01		ora $01,x	                ora 1,x
.b618		f0 08		beq $b622	                beq _second_number
.b61a		8a		txa		                txa
.b61b		18		clc		                clc
.b61c		69 0c		adc #$0c	                adc #12
.b61e		aa		tax		                tax                     ; back to ( addr-t u-t )
.b61f		4c 3c b9	jmp $b93c	                jmp ed_error
.b622						_second_number:
.b622		e8		inx		                inx
.b623		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b624		38		sec		                sec
.b625		a5 0e		lda $0e		                lda ciblen
.b627		f5 00		sbc $00,x	                sbc 0,x
.b629		48		pha		                pha
.b62a		20 db a1	jsr $a1db	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b62d		20 f1 89	jsr $89f1	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b630		20 68 95	jsr $9568	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b633		7a		ply		                ply
.b634						_check_command:
.b634		24 39		bit $39		                bit ed_flags
.b636		30 08		bmi $b640	                bmi _check_command_have_arg
.b638		a5 37		lda $37		                lda ed_cur
.b63a		95 02		sta $02,x	                sta 2,x
.b63c		a5 38		lda $38		                lda ed_cur+1
.b63e		95 03		sta $03,x	                sta 3,x
.b640						_check_command_have_arg:
.b640		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.b642		85 25		sta $25		                sta tmp1
.b644		da		phx		                phx
.b645		a2 00		ldx #$00	                ldx #00
.b647						_cmd_loop:
.b647		bd 20 ba	lda $ba20,x	                lda ed_cmd_list,x
.b64a		f0 07		beq $b653	                beq _illegal_command    ; zero marks end of list
.b64c		c5 25		cmp $25		                cmp tmp1
.b64e		f0 07		beq $b657	                beq _found_cmd
.b650		e8		inx		                inx
.b651		80 f4		bra $b647	                bra _cmd_loop
.b653						_illegal_command:
.b653		fa		plx		                plx
.b654		4c 38 b9	jmp $b938	                jmp ed_error_2drop
.b657						_found_cmd:
.b657		8a		txa		                txa
.b658		0a		asl a		                asl
.b659		aa		tax		                tax                     ; X * 2 for table
.b65a		7c 2b ba	jmp ($ba2b,x)	                jmp (ed_cmd_table,x)
.b65d						ed_next_command:
.b65d		e8		inx		                inx
.b65e		e8		inx		                inx
.b65f		e8		inx		                inx
.b660		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b661						_next_command_empty:
.b661		4c 6b b4	jmp $b46b	                jmp ed_input_loop
.b664						ed_all_done:
.b664		64 0e		stz $0e		                stz ciblen
.b666		64 0f		stz $0f		                stz ciblen+1
.b668		20 db a1	jsr $a1db	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b66b		a5 3a		lda $3a		                lda ed_base
.b66d		85 18		sta $18		                sta base
.b66f		60		rts		                rts
.b670						ed_cmd_a:
.b670		fa		plx		                plx
.b671		e8		inx		                inx
.b672		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b673						ed_entry_cmd_i:
.b673						ed_cmd_a_have_para:
.b673		20 be b9	jsr $b9be	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b676		20 d5 88	jsr $88d5	                jsr xt_cr
.b679						_next_string_loop:
.b679		20 4a b9	jsr $b94a	                jsr ed_get_input
.b67c		b2 0c		lda ($0c)	                lda (cib)
.b67e		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.b680		d0 16		bne $b698	                bne _add_line
.b682		a4 0e		ldy $0e		                ldy ciblen
.b684		c0 01		cpy #$01	                cpy #01
.b686		d0 10		bne $b698	                bne _add_line
.b688		a4 0f		ldy $0f		                ldy ciblen+1
.b68a		d0 0c		bne $b698	                bne _add_line
.b68c		e8		inx		                inx
.b68d		e8		inx		                inx
.b68e		a9 40		lda #$40	                lda #%01000000
.b690		04 39		tsb $39		                tsb ed_flags
.b692		20 d5 88	jsr $88d5	                jsr xt_cr
.b695		4c 6b b4	jmp $b46b	                jmp ed_input_loop
.b698						_add_line:
.b698		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b69b		20 88 90	jsr $9088	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b69e		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b6a1		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b6a4		20 de 86	jsr $86de	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b6a7		20 b8 a1	jsr $a1b8	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b6aa		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b6ad		20 ea 9f	jsr $9fea	                jsr xt_store            ; ! ( addr-t u-t here )
.b6b0		20 88 90	jsr $9088	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b6b3		a5 00		lda $00		                lda cp
.b6b5		18		clc		                clc
.b6b6		69 04		adc #$04	                adc #04
.b6b8		85 00		sta $00		                sta cp
.b6ba		90 02		bcc $b6be	                bcc +
.b6bc		e6 01		inc $01		                inc cp+1
.b6be						+
.b6be		e6 37		inc $37		                inc ed_cur
.b6c0		d0 02		bne $b6c4	                bne +
.b6c2		e6 38		inc $38		                inc ed_cur+1
.b6c4						+
.b6c4		20 88 90	jsr $9088	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b6c7		20 07 8d	jsr $8d07	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b6ca		ca		dex		                dex
.b6cb		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b6cc		a5 0c		lda $0c		                lda cib
.b6ce		95 00		sta $00,x	                sta 0,x
.b6d0		a5 0d		lda $0d		                lda cib+1
.b6d2		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b6d4		20 05 a0	jsr $a005	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b6d7		ca		dex		                dex
.b6d8		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b6d9		a5 0e		lda $0e		                lda ciblen
.b6db		95 00		sta $00,x	                sta 0,x
.b6dd		a5 0f		lda $0f		                lda ciblen+1
.b6df		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b6e1		20 f1 94	jsr $94f1	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b6e4		18		clc		                clc
.b6e5		a5 00		lda $00		                lda cp
.b6e7		65 0e		adc $0e		                adc ciblen
.b6e9		85 00		sta $00		                sta cp
.b6eb		90 06		bcc $b6f3	                bcc +
.b6ed		a5 01		lda $01		                lda cp+1
.b6ef		65 0f		adc $0f		                adc ciblen+1
.b6f1		85 01		sta $01		                sta cp+1
.b6f3						+
.b6f3		20 b6 97	jsr $97b6	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b6f6		20 ea 9f	jsr $9fea	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b6f9		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+
.b6fc		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b6ff		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b702		a5 0e		lda $0e		                lda ciblen
.b704		95 02		sta $02,x	                sta 2,x
.b706		a5 0f		lda $0f		                lda ciblen+1
.b708		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b70a		20 ea 9f	jsr $9fea	                jsr xt_store            ; ! ( addr-t u-t here )
.b70d		20 d5 88	jsr $88d5	                jsr xt_cr
.b710		4c 79 b6	jmp $b679	                jmp _next_string_loop
.b713						ed_cmd_d:
.b713		fa		plx		                plx
.b714		20 5b b9	jsr $b95b	                jsr ed_have_text
.b717		20 b0 b9	jsr $b9b0	                jsr ed_no_line_zero
.b71a		b5 00		lda $00,x	                lda 0,x
.b71c		15 01		ora $01,x	                ora 1,x
.b71e		d0 08		bne $b728	                bne +
.b720		20 b6 97	jsr $97b6	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b723		20 65 b7	jsr $b765	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b726		80 33		bra $b75b	                bra _cmd_d_done
.b728						+
.b728		20 66 b9	jsr $b966	                jsr ed_is_valid_line      ; result is in C flag
.b72b		b0 03		bcs $b730	                bcs _cmd_d_loop
.b72d		4c 38 b9	jmp $b938	                jmp ed_error_2drop
.b730						_cmd_d_loop:
.b730		20 e3 a1	jsr $a1e3	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b733		20 73 90	jsr $9073	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b736		b5 00		lda $00,x	                lda 0,x
.b738		15 01		ora $01,x	                ora 1,x
.b73a		d0 0d		bne $b749	                bne _cmd_d_done_with_flag
.b73c		e8		inx		                inx
.b73d		e8		inx		                inx                     ; Get rid of the flag from >
.b73e		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b741		20 65 b7	jsr $b765	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b744		20 34 97	jsr $9734	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b747		80 e7		bra $b730	                bra _cmd_d_loop
.b749						_cmd_d_done_with_flag:
.b749		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b74a		e8		inx		                inx
.b74b		b5 02		lda $02,x	                lda 2,x
.b74d		d0 02		bne $b751	                bne +
.b74f		d6 03		dec $03,x	                dec 3,x
.b751						+
.b751		d6 02		dec $02,x	                dec 2,x
.b753		b5 02		lda $02,x	                lda 2,x
.b755		85 37		sta $37		                sta ed_cur
.b757		b5 03		lda $03,x	                lda 3,x
.b759		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.b75b						_cmd_d_done:
.b75b		a9 40		lda #$40	                lda #%01000000
.b75d		04 39		tsb $39		                tsb ed_flags
.b75f		20 d5 88	jsr $88d5	                jsr xt_cr
.b762		4c 5d b6	jmp $b65d	                jmp ed_next_command
.b765						_cmd_d_common:
.b765		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b768		20 be b9	jsr $b9be	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b76b		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b76e		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b771		20 34 97	jsr $9734	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b774		20 be b9	jsr $b9be	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b777		20 ea 9f	jsr $9fea	                jsr xt_store            ; ! ( addr-t u-t )
.b77a		60		rts		                rts
.b77b						ed_cmd_equ:
.b77b		fa		plx		                plx
.b77c		a5 35		lda $35		                lda ed_head
.b77e		05 36		ora $36		                ora ed_head+1
.b780		d0 08		bne $b78a	                bne _cmd_equ_have_text
.b782		ca		dex		                dex
.b783		ca		dex		                dex
.b784		74 00		stz $00,x	                stz 0,x
.b786		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b788		80 21		bra $b7ab	                bra _cmd_equ_done
.b78a						_cmd_equ_have_text:
.b78a		20 b0 b9	jsr $b9b0	                jsr ed_no_line_zero
.b78d		24 39		bit $39		                bit ed_flags
.b78f		30 0c		bmi $b79d	                bmi _cmd_equ_have_para
.b791		ca		dex		                dex
.b792		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b793		a5 37		lda $37		                lda ed_cur
.b795		95 00		sta $00,x	                sta 0,x
.b797		a5 38		lda $38		                lda ed_cur+1
.b799		95 01		sta $01,x	                sta 1,x
.b79b		80 0e		bra $b7ab	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b79d						_cmd_equ_have_para:
.b79d		b5 00		lda $00,x	                lda 0,x
.b79f		15 01		ora $01,x	                ora 1,x
.b7a1		d0 05		bne $b7a8	                bne _cmd_equ_two_paras
.b7a3		20 b6 97	jsr $97b6	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b7a6		80 03		bra $b7ab	                bra _cmd_equ_done
.b7a8						_cmd_equ_two_paras:
.b7a8		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b7ab						_cmd_equ_done:
.b7ab		20 d5 88	jsr $88d5	                jsr xt_cr               ; number goes on new line
.b7ae		20 59 a3	jsr $a359	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b7b1		20 d5 88	jsr $88d5	                jsr xt_cr
.b7b4		4c 5d b6	jmp $b65d	                jmp ed_next_command
.b7b7						ed_cmd_f:
.b7b7		fa		plx		                plx
.b7b8		24 39		bit $39		                bit ed_flags
.b7ba		30 17		bmi $b7d3	                bmi _cmd_f_have_para
.b7bc		20 d5 88	jsr $88d5	                jsr xt_cr
.b7bf		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b7c2		20 71 9a	jsr $9a71	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b7c5		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b7c8		20 59 a3	jsr $a359	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b7cb		20 94 95	jsr $9594	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b7ce		20 b3 99	jsr $99b3	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b7d1		80 11		bra $b7e4	                bra _cmd_f_done
.b7d3						_cmd_f_have_para:
.b7d3		20 b6 97	jsr $97b6	                jsr xt_over
.b7d6		20 d5 88	jsr $88d5	                jsr xt_cr
.b7d9		20 59 a3	jsr $a359	                jsr xt_u_dot
.b7dc		b5 02		lda $02,x	                lda 2,x
.b7de		95 06		sta $06,x	                sta 6,x
.b7e0		b5 03		lda $03,x	                lda 3,x
.b7e2		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b7e4						_cmd_f_done:
.b7e4		20 d5 88	jsr $88d5	                jsr xt_cr
.b7e7		4c 5d b6	jmp $b65d	                jmp ed_next_command
.b7ea						ed_cmd_i:
.b7ea		fa		plx		                plx
.b7eb		e8		inx		                inx
.b7ec		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7ed		24 39		bit $39		                bit ed_flags
.b7ef		30 08		bmi $b7f9	                bmi _cmd_i_have_para
.b7f1		a5 37		lda $37		                lda ed_cur
.b7f3		95 00		sta $00,x	                sta 0,x
.b7f5		a5 38		lda $38		                lda ed_cur+1
.b7f7		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b7f9						_cmd_i_have_para:
.b7f9		b5 00		lda $00,x	                lda 0,x
.b7fb		15 01		ora $01,x	                ora 1,x
.b7fd		f0 09		beq $b808	                beq _cmd_i_done
.b7ff		20 34 97	jsr $9734	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b802		20 e4 a5	jsr $a5e4	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b805		20 47 94	jsr $9447	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b808						_cmd_i_done:
.b808		4c 73 b6	jmp $b673	                jmp ed_entry_cmd_i
.b80b						ed_cmd_n:
.b80b		fa		plx		                plx
.b80c		a9 01		lda #$01	                lda #%00000001
.b80e		04 39		tsb $39		                tsb ed_flags
.b810		80 05		bra $b817	                bra ed_cmd_p_entry_for_cmd_n
.b812						ed_cmd_p:
.b812		fa		plx		                plx
.b813						ed_cmd_p_from_external:
.b813		a9 01		lda #$01	                lda #%00000001
.b815		14 39		trb $39		                trb ed_flags
.b817						ed_cmd_p_entry_for_cmd_n:
.b817		20 5b b9	jsr $b95b	                jsr ed_have_text
.b81a		20 b0 b9	jsr $b9b0	                jsr ed_no_line_zero
.b81d		20 d5 88	jsr $88d5	                jsr xt_cr
.b820		b5 00		lda $00,x	                lda 0,x
.b822		15 01		ora $01,x	                ora 1,x
.b824		d0 10		bne $b836	                bne _cmd_p_loop
.b826		b5 02		lda $02,x	                lda 2,x
.b828		85 37		sta $37		                sta ed_cur
.b82a		b5 03		lda $03,x	                lda 3,x
.b82c		85 38		sta $38		                sta ed_cur+1
.b82e		20 b6 97	jsr $97b6	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b831		20 5f b8	jsr $b85f	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b834		80 26		bra $b85c	                bra _cmd_p_all_done
.b836						_cmd_p_loop:
.b836		20 e3 a1	jsr $a1e3	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b839		20 73 90	jsr $9073	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b83c		b5 00		lda $00,x	                lda 0,x
.b83e		15 01		ora $01,x	                ora 1,x
.b840		d0 10		bne $b852	                bne _cmd_p_done
.b842		e8		inx		                inx
.b843		e8		inx		                inx                     ; Get rid of the flag from >
.b844		20 b6 97	jsr $97b6	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b847		20 5f b8	jsr $b85f	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b84a		f6 02		inc $02,x	                inc 2,x
.b84c		d0 02		bne $b850	                bne +
.b84e		f6 03		inc $03,x	                inc 3,x
.b850						+
.b850		80 e4		bra $b836	                bra _cmd_p_loop
.b852						_cmd_p_done:
.b852		e8		inx		                inx
.b853		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b854		b5 00		lda $00,x	                lda 0,x
.b856		85 37		sta $37		                sta ed_cur
.b858		b5 01		lda $01,x	                lda 1,x
.b85a		85 38		sta $38		                sta ed_cur+1
.b85c						_cmd_p_all_done:
.b85c		4c 5d b6	jmp $b65d	                jmp ed_next_command
.b85f						_cmd_p_common:
.b85f		a5 39		lda $39		                lda ed_flags
.b861		4a		lsr a		                lsr                     ; bit 0 now in carry
.b862		90 0b		bcc $b86f	                bcc _cmd_p_common_no_num
.b864		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b867		20 59 a3	jsr $a359	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b86a		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b86c		20 7b 8d	jsr $8d7b	                jsr emit_a
.b86f						_cmd_p_common_no_num:
.b86f		20 be b9	jsr $b9be	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b872		20 fe b9	jsr $b9fe	                jsr ed_print_addr
.b875		60		rts		                rts
.b876						ed_cmd_q:
.b876		fa		plx		                plx
.b877		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.b879		50 03		bvc $b87e	                bvc +
.b87b		4c 38 b9	jmp $b938	                jmp ed_error_2drop
.b87e						+
.b87e		4c 64 b6	jmp $b664	                jmp ed_all_done            ; can't fall thru because of PLX
.b881						ed_cmd_qq:
.b881		fa		plx		                plx
.b882		4c 64 b6	jmp $b664	                jmp ed_all_done
.b885						ed_cmd_w:
.b885		fa		plx		                plx
.b886		20 5b b9	jsr $b95b	                jsr ed_have_text
.b889		24 39		bit $39		                bit ed_flags
.b88b		30 13		bmi $b8a0	                bmi _cmd_w_have_para
.b88d		b5 06		lda $06,x	                lda 6,x
.b88f		15 07		ora $07,x	                ora 7,x
.b891		d0 03		bne $b896	                bne +
.b893		4c 38 b9	jmp $b938	                jmp ed_error_2drop
.b896						+
.b896		b5 06		lda $06,x	                lda 6,x
.b898		95 02		sta $02,x	                sta 2,x
.b89a		b5 07		lda $07,x	                lda 7,x
.b89c		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b89e		80 08		bra $b8a8	                bra _cmd_w_para_ready
.b8a0						_cmd_w_have_para:
.b8a0		b5 02		lda $02,x	                lda 2,x
.b8a2		95 06		sta $06,x	                sta 6,x
.b8a4		b5 03		lda $03,x	                lda 3,x
.b8a6		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b8a8						_cmd_w_para_ready:
.b8a8		a9 35		lda #$35	                lda #<ed_head
.b8aa		95 00		sta $00,x	                sta 0,x
.b8ac		a9 00		lda #$00	                lda #>ed_head
.b8ae		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b8b0		20 b6 97	jsr $97b6	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b8b3		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b8b6						_cmd_w_loop:
.b8b6		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b8b9		b5 00		lda $00,x	                lda 0,x
.b8bb		15 01		ora $01,x	                ora 1,x
.b8bd		f0 55		beq $b914	                beq _cmd_w_eol
.b8bf		20 e3 a1	jsr $a1e3	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.b8c2		20 cd a2	jsr $a2cd	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.b8c5		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.b8c8		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.b8cb		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.b8ce		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.b8d1		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.b8d4		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.b8d7		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.b8da		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.b8dd		20 94 95	jsr $9594	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.b8e0		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.b8e3		20 71 9a	jsr $9a71	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.b8e6		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.b8e9		20 9b a1	jsr $a19b	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.b8ec		20 f1 94	jsr $94f1	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.b8ef		20 b3 99	jsr $99b3	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.b8f2		20 53 a2	jsr $a253	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.b8f5		20 94 95	jsr $9594	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.b8f8		20 04 99	jsr $9904	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.b8fb		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.b8fe		ca		dex		                dex
.b8ff		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.b900		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.b902		95 00		sta $00,x	                sta 0,x
.b904		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.b906		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.b909		20 ea 9f	jsr $9fea	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.b90c		20 40 97	jsr $9740	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.b90f		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.b912		80 a2		bra $b8b6	                bra _cmd_w_loop
.b914						_cmd_w_eol:
.b914		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.b917		20 b3 99	jsr $99b3	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.b91a		20 7f 94	jsr $947f	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.b91d		b5 00		lda $00,x	                lda 0,x
.b91f		95 04		sta $04,x	                sta 4,x
.b921		b5 01		lda $01,x	                lda 1,x
.b923		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.b925		20 d5 88	jsr $88d5	                jsr xt_cr
.b928		20 07 8d	jsr $8d07	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.b92b		20 59 a3	jsr $a359	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.b92e		20 d5 88	jsr $88d5	                jsr xt_cr
.b931		a9 40		lda #$40	                lda #%01000000
.b933		14 39		trb $39		                trb ed_flags
.b935		4c 5d b6	jmp $b65d	                jmp ed_next_command
.b938						ed_error_2drop:
.b938		e8		inx		                inx
.b939		e8		inx		                inx                     ; drop through to _error_1drop
.b93a						ed_error_1drop:
.b93a		e8		inx		                inx
.b93b		e8		inx		                inx                     ; drop through to _error
.b93c						ed_error:
.b93c		20 d5 88	jsr $88d5	                jsr xt_cr
.b93f		a9 3f		lda #$3f	                lda #'?'
.b941		20 7b 8d	jsr $8d7b	                jsr emit_a
.b944		20 d5 88	jsr $88d5	                jsr xt_cr
.b947		4c 6b b4	jmp $b46b	                jmp ed_input_loop
.b94a						ed_get_input:
.b94a		20 19 9a	jsr $9a19	                jsr xt_refill           ;  ( addr-t u-t f )
.b94d		b5 00		lda $00,x	                lda 0,x
.b94f		15 01		ora $01,x	                ora 1,x
.b951		d0 05		bne $b958	                bne +
.b953		7a		ply		                ply
.b954		7a		ply		                ply
.b955		4c 3a b9	jmp $b93a	                jmp ed_error_1drop
.b958						+
.b958		e8		inx		                inx
.b959		e8		inx		                inx
.b95a		60		rts		                rts
.b95b						ed_have_text:
.b95b		a5 35		lda $35		                lda ed_head
.b95d		05 36		ora $36		                ora ed_head+1
.b95f		d0 04		bne $b965	                bne +
.b961		7a		ply		                ply
.b962		7a		ply		                ply
.b963		80 d7		bra $b93c	                bra ed_error
.b965						+
.b965		60		rts		                rts
.b966						ed_is_valid_line:
.b966		38		sec		                sec                             ; default is legal line number
.b967		b5 00		lda $00,x	                lda 0,x
.b969		15 01		ora $01,x	                ora 1,x
.b96b		f0 19		beq $b986	                beq _is_valid_line_nope_zero    ; ( n )
.b96d		20 07 8d	jsr $8d07	                jsr xt_dup                      ; DUP ( n n )
.b970		20 88 b9	jsr $b988	                jsr ed_last_line                  ; ( n n last )
.b973		20 05 a0	jsr $a005	                jsr xt_swap                     ; SWAP ( n last n )
.b976		20 86 92	jsr $9286	                jsr xt_less_than                ; < ( n f )
.b979		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.b97b		15 01		ora $01,x	                ora 1,x
.b97d		d0 05		bne $b984	                bne _is_valid_line_too_small
.b97f		e8		inx		                inx
.b980		e8		inx		                inx                     ; DROP flag ( n )
.b981		38		sec		                sec                     ; Who knows what's happened to C by now
.b982		80 03		bra $b987	                bra _is_valid_line_done ; only one exit from this routine
.b984						_is_valid_line_too_small:
.b984		e8		inx		                inx
.b985		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.b986						_is_valid_line_nope_zero:
.b986		18		clc		                clc                     ; drop through to _is_valid_line_done
.b987						_is_valid_line_done:
.b987		60		rts		                rts
.b988						ed_last_line:
.b988		64 25		stz $25		                stz tmp1
.b98a		64 26		stz $26		                stz tmp1+1
.b98c		ca		dex		                dex
.b98d		ca		dex		                dex                     ; ( ? )
.b98e		a9 35		lda #$35	                lda #<ed_head
.b990		95 00		sta $00,x	                sta 0,x
.b992		a9 00		lda #$00	                lda #>ed_head
.b994		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.b996						_last_line_loop:
.b996		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; ( addr | 0 )
.b999		b5 00		lda $00,x	                lda 0,x
.b99b		15 01		ora $01,x	                ora 1,x
.b99d		f0 08		beq $b9a7	                beq _last_line_done
.b99f		e6 25		inc $25		                inc tmp1
.b9a1		d0 02		bne $b9a5	                bne +
.b9a3		e6 26		inc $26		                inc tmp1+1
.b9a5						+
.b9a5		80 ef		bra $b996	                bra _last_line_loop
.b9a7						_last_line_done:
.b9a7		a5 25		lda $25		                lda tmp1
.b9a9		95 00		sta $00,x	                sta 0,x
.b9ab		a5 26		lda $26		                lda tmp1+1
.b9ad		95 01		sta $01,x	                sta 1,x                 ; ( u )
.b9af		60		rts		                rts
.b9b0						ed_no_line_zero:
.b9b0		b5 02		lda $02,x	                lda 2,x
.b9b2		15 03		ora $03,x	                ora 3,x
.b9b4		d0 07		bne $b9bd	                bne _no_line_zero_done
.b9b6		24 39		bit $39		                bit ed_flags
.b9b8		10 03		bpl $b9bd	                bpl _no_line_zero_done
.b9ba		4c 38 b9	jmp $b938	                jmp ed_error_2drop
.b9bd						_no_line_zero_done:
.b9bd		60		rts		                rts
.b9be						ed_num_to_addr:
.b9be		ca		dex		                dex
.b9bf		ca		dex		                dex                     ; ( u ? )
.b9c0		a9 35		lda #$35	                lda #<ed_head
.b9c2		95 00		sta $00,x	                sta 0,x
.b9c4		a9 00		lda #$00	                lda #>ed_head
.b9c6		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.b9c8		b5 02		lda $02,x	                lda 2,x
.b9ca		15 03		ora $03,x	                ora 3,x
.b9cc		d0 05		bne $b9d3	                bne _num_to_addr_loop
.b9ce		20 68 95	jsr $9568	                jsr xt_nip              ; ( addr-h )
.b9d1		80 21		bra $b9f4	                bra _num_to_addr_done
.b9d3						_num_to_addr_loop:
.b9d3		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; @ ( u addr1 )
.b9d6		b5 00		lda $00,x	                lda 0,x
.b9d8		15 01		ora $01,x	                ora 1,x
.b9da		d0 05		bne $b9e1	                bne +
.b9dc		20 68 95	jsr $9568	                jsr xt_nip              ; NIP ( addr1 )
.b9df		80 13		bra $b9f4	                bra _num_to_addr_done
.b9e1						+
.b9e1		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( addr1 u )
.b9e4		20 34 97	jsr $9734	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.b9e7		b5 00		lda $00,x	                lda 0,x
.b9e9		15 01		ora $01,x	                ora 1,x
.b9eb		f0 05		beq $b9f2	                beq _num_to_addr_finished
.b9ed		20 05 a0	jsr $a005	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.b9f0		80 e1		bra $b9d3	                bra _num_to_addr_loop
.b9f2						_num_to_addr_finished:
.b9f2		e8		inx		                inx
.b9f3		e8		inx		                inx                     ; ( addr )
.b9f4						_num_to_addr_done:
.b9f4		60		rts		                rts
.b9f5						ed_para1_to_cur:
.b9f5		b5 02		lda $02,x	                lda 2,x
.b9f7		85 37		sta $37		                sta ed_cur
.b9f9		b5 03		lda $03,x	                lda 3,x
.b9fb		85 38		sta $38		                sta ed_cur+1
.b9fd		60		rts		                rts
.b9fe						ed_print_addr:
.b9fe		20 40 97	jsr $9740	                jsr xt_one_plus
.ba01		20 40 97	jsr $9740	                jsr xt_one_plus         ; ( addr+2 )
.ba04		20 07 8d	jsr $8d07	                jsr xt_dup              ; ( addr+2 addr+2 )
.ba07		20 40 97	jsr $9740	                jsr xt_one_plus
.ba0a		20 40 97	jsr $9740	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.ba0d		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; ( addr+2 u-s )
.ba10		20 05 a0	jsr $a005	                jsr xt_swap             ; ( u-s addr+2 )
.ba13		20 fe 8e	jsr $8efe	                jsr xt_fetch            ; ( u-s addr-s )
.ba16		20 05 a0	jsr $a005	                jsr xt_swap             ; ( addr-s u-s )
.ba19		20 2e a3	jsr $a32e	                jsr xt_type
.ba1c		20 d5 88	jsr $88d5	                jsr xt_cr
.ba1f		60		rts		                rts
>ba20		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ba28		71 51 00
.ba2b						ed_cmd_table:
>ba2b		70 b6 b7 b7 ea b7 13 b7		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ba33		12 b8 0b b8
>ba37		7b b7 85 b8 76 b8 81 b8		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ba3f						ed6502_end:

;******  Return to file: platform/../taliforth.asm

.ba3f						forth_words_start:
>ba3f		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>ba47		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>ba57		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>ba67		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>ba77		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>ba87		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>ba97		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>baa7		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bab7		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bac7		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bad7		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bae7		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>baf7		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bb07		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bb17		78 69 74 29 20 63 72 20
.bb1f						forth_words_end:
.bb1f						user_words_start:
>bb1f		20 20				.binary "user_words.asc"
.bb21						user_words_end:

;******  Processing file: platform/../headers.asm

.bb21						dictionary_start:
.bb21						nt_drop:
>bb21		04 10				        .byte 4, UF
>bb23		2d bb 86 8c 8b 8c		        .word nt_dup, xt_drop, z_drop
>bb29		64 72 6f 70			        .text "drop"
.bb2d						nt_dup:
>bb2d		03 10				        .byte 3, UF
>bb2f		38 bb 07 8d 14 8d		        .word nt_swap, xt_dup, z_dup
>bb35		64 75 70			        .text "dup"
.bb38						nt_swap:
>bb38		04 10				        .byte 4, UF
>bb3a		44 bb 05 a0 18 a0		        .word nt_store, xt_swap, z_swap
>bb40		73 77 61 70			        .text "swap"
.bb44						nt_store:
>bb44		01 10				        .byte 1, UF
>bb46		4d bb ea 9f ff 9f		        .word nt_fetch, xt_store, z_store
>bb4c		21				        .text "!"
.bb4d						nt_fetch:
>bb4d		01 10				        .byte 1, UF
>bb4f		56 bb fe 8e 10 8f		        .word nt_over, xt_fetch, z_fetch
>bb55		40				        .text "@"
.bb56						nt_over:
>bb56		04 10				        .byte 4, UF
>bb58		62 bb b6 97 c3 97		        .word nt_to_r, xt_over, z_over
>bb5e		6f 76 65 72			        .text "over"
.bb62						nt_to_r:
>bb62		02 11				        .byte 2, CO+UF ; native is special case
>bb64		6c bb 9b a1 ae a1		        .word nt_r_from, xt_to_r, z_to_r
>bb6a		3e 72				        .text ">r"
.bb6c						nt_r_from:
>bb6c		02 01				        .byte 2, CO    ; native is special case
>bb6e		76 bb b3 99 c3 99		        .word nt_r_fetch, xt_r_from, z_r_from
>bb74		72 3e				        .text "r>"
.bb76						nt_r_fetch:
>bb76		02 01				        .byte 2, CO    ; native is special case
>bb78		80 bb 9e 99 b2 99		        .word nt_nip, xt_r_fetch, z_r_fetch
>bb7e		72 40				        .text "r@"
.bb80						nt_nip:
>bb80		03 10				        .byte 3, UF
>bb82		8b bb 68 95 75 95		        .word nt_rot, xt_nip, z_nip
>bb88		6e 69 70			        .text "nip"
.bb8b						nt_rot:
>bb8b		03 10				        .byte 3, UF
>bb8d		96 bb 71 9a 8c 9a		        .word nt_not_rote, xt_rot, z_rot
>bb93		72 6f 74			        .text "rot"
.bb96						nt_not_rote:
>bb96		04 10				        .byte 4, UF
>bb98		a2 bb 94 95 af 95		        .word nt_tuck, xt_not_rote, z_not_rote
>bb9e		2d 72 6f 74			        .text "-rot"
.bba2						nt_tuck:
>bba2		04 10				        .byte 4, UF
>bba4		ae bb b8 a1 d1 a1		        .word nt_comma, xt_tuck, z_tuck
>bbaa		74 75 63 6b			        .text "tuck"
.bbae						nt_comma:
>bbae		01 10				        .byte 1, UF
>bbb0		b7 bb de 86 f7 86		        .word nt_c_fetch, xt_comma, z_comma
>bbb6		2c				        .text ","
.bbb7						nt_c_fetch:
>bbb7		02 10				        .byte 2, UF
>bbb9		c1 bb 7b 85 84 85		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bbbf		63 40				        .text "c@"
.bbc1						nt_c_store:
>bbc1		02 10				        .byte 2, UF
>bbc3		cb bb 85 85 90 85		        .word nt_plus_store, xt_c_store, z_c_store
>bbc9		63 21				        .text "c!"
.bbcb						nt_plus_store:
>bbcb		02 10				        .byte 2, UF
>bbcd		d5 bb 17 99 36 99		        .word nt_execute, xt_plus_store, z_plus_store
>bbd3		2b 21				        .text "+!"
.bbd5						nt_execute:
>bbd5		07 10				        .byte 7, UF
>bbd7		e4 bb c2 8e c8 8e		        .word nt_emit, xt_execute, z_execute
>bbdd		65 78 65 63 75 74 65		        .text "execute"
.bbe4						nt_emit:
>bbe4		04 18				        .byte 4, NN+UF
>bbe6		f0 bb 74 8d 7e 8d		        .word nt_type, xt_emit, z_emit
>bbec		65 6d 69 74			        .text "emit"
.bbf0						nt_type:
>bbf0		04 10				        .byte 4, UF
>bbf2		fc bb 2e a3 58 a3		        .word nt_dot, xt_type, z_type
>bbf8		74 79 70 65			        .text "type"
.bbfc						nt_dot:
>bbfc		01 10				        .byte 1, UF
>bbfe		05 bc 8e 8b af 8b		        .word nt_u_dot, xt_dot, z_dot
>bc04		2e				        .text "."
.bc05						nt_u_dot:
>bc05		02 10				        .byte 2, UF
>bc07		0f bc 59 a3 64 a3		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bc0d		75 2e				        .text "u."
.bc0f						nt_u_dot_r:
>bc0f		03 10				        .byte 3, UF
>bc11		1a bc 65 a3 86 a3		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bc17		75 2e 72			        .text "u.r"
.bc1a						nt_dot_r:
>bc1a		02 10				        .byte 2, UF
>bc1c		24 bc ca 8b f7 8b		        .word nt_d_dot, xt_dot_r, z_dot_r
>bc22		2e 72				        .text ".r"
.bc24						nt_d_dot:
>bc24		02 10				        .byte 2, UF
>bc26		2e bc 3c 8c 5a 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bc2c		64 2e				        .text "d."
.bc2e						nt_d_dot_r:
>bc2e		03 10				        .byte 3, UF
>bc30		39 bc 5b 8c 85 8c		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bc36		64 2e 72			        .text "d.r"
.bc39						nt_ud_dot:
>bc39		03 10				        .byte 3, UF
>bc3b		44 bc b3 a3 c5 a3		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bc41		75 64 2e			        .text "ud."
.bc44						nt_ud_dot_r:
>bc44		04 10				        .byte 4, UF
>bc46		50 bc c6 a3 e4 a3		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bc4c		75 64 2e 72			        .text "ud.r"
.bc50						nt_question:
>bc50		01 00				        .byte 1, 0
>bc52		59 bc 83 99 89 99		        .word nt_false, xt_question, z_question
>bc58		3f				        .text "?"
.bc59						nt_false:
>bc59		05 00				        .byte 5, 0
>bc5b		66 bc e4 a5 ea a5		        .word nt_true, xt_false, z_false
>bc61		66 61 6c 73 65			        .text "false"
.bc66						nt_true:
>bc66		04 00				        .byte 4, 0
>bc68		72 bc af a1 b7 a1		        .word nt_space, xt_true, z_true
>bc6e		74 72 75 65			        .text "true"
.bc72						nt_space:
>bc72		05 00				        .byte 5, 0
>bc74		7f bc 7b 9f 80 9f		        .word nt_zero, xt_space, z_space
>bc7a		73 70 61 63 65			        .text "space"
.bc7f						nt_zero:
>bc7f		01 00				        .byte 1, 0
>bc81		88 bc e4 a5 ea a5		        .word nt_one, xt_zero, z_zero
>bc87		30				        .text "0"
.bc88						nt_one:
>bc88		01 00				        .byte 1, 0
>bc8a		91 bc 2b 97 33 97		        .word nt_two, xt_one, z_one
>bc90		31				        .text "1"
.bc91						nt_two:
>bc91		01 00				        .byte 1, 0
>bc93		9a bc d2 a1 da a1		        .word nt_two_dup, xt_two, z_two
>bc99		32				        .text "2"
.bc9a						nt_two_dup:
>bc9a		04 10				        .byte 4, UF
>bc9c		a6 bc e3 a1 fa a1		        .word nt_question_dup, xt_two_dup, z_two_dup
>bca2		32 64 75 70			        .text "2dup"
.bca6						nt_question_dup:
>bca6		04 10				        .byte 4, UF
>bca8		b2 bc 8a 99 9d 99		        .word nt_plus, xt_question_dup, z_question_dup
>bcae		3f 64 75 70			        .text "?dup"
.bcb2						nt_plus:
>bcb2		01 10				        .byte 1, UF
>bcb4		bb bc 04 99 16 99		        .word nt_minus, xt_plus, z_plus
>bcba		2b				        .text "+"
.bcbb						nt_minus:
>bcbb		01 10				        .byte 1, UF
>bcbd		c4 bc 7f 94 91 94		        .word nt_one_minus, xt_minus, z_minus
>bcc3		2d				        .text "-"
.bcc4						nt_one_minus:
>bcc4		02 10				        .byte 2, UF
>bcc6		ce bc 34 97 3f 97		        .word nt_one_plus, xt_one_minus, z_one_minus
>bccc		31 2d				        .text "1-"
.bcce						nt_one_plus:
>bcce		02 10				        .byte 2, UF
>bcd0		d8 bc 40 97 49 97		        .word nt_two_star, xt_one_plus, z_one_plus
>bcd6		31 2b				        .text "1+"
.bcd8						nt_two_star:
>bcd8		02 10				        .byte 2, UF
>bcda		e2 bc 7b a2 82 a2		        .word nt_two_slash, xt_two_star, z_two_star
>bce0		32 2a				        .text "2*"
.bce2						nt_two_slash:
>bce2		02 10				        .byte 2, UF
>bce4		ec bc 70 a2 7a a2		        .word nt_abs, xt_two_slash, z_two_slash
>bcea		32 2f				        .text "2/"
.bcec						nt_abs:
>bcec		03 10				        .byte 3, UF
>bcee		f7 bc d1 80 e5 80		        .word nt_dabs, xt_abs, z_abs
>bcf4		61 62 73			        .text "abs"
.bcf7						nt_dabs:
>bcf7		04 10				        .byte 4, UF
>bcf9		03 bd f7 89 15 8a		        .word nt_and, xt_dabs, z_dabs
>bcff		64 61 62 73			        .text "dabs"
.bd03						nt_and:
>bd03		03 10				        .byte 3, UF
>bd05		0e bd c3 82 d4 82		        .word nt_or, xt_and, z_and
>bd0b		61 6e 64			        .text "and"
.bd0e						nt_or:
>bd0e		02 10				        .byte 2, UF
>bd10		18 bd 56 97 67 97		        .word nt_xor, xt_or, z_or
>bd16		6f 72				        .text "or"
.bd18						nt_xor:
>bd18		03 10				        .byte 3, UF
>bd1a		23 bd d2 a5 e3 a5		        .word nt_rshift, xt_xor, z_xor
>bd20		78 6f 72			        .text "xor"
.bd23						nt_rshift:
>bd23		06 10				        .byte 6, UF
>bd25		31 bd 8d 9a a0 9a		        .word nt_lshift, xt_rshift, z_rshift
>bd2b		72 73 68 69 66 74		        .text "rshift"
.bd31						nt_lshift:
>bd31		06 10				        .byte 6, UF
>bd33		3f bd a9 93 bc 93		        .word nt_pick, xt_lshift, z_lshift
>bd39		6c 73 68 69 66 74		        .text "lshift"
.bd3f						nt_pick:
>bd3f		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bd41		4b bd f3 98 03 99		        .word nt_char, xt_pick, z_pick
>bd47		70 69 63 6b			        .text "pick"
.bd4b						nt_char:
>bd4b		04 00				        .byte 4, 0
>bd4d		57 bd a1 85 b7 85		        .word nt_bracket_char, xt_char, z_char
>bd53		63 68 61 72			        .text "char"
.bd57						nt_bracket_char:
>bd57		06 05				        .byte 6, CO+IM
>bd59		65 bd 1d 85 23 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bd5f		5b 63 68 61 72 5d		        .text "[char]"
.bd65						nt_char_plus:
>bd65		05 00				        .byte 5, 0
>bd67		72 bd 40 97 49 97		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bd6d		63 68 61 72 2b			        .text "char+"
.bd72						nt_chars:
>bd72		05 12				        .byte 5, AN+UF   ; deleted during compile
>bd74		7f bd b8 85 bb 85		        .word nt_cells, xt_chars, z_chars
>bd7a		63 68 61 72 73			        .text "chars"
.bd7f						nt_cells:
>bd7f		05 00				        .byte 5, 0
>bd81		8c bd 7b a2 82 a2		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bd87		63 65 6c 6c 73			        .text "cells"
.bd8c						nt_cell_plus:
>bd8c		05 10				        .byte 5, UF
>bd8e		99 bd 91 85 a0 85		        .word nt_here, xt_cell_plus, z_cell_plus
>bd94		63 65 6c 6c 2b			        .text "cell+"
.bd99						nt_here:
>bd99		04 00				        .byte 4, 0
>bd9b		a5 bd 88 90 92 90		        .word nt_equal, xt_here, z_here
>bda1		68 65 72 65			        .text "here"
.bda5						nt_equal:
>bda5		01 10				        .byte 1, UF
>bda7		ae bd 53 8e 6e 8e		        .word nt_not_equals, xt_equal, z_equal
>bdad		3d				        .text "="
.bdae						nt_not_equals:
>bdae		02 10				        .byte 2, UF
>bdb0		b8 bd 76 95 93 95		        .word nt_less_than, xt_not_equals, z_not_equals
>bdb6		3c 3e				        .text "<>"
.bdb8						nt_less_than:
>bdb8		01 10				        .byte 1, UF
>bdba		c1 bd 86 92 9a 92		        .word nt_u_less_than, xt_less_than, z_less_than
>bdc0		3c				        .text "<"
.bdc1						nt_u_less_than:
>bdc1		02 10				        .byte 2, UF
>bdc3		cb bd 9d a3 b2 a3		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bdc9		75 3c				        .text "u<"
.bdcb						nt_u_greater_than:
>bdcb		02 10				        .byte 2, UF
>bdcd		d5 bd 87 a3 9c a3		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bdd3		75 3e				        .text "u>"
.bdd5						nt_greater_than:
>bdd5		01 10				        .byte 1, UF
>bdd7		de bd 73 90 87 90		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bddd		3e				        .text ">"
.bdde						nt_zero_equal:
>bdde		02 10				        .byte 2, UF
>bde0		e8 bd eb a5 fc a5		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bde6		30 3d				        .text "0="
.bde8						nt_zero_unequal:
>bde8		03 10				        .byte 3, UF
>bdea		f3 bd 21 a6 30 a6		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bdf0		30 3c 3e			        .text "0<>"
.bdf3						nt_zero_greater:
>bdf3		02 10				        .byte 2, UF
>bdf5		fd bd fd a5 10 a6		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bdfb		30 3e				        .text "0>"
.bdfd						nt_zero_less:
>bdfd		02 10				        .byte 2, UF
>bdff		07 be 11 a6 20 a6		        .word nt_min, xt_zero_less, z_zero_less
>be05		30 3c				        .text "0<"
.be07						nt_min:
>be07		03 10				        .byte 3, UF
>be09		12 be 63 94 7e 94		        .word nt_max, xt_min, z_min
>be0f		6d 69 6e			        .text "min"
.be12						nt_max:
>be12		03 10				        .byte 3, UF
>be14		1d be 47 94 62 94		        .word nt_two_drop, xt_max, z_max
>be1a		6d 61 78			        .text "max"
.be1d						nt_two_drop:
>be1d		05 10				        .byte 5, UF
>be1f		2a be db a1 e2 a1		        .word nt_two_swap, xt_two_drop, z_two_drop
>be25		32 64 72 6f 70			        .text "2drop"
.be2a						nt_two_swap:
>be2a		05 10				        .byte 5, UF
>be2c		37 be a9 a2 cc a2		        .word nt_two_over, xt_two_swap, z_two_swap
>be32		32 73 77 61 70			        .text "2swap"
.be37						nt_two_over:
>be37		05 10				        .byte 5, UF
>be39		44 be 1d a2 34 a2		        .word nt_two_store, xt_two_over, z_two_over
>be3f		32 6f 76 65 72			        .text "2over"
.be44						nt_two_store:
>be44		02 10				        .byte 2, UF
>be46		4e be 83 a2 a8 a2		        .word nt_two_fetch, xt_two_store, z_two_store
>be4c		32 21				        .text "2!"
.be4e						nt_two_fetch:
>be4e		02 10				        .byte 2, UF
>be50		58 be fb a1 1c a2		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>be56		32 40				        .text "2@"
.be58						nt_two_variable:
>be58		09 00				        .byte 9, 0
>be5a		69 be 1f a3 2d a3		        .word nt_two_constant, xt_two_variable, z_two_variable
>be60		32 76 61 72 69 61 62 6c		        .text "2variable"
>be68		65
.be69						nt_two_constant:
>be69		09 10				        .byte 9, UF
>be6b		7a be ed a2 11 a3		        .word nt_two_literal, xt_two_constant, z_two_constant
>be71		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>be79		74
.be7a						nt_two_literal:
>be7a		08 14				        .byte 8, UF+IM
>be7c		8a be 12 a3 1e a3		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>be82		32 6c 69 74 65 72 61 6c		        .text "2literal"
.be8a						nt_two_r_fetch:
>be8a		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>be8c		95 be 35 a2 52 a2		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>be92		32 72 40			        .text "2r@"
.be95						nt_two_r_from:
>be95		03 01				        .byte 3, CO             ; native is special case
>be97		a0 be 53 a2 6f a2		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>be9d		32 72 3e			        .text "2r>"
.bea0						nt_two_to_r:
>bea0		03 11				        .byte 3, CO+UF          ; native is special case
>bea2		ab be cd a2 ec a2		        .word nt_invert, xt_two_to_r, z_two_to_r
>bea8		32 3e 72			        .text "2>r"
.beab						nt_invert:
>beab		06 10				        .byte 6, UF
>bead		b9 be f8 91 07 92		        .word nt_negate, xt_invert, z_invert
>beb3		69 6e 76 65 72 74		        .text "invert"
.beb9						nt_negate:
>beb9		06 10				        .byte 6, UF
>bebb		c7 be 49 95 59 95		        .word nt_dnegate, xt_negate, z_negate
>bec1		6e 65 67 61 74 65		        .text "negate"
.bec7						nt_dnegate:
>bec7		07 10				        .byte 7, UF
>bec9		d6 be b2 8a cc 8a		        .word nt_c_comma, xt_dnegate, z_dnegate
>becf		64 6e 65 67 61 74 65		        .text "dnegate"
.bed6						nt_c_comma:
>bed6		02 10				        .byte 2, UF
>bed8		e0 be 70 85 7a 85		        .word nt_bounds, xt_c_comma, z_c_comma
>bede		63 2c				        .text "c,"
.bee0						nt_bounds:
>bee0		06 10				        .byte 6, UF
>bee2		ee be 04 85 1c 85		        .word nt_spaces, xt_bounds, z_bounds
>bee8		62 6f 75 6e 64 73		        .text "bounds"
.beee						nt_spaces:
>beee		06 10				        .byte 6, UF
>bef0		fc be 81 9f bc 9f		        .word nt_bl, xt_spaces, z_spaces
>bef6		73 70 61 63 65 73		        .text "spaces"
.befc						nt_bl:
>befc		02 00				        .byte 2, 0
>befe		06 bf 41 83 49 83		        .word nt_minus_trailing, xt_bl, z_bl
>bf04		62 6c				        .text "bl"
.bf06						nt_minus_trailing:
>bf06		09 10				        .byte 9, UF
>bf08		17 bf ab 94 e7 94		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>bf0e		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>bf16		67
.bf17						nt_minus_leading:
>bf17		08 10				        .byte 8, UF
>bf19		27 bf 92 94 aa 94		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>bf1f		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.bf27						nt_slash_string:
>bf27		07 10				        .byte 7, UF
>bf29		36 bf 7e 9e 9d 9e		        .word nt_refill, xt_slash_string, z_slash_string
>bf2f		2f 73 74 72 69 6e 67		        .text "/string"
.bf36						nt_refill:
>bf36		06 00				        .byte 6, 0
>bf38		44 bf 19 9a 5a 9a		        .word nt_accept, xt_refill, z_refill
>bf3e		72 65 66 69 6c 6c		        .text "refill"
.bf44						nt_accept:
>bf44		06 18				        .byte 6, UF+NN
>bf46		52 bf e6 80 de 81		        .word nt_input_to_r, xt_accept, z_accept
>bf4c		61 63 63 65 70 74		        .text "accept"
.bf52						nt_input_to_r:
>bf52		07 08				        .byte 7, NN
>bf54		61 bf 71 91 86 91		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>bf5a		69 6e 70 75 74 3e 72		        .text "input>r"
.bf61						nt_r_to_input:
>bf61		07 08				        .byte 7, NN
>bf63		70 bf c4 99 db 99		        .word nt_unused, xt_r_to_input, z_r_to_input
>bf69		72 3e 69 6e 70 75 74		        .text "r>input"
.bf70						nt_unused:
>bf70		06 00				        .byte 6, 0
>bf72		7e bf 92 a4 a1 a4		        .word nt_depth, xt_unused, z_unused
>bf78		75 6e 75 73 65 64		        .text "unused"
.bf7e						nt_depth:
>bf7e		05 00				        .byte 5, 0
>bf80		8b bf 67 8a 75 8a		        .word nt_key, xt_depth, z_depth
>bf86		64 65 70 74 68			        .text "depth"
.bf8b						nt_key:
>bf8b		03 00				        .byte 3, 0
>bf8d		96 bf 3b 92 44 92		        .word nt_allot, xt_key, z_key
>bf93		6b 65 79			        .text "key"
.bf96						nt_allot:
>bf96		05 10				        .byte 5, UF
>bf98		a3 bf 30 82 98 82		        .word nt_create, xt_allot, z_allot
>bf9e		61 6c 6c 6f 74			        .text "allot"
.bfa3						nt_create:
>bfa3		06 00				        .byte 6, 0
>bfa5		b1 bf db 88 ae 89		        .word nt_does, xt_create, z_create
>bfab		63 72 65 61 74 65		        .text "create"
.bfb1						nt_does:
>bfb1		05 05				        .byte 5, CO+IM
>bfb3		be bf 4d 8b 5b 8b		        .word nt_variable, xt_does, z_does
>bfb9		64 6f 65 73 3e			        .text "does>"
.bfbe						nt_variable:
>bfbe		08 00				        .byte 8, 0
>bfc0		ce bf b6 a4 ce a4		        .word nt_constant, xt_variable, z_variable
>bfc6		76 61 72 69 61 62 6c 65		        .text "variable"
.bfce						nt_constant:
>bfce		08 10				        .byte 8, UF
>bfd0		de bf 83 88 c0 88		        .word nt_value, xt_constant, z_constant
>bfd6		63 6f 6e 73 74 61 6e 74		        .text "constant"
.bfde						nt_value:
>bfde		05 10				        .byte 5, UF
>bfe0		eb bf 83 88 c0 88		        .word nt_to, xt_constant, z_constant
>bfe6		76 61 6c 75 65			        .text "value"
.bfeb						nt_to:
>bfeb		02 0c				        .byte 2, NN+IM
>bfed		f5 bf 7e a0 b9 a0		        .word nt_s_to_d, xt_to, z_to
>bff3		74 6f				        .text "to"
.bff5						nt_s_to_d:
>bff5		03 10				        .byte 3, UF
>bff7		00 c0 1c 9d 2d 9d		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>bffd		73 3e 64			        .text "s>d"
.c000						nt_d_to_s:
>c000		03 10				        .byte 3, UF
>c002		0b c0 f1 89 f6 89		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c008		64 3e 73			        .text "d>s"
.c00b						nt_d_minus:
>c00b		02 10				        .byte 2, UF
>c00d		15 c0 af 89 cf 89		        .word nt_d_plus, xt_d_minus, z_d_minus
>c013		64 2d				        .text "d-"
.c015						nt_d_plus:
>c015		02 10				        .byte 2, UF
>c017		1f c0 d0 89 f0 89		        .word nt_erase, xt_d_plus, z_d_plus
>c01d		64 2b				        .text "d+"
.c01f						nt_erase:
>c01f		05 00				        .byte 5, 0      ; underflow checked by FILL
>c021		2c c0 79 8e c1 8e		        .word nt_blank, xt_erase, z_erase
>c027		65 72 61 73 65			        .text "erase"
.c02c						nt_blank:
>c02c		05 00				        .byte 5, 0     ; underflow checked by FILL
>c02e		39 c0 6f 8e c1 8e		        .word nt_fill, xt_blank, z_blank
>c034		62 6c 61 6e 6b			        .text "blank"
.c039						nt_fill:
>c039		04 10				        .byte 4, UF
>c03b		45 c0 7f 8e c1 8e		        .word nt_find_name, xt_fill, z_fill
>c041		66 69 6c 6c			        .text "fill"
.c045						nt_find_name:
>c045		09 10				        .byte 9, UF
>c047		56 c0 59 8f 9c 8f		        .word nt_tick, xt_find_name, z_find_name
>c04d		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c055		65
.c056						nt_tick:
>c056		01 00				        .byte 1, 0
>c058		5f c0 5e a0 7d a0		        .word nt_bracket_tick, xt_tick, z_tick
>c05e		27				        .text "'"
.c05f						nt_bracket_tick:
>c05f		03 05				        .byte 3, CO+IM
>c061		6a c0 24 85 2a 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c067		5b 27 5d			        .text "[']"
.c06a						nt_name_to_int:
>c06a		08 10				        .byte 8, UF
>c06c		7a c0 10 95 2c 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c072		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c07a						nt_int_to_name:
>c07a		08 10				        .byte 8, UF
>c07c		8a c0 87 91 f7 91		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c082		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c08a						nt_name_to_string:
>c08a		0b 10				        .byte 11, UF
>c08c		9d c0 2d 95 43 95		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c092		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c09a		69 6e 67
.c09d						nt_to_body:
>c09d		05 10				        .byte 5, UF
>c09f		aa c0 ba a0 dc a0		        .word nt_defer, xt_to_body, z_to_body
>c0a5		3e 62 6f 64 79			        .text ">body"
.c0aa						nt_defer:
>c0aa		05 00				        .byte 5, 0
>c0ac		b7 c0 1d 8a 4f 8a		        .word nt_latestxt, xt_defer, z_defer
>c0b2		64 65 66 65 72			        .text "defer"
.c0b7						nt_latestxt:
>c0b7		08 00				        .byte 8, 0
>c0b9		c7 c0 56 92 5c 92		        .word nt_latestnt, xt_latestxt, z_latestxt
>c0bf		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c0c7						nt_latestnt:
>c0c7		08 00				        .byte 8, 0
>c0c9		d7 c0 48 92 55 92		        .word nt_parse_name, xt_latestnt, z_latestnt
>c0cf		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c0d7						nt_parse_name:
>c0d7		0a 08				        .byte 10, NN
>c0d9		e9 c0 02 98 f2 98		        .word nt_parse, xt_parse_name, z_parse_name
>c0df		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c0e7		6d 65
.c0e9						nt_parse:
>c0e9		05 10				        .byte 5, UF
>c0eb		f6 c0 5d 98 f2 98		        .word nt_execute_parsing, xt_parse, z_parse
>c0f1		70 61 72 73 65			        .text "parse"
.c0f6						nt_execute_parsing:
>c0f6		0f 10				        .byte 15, UF
>c0f8		0d c1 d6 8e fc 8e		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c0fe		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c106		70 61 72 73 69 6e 67
.c10d						nt_source:
>c10d		06 00				        .byte 6, 0
>c10f		1b c1 5b 9f 6f 9f		        .word nt_source_id, xt_source, z_source
>c115		73 6f 75 72 63 65		        .text "source"
.c11b						nt_source_id:
>c11b		09 00				        .byte 9, 0
>c11d		2c c1 70 9f 7a 9f		        .word nt_colon, xt_source_id, z_source_id
>c123		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c12b		64
.c12c						nt_colon:
>c12c		01 00				        .byte 1, 0
>c12e		35 c1 7f 86 c1 86		        .word nt_semicolon, xt_colon, z_colon
>c134		3a				        .text ":"
.c135						nt_semicolon:
>c135		01 05				        .byte 1, CO+IM
>c137		3e c1 ed 9d 4b 9e		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c13d		3b				        .text ";"
.c13e						nt_colon_noname:
>c13e		07 00				        .byte 7, 0
>c140		4d c1 c2 86 dd 86		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c146		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c14d						nt_compile_comma:
>c14d		08 18				        .byte 8, UF+NN
>c14f		5d c1 5d 87 76 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c155		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c15d						nt_left_bracket:
>c15d		01 05				        .byte 1, IM+CO
>c15f		66 c1 73 92 77 92		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c165		5b				        .text "["
.c166						nt_right_bracket:
>c166		01 04				        .byte 1, IM
>c168		6f c1 61 9a 67 9a		        .word nt_literal, xt_right_bracket, z_right_bracket
>c16e		5d				        .text "]"
.c16f						nt_literal:
>c16f		07 15				        .byte 7, IM+CO+UF
>c171		7e c1 a8 92 b5 92		        .word nt_sliteral, xt_literal, z_literal
>c177		6c 69 74 65 72 61 6c		        .text "literal"
.c17e						nt_sliteral:
>c17e		08 15				        .byte 8, CO+IM+UF
>c180		8e c1 9e 9e 05 9f		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c186		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c18e						nt_dot_quote:
>c18e		02 05				        .byte 2, CO+IM
>c190		98 c1 bf 8b c9 8b		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c196		2e 22				        .text ".", $22
.c198						nt_s_quote:
>c198		02 0c				        .byte 2, IM+NN
>c19a		a2 c1 fc 9b 1b 9d		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c1a0		73 22				        .text "s", $22
.c1a2						nt_s_backslash_quote:
>c1a2		03 04				        .byte 3, IM
>c1a4		ad c1 a1 9a aa 9a		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c1aa		73 5c 22			        .text "s", $5C, $22
.c1ad						nt_postpone:
>c1ad		08 05				        .byte 8, IM+CO
>c1af		bd c1 37 99 75 99		        .word nt_immediate, xt_postpone, z_postpone
>c1b5		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c1bd						nt_immediate:
>c1bd		09 00				        .byte 9, 0
>c1bf		ce c1 5a 91 65 91		        .word nt_compile_only, xt_immediate, z_immediate
>c1c5		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c1cd		65
.c1ce						nt_compile_only:
>c1ce		0c 00				        .byte 12, 0
>c1d0		e2 c1 77 88 82 88		        .word nt_never_native, xt_compile_only, z_compile_only
>c1d6		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c1de		6f 6e 6c 79
.c1e2						nt_never_native:
>c1e2		0c 00				        .byte 12, 0
>c1e4		f6 c1 5a 95 67 95		        .word nt_always_native, xt_never_native, z_never_native
>c1ea		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c1f2		74 69 76 65
.c1f6						nt_always_native:
>c1f6		0d 00				        .byte 13, 0
>c1f8		0b c2 b5 82 c2 82		        .word nt_allow_native, xt_always_native, z_always_native
>c1fe		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c206		61 74 69 76 65
.c20b						nt_allow_native:
>c20b		0c 00				        .byte 12, 0
>c20d		1f c2 99 82 a4 82		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c213		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c21b		74 69 76 65
.c21f						nt_nc_limit:
>c21f		08 08				        .byte 8, NN
>c221		2f c2 44 95 49 95		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c227		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c22f						nt_strip_underflow:
>c22f		0f 08				        .byte 15, NN
>c231		46 c2 00 a0 05 a0		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c237		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c23f		64 65 72 66 6c 6f 77
.c246						nt_abort:
>c246		05 00				        .byte 5, 0
>c248		53 c2 60 80 b1 80		        .word nt_abort_quote, xt_abort, z_abort
>c24e		61 62 6f 72 74			        .text "abort"
.c253						nt_abort_quote:
>c253		06 0d				        .byte 6, CO+IM+NN
>c255		61 c2 b1 80 bb 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c25b		61 62 6f 72 74 22		        .text "abort", $22
.c261						nt_do:
>c261		02 0d				        .byte 2, CO+IM+NN
>c263		6b c2 d1 8a 0a 8b		        .word nt_question_do, xt_do, z_do
>c269		64 6f				        .text "do"
.c26b						nt_question_do:
>c26b		03 0d				        .byte 3, CO+IM+NN
>c26d		76 c2 cd 8a 0a 8b		        .word nt_i, xt_question_do, z_question_do
>c273		3f 64 6f			        .text "?do"
.c276						nt_i:
>c276		01 01				        .byte 1, CO
>c278		7f c2 ff 90 13 91		        .word nt_j, xt_i, z_i
>c27e		69				        .text "i"
.c27f						nt_j:
>c27f		01 01				        .byte 1, CO
>c281		88 c2 21 92 3a 92		        .word nt_loop, xt_j, z_j
>c287		6a				        .text "j"
.c288						nt_loop:
>c288		04 05				        .byte 4, CO+IM
>c28a		94 c2 19 93 7b 93		        .word nt_plus_loop, xt_loop, z_loop
>c290		6c 6f 6f 70			        .text "loop"
.c294						nt_plus_loop:
>c294		05 05				        .byte 5, CO+IM
>c296		a1 c2 2a 93 7b 93		        .word nt_exit, xt_plus_loop, z_plus_loop
>c29c		2b 6c 6f 6f 70			        .text "+loop"
.c2a1						nt_exit:
>c2a1		04 03				        .byte 4, AN+CO
>c2a3		ad c2 fd 8e fe 8e		        .word nt_unloop, xt_exit, z_exit
>c2a9		65 78 69 74			        .text "exit"
.c2ad						nt_unloop:
>c2ad		06 01				        .byte 6, CO
>c2af		bb c2 6d a4 7c a4		        .word nt_leave, xt_unloop, z_unloop
>c2b5		75 6e 6c 6f 6f 70		        .text "unloop"
.c2bb						nt_leave:
>c2bb		05 05				        .byte 5, CO+IM
>c2bd		c8 c2 5d 92 72 92		        .word nt_recurse, xt_leave, z_leave
>c2c3		6c 65 61 76 65			        .text "leave"
.c2c8						nt_recurse:
>c2c8		07 0d				        .byte 7, CO+IM+NN
>c2ca		d7 c2 dc 99 18 9a		        .word nt_quit, xt_recurse, z_recurse
>c2d0		72 65 63 75 72 73 65		        .text "recurse"
.c2d7						nt_quit:
>c2d7		04 00				        .byte 4, 0
>c2d9		e3 c2 62 80 b1 80		        .word nt_begin, xt_quit, z_quit
>c2df		71 75 69 74			        .text "quit"
.c2e3						nt_begin:
>c2e3		05 07				        .byte 5, AN+CO+IM
>c2e5		f0 c2 37 83 3a 83		        .word nt_again, xt_begin, z_begin
>c2eb		62 65 67 69 6e			        .text "begin"
.c2f0						nt_again:
>c2f0		05 17				        .byte 5, AN+CO+IM+UF
>c2f2		fd c2 21 82 2e 82		        .word nt_state, xt_again, z_again
>c2f8		61 67 61 69 6e			        .text "again"
.c2fd						nt_state:
>c2fd		05 00				        .byte 5, 0
>c2ff		0a c3 df 9f e9 9f		        .word nt_evaluate, xt_state, z_state
>c305		73 74 61 74 65			        .text "state"
.c30a						nt_evaluate:
>c30a		08 10				        .byte 8, UF
>c30c		1a c3 eb 8f 3e 90		        .word nt_base, xt_evaluate, z_evaluate
>c312		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c31a						nt_base:
>c31a		04 00				        .byte 4, 0
>c31c		26 c3 2e 83 36 83		        .word nt_digit_question, xt_base, z_base
>c322		62 61 73 65			        .text "base"
.c326						nt_digit_question:
>c326		06 10				        .byte 6, UF
>c328		34 c3 76 8a aa 8a		        .word nt_number, xt_digit_question, z_digit_question
>c32e		64 69 67 69 74 3f		        .text "digit?"
.c334						nt_number:
>c334		06 10				        .byte 6, UF
>c336		42 c3 b0 95 a9 96		        .word nt_to_number, xt_number, z_number
>c33c		6e 75 6d 62 65 72		        .text "number"
.c342						nt_to_number:
>c342		07 10				        .byte 7, UF
>c344		51 c3 e8 a0 87 a1		        .word nt_hex, xt_to_number, z_to_number
>c34a		3e 6e 75 6d 62 65 72		        .text ">number"
.c351						nt_hex:
>c351		03 00				        .byte 3, 0
>c353		5c c3 93 90 99 90		        .word nt_decimal, xt_hex, z_hex
>c359		68 65 78			        .text "hex"
.c35c						nt_decimal:
>c35c		07 00				        .byte 7, 0
>c35e		6b c3 16 8a 1c 8a		        .word nt_count, xt_decimal, z_decimal
>c364		64 65 63 69 6d 61 6c		        .text "decimal"
.c36b						nt_count:
>c36b		05 10				        .byte 5, UF
>c36d		78 c3 c1 88 d4 88		        .word nt_m_star, xt_count, z_count
>c373		63 6f 75 6e 74			        .text "count"
.c378						nt_m_star:
>c378		02 10				        .byte 2, UF
>c37a		82 c3 bd 93 d7 93		        .word nt_um_star, xt_m_star, z_m_star
>c380		6d 2a				        .text "m*"
.c382						nt_um_star:
>c382		03 10				        .byte 3, UF
>c384		8d c3 27 a4 6c a4		        .word nt_star, xt_um_star, z_um_star
>c38a		75 6d 2a			        .text "um*"
.c38d						nt_star:
>c38d		01 10				        .byte 1, UF
>c38f		96 c3 bd 9f c5 9f		        .word nt_um_slash_mod, xt_star, z_star
>c395		2a				        .text "*"
.c396						nt_um_slash_mod:
>c396		06 10				        .byte 6, UF
>c398		a4 c3 e5 a3 26 a4		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c39e		75 6d 2f 6d 6f 64		        .text "um/mod"
.c3a4						nt_sm_slash_rem:
>c3a4		06 10				        .byte 6, UF
>c3a6		b2 c3 32 9f 5a 9f		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c3ac		73 6d 2f 72 65 6d		        .text "sm/rem"
.c3b2						nt_fm_slash_mod:
>c3b2		06 10				        .byte 6, UF
>c3b4		c0 c3 a7 8f dd 8f		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c3ba		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c3c0						nt_slash:
>c3c0		01 10				        .byte 1, UF
>c3c2		c9 c3 61 9e 7d 9e		        .word nt_slash_mod, xt_slash, z_slash
>c3c8		2f				        .text "/"
.c3c9						nt_slash_mod:
>c3c9		04 10				        .byte 4, UF
>c3cb		d5 c3 66 9e 7d 9e		        .word nt_mod, xt_slash_mod, z_slash_mod
>c3d1		2f 6d 6f 64			        .text "/mod"
.c3d5						nt_mod:
>c3d5		03 10				        .byte 3, UF
>c3d7		e0 c3 e8 94 f0 94		        .word nt_star_slash_mod, xt_mod, z_mod
>c3dd		6d 6f 64			        .text "mod"
.c3e0						nt_star_slash_mod:
>c3e0		05 10				        .byte 5, UF
>c3e2		ed c3 cf 9f de 9f		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c3e8		2a 2f 6d 6f 64			        .text "*/mod"
.c3ed						nt_star_slash:
>c3ed		02 10				        .byte 2, UF
>c3ef		f7 c3 c6 9f ce 9f		        .word nt_backslash, xt_star_slash, z_star_slash
>c3f5		2a 2f				        .text "*/"
.c3f7						nt_backslash:
>c3f7		01 04				        .byte 1, IM
>c3f9		00 c4 03 83 2d 83		        .word nt_move, xt_backslash, z_backslash
>c3ff		5c				        .byte '\'
.c400						nt_move:
>c400		04 18				        .byte 4, NN+UF
>c402		0c c4 f1 94 0f 95		        .word nt_cmove_up, xt_move, z_move
>c408		6d 6f 76 65			        .text "move"
.c40c						nt_cmove_up:
>c40c		06 10				        .byte 6, UF
>c40e		1a c4 44 86 7e 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c414		63 6d 6f 76 65 3e		        .text "cmove>"
.c41a						nt_cmove:
>c41a		05 10				        .byte 5, UF
>c41c		27 c4 09 86 43 86		        .word nt_pad, xt_cmove, z_cmove
>c422		63 6d 6f 76 65			        .text "cmove"
.c427						nt_pad:
>c427		03 00				        .byte 3, 0
>c429		32 c4 c4 97 d3 97		        .word nt_cleave, xt_pad, z_pad
>c42f		70 61 64			        .text "pad"
.c432						nt_cleave:
>c432		06 10				        .byte 6, UF
>c434		40 c4 bc 85 08 86		        .word nt_hexstore, xt_cleave, z_cleave
>c43a		63 6c 65 61 76 65		        .text "cleave"
.c440						nt_hexstore:
>c440		08 10				        .byte 8, UF
>c442		50 c4 9a 90 ec 90		        .word nt_within, xt_hexstore, z_hexstore
>c448		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c450						nt_within:
>c450		06 10				        .byte 6, UF
>c452		5e c4 e3 a4 f8 a4		        .word nt_to_in, xt_within, z_within
>c458		77 69 74 68 69 6e		        .text "within"
.c45e						nt_to_in:
>c45e		03 00				        .byte 3, 0
>c460		69 c4 dd a0 e7 a0		        .word nt_less_number_sign, xt_to_in, z_to_in
>c466		3e 69 6e			        .text ">in"
.c469						nt_less_number_sign:
>c469		02 00				        .byte 2, 0
>c46b		73 c4 78 92 85 92		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c471		3c 23				        .text "<#"
.c473						nt_number_sign:
>c473		01 10				        .byte 1, UF
>c475		7c c4 aa 96 de 96		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c47b		23				        .text "#"
.c47c						nt_number_sign_s:
>c47c		02 10				        .byte 2, UF
>c47e		86 c4 01 97 11 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c484		23 73				        .text "#s"
.c486						nt_number_sign_greater:
>c486		02 10				        .byte 2, UF
>c488		90 c4 df 96 00 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c48e		23 3e				        .text "#>"
.c490						nt_hold:
>c490		04 10				        .byte 4, UF
>c492		9c c4 ed 90 fe 90		        .word nt_sign, xt_hold, z_hold
>c498		68 6f 6c 64			        .text "hold"
.c49c						nt_sign:
>c49c		04 10				        .byte 4, UF
>c49e		a8 c4 4c 9e 60 9e		        .word nt_output, xt_sign, z_sign
>c4a4		73 69 67 6e			        .text "sign"
.c4a8						nt_output:
>c4a8		06 00				        .byte 6, 0
>c4aa		b6 c4 ab 97 b5 97		        .word nt_input, xt_output, z_output
>c4b0		6f 75 74 70 75 74		        .text "output"
.c4b6						nt_input:
>c4b6		05 00				        .byte 5, 0
>c4b8		c3 c4 66 91 70 91		        .word nt_cr, xt_input, z_input
>c4be		69 6e 70 75 74			        .text "input"
.c4c3						nt_cr:
>c4c3		02 00				        .byte 2, 0
>c4c5		cd c4 d5 88 da 88		        .word nt_page, xt_cr, z_cr
>c4cb		63 72				        .text "cr"
.c4cd						nt_page:
>c4cd		04 00				        .byte 4, 0
>c4cf		d9 c4 d4 97 f1 97		        .word nt_at_xy, xt_page, z_page
>c4d5		70 61 67 65			        .text "page"
.c4d9						nt_at_xy:
>c4d9		05 10				        .byte 5, UF
>c4db		e6 c4 d5 82 02 83		        .word nt_marker, xt_at_xy, z_at_xy
>c4e1		61 74 2d 78 79			        .text "at-xy"
.c4e6						nt_marker:
>c4e6		06 04				        .byte 6, IM
>c4e8		f4 c4 d8 93 15 94		        .word nt_words, xt_marker, z_marker
>c4ee		6d 61 72 6b 65 72		        .text "marker"
.c4f4						nt_words:
>c4f4		05 00				        .byte 5, 0
>c4f6		01 c5 54 a5 b0 a5		        .word nt_wordsize, xt_words, z_words
>c4fc		77 6f 72 64 73			        .text "words"
.c501						nt_wordsize:
>c501		08 10				        .byte 8, UF
>c503		11 c5 b1 a5 d1 a5		        .word nt_aligned, xt_wordsize, z_wordsize
>c509		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c511						nt_aligned:
>c511		07 00				        .byte 7, 0
>c513		20 c5 2f 82 2f 82		        .word nt_align, xt_align, z_align
>c519		61 6c 69 67 6e 65 64		        .text "aligned"
.c520						nt_align:
>c520		05 00				        .byte 5, 0
>c522		2d c5 2f 82 2f 82		        .word nt_bell, xt_align, z_align
>c528		61 6c 69 67 6e			        .text "align"
.c52d						nt_bell:
>c52d		04 00				        .byte 4, 0
>c52f		39 c5 3b 83 40 83		        .word nt_dump, xt_bell, z_bell
>c535		62 65 6c 6c			        .text "bell"
.c539						nt_dump:
>c539		04 10				        .byte 4, UF
>c53b		45 c5 8c 8c f2 8c		        .word nt_dot_s, xt_dump, z_dump
>c541		64 75 6d 70			        .text "dump"
.c545						nt_dot_s:
>c545		02 00				        .byte 2, 0
>c547		4f c5 f8 8b 3b 8c		        .word +, xt_dot_s, z_dot_s
>c54d		2e 73				        .text ".s"
.c54f						+
.c54f						nt_disasm:
>c54f		06 10				        .byte 6, UF
>c551		5d c5 ab 8a b1 8a		        .word +, xt_disasm, z_disasm
>c557		64 69 73 61 73 6d		        .text "disasm"
.c55d						+
.c55d						nt_compare:
>c55d		07 10				        .byte 7, UF
>c55f		6c c5 f8 86 5c 87		        .word nt_search, xt_compare, z_compare
>c565		63 6f 6d 70 61 72 65		        .text "compare"
.c56c						nt_search:
>c56c		06 18				        .byte 6, UF+NN
>c56e		7a c5 4e 9d ec 9d		        .word +, xt_search, z_search
>c574		73 65 61 72 63 68		        .text "search"
.c57a						+
.c57a						nt_environment_q:
>c57a		0c 10				        .byte 12, UF
>c57c		8e c5 9a 8d 16 8e		        .word +, xt_environment_q, z_environment_q
>c582		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c58a		65 6e 74 3f
.c58e						+
.c58e						nt_find:
>c58e		04 10				        .byte 4, UF
>c590		9a c5 11 8f 58 8f		        .word nt_word, xt_find, z_find
>c596		66 69 6e 64			        .text "find"
.c59a						nt_word:
>c59a		04 10				        .byte 4, UF
>c59c		a6 c5 f9 a4 3c a5		        .word nt_paren, xt_word, z_word
>c5a2		77 6f 72 64			        .text "word"
.c5a6						nt_paren:
>c5a6		01 04				        .byte 1, IM
>c5a8		af c5 f2 97 01 98		        .word nt_dot_paren, xt_paren, z_paren
>c5ae		28				        .text "("
.c5af						nt_dot_paren:
>c5af		02 04				        .byte 2, IM
>c5b1		b9 c5 b0 8b be 8b		        .word nt_if, xt_dot_paren, z_dot_paren
>c5b7		2e 28				        .text ".("
.c5b9						nt_if:
>c5b9		02 0d				        .byte 2, IM+CO+NN
>c5bb		c3 c5 14 91 24 91		        .word nt_then, xt_if, z_if
>c5c1		69 66				        .text "if"
.c5c3						nt_then:
>c5c3		04 0d				        .byte 4, IM+CO+NN
>c5c5		cf c5 25 8d 6e 8d		        .word nt_else, xt_then, z_then
>c5cb		74 68 65 6e			        .text "then"
.c5cf						nt_else:
>c5cf		04 0d				        .byte 4, IM+CO+NN
>c5d1		db c5 19 8d 6e 8d		        .word nt_repeat, xt_else, z_else
>c5d7		65 6c 73 65			        .text "else"
.c5db						nt_repeat:
>c5db		06 0d				        .byte 6, IM+CO+NN
>c5dd		e9 c5 5b 9a 61 9a		        .word nt_until, xt_repeat, z_repeat
>c5e3		72 65 70 65 61 74		        .text "repeat"
.c5e9						nt_until:
>c5e9		05 0d				        .byte 5, IM+CO+NN
>c5eb		f6 c5 7d a4 91 a4		        .word nt_while, xt_until, z_until
>c5f1		75 6e 74 69 6c			        .text "until"
.c5f6						nt_while:
>c5f6		05 0d				        .byte 5, IM+CO+NN
>c5f8		03 c6 cf a4 e2 a4		        .word nt_case, xt_while, z_while
>c5fe		77 68 69 6c 65			        .text "while"
.c603						nt_case:
>c603		04 0d				        .byte 4, IM+CO+NN
>c605		0f c6 e4 a5 ea a5		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c60b		63 61 73 65			        .text "case"
.c60f						nt_of:
>c60f		02 0d				        .byte 2, IM+CO+NN
>c611		19 c6 12 97 2a 97		        .word nt_endof, xt_of, z_of
>c617		6f 66				        .text "of"
.c619						nt_endof:
>c619		05 0d				        .byte 5, IM+CO+NN
>c61b		26 c6 19 8d 6e 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c621		65 6e 64 6f 66			        .text "endof"
.c626						nt_endcase:
>c626		07 0d				        .byte 7, IM+CO+NN
>c628		35 c6 85 8d 99 8d		        .word nt_defer_fetch, xt_endcase, z_endcase
>c62e		65 6e 64 63 61 73 65		        .text "endcase"
.c635						nt_defer_fetch:
>c635		06 00				        .byte 6, 0
>c637		43 c6 50 8a 56 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c63d		64 65 66 65 72 40		        .text "defer@"
.c643						nt_defer_store:
>c643		06 00				        .byte 6, 0
>c645		51 c6 57 8a 5d 8a		        .word nt_is, xt_defer_store, z_defer_store
>c64b		64 65 66 65 72 21		        .text "defer!"
.c651						nt_is:
>c651		02 04				        .byte 2, IM
>c653		5b c6 08 92 20 92		        .word nt_action_of, xt_is, z_is
>c659		69 73				        .text "is"
.c65b						nt_action_of:
>c65b		09 04				        .byte 9, IM
>c65d		6c c6 08 82 20 82		        .word nt_useraddr, xt_action_of, z_action_of
>c663		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c66b		66
.c66c						nt_useraddr:
>c66c		08 00				        .byte 8, 0
>c66e		7c c6 ab a4 b5 a4		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c674		75 73 65 72 61 64 64 72		        .text "useraddr"
.c67c						nt_buffer_colon:
>c67c		07 00				        .byte 7, 0
>c67e		8b c6 61 85 67 85		        .word +, xt_buffer_colon, z_buffer_colon
>c684		62 75 66 66 65 72 3a		        .text "buffer:"
.c68b						+
.c68b						nt_buffstatus:
>c68b		0a 00				        .byte 10, 0
>c68d		9d c6 68 85 6d 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c693		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c69b		75 73
.c69d						nt_buffblocknum:
>c69d		0c 00				        .byte 12, 0
>c69f		b1 c6 2b 85 30 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c6a5		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c6ad		6b 6e 75 6d
.c6b1						nt_blkbuffer:
>c6b1		09 00				        .byte 9, 0
>c6b3		c2 c6 4f 83 5c 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c6b9		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c6c1		72
.c6c2						nt_scr:
>c6c2		03 08				        .byte 3, NN
>c6c4		cd c6 49 9d 4e 9d		        .word nt_blk, xt_scr, z_scr
>c6ca		73 63 72			        .text "scr"
.c6cd						nt_blk:
>c6cd		03 08				        .byte 3, NN
>c6cf		d8 c6 4a 83 4f 83		        .word nt_block_write, xt_blk, z_blk
>c6d5		62 6c 6b			        .text "blk"
.c6d8						nt_block_write:
>c6d8		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c6da		eb c6 f1 84 ff 84		        .word nt_block_write_vector, xt_block_write, z_block_write
>c6e0		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c6e8		69 74 65
.c6eb						nt_block_write_vector:
>c6eb		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c6ed		05 c7 ff 84 04 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c6f3		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c6fb		69 74 65 2d 76 65 63 74 6f 72
.c705						nt_block_read:
>c705		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c707		17 c7 d9 84 e7 84		        .word nt_block_read_vector, xt_block_read, z_block_read
>c70d		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c715		61 64
.c717						nt_block_read_vector:
>c717		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c719		30 c7 e7 84 ec 84		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c71f		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c727		61 64 2d 76 65 63 74 6f 72
.c730						nt_save_buffers:
>c730		0c 00				        .byte 12, 0
>c732		44 c7 2e 9d 48 9d		        .word nt_block, xt_save_buffers, z_save_buffers
>c738		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c740		66 65 72 73
.c744						nt_block:
>c744		05 00				        .byte 5, 0
>c746		51 c7 5d 83 af 83		        .word nt_update, xt_block, z_block
>c74c		62 6c 6f 63 6b			        .text "block"
.c751						nt_update:
>c751		06 00				        .byte 6, 0
>c753		5f c7 a2 a4 aa a4		        .word nt_buffer, xt_update, z_update
>c759		75 70 64 61 74 65		        .text "update"
.c75f						nt_buffer:
>c75f		06 00				        .byte 6, 0
>c761		6d c7 30 85 60 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c767		62 75 66 66 65 72		        .text "buffer"
.c76d						nt_empty_buffers:
>c76d		0d 00				        .byte 13, 0
>c76f		82 c7 7e 8d 84 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c775		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c77d		66 66 65 72 73
.c782						nt_flush:
>c782		05 00				        .byte 5, 0
>c784		8f c7 9d 8f a6 8f		        .word nt_load, xt_flush, z_flush
>c78a		66 6c 75 73 68			        .text "flush"
.c78f						nt_load:
>c78f		04 10				        .byte 4, UF
>c791		9b c7 d5 92 18 93		        .word nt_thru, xt_load, z_load
>c797		6c 6f 61 64			        .text "load"
.c79b						nt_thru:
>c79b		04 10				        .byte 4, UF
>c79d		a7 c7 19 a0 5d a0		        .word nt_list, xt_thru, z_thru
>c7a3		74 68 72 75			        .text "thru"
.c7a7						nt_list:
>c7a7		04 10				        .byte 4, UF
>c7a9		b3 c7 9b 92 a7 92		        .word +, xt_list, z_list
>c7af		6c 69 73 74			        .text "list"
.c7b3						+
.c7b3						nt_block_ramdrive_init:
>c7b3		13 10				        .byte 19, UF
>c7b5		ce c7 b0 83 d8 84		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c7bb		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c7c3		6d 64 72 69 76 65 2d 69 6e 69 74
.c7ce						+
.c7ce						nt_definitions:
>c7ce		0b 00				        .byte 11, 0
>c7d0		e1 c7 5e 8a 66 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c7d6		64 65 66 69 6e 69 74 69		        .text "definitions"
>c7de		6f 6e 73
.c7e1						nt_wordlist:
>c7e1		08 00				        .byte 8, 0
>c7e3		f1 c7 3d a5 53 a5		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c7e9		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c7f1						nt_search_wordlist:
>c7f1		0f 10				        .byte 15, UF
>c7f3		08 c8 ba 9a 2d 9b		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c7f9		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c801		6f 72 64 6c 69 73 74
.c808						nt_set_current:
>c808		0b 10				        .byte 11, UF
>c80a		1b c8 bc 9b c7 9b		        .word nt_get_current, xt_set_current, z_set_current
>c810		73 65 74 2d 63 75 72 72		        .text "set-current"
>c818		65 6e 74
.c81b						nt_get_current:
>c81b		0b 00				        .byte 11, 0
>c81d		2e c8 3f 90 49 90		        .word nt_set_order, xt_get_current, z_get_current
>c823		67 65 74 2d 63 75 72 72		        .text "get-current"
>c82b		65 6e 74
.c82e						nt_set_order:
>c82e		09 00				        .byte 9, 0
>c830		3f c8 c8 9b fb 9b		        .word nt_get_order, xt_set_order, z_set_order
>c836		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c83e		72
.c83f						nt_get_order:
>c83f		09 00				        .byte 9, 0
>c841		50 c8 4a 90 72 90		        .word nt_root_wordlist, xt_get_order, z_get_order
>c847		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c84f		72
.c850						nt_root_wordlist:
>c850		0d 00				        .byte 13, 0
>c852		65 c8 68 9a 70 9a		        .word +, xt_root_wordlist, z_root_wordlist
>c858		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c860		64 6c 69 73 74
.c865						+
.c865						nt_assembler_wordlist:
>c865		12 00				        .byte 18, 0
>c867		7f c8 d2 a1 da a1		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c86d		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c875		72 2d 77 6f 72 64 6c 69 73 74
.c87f						+
.c87f						nt_editor_wordlist:
>c87f		0f 00				        .byte 15, 0
>c881		96 c8 2b 97 33 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>c887		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c88f		6f 72 64 6c 69 73 74
.c896						+
.c896						nt_forth_wordlist:
>c896		0e 00				        .byte 14, 0
>c898		ac c8 e4 a5 ea a5		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c89e		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c8a6		72 64 6c 69 73 74
.c8ac						nt_only:
>c8ac		04 00				        .byte 4, 0
>c8ae		b8 c8 4a 97 55 97		        .word nt_also, xt_only, z_only
>c8b4		6f 6e 6c 79			        .text "only"
.c8b8						nt_also:
>c8b8		04 00				        .byte 4, 0
>c8ba		c4 c8 a5 82 b4 82		        .word nt_previous, xt_also, z_also
>c8c0		61 6c 73 6f			        .text "also"
.c8c4						nt_previous:
>c8c4		08 00				        .byte 8, 0
>c8c6		d4 c8 76 99 82 99		        .word nt_to_order, xt_previous, z_previous
>c8cc		70 72 65 76 69 6f 75 73		        .text "previous"
.c8d4						nt_to_order:
>c8d4		06 00				        .byte 6, 0
>c8d6		e2 c8 88 a1 9a a1		        .word nt_order, xt_to_order, z_to_order
>c8dc		3e 6f 72 64 65 72		        .text ">order"
.c8e2						nt_order:
>c8e2		05 00				        .byte 5, 0
>c8e4		ef c8 68 97 92 97		        .word nt_forth, xt_order, z_order
>c8ea		6f 72 64 65 72			        .text "order"
.c8ef						nt_forth:
>c8ef		05 00				        .byte 5, 0
>c8f1		fc c8 de 8f e4 8f		        .word +, xt_forth, z_forth
>c8f7		66 6f 72 74 68			        .text "forth"
.c8fc						+
>c8fc		03 08				nt_see: .byte 3, NN
>c8fe		07 c9 2e 9b bb 9b		        .word +, xt_see, z_see
>c904		73 65 65			        .text "see"
.c907						+
.c907						nt_ed:
>c907		03 08				        .byte 3, NN
>c909		12 c9 15 8d 18 8d		        .word +, xt_ed, z_ed
>c90f		65 64 3a			        .text "ed:"
.c912						+
.c912						nt_cold:
>c912		04 00				        .byte 4, 0
>c914		1e c9 00 80 b1 80		        .word nt_bye, xt_cold, z_cold
>c91a		63 6f 6c 64			        .text "cold"
.c91e						nt_bye:
>c91e		03				        .byte 3         ; length of word strings
>c91f		00				        .byte 0         ; status byte
>c920		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>c922		6d 85				        .word xt_bye    ; start of code block (xt of this word)
>c924		70 85				        .word z_bye     ; end of code (RTS)
>c926		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.c929						root_dictionary_start:
.c929						nt_root_set_order:
>c929		09 00				        .byte 9, 0
>c92b		3a c9 c8 9b fb 9b		        .word nt_root_forth, xt_set_order, z_set_order
>c931		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c939		72
.c93a						nt_root_forth:
>c93a		05 00				        .byte 5, 0
>c93c		47 c9 de 8f e4 8f		        .word nt_root_forth_wordlist, xt_forth, z_forth
>c942		66 6f 72 74 68			        .text "forth"
.c947						nt_root_forth_wordlist:
>c947		0e 00				        .byte 14, 0
>c949		5d c9 e4 a5 ea a5		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>c94f		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c957		72 64 6c 69 73 74
.c95d						nt_root_words:
>c95d		05 00				        .byte 5, 0
>c95f		00 00 54 a5 b0 a5		        .word 0000, xt_words, z_words
>c965		77 6f 72 64 73			        .text "words"
.c96a						editor_dictionary_start:
.c96a						nt_editor_o:
>c96a		01 00				        .byte 1, 0
>c96c		73 c9 11 a7 56 a7		        .word nt_editor_line, xt_editor_o, z_editor_o
>c972		6f				        .text "o"
.c973						nt_editor_line:
>c973		04 10				        .byte 4, UF
>c975		7f c9 f8 a6 10 a7		        .word nt_editor_l, xt_editor_line, z_editor_line
>c97b		6c 69 6e 65			        .text "line"
.c97f						nt_editor_l:
>c97f		01 00				        .byte 1, 0
>c981		88 c9 7e a6 f7 a6		        .word nt_editor_el, xt_editor_l, z_editor_l
>c987		6c				        .text "l"
.c988						nt_editor_el:
>c988		02 00				        .byte 2, 0
>c98a		92 c9 6c a6 7d a6		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>c990		65 6c				        .text "el"
.c992						nt_editor_erase_screen:
>c992		0c 00				        .byte 12, 0
>c994		a6 c9 5a a6 6b a6		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>c99a		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>c9a2		72 65 65 6e
.c9a6						nt_editor_enter_screen:
>c9a6		0c 00				        .byte 12, 0
>c9a8		00 00 3e a6 59 a6		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>c9ae		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>c9b6		72 65 65 6e
.c9ba						assembler_dictionary_start:
.c9ba						nt_asm_adc_h:
>c9ba		05 0c						.byte 5, IM+NN
>c9bc		c7 c9				                .word nt_asm_adc_x
>c9be		ab a7 b0 a7					.word xt_asm_adc_h, z_asm_adc_h
>c9c2		61 64 63 2e 23					.text "adc.#"
.c9c7						nt_asm_adc_x:
>c9c7		05 0c						.byte 5, IM+NN
>c9c9		d4 c9				                .word nt_asm_adc_y
>c9cb		b0 a7 b5 a7					.word xt_asm_adc_x, z_asm_adc_x
>c9cf		61 64 63 2e 78					.text "adc.x"
.c9d4						nt_asm_adc_y:
>c9d4		05 0c						.byte 5, IM+NN
>c9d6		e1 c9				                .word nt_asm_adc_z
>c9d8		b5 a7 ba a7					.word xt_asm_adc_y, z_asm_adc_y
>c9dc		61 64 63 2e 79					.text "adc.y"
.c9e1						nt_asm_adc_z:
>c9e1		05 0c						.byte 5, IM+NN
>c9e3		ee c9				                .word nt_asm_adc_zi
>c9e5		ba a7 bf a7					.word xt_asm_adc_z, z_asm_adc_z
>c9e9		61 64 63 2e 7a					.text "adc.z"
.c9ee						nt_asm_adc_zi:
>c9ee		06 0c						.byte 6, IM+NN
>c9f0		fc c9				                .word nt_asm_adc_ziy
>c9f2		bf a7 c4 a7					.word xt_asm_adc_zi, z_asm_adc_zi
>c9f6		61 64 63 2e 7a 69				.text "adc.zi"
.c9fc						nt_asm_adc_ziy:
>c9fc		07 0c						.byte 7, IM+NN
>c9fe		0b ca				                .word nt_asm_adc_zx
>ca00		c4 a7 c9 a7					.word xt_asm_adc_ziy, z_asm_adc_ziy
>ca04		61 64 63 2e 7a 69 79				.text "adc.ziy"
.ca0b						nt_asm_adc_zx:
>ca0b		06 0c						.byte 6, IM+NN
>ca0d		19 ca				                .word nt_asm_adc_zxi
>ca0f		c9 a7 ce a7					.word xt_asm_adc_zx, z_asm_adc_zx
>ca13		61 64 63 2e 7a 78				.text "adc.zx"
.ca19						nt_asm_adc_zxi:
>ca19		07 0c						.byte 7, IM+NN
>ca1b		28 ca				                .word nt_asm_and
>ca1d		ce a7 d3 a7					.word xt_asm_adc_zxi, z_asm_adc_zxi
>ca21		61 64 63 2e 7a 78 69				.text "adc.zxi"
.ca28						nt_asm_and:
>ca28		04 0c						.byte 4, IM+NN
>ca2a		34 ca				                .word nt_asm_and_h
>ca2c		d3 a7 d8 a7					.word xt_asm_and, z_asm_and
>ca30		61 6e 64 2e					.text "and."
.ca34						nt_asm_and_h:
>ca34		05 0c						.byte 5, IM+NN
>ca36		41 ca				                .word nt_asm_and_x
>ca38		d8 a7 dd a7					.word xt_asm_and_h, z_asm_and_h
>ca3c		61 6e 64 2e 23					.text "and.#"
.ca41						nt_asm_and_x:
>ca41		05 0c						.byte 5, IM+NN
>ca43		4e ca				                .word nt_asm_and_y
>ca45		dd a7 e2 a7					.word xt_asm_and_x, z_asm_and_x
>ca49		61 6e 64 2e 78					.text "and.x"
.ca4e						nt_asm_and_y:
>ca4e		05 0c						.byte 5, IM+NN
>ca50		5b ca				                .word nt_asm_and_z
>ca52		e2 a7 e7 a7					.word xt_asm_and_y, z_asm_and_y
>ca56		61 6e 64 2e 79					.text "and.y"
.ca5b						nt_asm_and_z:
>ca5b		05 0c						.byte 5, IM+NN
>ca5d		68 ca				                .word nt_asm_and_zi
>ca5f		e7 a7 ec a7					.word xt_asm_and_z, z_asm_and_z
>ca63		61 6e 64 2e 7a					.text "and.z"
.ca68						nt_asm_and_zi:
>ca68		06 0c						.byte 6, IM+NN
>ca6a		76 ca				                .word nt_asm_and_ziy
>ca6c		ec a7 f1 a7					.word xt_asm_and_zi, z_asm_and_zi
>ca70		61 6e 64 2e 7a 69				.text "and.zi"
.ca76						nt_asm_and_ziy:
>ca76		07 0c						.byte 7, IM+NN
>ca78		85 ca				                .word nt_asm_and_zx
>ca7a		f1 a7 f6 a7					.word xt_asm_and_ziy, z_asm_and_ziy
>ca7e		61 6e 64 2e 7a 69 79				.text "and.ziy"
.ca85						nt_asm_and_zx:
>ca85		06 0c						.byte 6, IM+NN
>ca87		93 ca				                .word nt_asm_and_zxi
>ca89		f6 a7 fb a7					.word xt_asm_and_zx, z_asm_and_zx
>ca8d		61 6e 64 2e 7a 78				.text "and.zx"
.ca93						nt_asm_and_zxi:
>ca93		07 0c						.byte 7, IM+NN
>ca95		a2 ca				                .word nt_asm_asl
>ca97		fb a7 00 a8					.word xt_asm_and_zxi, z_asm_and_zxi
>ca9b		61 6e 64 2e 7a 78 69				.text "and.zxi"
.caa2						nt_asm_asl:
>caa2		03 0c						.byte 3, IM+NN
>caa4		ad ca				                .word nt_asm_asl_a
>caa6		00 a8 05 a8					.word xt_asm_asl, z_asm_asl
>caaa		61 73 6c					.text "asl"
.caad						nt_asm_asl_a:
>caad		05 0c						.byte 5, IM+NN
>caaf		ba ca				                .word nt_asm_asl_x
>cab1		05 a8 0a a8					.word xt_asm_asl_a, z_asm_asl_a
>cab5		61 73 6c 2e 61					.text "asl.a"
.caba						nt_asm_asl_x:
>caba		05 0c						.byte 5, IM+NN
>cabc		c7 ca				                .word nt_asm_asl_z
>cabe		0a a8 0f a8					.word xt_asm_asl_x, z_asm_asl_x
>cac2		61 73 6c 2e 78					.text "asl.x"
.cac7						nt_asm_asl_z:
>cac7		05 0c						.byte 5, IM+NN
>cac9		d4 ca				                .word nt_asm_asl_zx
>cacb		0f a8 14 a8					.word xt_asm_asl_z, z_asm_asl_z
>cacf		61 73 6c 2e 7a					.text "asl.z"
.cad4						nt_asm_asl_zx:
>cad4		06 0c						.byte 6, IM+NN
>cad6		e2 ca				                .word nt_asm_bcc
>cad8		14 a8 19 a8					.word xt_asm_asl_zx, z_asm_asl_zx
>cadc		61 73 6c 2e 7a 78				.text "asl.zx"
.cae2						nt_asm_bcc:
>cae2		03 0c						.byte 3, IM+NN
>cae4		ed ca				                .word nt_asm_bcs
>cae6		19 a8 1e a8					.word xt_asm_bcc, z_asm_bcc
>caea		62 63 63					.text "bcc"
.caed						nt_asm_bcs:
>caed		03 0c						.byte 3, IM+NN
>caef		f8 ca				                .word nt_asm_beq
>caf1		1e a8 25 a8					.word xt_asm_bcs, z_asm_bcs
>caf5		62 63 73					.text "bcs"
.caf8						nt_asm_beq:
>caf8		03 0c						.byte 3, IM+NN
>cafa		03 cb				                .word nt_asm_bit
>cafc		25 a8 2a a8					.word xt_asm_beq, z_asm_beq
>cb00		62 65 71					.text "beq"
.cb03						nt_asm_bit:
>cb03		03 0c						.byte 3, IM+NN
>cb05		0e cb				                .word nt_asm_bit_h
>cb07		2a a8 2f a8					.word xt_asm_bit, z_asm_bit
>cb0b		62 69 74					.text "bit"
.cb0e						nt_asm_bit_h:
>cb0e		05 0c						.byte 5, IM+NN
>cb10		1b cb				                .word nt_asm_bit_x
>cb12		2f a8 34 a8					.word xt_asm_bit_h, z_asm_bit_h
>cb16		62 69 74 2e 23					.text "bit.#"
.cb1b						nt_asm_bit_x:
>cb1b		05 0c						.byte 5, IM+NN
>cb1d		28 cb				                .word nt_asm_bit_z
>cb1f		34 a8 39 a8					.word xt_asm_bit_x, z_asm_bit_x
>cb23		62 69 74 2e 78					.text "bit.x"
.cb28						nt_asm_bit_z:
>cb28		05 0c						.byte 5, IM+NN
>cb2a		35 cb				                .word nt_asm_bit_zx
>cb2c		39 a8 3e a8					.word xt_asm_bit_z, z_asm_bit_z
>cb30		62 69 74 2e 7a					.text "bit.z"
.cb35						nt_asm_bit_zx:
>cb35		06 0c						.byte 6, IM+NN
>cb37		43 cb				                .word nt_asm_bmi
>cb39		3e a8 43 a8					.word xt_asm_bit_zx, z_asm_bit_zx
>cb3d		62 69 74 2e 7a 78				.text "bit.zx"
.cb43						nt_asm_bmi:
>cb43		03 0c						.byte 3, IM+NN
>cb45		4e cb				                .word nt_asm_bne
>cb47		43 a8 48 a8					.word xt_asm_bmi, z_asm_bmi
>cb4b		62 6d 69					.text "bmi"
.cb4e						nt_asm_bne:
>cb4e		03 0c						.byte 3, IM+NN
>cb50		59 cb				                .word nt_asm_bpl
>cb52		48 a8 4d a8					.word xt_asm_bne, z_asm_bne
>cb56		62 6e 65					.text "bne"
.cb59						nt_asm_bpl:
>cb59		03 0c						.byte 3, IM+NN
>cb5b		64 cb				                .word nt_asm_bra
>cb5d		4d a8 52 a8					.word xt_asm_bpl, z_asm_bpl
>cb61		62 70 6c					.text "bpl"
.cb64						nt_asm_bra:
>cb64		03 0c						.byte 3, IM+NN
>cb66		6f cb				                .word nt_asm_brk
>cb68		52 a8 57 a8					.word xt_asm_bra, z_asm_bra
>cb6c		62 72 61					.text "bra"
.cb6f						nt_asm_brk:
>cb6f		03 0c						.byte 3, IM+NN
>cb71		7a cb				                .word nt_asm_bvc
>cb73		57 a8 5c a8					.word xt_asm_brk, z_asm_brk
>cb77		62 72 6b					.text "brk"
.cb7a						nt_asm_bvc:
>cb7a		03 0c						.byte 3, IM+NN
>cb7c		85 cb				                .word nt_asm_bvs
>cb7e		5c a8 61 a8					.word xt_asm_bvc, z_asm_bvc
>cb82		62 76 63					.text "bvc"
.cb85						nt_asm_bvs:
>cb85		03 0c						.byte 3, IM+NN
>cb87		90 cb				                .word nt_asm_clc
>cb89		61 a8 66 a8					.word xt_asm_bvs, z_asm_bvs
>cb8d		62 76 73					.text "bvs"
.cb90						nt_asm_clc:
>cb90		03 0c						.byte 3, IM+NN
>cb92		9b cb				                .word nt_asm_cld
>cb94		66 a8 6b a8					.word xt_asm_clc, z_asm_clc
>cb98		63 6c 63					.text "clc"
.cb9b						nt_asm_cld:
>cb9b		03 0c						.byte 3, IM+NN
>cb9d		a6 cb				                .word nt_asm_cli
>cb9f		6b a8 70 a8					.word xt_asm_cld, z_asm_cld
>cba3		63 6c 64					.text "cld"
.cba6						nt_asm_cli:
>cba6		03 0c						.byte 3, IM+NN
>cba8		b1 cb				                .word nt_asm_clv
>cbaa		70 a8 75 a8					.word xt_asm_cli, z_asm_cli
>cbae		63 6c 69					.text "cli"
.cbb1						nt_asm_clv:
>cbb1		03 0c						.byte 3, IM+NN
>cbb3		bc cb				                .word nt_asm_cmp
>cbb5		75 a8 7a a8					.word xt_asm_clv, z_asm_clv
>cbb9		63 6c 76					.text "clv"
.cbbc						nt_asm_cmp:
>cbbc		03 0c						.byte 3, IM+NN
>cbbe		c7 cb				                .word nt_asm_cmp_h
>cbc0		7a a8 7f a8					.word xt_asm_cmp, z_asm_cmp
>cbc4		63 6d 70					.text "cmp"
.cbc7						nt_asm_cmp_h:
>cbc7		05 0c						.byte 5, IM+NN
>cbc9		d4 cb				                .word nt_asm_cmp_x
>cbcb		7f a8 84 a8					.word xt_asm_cmp_h, z_asm_cmp_h
>cbcf		63 6d 70 2e 23					.text "cmp.#"
.cbd4						nt_asm_cmp_x:
>cbd4		05 0c						.byte 5, IM+NN
>cbd6		e1 cb				                .word nt_asm_cmp_y
>cbd8		84 a8 89 a8					.word xt_asm_cmp_x, z_asm_cmp_x
>cbdc		63 6d 70 2e 78					.text "cmp.x"
.cbe1						nt_asm_cmp_y:
>cbe1		05 0c						.byte 5, IM+NN
>cbe3		ee cb				                .word nt_asm_cmp_z
>cbe5		89 a8 8e a8					.word xt_asm_cmp_y, z_asm_cmp_y
>cbe9		63 6d 70 2e 79					.text "cmp.y"
.cbee						nt_asm_cmp_z:
>cbee		05 0c						.byte 5, IM+NN
>cbf0		fb cb				                .word nt_asm_cmp_zi
>cbf2		8e a8 93 a8					.word xt_asm_cmp_z, z_asm_cmp_z
>cbf6		63 6d 70 2e 7a					.text "cmp.z"
.cbfb						nt_asm_cmp_zi:
>cbfb		06 0c						.byte 6, IM+NN
>cbfd		09 cc				                .word nt_asm_cmp_ziy
>cbff		93 a8 98 a8					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cc03		63 6d 70 2e 7a 69				.text "cmp.zi"
.cc09						nt_asm_cmp_ziy:
>cc09		07 0c						.byte 7, IM+NN
>cc0b		18 cc				                .word nt_asm_cmp_zx
>cc0d		98 a8 9d a8					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cc11		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cc18						nt_asm_cmp_zx:
>cc18		06 0c						.byte 6, IM+NN
>cc1a		26 cc				                .word nt_asm_cmp_zxi
>cc1c		9d a8 a2 a8					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cc20		63 6d 70 2e 7a 78				.text "cmp.zx"
.cc26						nt_asm_cmp_zxi:
>cc26		07 0c						.byte 7, IM+NN
>cc28		35 cc				                .word nt_asm_cpx
>cc2a		a2 a8 a7 a8					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cc2e		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cc35						nt_asm_cpx:
>cc35		03 0c						.byte 3, IM+NN
>cc37		40 cc				                .word nt_asm_cpx_h
>cc39		a7 a8 ac a8					.word xt_asm_cpx, z_asm_cpx
>cc3d		63 70 78					.text "cpx"
.cc40						nt_asm_cpx_h:
>cc40		05 0c						.byte 5, IM+NN
>cc42		4d cc				                .word nt_asm_cpx_z
>cc44		ac a8 b1 a8					.word xt_asm_cpx_h, z_asm_cpx_h
>cc48		63 70 78 2e 23					.text "cpx.#"
.cc4d						nt_asm_cpx_z:
>cc4d		05 0c						.byte 5, IM+NN
>cc4f		5a cc				                .word nt_asm_cpy
>cc51		b1 a8 b6 a8					.word xt_asm_cpx_z, z_asm_cpx_z
>cc55		63 70 78 2e 7a					.text "cpx.z"
.cc5a						nt_asm_cpy:
>cc5a		03 0c						.byte 3, IM+NN
>cc5c		65 cc				                .word nt_asm_cpy_h
>cc5e		b6 a8 bd a8					.word xt_asm_cpy, z_asm_cpy
>cc62		63 70 79					.text "cpy"
.cc65						nt_asm_cpy_h:
>cc65		05 0c						.byte 5, IM+NN
>cc67		72 cc				                .word nt_asm_cpy_z
>cc69		bd a8 c2 a8					.word xt_asm_cpy_h, z_asm_cpy_h
>cc6d		63 70 79 2e 23					.text "cpy.#"
.cc72						nt_asm_cpy_z:
>cc72		05 0c						.byte 5, IM+NN
>cc74		7f cc				                .word nt_asm_dec
>cc76		c2 a8 c7 a8					.word xt_asm_cpy_z, z_asm_cpy_z
>cc7a		63 70 79 2e 7a					.text "cpy.z"
.cc7f						nt_asm_dec:
>cc7f		03 0c						.byte 3, IM+NN
>cc81		8a cc				                .word nt_asm_dec_a
>cc83		c7 a8 cc a8					.word xt_asm_dec, z_asm_dec
>cc87		64 65 63					.text "dec"
.cc8a						nt_asm_dec_a:
>cc8a		05 0c						.byte 5, IM+NN
>cc8c		97 cc				                .word nt_asm_dec_x
>cc8e		cc a8 d1 a8					.word xt_asm_dec_a, z_asm_dec_a
>cc92		64 65 63 2e 61					.text "dec.a"
.cc97						nt_asm_dec_x:
>cc97		05 0c						.byte 5, IM+NN
>cc99		a4 cc				                .word nt_asm_dec_z
>cc9b		d1 a8 d6 a8					.word xt_asm_dec_x, z_asm_dec_x
>cc9f		64 65 63 2e 78					.text "dec.x"
.cca4						nt_asm_dec_z:
>cca4		05 0c						.byte 5, IM+NN
>cca6		b1 cc				                .word nt_asm_dec_zx
>cca8		d6 a8 db a8					.word xt_asm_dec_z, z_asm_dec_z
>ccac		64 65 63 2e 7a					.text "dec.z"
.ccb1						nt_asm_dec_zx:
>ccb1		06 0c						.byte 6, IM+NN
>ccb3		bf cc				                .word nt_asm_dex
>ccb5		db a8 e0 a8					.word xt_asm_dec_zx, z_asm_dec_zx
>ccb9		64 65 63 2e 7a 78				.text "dec.zx"
.ccbf						nt_asm_dex:
>ccbf		03 0c						.byte 3, IM+NN
>ccc1		ca cc				                .word nt_asm_dey
>ccc3		e0 a8 e5 a8					.word xt_asm_dex, z_asm_dex
>ccc7		64 65 78					.text "dex"
.ccca						nt_asm_dey:
>ccca		03 0c						.byte 3, IM+NN
>cccc		d5 cc				                .word nt_asm_eor
>ccce		e5 a8 ea a8					.word xt_asm_dey, z_asm_dey
>ccd2		64 65 79					.text "dey"
.ccd5						nt_asm_eor:
>ccd5		03 0c						.byte 3, IM+NN
>ccd7		e0 cc				                .word nt_asm_eor_h
>ccd9		ea a8 ef a8					.word xt_asm_eor, z_asm_eor
>ccdd		65 6f 72					.text "eor"
.cce0						nt_asm_eor_h:
>cce0		05 0c						.byte 5, IM+NN
>cce2		ed cc				                .word nt_asm_eor_x
>cce4		ef a8 f4 a8					.word xt_asm_eor_h, z_asm_eor_h
>cce8		65 6f 72 2e 23					.text "eor.#"
.cced						nt_asm_eor_x:
>cced		05 0c						.byte 5, IM+NN
>ccef		fa cc				                .word nt_asm_eor_y
>ccf1		f4 a8 f9 a8					.word xt_asm_eor_x, z_asm_eor_x
>ccf5		65 6f 72 2e 78					.text "eor.x"
.ccfa						nt_asm_eor_y:
>ccfa		05 0c						.byte 5, IM+NN
>ccfc		07 cd				                .word nt_asm_eor_z
>ccfe		f9 a8 fe a8					.word xt_asm_eor_y, z_asm_eor_y
>cd02		65 6f 72 2e 79					.text "eor.y"
.cd07						nt_asm_eor_z:
>cd07		05 0c						.byte 5, IM+NN
>cd09		14 cd				                .word nt_asm_eor_zi
>cd0b		fe a8 03 a9					.word xt_asm_eor_z, z_asm_eor_z
>cd0f		65 6f 72 2e 7a					.text "eor.z"
.cd14						nt_asm_eor_zi:
>cd14		06 0c						.byte 6, IM+NN
>cd16		22 cd				                .word nt_asm_eor_ziy
>cd18		03 a9 08 a9					.word xt_asm_eor_zi, z_asm_eor_zi
>cd1c		65 6f 72 2e 7a 69				.text "eor.zi"
.cd22						nt_asm_eor_ziy:
>cd22		07 0c						.byte 7, IM+NN
>cd24		31 cd				                .word nt_asm_eor_zx
>cd26		08 a9 0d a9					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cd2a		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cd31						nt_asm_eor_zx:
>cd31		06 0c						.byte 6, IM+NN
>cd33		3f cd				                .word nt_asm_eor_zxi
>cd35		0d a9 12 a9					.word xt_asm_eor_zx, z_asm_eor_zx
>cd39		65 6f 72 2e 7a 78				.text "eor.zx"
.cd3f						nt_asm_eor_zxi:
>cd3f		07 0c						.byte 7, IM+NN
>cd41		4e cd				                .word nt_asm_inc
>cd43		12 a9 17 a9					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cd47		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cd4e						nt_asm_inc:
>cd4e		03 0c						.byte 3, IM+NN
>cd50		59 cd				                .word nt_asm_inc_a
>cd52		17 a9 1c a9					.word xt_asm_inc, z_asm_inc
>cd56		69 6e 63					.text "inc"
.cd59						nt_asm_inc_a:
>cd59		05 0c						.byte 5, IM+NN
>cd5b		66 cd				                .word nt_asm_inc_x
>cd5d		1c a9 21 a9					.word xt_asm_inc_a, z_asm_inc_a
>cd61		69 6e 63 2e 61					.text "inc.a"
.cd66						nt_asm_inc_x:
>cd66		05 0c						.byte 5, IM+NN
>cd68		73 cd				                .word nt_asm_inc_z
>cd6a		21 a9 26 a9					.word xt_asm_inc_x, z_asm_inc_x
>cd6e		69 6e 63 2e 78					.text "inc.x"
.cd73						nt_asm_inc_z:
>cd73		05 0c						.byte 5, IM+NN
>cd75		80 cd				                .word nt_asm_inc_zx
>cd77		26 a9 2b a9					.word xt_asm_inc_z, z_asm_inc_z
>cd7b		69 6e 63 2e 7a					.text "inc.z"
.cd80						nt_asm_inc_zx:
>cd80		06 0c						.byte 6, IM+NN
>cd82		8e cd				                .word nt_asm_inx
>cd84		2b a9 30 a9					.word xt_asm_inc_zx, z_asm_inc_zx
>cd88		69 6e 63 2e 7a 78				.text "inc.zx"
.cd8e						nt_asm_inx:
>cd8e		03 0c						.byte 3, IM+NN
>cd90		99 cd				                .word nt_asm_iny
>cd92		30 a9 35 a9					.word xt_asm_inx, z_asm_inx
>cd96		69 6e 78					.text "inx"
.cd99						nt_asm_iny:
>cd99		03 0c						.byte 3, IM+NN
>cd9b		a4 cd				                .word nt_asm_jmp
>cd9d		35 a9 3a a9					.word xt_asm_iny, z_asm_iny
>cda1		69 6e 79					.text "iny"
.cda4						nt_asm_jmp:
>cda4		03 0c						.byte 3, IM+NN
>cda6		af cd				                .word nt_asm_jmp_i
>cda8		3a a9 3f a9					.word xt_asm_jmp, z_asm_jmp
>cdac		6a 6d 70					.text "jmp"
.cdaf						nt_asm_jmp_i:
>cdaf		05 0c						.byte 5, IM+NN
>cdb1		bc cd				                .word nt_asm_jmp_xi
>cdb3		3f a9 44 a9					.word xt_asm_jmp_i, z_asm_jmp_i
>cdb7		6a 6d 70 2e 69					.text "jmp.i"
.cdbc						nt_asm_jmp_xi:
>cdbc		06 0c						.byte 6, IM+NN
>cdbe		ca cd				                .word nt_asm_jsr
>cdc0		44 a9 49 a9					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cdc4		6a 6d 70 2e 78 69				.text "jmp.xi"
.cdca						nt_asm_jsr:
>cdca		03 0c						.byte 3, IM+NN
>cdcc		d5 cd				                .word nt_asm_lda
>cdce		49 a9 4e a9					.word xt_asm_jsr, z_asm_jsr
>cdd2		6a 73 72					.text "jsr"
.cdd5						nt_asm_lda:
>cdd5		03 0c						.byte 3, IM+NN
>cdd7		e0 cd				                .word nt_asm_lda_h
>cdd9		4e a9 53 a9					.word xt_asm_lda, z_asm_lda
>cddd		6c 64 61					.text "lda"
.cde0						nt_asm_lda_h:
>cde0		05 0c						.byte 5, IM+NN
>cde2		ed cd				                .word nt_asm_lda_x
>cde4		53 a9 58 a9					.word xt_asm_lda_h, z_asm_lda_h
>cde8		6c 64 61 2e 23					.text "lda.#"
.cded						nt_asm_lda_x:
>cded		05 0c						.byte 5, IM+NN
>cdef		fa cd				                .word nt_asm_lda_y
>cdf1		58 a9 5d a9					.word xt_asm_lda_x, z_asm_lda_x
>cdf5		6c 64 61 2e 78					.text "lda.x"
.cdfa						nt_asm_lda_y:
>cdfa		05 0c						.byte 5, IM+NN
>cdfc		07 ce				                .word nt_asm_lda_z
>cdfe		5d a9 62 a9					.word xt_asm_lda_y, z_asm_lda_y
>ce02		6c 64 61 2e 79					.text "lda.y"
.ce07						nt_asm_lda_z:
>ce07		05 0c						.byte 5, IM+NN
>ce09		14 ce				                .word nt_asm_lda_zi
>ce0b		62 a9 67 a9					.word xt_asm_lda_z, z_asm_lda_z
>ce0f		6c 64 61 2e 7a					.text "lda.z"
.ce14						nt_asm_lda_zi:
>ce14		06 0c						.byte 6, IM+NN
>ce16		22 ce				                .word nt_asm_lda_ziy
>ce18		67 a9 6c a9					.word xt_asm_lda_zi, z_asm_lda_zi
>ce1c		6c 64 61 2e 7a 69				.text "lda.zi"
.ce22						nt_asm_lda_ziy:
>ce22		07 0c						.byte 7, IM+NN
>ce24		31 ce				                .word nt_asm_lda_zx
>ce26		6c a9 71 a9					.word xt_asm_lda_ziy, z_asm_lda_ziy
>ce2a		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.ce31						nt_asm_lda_zx:
>ce31		06 0c						.byte 6, IM+NN
>ce33		3f ce				                .word nt_asm_lda_zxi
>ce35		71 a9 76 a9					.word xt_asm_lda_zx, z_asm_lda_zx
>ce39		6c 64 61 2e 7a 78				.text "lda.zx"
.ce3f						nt_asm_lda_zxi:
>ce3f		07 0c						.byte 7, IM+NN
>ce41		4e ce				                .word nt_asm_ldx
>ce43		76 a9 7b a9					.word xt_asm_lda_zxi, z_asm_lda_zxi
>ce47		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.ce4e						nt_asm_ldx:
>ce4e		03 0c						.byte 3, IM+NN
>ce50		59 ce				                .word nt_asm_ldx_h
>ce52		7b a9 80 a9					.word xt_asm_ldx, z_asm_ldx
>ce56		6c 64 78					.text "ldx"
.ce59						nt_asm_ldx_h:
>ce59		05 0c						.byte 5, IM+NN
>ce5b		66 ce				                .word nt_asm_ldx_y
>ce5d		80 a9 85 a9					.word xt_asm_ldx_h, z_asm_ldx_h
>ce61		6c 64 78 2e 23					.text "ldx.#"
.ce66						nt_asm_ldx_y:
>ce66		05 0c						.byte 5, IM+NN
>ce68		73 ce				                .word nt_asm_ldx_z
>ce6a		85 a9 8a a9					.word xt_asm_ldx_y, z_asm_ldx_y
>ce6e		6c 64 78 2e 79					.text "ldx.y"
.ce73						nt_asm_ldx_z:
>ce73		05 0c						.byte 5, IM+NN
>ce75		80 ce				                .word nt_asm_ldx_zy
>ce77		8a a9 8f a9					.word xt_asm_ldx_z, z_asm_ldx_z
>ce7b		6c 64 78 2e 7a					.text "ldx.z"
.ce80						nt_asm_ldx_zy:
>ce80		06 0c						.byte 6, IM+NN
>ce82		8e ce				                .word nt_asm_ldy
>ce84		8f a9 94 a9					.word xt_asm_ldx_zy, z_asm_ldx_zy
>ce88		6c 64 78 2e 7a 79				.text "ldx.zy"
.ce8e						nt_asm_ldy:
>ce8e		03 0c						.byte 3, IM+NN
>ce90		99 ce				                .word nt_asm_ldy_h
>ce92		94 a9 99 a9					.word xt_asm_ldy, z_asm_ldy
>ce96		6c 64 79					.text "ldy"
.ce99						nt_asm_ldy_h:
>ce99		05 0c						.byte 5, IM+NN
>ce9b		a6 ce				                .word nt_asm_ldy_x
>ce9d		99 a9 9e a9					.word xt_asm_ldy_h, z_asm_ldy_h
>cea1		6c 64 79 2e 23					.text "ldy.#"
.cea6						nt_asm_ldy_x:
>cea6		05 0c						.byte 5, IM+NN
>cea8		b3 ce				                .word nt_asm_ldy_z
>ceaa		9e a9 a3 a9					.word xt_asm_ldy_x, z_asm_ldy_x
>ceae		6c 64 79 2e 78					.text "ldy.x"
.ceb3						nt_asm_ldy_z:
>ceb3		05 0c						.byte 5, IM+NN
>ceb5		c0 ce				                .word nt_asm_ldy_zx
>ceb7		a3 a9 a8 a9					.word xt_asm_ldy_z, z_asm_ldy_z
>cebb		6c 64 79 2e 7a					.text "ldy.z"
.cec0						nt_asm_ldy_zx:
>cec0		06 0c						.byte 6, IM+NN
>cec2		ce ce				                .word nt_asm_lsr
>cec4		a8 a9 ad a9					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cec8		6c 64 79 2e 7a 78				.text "ldy.zx"
.cece						nt_asm_lsr:
>cece		03 0c						.byte 3, IM+NN
>ced0		d9 ce				                .word nt_asm_lsr_a
>ced2		ad a9 b2 a9					.word xt_asm_lsr, z_asm_lsr
>ced6		6c 73 72					.text "lsr"
.ced9						nt_asm_lsr_a:
>ced9		05 0c						.byte 5, IM+NN
>cedb		e6 ce				                .word nt_asm_lsr_x
>cedd		b2 a9 b7 a9					.word xt_asm_lsr_a, z_asm_lsr_a
>cee1		6c 73 72 2e 61					.text "lsr.a"
.cee6						nt_asm_lsr_x:
>cee6		05 0c						.byte 5, IM+NN
>cee8		f3 ce				                .word nt_asm_lsr_z
>ceea		b7 a9 bc a9					.word xt_asm_lsr_x, z_asm_lsr_x
>ceee		6c 73 72 2e 78					.text "lsr.x"
.cef3						nt_asm_lsr_z:
>cef3		05 0c						.byte 5, IM+NN
>cef5		00 cf				                .word nt_asm_lsr_zx
>cef7		bc a9 c1 a9					.word xt_asm_lsr_z, z_asm_lsr_z
>cefb		6c 73 72 2e 7a					.text "lsr.z"
.cf00						nt_asm_lsr_zx:
>cf00		06 0c						.byte 6, IM+NN
>cf02		0e cf				                .word nt_asm_nop
>cf04		c1 a9 c6 a9					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cf08		6c 73 72 2e 7a 78				.text "lsr.zx"
.cf0e						nt_asm_nop:
>cf0e		03 0c						.byte 3, IM+NN
>cf10		19 cf				                .word nt_asm_ora
>cf12		c6 a9 cb a9					.word xt_asm_nop, z_asm_nop
>cf16		6e 6f 70					.text "nop"
.cf19						nt_asm_ora:
>cf19		03 0c						.byte 3, IM+NN
>cf1b		24 cf				                .word nt_asm_ora_h
>cf1d		cb a9 d0 a9					.word xt_asm_ora, z_asm_ora
>cf21		6f 72 61					.text "ora"
.cf24						nt_asm_ora_h:
>cf24		05 0c						.byte 5, IM+NN
>cf26		31 cf				                .word nt_asm_ora_x
>cf28		d0 a9 d5 a9					.word xt_asm_ora_h, z_asm_ora_h
>cf2c		6f 72 61 2e 23					.text "ora.#"
.cf31						nt_asm_ora_x:
>cf31		05 0c						.byte 5, IM+NN
>cf33		3e cf				                .word nt_asm_ora_y
>cf35		d5 a9 da a9					.word xt_asm_ora_x, z_asm_ora_x
>cf39		6f 72 61 2e 78					.text "ora.x"
.cf3e						nt_asm_ora_y:
>cf3e		05 0c						.byte 5, IM+NN
>cf40		4b cf				                .word nt_asm_ora_z
>cf42		da a9 df a9					.word xt_asm_ora_y, z_asm_ora_y
>cf46		6f 72 61 2e 79					.text "ora.y"
.cf4b						nt_asm_ora_z:
>cf4b		05 0c						.byte 5, IM+NN
>cf4d		58 cf				                .word nt_asm_ora_zi
>cf4f		df a9 e4 a9					.word xt_asm_ora_z, z_asm_ora_z
>cf53		6f 72 61 2e 7a					.text "ora.z"
.cf58						nt_asm_ora_zi:
>cf58		06 0c						.byte 6, IM+NN
>cf5a		66 cf				                .word nt_asm_ora_ziy
>cf5c		e4 a9 eb a9					.word xt_asm_ora_zi, z_asm_ora_zi
>cf60		6f 72 61 2e 7a 69				.text "ora.zi"
.cf66						nt_asm_ora_ziy:
>cf66		07 0c						.byte 7, IM+NN
>cf68		75 cf				                .word nt_asm_ora_zx
>cf6a		eb a9 f0 a9					.word xt_asm_ora_ziy, z_asm_ora_ziy
>cf6e		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.cf75						nt_asm_ora_zx:
>cf75		06 0c						.byte 6, IM+NN
>cf77		83 cf				                .word nt_asm_ora_zxi
>cf79		f0 a9 f5 a9					.word xt_asm_ora_zx, z_asm_ora_zx
>cf7d		6f 72 61 2e 7a 78				.text "ora.zx"
.cf83						nt_asm_ora_zxi:
>cf83		07 0c						.byte 7, IM+NN
>cf85		92 cf				                .word nt_asm_pha
>cf87		f5 a9 fa a9					.word xt_asm_ora_zxi, z_asm_ora_zxi
>cf8b		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.cf92						nt_asm_pha:
>cf92		03 0c						.byte 3, IM+NN
>cf94		9d cf				                .word nt_asm_php
>cf96		fa a9 ff a9					.word xt_asm_pha, z_asm_pha
>cf9a		70 68 61					.text "pha"
.cf9d						nt_asm_php:
>cf9d		03 0c						.byte 3, IM+NN
>cf9f		a8 cf				                .word nt_asm_phx
>cfa1		ff a9 04 aa					.word xt_asm_php, z_asm_php
>cfa5		70 68 70					.text "php"
.cfa8						nt_asm_phx:
>cfa8		03 0c						.byte 3, IM+NN
>cfaa		b3 cf				                .word nt_asm_phy
>cfac		04 aa 09 aa					.word xt_asm_phx, z_asm_phx
>cfb0		70 68 78					.text "phx"
.cfb3						nt_asm_phy:
>cfb3		03 0c						.byte 3, IM+NN
>cfb5		be cf				                .word nt_asm_pla
>cfb7		09 aa 0e aa					.word xt_asm_phy, z_asm_phy
>cfbb		70 68 79					.text "phy"
.cfbe						nt_asm_pla:
>cfbe		03 0c						.byte 3, IM+NN
>cfc0		c9 cf				                .word nt_asm_plp
>cfc2		0e aa 13 aa					.word xt_asm_pla, z_asm_pla
>cfc6		70 6c 61					.text "pla"
.cfc9						nt_asm_plp:
>cfc9		03 0c						.byte 3, IM+NN
>cfcb		d4 cf				                .word nt_asm_plx
>cfcd		13 aa 18 aa					.word xt_asm_plp, z_asm_plp
>cfd1		70 6c 70					.text "plp"
.cfd4						nt_asm_plx:
>cfd4		03 0c						.byte 3, IM+NN
>cfd6		df cf				                .word nt_asm_ply
>cfd8		18 aa 1d aa					.word xt_asm_plx, z_asm_plx
>cfdc		70 6c 78					.text "plx"
.cfdf						nt_asm_ply:
>cfdf		03 0c						.byte 3, IM+NN
>cfe1		ea cf				                .word nt_asm_rol
>cfe3		1d aa 22 aa					.word xt_asm_ply, z_asm_ply
>cfe7		70 6c 79					.text "ply"
.cfea						nt_asm_rol:
>cfea		03 0c						.byte 3, IM+NN
>cfec		f5 cf				                .word nt_asm_rol_a
>cfee		22 aa 27 aa					.word xt_asm_rol, z_asm_rol
>cff2		72 6f 6c					.text "rol"
.cff5						nt_asm_rol_a:
>cff5		05 0c						.byte 5, IM+NN
>cff7		02 d0				                .word nt_asm_rol_x
>cff9		27 aa 2c aa					.word xt_asm_rol_a, z_asm_rol_a
>cffd		72 6f 6c 2e 61					.text "rol.a"
.d002						nt_asm_rol_x:
>d002		05 0c						.byte 5, IM+NN
>d004		0f d0				                .word nt_asm_rol_z
>d006		2c aa 31 aa					.word xt_asm_rol_x, z_asm_rol_x
>d00a		72 6f 6c 2e 78					.text "rol.x"
.d00f						nt_asm_rol_z:
>d00f		05 0c						.byte 5, IM+NN
>d011		1c d0				                .word nt_asm_rol_zx
>d013		31 aa 36 aa					.word xt_asm_rol_z, z_asm_rol_z
>d017		72 6f 6c 2e 7a					.text "rol.z"
.d01c						nt_asm_rol_zx:
>d01c		06 0c						.byte 6, IM+NN
>d01e		2a d0				                .word nt_asm_ror
>d020		36 aa 3b aa					.word xt_asm_rol_zx, z_asm_rol_zx
>d024		72 6f 6c 2e 7a 78				.text "rol.zx"
.d02a						nt_asm_ror:
>d02a		03 0c						.byte 3, IM+NN
>d02c		35 d0				                .word nt_asm_ror_a
>d02e		3b aa 40 aa					.word xt_asm_ror, z_asm_ror
>d032		72 6f 72					.text "ror"
.d035						nt_asm_ror_a:
>d035		05 0c						.byte 5, IM+NN
>d037		42 d0				                .word nt_asm_ror_x
>d039		40 aa 45 aa					.word xt_asm_ror_a, z_asm_ror_a
>d03d		72 6f 72 2e 61					.text "ror.a"
.d042						nt_asm_ror_x:
>d042		05 0c						.byte 5, IM+NN
>d044		4f d0				                .word nt_asm_ror_z
>d046		45 aa 4a aa					.word xt_asm_ror_x, z_asm_ror_x
>d04a		72 6f 72 2e 78					.text "ror.x"
.d04f						nt_asm_ror_z:
>d04f		05 0c						.byte 5, IM+NN
>d051		5c d0				                .word nt_asm_ror_zx
>d053		4a aa 4f aa					.word xt_asm_ror_z, z_asm_ror_z
>d057		72 6f 72 2e 7a					.text "ror.z"
.d05c						nt_asm_ror_zx:
>d05c		06 0c						.byte 6, IM+NN
>d05e		6a d0				                .word nt_asm_rti
>d060		4f aa 54 aa					.word xt_asm_ror_zx, z_asm_ror_zx
>d064		72 6f 72 2e 7a 78				.text "ror.zx"
.d06a						nt_asm_rti:
>d06a		03 0c						.byte 3, IM+NN
>d06c		75 d0				                .word nt_asm_rts
>d06e		54 aa 59 aa					.word xt_asm_rti, z_asm_rti
>d072		72 74 69					.text "rti"
.d075						nt_asm_rts:
>d075		03 0c						.byte 3, IM+NN
>d077		80 d0				                .word nt_asm_sbc
>d079		59 aa 5e aa					.word xt_asm_rts, z_asm_rts
>d07d		72 74 73					.text "rts"
.d080						nt_asm_sbc:
>d080		03 0c						.byte 3, IM+NN
>d082		8b d0				                .word nt_asm_sbc_h
>d084		5e aa 63 aa					.word xt_asm_sbc, z_asm_sbc
>d088		73 62 63					.text "sbc"
.d08b						nt_asm_sbc_h:
>d08b		05 0c						.byte 5, IM+NN
>d08d		98 d0				                .word nt_asm_sbc_x
>d08f		63 aa 68 aa					.word xt_asm_sbc_h, z_asm_sbc_h
>d093		73 62 63 2e 23					.text "sbc.#"
.d098						nt_asm_sbc_x:
>d098		05 0c						.byte 5, IM+NN
>d09a		a5 d0				                .word nt_asm_sbc_y
>d09c		68 aa 6d aa					.word xt_asm_sbc_x, z_asm_sbc_x
>d0a0		73 62 63 2e 78					.text "sbc.x"
.d0a5						nt_asm_sbc_y:
>d0a5		05 0c						.byte 5, IM+NN
>d0a7		b2 d0				                .word nt_asm_sbc_z
>d0a9		6d aa 72 aa					.word xt_asm_sbc_y, z_asm_sbc_y
>d0ad		73 62 63 2e 79					.text "sbc.y"
.d0b2						nt_asm_sbc_z:
>d0b2		05 0c						.byte 5, IM+NN
>d0b4		bf d0				                .word nt_asm_sbc_zi
>d0b6		72 aa 77 aa					.word xt_asm_sbc_z, z_asm_sbc_z
>d0ba		73 62 63 2e 7a					.text "sbc.z"
.d0bf						nt_asm_sbc_zi:
>d0bf		06 0c						.byte 6, IM+NN
>d0c1		cd d0				                .word nt_asm_sbc_ziy
>d0c3		77 aa 7c aa					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d0c7		73 62 63 2e 7a 69				.text "sbc.zi"
.d0cd						nt_asm_sbc_ziy:
>d0cd		07 0c						.byte 7, IM+NN
>d0cf		dc d0				                .word nt_asm_sbc_zx
>d0d1		7c aa 81 aa					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d0d5		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d0dc						nt_asm_sbc_zx:
>d0dc		06 0c						.byte 6, IM+NN
>d0de		ea d0				                .word nt_asm_sbc_zxi
>d0e0		81 aa 86 aa					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d0e4		73 62 63 2e 7a 78				.text "sbc.zx"
.d0ea						nt_asm_sbc_zxi:
>d0ea		07 0c						.byte 7, IM+NN
>d0ec		f9 d0				                .word nt_asm_sec
>d0ee		86 aa 8a aa					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d0f2		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d0f9						nt_asm_sec:
>d0f9		03 0c						.byte 3, IM+NN
>d0fb		04 d1				                .word nt_asm_sed
>d0fd		8a aa 8e aa					.word xt_asm_sec, z_asm_sec
>d101		73 65 63					.text "sec"
.d104						nt_asm_sed:
>d104		03 0c						.byte 3, IM+NN
>d106		0f d1				                .word nt_asm_sei
>d108		8e aa 92 aa					.word xt_asm_sed, z_asm_sed
>d10c		73 65 64					.text "sed"
.d10f						nt_asm_sei:
>d10f		03 0c						.byte 3, IM+NN
>d111		1a d1				                .word nt_asm_sta
>d113		92 aa 96 aa					.word xt_asm_sei, z_asm_sei
>d117		73 65 69					.text "sei"
.d11a						nt_asm_sta:
>d11a		03 0c						.byte 3, IM+NN
>d11c		25 d1				                .word nt_asm_sta_x
>d11e		96 aa 9a aa					.word xt_asm_sta, z_asm_sta
>d122		73 74 61					.text "sta"
.d125						nt_asm_sta_x:
>d125		05 0c						.byte 5, IM+NN
>d127		32 d1				                .word nt_asm_sta_y
>d129		9a aa 9e aa					.word xt_asm_sta_x, z_asm_sta_x
>d12d		73 74 61 2e 78					.text "sta.x"
.d132						nt_asm_sta_y:
>d132		05 0c						.byte 5, IM+NN
>d134		3f d1				                .word nt_asm_sta_z
>d136		9e aa a2 aa					.word xt_asm_sta_y, z_asm_sta_y
>d13a		73 74 61 2e 79					.text "sta.y"
.d13f						nt_asm_sta_z:
>d13f		05 0c						.byte 5, IM+NN
>d141		4c d1				                .word nt_asm_sta_zi
>d143		a2 aa a6 aa					.word xt_asm_sta_z, z_asm_sta_z
>d147		73 74 61 2e 7a					.text "sta.z"
.d14c						nt_asm_sta_zi:
>d14c		06 0c						.byte 6, IM+NN
>d14e		5a d1				                .word nt_asm_sta_ziy
>d150		a6 aa aa aa					.word xt_asm_sta_zi, z_asm_sta_zi
>d154		73 74 61 2e 7a 69				.text "sta.zi"
.d15a						nt_asm_sta_ziy:
>d15a		07 0c						.byte 7, IM+NN
>d15c		69 d1				                .word nt_asm_sta_zx
>d15e		aa aa ae aa					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d162		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d169						nt_asm_sta_zx:
>d169		06 0c						.byte 6, IM+NN
>d16b		77 d1				                .word nt_asm_sta_zxi
>d16d		ae aa b2 aa					.word xt_asm_sta_zx, z_asm_sta_zx
>d171		73 74 61 2e 7a 78				.text "sta.zx"
.d177						nt_asm_sta_zxi:
>d177		07 0c						.byte 7, IM+NN
>d179		86 d1				                .word nt_asm_stx
>d17b		b2 aa b6 aa					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d17f		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d186						nt_asm_stx:
>d186		03 0c						.byte 3, IM+NN
>d188		91 d1				                .word nt_asm_stx_z
>d18a		b6 aa ba aa					.word xt_asm_stx, z_asm_stx
>d18e		73 74 78					.text "stx"
.d191						nt_asm_stx_z:
>d191		05 0c						.byte 5, IM+NN
>d193		9e d1				                .word nt_asm_stx_zy
>d195		ba aa be aa					.word xt_asm_stx_z, z_asm_stx_z
>d199		73 74 78 2e 7a					.text "stx.z"
.d19e						nt_asm_stx_zy:
>d19e		06 0c						.byte 6, IM+NN
>d1a0		ac d1				                .word nt_asm_sty
>d1a2		be aa c2 aa					.word xt_asm_stx_zy, z_asm_stx_zy
>d1a6		73 74 78 2e 7a 79				.text "stx.zy"
.d1ac						nt_asm_sty:
>d1ac		03 0c						.byte 3, IM+NN
>d1ae		b7 d1				                .word nt_asm_sty_z
>d1b0		c2 aa c6 aa					.word xt_asm_sty, z_asm_sty
>d1b4		73 74 79					.text "sty"
.d1b7						nt_asm_sty_z:
>d1b7		05 0c						.byte 5, IM+NN
>d1b9		c4 d1				                .word nt_asm_sty_zx
>d1bb		c6 aa ca aa					.word xt_asm_sty_z, z_asm_sty_z
>d1bf		73 74 79 2e 7a					.text "sty.z"
.d1c4						nt_asm_sty_zx:
>d1c4		06 0c						.byte 6, IM+NN
>d1c6		d2 d1				                .word nt_asm_stz
>d1c8		ca aa ce aa					.word xt_asm_sty_zx, z_asm_sty_zx
>d1cc		73 74 79 2e 7a 78				.text "sty.zx"
.d1d2						nt_asm_stz:
>d1d2		03 0c						.byte 3, IM+NN
>d1d4		dd d1				                .word nt_asm_stz_x
>d1d6		ce aa d2 aa					.word xt_asm_stz, z_asm_stz
>d1da		73 74 7a					.text "stz"
.d1dd						nt_asm_stz_x:
>d1dd		05 0c						.byte 5, IM+NN
>d1df		ea d1				                .word nt_asm_stz_z
>d1e1		d2 aa d6 aa					.word xt_asm_stz_x, z_asm_stz_x
>d1e5		73 74 7a 2e 78					.text "stz.x"
.d1ea						nt_asm_stz_z:
>d1ea		05 0c						.byte 5, IM+NN
>d1ec		f7 d1				                .word nt_asm_stz_zx
>d1ee		d6 aa da aa					.word xt_asm_stz_z, z_asm_stz_z
>d1f2		73 74 7a 2e 7a					.text "stz.z"
.d1f7						nt_asm_stz_zx:
>d1f7		06 0c						.byte 6, IM+NN
>d1f9		05 d2				                .word nt_asm_tax
>d1fb		da aa de aa					.word xt_asm_stz_zx, z_asm_stz_zx
>d1ff		73 74 7a 2e 7a 78				.text "stz.zx"
.d205						nt_asm_tax:
>d205		03 0c						.byte 3, IM+NN
>d207		10 d2				                .word nt_asm_tay
>d209		de aa e2 aa					.word xt_asm_tax, z_asm_tax
>d20d		74 61 78					.text "tax"
.d210						nt_asm_tay:
>d210		03 0c						.byte 3, IM+NN
>d212		1b d2				                .word nt_asm_trb
>d214		e2 aa e6 aa					.word xt_asm_tay, z_asm_tay
>d218		74 61 79					.text "tay"
.d21b						nt_asm_trb:
>d21b		03 0c						.byte 3, IM+NN
>d21d		26 d2				                .word nt_asm_trb_z
>d21f		e6 aa ea aa					.word xt_asm_trb, z_asm_trb
>d223		74 72 62					.text "trb"
.d226						nt_asm_trb_z:
>d226		05 0c						.byte 5, IM+NN
>d228		33 d2				                .word nt_asm_tsb
>d22a		ea aa ee aa					.word xt_asm_trb_z, z_asm_trb_z
>d22e		74 72 62 2e 7a					.text "trb.z"
.d233						nt_asm_tsb:
>d233		03 0c						.byte 3, IM+NN
>d235		3e d2				                .word nt_asm_tsb_z
>d237		ee aa f2 aa					.word xt_asm_tsb, z_asm_tsb
>d23b		74 73 62					.text "tsb"
.d23e						nt_asm_tsb_z:
>d23e		05 0c						.byte 5, IM+NN
>d240		4b d2				                .word nt_asm_tsx
>d242		f2 aa f6 aa					.word xt_asm_tsb_z, z_asm_tsb_z
>d246		74 73 62 2e 7a					.text "tsb.z"
.d24b						nt_asm_tsx:
>d24b		03 0c						.byte 3, IM+NN
>d24d		56 d2				                .word nt_asm_txa
>d24f		f6 aa fa aa					.word xt_asm_tsx, z_asm_tsx
>d253		74 73 78					.text "tsx"
.d256						nt_asm_txa:
>d256		03 0c						.byte 3, IM+NN
>d258		61 d2				                .word nt_asm_txs
>d25a		fa aa fe aa					.word xt_asm_txa, z_asm_txa
>d25e		74 78 61					.text "txa"
.d261						nt_asm_txs:
>d261		03 0c						.byte 3, IM+NN
>d263		6c d2				                .word nt_asm_tya
>d265		fe aa 02 ab					.word xt_asm_txs, z_asm_txs
>d269		74 78 73					.text "txs"
.d26c						nt_asm_tya:
>d26c		03 0c						.byte 3, IM+NN
>d26e		77 d2				                .word nt_asm_arrow
>d270		02 ab 06 ab					.word xt_asm_tya, z_asm_tya
>d274		74 79 61					.text "tya"
.d277						nt_asm_arrow:
>d277		03 04				                .byte 3, IM
>d279		82 d2				                .word nt_asm_back_jump
>d27b		88 90 92 90			                .word xt_asm_arrow, z_asm_arrow
>d27f		2d 2d 3e			                .text "-->"
.d282						nt_asm_back_jump:
>d282		02 04				                .byte 2, IM
>d284		8c d2				                .word nt_asm_back_branch
>d286		57 ab 57 ab			                .word xt_asm_back_jump, z_asm_back_jump
>d28a		3c 6a				                .text "<j"
.d28c						nt_asm_back_branch:
>d28c		02 04				                .byte 2, IM
>d28e		96 d2				                .word nt_asm_push_a
>d290		58 ab 60 ab			                .word xt_asm_back_branch, z_asm_back_branch
>d294		3c 62				                .text "<b"
.d296						nt_asm_push_a:
>d296		06 0c				                .byte 6, IM+NN
>d298		00 00				                .word 0000
>d29a		40 ab 4f ab			                .word xt_asm_push_a, z_asm_push_a
>d29e		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix
=1						ix += 1
=1						str_compile        = ix
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_sdc     = ix
=14						ix += 1
=14						str_disasm_bra     = ix
=15						ix += 1
=15						str_disasm_0test   = ix
=16						ix += 1
.d2a4						string_table:
>d2a4		c4 d2 c8 d2 d2 d2 dd d2		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d2ac		14 d3 0c d3 01 d3 1b d3		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d2b4		21 d3 3d d3 42 d3 47 d3		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d2bc		58 d3 61 d3 73 d3 7b d3		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra, s_disasm_0test ; 12-15
>d2c4		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d2c8		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d2d0		64 00
>d2d2		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d2da		64 20 00
>d2dd		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d2e5		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d2f5		4f 50 51 52 53 54 55 56 57 58 59 5a
>d301		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d309		72 20 00
>d30c		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d314		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d31b		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d321		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d329		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d339		29 3a 20 00
>d33d		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d342		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d347		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d34f		63 69 6d 61 6c 29 3a 20 00
>d358		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d360		00
>d361		53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d369		50 54 48 20 43 48 45 43 4b 00
>d373		42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
>d37b		30 54 45 53 54 00		s_disasm_0test: .text "0TEST",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d381						error_table:
>d381		9d d3 be d3 de d3 ff d3		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d389		1c d4 2d d4 3d d4 6b d4		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d391		83 d4 a4 d4 b9 d4 d5 d4		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d399		ec d4 2b d5			        .word es_blockwords, es_returnstack                     ; 12-13
>d39d		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d3a5		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d3b5		65 20 6d 65 6d 6f 72 79 00
>d3be		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d3c6		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d3d6		20 52 45 46 49 4c 4c 00
>d3de		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d3e6		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d3f6		6e 6c 79 20 77 6f 72 64 00
>d3ff		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d407		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d417		20 79 65 74 00
>d41c		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d424		20 62 79 20 7a 65 72 6f 00
>d42d		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d435		66 61 69 6c 75 72 65 00
>d43d		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d445		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d455		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d465		64 20 2d 31 29 00
>d46b		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d473		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d483		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d48b		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d49b		64 20 6e 75 6d 62 65 72 00
>d4a4		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d4ac		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d4b9		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d4c1		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d4d1		4c 4f 54 00
>d4d5		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d4dd		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d4ec		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d4f4		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d504		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d514		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d524		56 45 43 54 4f 52 00
>d52b		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d533		74 61 63 6b 3a 00
>d539		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d541		44 2d 53 54 52 49 4e 47
>d549		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d54f		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d554		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d55c		2d 55 4e 49 54 2d 42 49 54 53
>d566		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d56e		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d576		52
>d577		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d57d		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d583		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d58b		53 54 41 43 4b 2d 43 45 4c 4c 53
>d596		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d59e		45 4c 4c 53
>d5a2		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d5aa		54 53
>d5ac		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d5b2		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d5b9						cmpl_subroutine:
.d5b9		48		pha		                pha             ; save LSB of address
.d5ba		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.d5bc		80 03		bra $d5c1	                bra +
.d5be						cmpl_jump:
.d5be		48		pha		                pha             ; save LSB of address
.d5bf		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.d5c1						+
.d5c1		20 c9 d5	jsr $d5c9	                jsr cmpl_a      ; compile opcode
.d5c4		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d5c5						cmpl_word:
.d5c5		20 c9 d5	jsr $d5c9	                jsr cmpl_a      ; compile LSB of address
.d5c8		98		tya		                tya             ; fall thru for MSB
.d5c9						cmpl_a:
.d5c9		92 00		sta ($00)	                sta (cp)
.d5cb		e6 00		inc $00		                inc cp
.d5cd		d0 02		bne $d5d1	                bne _done
.d5cf		e6 01		inc $01		                inc cp+1
.d5d1						_done:
.d5d1		60		rts		                rts
.d5d2						doconst:
.d5d2		ca		dex		                dex             ; make room for constant
.d5d3		ca		dex		                dex
.d5d4		68		pla		                pla             ; LSB of return address
.d5d5		85 25		sta $25		                sta tmp1
.d5d7		68		pla		                pla             ; MSB of return address
.d5d8		85 26		sta $26		                sta tmp1+1
.d5da		a0 01		ldy #$01	                ldy #1
.d5dc		b1 25		lda ($25),y	                lda (tmp1),y
.d5de		95 00		sta $00,x	                sta 0,x
.d5e0		c8		iny		                iny
.d5e1		b1 25		lda ($25),y	                lda (tmp1),y
.d5e3		95 01		sta $01,x	                sta 1,x
.d5e5		60		rts		                rts
.d5e6						dodefer:
.d5e6		68		pla		                pla             ; LSB
.d5e7		85 25		sta $25		                sta tmp1
.d5e9		68		pla		                pla             ; MSB
.d5ea		85 26		sta $26		                sta tmp1+1
.d5ec		a0 01		ldy #$01	                ldy #1
.d5ee		b1 25		lda ($25),y	                lda (tmp1),y
.d5f0		85 27		sta $27		                sta tmp2
.d5f2		c8		iny		                iny
.d5f3		b1 25		lda ($25),y	                lda (tmp1),y
.d5f5		85 28		sta $28		                sta tmp2+1
.d5f7		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d5fa						defer_error:
.d5fa		a9 03		lda #$03	                lda #err_defer
.d5fc		4c 92 d7	jmp $d792	                jmp error
.d5ff						dodoes:
.d5ff		7a		ply		                ply             ; LSB
.d600		68		pla		                pla             ; MSB
.d601		c8		iny		                iny
.d602		d0 01		bne $d605	                bne +
.d604		1a		inc a		                ina
.d605						+
.d605		84 27		sty $27		                sty tmp2
.d607		85 28		sta $28		                sta tmp2+1
.d609		ca		dex		                dex
.d60a		ca		dex		                dex
.d60b		7a		ply		                ply
.d60c		68		pla		                pla
.d60d		c8		iny		                iny
.d60e		d0 01		bne $d611	                bne +
.d610		1a		inc a		                ina
.d611						+
.d611		94 00		sty $00,x	                sty 0,x         ; LSB
.d613		95 01		sta $01,x	                sta 1,x         ; MSB
.d615		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d618						dovar:
.d618		7a		ply		                ply             ; LSB
.d619		68		pla		                pla             ; MSB
.d61a		c8		iny		                iny
.d61b		d0 01		bne $d61e	                bne +
.d61d		1a		inc a		                ina
.d61e						+
.d61e		ca		dex		                dex
.d61f		ca		dex		                dex
.d620		95 01		sta $01,x	                sta 1,x
.d622		98		tya		                tya
.d623		95 00		sta $00,x	                sta 0,x
.d625		60		rts		                rts
.d626						push_upvar_tos:
.d626		ca		dex		                dex
.d627		ca		dex		                dex
.d628		18		clc		                clc
.d629		65 08		adc $08		                adc up
.d62b		95 00		sta $00,x	                sta 0,x
.d62d		a5 09		lda $09		                lda up+1
.d62f		90 01		bcc $d632	                bcc +
.d631		1a		inc a		                ina
.d632						+
.d632		95 01		sta $01,x	                sta 1,x
.d634		60		rts		                rts
.d635						byte_to_ascii:
.d635		48		pha		                pha
.d636		4a		lsr a		                lsr             ; convert high nibble first
.d637		4a		lsr a		                lsr
.d638		4a		lsr a		                lsr
.d639		4a		lsr a		                lsr
.d63a		20 3e d6	jsr $d63e	                jsr _nibble_to_ascii
.d63d		68		pla		                pla
.d63e						_nibble_to_ascii:
.d63e		29 0f		and #$0f	                and #$F
.d640		09 30		ora #$30	                ora #'0'
.d642		c9 3a		cmp #$3a	                cmp #'9'+1
.d644		90 02		bcc $d648	                bcc +
.d646		69 06		adc #$06	                adc #6
.d648		4c 7b 8d	jmp $8d7b	+               jmp emit_a
.d64b		60		rts		                rts
.d64c						find_header_name:
.d64c		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d64e		85 27		sta $27		                sta tmp2
.d650		b5 03		lda $03,x	                lda 3,x
.d652		85 28		sta $28		                sta tmp2+1
.d654						_loop:
.d654		b2 25		lda ($25)	                lda (tmp1)
.d656		d5 00		cmp $00,x	                cmp 0,x
.d658		d0 3a		bne $d694	                bne _next_entry
.d65a		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d65c		a0 08		ldy #$08	                ldy #8
.d65e		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d660		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d662		d0 30		bne $d694	                bne _next_entry ; definitely not equal if any bits differ
.d664		a5 25		lda $25		                lda tmp1
.d666		48		pha		                pha             ; Save original address on the stack
.d667		18		clc		                clc
.d668		69 08		adc #$08	                adc #8
.d66a		85 25		sta $25		                sta tmp1
.d66c		a5 26		lda $26		                lda tmp1+1
.d66e		48		pha		                pha
.d66f		90 03		bcc $d674	                bcc +
.d671		1a		inc a		                ina
.d672		85 26		sta $26		                sta tmp1+1
.d674						+
.d674		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d676		88		dey		                dey
.d677						_next_char:
.d677		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d679		c9 5b		cmp #$5b	                cmp #'Z'+1
.d67b		b0 06		bcs $d683	                bcs _check_char
.d67d		c9 41		cmp #$41	                cmp #'A'
.d67f		90 02		bcc $d683	                bcc _check_char
.d681		09 20		ora #$20	                ora #$20
.d683						_check_char:
.d683		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d685		d0 03		bne $d68a	                bne _reset_tmp1
.d687		88		dey		                dey
.d688		10 ed		bpl $d677	                bpl _next_char
.d68a						_reset_tmp1:
.d68a		68		pla		                pla
.d68b		85 26		sta $26		                sta tmp1+1
.d68d		68		pla		                pla
.d68e		85 25		sta $25		                sta tmp1
.d690		98		tya		                tya             ; leave A = $FF on success
.d691		c8		iny		                iny             ; if Y was $FF, we succeeded
.d692		f0 11		beq $d6a5	                beq _done
.d694						_next_entry:
.d694		a0 02		ldy #$02	                ldy #2
.d696		b1 25		lda ($25),y	                lda (tmp1),y
.d698		48		pha		                pha
.d699		c8		iny		                iny
.d69a		b1 25		lda ($25),y	                lda (tmp1),y
.d69c		85 26		sta $26		                sta tmp1+1
.d69e		68		pla		                pla
.d69f		85 25		sta $25		                sta tmp1
.d6a1		05 26		ora $26		                ora tmp1+1
.d6a3		d0 af		bne $d654	                bne _loop
.d6a5		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d6a7		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d6a8						compare_16bit:
.d6a8		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d6aa		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d6ac		f0 0a		beq $d6b8	                beq _equal
.d6ae		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6b0		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6b2		09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d6b4		70 08		bvs $d6be	                bvs _overflow
.d6b6		80 08		bra $d6c0	                bra _not_equal
.d6b8						_equal:
.d6b8		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d6ba		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d6bc		50 04		bvc $d6c2	                bvc _done
.d6be						_overflow:
.d6be		49 80		eor #$80	                eor #$80                ; complement negative flag
.d6c0						_not_equal:
.d6c0		09 01		ora #$01	                ora #1                  ; if overflow, we can't be equal
.d6c2						_done:
.d6c2		60		rts		                rts
.d6c3						current_to_dp:
.d6c3		a0 08		ldy #$08	                ldy #current_offset
.d6c5		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6c7		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6c8		18		clc		                clc
.d6c9		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6cb		a8		tay		                tay
.d6cc		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d6ce		85 02		sta $02		                sta dp
.d6d0		c8		iny		                iny
.d6d1		b1 08		lda ($08),y	                lda (up),y
.d6d3		85 03		sta $03		                sta dp+1
.d6d5		60		rts		                rts
.d6d6						dp_to_current:
.d6d6		a0 08		ldy #$08	                ldy #current_offset
.d6d8		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d6da		0a		asl a		                asl             ; turn it into an offset (in cells)
.d6db		18		clc		                clc
.d6dc		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d6de		a8		tay		                tay
.d6df		a5 02		lda $02		                lda dp
.d6e1		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d6e3		c8		iny		                iny
.d6e4		a5 03		lda $03		                lda dp+1
.d6e6		91 08		sta ($08),y	                sta (up),y
.d6e8		60		rts		                rts
.d6e9						interpret:
.d6e9						_loop:
.d6e9		20 02 98	jsr $9802	                jsr xt_parse_name       ; ( "string" -- addr u )
.d6ec		b5 00		lda $00,x	                lda 0,x
.d6ee		15 01		ora $01,x	                ora 1,x
.d6f0		f0 6b		beq $d75d	                beq _line_done
.d6f2		20 e3 a1	jsr $a1e3	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d6f5		20 59 8f	jsr $8f59	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d6f8		b5 00		lda $00,x	                lda 0,x
.d6fa		15 01		ora $01,x	                ora 1,x
.d6fc		d0 28		bne $d726	                bne _got_name_token
.d6fe		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d6ff		e8		inx		                inx
.d700		20 b0 95	jsr $95b0	                jsr xt_number           ; ( addr u -- u|d )
.d703		a5 1a		lda $1a		                lda state
.d705		f0 e2		beq $d6e9	                beq _loop
.d707		a9 20		lda #$20	                lda #%00100000
.d709		24 1c		bit $1c		                bit status
.d70b		f0 0d		beq $d71a	                beq _single_number
.d70d		20 05 a0	jsr $a005	                jsr xt_swap
.d710		a0 92		ldy #$92	                ldy #>literal_runtime
.d712		a9 b6		lda #$b6	                lda #<literal_runtime
.d714		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.d717		20 de 86	jsr $86de	                jsr xt_comma
.d71a						_single_number:
.d71a		a0 92		ldy #$92	                ldy #>literal_runtime
.d71c		a9 b6		lda #$b6	                lda #<literal_runtime
.d71e		20 b9 d5	jsr $d5b9	                jsr cmpl_subroutine
.d721		20 de 86	jsr $86de	                jsr xt_comma
.d724		80 c3		bra $d6e9	                bra _loop
.d726						_got_name_token:
.d726		b5 00		lda $00,x	                lda 0,x
.d728		95 04		sta $04,x	                sta 4,x
.d72a		b5 01		lda $01,x	                lda 1,x
.d72c		95 05		sta $05,x	                sta 5,x
.d72e		e8		inx		                inx
.d72f		e8		inx		                inx
.d730		e8		inx		                inx
.d731		e8		inx		                inx                     ; ( nt )
.d732		20 40 97	jsr $9740	                jsr xt_one_plus
.d735		a1 00		lda ($00,x)	                lda (0,x)
.d737		48		pha		                pha
.d738		20 34 97	jsr $9734	                jsr xt_one_minus
.d73b		20 10 95	jsr $9510	                jsr xt_name_to_int      ; ( nt - xt )
.d73e		a5 1a		lda $1a		                lda state
.d740		d0 10		bne $d752	                bne _compile
.d742		68		pla		                pla
.d743		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d745		f0 05		beq $d74c	                beq _interpret
.d747		a9 02		lda #$02	                lda #err_compileonly
.d749		4c 92 d7	jmp $d792	                jmp error
.d74c						_interpret:
.d74c		20 c2 8e	jsr $8ec2	                jsr xt_execute
.d74f		4c e9 d6	jmp $d6e9	                jmp _loop
.d752						_compile:
.d752		68		pla		                pla
.d753		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d755		d0 f5		bne $d74c	                bne _interpret          ; IMMEDIATE word, execute right now
.d757		20 5d 87	jsr $875d	                jsr xt_compile_comma
.d75a		4c e9 d6	jmp $d6e9	                jmp _loop
.d75d						_line_done:
.d75d		e8		inx		                inx
.d75e		e8		inx		                inx
.d75f		e8		inx		                inx
.d760		e8		inx		                inx
.d761		60		rts		                rts
.d762						is_printable:
.d762		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d764		90 08		bcc $d76e	                bcc _done
.d766		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d768		b0 03		bcs $d76d	                bcs _failed
.d76a		38		sec		                sec
.d76b		80 01		bra $d76e	                bra _done
.d76d						_failed:
.d76d		18		clc		                clc
.d76e						_done:
.d76e		60		rts		                rts
.d76f						is_whitespace:
.d76f		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d771		90 08		bcc $d77b	                bcc _done
.d773		c9 21		cmp #$21	                cmp #AscSP+1
.d775		b0 03		bcs $d77a	                bcs _failed
.d777		38		sec		                sec
.d778		80 01		bra $d77b	                bra _done
.d77a						_failed:
.d77a		18		clc		                clc
.d77b						_done:
.d77b		60		rts		                rts
.d77c						underflow_1:
.d77c		e0 77		cpx #$77	                cpx #dsp0-1
.d77e		10 10		bpl $d790	                bpl underflow_error
.d780		60		rts		                rts
.d781						underflow_2:
.d781		e0 75		cpx #$75	                cpx #dsp0-3
.d783		10 0b		bpl $d790	                bpl underflow_error
.d785		60		rts		                rts
.d786						underflow_3:
.d786		e0 73		cpx #$73	                cpx #dsp0-5
.d788		10 06		bpl $d790	                bpl underflow_error
.d78a		60		rts		                rts
.d78b						underflow_4:
.d78b		e0 71		cpx #$71	                cpx #dsp0-7
.d78d		10 01		bpl $d790	                bpl underflow_error
.d78f		60		rts		                rts
.d790						underflow_error:
.d790		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d792						error:
.d792		48		pha		                pha                     ; save error
.d793		20 d2 d7	jsr $d7d2	                jsr print_error
.d796		20 d5 88	jsr $88d5	                jsr xt_cr
.d799		68		pla		                pla
.d79a		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d79c		d0 17		bne $d7b5	                bne _no_underflow
.d79e		a9 0d		lda #$0d	                lda #err_returnstack
.d7a0		20 d2 d7	jsr $d7d2	                jsr print_error
.d7a3		ba		tsx		                tsx
.d7a4						-
.d7a4		e8		inx		                inx
.d7a5		f0 0b		beq $d7b2	                beq +
.d7a7		20 7b 9f	jsr $9f7b	                jsr xt_space
.d7aa		bd 00 01	lda $0100,x	                lda $100,x
.d7ad		20 35 d6	jsr $d635	                jsr byte_to_ascii
.d7b0		80 f2		bra $d7a4	                bra -
.d7b2						+
.d7b2		20 d5 88	jsr $88d5	                jsr xt_cr
.d7b5						_no_underflow:
.d7b5		4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d7b8						print_string_no_lf:
.d7b8		0a		asl a		                asl
.d7b9		a8		tay		                tay
.d7ba		b9 a4 d2	lda $d2a4,y	                lda string_table,y
.d7bd		85 29		sta $29		                sta tmp3                ; LSB
.d7bf		c8		iny		                iny
.d7c0		b9 a4 d2	lda $d2a4,y	                lda string_table,y
.d7c3		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7c5						print_common:
.d7c5		a0 00		ldy #$00	                ldy #0
.d7c7						_loop:
.d7c7		b1 29		lda ($29),y	                lda (tmp3),y
.d7c9		f0 06		beq $d7d1	                beq _done               ; strings are zero-terminated
.d7cb		20 7b 8d	jsr $8d7b	                jsr emit_a              ; allows vectoring via output
.d7ce		c8		iny		                iny
.d7cf		80 f6		bra $d7c7	                bra _loop
.d7d1						_done:
.d7d1		60		rts		                rts
.d7d2						print_error:
.d7d2		0a		asl a		                asl
.d7d3		a8		tay		                tay
.d7d4		b9 81 d3	lda $d381,y	                lda error_table,y
.d7d7		85 29		sta $29		                sta tmp3                ; LSB
.d7d9		c8		iny		                iny
.d7da		b9 81 d3	lda $d381,y	                lda error_table,y
.d7dd		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d7df		20 c5 d7	jsr $d7c5	                jsr print_common
.d7e2		60		rts		                rts
.d7e3						print_string:
.d7e3		20 b8 d7	jsr $d7b8	                jsr print_string_no_lf
.d7e6		4c d5 88	jmp $88d5	                jmp xt_cr               ; JSR/RTS because never compiled
.d7e9						print_u:
.d7e9		20 e4 a5	jsr $a5e4	                jsr xt_zero                     ; 0
.d7ec		20 78 92	jsr $9278	                jsr xt_less_number_sign         ; <#
.d7ef		20 01 97	jsr $9701	                jsr xt_number_sign_s            ; #S
.d7f2		20 df 96	jsr $96df	                jsr xt_number_sign_greater      ; #>
.d7f5		4c 2e a3	jmp $a32e	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010						v_nmi:
.f010						v_reset:
.f010						v_irq:
.f010						kernel_init:
.f010		78		sei		                sei             ; Disable interrupts
.f011		a2 00		ldx #$00	                ldx #0
.f013		bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016		f0 06		beq $f01e	                beq _done
.f018		20 27 f0	jsr $f027	                jsr kernel_putc
.f01b		e8		inx		                inx
.f01c		80 f5		bra $f013	                bra -
.f01e						_done:
.f01e		4c 00 80	jmp $8000	                jmp forth
.f021						kernel_getc:
.f021						_loop:
.f021		ad 04 f0	lda $f004	                lda $f004
.f024		f0 fb		beq $f021	                beq _loop
.f026		60		rts		                rts
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta $f001
.f02a		60		rts		                rts
.f02b						platform_bye:
.f02b		00		brk #		                brk
.f02c						s_kernel_id:
>f02c		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		10 f0				.word v_nmi
>fffc		10 f0				.word v_reset
>fffe		10 f0				.word v_irq

;******  End of listing
