
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Tue Mar 26 21:02:31 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../native_words.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 10		sta $10		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 11		sta $11		                sta output+1
.8009		a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd c7 a8	lda $a8c7,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad c7 a8	lda $a8c7	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 31		ldy #$31	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 e9 a8	lda $a8e9,y	                lda cold_user_table,y
.8024		91 1e		sta ($1e),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad e9 a8	lda $a8e9	                lda cold_user_table
.802c		92 1e		sta ($1e)	                sta (up)
.802e		20 3a 89	jsr $893a	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 cc		lda #$cc	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 bb		lda #$bb	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 82		lda #$82	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 01		lda #$01	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 98 90	jsr $9098	                jsr xt_evaluate
.8048		80 0e		bra $8058	                bra _skip_turnkey
.804a						_turnkey:
.804a		78		sei		                sei
.804b		a2 76		ldx #$76	                ldx #dsp0-2
.804d		a5 7e		lda $7e		                lda turnkey
.804f		95 00		sta $00,x	                sta 0,x
.8051		a5 7f		lda $7f		                lda turnkey+1
.8053		95 01		sta $01,x	                sta 1,x
.8055		20 00 8f	jsr $8f00	                jsr xt_execute
.8058						_skip_turnkey:
.8058		9c 00 7c	stz $7c00	                stz hist_buff
.805b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.805e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8061		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8064		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8067		9c 80 7e	stz $7e80	                stz hist_buff+$280
.806a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.806d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8070						xt_abort:
.8070		a2 78		ldx #$78	                ldx #dsp0
.8072						xt_quit:
.8072		8a		txa		                txa             ; Save the DSP that we just defined
.8073		a2 ff		ldx #$ff	                ldx #rsp0
.8075		9a		txs		                txs
.8076		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8077		64 0e		stz $0e		                stz ip
.8079		64 0f		stz $0f		                stz ip+1
.807b		64 06		stz $06		                stz insrc
.807d		64 07		stz $07		                stz insrc+1
.807f		a9 00		lda #$00	                lda #0
.8081		a0 00		ldy #$00	                ldy #blk_offset
.8083		91 1e		sta ($1e),y	                sta (up),y
.8085		c8		iny		                iny
.8086		91 1e		sta ($1e),y	                sta (up),y
.8088		64 16		stz $16		                stz state
.808a		64 17		stz $17		                stz state+1
.808c						_get_line:
.808c		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.808e		85 08		sta $08		                sta cib
.8090		a9 02		lda #$02	                lda #>buffer0
.8092		85 09		sta $09		                sta cib+1
.8094		64 0a		stz $0a		                stz ciblen
.8096		64 0b		stz $0b		                stz ciblen+1
.8098		20 d1 9a	jsr $9ad1	                jsr xt_refill           ; ( -- f )
.809b		b5 00		lda $00,x	                lda 0,x
.809d		d0 05		bne $80a4	                bne _success
.809f		a9 06		lda #$06	                lda #err_refill
.80a1		4c 5d d9	jmp $d95d	                jmp error
.80a4						_success:
.80a4		e8		inx		                inx                     ; drop
.80a5		e8		inx		                inx
.80a6		20 a2 d8	jsr $d8a2	                jsr interpret
.80a9		e0 78		cpx #$78	                cpx #dsp0
.80ab		f0 05		beq $80b2	                beq _stack_ok
.80ad		90 03		bcc $80b2	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80af		4c 5b d9	jmp $d95b	                jmp underflow_error
.80b2						_stack_ok:
.80b2		a5 16		lda $16		                lda state
.80b4		f0 02		beq $80b8	                beq _print
.80b6		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80b8						_print:
.80b8		20 ae d9	jsr $d9ae	                jsr print_string
.80bb		80 cf		bra $808c	                bra _get_line
.80bd						z_cold:
.80bd						z_abort:
.80bd						z_quit:
.80bd						xt_abort_quote:
.80bd		20 28 9d	jsr $9d28	                jsr xt_s_quote          ; S"
.80c0		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80c2		a9 c8		lda #$c8	                lda #<abort_quote_runtime
.80c4		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80c7		60		rts		z_abort_quote:  rts
.80c8						abort_quote_runtime:
.80c8		b5 04		lda $04,x	                lda 4,x
.80ca		15 05		ora $05,x	                ora 5,x
.80cc		f0 09		beq $80d7	                beq _done       ; if FALSE, we're done
.80ce		20 ad a4	jsr $a4ad	                jsr xt_type
.80d1		20 3a 89	jsr $893a	                jsr xt_cr
.80d4		4c 70 80	jmp $8070	                jmp xt_abort    ; not JSR, so never come back
.80d7						_done:
.80d7		8a		txa		                txa
.80d8		18		clc		                clc
.80d9		69 06		adc #$06	                adc #6
.80db		aa		tax		                tax
.80dc		60		rts		                rts
.80dd						xt_abs:
.80dd		20 47 d9	jsr $d947	                jsr underflow_1
.80e0		b5 01		lda $01,x	                lda 1,x
.80e2		10 0d		bpl $80f1	                bpl _done       ; positive number, easy money!
.80e4		38		sec		                sec
.80e5		a9 00		lda #$00	                lda #0
.80e7		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80e9		95 00		sta $00,x	                sta 0,x
.80eb		a9 00		lda #$00	                lda #0          ; MSB
.80ed		f5 01		sbc $01,x	                sbc 1,x
.80ef		95 01		sta $01,x	                sta 1,x
.80f1						_done:
.80f1		60		rts		z_abs:          rts
.80f2						xt_accept:
.80f2		20 4c d9	jsr $d94c	                jsr underflow_2
.80f5		b5 00		lda $00,x	                lda 0,x
.80f7		15 01		ora $01,x	                ora 1,x
.80f9		d0 09		bne $8104	                bne _not_zero
.80fb		e8		inx		                inx
.80fc		e8		inx		                inx
.80fd		74 00		stz $00,x	                stz 0,x
.80ff		74 01		stz $01,x	                stz 1,x
.8101		4c d0 81	jmp $81d0	                jmp accept_done
.8104						_not_zero:
.8104		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.8106		85 26		sta $26		                sta tmp2
.8108		64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.810a		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.810c		85 24		sta $24		                sta tmp1
.810e		b5 03		lda $03,x	                lda 3,x
.8110		85 25		sta $25		                sta tmp1+1
.8112		e8		inx		                inx
.8113		e8		inx		                inx
.8114		a0 00		ldy #$00	                ldy #0
.8116		a5 20		lda $20		                lda status
.8118		29 f7		and #$f7	                and #$f7
.811a		1a		inc a		               ina
.811b		09 08		ora #$08	                ora #$08
.811d		85 20		sta $20		                sta status
.811f						accept_loop:
.811f		20 f9 92	jsr $92f9	                jsr key_a
.8122		c9 0a		cmp #$0a	                cmp #AscLF
.8124		f0 20		beq $8146	                beq _eol
.8126		c9 0d		cmp #$0d	                cmp #AscCR
.8128		f0 1c		beq $8146	                beq _eol
.812a		c9 08		cmp #$08	                cmp #AscBS
.812c		f0 22		beq $8150	                beq _backspace
.812e		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8130		f0 1e		beq $8150	                beq _backspace
.8132		c9 10		cmp #$10	                cmp #AscCP
.8134		f0 36		beq $816c	                beq _ctrl_p
.8136		c9 0e		cmp #$0e	                cmp #AscCN
.8138		f0 44		beq $817e	                beq _ctrl_n
.813a		91 24		sta ($24),y	                sta (tmp1),y
.813c		c8		iny		                iny
.813d		20 b9 8d	jsr $8db9	                jsr emit_a
.8140		c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.8142		d0 db		bne $811f	                bne accept_loop       ; fall through if buffer limit reached
.8144		80 03		bra $8149	                bra _buffer_full
.8146						_eol:
.8146		20 c8 a0	jsr $a0c8	                jsr xt_space    ; print final space
.8149						_buffer_full:
.8149		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.814b		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.814d		4c d0 81	jmp $81d0	                jmp accept_done
.8150						_backspace:
.8150		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8152		d0 06		bne $815a	                bne +
.8154		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8156		20 b9 8d	jsr $8db9	                jsr emit_a
.8159		c8		iny		                iny
.815a						+
.815a		88		dey		                dey
.815b		a9 08		lda #$08	                lda #AscBS      ; move back one
.815d		20 b9 8d	jsr $8db9	                jsr emit_a
.8160		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8162		20 b9 8d	jsr $8db9	                jsr emit_a
.8165		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8167		20 b9 8d	jsr $8db9	                jsr emit_a
.816a		80 b3		bra $811f	                bra accept_loop
.816c						_ctrl_p:
.816c		a5 20		lda $20		                lda status
.816e		29 07		and #$07	                and #7
.8170		d0 08		bne $817a	                bne _ctrl_p_dec
.8172		a5 20		lda $20		                lda status
.8174		09 07		ora #$07	                ora #7
.8176		85 20		sta $20		                sta status
.8178		80 11		bra $818b	                bra _recall_history
.817a						_ctrl_p_dec:
.817a		c6 20		dec $20		                dec status
.817c		80 0d		bra $818b	                bra _recall_history
.817e						_ctrl_n:
.817e		a9 08		lda #$08	                lda #$8
.8180		24 20		bit $20		                bit status
.8182		d0 07		bne $818b	                bne _recall_history
.8184		a5 20		lda $20		                lda status
.8186		29 f7		and #$f7	                and #$f7
.8188		1a		inc a		               ina
.8189		85 20		sta $20		                sta status
.818b						_recall_history:
.818b		a9 08		lda #$08	                lda #%00001000
.818d		14 20		trb $20		                trb status
.818f		20 eb 81	jsr $81eb	                jsr accept_total_recall
.8192		a9 0d		lda #$0d	                lda #AscCR
.8194		20 b9 8d	jsr $8db9	                jsr emit_a
.8197						input_clear:
.8197		c0 00		cpy #$00	                cpy #0
.8199		f0 08		beq $81a3	                beq input_cleared
.819b		a9 20		lda #$20	                lda #AscSP
.819d		20 b9 8d	jsr $8db9	                jsr emit_a
.81a0		88		dey		                dey
.81a1		80 f4		bra $8197	                bra input_clear
.81a3						input_cleared:
.81a3		a9 0d		lda #$0d	                lda #AscCR
.81a5		20 b9 8d	jsr $8db9	                jsr emit_a
.81a8		b1 28		lda ($28),y	                lda (tmp3),y
.81aa		85 21		sta $21		                sta status+1
.81ac		e6 28		inc $28		                inc tmp3
.81ae		d0 02		bne $81b2	                bne +           ; Increment the upper byte on carry.
.81b0		e6 29		inc $29		                inc tmp3+1
.81b2						+
.81b2		a9 0d		lda #$0d	                lda #AscCR
.81b4		20 b9 8d	jsr $8db9	                jsr emit_a
.81b7						_history_loop:
.81b7		c4 21		cpy $21		                cpy status+1
.81b9		d0 03		bne $81be	                bne +
.81bb		4c 1f 81	jmp $811f	                jmp accept_loop       ; Needs a long jump
.81be						+
.81be		c4 26		cpy $26		                cpy tmp2
.81c0		f0 0a		beq $81cc	                beq _hist_filled_buffer
.81c2		b1 28		lda ($28),y	                lda (tmp3),y
.81c4		91 24		sta ($24),y	                sta (tmp1),y
.81c6		20 b9 8d	jsr $8db9	                jsr emit_a
.81c9		c8		iny		                iny
.81ca		80 eb		bra $81b7	                bra _history_loop
.81cc						_hist_filled_buffer:
.81cc		88		dey		                dey
.81cd		4c 1f 81	jmp $811f	                jmp accept_loop
.81d0						accept_done:
.81d0		20 eb 81	jsr $81eb	                jsr accept_total_recall
.81d3		85 21		sta $21		                sta status+1
.81d5		a0 00		ldy #$00	                ldy #0
.81d7		91 28		sta ($28),y	                sta (tmp3),y
.81d9		e6 28		inc $28		                inc tmp3
.81db		d0 02		bne $81df	                bne +           ; Increment the upper byte on carry.
.81dd		e6 29		inc $29		                inc tmp3+1
.81df						+
.81df						_save_history_loop:
.81df		c4 21		cpy $21		                cpy status+1
.81e1		f0 07		beq $81ea	                beq _save_history_done
.81e3		b1 24		lda ($24),y	                lda (tmp1),y
.81e5		91 28		sta ($28),y	                sta (tmp3),y
.81e7		c8		iny		                iny
.81e8		80 f5		bra $81df	                bra _save_history_loop
.81ea						_save_history_done:
.81ea						z_accept:
.81ea		60		rts		                rts
.81eb						accept_total_recall:
.81eb		a9 00		lda #$00	                lda #<hist_buff
.81ed		85 28		sta $28		                sta tmp3
.81ef		a9 7c		lda #$7c	                lda #>hist_buff
.81f1		85 29		sta $29		                sta tmp3+1
.81f3		a5 20		lda $20		                lda status
.81f5		6a		ror a		                ror
.81f6		29 03		and #$03	                and #3
.81f8		18		clc		                clc
.81f9		65 29		adc $29		                adc tmp3+1
.81fb		85 29		sta $29		                sta tmp3+1
.81fd		a5 20		lda $20		                lda status
.81ff		6a		ror a		                ror             ; Rotate through carry into msb.
.8200		6a		ror a		                ror
.8201		29 80		and #$80	                and #$80
.8203		18		clc		                clc
.8204		65 28		adc $28		                adc tmp3
.8206		85 28		sta $28		                sta tmp3
.8208		90 02		bcc $820c	                bcc +           ; Increment the upper byte on carry.
.820a		e6 29		inc $29		                inc tmp3+1
.820c						+
.820c		98		tya		                tya
.820d		c9 80		cmp #$80	                cmp #$80
.820f		90 02		bcc $8213	                bcc +
.8211		a9 7f		lda #$7f	                lda #$7F
.8213						+
.8213		60		rts		                rts
.8214						xt_action_of:
.8214		a5 16		lda $16		                lda state
.8216		05 17		ora $17		                ora state+1
.8218		f0 0c		beq $8226	                beq _interpreting
.821a						_compiling:
.821a		20 64 85	jsr $8564	                jsr xt_bracket_tick
.821d		a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.821f		a9 b6		lda #$b6	                lda #<xt_defer_fetch
.8221		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.8224		80 06		bra $822c	                bra _done
.8226						_interpreting:
.8226		20 bb a1	jsr $a1bb	                jsr xt_tick
.8229		20 b6 8a	jsr $8ab6	                jsr xt_defer_fetch
.822c						_done:
.822c		60		rts		z_action_of:           rts
.822d						xt_again:
.822d		20 47 d9	jsr $d947	                jsr underflow_1
.8230		a0 00		ldy #$00	                ldy #0
.8232		a9 4c		lda #$4c	                lda #$4C        ; JMP
.8234		91 00		sta ($00),y	                sta (cp),y
.8236		c8		iny		                iny
.8237		b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8239		91 00		sta ($00),y	                sta (cp),y
.823b		c8		iny		                iny
.823c		b5 01		lda $01,x	                lda 1,x         ; MSB of address
.823e		91 00		sta ($00),y	                sta (cp),y
.8240		c8		iny		                iny
.8241		98		tya		                tya
.8242		18		clc		                clc
.8243		65 00		adc $00		                adc cp
.8245		85 00		sta $00		                sta cp
.8247		90 02		bcc $824b	                bcc _done
.8249		e6 01		inc $01		                inc cp+1
.824b						_done:
.824b		e8		inx		                inx
.824c		e8		inx		                inx
.824d		60		rts		z_again:        rts
.824e						xt_align:
.824e						xt_aligned:
.824e						z_align:
.824e		60		rts		z_aligned:      rts             ; stripped out during native compile
.824f						xt_allot:
.824f		20 47 d9	jsr $d947	                jsr underflow_1
.8252		b5 01		lda $01,x	                lda 1,x
.8254		30 22		bmi $8278	                bmi _release
.8256		18		clc		                clc
.8257		a5 00		lda $00		                lda cp
.8259		75 00		adc $00,x	                adc 0,x
.825b		85 00		sta $00		                sta cp
.825d		a5 01		lda $01		                lda cp+1
.825f		75 01		adc $01,x	                adc 1,x
.8261		85 01		sta $01		                sta cp+1
.8263		a0 00		ldy #$00	                ldy #<cp_end
.8265		c4 00		cpy $00		                cpy cp
.8267		a9 7c		lda #$7c	                lda #>cp_end
.8269		e5 01		sbc $01		                sbc cp+1
.826b		b0 48		bcs $82b5	                bcs _done               ; we're fine.
.826d		84 00		sty $00		                sty cp                  ; still #<cp_end
.826f		a9 7c		lda #$7c	                lda #>cp_end
.8271		85 01		sta $01		                sta cp+1
.8273		a9 00		lda #$00	                lda #err_allot
.8275		4c 5d d9	jmp $d95d	                jmp error
.8278						_release:
.8278		ca		dex		                dex
.8279		ca		dex		                dex
.827a		a5 00		lda $00		                lda cp
.827c		95 00		sta $00,x	                sta 0,x
.827e		a5 01		lda $01		                lda cp+1
.8280		95 01		sta $01,x	                sta 1,x
.8282		20 bc 99	jsr $99bc	                jsr xt_plus                     ; new CP is now TOS
.8285		ca		dex		                dex
.8286		ca		dex		                dex                             ; new CP now NOS
.8287		a9 00		lda #$00	                lda #<cp0
.8289		95 00		sta $00,x	                sta 0,x
.828b		a9 03		lda #$03	                lda #>cp0
.828d		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.828f		20 61 d8	jsr $d861	                jsr compare_16bit               ; still ( CP CP0 )
.8292		f0 17		beq $82ab	                beq _nega_done
.8294		30 15		bmi $82ab	                bmi _nega_done
.8296		a9 00		lda #$00	                lda #<cp0
.8298		85 00		sta $00		                sta cp
.829a		a9 03		lda #$03	                lda #>cp0
.829c		85 01		sta $01		                sta cp+1
.829e		a9 4e		lda #$4e	                lda #<dictionary_start
.82a0		85 02		sta $02		                sta dp
.82a2		a9 bd		lda #$bd	                lda #>dictionary_start
.82a4		85 03		sta $03		                sta dp+1
.82a6		a9 0a		lda #$0a	                lda #err_negallot
.82a8		4c 5d d9	jmp $d95d	                jmp error
.82ab						_nega_done:
.82ab		b5 02		lda $02,x	                lda 2,x
.82ad		85 00		sta $00		                sta cp
.82af		b5 03		lda $03,x	                lda 3,x
.82b1		85 01		sta $01		                sta cp+1
.82b3		e8		inx		                inx
.82b4		e8		inx		                inx                     ; drop through to _done
.82b5						_done:
.82b5		e8		inx		                inx
.82b6		e8		inx		                inx
.82b7						z_allot:
.82b7		60		rts		                rts
.82b8						xt_allow_native:
.82b8		20 7c d8	jsr $d87c	                jsr current_to_dp
.82bb		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82bd		b1 02		lda ($02),y	                lda (dp),y
.82bf		29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.82c1		91 02		sta ($02),y	                sta (dp),y
.82c3						z_allow_native:
.82c3		60		rts		                rts
.82c4						xt_also:
.82c4		20 f7 90	jsr $90f7	                jsr xt_get_order
.82c7		20 6c 98	jsr $986c	                jsr xt_over
.82ca		20 58 a1	jsr $a158	                jsr xt_swap
.82cd		20 f6 97	jsr $97f6	                jsr xt_one_plus
.82d0		20 f4 9c	jsr $9cf4	                jsr xt_set_order
.82d3		60		rts		z_also:         rts
.82d4						xt_always_native:
.82d4		20 7c d8	jsr $d87c	                jsr current_to_dp
.82d7		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82d9		b1 02		lda ($02),y	                lda (dp),y
.82db		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.82dd		29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.82df		91 02		sta ($02),y	                sta (dp),y
.82e1						z_always_native:
.82e1		60		rts		                rts
.82e2						xt_and:
.82e2		20 4c d9	jsr $d94c	                jsr underflow_2
.82e5		b5 00		lda $00,x	                lda 0,x
.82e7		35 02		and $02,x	                and 2,x
.82e9		95 02		sta $02,x	                sta 2,x
.82eb		b5 01		lda $01,x	                lda 1,x
.82ed		35 03		and $03,x	                and 3,x
.82ef		95 03		sta $03,x	                sta 3,x
.82f1		e8		inx		                inx
.82f2		e8		inx		                inx
.82f3		60		rts		z_and:          rts
.82f4						xt_at_xy:
.82f4		20 4c d9	jsr $d94c	                jsr underflow_2
.82f7		a5 18		lda $18		                lda base
.82f9		48		pha		                pha
.82fa		a9 0a		lda #$0a	                lda #10
.82fc		85 18		sta $18		                sta base
.82fe		a9 1b		lda #$1b	                lda #AscESC
.8300		20 b9 8d	jsr $8db9	                jsr emit_a
.8303		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.8305		20 b9 8d	jsr $8db9	                jsr emit_a
.8308		20 f6 97	jsr $97f6	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.830b		20 b4 d9	jsr $d9b4	                jsr print_u
.830e		a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8310		20 b9 8d	jsr $8db9	                jsr emit_a
.8313		20 f6 97	jsr $97f6	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8316		20 b4 d9	jsr $d9b4	                jsr print_u
.8319		a9 48		lda #$48	                lda #'H'
.831b		20 b9 8d	jsr $8db9	                jsr emit_a
.831e		68		pla		                pla
.831f		85 18		sta $18		                sta base
.8321		60		rts		z_at_xy:        rts
.8322						xt_backslash:
.8322		a0 00		ldy #$00	                ldy #blk_offset
.8324		b1 1e		lda ($1e),y	                lda (up),y
.8326		c8		iny		                iny
.8327		11 1e		ora ($1e),y	                ora (up),y
.8329		f0 19		beq $8344	                beq backslash_not_block
.832b		a5 0c		lda $0c		                lda toin
.832d		29 3f		and #$3f	                and #$3F
.832f		f0 1b		beq $834c	                beq z_backslash
.8331		c9 01		cmp #$01	                cmp #$01
.8333		f0 17		beq $834c	                beq z_backslash
.8335		a5 0c		lda $0c		                lda toin
.8337		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.8339		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.833a		69 40		adc #$40	                adc #$40
.833c		85 0c		sta $0c		                sta toin
.833e		90 0c		bcc $834c	                bcc z_backslash
.8340		e6 0d		inc $0d		                inc toin+1
.8342		80 08		bra $834c	                bra z_backslash
.8344						backslash_not_block:
.8344		a5 0a		lda $0a		                lda ciblen
.8346		85 0c		sta $0c		                sta toin
.8348		a5 0b		lda $0b		                lda ciblen+1
.834a		85 0d		sta $0d		                sta toin+1
.834c		60		rts		z_backslash:    rts
.834d						xt_base:
.834d		ca		dex		                dex
.834e		ca		dex		                dex
.834f		a9 18		lda #$18	                lda #<base
.8351		95 00		sta $00,x	                sta 0,x         ; LSB
.8353		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8355		60		rts		z_base:         rts
.8356						xt_begin:
.8356		20 35 91	jsr $9135	                jsr xt_here
.8359		60		rts		z_begin:        rts
.835a						xt_bell:
.835a		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.835c		20 b9 8d	jsr $8db9	                jsr emit_a
.835f		60		rts		z_bell:         rts
.8360						xt_bl:
.8360		ca		dex		                dex
.8361		ca		dex		                dex
.8362		a9 20		lda #$20	                lda #AscSP
.8364		95 00		sta $00,x	                sta 0,x
.8366		74 01		stz $01,x	                stz 1,x
.8368		60		rts		z_bl:           rts
.8369						xt_blk:
.8369		ca		dex		                dex
.836a		ca		dex		                dex
.836b		18		clc		                clc
.836c		a5 1e		lda $1e		                lda up
.836e		69 00		adc #$00	                adc #blk_offset ; Add offset
.8370		95 00		sta $00,x	                sta 0,x
.8372		a5 1f		lda $1f		                lda up+1
.8374		69 00		adc #$00	                adc #0          ; Adding carry
.8376		95 01		sta $01,x	                sta 1,x
.8378		60		rts		z_blk:          rts
.8379						xt_blkbuffer:
.8379		ca		dex		                dex
.837a		ca		dex		                dex
.837b		a0 28		ldy #$28	                ldy #blkbuffer_offset
.837d		b1 1e		lda ($1e),y	                lda (up),y
.837f		95 00		sta $00,x	                sta 0,x
.8381		c8		iny		                iny             ; Move along to the next byte
.8382		b1 1e		lda ($1e),y	                lda (up),y
.8384		95 01		sta $01,x	                sta 1,x
.8386		60		rts		z_blkbuffer:    rts
.8387						xt_block:
.8387		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8389		b1 1e		lda ($1e),y	                lda (up),y
.838b		d5 00		cmp $00,x	                cmp 0,x
.838d		d0 0f		bne $839e	                bne _not_in_buffer
.838f		c8		iny		                iny
.8390		b1 1e		lda ($1e),y	                lda (up),y
.8392		d5 01		cmp $01,x	                cmp 1,x
.8394		d0 08		bne $839e	                bne _not_in_buffer
.8396		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8398		b1 1e		lda ($1e),y	                lda (up),y
.839a		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.839c		d0 30		bne $83ce	                bne _done       ; It's already in the buffer and in use.
.839e						_not_in_buffer:
.839e		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83a0		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83a2		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83a4		d0 0c		bne $83b2	                bne _buffer_available ; Unused or not dirty = available
.83a6		20 79 83	jsr $8379	                jsr xt_blkbuffer
.83a9		20 6b 85	jsr $856b	                jsr xt_buffblocknum
.83ac		20 43 8f	jsr $8f43	                jsr xt_fetch
.83af		20 26 85	jsr $8526	                jsr xt_block_write
.83b2						_buffer_available:
.83b2		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83b4		b5 00		lda $00,x	                lda 0,x
.83b6		91 1e		sta ($1e),y	                sta (up),y
.83b8		c8		iny		                iny
.83b9		b5 01		lda $01,x	                lda 1,x
.83bb		91 1e		sta ($1e),y	                sta (up),y
.83bd		20 79 83	jsr $8379	                jsr xt_blkbuffer
.83c0		20 58 a1	jsr $a158	                jsr xt_swap
.83c3		20 03 85	jsr $8503	                jsr xt_block_read
.83c6		a9 01		lda #$01	                lda #1
.83c8		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83ca		91 1e		sta ($1e),y	                sta (up),y
.83cc		ca		dex		                dex
.83cd		ca		dex		                dex
.83ce						_done:
.83ce		a0 28		ldy #$28	                ldy #blkbuffer_offset
.83d0		b1 1e		lda ($1e),y	                lda (up),y
.83d2		95 00		sta $00,x	                sta 0,x
.83d4		c8		iny		                iny
.83d5		b1 1e		lda ($1e),y	                lda (up),y
.83d7		95 01		sta $01,x	                sta 1,x
.83d9		60		rts		z_block:        rts
.83da						xt_block_ramdrive_init:
.83da		20 47 d9	jsr $d947	                jsr underflow_1
.83dd		4c f8 84	jmp $84f8	                jmp _after_ramdrive_code
.83e0						_ramdrive_code:
>83e0		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>83e8		77 61 70 20 64 65 63 69 6d 61 6c
>83f3		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>83fa		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>83fe		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>8406		20 72 61 6d 64 72 69 76 65
>840f		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8417		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>8425		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>842d		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>843d		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>844d		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>8455		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>8464		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>846c		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>847c		31 30 32 34 20 6d 6f 76 65 20 3b
>8487		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>848f		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>849f		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>84af		20 21
>84b1		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84b9		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84c9		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>84d9		6f 72 20 21
>84dd		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>84e5		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>84f5		65 20 21
.84f8						_after_ramdrive_code:
.84f8		20 53 a0	jsr $a053	                jsr sliteral_runtime
>84fb		e0 83 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.84ff		20 98 90	jsr $9098	                jsr xt_evaluate
.8502						z_block_ramdrive_init:
.8502		60		rts		                rts
.8503						xt_block_read:
.8503		a0 2e		ldy #$2e	                ldy #blockread_offset
.8505		b1 1e		lda ($1e),y	                lda (up),y
.8507		85 24		sta $24		                sta tmp1
.8509		c8		iny		                iny
.850a		b1 1e		lda ($1e),y	                lda (up),y
.850c		85 25		sta $25		                sta tmp1+1
.850e		6c 24 00	jmp ($0024)	                jmp (tmp1)
.8511						z_block_read:
.8511						xt_block_read_vector:
.8511		ca		dex		                dex
.8512		ca		dex		                dex
.8513		18		clc		                clc
.8514		a5 1e		lda $1e		                lda up
.8516		69 2e		adc #$2e	                adc #blockread_offset
.8518		95 00		sta $00,x	                sta 0,x
.851a		a5 1f		lda $1f		                lda up+1
.851c		69 00		adc #$00	                adc #0          ; Add carry
.851e		95 01		sta $01,x	                sta 1,x
.8520						z_block_read_vector:
.8520		60		rts		                rts
.8521						xt_block_word_error:
.8521		a9 0c		lda #$0c	                lda #err_blockwords
.8523		4c 5d d9	jmp $d95d	                jmp error       ; no RTS needed
.8526						z_block_word_error:
.8526						xt_block_write:
.8526		a0 30		ldy #$30	                ldy #blockwrite_offset
.8528		b1 1e		lda ($1e),y	                lda (up),y
.852a		85 24		sta $24		                sta tmp1
.852c		c8		iny		                iny
.852d		b1 1e		lda ($1e),y	                lda (up),y
.852f		85 25		sta $25		                sta tmp1+1
.8531		6c 24 00	jmp ($0024)	                jmp (tmp1)
.8534						z_block_write:
.8534						xt_block_write_vector:
.8534		ca		dex		                dex
.8535		ca		dex		                dex
.8536		18		clc		                clc
.8537		a5 1e		lda $1e		                lda up
.8539		69 30		adc #$30	                adc #blockwrite_offset
.853b		95 00		sta $00,x	                sta 0,x
.853d		a5 1f		lda $1f		                lda up+1
.853f		69 00		adc #$00	                adc #0          ; Add carry
.8541		95 01		sta $01,x	                sta 1,x
.8543						z_block_write_vector:
.8543		60		rts		                rts
.8544						xt_bounds:
.8544		20 4c d9	jsr $d94c	                jsr underflow_2
.8547		18		clc		                clc
.8548		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.854a		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.854c		75 02		adc $02,x	                adc 2,x
.854e		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8550		94 00		sty $00,x	                sty 0,x
.8552		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.8554		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8556		75 03		adc $03,x	                adc 3,x
.8558		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.855a		94 01		sty $01,x	                sty 1,x
.855c		60		rts		z_bounds:       rts
.855d						xt_bracket_char:
.855d		20 f7 85	jsr $85f7	                jsr xt_char
.8560		20 4b 93	jsr $934b	                jsr xt_literal
.8563		60		rts		z_bracket_char: rts
.8564						xt_bracket_tick:
.8564		20 bb a1	jsr $a1bb	                jsr xt_tick
.8567		20 4b 93	jsr $934b	                jsr xt_literal
.856a		60		rts		z_bracket_tick: rts
.856b						xt_buffblocknum:
.856b		ca		dex		                dex
.856c		ca		dex		                dex
.856d		18		clc		                clc
.856e		a5 1e		lda $1e		                lda up
.8570		69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.8572		95 00		sta $00,x	                sta 0,x
.8574		a5 1f		lda $1f		                lda up+1
.8576		69 00		adc #$00	                adc #0                          ; Adding carry
.8578		95 01		sta $01,x	                sta 1,x
.857a		60		rts		z_buffblocknum: rts
.857b						xt_buffer:
.857b		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.857d		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.857f		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8581		d0 0c		bne $858f	                bne _buffer_available ; Unused or not dirty = available
.8583		20 79 83	jsr $8379	                jsr xt_blkbuffer
.8586		20 6b 85	jsr $856b	                jsr xt_buffblocknum
.8589		20 43 8f	jsr $8f43	                jsr xt_fetch
.858c		20 26 85	jsr $8526	                jsr xt_block_write
.858f						_buffer_available:
.858f		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8591		b5 00		lda $00,x	                lda 0,x
.8593		91 1e		sta ($1e),y	                sta (up),y
.8595		c8		iny		                iny
.8596		b5 01		lda $01,x	                lda 1,x
.8598		91 1e		sta ($1e),y	                sta (up),y
.859a		a9 01		lda #$01	                lda #1
.859c		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.859e		91 1e		sta ($1e),y	                sta (up),y
.85a0						_done:
.85a0		a0 28		ldy #$28	                ldy #blkbuffer_offset
.85a2		b1 1e		lda ($1e),y	                lda (up),y
.85a4		95 00		sta $00,x	                sta 0,x
.85a6		c8		iny		                iny
.85a7		b1 1e		lda ($1e),y	                lda (up),y
.85a9		95 01		sta $01,x	                sta 1,x
.85ab		60		rts		z_buffer:       rts
.85ac						xt_buffer_colon:
.85ac		20 40 89	jsr $8940	                jsr xt_create
.85af		20 4f 82	jsr $824f	                jsr xt_allot
.85b2		60		rts		z_buffer_colon: rts
.85b3						xt_buffstatus:
.85b3		ca		dex		                dex
.85b4		ca		dex		                dex
.85b5		18		clc		                clc
.85b6		a5 1e		lda $1e		                lda up
.85b8		69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85ba		95 00		sta $00,x	                sta 0,x
.85bc		a5 1f		lda $1f		                lda up+1
.85be		69 00		adc #$00	                adc #0                  ; Adding carry
.85c0		95 01		sta $01,x	                sta 1,x
.85c2		60		rts		z_buffstatus:   rts
.85c3						xt_bye:
.85c3		4c 2b f0	jmp $f02b	                jmp platform_bye
.85c6						z_bye:
.85c6						xt_c_comma:
.85c6		20 47 d9	jsr $d947	                jsr underflow_1
.85c9		b5 00		lda $00,x	                lda 0,x
.85cb		20 ed d7	jsr $d7ed	                jsr cmpl_a
.85ce		e8		inx		                inx
.85cf		e8		inx		                inx
.85d0		60		rts		z_c_comma:      rts
.85d1						xt_c_fetch:
.85d1		20 47 d9	jsr $d947	                jsr underflow_1
.85d4		a1 00		lda ($00,x)	                lda (0,x)
.85d6		95 00		sta $00,x	                sta 0,x
.85d8		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.85da		60		rts		z_c_fetch:      rts
.85db						xt_c_store:
.85db		20 4c d9	jsr $d94c	                jsr underflow_2
.85de		b5 02		lda $02,x	                lda 2,x
.85e0		81 00		sta ($00,x)	                sta (0,x)
.85e2		e8		inx		                inx
.85e3		e8		inx		                inx
.85e4		e8		inx		                inx
.85e5		e8		inx		                inx
.85e6		60		rts		z_c_store:      rts
.85e7						xt_cell_plus:
.85e7		20 47 d9	jsr $d947	                jsr underflow_1
.85ea		f6 00		inc $00,x	                inc 0,x
.85ec		d0 02		bne $85f0	                bne +
.85ee		f6 01		inc $01,x	                inc 1,x
.85f0						+
.85f0		f6 00		inc $00,x	                inc 0,x
.85f2		d0 02		bne $85f6	                bne _done
.85f4		f6 01		inc $01,x	                inc 1,x
.85f6						_done:
.85f6		60		rts		z_cell_plus:    rts
.85f7						xt_char:
.85f7		20 b8 98	jsr $98b8	                jsr xt_parse_name
.85fa		b5 00		lda $00,x	                lda 0,x
.85fc		15 01		ora $01,x	                ora 1,x
.85fe		d0 05		bne $8605	                bne _not_empty
.8600		a9 05		lda #$05	                lda #err_noname
.8602		4c 5d d9	jmp $d95d	                jmp error
.8605						_not_empty:
.8605		e8		inx		                inx             ; drop number of characters, leave addr
.8606		e8		inx		                inx
.8607		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8609		95 00		sta $00,x	                sta 0,x
.860b		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.860d		60		rts		z_char:         rts
.860e						xt_chars:
.860e		20 47 d9	jsr $d947	                jsr underflow_1
.8611		60		rts		z_chars:        rts
.8612						xt_cleave:
.8612		20 4c d9	jsr $d94c	                jsr underflow_2
.8615		20 3c 95	jsr $953c	                jsr xt_minus_leading    ; -LEADING ( addr u )
.8618		20 23 92	jsr $9223	                jsr xt_input_to_r       ; save old imput state
.861b		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.861d		85 0a		sta $0a		                sta ciblen
.861f		b5 01		lda $01,x	                lda 1,x
.8621		85 0b		sta $0b		                sta ciblen+1
.8623		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.8625		85 08		sta $08		                sta cib
.8627		b5 03		lda $03,x	                lda 3,x
.8629		85 09		sta $09		                sta cib+1
.862b		64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.862d		64 0d		stz $0d		                stz toin+1
.862f		20 b8 98	jsr $98b8	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8632		b5 00		lda $00,x	                lda 0,x
.8634		15 01		ora $01,x	                ora 1,x
.8636		f0 23		beq $865b	                beq _done
.8638		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.863a		38		sec		                sec
.863b		f5 00		sbc $00,x	                sbc 0,x
.863d		95 04		sta $04,x	                sta 4,x
.863f		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.8641		f5 01		sbc $01,x	                sbc 1,x
.8643		95 05		sta $05,x	                sta 5,x
.8645		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8647		18		clc		                clc
.8648		75 00		adc $00,x	                adc 0,x
.864a		95 06		sta $06,x	                sta 6,x
.864c		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.864e		75 01		adc $01,x	                adc 1,x
.8650		95 07		sta $07,x	                sta 7,x
.8652		20 28 a4	jsr $a428	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.8655		20 3c 95	jsr $953c	                jsr xt_minus_leading
.8658		20 28 a4	jsr $a428	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.865b						_done:
.865b		20 7c 9a	jsr $9a7c	                jsr xt_r_to_input
.865e		60		rts		z_cleave:       rts
.865f						xt_cmove:
.865f		20 51 d9	jsr $d951	                jsr underflow_3
.8662		b5 02		lda $02,x	                lda 2,x
.8664		85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8666		b5 03		lda $03,x	                lda 3,x
.8668		85 27		sta $27		                sta tmp2+1
.866a		b5 04		lda $04,x	                lda 4,x
.866c		85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.866e		b5 05		lda $05,x	                lda 5,x
.8670		85 25		sta $25		                sta tmp1+1
.8672		a0 00		ldy #$00	                ldy #0
.8674		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.8676		f0 0f		beq $8687	                beq _dopartial
.8678						_page:
.8678		b1 24		lda ($24),y	                lda (tmp1),y
.867a		91 26		sta ($26),y	                sta (tmp2),y
.867c		c8		iny		                iny
.867d		d0 f9		bne $8678	                bne _page
.867f		e6 25		inc $25		                inc tmp1+1
.8681		e6 27		inc $27		                inc tmp2+1
.8683		d6 01		dec $01,x	                dec 1,x
.8685		d0 f1		bne $8678	                bne _page
.8687						_dopartial:
.8687		b5 00		lda $00,x	                lda 0,x         ; length of last page
.8689		f0 09		beq $8694	                beq _done
.868b						_partial:
.868b		b1 24		lda ($24),y	                lda (tmp1),y
.868d		91 26		sta ($26),y	                sta (tmp2),y
.868f		c8		iny		                iny
.8690		d6 00		dec $00,x	                dec 0,x
.8692		d0 f7		bne $868b	                bne _partial
.8694						_done:
.8694		8a		txa		                txa
.8695		18		clc		                clc
.8696		69 06		adc #$06	                adc #6
.8698		aa		tax		                tax
.8699		60		rts		z_cmove:        rts
.869a						xt_cmove_up:
.869a		20 51 d9	jsr $d951	                jsr underflow_3
.869d		b5 02		lda $02,x	                lda 2,x
.869f		85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86a1		b5 03		lda $03,x	                lda 3,x
.86a3		18		clc		                clc
.86a4		75 01		adc $01,x	                adc 1,x
.86a6		85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86a8		b5 04		lda $04,x	                lda 4,x
.86aa		85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86ac		b5 05		lda $05,x	                lda 5,x
.86ae		18		clc		                clc
.86af		75 01		adc $01,x	                adc 1,x
.86b1		85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86b3		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86b5		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86b7		f0 0e		beq $86c7	                beq _nopartial
.86b9						_outerloop:
.86b9		88		dey		                dey
.86ba		f0 07		beq $86c3	                beq _finishpage
.86bc						_innerloop:
.86bc		b1 24		lda ($24),y	                lda (tmp1),y
.86be		91 26		sta ($26),y	                sta (tmp2),y
.86c0		88		dey		                dey
.86c1		d0 f9		bne $86bc	                bne _innerloop
.86c3						_finishpage:
.86c3		b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.86c5		92 26		sta ($26)	                sta (tmp2)
.86c7						_nopartial:
.86c7		c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.86c9		c6 27		dec $27		                dec tmp2+1
.86cb		d6 01		dec $01,x	                dec 1,x
.86cd		d0 ea		bne $86b9	                bne _outerloop
.86cf						_done:
.86cf		8a		txa		                txa
.86d0		18		clc		                clc
.86d1		69 06		adc #$06	                adc #6
.86d3		aa		tax		                tax
.86d4		60		rts		z_cmove_up:     rts
.86d5						xt_colon:
.86d5		a5 16		lda $16		                lda state
.86d7		05 17		ora $17		                ora state+1
.86d9		f0 05		beq $86e0	                beq +
.86db		a9 07		lda #$07	                lda #err_state
.86dd		4c 5d d9	jmp $d95d	                jmp error
.86e0						+
.86e0		c6 16		dec $16		                dec state
.86e2		c6 17		dec $17		                dec state+1
.86e4		a9 40		lda #$40	                lda #%01000000
.86e6		04 20		tsb $20		                tsb status
.86e8		20 7c d8	jsr $d87c	                jsr current_to_dp
.86eb		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.86ed		48		pha		                pha
.86ee		a5 02		lda $02		                lda dp
.86f0		48		pha		                pha
.86f1		a9 80		lda #$80	                lda #%10000000
.86f3		04 20		tsb $20		                tsb status
.86f5		20 40 89	jsr $8940	                jsr xt_create
.86f8		20 7c d8	jsr $d87c	                jsr current_to_dp   ; This might be able to be omitted
.86fb		a5 02		lda $02		                lda dp
.86fd		85 04		sta $04		                sta workword
.86ff		a5 03		lda $03		                lda dp+1
.8701		85 05		sta $05		                sta workword+1
.8703		68		pla		                pla
.8704		85 02		sta $02		                sta dp
.8706		68		pla		                pla
.8707		85 03		sta $03		                sta dp+1
.8709		20 8f d8	jsr $d88f	                jsr dp_to_current
.870c		a5 00		lda $00		                lda cp
.870e		38		sec		                sec
.870f		e9 03		sbc #$03	                sbc #3
.8711		85 00		sta $00		                sta cp
.8713		b0 02		bcs $8717	                bcs _done
.8715		c6 01		dec $01		                dec cp+1
.8717						_done:
.8717		60		rts		z_colon:        rts
.8718						xt_colon_noname:
.8718		a5 16		lda $16		                lda state
.871a		05 17		ora $17		                ora state+1
.871c		f0 05		beq $8723	                beq +
.871e		a9 07		lda #$07	                lda #err_state
.8720		4c 5d d9	jmp $d95d	                jmp error
.8723						+
.8723		c6 16		dec $16		                dec state
.8725		c6 17		dec $17		                dec state+1
.8727		a9 40		lda #$40	                lda #%01000000
.8729		14 20		trb $20		                trb status
.872b		a5 00		lda $00		                lda cp
.872d		85 04		sta $04		                sta workword
.872f		a5 01		lda $01		                lda cp+1
.8731		85 05		sta $05		                sta workword+1
.8733						_done:
.8733		60		rts		z_colon_noname:        rts
.8734						xt_comma:
.8734		20 47 d9	jsr $d947	                jsr underflow_1
.8737		b5 00		lda $00,x	                lda 0,x
.8739		92 00		sta ($00)	                sta (cp)
.873b		e6 00		inc $00		                inc cp
.873d		d0 02		bne $8741	                bne +
.873f		e6 01		inc $01		                inc cp+1
.8741						+
.8741		b5 01		lda $01,x	                lda 1,x
.8743		92 00		sta ($00)	                sta (cp)
.8745		e6 00		inc $00		                inc cp
.8747		d0 02		bne $874b	                bne _done
.8749		e6 01		inc $01		                inc cp+1
.874b						_done:
.874b		e8		inx		                inx
.874c		e8		inx		                inx
.874d		60		rts		z_comma:        rts
.874e						xt_compare:
.874e		20 56 d9	jsr $d956	                jsr underflow_4
.8751		b5 02		lda $02,x	                lda 2,x
.8753		85 26		sta $26		                sta tmp2
.8755		b5 03		lda $03,x	                lda 3,x
.8757		85 27		sta $27		                sta tmp2+1
.8759		b5 06		lda $06,x	                lda 6,x
.875b		85 24		sta $24		                sta tmp1
.875d		b5 07		lda $07,x	                lda 7,x
.875f		85 25		sta $25		                sta tmp1+1
.8761						_compare_loop:
.8761		b5 04		lda $04,x	                lda 4,x
.8763		15 05		ora $05,x	                ora 5,x
.8765		f0 2c		beq $8793	                beq _str1_done
.8767		b5 00		lda $00,x	                lda 0,x
.8769		15 01		ora $01,x	                ora 1,x
.876b		f0 3a		beq $87a7	                beq _greater    ; Str2 empty first
.876d						_check_letter:
.876d		b2 24		lda ($24)	                lda (tmp1)
.876f		d2 26		cmp ($26)	                cmp (tmp2)
.8771		90 26		bcc $8799	                bcc _less
.8773		d0 32		bne $87a7	                bne _greater
.8775						_next_letter:
.8775		e6 24		inc $24		                inc tmp1
.8777		d0 02		bne $877b	                bne +
.8779		e6 25		inc $25		                inc tmp1+1
.877b						+
.877b		e6 26		inc $26		                inc tmp2
.877d		d0 02		bne $8781	                bne +
.877f		e6 27		inc $27		                inc tmp2+1
.8781						+
.8781		b5 04		lda $04,x	                lda 4,x
.8783		d0 02		bne $8787	                bne +
.8785		d6 05		dec $05,x	                dec 5,x
.8787						+
.8787		d6 04		dec $04,x	                dec 4,x
.8789		b5 00		lda $00,x	                lda 0,x
.878b		d0 02		bne $878f	                bne +
.878d		d6 01		dec $01,x	                dec 1,x
.878f						+
.878f		d6 00		dec $00,x	                dec 0,x
.8791		80 ce		bra $8761	                bra _compare_loop
.8793						_str1_done:
.8793		b5 00		lda $00,x	                lda 0,x
.8795		15 01		ora $01,x	                ora 1,x
.8797		f0 08		beq $87a1	                beq _equal      ; Both out of letters
.8799						_less:
.8799		a9 ff		lda #$ff	                lda #$FF
.879b		95 06		sta $06,x	                sta 6,x
.879d		95 07		sta $07,x	                sta 7,x
.879f		80 0c		bra $87ad	                bra _done
.87a1						_equal:
.87a1		74 06		stz $06,x	                stz 6,x
.87a3		74 07		stz $07,x	                stz 7,x
.87a5		80 06		bra $87ad	                bra _done
.87a7						_greater:
.87a7		a9 01		lda #$01	                lda #1
.87a9		95 06		sta $06,x	                sta 6,x
.87ab		74 07		stz $07,x	                stz 7,x
.87ad						_done:
.87ad		8a		txa		                txa
.87ae		18		clc		                clc
.87af		69 06		adc #$06	                adc #6
.87b1		aa		tax		                tax
.87b2		60		rts		z_compare:      rts
.87b3						xt_compile_comma:
.87b3		20 47 d9	jsr $d947	                jsr underflow_1
.87b6		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87b8		48		pha		                pha
.87b9		b5 00		lda $00,x	                lda 0,x
.87bb		48		pha		                pha                     ; LSB
.87bc		20 39 92	jsr $9239	                jsr xt_int_to_name      ; ( xt -- nt )
.87bf		b5 00		lda $00,x	                lda 0,x
.87c1		15 01		ora $01,x	                ora 1,x
.87c3		d0 03		bne $87c8	                bne _check_nt
.87c5		4c c1 88	jmp $88c1	                jmp compile_as_jump
.87c8						_check_nt:
.87c8		b5 00		lda $00,x	                lda 0,x
.87ca		85 2c		sta $2c		                sta tmptos
.87cc		b5 01		lda $01,x	                lda 1,x
.87ce		85 2d		sta $2d		                sta tmptos+1
.87d0		f6 00		inc $00,x	                inc 0,x
.87d2		d0 02		bne $87d6	                bne +
.87d4		f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.87d6						+
.87d6		a1 00		lda ($00,x)	                lda (0,x)
.87d8		85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.87da		29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.87dc		f0 0d		beq $87eb	                beq _compile_check
.87de		a5 2c		lda $2c		                lda tmptos
.87e0		95 00		sta $00,x	                sta 0,x
.87e2		a5 2d		lda $2d		                lda tmptos+1
.87e4		95 01		sta $01,x	                sta 1,x
.87e6		20 1f a7	jsr $a71f	                jsr xt_wordsize         ; ( nt -- u )
.87e9		80 27		bra $8812	                bra _compile_as_code
.87eb						_compile_check:
.87eb		a5 28		lda $28		                lda tmp3
.87ed		29 08		and #$08	                and #NN
.87ef		f0 03		beq $87f4	                beq _check_size_limit
.87f1		4c c1 88	jmp $88c1	                jmp compile_as_jump    ; too far for BRA
.87f4						_check_size_limit:
.87f4		a5 2c		lda $2c		                lda tmptos
.87f6		95 00		sta $00,x	                sta 0,x
.87f8		a5 2d		lda $2d		                lda tmptos+1
.87fa		95 01		sta $01,x	                sta 1,x
.87fc		20 1f a7	jsr $a71f	                jsr xt_wordsize         ; ( nt -- u )
.87ff		b5 01		lda $01,x	                lda 1,x
.8801		c5 1b		cmp $1b		                cmp nc_limit+1
.8803		90 0d		bcc $8812	                bcc _compile_as_code    ; user-defined limit MSB
.8805		d0 08		bne $880f	                bne _jumpto_compile_as_jump
.8807		b5 00		lda $00,x	                lda 0,x
.8809		c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.880b		90 05		bcc $8812	                bcc _compile_as_code    ; Allow native compiling for less
.880d		f0 03		beq $8812	                beq _compile_as_code    ; than or equal to the limit.
.880f						_jumpto_compile_as_jump:
.880f		4c c1 88	jmp $88c1	                jmp compile_as_jump    ; too far for BRA
.8812						_compile_as_code:
.8812		ca		dex		                dex
.8813		ca		dex		                dex                     ; ( -- u ? )
.8814		ca		dex		                dex
.8815		ca		dex		                dex                     ; ( -- u ? ? )
.8816		b5 04		lda $04,x	                lda 4,x
.8818		95 00		sta $00,x	                sta 0,x                 ; LSB of u
.881a		b5 05		lda $05,x	                lda 5,x
.881c		95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.881e		68		pla		                pla
.881f		95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8821		68		pla		                pla
.8822		95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.8824		a5 00		lda $00		                lda cp                  ; LSB of cp
.8826		95 02		sta $02,x	                sta 2,x
.8828		a5 01		lda $01		                lda cp+1
.882a		95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.882c		a0 00		ldy #$00	                ldy #0
.882e						_strip_loop:
.882e		b9 af 88	lda $88af,y	                lda strip_table,y      ; LSB of first word
.8831		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8833		d0 07		bne $883c	                bne _next_entry
.8835		b9 b0 88	lda $88b0,y	                lda strip_table+1,y
.8838		d5 05		cmp $05,x	                cmp 5,x
.883a		f0 0c		beq $8848	                beq _found_entry
.883c						_next_entry:
.883c		b9 af 88	lda $88af,y	                lda strip_table,y      ; pointing to LSB
.883f		19 b0 88	ora $88b0,y	                ora strip_table+1,y    ; get MSB
.8842		f0 22		beq $8866	                beq _underflow_strip    ; table done, let's get out of here
.8844		c8		iny		                iny
.8845		c8		iny		                iny
.8846		80 e6		bra $882e	                bra _strip_loop
.8848						_found_entry:
.8848		98		tya		                tya
.8849		4a		lsr a		                lsr
.884a		a8		tay		                tay
.884b		b9 bb 88	lda $88bb,y	                lda strip_size,y
.884e		85 2c		sta $2c		                sta tmptos              ; save a copy
.8850		18		clc		                clc
.8851		75 04		adc $04,x	                adc 4,x
.8853		95 04		sta $04,x	                sta 4,x
.8855		90 02		bcc $8859	                bcc+
.8857		f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8859						+
.8859		06 2c		asl $2c		                asl tmptos
.885b		38		sec		                sec
.885c		b5 00		lda $00,x	                lda 0,x
.885e		e5 2c		sbc $2c		                sbc tmptos
.8860		95 00		sta $00,x	                sta 0,x
.8862		b0 02		bcs $8866	                bcs +
.8864		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8866						+
.8866						_underflow_strip:
.8866		a5 1c		lda $1c		                lda uf_strip
.8868		05 1d		ora $1d		                ora uf_strip+1
.886a		f0 1c		beq $8888	                beq cmpl_inline
.886c		a5 28		lda $28		                lda tmp3
.886e		29 10		and #$10	                and #UF
.8870		f0 16		beq $8888	                beq cmpl_inline
.8872		18		clc		                clc
.8873		b5 04		lda $04,x	                lda 4,x
.8875		69 03		adc #$03	                adc #3
.8877		95 04		sta $04,x	                sta 4,x
.8879		90 02		bcc $887d	                bcc +
.887b		f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.887d						+
.887d		38		sec		                sec
.887e		b5 00		lda $00,x	                lda 0,x
.8880		e9 03		sbc #$03	                sbc #3
.8882		95 00		sta $00,x	                sta 0,x
.8884		b0 02		bcs $8888	                bcs +
.8886		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.8888						+
.8888						cmpl_inline:
.8888		b5 01		lda $01,x	                lda 1,x                 ; MSB
.888a		48		pha		                pha
.888b		b5 00		lda $00,x	                lda 0,x                 ; LSB
.888d		48		pha		                pha
.888e		20 9b 95	jsr $959b	                jsr xt_move
.8891		18		clc		                clc
.8892		68		pla		                pla                     ; LSB
.8893		65 00		adc $00		                adc cp
.8895		85 00		sta $00		                sta cp
.8897		68		pla		                pla                     ; MSB
.8898		65 01		adc $01		                adc cp+1
.889a		85 01		sta $01		                sta cp+1
.889c		60		rts		                rts
.889d						cmpl_inline_y:
.889d		ca		dex		                dex             ; set up stack as ( src dst n -- )
.889e		ca		dex		                dex
.889f		ca		dex		                dex
.88a0		ca		dex		                dex
.88a1		94 00		sty $00,x	                sty 0,x
.88a3		74 01		stz $01,x	                stz 1,x             ; assume < 256 bytes
.88a5		a5 00		lda $00		                lda cp
.88a7		95 02		sta $02,x	                sta 2,x
.88a9		a5 01		lda $01		                lda cp+1
.88ab		95 03		sta $03,x	                sta 3,x
.88ad		80 d9		bra $8888	                bra cmpl_inline
.88af						strip_table:
>88af		6b 9a 56 9a 1a a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88b5		4c a4 d2 a3 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88bb						strip_size:
>88bb		04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88c1						compile_as_jump:
.88c1		a9 20		lda #$20	                lda #$20
.88c3		92 00		sta ($00)	                sta (cp)
.88c5		a0 01		ldy #$01	                ldy #1
.88c7		68		pla		                pla             ; LSB
.88c8		91 00		sta ($00),y	                sta (cp),y
.88ca		c8		iny		                iny
.88cb		68		pla		                pla             ; MSB
.88cc		91 00		sta ($00),y	                sta (cp),y
.88ce		a9 03		lda #$03	                lda #3
.88d0		18		clc		                clc
.88d1		65 00		adc $00		                adc cp
.88d3		85 00		sta $00		                sta cp
.88d5		90 02		bcc $88d9	                bcc +
.88d7		e6 01		inc $01		                inc cp+1
.88d9						+
.88d9		e8		inx		                inx             ; drop xt
.88da		e8		inx		                inx
.88db						z_compile_comma:
.88db		60		rts		                rts
.88dc						xt_compile_only:
.88dc		20 7c d8	jsr $d87c	                jsr current_to_dp
.88df		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.88e1		b1 02		lda ($02),y	                lda (dp),y
.88e3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.88e5		91 02		sta ($02),y	                sta (dp),y
.88e7		60		rts		z_compile_only: rts
.88e8						xt_value:
.88e8						xt_constant:
.88e8		20 47 d9	jsr $d947	                jsr underflow_1
.88eb		20 40 89	jsr $8940	                jsr xt_create
.88ee		38		sec		                sec
.88ef		a5 00		lda $00		                lda cp
.88f1		e9 02		sbc #$02	                sbc #2
.88f3		85 24		sta $24		                sta tmp1
.88f5		a5 01		lda $01		                lda cp+1
.88f7		e9 00		sbc #$00	                sbc #0
.88f9		85 25		sta $25		                sta tmp1+1
.88fb		a9 f6		lda #$f6	                lda #<doconst           ; LSB of DOCONST
.88fd		92 24		sta ($24)	                sta (tmp1)
.88ff		a0 01		ldy #$01	                ldy #1
.8901		a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.8903		91 24		sta ($24),y	                sta (tmp1),y
.8905		20 34 87	jsr $8734	                jsr xt_comma            ; drop through to adjust_z
.8908						adjust_z:
.8908		20 fc 92	jsr $92fc	                jsr xt_latestnt         ; gives us ( -- nt )
.890b		b5 00		lda $00,x	                lda 0,x
.890d		85 24		sta $24		                sta tmp1
.890f		b5 01		lda $01,x	                lda 1,x
.8911		85 25		sta $25		                sta tmp1+1
.8913		a0 06		ldy #$06	                ldy #6
.8915		b1 24		lda ($24),y	                lda (tmp1),y
.8917		18		clc		                clc
.8918		69 02		adc #$02	                adc #2
.891a		91 24		sta ($24),y	                sta (tmp1),y
.891c		c8		iny		                iny
.891d		b1 24		lda ($24),y	                lda (tmp1),y
.891f		69 00		adc #$00	                adc #0                  ; only need carry
.8921		91 24		sta ($24),y	                sta (tmp1),y
.8923		e8		inx		                inx
.8924		e8		inx		                inx
.8925						z_value:
.8925		60		rts		z_constant:     rts
.8926						xt_count:
.8926		20 47 d9	jsr $d947	                jsr underflow_1
.8929		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.892b		a8		tay		                tay
.892c		f6 00		inc $00,x	                inc 0,x         ; LSB
.892e		d0 02		bne $8932	                bne +
.8930		f6 01		inc $01,x	                inc 1,x         ; MSB
.8932		98		tya		+               tya
.8933		ca		dex		                dex
.8934		ca		dex		                dex
.8935		95 00		sta $00,x	                sta 0,x         ; LSB
.8937		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8939		60		rts		z_count:        rts
.893a						xt_cr:
.893a		a9 0a		lda #$0a	                lda #AscLF
.893c		20 b9 8d	jsr $8db9	                jsr emit_a
.893f		60		rts		z_cr:           rts
.8940						xt_create:
.8940		20 b8 98	jsr $98b8	                jsr xt_parse_name       ; ( addr u )
.8943		b5 00		lda $00,x	                lda 0,x
.8945		15 01		ora $01,x	                ora 1,x
.8947		d0 05		bne $894e	                bne _got_name
.8949		a9 05		lda #$05	                lda #err_noname
.894b		4c 5d d9	jmp $d95d	                jmp error
.894e						_got_name:
.894e		74 01		stz $01,x	                stz 1,x
.8950		20 62 a3	jsr $a362	                jsr xt_two_dup          ; ( addr u addr u )
.8953		20 9e 8f	jsr $8f9e	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8956		b5 00		lda $00,x	                lda 0,x
.8958		15 01		ora $01,x	                ora 1,x
.895a		f0 1e		beq $897a	                beq _new_name           ; We haven't seen this one before.
.895c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.895d		e8		inx		                inx
.895e		24 20		bit $20		                bit status
.8960		10 08		bpl $896a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8962		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8964		05 20		ora $20		                ora status
.8966		85 20		sta $20		                sta status
.8968		80 18		bra $8982	                bra _process_name
.896a						_redefined_name:
.896a		a9 02		lda #$02	                lda #str_redefined
.896c		20 83 d9	jsr $d983	                jsr print_string_no_lf
.896f		20 62 a3	jsr $a362	                jsr xt_two_dup           ; ( addr u addr u )
.8972		20 ad a4	jsr $a4ad	                jsr xt_type
.8975		20 c8 a0	jsr $a0c8	                jsr xt_space
.8978		80 08		bra $8982	                bra _process_name
.897a						_new_name:
.897a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.897b		e8		inx		                inx
.897c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.897e		25 20		and $20		                and status
.8980		85 20		sta $20		                sta status
.8982						_process_name:
.8982		b5 00		lda $00,x	                lda 0,x
.8984		85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.8986		a5 00		lda $00		                lda cp
.8988		85 24		sta $24		                sta tmp1
.898a		a5 01		lda $01		                lda cp+1
.898c		85 25		sta $25		                sta tmp1+1
.898e		b5 00		lda $00,x	                lda 0,x
.8990		18		clc		                clc
.8991		69 08		adc #$08	                adc #8
.8993		85 28		sta $28		                sta tmp3                ; total header length
.8995		18		clc		                clc
.8996		69 03		adc #$03	                adc #3
.8998		95 00		sta $00,x	                sta 0,x
.899a		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.899c		20 4f 82	jsr $824f	                jsr xt_allot    ; ( addr )
.899f		20 7c d8	jsr $d87c	                jsr current_to_dp
.89a2		a0 00		ldy #$00	                ldy #0
.89a4		a5 26		lda $26		                lda tmp2
.89a6		91 24		sta ($24),y	                sta (tmp1),y
.89a8		a9 08		lda #$08	                lda #NN
.89aa		09 20		ora #$20	                ora #HC
.89ac		c8		iny		                iny
.89ad		91 24		sta ($24),y	                sta (tmp1),y
.89af		c8		iny		                iny
.89b0		a5 02		lda $02		                lda dp
.89b2		91 24		sta ($24),y	                sta (tmp1),y
.89b4		c8		iny		                iny
.89b5		a5 03		lda $03		                lda dp+1
.89b7		91 24		sta ($24),y	                sta (tmp1),y
.89b9		c8		iny		                iny
.89ba		a5 25		lda $25		                lda tmp1+1
.89bc		85 03		sta $03		                sta dp+1
.89be		a5 24		lda $24		                lda tmp1
.89c0		85 02		sta $02		                sta dp
.89c2		18		clc		                clc
.89c3		65 28		adc $28		                adc tmp3        ; add total header length
.89c5		91 24		sta ($24),y	                sta (tmp1),y
.89c7		48		pha		                pha             ; we need this in the next step
.89c8		c8		iny		                iny
.89c9		a5 25		lda $25		                lda tmp1+1
.89cb		69 00		adc #$00	                adc #0          ; only need the carry
.89cd		91 24		sta ($24),y	                sta (tmp1),y
.89cf		c8		iny		                iny
.89d0		68		pla		                pla             ; LSB of "z_" address
.89d1		18		clc		                clc
.89d2		69 03		adc #$03	                adc #3
.89d4		91 24		sta ($24),y	                sta (tmp1),y
.89d6		88		dey		                dey             ; get the MSB of xt back
.89d7		b1 24		lda ($24),y	                lda (tmp1),y
.89d9		69 00		adc #$00	                adc #0          ; only need the carry
.89db		c8		iny		                iny
.89dc		c8		iny		                iny
.89dd		91 24		sta ($24),y	                sta (tmp1),y
.89df		c8		iny		                iny
.89e0		b5 00		lda $00,x	                lda 0,x
.89e2		38		sec		                sec
.89e3		e9 08		sbc #$08	                sbc #8
.89e5		85 2c		sta $2c		                sta tmptos
.89e7		b5 01		lda $01,x	                lda 1,x
.89e9		e9 00		sbc #$00	                sbc #0          ; only need carry
.89eb		85 2d		sta $2d		                sta tmptos+1
.89ed						_name_loop:
.89ed		b1 2c		lda ($2c),y	                lda (tmptos),y
.89ef		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.89f1		b0 07		bcs $89fa	                bcs _store_name
.89f3		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.89f5		90 03		bcc $89fa	                bcc _store_name
.89f7		18		clc		                clc
.89f8		69 20		adc #$20	                adc #$20
.89fa						_store_name:
.89fa		91 24		sta ($24),y	                sta (tmp1),y
.89fc		c8		iny		                iny
.89fd		c6 26		dec $26		                dec tmp2
.89ff		d0 ec		bne $89ed	                bne _name_loop
.8a01		a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a03		91 24		sta ($24),y	                sta (tmp1),y
.8a05		c8		iny		                iny
.8a06		a9 3c		lda #$3c	                lda #<dovar
.8a08		91 24		sta ($24),y	                sta (tmp1),y
.8a0a		c8		iny		                iny
.8a0b		a9 d8		lda #$d8	                lda #>dovar
.8a0d		91 24		sta ($24),y	                sta (tmp1),y
.8a0f		20 8f d8	jsr $d88f	                jsr dp_to_current
.8a12		e8		inx		                inx
.8a13		e8		inx		                inx
.8a14		60		rts		z_create:       rts
.8a15						xt_d_minus:
.8a15		20 56 d9	jsr $d956	                jsr underflow_4 ; two double numbers
.8a18		38		sec		                sec
.8a19		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a1b		f5 02		sbc $02,x	                sbc 2,x
.8a1d		95 06		sta $06,x	                sta 6,x
.8a1f		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a21		f5 03		sbc $03,x	                sbc 3,x
.8a23		95 07		sta $07,x	                sta 7,x
.8a25		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a27		f5 00		sbc $00,x	                sbc 0,x
.8a29		95 04		sta $04,x	                sta 4,x
.8a2b		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a2d		f5 01		sbc $01,x	                sbc 1,x
.8a2f		95 05		sta $05,x	                sta 5,x
.8a31		e8		inx		                inx
.8a32		e8		inx		                inx
.8a33		e8		inx		                inx
.8a34		e8		inx		                inx
.8a35		60		rts		z_d_minus:      rts
.8a36						xt_d_plus:
.8a36		20 56 d9	jsr $d956	                jsr underflow_4 ; two double numbers
.8a39		18		clc		                clc
.8a3a		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a3c		75 06		adc $06,x	                adc 6,x
.8a3e		95 06		sta $06,x	                sta 6,x
.8a40		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a42		75 07		adc $07,x	                adc 7,x
.8a44		95 07		sta $07,x	                sta 7,x
.8a46		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a48		75 04		adc $04,x	                adc 4,x
.8a4a		95 04		sta $04,x	                sta 4,x
.8a4c		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a4e		75 05		adc $05,x	                adc 5,x
.8a50		95 05		sta $05,x	                sta 5,x
.8a52		e8		inx		                inx
.8a53		e8		inx		                inx
.8a54		e8		inx		                inx
.8a55		e8		inx		                inx
.8a56		60		rts		z_d_plus:       rts
.8a57						xt_d_to_s:
.8a57		20 4c d9	jsr $d94c	                jsr underflow_2
.8a5a		e8		inx		                inx
.8a5b		e8		inx		                inx
.8a5c		60		rts		z_d_to_s:       rts
.8a5d						xt_dabs:
.8a5d		20 4c d9	jsr $d94c	                jsr underflow_2 ; double number
.8a60		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a62		10 17		bpl $8a7b	                bpl _done       ; positive, we get off light
.8a64		a0 00		ldy #$00	                ldy #0
.8a66		38		sec		                sec
.8a67		98		tya		                tya
.8a68		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a6a		95 02		sta $02,x	                sta 2,x
.8a6c		98		tya		                tya
.8a6d		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a6f		95 03		sta $03,x	                sta 3,x
.8a71		98		tya		                tya
.8a72		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a74		95 00		sta $00,x	                sta 0,x
.8a76		98		tya		                tya
.8a77		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a79		95 01		sta $01,x	                sta 1,x
.8a7b						_done:
.8a7b		60		rts		z_dabs:         rts
.8a7c						xt_decimal:
.8a7c		a9 0a		lda #$0a	                lda #10
.8a7e		85 18		sta $18		                sta base
.8a80		64 19		stz $19		                stz base+1              ; paranoid
.8a82		60		rts		z_decimal:      rts
.8a83						xt_defer:
.8a83		20 40 89	jsr $8940	                jsr xt_create
.8a86		a5 00		lda $00		                lda cp          ; LSB
.8a88		38		sec		                sec
.8a89		e9 02		sbc #$02	                sbc #2
.8a8b		85 24		sta $24		                sta tmp1
.8a8d		a5 01		lda $01		                lda cp+1        ; MSB
.8a8f		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8a91		85 25		sta $25		                sta tmp1+1
.8a93		a0 00		ldy #$00	                ldy #0
.8a95		a9 0a		lda #$0a	                lda #<dodefer   ; LSB
.8a97		91 24		sta ($24),y	                sta (tmp1),y
.8a99		c8		iny		                iny
.8a9a		a9 d8		lda #$d8	                lda #>dodefer   ; MSB
.8a9c		91 24		sta ($24),y	                sta (tmp1),y
.8a9e		a9 1e		lda #$1e	                lda #<defer_error
.8aa0		92 00		sta ($00)	                sta (cp)
.8aa2		e6 00		inc $00		                inc cp
.8aa4		d0 02		bne $8aa8	                bne +
.8aa6		e6 01		inc $01		                inc cp+1
.8aa8						+
.8aa8		a9 d8		lda #$d8	                lda #>defer_error
.8aaa		92 00		sta ($00)	                sta (cp)
.8aac		e6 00		inc $00		                inc cp
.8aae		d0 02		bne $8ab2	                bne +
.8ab0		e6 01		inc $01		                inc cp+1
.8ab2						+
.8ab2		20 08 89	jsr $8908	                jsr adjust_z    ; adjust header to correct length
.8ab5		60		rts		z_defer:        rts
.8ab6						xt_defer_fetch:
.8ab6		20 37 a2	jsr $a237	                jsr xt_to_body
.8ab9		20 43 8f	jsr $8f43	                jsr xt_fetch
.8abc		60		rts		z_defer_fetch:  rts
.8abd						xt_defer_store:
.8abd		20 37 a2	jsr $a237	                jsr xt_to_body
.8ac0		20 37 a1	jsr $a137	                jsr xt_store
.8ac3		60		rts		z_defer_store:  rts
.8ac4						xt_definitions:
.8ac4		a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8ac6		b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8ac8		a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8aca		91 1e		sta ($1e),y	                sta (up),y
.8acc		60		rts		z_definitions:  rts
.8acd						xt_depth:
.8acd		a9 78		lda #$78	                lda #dsp0
.8acf		86 2a		stx $2a		                stx tmpdsp
.8ad1		38		sec		                sec
.8ad2		e5 2a		sbc $2a		                sbc tmpdsp
.8ad4		4a		lsr a		                lsr
.8ad5		ca		dex		                dex
.8ad6		ca		dex		                dex
.8ad7		95 00		sta $00,x	                sta 0,x
.8ad9		74 01		stz $01,x	                stz 1,x
.8adb		60		rts		z_depth:        rts
.8adc						xt_digit_question:
.8adc		20 47 d9	jsr $d947	                jsr underflow_1
.8adf		ca		dex		                dex
.8ae0		ca		dex		                dex
.8ae1		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8ae3		74 01		stz $01,x	                stz 1,x
.8ae5		74 03		stz $03,x	                stz 3,x                 ; paranoid
.8ae7		b5 02		lda $02,x	                lda 2,x
.8ae9		c9 30		cmp #$30	                cmp #'0'
.8aeb		90 23		bcc $8b10	                bcc _done               ; failure flag already set
.8aed		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8aef		90 12		bcc $8b03	                bcc _checkbase
.8af1		c9 41		cmp #$41	                cmp #'A'
.8af3		90 1b		bcc $8b10	                bcc _done               ; failure flag is already set
.8af5		c9 61		cmp #$61	                cmp #'a'
.8af7		90 07		bcc $8b00	                bcc _case_done          ; not lower case, too low
.8af9		c9 7b		cmp #$7b	                cmp #'z'+1
.8afb		b0 03		bcs $8b00	                bcs _case_done          ; not lower case, too high
.8afd		18		clc		                clc                     ; just right
.8afe		69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b00						_case_done:
.8b00		38		sec		                sec
.8b01		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b03						_checkbase:
.8b03		38		sec		                sec
.8b04		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b06		c5 18		cmp $18		                cmp base
.8b08		b0 06		bcs $8b10	                bcs _done               ; already have false flag
.8b0a		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b0c		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b0e		d6 01		dec $01,x	                dec 1,x
.8b10						_done:
.8b10						z_digit_question:
.8b10		60		rts		                rts
.8b11						xt_disasm:
.8b11		20 4c d9	jsr $d94c	                jsr underflow_2
.8b14		20 d1 ac	jsr $acd1	                jsr disassembler
.8b17		60		rts		z_disasm:       rts
.8b18						xt_dnegate:
.8b18		20 4c d9	jsr $d94c	                jsr underflow_2 ; double number
.8b1b		a0 00		ldy #$00	     		ldy #0
.8b1d		38		sec		                sec
.8b1e		98		tya		                tya
.8b1f		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b21		95 02		sta $02,x	                sta 2,x
.8b23		98		tya		                tya
.8b24		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b26		95 03		sta $03,x	                sta 3,x
.8b28		98		tya		                tya
.8b29		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b2b		95 00		sta $00,x	                sta 0,x
.8b2d		98		tya		                tya
.8b2e		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b30		95 01		sta $01,x	                sta 1,x
.8b32		60		rts		z_dnegate:      rts
.8b33						xt_question_do:
.8b33		a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b35		85 24		sta $24		                sta tmp1
.8b37		80 02		bra $8b3b	                bra do_common           ; skip flag for DO
.8b39						xt_do:
.8b39		64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b3b						do_common:
.8b3b		ca		dex		                dex
.8b3c		ca		dex		                dex
.8b3d		a5 01		lda $01		                lda cp+1
.8b3f		95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b41		a5 00		lda $00		                lda cp
.8b43		95 00		sta $00,x	                sta 0,x                 ; LSB
.8b45		18		clc		                clc
.8b46		69 06		adc #$06	                adc #6
.8b48		85 00		sta $00		                sta cp
.8b4a		90 02		bcc $8b4e	                bcc +
.8b4c		e6 01		inc $01		                inc cp+1
.8b4e						+
.8b4e		a5 24		lda $24		                lda tmp1
.8b50		f0 0f		beq $8b61	                beq _compile_do
.8b52		ca		dex		                dex
.8b53		ca		dex		                dex
.8b54		a9 a4		lda #$a4	                lda #<question_do_runtime
.8b56		95 00		sta $00,x	                sta 0,x
.8b58		a9 8b		lda #$8b	                lda #>question_do_runtime
.8b5a		95 01		sta $01,x	                sta 1,x
.8b5c		a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b5e		20 9d 88	jsr $889d	                jsr cmpl_inline_y
.8b61						_compile_do:
.8b61		a0 8b		ldy #$8b	                ldy #>do_runtime
.8b63		a9 73		lda #$73	                lda #<do_runtime
.8b65		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.8b68		ca		dex		                dex
.8b69		ca		dex		                dex
.8b6a		a5 00		lda $00		                lda CP          ; LSB
.8b6c		95 00		sta $00,x	                sta 0,x
.8b6e		a5 01		lda $01		                lda CP+1        ; MSB
.8b70		95 01		sta $01,x	                sta 1,x
.8b72						z_question_do:
.8b72		60		rts		z_do:           rts
.8b73						do_runtime:
.8b73		68		pla		                pla
.8b74		85 24		sta $24		                sta tmp1
.8b76		68		pla		                pla
.8b77		85 25		sta $25		                sta tmp1+1
.8b79		38		sec		                sec
.8b7a		a9 00		lda #$00	                lda #0
.8b7c		f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8b7e		95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8b80		a9 80		lda #$80	                lda #$80
.8b82		f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8b84		95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8b86		48		pha		                pha             ; FUFA replaces limit on R stack
.8b87		b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8b89		48		pha		                pha
.8b8a		18		clc		                clc
.8b8b		b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8b8d		75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8b8f		95 00		sta $00,x	                sta 0,x
.8b91		b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8b93		75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8b95		48		pha		                pha
.8b96		b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8b98		48		pha		                pha
.8b99		e8		inx		                inx
.8b9a		e8		inx		                inx
.8b9b		e8		inx		                inx
.8b9c		e8		inx		                inx
.8b9d		a5 25		lda $25		                lda tmp1+1
.8b9f		48		pha		                pha
.8ba0		a5 24		lda $24		                lda tmp1
.8ba2		48		pha		                pha
.8ba3		60		rts		                rts
.8ba4						question_do_runtime:
.8ba4		20 62 a3	jsr $a362	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8ba7		20 91 8e	jsr $8e91	                jsr xt_equal            ; ( -- n1 n2 f )
.8baa		b5 00		lda $00,x	                lda 0,x
.8bac		15 01		ora $01,x	                ora 1,x
.8bae		f0 06		beq $8bb6	                beq _do_do
.8bb0		8a		txa		                txa
.8bb1		18		clc		                clc
.8bb2		69 06		adc #$06	                adc #6
.8bb4		aa		tax		                tax
.8bb5		60		rts		                rts
.8bb6						_do_do:
.8bb6		e8		inx		                inx             ; clear flag from EQUAL off stack
.8bb7		e8		inx		                inx             ; no RTS because this is copied into code
.8bb8						question_do_runtime_end:
.8bb8						xt_does:
.8bb8		a0 8b		ldy #$8b	                ldy #>does_runtime
.8bba		a9 c7		lda #$c7	                lda #<does_runtime
.8bbc		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.8bbf		a0 d8		ldy #$d8	                ldy #>dodoes
.8bc1		a9 23		lda #$23	                lda #<dodoes
.8bc3		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.8bc6		60		rts		z_does:         rts
.8bc7						does_runtime:
.8bc7		7a		ply		                ply             ; LSB
.8bc8		68		pla		                pla             ; MSB
.8bc9		c8		iny		                iny
.8bca		d0 01		bne $8bcd	                bne +
.8bcc		1a		inc a		                ina
.8bcd						+
.8bcd		84 24		sty $24		                sty tmp1
.8bcf		85 25		sta $25		                sta tmp1+1
.8bd1		20 7c d8	jsr $d87c	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8bd4		a5 02		lda $02		                lda dp
.8bd6		18		clc		                clc
.8bd7		69 04		adc #$04	                adc #4
.8bd9		85 26		sta $26		                sta tmp2
.8bdb		a5 03		lda $03		                lda dp+1
.8bdd		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bdf		85 27		sta $27		                sta tmp2+1
.8be1		b2 26		lda ($26)	                lda (tmp2)
.8be3		18		clc		                clc
.8be4		69 01		adc #$01	                adc #1
.8be6		85 28		sta $28		                sta tmp3
.8be8		a0 01		ldy #$01	                ldy #1
.8bea		b1 26		lda ($26),y	                lda (tmp2),y
.8bec		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bee		85 29		sta $29		                sta tmp3+1
.8bf0		a5 24		lda $24		                lda tmp1        ; LSB
.8bf2		92 28		sta ($28)	                sta (tmp3)
.8bf4		a5 25		lda $25		                lda tmp1+1
.8bf6		91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8bf8		60		rts		                rts
.8bf9						xt_dot:
.8bf9		20 47 d9	jsr $d947	                jsr underflow_1
.8bfc		20 72 8d	jsr $8d72	                jsr xt_dup                      ; ( n n )
.8bff		20 dd 80	jsr $80dd	                jsr xt_abs                      ; ( n u )
.8c02		20 52 a7	jsr $a752	                jsr xt_zero                     ; ( n u 0 )
.8c05		20 1b 93	jsr $931b	                jsr xt_less_number_sign         ; ( n u 0 )
.8c08		20 b7 97	jsr $97b7	                jsr xt_number_sign_s            ; ( n ud )
.8c0b		20 30 9b	jsr $9b30	                jsr xt_rot                      ; ( ud n )
.8c0e		20 91 9f	jsr $9f91	                jsr xt_sign                     ; ( ud )
.8c11		20 95 97	jsr $9795	                jsr xt_number_sign_greater      ; ( addr u )
.8c14		20 ad a4	jsr $a4ad	                jsr xt_type
.8c17		20 c8 a0	jsr $a0c8	                jsr xt_space
.8c1a		60		rts		z_dot:          rts
.8c1b						xt_dot_paren:
.8c1b		ca		dex		                dex
.8c1c		ca		dex		                dex
.8c1d		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c1f		95 00		sta $00,x	                sta 0,x
.8c21		74 01		stz $01,x	                stz 1,x
.8c23		20 13 99	jsr $9913	                jsr xt_parse
.8c26		20 ad a4	jsr $a4ad	                jsr xt_type
.8c29		60		rts		z_dot_paren:    rts
.8c2a						xt_dot_quote:
.8c2a		20 28 9d	jsr $9d28	                jsr xt_s_quote
.8c2d		a0 a4		ldy #$a4	                ldy #>xt_type
.8c2f		a9 ad		lda #$ad	                lda #<xt_type
.8c31		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.8c34		60		rts		z_dot_quote:    rts
.8c35						xt_dot_r:
.8c35		20 4c d9	jsr $d94c	                jsr underflow_2
.8c38		20 1a a3	jsr $a31a	                jsr xt_to_r
.8c3b		20 72 8d	jsr $8d72	                jsr xt_dup
.8c3e		20 dd 80	jsr $80dd	                jsr xt_abs
.8c41		20 52 a7	jsr $a752	                jsr xt_zero
.8c44		20 1b 93	jsr $931b	                jsr xt_less_number_sign
.8c47		20 b7 97	jsr $97b7	                jsr xt_number_sign_s
.8c4a		20 30 9b	jsr $9b30	                jsr xt_rot
.8c4d		20 91 9f	jsr $9f91	                jsr xt_sign
.8c50		20 95 97	jsr $9795	                jsr xt_number_sign_greater
.8c53		20 6b 9a	jsr $9a6b	                jsr xt_r_from
.8c56		20 6c 98	jsr $986c	                jsr xt_over
.8c59		20 29 95	jsr $9529	                jsr xt_minus
.8c5c		20 ce a0	jsr $a0ce	                jsr xt_spaces
.8c5f		20 ad a4	jsr $a4ad	                jsr xt_type
.8c62		60		rts		z_dot_r:        rts
.8c63						xt_dot_s:
.8c63		20 cd 8a	jsr $8acd	                jsr xt_depth    ; ( -- u )
.8c66		a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c68		20 b9 8d	jsr $8db9	                jsr emit_a
.8c6b		b5 00		lda $00,x	                lda 0,x
.8c6d		48		pha		                pha
.8c6e		ca		dex		                dex             ; DUP
.8c6f		ca		dex		                dex
.8c70		95 00		sta $00,x	                sta 0,x
.8c72		74 01		stz $01,x	                stz 1,x
.8c74		20 b4 d9	jsr $d9b4	                jsr print_u
.8c77		a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8c79		20 b9 8d	jsr $8db9	                jsr emit_a
.8c7c		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8c7e		20 b9 8d	jsr $8db9	                jsr emit_a
.8c81		e8		inx		                inx
.8c82		e8		inx		                inx
.8c83		e0 78		cpx #$78	                cpx #dsp0
.8c85		f0 1e		beq $8ca5	                beq _done
.8c87						_have_stack:
.8c87		7a		ply		                ply
.8c88		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8c8a		85 28		sta $28		                sta tmp3
.8c8c		64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8c8e						_loop:
.8c8e		ca		dex		                dex
.8c8f		ca		dex		                dex
.8c90		b2 28		lda ($28)	                lda (tmp3)
.8c92		95 01		sta $01,x	                sta 1,x
.8c94		c6 28		dec $28		                dec tmp3
.8c96		b2 28		lda ($28)	                lda (tmp3)
.8c98		95 00		sta $00,x	                sta 0,x
.8c9a		c6 28		dec $28		                dec tmp3
.8c9c		5a		phy		                phy
.8c9d		20 f9 8b	jsr $8bf9	                jsr xt_dot
.8ca0		7a		ply		                ply
.8ca1		88		dey		                dey
.8ca2		d0 ea		bne $8c8e	                bne _loop
.8ca4		48		pha		                pha             ; dummy to balance stack
.8ca5						_done:
.8ca5		68		pla		                pla
.8ca6		60		rts		z_dot_s:        rts
.8ca7						xt_d_dot:
.8ca7		20 4c d9	jsr $d94c	                jsr underflow_2
.8caa		20 37 a3	jsr $a337	                jsr xt_tuck
.8cad		20 5d 8a	jsr $8a5d	                jsr xt_dabs
.8cb0		20 1b 93	jsr $931b	                jsr xt_less_number_sign
.8cb3		20 b7 97	jsr $97b7	                jsr xt_number_sign_s
.8cb6		20 30 9b	jsr $9b30	                jsr xt_rot
.8cb9		20 91 9f	jsr $9f91	                jsr xt_sign
.8cbc		20 95 97	jsr $9795	                jsr xt_number_sign_greater
.8cbf		20 ad a4	jsr $a4ad	                jsr xt_type
.8cc2		20 c8 a0	jsr $a0c8	                jsr xt_space
.8cc5		60		rts		z_d_dot:        rts
.8cc6						xt_d_dot_r:
.8cc6		20 51 d9	jsr $d951	                jsr underflow_3
.8cc9		20 1a a3	jsr $a31a	                jsr xt_to_r
.8ccc		20 37 a3	jsr $a337	                jsr xt_tuck
.8ccf		20 5d 8a	jsr $8a5d	                jsr xt_dabs
.8cd2		20 1b 93	jsr $931b	                jsr xt_less_number_sign
.8cd5		20 b7 97	jsr $97b7	                jsr xt_number_sign_s
.8cd8		20 30 9b	jsr $9b30	                jsr xt_rot
.8cdb		20 91 9f	jsr $9f91	                jsr xt_sign
.8cde		20 95 97	jsr $9795	                jsr xt_number_sign_greater
.8ce1		20 6b 9a	jsr $9a6b	                jsr xt_r_from
.8ce4		20 6c 98	jsr $986c	                jsr xt_over
.8ce7		20 29 95	jsr $9529	                jsr xt_minus
.8cea		20 ce a0	jsr $a0ce	                jsr xt_spaces
.8ced		20 ad a4	jsr $a4ad	                jsr xt_type
.8cf0		60		rts		z_d_dot_r:      rts
.8cf1						xt_drop:
.8cf1		20 47 d9	jsr $d947	                jsr underflow_1
.8cf4		e8		inx		                inx
.8cf5		e8		inx		                inx
.8cf6		60		rts		z_drop:         rts
.8cf7						xt_dump:
.8cf7		20 4c d9	jsr $d94c	                jsr underflow_2
.8cfa						_row:
.8cfa		a0 10		ldy #$10	                ldy #16
.8cfc		64 26		stz $26		                stz tmp2
.8cfe		20 3a 89	jsr $893a	                jsr xt_cr
.8d01		b5 03		lda $03,x	                lda 3,x
.8d03		20 4a d8	jsr $d84a	                jsr byte_to_ascii
.8d06		b5 02		lda $02,x	                lda 2,x
.8d08		20 4a d8	jsr $d84a	                jsr byte_to_ascii
.8d0b		20 c8 a0	jsr $a0c8	                jsr xt_space
.8d0e		20 c8 a0	jsr $a0c8	                jsr xt_space
.8d11						_loop:
.8d11		b5 00		lda $00,x	                lda 0,x
.8d13		15 01		ora $01,x	                ora 1,x
.8d15		f0 39		beq $8d50	                beq _all_printed
.8d17		a1 02		lda ($02,x)	                lda (2,x)
.8d19		48		pha		                pha                     ; byte_to_ascii destroys A
.8d1a		20 4a d8	jsr $d84a	                jsr byte_to_ascii
.8d1d		20 c8 a0	jsr $a0c8	                jsr xt_space
.8d20		68		pla		                pla
.8d21		20 2d d9	jsr $d92d	                jsr is_printable
.8d24		b0 02		bcs $8d28	                bcs _printable
.8d26		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d28						_printable:
.8d28		5a		phy		                phy                     ; save counter
.8d29		a4 26		ldy $26		                ldy tmp2
.8d2b		91 00		sta ($00),y	                sta (cp),y
.8d2d		e6 26		inc $26		                inc tmp2
.8d2f		7a		ply		                ply
.8d30		c0 09		cpy #$09	                cpy #9
.8d32		d0 03		bne $8d37	                bne _next_char
.8d34		20 c8 a0	jsr $a0c8	                jsr xt_space
.8d37						_next_char:
.8d37		f6 02		inc $02,x	                inc 2,x
.8d39		d0 02		bne $8d3d	                bne _counter
.8d3b		f6 03		inc $03,x	                inc 3,x
.8d3d						_counter:
.8d3d		b5 00		lda $00,x	                lda 0,x
.8d3f		d0 02		bne $8d43	                bne +
.8d41		d6 01		dec $01,x	                dec 1,x
.8d43						+
.8d43		d6 00		dec $00,x	                dec 0,x
.8d45		88		dey		                dey
.8d46		d0 c9		bne $8d11	                bne _loop               ; next byte
.8d48		20 c8 a0	jsr $a0c8	                jsr xt_space
.8d4b		20 5e 8d	jsr $8d5e	                jsr dump_print_ascii
.8d4e		80 aa		bra $8cfa	                bra _row                ; new row
.8d50						_all_printed:
.8d50		a5 26		lda $26		                lda tmp2
.8d52		f0 06		beq $8d5a	                beq _done
.8d54		20 c8 a0	jsr $a0c8	                jsr xt_space
.8d57		20 5e 8d	jsr $8d5e	                jsr dump_print_ascii
.8d5a						_done:
.8d5a		20 5a a3	jsr $a35a	                jsr xt_two_drop         ; one byte less than 4x INX
.8d5d		60		rts		z_dump:         rts
.8d5e						dump_print_ascii:
.8d5e		a0 00		ldy #$00	                ldy #0
.8d60						_ascii_loop:
.8d60		b1 00		lda ($00),y	                lda (cp),y
.8d62		20 b9 8d	jsr $8db9	                jsr emit_a
.8d65		c8		iny		                iny
.8d66		c0 08		cpy #$08	                cpy #8
.8d68		d0 03		bne $8d6d	                bne +
.8d6a		20 c8 a0	jsr $a0c8	                jsr xt_space
.8d6d						+
.8d6d		c6 26		dec $26		                dec tmp2
.8d6f		d0 ef		bne $8d60	                bne _ascii_loop
.8d71		60		rts		                rts
.8d72						xt_dup:
.8d72		20 47 d9	jsr $d947	                jsr underflow_1
.8d75		ca		dex		                dex
.8d76		ca		dex		                dex
.8d77		b5 02		lda $02,x	                lda 2,x         ; LSB
.8d79		95 00		sta $00,x	                sta 0,x
.8d7b		b5 03		lda $03,x	                lda 3,x         ; MSB
.8d7d		95 01		sta $01,x	                sta 1,x
.8d7f		60		rts		z_dup:          rts
.8d80						xt_ed:
.8d80		20 dd b5	jsr $b5dd	                jsr ed6502      ; kept in separate file
.8d83		60		rts		z_ed:           rts
.8d84						xt_else:
.8d84						xt_endof:
.8d84		a0 8d		ldy #$8d	                ldy #>branch_runtime
.8d86		a9 9e		lda #$9e	                lda #<branch_runtime
.8d88		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.8d8b		20 35 91	jsr $9135	                jsr xt_here
.8d8e		20 52 a7	jsr $a752	                jsr xt_zero
.8d91		20 34 87	jsr $8734	                jsr xt_comma
.8d94		20 35 91	jsr $9135	                jsr xt_here
.8d97		20 30 9b	jsr $9b30	                jsr xt_rot
.8d9a		20 37 a1	jsr $a137	                jsr xt_store
.8d9d						z_else:
.8d9d						z_endof:
.8d9d		60		rts		                rts
.8d9e						branch_runtime:
.8d9e		68		pla		                pla
.8d9f		85 22		sta $22		                sta tmpbranch
.8da1		68		pla		                pla
.8da2		85 23		sta $23		                sta tmpbranch+1
.8da4		a0 01		ldy #$01	                ldy #1
.8da6		b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8da8		85 24		sta $24		                sta tmp1
.8daa		c8		iny		                iny
.8dab		b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8dad		85 25		sta $25		                sta tmp1+1
.8daf		6c 24 00	jmp ($0024)	                jmp (tmp1)
.8db2						xt_emit:
.8db2		20 47 d9	jsr $d947	                jsr underflow_1
.8db5		b5 00		lda $00,x	                lda 0,x
.8db7		e8		inx		                inx
.8db8		e8		inx		                inx
.8db9						emit_a:
.8db9		6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8dbc						z_emit:
.8dbc						xt_empty_buffers:
.8dbc		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8dbe		a9 00		lda #$00	                lda #0
.8dc0		91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8dc2						z_empty_buffers:
.8dc2		60		rts		                rts
.8dc3						xt_endcase:
.8dc3		a0 8c		ldy #$8c	                ldy #>xt_drop
.8dc5		a9 f1		lda #$f1	                lda #<xt_drop
.8dc7		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.8dca						_endcase_loop:
.8dca		b5 00		lda $00,x	                lda 0,x
.8dcc		15 01		ora $01,x	                ora 1,x
.8dce		f0 05		beq $8dd5	                beq _done
.8dd0		20 6c a1	jsr $a16c	                jsr xt_then
.8dd3		80 f5		bra $8dca	                bra _endcase_loop
.8dd5						_done:
.8dd5		e8		inx		                inx
.8dd6		e8		inx		                inx
.8dd7		60		rts		z_endcase:      rts
.8dd8						xt_environment_q:
.8dd8		20 47 d9	jsr $d947	                jsr underflow_1
.8ddb		a0 00		ldy #$00	                ldy #00                 ; counter for table
.8ddd		5a		phy		                phy
.8dde						_table_loop:
.8dde		20 62 a3	jsr $a362	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8de1		ca		dex		                dex
.8de2		ca		dex		                dex                     ; ( addr u addr u ? )
.8de3		b9 55 8e	lda $8e55,y	                lda env_table_single,y
.8de6		95 00		sta $00,x	                sta 0,x
.8de8		c8		iny		                iny
.8de9		b9 55 8e	lda $8e55,y	                lda env_table_single,y
.8dec		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8dee		c8		iny		                iny
.8def		15 00		ora $00,x	                ora 0,x
.8df1		f0 4d		beq $8e40	                beq _table_done
.8df3		5a		phy		                phy                     ; save Y, which is used by COUNT
.8df4		20 26 89	jsr $8926	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8df7		20 4e 87	jsr $874e	                jsr xt_compare          ; ( addr u f )
.8dfa		7a		ply		                ply
.8dfb		b5 00		lda $00,x	                lda 0,x
.8dfd		15 01		ora $01,x	                ora 1,x
.8dff		f0 04		beq $8e05	                beq _got_result
.8e01		e8		inx		                inx                     ; DROP, now ( addr u )
.8e02		e8		inx		                inx
.8e03		80 d9		bra $8dde	                bra _table_loop
.8e05						_got_result:
.8e05		e8		inx		                inx                     ; drop flag, now ( addr u )
.8e06		e8		inx		                inx
.8e07		88		dey		                dey                     ; go back to index we had
.8e08		88		dey		                dey
.8e09		68		pla		                pla
.8e0a		d0 0d		bne $8e19	                bne _double_result
.8e0c		b9 73 8e	lda $8e73,y	                lda env_results_single,y
.8e0f		95 02		sta $02,x	                sta 2,x
.8e11		c8		iny		                iny
.8e12		b9 73 8e	lda $8e73,y	                lda env_results_single,y
.8e15		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e17		80 1f		bra $8e38	                bra _set_flag
.8e19						_double_result:
.8e19		ca		dex		                dex                     ; ( addr u ? )
.8e1a		ca		dex		                dex
.8e1b		98		tya		                tya
.8e1c		38		sec		                sec
.8e1d		e9 18		sbc #$18	                sbc #24
.8e1f		0a		asl a		                asl
.8e20		a8		tay		                tay
.8e21		b9 89 8e	lda $8e89,y	                lda env_results_double,y
.8e24		95 02		sta $02,x	                sta 2,x
.8e26		c8		iny		                iny
.8e27		b9 89 8e	lda $8e89,y	                lda env_results_double,y
.8e2a		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e2c		c8		iny		                iny
.8e2d		b9 89 8e	lda $8e89,y	                lda env_results_double,y
.8e30		95 04		sta $04,x	                sta 4,x
.8e32		c8		iny		                iny
.8e33		b9 89 8e	lda $8e89,y	                lda env_results_double,y
.8e36		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e38						_set_flag:
.8e38		a9 ff		lda #$ff	                lda #$ff
.8e3a		95 00		sta $00,x	                sta 0,x
.8e3c		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e3e		80 14		bra $8e54	                bra _done
.8e40						_table_done:
.8e40		68		pla		                pla
.8e41		d0 09		bne $8e4c	                bne _no_match
.8e43		1a		inc a		                ina
.8e44		48		pha		                pha
.8e45		8a		txa		                txa
.8e46		18		clc		                clc
.8e47		69 06		adc #$06	                adc #6                  ; skip six bytes
.8e49		aa		tax		                tax                     ; ( addr u )
.8e4a		80 92		bra $8dde	                bra _table_loop
.8e4c						_no_match:
.8e4c		8a		txa		                txa
.8e4d		18		clc		                clc
.8e4e		69 0a		adc #$0a	                adc #10
.8e50		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e51		20 3c 8f	jsr $8f3c	                jsr xt_false
.8e54						_done:
.8e54						z_environment_q:
.8e54		60		rts		                rts
.8e55						env_table_single:
>8e55		5d d7 6d d7 73 d7 78 d7		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e5d		8a d7
>8e5f		92 d7 9b d7 a1 d7 a7 d7		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e67		ba d7 c6 d7 00 00		        .word envs_sc, envs_wl, 0000
.8e6d						env_table_double:
>8e6d		d0 d7 d6 d7 00 00		        .word envs_max_d, envs_max_ud, 0000
.8e73						env_results_single:
>8e73		ff 00				        .word $00FF     ; /COUNTED-STRING
>8e75		ff 00				        .word $00FF     ; /HOLD
>8e77		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8e79		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8e7b		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8e7d		ff 00				        .word $00FF     ; MAX-CHAR
>8e7f		ff 7f				        .word $7FFF     ; MAX-N
>8e81		ff ff				        .word $FFFF     ; MAX-U
>8e83		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8e85		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8e87		09 00				        .word $0009     ; WORDLISTS
.8e89						env_results_double:
>8e89		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8e8d		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8e91						xt_equal:
.8e91		20 4c d9	jsr $d94c	                jsr underflow_2
.8e94		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8e96		d5 02		cmp $02,x	                cmp 2,x
.8e98		d0 0a		bne $8ea4	                bne _false
.8e9a		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8e9c		d5 03		cmp $03,x	                cmp 3,x
.8e9e		d0 04		bne $8ea4	                bne _false
.8ea0		a9 ff		lda #$ff	                lda #$ff
.8ea2		80 02		bra $8ea6	                bra _done
.8ea4		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8ea6		95 02		sta $02,x	_done:          sta 2,x
.8ea8		95 03		sta $03,x	                sta 3,x
.8eaa		e8		inx		                inx
.8eab		e8		inx		                inx
.8eac		60		rts		z_equal:        rts
.8ead						xt_blank:
.8ead		ca		dex		                dex
.8eae		ca		dex		                dex
.8eaf		a9 20		lda #$20	                lda #AscSP
.8eb1		95 00		sta $00,x	                sta 0,x
.8eb3		74 01		stz $01,x	                stz 1,x
.8eb5		80 06		bra $8ebd	                bra xt_fill     ; skip over code for ERASE
.8eb7						xt_erase:
.8eb7		ca		dex		                dex
.8eb8		ca		dex		                dex
.8eb9		74 00		stz $00,x	                stz 0,x
.8ebb		74 01		stz $01,x	                stz 1,x
.8ebd						xt_fill:
.8ebd		20 51 d9	jsr $d951	                jsr underflow_3
.8ec0		b5 04		lda $04,x	                lda 4,x         ; LSB
.8ec2		85 24		sta $24		                sta tmp1
.8ec4		b5 05		lda $05,x	                lda 5,x
.8ec6		85 25		sta $25		                sta tmp1+1
.8ec8		b5 02		lda $02,x	                lda 2,x
.8eca		85 26		sta $26		                sta tmp2
.8ecc		b5 03		lda $03,x	                lda 3,x
.8ece		85 27		sta $27		                sta tmp2+1
.8ed0		b5 00		lda $00,x	                lda 0,x
.8ed2		a8		tay		                tay
.8ed3						_loop:
.8ed3		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8ed5		c5 25		cmp $25		                cmp tmp1+1
.8ed7		90 21		bcc $8efa	                bcc _done               ; RAM_END < TMP1, so leave
.8ed9		d0 06		bne $8ee1	                bne _check_counter      ; RAM_END is not smaller and not equal
.8edb		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8edd		c5 24		cmp $24		                cmp tmp1
.8edf		90 19		bcc $8efa	                bcc _done               ; RAM_END < TMP1, so leave
.8ee1						_check_counter:
.8ee1		a5 26		lda $26		                lda tmp2
.8ee3		05 27		ora $27		                ora tmp2+1
.8ee5		f0 13		beq $8efa	                beq _done
.8ee7		98		tya		                tya
.8ee8		92 24		sta ($24)	                sta (tmp1)
.8eea		a5 26		lda $26		                lda tmp2
.8eec		d0 02		bne $8ef0	                bne +
.8eee		c6 27		dec $27		                dec tmp2+1
.8ef0		c6 26		dec $26		+               dec tmp2
.8ef2		e6 24		inc $24		                inc tmp1
.8ef4		d0 dd		bne $8ed3	                bne _loop
.8ef6		e6 25		inc $25		                inc tmp1+1
.8ef8		80 d9		bra $8ed3	                bra _loop
.8efa						_done:
.8efa		8a		txa		                txa
.8efb		18		clc		                clc
.8efc		69 06		adc #$06	                adc #6
.8efe		aa		tax		                tax
.8eff						z_blank:
.8eff						z_erase:
.8eff		60		rts		z_fill:         rts
.8f00						xt_execute:
.8f00		20 47 d9	jsr $d947	                jsr underflow_1
.8f03		20 07 8f	jsr $8f07	                jsr doexecute   ; do not combine to JMP (native coding)
.8f06		60		rts		z_execute:      rts
.8f07						doexecute:
.8f07		b5 00		lda $00,x	                lda 0,x
.8f09		85 0e		sta $0e		                sta ip
.8f0b		b5 01		lda $01,x	                lda 1,x
.8f0d		85 0f		sta $0f		                sta ip+1
.8f0f		e8		inx		                inx
.8f10		e8		inx		                inx
.8f11		6c 0e 00	jmp ($000e)	                jmp (ip)
.8f14						xt_execute_parsing:
.8f14		20 51 d9	jsr $d951	                jsr underflow_3
.8f17		20 23 92	jsr $9223	                jsr xt_input_to_r       ; save normal input for later
.8f1a		20 47 96	jsr $9647	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f1d		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f1f		85 0a		sta $0a		                sta ciblen
.8f21		b5 01		lda $01,x	                lda 1,x
.8f23		85 0b		sta $0b		                sta ciblen+1
.8f25		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f27		85 08		sta $08		                sta cib
.8f29		b5 03		lda $03,x	                lda 3,x
.8f2b		85 09		sta $09		                sta cib+1
.8f2d		64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f2f		64 0d		stz $0d		                stz toin+1
.8f31		20 5a a3	jsr $a35a	                jsr xt_two_drop         ; 2DROP ( xt )
.8f34		20 00 8f	jsr $8f00	                jsr xt_execute
.8f37		20 7c 9a	jsr $9a7c	                jsr xt_r_to_input
.8f3a						z_execute_parsing:
.8f3a		60		rts		                rts
.8f3b						xt_exit:
.8f3b		60		rts		                rts             ; keep before z_exit
.8f3c						z_exit:
.8f3c						xt_false:
.8f3c		ca		dex		                dex
.8f3d		ca		dex		                dex
.8f3e		74 00		stz $00,x	                stz 0,x
.8f40		74 01		stz $01,x	                stz 1,x
.8f42		60		rts		z_false:        rts
.8f43						xt_fetch:
.8f43		20 47 d9	jsr $d947	                jsr underflow_1
.8f46		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f48		a8		tay		                tay
.8f49		f6 00		inc $00,x	                inc 0,x
.8f4b		d0 02		bne $8f4f	                bne +
.8f4d		f6 01		inc $01,x	                inc 1,x
.8f4f						+
.8f4f		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f51		95 01		sta $01,x	                sta 1,x
.8f53		94 00		sty $00,x	                sty 0,x
.8f55		60		rts		z_fetch:        rts
.8f56						xt_find:
.8f56		20 47 d9	jsr $d947	                jsr underflow_1
.8f59		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f5b		48		pha		                pha
.8f5c		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f5e		48		pha		                pha
.8f5f		20 26 89	jsr $8926	                jsr xt_count            ; ( caddr -- addr u )
.8f62		20 9e 8f	jsr $8f9e	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f65		b5 00		lda $00,x	                lda 0,x
.8f67		15 01		ora $01,x	                ora 1,x
.8f69		d0 0b		bne $8f76	                bne _found_word
.8f6b		20 3c 8f	jsr $8f3c	                jsr xt_false            ; ( 0 0 )
.8f6e		68		pla		                pla                     ; LSB of address
.8f6f		95 02		sta $02,x	                sta 2,x
.8f71		68		pla		                pla
.8f72		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8f74		80 27		bra $8f9d	                bra _done               ; ( addr 0 )
.8f76						_found_word:
.8f76		68		pla		                pla
.8f77		68		pla		                pla
.8f78		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( nt nt )
.8f7b		20 ba 95	jsr $95ba	                jsr xt_name_to_int      ; ( nt xt )
.8f7e		20 58 a1	jsr $a158	                jsr xt_swap             ; ( xt nt )
.8f81		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8f83		f6 00		inc $00,x	                inc 0,x
.8f85		d0 02		bne $8f89	                bne +
.8f87		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8f89						+
.8f89		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8f8b		29 04		and #$04	                and #IM
.8f8d		d0 08		bne $8f97	                bne _immediate          ; bit set, we're immediate
.8f8f		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8f91		95 00		sta $00,x	                sta 0,x
.8f93		95 01		sta $01,x	                sta 1,x
.8f95		80 06		bra $8f9d	                bra _done
.8f97						_immediate:
.8f97		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8f99		95 00		sta $00,x	                sta 0,x
.8f9b		74 01		stz $01,x	                stz 1,x
.8f9d						_done:
.8f9d		60		rts		z_find:         rts
.8f9e						xt_find_name:
.8f9e		20 4c d9	jsr $d94c	                jsr underflow_2
.8fa1		b5 00		lda $00,x	                lda 0,x
.8fa3		15 01		ora $01,x	                ora 1,x
.8fa5		d0 03		bne $8faa	                bne _nonempty
.8fa7		4c 43 90	jmp $9043	                jmp _fail_done
.8faa						_nonempty:
.8faa		64 28		stz $28		                stz tmp3                ; Start at the beginning
.8fac						_wordlist_loop:
.8fac		a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8fae		a5 28		lda $28		                lda tmp3
.8fb0		d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fb2		d0 03		bne $8fb7	                bne _have_string
.8fb4		4c 43 90	jmp $9043	                jmp _fail_done
.8fb7						_have_string:
.8fb7		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fb8		69 1f		adc #$1f	                adc #search_order_offset
.8fba		a8		tay		                tay
.8fbb		b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8fbd		0a		asl a		                asl                     ; Turn offset into cells offset.
.8fbe		18		clc		                clc
.8fbf		69 06		adc #$06	                adc #wordlists_offset
.8fc1		a8		tay		                tay
.8fc2		b1 1e		lda ($1e),y	                lda (up),y
.8fc4		85 24		sta $24		                sta tmp1
.8fc6		c8		iny		                iny
.8fc7		b1 1e		lda ($1e),y	                lda (up),y
.8fc9		85 25		sta $25		                sta tmp1+1
.8fcb		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.8fcd		85 26		sta $26		                sta tmp2
.8fcf		b5 03		lda $03,x	                lda 3,x
.8fd1		85 27		sta $27		                sta tmp2+1
.8fd3						_loop:
.8fd3		b2 24		lda ($24)	                lda (tmp1)
.8fd5		d5 00		cmp $00,x	                cmp 0,x
.8fd7		d0 54		bne $902d	                bne _next_entry
.8fd9						_compare_string:
.8fd9		b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.8fdb		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.8fdd		b0 07		bcs $8fe6	                bcs _compare_first
.8fdf		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8fe1		90 03		bcc $8fe6	                bcc _compare_first
.8fe3		18		clc		                clc
.8fe4		69 20		adc #$20	                adc #$20
.8fe6						_compare_first:
.8fe6		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.8fe8		d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.8fea		d0 41		bne $902d	                bne _next_entry
.8fec		b5 00		lda $00,x	                lda 0,x
.8fee		3a		dec a		                dea
.8fef		f0 2c		beq $901d	                beq _success
.8ff1		a5 24		lda $24		                lda tmp1
.8ff3		48		pha		                pha             ; Preserve tmp1 on the return stack.
.8ff4		18		clc		                clc
.8ff5		69 08		adc #$08	                adc #8
.8ff7		85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.8ff9		a5 25		lda $25		                lda tmp1+1
.8ffb		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.8ffc		69 00		adc #$00	                adc #0          ; we only need the carry
.8ffe		85 25		sta $25		                sta tmp1+1
.9000		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9002		88		dey		                dey
.9003						_string_loop:
.9003		b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9005		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9007		b0 07		bcs $9010	                bcs _check_char
.9009		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.900b		90 03		bcc $9010	                bcc _check_char
.900d		18		clc		                clc
.900e		69 20		adc #$20	                adc #$20
.9010						_check_char:
.9010		d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9012		d0 13		bne $9027	                bne _next_entry_tmp1
.9014		88		dey		                dey
.9015		d0 ec		bne $9003	                bne _string_loop
.9017						_success_tmp1:
.9017		68		pla		                pla             ; Restore tmp1 from the return stack.
.9018		85 25		sta $25		                sta tmp1+1
.901a		68		pla		                pla
.901b		85 24		sta $24		                sta tmp1
.901d						_success:
.901d		a5 24		lda $24		                lda tmp1
.901f		95 02		sta $02,x	                sta 2,x
.9021		a5 25		lda $25		                lda tmp1+1
.9023		95 03		sta $03,x	                sta 3,x
.9025		80 20		bra $9047	                bra _done
.9027						_next_entry_tmp1:
.9027		68		pla		                pla             ; Restore tmp1 from the return stack.
.9028		85 25		sta $25		                sta tmp1+1
.902a		68		pla		                pla
.902b		85 24		sta $24		                sta tmp1
.902d						_next_entry:
.902d		a0 02		ldy #$02	                ldy #2
.902f		b1 24		lda ($24),y	                lda (tmp1),y
.9031		48		pha		                pha
.9032		c8		iny		                iny
.9033		b1 24		lda ($24),y	                lda (tmp1),y
.9035		85 25		sta $25		                sta tmp1+1
.9037		68		pla		                pla
.9038		85 24		sta $24		                sta tmp1
.903a		05 25		ora $25		                ora tmp1+1
.903c		d0 95		bne $8fd3	                bne _loop
.903e		e6 28		inc $28		                inc tmp3
.9040		4c ac 8f	jmp $8fac	                jmp _wordlist_loop
.9043						_fail_done:
.9043		74 02		stz $02,x	                stz 2,x         ; failure flag
.9045		74 03		stz $03,x	                stz 3,x
.9047						_done:
.9047		e8		inx		                inx
.9048		e8		inx		                inx
.9049		60		rts		z_find_name:    rts
.904a						xt_flush:
.904a		20 68 9e	jsr $9e68	                jsr xt_save_buffers
.904d		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.904f		a9 00		lda #$00	                lda #0
.9051		91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9053						z_flush:
.9053		60		rts		                rts
.9054						xt_fm_slash_mod:
.9054		20 51 d9	jsr $d951	                jsr underflow_3
.9057		64 26		stz $26		                stz tmp2        ; default: n is positive
.9059		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.905b		10 0e		bpl $906b	                bpl _check_d
.905d		e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.905f		20 fc 95	jsr $95fc	                jsr xt_negate   ; NEGATE
.9062		20 1a a3	jsr $a31a	                jsr xt_to_r     ; >R
.9065		20 18 8b	jsr $8b18	                jsr xt_dnegate  ; DNEGATE
.9068		20 6b 9a	jsr $9a6b	                jsr xt_r_from   ; R>
.906b						_check_d:
.906b		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.906d		10 0d		bpl $907c	                bpl _multiply
.906f		18		clc		                clc
.9070		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.9072		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.9074		95 02		sta $02,x	                sta 2,x
.9076		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9078		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.907a		95 03		sta $03,x	                sta 3,x
.907c						_multiply:
.907c		20 64 a5	jsr $a564	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.907f		a5 26		lda $26		                lda tmp2
.9081		f0 07		beq $908a	                beq _done
.9083		e8		inx		                inx             ; pretend that we SWAP
.9084		e8		inx		                inx
.9085		20 fc 95	jsr $95fc	                jsr xt_negate
.9088		ca		dex		                dex
.9089		ca		dex		                dex
.908a						_done:
.908a		60		rts		z_fm_slash_mod: rts
.908b						xt_forth:
.908b		a0 1f		ldy #$1f	                ldy #search_order_offset
.908d		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.908f		91 1e		sta ($1e),y	                sta (up),y
.9091						z_forth:
.9091		60		rts		                rts
.9092						load_evaluate:
.9092		a9 ff		lda #$ff	                lda #$FF
.9094		85 24		sta $24		                sta tmp1
.9096		80 11		bra $90a9	                bra load_evaluate_start
.9098						xt_evaluate:
.9098		20 4c d9	jsr $d94c	                jsr underflow_2
.909b		64 24		stz $24		                stz tmp1
.909d		b5 00		lda $00,x	                lda 0,x
.909f		15 01		ora $01,x	                ora 1,x
.90a1		d0 06		bne $90a9	                bne evaluate_got_work
.90a3		e8		inx		                inx
.90a4		e8		inx		                inx
.90a5		e8		inx		                inx
.90a6		e8		inx		                inx
.90a7		80 42		bra $90eb	                bra evaluate_done
.90a9						load_evaluate_start:
.90a9						evaluate_got_work:
.90a9		a0 01		ldy #$01	                ldy #blk_offset+1
.90ab		b1 1e		lda ($1e),y	                lda (up),y
.90ad		48		pha		                pha
.90ae		88		dey		                dey
.90af		b1 1e		lda ($1e),y	                lda (up),y
.90b1		48		pha		                pha
.90b2		a5 24		lda $24		                lda tmp1
.90b4		d0 05		bne $90bb	                bne _nozero
.90b6		91 1e		sta ($1e),y	                sta (up),y
.90b8		c8		iny		                iny
.90b9		91 1e		sta ($1e),y	                sta (up),y
.90bb						_nozero:
.90bb		20 23 92	jsr $9223	                jsr xt_input_to_r
.90be		a9 ff		lda #$ff	                lda #$ff
.90c0		85 06		sta $06		                sta insrc
.90c2		85 07		sta $07		                sta insrc+1
.90c4		64 0c		stz $0c		                stz toin
.90c6		64 0d		stz $0d		                stz toin+1
.90c8		b5 00		lda $00,x	                lda 0,x
.90ca		85 0a		sta $0a		                sta ciblen
.90cc		b5 01		lda $01,x	                lda 1,x
.90ce		85 0b		sta $0b		                sta ciblen+1
.90d0		b5 02		lda $02,x	                lda 2,x
.90d2		85 08		sta $08		                sta cib
.90d4		b5 03		lda $03,x	                lda 3,x
.90d6		85 09		sta $09		                sta cib+1
.90d8		e8		inx		                inx             ; A clean stack is a clean mind
.90d9		e8		inx		                inx
.90da		e8		inx		                inx
.90db		e8		inx		                inx
.90dc		20 a2 d8	jsr $d8a2	                jsr interpret   ; ( -- )
.90df		20 7c 9a	jsr $9a7c	                jsr xt_r_to_input
.90e2		a0 00		ldy #$00	                ldy #blk_offset
.90e4		68		pla		                pla
.90e5		91 1e		sta ($1e),y	                sta (up),y
.90e7		c8		iny		                iny
.90e8		68		pla		                pla
.90e9		91 1e		sta ($1e),y	                sta (up),y
.90eb						evaluate_done:
.90eb		60		rts		z_evaluate:     rts
.90ec						xt_get_current:
.90ec		ca		dex		                dex
.90ed		ca		dex		                dex
.90ee		a0 04		ldy #$04	                ldy #current_offset
.90f0		b1 1e		lda ($1e),y	                lda (up),y
.90f2		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.90f4		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.90f6		60		rts		z_get_current:  rts
.90f7						xt_get_order:
.90f7		a0 1e		ldy #$1e	                ldy #num_order_offset
.90f9		b1 1e		lda ($1e),y	                lda (up),y
.90fb		85 24		sta $24		                sta tmp1
.90fd		f0 16		beq $9115	                beq _done       ; If zero, there are no wordlists.
.90ff						_loop:
.90ff		c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.9101		a9 1f		lda #$1f	                lda #search_order_offset
.9103		18		clc		                clc
.9104		65 24		adc $24		                adc tmp1
.9106		a8		tay		                tay
.9107		ca		dex		                dex
.9108		ca		dex		                dex
.9109		b1 1e		lda ($1e),y	                lda (up),y
.910b		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.910d		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.910f		a9 00		lda #$00	                lda #0
.9111		c5 24		cmp $24		                cmp tmp1
.9113		d0 ea		bne $90ff	                bne _loop
.9115						_done:
.9115		ca		dex		                dex
.9116		ca		dex		                dex
.9117		a0 1e		ldy #$1e	                ldy #num_order_offset
.9119		b1 1e		lda ($1e),y	                lda (up),y
.911b		95 00		sta $00,x	                sta 0,x
.911d		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.911f		60		rts		z_get_order:    rts
.9120						xt_greater_than:
.9120		20 4c d9	jsr $d94c	                jsr underflow_2
.9123		a0 00		ldy #$00	                ldy #0          ; default false
.9125		20 61 d8	jsr $d861	                jsr compare_16bit
.9128		f0 03		beq $912d	                beq _false
.912a		10 01		bpl $912d	                bpl _false
.912c		88		dey		                dey
.912d						_false:
.912d		98		tya		                tya
.912e		e8		inx		                inx
.912f		e8		inx		                inx
.9130		95 00		sta $00,x	                sta 0,x
.9132		95 01		sta $01,x	                sta 1,x
.9134		60		rts		z_greater_than: rts
.9135						xt_here:
.9135						xt_asm_arrow:
.9135		ca		dex		                dex
.9136		ca		dex		                dex
.9137		a5 00		lda $00		                lda cp
.9139		95 00		sta $00,x	                sta 0,x
.913b		a5 01		lda $01		                lda cp+1
.913d		95 01		sta $01,x	                sta 1,x
.913f						z_asm_arrow:
.913f		60		rts		z_here:         rts
.9140						xt_hex:
.9140		a9 10		lda #$10	                lda #16
.9142		85 18		sta $18		                sta base
.9144		64 19		stz $19		                stz base+1              ; paranoid
.9146		60		rts		z_hex:          rts
.9147						xt_hexstore:
.9147		20 51 d9	jsr $d951	                jsr underflow_3
.914a		20 72 8d	jsr $8d72	                jsr xt_dup              ; Save copy of original address
.914d		20 4c a4	jsr $a44c	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9150						_loop:
.9150		b5 00		lda $00,x	                lda 0,x
.9152		15 01		ora $01,x	                ora 1,x
.9154		f0 36		beq $918c	                beq _done
.9156		20 12 86	jsr $8612	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9159		20 4c a4	jsr $a44c	                jsr xt_two_to_r
.915c		20 52 a7	jsr $a752	                jsr xt_zero
.915f		20 52 a7	jsr $a752	                jsr xt_zero
.9162		20 d2 a3	jsr $a3d2	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9165		20 67 a2	jsr $a267	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9168		b5 00		lda $00,x	                lda 0,x
.916a		15 01		ora $01,x	                ora 1,x
.916c		d0 17		bne $9185	                bne _have_chars_left
.916e		20 5a a3	jsr $a35a	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9171		20 57 8a	jsr $8a57	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9174		20 56 9a	jsr $9a56	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9177		20 db 85	jsr $85db	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.917a		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; R>
.917d		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+
.9180		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9183		80 cb		bra $9150	                bra _loop
.9185						_have_chars_left:
.9185		8a		txa		                txa
.9186		18		clc		                clc
.9187		69 08		adc #$08	                adc #8
.9189		aa		tax		                tax
.918a		80 c4		bra $9150	                bra _loop
.918c						_done:
.918c		e8		inx		                inx
.918d		e8		inx		                inx
.918e		e8		inx		                inx
.918f		e8		inx		                inx                     ; 2DROP
.9190		20 d2 a3	jsr $a3d2	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9193		20 58 a1	jsr $a158	                jsr xt_swap
.9196		20 29 95	jsr $9529	                jsr xt_minus            ; ( n )
.9199		60		rts		z_hexstore:     rts
.919a						xt_hold:
.919a		20 47 d9	jsr $d947	                jsr underflow_1
.919d		a5 34		lda $34		                lda tohold
.919f		d0 02		bne $91a3	                bne +
.91a1		c6 35		dec $35		                dec tohold+1
.91a3						+
.91a3		c6 34		dec $34		                dec tohold
.91a5		b5 00		lda $00,x	                lda 0,x
.91a7		92 34		sta ($34)	                sta (tohold)
.91a9		e8		inx		                inx
.91aa		e8		inx		                inx
.91ab		60		rts		z_hold:         rts
.91ac						xt_i:
.91ac		ca		dex		                dex
.91ad		ca		dex		                dex
.91ae		da		phx		                phx
.91af		ba		tsx		                tsx
.91b0		38		sec		                sec
.91b1		bd 02 01	lda $0102,x	                lda $0102,x     ; LSB
.91b4		fd 04 01	sbc $0104,x	                sbc $0104,x
.91b7		a8		tay		                tay
.91b8		bd 03 01	lda $0103,x	                lda $0103,x     ; MSB
.91bb		fd 05 01	sbc $0105,x	                sbc $0105,x
.91be		fa		plx		                plx
.91bf		95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.91c1		94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.91c3		60		rts		z_i:            rts
.91c4						xt_if:
.91c4		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.91c6		a9 d5		lda #$d5	                lda #<zero_branch_runtime
.91c8		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.91cb		20 35 91	jsr $9135	                jsr xt_here
.91ce		20 52 a7	jsr $a752	                jsr xt_zero
.91d1		20 34 87	jsr $8734	                jsr xt_comma
.91d4		60		rts		z_if:           rts
.91d5						zero_branch_runtime:
.91d5		68		pla		                pla
.91d6		85 22		sta $22		                sta tmpbranch
.91d8		68		pla		                pla
.91d9		85 23		sta $23		                sta tmpbranch+1
.91db		b5 00		lda $00,x	                lda 0,x
.91dd		15 01		ora $01,x	                ora 1,x
.91df		f0 0f		beq $91f0	                beq _zero
.91e1		a5 22		lda $22		                lda tmpbranch   ; LSB
.91e3		18		clc		                clc
.91e4		69 02		adc #$02	                adc #2
.91e6		85 24		sta $24		                sta tmp1
.91e8		a5 23		lda $23		                lda tmpbranch+1 ; MSB
.91ea		69 00		adc #$00	                adc #0          ; For carry
.91ec		85 25		sta $25		                sta tmp1+1
.91ee		80 13		bra $9203	                bra _done
.91f0						_zero:
.91f0		a0 01		ldy #$01	                ldy #1
.91f2		b1 22		lda ($22),y	                lda (tmpbranch),y
.91f4		85 24		sta $24		                sta tmp1
.91f6		c8		iny		                iny
.91f7		b1 22		lda ($22),y	                lda (tmpbranch),y
.91f9		85 25		sta $25		                sta tmp1+1
.91fb		a5 24		lda $24		                lda tmp1
.91fd		d0 02		bne $9201	                bne +
.91ff		c6 25		dec $25		                dec tmp1+1
.9201						+
.9201		c6 24		dec $24		                dec tmp1
.9203						_done:
.9203		a5 25		lda $25		                lda tmp1+1
.9205		48		pha		                pha             ; MSB first
.9206		a5 24		lda $24		                lda tmp1
.9208		48		pha		                pha
.9209		e8		inx		                inx
.920a		e8		inx		                inx
.920b		60		rts		                rts
.920c						xt_immediate:
.920c		20 7c d8	jsr $d87c	                jsr current_to_dp
.920f		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9211		b1 02		lda ($02),y	                lda (dp),y
.9213		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9215		91 02		sta ($02),y	                sta (dp),y
.9217		60		rts		z_immediate:    rts
.9218						xt_input:
.9218		ca		dex		                dex
.9219		ca		dex		                dex
.921a		a9 12		lda #$12	                lda #<input
.921c		95 00		sta $00,x	                sta 0,x
.921e		a9 00		lda #$00	                lda #>input
.9220		95 01		sta $01,x	                sta 1,x
.9222		60		rts		z_input:        rts
.9223						xt_input_to_r:
.9223		68		pla		                pla
.9224		85 24		sta $24		                sta tmp1
.9226		68		pla		                pla
.9227		85 25		sta $25		                sta tmp1+1
.9229		a0 07		ldy #$07	                ldy #7
.922b						_loop:
.922b		b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.922e		48		pha		                pha
.922f		88		dey		                dey
.9230		10 f9		bpl $922b	                bpl _loop
.9232		a5 25		lda $25		                lda tmp1+1
.9234		48		pha		                pha
.9235		a5 24		lda $24		                lda tmp1
.9237		48		pha		                pha
.9238		60		rts		z_input_to_r: 	rts
.9239						xt_int_to_name:
.9239		20 47 d9	jsr $d947	                jsr underflow_1
.923c		ca		dex		                dex
.923d		ca		dex		                dex
.923e		74 00		stz $00,x	                stz 0,x
.9240		74 01		stz $01,x	                stz 1,x
.9242						_wordlist_loop:
.9242		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9244		0a		asl a		                asl                     ; Turn offset into cells offset.
.9245		18		clc		                clc
.9246		69 06		adc #$06	                adc #wordlists_offset
.9248		a8		tay		                tay
.9249		b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.924b		85 26		sta $26		                sta tmp2                ; into tmp2
.924d		c8		iny		                iny
.924e		b1 1e		lda ($1e),y	                lda (up),y
.9250		85 27		sta $27		                sta tmp2+1
.9252		a5 26		lda $26		                lda tmp2
.9254		05 27		ora $27		                ora tmp2+1
.9256		f0 38		beq $9290	                beq _next_wordlist
.9258		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.925a		85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.925c		b5 03		lda $03,x	                lda 3,x
.925e		85 29		sta $29		                sta tmp3+1
.9260						_loop:
.9260		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9262		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.9264		c5 28		cmp $28		                cmp tmp3
.9266		d0 07		bne $926f	                bne _no_match
.9268		c8		iny		                iny
.9269		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.926b		c5 29		cmp $29		                cmp tmp3+1
.926d		f0 32		beq $92a1	                beq _match
.926f						_no_match:
.926f		18		clc		                clc
.9270		a5 26		lda $26		                lda tmp2
.9272		69 02		adc #$02	                adc #2
.9274		85 26		sta $26		                sta tmp2
.9276		a5 27		lda $27		                lda tmp2+1
.9278		69 00		adc #$00	                adc #0          ; only care about carry
.927a		85 27		sta $27		                sta tmp2+1
.927c		a0 00		ldy #$00	                ldy #0
.927e		b1 26		lda ($26),y	                lda (tmp2),y
.9280		48		pha		                pha
.9281		c8		iny		                iny
.9282		11 26		ora ($26),y	                ora (tmp2),y
.9284		f0 09		beq $928f	                beq _zero
.9286		b1 26		lda ($26),y	                lda (tmp2),y
.9288		85 27		sta $27		                sta tmp2+1
.928a		68		pla		                pla
.928b		85 26		sta $26		                sta tmp2
.928d		80 d1		bra $9260	                bra _loop
.928f						_zero:
.928f		68		pla		                pla             ; Leftover from above loop
.9290						_next_wordlist:
.9290		b5 00		lda $00,x	                lda 0,x
.9292		1a		inc a		                ina
.9293		95 00		sta $00,x	                sta 0,x
.9295		c9 0c		cmp #$0c	                cmp #max_wordlists
.9297		d0 a9		bne $9242	                bne _wordlist_loop
.9299		e8		inx		                inx
.929a		e8		inx		                inx
.929b		74 00		stz $00,x	                stz 0,x
.929d		74 01		stz $01,x	                stz 1,x
.929f		80 0a		bra $92ab	                bra z_int_to_name
.92a1						_match:
.92a1		e8		inx		                inx
.92a2		e8		inx		                inx
.92a3		a5 26		lda $26		                lda tmp2
.92a5		95 00		sta $00,x	                sta 0,x
.92a7		a5 27		lda $27		                lda tmp2+1
.92a9		95 01		sta $01,x	                sta 1,x
.92ab		60		rts		z_int_to_name:  rts
.92ac						xt_invert:
.92ac		20 47 d9	jsr $d947	                jsr underflow_1
.92af		a9 ff		lda #$ff	                lda #$FF
.92b1		55 00		eor $00,x	                eor 0,x         ; LSB
.92b3		95 00		sta $00,x	                sta 0,x
.92b5		a9 ff		lda #$ff	                lda #$FF
.92b7		55 01		eor $01,x	                eor 1,x         ; MSB
.92b9		95 01		sta $01,x	                sta 1,x
.92bb		60		rts		z_invert:       rts
.92bc						xt_is:
.92bc		a5 16		lda $16		                lda state
.92be		05 17		ora $17		                ora state+1
.92c0		f0 0c		beq $92ce	                beq _interpreting
.92c2						_compiling:
.92c2		20 64 85	jsr $8564	                jsr xt_bracket_tick
.92c5		a0 8a		ldy #$8a	                ldy #>xt_defer_store
.92c7		a9 bd		lda #$bd	                lda #<xt_defer_store
.92c9		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.92cc		80 06		bra $92d4	                bra _done
.92ce						_interpreting:
.92ce		20 bb a1	jsr $a1bb	                jsr xt_tick
.92d1		20 bd 8a	jsr $8abd	                jsr xt_defer_store
.92d4						_done:
.92d4		60		rts		z_is:           rts
.92d5						xt_j:
.92d5		ca		dex		                dex
.92d6		ca		dex		                dex
.92d7		86 2a		stx $2a		                stx tmpdsp
.92d9		ba		tsx		                tsx
.92da		38		sec		                sec
.92db		bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.92de		fd 09 01	sbc $0109,x	                sbc $0109,x
.92e1		a8		tay		                tay
.92e2		bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.92e5		fd 0a 01	sbc $010a,x	                sbc $010A,x
.92e8		a6 2a		ldx $2a		                ldx tmpdsp
.92ea		95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.92ec		94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.92ee		60		rts		z_j:            rts
.92ef						xt_key:
.92ef		20 f9 92	jsr $92f9	                jsr key_a               ; returns char in A
.92f2		ca		dex		                dex
.92f3		ca		dex		                dex
.92f4		95 00		sta $00,x	                sta 0,x
.92f6		74 01		stz $01,x	                stz 1,x
.92f8		60		rts		z_key:          rts
.92f9						key_a:
.92f9		6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.92fc						xt_latestnt:
.92fc		ca		dex		                dex
.92fd		ca		dex		                dex
.92fe		20 7c d8	jsr $d87c	                jsr current_to_dp
.9301		a5 02		lda $02		                lda dp
.9303		95 00		sta $00,x	                sta 0,x
.9305		a5 03		lda $03		                lda dp+1
.9307		95 01		sta $01,x	                sta 1,x
.9309		60		rts		z_latestnt:     rts
.930a						xt_latestxt:
.930a		20 fc 92	jsr $92fc	                jsr xt_latestnt         ; ( nt )
.930d		20 ba 95	jsr $95ba	                jsr xt_name_to_int      ; ( xt )
.9310		60		rts		z_latestxt:     rts
.9311						xt_leave:
.9311		68		pla		                pla
.9312		68		pla		                pla
.9313		68		pla		                pla
.9314		68		pla		                pla
.9315		60		rts		                rts             ; this must be compiled, so keep before z_leave
.9316						z_leave:
.9316						xt_left_bracket:
.9316		64 16		stz $16		                stz state
.9318		64 17		stz $17		                stz state+1
.931a		60		rts		z_left_bracket: rts
.931b						xt_less_number_sign:
.931b		20 7a 98	jsr $987a	                jsr xt_pad      ; ( addr )
.931e		b5 00		lda $00,x	                lda 0,x
.9320		85 34		sta $34		                sta tohold
.9322		b5 01		lda $01,x	                lda 1,x
.9324		85 35		sta $35		                sta tohold+1
.9326		e8		inx		                inx
.9327		e8		inx		                inx
.9328						z_less_number_sign:
.9328		60		rts		                rts
.9329						xt_less_than:
.9329		20 4c d9	jsr $d94c	                jsr underflow_2
.932c		a0 00		ldy #$00	                ldy #0          ; default false
.932e		20 61 d8	jsr $d861	                jsr compare_16bit
.9331		f0 03		beq $9336	                beq _false
.9333		30 01		bmi $9336	                bmi _false
.9335		88		dey		                dey
.9336						_false:
.9336		98		tya		                tya
.9337		e8		inx		                inx
.9338		e8		inx		                inx
.9339		95 00		sta $00,x	                sta 0,x
.933b		95 01		sta $01,x	                sta 1,x
.933d		60		rts		z_less_than:    rts
.933e						xt_list:
.933e		20 47 d9	jsr $d947	                jsr underflow_1
.9341		20 83 9e	jsr $9e83	                jsr xt_scr
.9344		20 37 a1	jsr $a137	                jsr xt_store
.9347		20 ec a7	jsr $a7ec	                jsr xt_editor_l
.934a		60		rts		z_list:         rts
.934b						xt_literal:
.934b		20 47 d9	jsr $d947	                jsr underflow_1
.934e		a0 93		ldy #$93	                ldy #>literal_runtime
.9350		a9 59		lda #$59	                lda #<literal_runtime
.9352		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.9355		20 34 87	jsr $8734	                jsr xt_comma
.9358		60		rts		z_literal:      rts
.9359						literal_runtime:
.9359		ca		dex		                dex
.935a		ca		dex		                dex
.935b		68		pla		                pla             ; LSB
.935c		85 24		sta $24		                sta tmp1
.935e		68		pla		                pla             ; MSB
.935f		85 25		sta $25		                sta tmp1+1
.9361		a0 01		ldy #$01	                ldy #1
.9363		b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.9365		95 00		sta $00,x	                sta 0,x
.9367		c8		iny		                iny
.9368		b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.936a		95 01		sta $01,x	                sta 1,x
.936c		98		tya		                tya
.936d		18		clc		                clc
.936e		65 24		adc $24		                adc tmp1
.9370		a8		tay		                tay
.9371		a5 25		lda $25		                lda tmp1+1
.9373		69 00		adc #$00	                adc #0
.9375		48		pha		                pha
.9376		5a		phy		                phy
.9377		60		rts		                rts
.9378						byte_runtime:
.9378		ca		dex		                dex             ; make space on the stack
.9379		ca		dex		                dex
.937a		68		pla		                pla             ; LSB
.937b		7a		ply		                ply             ; MSB
.937c		1a		inc a		                ina             ; inc return addr and store in tmp1
.937d		d0 01		bne $9380	                bne +
.937f		c8		iny		                iny
.9380		5a		phy		+               phy
.9381		48		pha		                pha
.9382		85 24		sta $24		                sta tmp1
.9384		84 25		sty $25		                sty tmp1+1
.9386		b2 24		lda ($24)	                lda (tmp1)      ; LSB
.9388		95 00		sta $00,x	                sta 0,x
.938a		74 01		stz $01,x	                stz 1,x         ; MSB is zero
.938c		60		rts		                rts
.938d						xt_load:
.938d		20 47 d9	jsr $d947	                jsr underflow_1
.9390		a0 01		ldy #$01	                ldy #blk_offset+1
.9392		b1 1e		lda ($1e),y	                lda (up),y
.9394		48		pha		                pha
.9395		88		dey		                dey
.9396		b1 1e		lda ($1e),y	                lda (up),y
.9398		48		pha		                pha
.9399		b5 00		lda $00,x	                lda 0,x
.939b		91 1e		sta ($1e),y	                sta (up),y
.939d		c8		iny		                iny
.939e		b5 01		lda $01,x	                lda 1,x
.93a0		91 1e		sta ($1e),y	                sta (up),y
.93a2		20 87 83	jsr $8387	                jsr xt_block
.93a5		ca		dex		                dex
.93a6		ca		dex		                dex
.93a7		a9 04		lda #$04	                lda #4
.93a9		95 01		sta $01,x	                sta 1,x
.93ab		74 00		stz $00,x	                stz 0,x
.93ad		20 92 90	jsr $9092	                jsr load_evaluate
.93b0		a0 00		ldy #$00	                ldy #blk_offset
.93b2		68		pla		                pla
.93b3		91 1e		sta ($1e),y	                sta (up),y
.93b5		c8		iny		                iny
.93b6		68		pla		                pla
.93b7		91 1e		sta ($1e),y	                sta (up),y
.93b9		88		dey		                dey
.93ba		11 1e		ora ($1e),y	                ora (up),y
.93bc		f0 12		beq $93d0	                beq _done
.93be		ca		dex		                dex
.93bf		ca		dex		                dex
.93c0		a0 00		ldy #$00	                ldy #blk_offset
.93c2		b1 1e		lda ($1e),y	                lda (up),y
.93c4		95 00		sta $00,x	                sta 0,x
.93c6		c8		iny		                iny
.93c7		b1 1e		lda ($1e),y	                lda (up),y
.93c9		95 01		sta $01,x	                sta 1,x
.93cb		20 87 83	jsr $8387	                jsr xt_block
.93ce		e8		inx		                inx
.93cf		e8		inx		                inx
.93d0						_done:
.93d0		60		rts		z_load:         rts
.93d1						xt_loop:
.93d1		ca		dex		                dex
.93d2		ca		dex		                dex
.93d3		a0 0e		ldy #$0e	                ldy #loop_runtime_end-loop_runtime
.93d5		a9 45		lda #$45	                lda #<loop_runtime
.93d7		95 00		sta $00,x	                sta 0,x
.93d9		a9 94		lda #$94	                lda #>loop_runtime
.93db		95 01		sta $01,x	                sta 1,x
.93dd		20 9d 88	jsr $889d	                jsr cmpl_inline_y
.93e0		80 0f		bra $93f1	                bra xt_loop_common
.93e2						xt_plus_loop:
.93e2		ca		dex		                dex
.93e3		ca		dex		                dex
.93e4		a0 10		ldy #$10	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93e6		a9 35		lda #$35	                lda #<plus_loop_runtime
.93e8		95 00		sta $00,x	                sta 0,x
.93ea		a9 94		lda #$94	                lda #>plus_loop_runtime
.93ec		95 01		sta $01,x	                sta 1,x
.93ee		20 9d 88	jsr $889d	                jsr cmpl_inline_y
.93f1						xt_loop_common:
.93f1		20 34 87	jsr $8734	                jsr xt_comma
.93f4		a9 68		lda #$68	                lda #$68                ; opcode for PLA
.93f6		a0 06		ldy #$06	                ldy #6
.93f8						-
.93f8		91 00		sta ($00),y	                sta (cp),y
.93fa		88		dey		                dey
.93fb		10 fb		bpl $93f8	                bpl -
.93fd		a9 06		lda #$06	                lda #6
.93ff		18		clc		                clc
.9400		65 00		adc $00		                adc cp
.9402		85 00		sta $00		                sta cp
.9404		a5 01		lda $01		                lda cp+1
.9406		69 00		adc #$00	                adc #0                  ; only need carry
.9408		85 01		sta $01		                sta cp+1
.940a		b5 00		lda $00,x	                lda 0,x
.940c		85 24		sta $24		                sta tmp1
.940e		b5 01		lda $01,x	                lda 1,x
.9410		85 25		sta $25		                sta tmp1+1
.9412		e8		inx		                inx
.9413		e8		inx		                inx
.9414		a5 00		lda $00		                lda cp
.9416		38		sec		                sec
.9417		e9 01		sbc #$01	                sbc #1
.9419		48		pha		                pha             ; lsb
.941a		a5 01		lda $01		                lda cp+1
.941c		e9 00		sbc #$00	                sbc #0
.941e		48		pha		                pha             ; msb
.941f		a0 00		ldy #$00	                ldy #0
.9421						-
.9421		b9 2f 94	lda $942f,y	                lda loop_epilogue,y
.9424		d0 01		bne $9427	                bne +
.9426		68		pla		                pla
.9427						+
.9427		91 24		sta ($24),y	                sta (tmp1),y
.9429		c8		iny		                iny
.942a		c0 06		cpy #$06	                cpy #(loop_epilogue_end-loop_epilogue)
.942c		d0 f3		bne $9421	                bne -
.942e						z_loop:
.942e		60		rts		z_plus_loop:    rts
.942f						loop_epilogue:
.942f		a9 00		lda #$00	                lda #0
.9431		48		pha		                pha
.9432		a9 00		lda #$00	                lda #0
.9434		48		pha		                pha
.9435						loop_epilogue_end:
.9435						plus_loop_runtime:
.9435		18		clc		                clc
.9436		68		pla		                pla             ; LSB of index
.9437		75 00		adc $00,x	                adc 0,x         ; LSB of step
.9439		a8		tay		                tay             ; temporary storage of LSB
.943a		b8		clv		                clv
.943b		68		pla		                pla             ; MSB of index
.943c		75 01		adc $01,x	                adc 1,x         ; MSB of step
.943e		48		pha		                pha             ; put MSB of index back on stack
.943f		5a		phy		                phy             ; put LSB of index back on stack
.9440		e8		inx		                inx             ; dump step from TOS
.9441		e8		inx		                inx
.9442		70 03		bvs $9447	                bvs _hack+3     ; skip over JMP instruction
.9444						_hack:
>9444		4c				                .byte $4C
.9445						plus_loop_runtime_end:
.9445						loop_runtime:
.9445		b8		clv		                clv             ; note inc doesn't affect V
.9446		7a		ply		                ply             ; LSB of index
.9447		c8		iny		                iny             ; add one
.9448		d0 05		bne $944f	                bne _skip_msb   ; definitely not done
.944a		68		pla		                pla             ; MSB of index
.944b		18		clc		                clc
.944c		69 01		adc #$01	                adc #1          ; use adc to get V flag
.944e		48		pha		                pha             ; put MSB of index back on stack
.944f		5a		phy		_skip_msb:      phy             ; put LSB of index back on stack
.9450		70 03		bvs $9455	                bvs _hack+3     ; skip over JMP instruction
.9452						_hack:
>9452		4c				                .byte $4C
.9453						loop_runtime_end:
.9453						xt_lshift:
.9453		20 4c d9	jsr $d94c	                jsr underflow_2
.9456		b5 00		lda $00,x	                lda 0,x
.9458		29 0f		and #$0f	                and #%00001111
.945a		f0 08		beq $9464	                beq _done
.945c		a8		tay		                tay
.945d						_loop:
.945d		16 02		asl $02,x	                asl 2,x
.945f		36 03		rol $03,x	                rol 3,x
.9461		88		dey		                dey
.9462		d0 f9		bne $945d	                bne _loop
.9464						_done:
.9464		e8		inx		                inx
.9465		e8		inx		                inx
.9466		60		rts		z_lshift:       rts
.9467						xt_m_star:
.9467		20 4c d9	jsr $d94c	                jsr underflow_2
.946a		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.946c		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.946e		48		pha		                pha
.946f		20 dd 80	jsr $80dd	                jsr xt_abs
.9472		20 58 a1	jsr $a158	                jsr xt_swap
.9475		20 dd 80	jsr $80dd	                jsr xt_abs
.9478		20 a6 a5	jsr $a5a6	                jsr xt_um_star          ; ( d )
.947b		68		pla		                pla
.947c		10 03		bpl $9481	                bpl _done
.947e		20 18 8b	jsr $8b18	                jsr xt_dnegate
.9481						_done:
.9481		60		rts		z_m_star:       rts
.9482						xt_marker:
.9482		20 7c d8	jsr $d87c	                jsr current_to_dp
.9485		a5 02		lda $02		                lda dp
.9487		48		pha		                pha
.9488		a5 03		lda $03		                lda dp+1
.948a		48		pha		                pha
.948b		a5 00		lda $00		                lda cp
.948d		48		pha		                pha
.948e		a5 01		lda $01		                lda cp+1
.9490		48		pha		                pha
.9491		20 40 89	jsr $8940	                jsr xt_create
.9494		a5 00		lda $00		                lda cp          ; LSB
.9496		38		sec		                sec
.9497		e9 02		sbc #$02	                sbc #2
.9499		85 00		sta $00		                sta cp
.949b		a5 01		lda $01		                lda cp+1        ; MSB
.949d		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.949f		85 01		sta $01		                sta cp+1
.94a1		a0 94		ldy #$94	                ldy #>marker_runtime
.94a3		a9 c0		lda #$c0	                lda #<marker_runtime
.94a5		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.94a8		7a		ply		                ply                     ; MSB
.94a9		68		pla		                pla                     ; LSB
.94aa		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.94ad		7a		ply		                ply                     ; MSB
.94ae		68		pla		                pla                     ; LSB
.94af		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.94b2		a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94b4						_marker_loop:
.94b4		b1 1e		lda ($1e),y	                lda (up),y
.94b6		20 ed d7	jsr $d7ed	                jsr cmpl_a
.94b9		c8		iny		                iny
.94ba		98		tya		                tya
.94bb		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94bd		d0 f5		bne $94b4	                bne _marker_loop
.94bf		60		rts		z_marker:       rts
.94c0						marker_runtime:
.94c0		68		pla		                pla
.94c1		85 24		sta $24		                sta tmp1        ; LSB of address
.94c3		68		pla		                pla
.94c4		85 25		sta $25		                sta tmp1+1      ; MSB of address
.94c6		e6 24		inc $24		                inc tmp1
.94c8		d0 02		bne $94cc	                bne +
.94ca		e6 25		inc $25		                inc tmp1+1
.94cc						+
.94cc		a0 00		ldy #$00	                ldy #0
.94ce		b1 24		lda ($24),y	                lda (tmp1),y
.94d0		85 00		sta $00		                sta cp
.94d2		c8		iny		                iny
.94d3		b1 24		lda ($24),y	                lda (tmp1),y
.94d5		85 01		sta $01		                sta cp+1
.94d7		c8		iny		                iny
.94d8		b1 24		lda ($24),y	                lda (tmp1),y
.94da		85 02		sta $02		                sta dp
.94dc		c8		iny		                iny
.94dd		b1 24		lda ($24),y	                lda (tmp1),y
.94df		85 03		sta $03		                sta dp+1
.94e1		a0 04		ldy #$04	                ldy #4
.94e3						_marker_restore_loop:
.94e3		b1 24		lda ($24),y	                lda (tmp1), y
.94e5		91 1e		sta ($1e),y	                sta (up), y
.94e7		c8		iny		                iny
.94e8		98		tya		                tya
.94e9		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94eb		d0 f6		bne $94e3	                bne _marker_restore_loop
.94ed		20 8f d8	jsr $d88f	                jsr dp_to_current       ; Move the CURRENT DP back.
.94f0		60		rts		                rts
.94f1						xt_max:
.94f1		20 4c d9	jsr $d94c	                jsr underflow_2
.94f4		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.94f6		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.94f8		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.94fa		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.94fc		50 02		bvc $9500	                bvc _no_overflow
.94fe		49 80		eor #$80	                eor #$80        ; complement negative flag
.9500						_no_overflow:
.9500		30 08		bmi $950a	                bmi _keep_nos
.9502		b5 00		lda $00,x	                lda 0,x
.9504		95 02		sta $02,x	                sta 2,x
.9506		b5 01		lda $01,x	                lda 1,x
.9508		95 03		sta $03,x	                sta 3,x
.950a						_keep_nos:
.950a		e8		inx		                inx
.950b		e8		inx		                inx
.950c		60		rts		z_max:          rts
.950d						xt_min:
.950d		20 4c d9	jsr $d94c	                jsr underflow_2
.9510		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9512		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.9514		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9516		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9518		50 02		bvc $951c	                bvc _no_overflow
.951a		49 80		eor #$80	                eor #$80
.951c						_no_overflow:
.951c		10 08		bpl $9526	                bpl _keep_nos
.951e		b5 00		lda $00,x	                lda 0,x
.9520		95 02		sta $02,x	                sta 2,x
.9522		b5 01		lda $01,x	                lda 1,x
.9524		95 03		sta $03,x	                sta 3,x
.9526						_keep_nos:
.9526		e8		inx		                inx
.9527		e8		inx		                inx
.9528		60		rts		z_min:          rts
.9529						xt_minus:
.9529		20 4c d9	jsr $d94c	                jsr underflow_2
.952c		38		sec		                sec
.952d		b5 02		lda $02,x	                lda 2,x         ; LSB
.952f		f5 00		sbc $00,x	                sbc 0,x
.9531		95 02		sta $02,x	                sta 2,x
.9533		b5 03		lda $03,x	                lda 3,x         ; MSB
.9535		f5 01		sbc $01,x	                sbc 1,x
.9537		95 03		sta $03,x	                sta 3,x
.9539		e8		inx		                inx
.953a		e8		inx		                inx
.953b		60		rts		z_minus:        rts
.953c						xt_minus_leading:
.953c		20 4c d9	jsr $d94c	                jsr underflow_2
.953f						_loop:
.953f		b5 00		lda $00,x	                lda 0,x
.9541		15 01		ora $01,x	                ora 1,x
.9543		f0 0f		beq $9554	                beq _done
.9545		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9547		20 3a d9	jsr $d93a	                jsr is_whitespace
.954a		90 08		bcc $9554	                bcc _done
.954c		20 e1 97	jsr $97e1	                jsr xt_one              ; ( addr u 1 )
.954f		20 c3 9f	jsr $9fc3	                jsr xt_slash_string     ; ( addr+ u-1 )
.9552		80 eb		bra $953f	                bra _loop
.9554						_done:
.9554						z_minus_leading:
.9554		60		rts		                rts
.9555						xt_minus_trailing:
.9555		20 4c d9	jsr $d94c	                jsr underflow_2
.9558		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.955a		15 01		ora $01,x	                ora 1,x         ; MSB of n
.955c		f0 33		beq $9591	                beq _done
.955e		18		clc		                clc
.955f		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9561		75 00		adc $00,x	                adc 0,x
.9563		85 24		sta $24		                sta tmp1
.9565		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.9567		75 01		adc $01,x	                adc 1,x
.9569		85 25		sta $25		                sta tmp1+1
.956b		a5 24		lda $24		                lda tmp1
.956d		d0 02		bne $9571	                bne +
.956f		c6 25		dec $25		                dec tmp1+1
.9571						+
.9571		c6 24		dec $24		                dec tmp1
.9573						_loop:
.9573		b2 24		lda ($24)	                lda (tmp1)
.9575		c9 20		cmp #$20	                cmp #AscSP
.9577		d0 18		bne $9591	                bne _done
.9579		a5 24		lda $24		                lda tmp1
.957b		d0 02		bne $957f	                bne +
.957d		c6 25		dec $25		                dec tmp1+1
.957f						+
.957f		c6 24		dec $24		                dec tmp1
.9581		b5 00		lda $00,x	                lda 0,x
.9583		d0 02		bne $9587	                bne +
.9585		d6 01		dec $01,x	                dec 1,x
.9587						+
.9587		d6 00		dec $00,x	                dec 0,x
.9589		b5 00		lda $00,x	                lda 0,x
.958b		15 01		ora $01,x	                ora 1,x
.958d		f0 02		beq $9591	                beq _done       ; Count has reached zero - we're done!
.958f		80 e2		bra $9573	                bra _loop
.9591						_done:
.9591						z_minus_trailing:
.9591		60		rts		                rts
.9592						xt_mod:
.9592		20 4c d9	jsr $d94c	                jsr underflow_2
.9595		20 ab 9f	jsr $9fab	                jsr xt_slash_mod
.9598		e8		inx		                inx             ; DROP
.9599		e8		inx		                inx
.959a						z_mod:
.959a		60		rts		                rts
.959b						xt_move:
.959b		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.959d		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.959f		f0 05		beq $95a6	                beq _lsb                ; wasn't helpful, move to LSB
.95a1		b0 0e		bcs $95b1	                bcs _to_move_up         ; we want CMOVE>
.95a3		4c 5f 86	jmp $865f	                jmp xt_cmove            ; JSR/RTS
.95a6						_lsb:
.95a6		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95a8		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95aa		f0 08		beq $95b4	                beq _equal              ; LSB is equal as well
.95ac		b0 03		bcs $95b1	                bcs _to_move_up         ; we want CMOVE>
.95ae		4c 5f 86	jmp $865f	                jmp xt_cmove            ; JSR/RTS
.95b1						_to_move_up:
.95b1		4c 9a 86	jmp $869a	                jmp xt_cmove_up         ; JSR/RTS
.95b4						_equal:
.95b4		8a		txa		                txa
.95b5		18		clc		                clc
.95b6		69 06		adc #$06	                adc #6
.95b8		aa		tax		                tax
.95b9		60		rts		z_move:         rts
.95ba						xt_name_to_int:
.95ba		20 47 d9	jsr $d947	                jsr underflow_1
.95bd		b5 00		lda $00,x	                lda 0,x
.95bf		18		clc		                clc
.95c0		69 04		adc #$04	                adc #4
.95c2		85 28		sta $28		                sta tmp3
.95c4		b5 01		lda $01,x	                lda 1,x
.95c6		90 01		bcc $95c9	                bcc _done
.95c8		1a		inc a		                ina
.95c9						_done:
.95c9		85 29		sta $29		                sta tmp3+1
.95cb		a0 00		ldy #$00	                ldy #0
.95cd		b1 28		lda ($28),y	                lda (tmp3),y
.95cf		95 00		sta $00,x	                sta 0,x
.95d1		c8		iny		                iny
.95d2		b1 28		lda ($28),y	                lda (tmp3),y
.95d4		95 01		sta $01,x	                sta 1,x
.95d6		60		rts		z_name_to_int:  rts
.95d7						xt_name_to_string:
.95d7		20 47 d9	jsr $d947	                jsr underflow_1
.95da		ca		dex		                dex
.95db		ca		dex		                dex
.95dc		a1 02		lda ($02,x)	                lda (2,x)
.95de		95 00		sta $00,x	                sta 0,x
.95e0		74 01		stz $01,x	                stz 1,x
.95e2		b5 02		lda $02,x	                lda 2,x         ; LSB
.95e4		18		clc		                clc
.95e5		69 08		adc #$08	                adc #8
.95e7		a8		tay		                tay
.95e8		b5 03		lda $03,x	                lda 3,x         ; MSB
.95ea		69 00		adc #$00	                adc #0          ; just need carry
.95ec		95 03		sta $03,x	                sta 3,x
.95ee		94 02		sty $02,x	                sty 2,x
.95f0						z_name_to_string:
.95f0		60		rts		                rts
.95f1						xt_nc_limit:
.95f1		ca		dex		                dex
.95f2		ca		dex		                dex
.95f3		a9 1a		lda #$1a	                lda #<nc_limit
.95f5		95 00		sta $00,x	                sta 0,x
.95f7		a9 00		lda #$00	                lda #>nc_limit
.95f9		95 01		sta $01,x	                sta 1,x
.95fb		60		rts		z_nc_limit:     rts
.95fc						xt_negate:
.95fc		20 47 d9	jsr $d947	                jsr underflow_1
.95ff		a9 00		lda #$00	        	lda #0
.9601		38		sec		                sec
.9602		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.9604		95 00		sta $00,x	                sta 0,x
.9606		a9 00		lda #$00	                lda #0
.9608		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.960a		95 01		sta $01,x	                sta 1,x
.960c		60		rts		z_negate:       rts
.960d						xt_never_native:
.960d		20 7c d8	jsr $d87c	                jsr current_to_dp
.9610		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9612		b1 02		lda ($02),y	                lda (dp),y
.9614		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9616		29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.9618		91 02		sta ($02),y	                sta (dp),y
.961a						z_never_native:
.961a		60		rts		                rts
.961b						xt_nip:
.961b		20 4c d9	jsr $d94c	                jsr underflow_2
.961e		b5 00		lda $00,x	                lda 0,x         ; LSB
.9620		95 02		sta $02,x	                sta 2,x
.9622		b5 01		lda $01,x	                lda 1,x         ; MSB
.9624		95 03		sta $03,x	                sta 3,x
.9626		e8		inx		                inx
.9627		e8		inx		                inx
.9628		60		rts		z_nip:          rts
.9629						xt_not_equals:
.9629		20 4c d9	jsr $d94c	                jsr underflow_2
.962c		a0 00		ldy #$00	                ldy #0                  ; default is true
.962e		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9630		d5 02		cmp $02,x	                cmp 2,x
.9632		d0 0a		bne $963e	                bne _not_equal
.9634		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9636		d5 03		cmp $03,x	                cmp 3,x
.9638		d0 04		bne $963e	                bne _not_equal
.963a		a9 ff		lda #$ff	                lda #$FF
.963c		80 01		bra $963f	                bra _done
.963e						_not_equal:
.963e		88		dey		                dey                     ; drop thru to done
.963f						_done:
.963f		98		tya		                tya
.9640		e8		inx		                inx
.9641		e8		inx		                inx
.9642		95 00		sta $00,x	                sta 0,x
.9644		95 01		sta $01,x	                sta 1,x
.9646		60		rts		z_not_equals:   rts
.9647						xt_not_rote:
.9647		20 51 d9	jsr $d951	                jsr underflow_3
.964a		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.964c		b5 03		lda $03,x	                lda 3,x
.964e		95 01		sta $01,x	                sta 1,x
.9650		b5 05		lda $05,x	                lda 5,x
.9652		95 03		sta $03,x	                sta 3,x
.9654		94 05		sty $05,x	                sty 5,x
.9656		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9658		b5 02		lda $02,x	                lda 2,x
.965a		95 00		sta $00,x	                sta 0,x
.965c		b5 04		lda $04,x	                lda 4,x
.965e		95 02		sta $02,x	                sta 2,x
.9660		94 04		sty $04,x	                sty 4,x
.9662		60		rts		z_not_rote:     rts
.9663						xt_number:
.9663		20 4c d9	jsr $d94c	                jsr underflow_2
.9666		64 2a		stz $2a		                stz tmpdsp      ; flag for double
.9668		64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.966a		a5 18		lda $18		                lda base
.966c		48		pha		                pha
.966d		20 62 a3	jsr $a362	                jsr xt_two_dup
.9670		a1 02		lda ($02,x)	                lda (2,x)
.9672						_check_dec:
.9672		c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.9674		d0 04		bne $967a	                bne _check_hex
.9676		a9 0a		lda #$0a	                lda #$0A
.9678		80 42		bra $96bc	                bra _base_changed
.967a						_check_hex:
.967a		c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.967c		d0 04		bne $9682	                bne _check_binary
.967e		a9 10		lda #$10	                lda #$10
.9680		80 3a		bra $96bc	                bra _base_changed
.9682						_check_binary:
.9682		c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.9684		d0 04		bne $968a	                bne _check_char
.9686		a9 02		lda #$02	                lda #$02
.9688		80 32		bra $96bc	                bra _base_changed
.968a						_check_char:
.968a		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.968c		d0 3a		bne $96c8	                bne _check_minus
.968e		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9690		c9 03		cmp #$03	                cmp #$03
.9692		d0 26		bne $96ba	                bne _not_a_char
.9694		b5 01		lda $01,x	                lda 1,x
.9696		d0 22		bne $96ba	                bne _not_a_char ; No compare needed to check for non-zero.
.9698		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.969a		18		clc		                clc
.969b		69 02		adc #$02	                adc #2          ; length of string
.969d		85 2c		sta $2c		                sta tmptos
.969f		b5 03		lda $03,x	                lda 3,x
.96a1		69 00		adc #$00	                adc #0          ; only need carry
.96a3		85 2d		sta $2d		                sta tmptos+1
.96a5		b2 2c		lda ($2c)	                lda (tmptos)
.96a7		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96a9		d0 0f		bne $96ba	                bne _not_a_char
.96ab		f6 02		inc $02,x	                inc 2,x
.96ad		d0 02		bne $96b1	                bne +
.96af		f6 03		inc $03,x	                inc 3,x
.96b1						+
.96b1		a1 02		lda ($02,x)	                lda (2,x)
.96b3		95 02		sta $02,x	                sta 2,x
.96b5		74 03		stz $03,x	                stz 3,x
.96b7		4c 38 97	jmp $9738	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96ba						_not_a_char:
.96ba		80 5a		bra $9716	                bra _number_error
.96bc						_base_changed:
.96bc		85 18		sta $18		                sta base        ; Switch to the new base
.96be		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96c0		d0 02		bne $96c4	                bne +
.96c2		f6 03		inc $03,x	                inc 3,x
.96c4						+
.96c4		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96c6		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96c8						_check_minus:
.96c8		c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96ca		d0 0a		bne $96d6	                bne _check_dot
.96cc		c6 2b		dec $2b		                dec tmpdsp+1
.96ce		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96d0		d0 02		bne $96d4	                bne +
.96d2		f6 03		inc $03,x	                inc 3,x
.96d4						+
.96d4		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96d6						_check_dot:
.96d6		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96d8		18		clc		                clc
.96d9		75 00		adc $00,x	                adc 0,x         ; length of string
.96db		85 2c		sta $2c		                sta tmptos
.96dd		b5 03		lda $03,x	                lda 3,x
.96df		69 00		adc #$00	                adc #0          ; only need carry
.96e1		85 2d		sta $2d		                sta tmptos+1
.96e3		a5 2c		lda $2c		                lda tmptos
.96e5		d0 02		bne $96e9	                bne +
.96e7		c6 2d		dec $2d		                dec tmptos+1
.96e9						+
.96e9		c6 2c		dec $2c		                dec tmptos
.96eb		b2 2c		lda ($2c)	                lda (tmptos)
.96ed		c9 2e		cmp #$2e	                cmp #'.'
.96ef		d0 04		bne $96f5	                bne _main
.96f1		c6 2a		dec $2a		                dec tmpdsp
.96f3		d6 00		dec $00,x	                dec 0,x
.96f5						_main:
.96f5		ca		dex		                dex
.96f6		ca		dex		                dex
.96f7		ca		dex		                dex
.96f8		ca		dex		                dex
.96f9		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.96fb		95 00		sta $00,x	                sta 0,x
.96fd		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.96ff		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9701		95 02		sta $02,x	                sta 2,x
.9703		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9705		95 03		sta $03,x	                sta 3,x
.9707		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9709		74 05		stz $05,x	                stz 5,x
.970b		74 06		stz $06,x	                stz 6,x
.970d		74 07		stz $07,x	                stz 7,x
.970f		20 67 a2	jsr $a267	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9712		b5 00		lda $00,x	                lda 0,x
.9714		f0 1e		beq $9734	                beq _all_converted
.9716						_number_error:
.9716		20 5a a3	jsr $a35a	                jsr xt_two_drop ; >NUMBER modified addr u
.9719		20 5a a3	jsr $a35a	                jsr xt_two_drop ; ud   (partially converted number)
.971c		a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.971e		20 b9 8d	jsr $8db9	                jsr emit_a
.9721		20 ad a4	jsr $a4ad	                jsr xt_type
.9724		a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.9726		20 b9 8d	jsr $8db9	                jsr emit_a
.9729		20 c8 a0	jsr $a0c8	                jsr xt_space
.972c		68		pla		                pla
.972d		85 18		sta $18		                sta base
.972f		a9 08		lda #$08	                lda #err_syntax
.9731		4c 5d d9	jmp $d95d	                jmp error
.9734						_all_converted:
.9734		e8		inx		                inx ; Drop the current addr u
.9735		e8		inx		                inx
.9736		e8		inx		                inx
.9737		e8		inx		                inx
.9738						_drop_original_string:
.9738		20 28 a4	jsr $a428	                jsr xt_two_swap  ; Drop the original addr u
.973b		20 5a a3	jsr $a35a	                jsr xt_two_drop  ; (was saved for unknown word error message)
.973e		a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9740		f0 0d		beq $974f	                beq _single
.9742		a9 20		lda #$20	                lda #%00100000
.9744		04 20		tsb $20		                tsb status
.9746		a5 2b		lda $2b		                lda tmpdsp+1
.9748		f0 12		beq $975c	                beq _done       ; no minus, all done
.974a		20 18 8b	jsr $8b18	                jsr xt_dnegate
.974d		80 0d		bra $975c	                bra _done
.974f						_single:
.974f		e8		inx		                inx
.9750		e8		inx		                inx
.9751		a9 20		lda #$20	                lda #%00100000
.9753		14 20		trb $20		                trb status
.9755		a5 2b		lda $2b		                lda tmpdsp+1
.9757		f0 03		beq $975c	                beq _done       ; no minus, all done
.9759		20 fc 95	jsr $95fc	                jsr xt_negate
.975c						_done:
.975c		68		pla		                pla
.975d		85 18		sta $18		                sta base
.975f		60		rts		z_number:       rts
.9760						xt_number_sign:
.9760		20 4c d9	jsr $d94c	                jsr underflow_2         ; double number
.9763		20 4d 83	jsr $834d	                jsr xt_base
.9766		20 43 8f	jsr $8f43	                jsr xt_fetch            ; ( ud1 base )
.9769		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >r
.976c		20 52 a7	jsr $a752	                jsr xt_zero             ; 0
.976f		20 56 9a	jsr $9a56	                jsr xt_r_fetch          ; r@
.9772		20 64 a5	jsr $a564	                jsr xt_um_slash_mod     ; um/mod
.9775		20 30 9b	jsr $9b30	                jsr xt_rot              ; rot
.9778		20 30 9b	jsr $9b30	                jsr xt_rot              ; rot
.977b		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; r>
.977e		20 64 a5	jsr $a564	                jsr xt_um_slash_mod     ; um/mod
.9781		20 30 9b	jsr $9b30	                jsr xt_rot              ; rot
.9784		20 30 9b	jsr $9b30	                jsr xt_rot              ; ( ud rem )
.9787		b5 00		lda $00,x	                lda 0,x
.9789		a8		tay		                tay
.978a		b9 07 d5	lda $d507,y	                lda s_abc_upper,y
.978d		95 00		sta $00,x	                sta 0,x
.978f		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.9791		20 9a 91	jsr $919a	                jsr xt_hold
.9794						z_number_sign:
.9794		60		rts		                rts
.9795						xt_number_sign_greater:
.9795		20 4c d9	jsr $d94c	                jsr underflow_2         ; double number
.9798		a5 34		lda $34		                lda tohold
.979a		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.979c		95 02		sta $02,x	                sta 2,x
.979e		a5 35		lda $35		                lda tohold+1
.97a0		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97a2		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97a4		20 7a 98	jsr $987a	                jsr xt_pad      ; ( addr addr pad )
.97a7		38		sec		                sec
.97a8		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97aa		f5 02		sbc $02,x	                sbc 2,x
.97ac		95 02		sta $02,x	                sta 2,x
.97ae		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97b0		f5 03		sbc $03,x	                sbc 3,x
.97b2		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97b4		e8		inx		                inx
.97b5		e8		inx		                inx
.97b6						z_number_sign_greater:
.97b6		60		rts		                rts
.97b7						xt_number_sign_s:
.97b7		20 4c d9	jsr $d94c	                jsr underflow_2
.97ba						_loop:
.97ba		20 60 97	jsr $9760	                jsr xt_number_sign
.97bd		b5 00		lda $00,x	                lda 0,x
.97bf		15 01		ora $01,x	                ora 1,x
.97c1		15 02		ora $02,x	                ora 2,x
.97c3		15 03		ora $03,x	                ora 3,x
.97c5		d0 f3		bne $97ba	                bne _loop
.97c7						z_number_sign_s:
.97c7		60		rts		                rts
.97c8						xt_of:
.97c8		a0 98		ldy #$98	                ldy #>xt_over
.97ca		a9 6c		lda #$6c	                lda #<xt_over
.97cc		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.97cf		a0 8e		ldy #$8e	                ldy #>xt_equal
.97d1		a9 91		lda #$91	                lda #<xt_equal
.97d3		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.97d6		20 c4 91	jsr $91c4	                jsr xt_if
.97d9		a0 8c		ldy #$8c	                ldy #>xt_drop
.97db		a9 f1		lda #$f1	                lda #<xt_drop
.97dd		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.97e0		60		rts		z_of:           rts
.97e1						xt_editor_wordlist:
.97e1						xt_one:
.97e1		ca		dex		                dex
.97e2		ca		dex		                dex
.97e3		a9 01		lda #$01	                lda #1
.97e5		95 00		sta $00,x	                sta 0,x
.97e7		74 01		stz $01,x	                stz 1,x
.97e9						z_editor_wordlist:
.97e9						z_one:
.97e9		60		rts		                rts
.97ea						xt_one_minus:
.97ea		20 47 d9	jsr $d947	                jsr underflow_1
.97ed		b5 00		lda $00,x	                lda 0,x
.97ef		d0 02		bne $97f3	                bne +
.97f1		d6 01		dec $01,x	                dec 1,x
.97f3						+
.97f3		d6 00		dec $00,x	                dec 0,x
.97f5		60		rts		z_one_minus:    rts
.97f6						xt_char_plus:
.97f6						xt_one_plus:
.97f6		20 47 d9	jsr $d947	                jsr underflow_1
.97f9		f6 00		inc $00,x	                inc 0,x
.97fb		d0 02		bne $97ff	                bne _done
.97fd		f6 01		inc $01,x	                inc 1,x
.97ff						_done:
.97ff						z_char_plus:
.97ff		60		rts		z_one_plus:     rts
.9800						xt_only:
.9800		ca		dex		                dex
.9801		ca		dex		                dex
.9802		a9 ff		lda #$ff	                lda #$FF
.9804		95 00		sta $00,x	                sta 0,x
.9806		95 01		sta $01,x	                sta 1,x
.9808		20 f4 9c	jsr $9cf4	                jsr xt_set_order
.980b		60		rts		z_only:         rts
.980c						xt_or:
.980c		20 4c d9	jsr $d94c	                jsr underflow_2
.980f		b5 00		lda $00,x	                lda 0,x
.9811		15 02		ora $02,x	                ora 2,x
.9813		95 02		sta $02,x	                sta 2,x
.9815		b5 01		lda $01,x	                lda 1,x
.9817		15 03		ora $03,x	                ora 3,x
.9819		95 03		sta $03,x	                sta 3,x
.981b		e8		inx		                inx
.981c		e8		inx		                inx
.981d		60		rts		z_or:           rts
.981e						xt_order:
.981e		20 3a 89	jsr $893a	                jsr xt_cr
.9821		20 f7 90	jsr $90f7	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.9824		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9826		f0 1e		beq $9846	                beq _drop_done
.9828						_have_wordlists:
.9828		a8		tay		                tay
.9829						_loop:
.9829		e8		inx		                inx
.982a		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.982b		b5 00		lda $00,x	                lda 0,x
.982d		5a		phy		                phy
.982e		20 49 98	jsr $9849	                jsr order_print_wid_string   ; internal helper function
.9831		7a		ply		                ply
.9832		88		dey		                dey
.9833		d0 f4		bne $9829	                bne _loop
.9835		20 c8 a0	jsr $a0c8	                jsr xt_space
.9838		20 c8 a0	jsr $a0c8	                jsr xt_space
.983b		20 ec 90	jsr $90ec	                jsr xt_get_current      ; ( wid )
.983e		b5 00		lda $00,x	                lda 0,x
.9840		20 49 98	jsr $9849	                jsr order_print_wid_string
.9843		20 3a 89	jsr $893a	                jsr xt_cr
.9846						_drop_done:
.9846		e8		inx		                inx
.9847		e8		inx		                inx
.9848						z_order:
.9848		60		rts		                rts
.9849						order_print_wid_string:
.9849		c9 04		cmp #$04	                cmp #4
.984b		90 09		bcc $9856	                bcc _output_string      ; less than 4, print a real string
.984d		ca		dex		                dex
.984e		ca		dex		                dex
.984f		95 00		sta $00,x	                sta 0,x
.9851		74 01		stz $01,x	                stz 1,x
.9853		4c d8 a4	jmp $a4d8	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.9856						_output_string:
.9856		a8		tay		                tay
.9857		b9 5d 98	lda $985d,y	                lda _wid_data,y
.985a		4c 83 d9	jmp $d983	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.985d						_wid_data:
>985d		04				        .byte str_wid_forth            ; WID 0: "Forth"
>985e		05				        .byte str_wid_editor           ; WID 1: "Editor"
>985f		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9860		07				        .byte str_wid_root             ; WID 3: "Root"
.9861						xt_output:
.9861		ca		dex		                dex
.9862		ca		dex		                dex
.9863		a9 10		lda #$10	                lda #<output
.9865		95 00		sta $00,x	                sta 0,x
.9867		a9 00		lda #$00	                lda #>output
.9869		95 01		sta $01,x	                sta 1,x
.986b		60		rts		z_output:       rts
.986c						xt_over:
.986c		20 4c d9	jsr $d94c	                jsr underflow_2
.986f		ca		dex		                dex
.9870		ca		dex		                dex
.9871		b5 04		lda $04,x	                lda 4,x         ; LSB
.9873		95 00		sta $00,x	                sta 0,x
.9875		b5 05		lda $05,x	                lda 5,x         ; MSB
.9877		95 01		sta $01,x	                sta 1,x
.9879		60		rts		z_over:         rts
.987a						xt_pad:
.987a		ca		dex		                dex
.987b		ca		dex		                dex
.987c		a5 00		lda $00		                lda cp
.987e		18		clc		                clc
.987f		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.9881		95 00		sta $00,x	                sta 0,x
.9883		a5 01		lda $01		                lda cp+1
.9885		69 00		adc #$00	                adc #0          ; only need carry
.9887		95 01		sta $01,x	                sta 1,x
.9889		60		rts		z_pad:          rts
.988a						xt_page:
.988a		a9 1b		lda #$1b	                lda #AscESC
.988c		20 b9 8d	jsr $8db9	                jsr emit_a
.988f		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.9891		20 b9 8d	jsr $8db9	                jsr emit_a
.9894		a9 32		lda #$32	                lda #'2'
.9896		20 b9 8d	jsr $8db9	                jsr emit_a
.9899		a9 4a		lda #$4a	                lda #'J'
.989b		20 b9 8d	jsr $8db9	                jsr emit_a
.989e		20 52 a7	jsr $a752	                jsr xt_zero
.98a1		20 52 a7	jsr $a752	                jsr xt_zero
.98a4		20 f4 82	jsr $82f4	                jsr xt_at_xy
.98a7		60		rts		z_page:         rts
.98a8						xt_paren:
.98a8		ca		dex		                dex
.98a9		ca		dex		                dex
.98aa		a9 29		lda #$29	                lda #41     ; Right parenthesis
.98ac		95 00		sta $00,x	                sta 0,x
.98ae		74 01		stz $01,x	                stz 1,x
.98b0		20 13 99	jsr $9913	                jsr xt_parse
.98b3		e8		inx		                inx
.98b4		e8		inx		                inx
.98b5		e8		inx		                inx
.98b6		e8		inx		                inx
.98b7		60		rts		z_paren:        rts
.98b8						xt_parse_name:
.98b8		a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98ba		38		sec		                sec
.98bb		e5 0c		sbc $0c		                sbc toin
.98bd		85 24		sta $24		                sta tmp1
.98bf		a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98c1		e5 0d		sbc $0d		                sbc toin+1
.98c3		85 25		sta $25		                sta tmp1+1
.98c5		a5 24		lda $24		                lda tmp1
.98c7		05 25		ora $25		                ora tmp1+1
.98c9		f0 28		beq $98f3	                beq _empty_line
.98cb		a5 08		lda $08		                lda cib
.98cd		18		clc		                clc
.98ce		65 0c		adc $0c		                adc toin
.98d0		85 26		sta $26		                sta tmp2                ; LSB of first character
.98d2		a5 09		lda $09		                lda cib+1
.98d4		65 0d		adc $0d		                adc toin+1
.98d6		85 27		sta $27		                sta tmp2+1              ; MSB
.98d8						_skip_loop:
.98d8		b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.98da		20 3a d9	jsr $d93a	                jsr is_whitespace
.98dd		90 1f		bcc $98fe	                bcc _char_found
.98df		e6 26		inc $26		                inc tmp2
.98e1		d0 02		bne $98e5	                bne +
.98e3		e6 27		inc $27		                inc tmp2+1
.98e5						+
.98e5		a5 24		lda $24		                lda tmp1
.98e7		d0 02		bne $98eb	                bne +
.98e9		c6 25		dec $25		                dec tmp1+1
.98eb		c6 24		dec $24		+               dec tmp1
.98ed		a5 24		lda $24		                lda tmp1
.98ef		05 25		ora $25		                ora tmp1+1
.98f1		d0 e5		bne $98d8	                bne _skip_loop          ; fall through if empty line
.98f3						_empty_line:
.98f3		ca		dex		                dex
.98f4		ca		dex		                dex
.98f5		ca		dex		                dex
.98f6		ca		dex		                dex
.98f7		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.98f9		74 01		stz $01,x	                stz 1,x
.98fb		4c aa 99	jmp $99aa	                jmp z_parse_name        ; skip over PARSE
.98fe						_char_found:
.98fe		a5 26		lda $26		                lda tmp2
.9900		38		sec		                sec
.9901		e5 08		sbc $08		                sbc cib
.9903		85 0c		sta $0c		                sta toin
.9905		a5 27		lda $27		                lda tmp2+1
.9907		e5 09		sbc $09		                sbc cib+1
.9909		85 0d		sta $0d		                sta toin+1
.990b		ca		dex		                dex
.990c		ca		dex		                dex
.990d		a9 20		lda #$20	                lda #AscSP
.990f		95 00		sta $00,x	                sta 0,x
.9911		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.9913						xt_parse:
.9913		20 47 d9	jsr $d947	                jsr underflow_1
.9916		a5 0a		lda $0a		                lda ciblen
.9918		05 0b		ora $0b		                ora ciblen+1
.991a		f0 0c		beq $9928	                beq _abort_parse
.991c		a5 0d		lda $0d		                lda toin+1              ; MSB
.991e		c5 0b		cmp $0b		                cmp ciblen+1
.9920		90 0e		bcc $9930	                bcc _go_parse           ; unsigned comparison
.9922		a5 0c		lda $0c		                lda toin                ; LSB
.9924		c5 0a		cmp $0a		                cmp ciblen
.9926		90 08		bcc $9930	                bcc _go_parse
.9928						_abort_parse:
.9928		ca		dex		                dex
.9929		ca		dex		                dex
.992a		74 00		stz $00,x	                stz 0,x
.992c		74 01		stz $01,x	                stz 1,x
.992e		80 7a		bra $99aa	                bra _done
.9930						_go_parse:
.9930		b5 00		lda $00,x	                lda 0,x
.9932		85 2c		sta $2c		                sta tmptos
.9934		ca		dex		                dex
.9935		ca		dex		                dex
.9936		a5 08		lda $08		                lda cib
.9938		18		clc		                clc
.9939		65 0c		adc $0c		                adc toin        ; LSB
.993b		85 24		sta $24		                sta tmp1
.993d		85 26		sta $26		                sta tmp2
.993f		95 02		sta $02,x	                sta 2,x
.9941		a5 09		lda $09		                lda cib+1
.9943		65 0d		adc $0d		                adc toin+1      ; MSB
.9945		85 25		sta $25		                sta tmp1+1
.9947		85 27		sta $27		                sta tmp2+1
.9949		95 03		sta $03,x	                sta 3,x
.994b		a5 08		lda $08		                lda cib
.994d		18		clc		                clc
.994e		65 0a		adc $0a		                adc ciblen
.9950		85 28		sta $28		                sta tmp3
.9952		a5 09		lda $09		                lda cib+1
.9954		65 0b		adc $0b		                adc ciblen+1
.9956		85 29		sta $29		                sta tmp3+1
.9958		64 2d		stz $2d		                stz tmptos+1
.995a						_loop:
.995a		a5 26		lda $26		                lda tmp2
.995c		c5 28		cmp $28		                cmp tmp3
.995e		d0 06		bne $9966	                bne _not_empty
.9960		a5 27		lda $27		                lda tmp2+1
.9962		c5 29		cmp $29		                cmp tmp3+1
.9964		f0 1d		beq $9983	                beq _eol
.9966						_not_empty:
.9966		b2 26		lda ($26)	                lda (tmp2)
.9968		a4 2c		ldy $2c		                ldy tmptos
.996a		c0 20		cpy #$20	                cpy #AscSP
.996c		d0 07		bne $9975	                bne _not_whitespace
.996e		20 3a d9	jsr $d93a	                jsr is_whitespace
.9971		90 02		bcc $9975	                bcc _not_whitespace
.9973		80 0c		bra $9981	                bra _found_delimiter
.9975						_not_whitespace:
.9975		c5 2c		cmp $2c		                cmp tmptos
.9977		f0 08		beq $9981	                beq _found_delimiter
.9979		e6 26		inc $26		                inc tmp2
.997b		d0 dd		bne $995a	                bne _loop
.997d		e6 27		inc $27		                inc tmp2+1
.997f		80 d9		bra $995a	                bra _loop
.9981						_found_delimiter:
.9981		e6 2d		inc $2d		                inc tmptos+1
.9983						_eol:
.9983		a5 26		lda $26		                lda tmp2
.9985		38		sec		                sec
.9986		e5 24		sbc $24		                sbc tmp1
.9988		95 00		sta $00,x	                sta 0,x
.998a		a5 27		lda $27		                lda tmp2+1
.998c		e5 25		sbc $25		                sbc tmp1+1
.998e		95 01		sta $01,x	                sta 1,x
.9990		a5 26		lda $26		                lda tmp2
.9992		38		sec		                sec
.9993		e5 08		sbc $08		                sbc cib
.9995		85 0c		sta $0c		                sta toin
.9997		a5 27		lda $27		                lda tmp2+1
.9999		e5 09		sbc $09		                sbc cib+1
.999b		85 0d		sta $0d		                sta toin+1
.999d		a5 0c		lda $0c		                lda toin
.999f		18		clc		                clc
.99a0		65 2d		adc $2d		                adc tmptos+1
.99a2		85 0c		sta $0c		                sta toin
.99a4		a5 0d		lda $0d		                lda toin+1
.99a6		69 00		adc #$00	                adc #0          ; we only need the carry
.99a8		85 0d		sta $0d		                sta toin+1
.99aa						_done:
.99aa						z_parse_name:
.99aa		60		rts		z_parse:        rts
.99ab						xt_pick:
.99ab		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99ad		8a		txa		                txa
.99ae		75 00		adc $00,x	                adc 0,x
.99b0		a8		tay		                tay
.99b1		b9 02 00	lda $0002,y	                lda 0002,y
.99b4		95 00		sta $00,x	                sta 0,x
.99b6		b9 03 00	lda $0003,y	                lda 0003,y
.99b9		95 01		sta $01,x	                sta 1,x
.99bb		60		rts		z_pick:         rts
.99bc						xt_plus:
.99bc		20 4c d9	jsr $d94c	                jsr underflow_2
.99bf		18		clc		                clc
.99c0		b5 00		lda $00,x	                lda 0,x         ; LSB
.99c2		75 02		adc $02,x	                adc 2,x
.99c4		95 02		sta $02,x	                sta 2,x
.99c6		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99c8		75 03		adc $03,x	                adc 3,x
.99ca		95 03		sta $03,x	                sta 3,x
.99cc		e8		inx		                inx
.99cd		e8		inx		                inx
.99ce		60		rts		z_plus:         rts
.99cf						xt_plus_store:
.99cf		20 4c d9	jsr $d94c	                jsr underflow_2
.99d2		b5 00		lda $00,x	                lda 0,x
.99d4		85 24		sta $24		                sta tmp1
.99d6		b5 01		lda $01,x	                lda 1,x
.99d8		85 25		sta $25		                sta tmp1+1
.99da		a0 00		ldy #$00	                ldy #0          ; LSB
.99dc		b1 24		lda ($24),y	                lda (tmp1),y
.99de		18		clc		                clc
.99df		75 02		adc $02,x	                adc 2,x
.99e1		91 24		sta ($24),y	                sta (tmp1),y
.99e3		c8		iny		                iny             ; MSB
.99e4		b1 24		lda ($24),y	                lda (tmp1),y
.99e6		75 03		adc $03,x	                adc 3,x
.99e8		91 24		sta ($24),y	                sta (tmp1),y
.99ea		e8		inx		                inx
.99eb		e8		inx		                inx
.99ec		e8		inx		                inx
.99ed		e8		inx		                inx
.99ee		60		rts		z_plus_store:   rts
.99ef						xt_postpone:
.99ef		20 b8 98	jsr $98b8	                jsr xt_parse_name               ; ( -- addr n )
.99f2		b5 00		lda $00,x	                lda 0,x
.99f4		15 01		ora $01,x	                ora 1,x
.99f6		d0 05		bne $99fd	                bne +
.99f8		a9 05		lda #$05	                lda #err_noname
.99fa		4c 5d d9	jmp $d95d	                jmp error
.99fd						+
.99fd		20 9e 8f	jsr $8f9e	                jsr xt_find_name                ; ( -- nt | 0 )
.9a00		d0 05		bne $9a07	                bne +
.9a02		a9 05		lda #$05	                lda #err_noname
.9a04		4c 5d d9	jmp $d95d	                jmp error
.9a07						+
.9a07		b5 00		lda $00,x	                lda 0,x
.9a09		85 24		sta $24		                sta tmp1
.9a0b		b5 01		lda $01,x	                lda 1,x
.9a0d		85 25		sta $25		                sta tmp1+1
.9a0f		20 ba 95	jsr $95ba	                jsr xt_name_to_int              ; ( nt -- xt )
.9a12		e6 24		inc $24		                inc tmp1
.9a14		d0 02		bne $9a18	                bne +
.9a16		e6 25		inc $25		                inc tmp1+1
.9a18						+
.9a18		b2 24		lda ($24)	                lda (tmp1)
.9a1a		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a1c		f0 05		beq $9a23	                beq _not_immediate
.9a1e		20 b3 87	jsr $87b3	                jsr xt_compile_comma
.9a21		80 0a		bra $9a2d	                bra _done
.9a23						_not_immediate:
.9a23		20 4b 93	jsr $934b	                jsr xt_literal
.9a26		a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a28		a9 b3		lda #$b3	                lda #<xt_compile_comma
.9a2a		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.9a2d						_done:
.9a2d		60		rts		z_postpone:     rts
.9a2e						xt_previous:
.9a2e		20 f7 90	jsr $90f7	                jsr xt_get_order
.9a31		20 1b 96	jsr $961b	                jsr xt_nip
.9a34		20 ea 97	jsr $97ea	                jsr xt_one_minus
.9a37		20 f4 9c	jsr $9cf4	                jsr xt_set_order
.9a3a		60		rts		z_previous:     rts
.9a3b						xt_question:
.9a3b		20 43 8f	jsr $8f43	                jsr xt_fetch
.9a3e		20 f9 8b	jsr $8bf9	                jsr xt_dot
.9a41		60		rts		z_question:     rts
.9a42						xt_question_dup:
.9a42		20 47 d9	jsr $d947	                jsr underflow_1
.9a45		b5 00		lda $00,x	                lda 0,x
.9a47		15 01		ora $01,x	                ora 1,x
.9a49		f0 0a		beq $9a55	                beq _done
.9a4b		ca		dex		                dex
.9a4c		ca		dex		                dex
.9a4d		b5 02		lda $02,x	                lda 2,x
.9a4f		95 00		sta $00,x	                sta 0,x
.9a51		b5 03		lda $03,x	                lda 3,x
.9a53		95 01		sta $01,x	                sta 1,x
.9a55						_done:
.9a55		60		rts		z_question_dup: rts
.9a56						xt_r_fetch:
.9a56		7a		ply		                ply             ; LSB
.9a57		84 24		sty $24		                sty tmp1
.9a59		7a		ply		                ply             ; MSB
.9a5a		ca		dex		                dex
.9a5b		ca		dex		                dex
.9a5c		68		pla		                pla             ; LSB
.9a5d		95 00		sta $00,x	                sta 0,x
.9a5f		68		pla		                pla             ; MSB
.9a60		95 01		sta $01,x	                sta 1,x
.9a62		48		pha		                pha
.9a63		b5 00		lda $00,x	                lda 0,x
.9a65		48		pha		                pha
.9a66		5a		phy		                phy             ; MSB
.9a67		a4 24		ldy $24		                ldy tmp1
.9a69		5a		phy		                phy             ; LSB
.9a6a		60		rts		z_r_fetch:      rts
.9a6b						xt_r_from:
.9a6b		68		pla		                pla             ; LSB
.9a6c		85 2c		sta $2c		                sta tmptos
.9a6e		7a		ply		                ply             ; MSB
.9a6f		ca		dex		                dex
.9a70		ca		dex		                dex
.9a71		68		pla		                pla             ; LSB
.9a72		95 00		sta $00,x	                sta 0,x
.9a74		68		pla		                pla             ; MSB
.9a75		95 01		sta $01,x	                sta 1,x
.9a77		5a		phy		                phy             ; MSB
.9a78		a5 2c		lda $2c		                lda tmptos
.9a7a		48		pha		                pha             ; LSB
.9a7b		60		rts		z_r_from:       rts
.9a7c						xt_r_to_input:
.9a7c		68		pla		                pla
.9a7d		85 24		sta $24		                sta tmp1
.9a7f		68		pla		                pla
.9a80		85 25		sta $25		                sta tmp1+1
.9a82		a0 00		ldy #$00	                ldy #0
.9a84						_loop:
.9a84		68		pla		                pla
.9a85		99 06 00	sta $0006,y	                sta insrc,y
.9a88		c8		iny		                iny
.9a89		c0 08		cpy #$08	                cpy #8
.9a8b		d0 f7		bne $9a84	                bne _loop
.9a8d		a5 25		lda $25		                lda tmp1+1
.9a8f		48		pha		                pha
.9a90		a5 24		lda $24		                lda tmp1
.9a92		48		pha		                pha
.9a93		60		rts		z_r_to_input: 	rts
.9a94						xt_recurse:
.9a94		a0 00		ldy #$00	                ldy #0
.9a96		a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9a98		91 00		sta ($00),y	                sta (cp),y
.9a9a		c8		iny		                iny
.9a9b		24 20		bit $20		                bit status
.9a9d		70 0c		bvs $9aab	                bvs _nt_in_workword
.9a9f		a5 04		lda $04		                lda workword
.9aa1		91 00		sta ($00),y	                sta (cp),y
.9aa3		c8		iny		                iny
.9aa4		a5 05		lda $05		                lda workword+1
.9aa6		91 00		sta ($00),y	                sta (cp),y
.9aa8		c8		iny		                iny
.9aa9		80 1b		bra $9ac6	                bra _update_cp
.9aab						_nt_in_workword:
.9aab		a5 04		lda $04		                lda workword            ; LSB
.9aad		18		clc		                clc
.9aae		69 04		adc #$04	                adc #4
.9ab0		85 24		sta $24		                sta tmp1
.9ab2		a5 05		lda $05		                lda workword+1          ; MSB
.9ab4		69 00		adc #$00	                adc #0
.9ab6		85 25		sta $25		                sta tmp1+1
.9ab8		b2 24		lda ($24)	                lda (tmp1)
.9aba		91 00		sta ($00),y	                sta (cp),y
.9abc		5a		phy		                phy
.9abd		a0 01		ldy #$01	                ldy #1
.9abf		b1 24		lda ($24),y	                lda (tmp1),y
.9ac1		7a		ply		                ply
.9ac2		c8		iny		                iny
.9ac3		91 00		sta ($00),y	                sta (cp),y
.9ac5		c8		iny		                iny
.9ac6						_update_cp:
.9ac6		98		tya		                tya
.9ac7		18		clc		                clc
.9ac8		65 00		adc $00		                adc cp
.9aca		85 00		sta $00		                sta cp
.9acc		90 02		bcc $9ad0	                bcc _done
.9ace		e6 01		inc $01		                inc cp+1
.9ad0						_done:
.9ad0		60		rts		z_recurse:      rts
.9ad1						xt_refill:
.9ad1		a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9ad3		d0 2d		bne $9b02	                bne _src_not_kbd
.9ad5		ca		dex		                dex
.9ad6		ca		dex		                dex
.9ad7		ca		dex		                dex
.9ad8		ca		dex		                dex
.9ad9		a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9adb		95 02		sta $02,x	                sta 2,x
.9add		a5 09		lda $09		                lda cib+1
.9adf		95 03		sta $03,x	                sta 3,x
.9ae1		64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9ae3		64 0b		stz $0b		                stz ciblen+1
.9ae5		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9ae7		95 00		sta $00,x	                sta 0,x
.9ae9		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9aeb		20 f2 80	jsr $80f2	                jsr xt_accept           ; ( addr n1 -- n2)
.9aee		b5 00		lda $00,x	                lda 0,x
.9af0		85 0a		sta $0a		                sta ciblen
.9af2		b5 01		lda $01,x	                lda 1,x
.9af4		85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9af6		64 0c		stz $0c		                stz toin
.9af8		64 0d		stz $0d		                stz toin+1
.9afa		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9afc		95 00		sta $00,x	                sta 0,x
.9afe		95 01		sta $01,x	                sta 1,x
.9b00		80 10		bra $9b12	                bra _done
.9b02						_src_not_kbd:
.9b02		1a		inc a		                ina
.9b03		d0 08		bne $9b0d	                bne _src_not_string
.9b05		ca		dex		                dex
.9b06		ca		dex		                dex
.9b07		74 00		stz $00,x	                stz 0,x
.9b09		74 01		stz $01,x	                stz 1,x
.9b0b		80 05		bra $9b12	                bra z_refill
.9b0d						_src_not_string:
.9b0d		a9 01		lda #$01	                lda #err_badsource
.9b0f		4c 5d d9	jmp $d95d	                jmp error
.9b12						_done:
.9b12		60		rts		z_refill:       rts
.9b13						xt_repeat:
.9b13		20 2d 82	jsr $822d	                jsr xt_again
.9b16		20 35 91	jsr $9135	                jsr xt_here
.9b19		20 58 a1	jsr $a158	                jsr xt_swap
.9b1c		20 37 a1	jsr $a137	                jsr xt_store
.9b1f		60		rts		z_repeat:       rts
.9b20						xt_right_bracket:
.9b20		a9 ff		lda #$ff	                lda #$FF
.9b22		85 16		sta $16		                sta state
.9b24		85 17		sta $17		                sta state+1
.9b26						z_right_bracket:
.9b26		60		rts		                rts
.9b27						xt_root_wordlist:
.9b27		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b28		ca		dex		                dex
.9b29		a9 03		lda #$03	                lda #3
.9b2b		95 00		sta $00,x	                sta 0,x
.9b2d		74 01		stz $01,x	                stz 1,x
.9b2f						z_root_wordlist:
.9b2f		60		rts		                rts
.9b30						xt_rot:
.9b30		20 51 d9	jsr $d951	                jsr underflow_3
.9b33		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b35		b5 03		lda $03,x	                lda 3,x
.9b37		95 05		sta $05,x	                sta 5,x
.9b39		b5 01		lda $01,x	                lda 1,x
.9b3b		95 03		sta $03,x	                sta 3,x
.9b3d		94 01		sty $01,x	                sty 1,x
.9b3f		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b41		b5 02		lda $02,x	                lda 2,x
.9b43		95 04		sta $04,x	                sta 4,x
.9b45		b5 00		lda $00,x	                lda 0,x
.9b47		95 02		sta $02,x	                sta 2,x
.9b49		94 00		sty $00,x	                sty 0,x
.9b4b		60		rts		z_rot:          rts
.9b4c						xt_rshift:
.9b4c		20 4c d9	jsr $d94c	                jsr underflow_2
.9b4f		b5 00		lda $00,x	                lda 0,x
.9b51		29 0f		and #$0f	                and #%00001111
.9b53		f0 08		beq $9b5d	                beq _done               ; if 0 shifts, quit
.9b55		a8		tay		                tay
.9b56						_loop:
.9b56		56 03		lsr $03,x	                lsr 3,x
.9b58		76 02		ror $02,x	                ror 2,x
.9b5a		88		dey		                dey
.9b5b		d0 f9		bne $9b56	                bne _loop
.9b5d						_done:
.9b5d		e8		inx		                inx
.9b5e		e8		inx		                inx
.9b5f		60		rts		z_rshift:       rts
.9b60						xt_s_backslash_quote:
.9b60		a9 ff		lda #$ff	                lda #$FF
.9b62		85 26		sta $26		                sta tmp2
.9b64		64 27		stz $27		                stz tmp2+1
.9b66		20 2c 9d	jsr $9d2c	                jsr s_quote_start
.9b69						_done:
.9b69						z_s_backslash_quote:
.9b69		60		rts		                rts
.9b6a						convert_hex_value:
.9b6a		c9 41		cmp #$41	        cmp #'A'
.9b6c		90 07		bcc $9b75	        bcc _digit
.9b6e		29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b70		38		sec		        sec
.9b71		e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b73		80 03		bra $9b78	        bra _done
.9b75						_digit:
.9b75		38		sec		        sec
.9b76		e9 30		sbc #$30	        sbc #'0'
.9b78						_done:
.9b78		60		rts		        rts
.9b79						xt_search_wordlist:
.9b79		20 51 d9	jsr $d951	                jsr underflow_3
.9b7c		a5 1e		lda $1e		                lda up
.9b7e		18		clc		                clc
.9b7f		69 06		adc #$06	                adc #wordlists_offset
.9b81		85 26		sta $26		                sta tmp2
.9b83		a5 1f		lda $1f		                lda up+1
.9b85		69 00		adc #$00	                adc #0          ; Adding carry
.9b87		85 27		sta $27		                sta tmp2+1
.9b89		b5 00		lda $00,x	                lda 0,x
.9b8b		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9b8c		65 26		adc $26		                adc tmp2
.9b8e		85 26		sta $26		                sta tmp2
.9b90		90 02		bcc $9b94	                bcc +
.9b92		e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9b94						+
.9b94		e8		inx		                inx
.9b95		e8		inx		                inx
.9b96		b5 00		lda $00,x	                lda 0,x
.9b98		15 01		ora $01,x	                ora 1,x
.9b9a		d0 03		bne $9b9f	                bne _check_wordlist
.9b9c		4c 57 9c	jmp $9c57	                jmp _done
.9b9f						_check_wordlist:
.9b9f		a5 26		lda $26		                lda tmp2
.9ba1		05 27		ora $27		                ora tmp2+1
.9ba3		d0 03		bne $9ba8	                bne _have_string
.9ba5		4c 57 9c	jmp $9c57	                jmp _done
.9ba8						_have_string:
.9ba8		b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9baa		85 24		sta $24		                sta tmp1
.9bac		e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9bae		d0 02		bne $9bb2	                bne +
.9bb0		e6 27		inc $27		                inc tmp2+1
.9bb2						+
.9bb2		b2 26		lda ($26)	                lda (tmp2)
.9bb4		85 25		sta $25		                sta tmp1+1
.9bb6		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9bb8		85 26		sta $26		                sta tmp2
.9bba		b5 03		lda $03,x	                lda 3,x
.9bbc		85 27		sta $27		                sta tmp2+1
.9bbe						_loop:
.9bbe		b2 24		lda ($24)	                lda (tmp1)
.9bc0		d5 00		cmp $00,x	                cmp 0,x
.9bc2		d0 7b		bne $9c3f	                bne _next_entry
.9bc4						_compare_string:
.9bc4		b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bc6		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bc8		b0 07		bcs $9bd1	                bcs _compare_first
.9bca		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bcc		90 03		bcc $9bd1	                bcc _compare_first
.9bce		18		clc		                clc
.9bcf		69 20		adc #$20	                adc #$20
.9bd1						_compare_first:
.9bd1		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9bd3		d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9bd5		d0 68		bne $9c3f	                bne _next_entry
.9bd7		b5 00		lda $00,x	                lda 0,x
.9bd9		3a		dec a		                dea
.9bda		f0 2c		beq $9c08	                beq _success
.9bdc		a5 24		lda $24		                lda tmp1
.9bde		48		pha		                pha             ; Preserve tmp1 on the return stack.
.9bdf		18		clc		                clc
.9be0		69 08		adc #$08	                adc #8
.9be2		85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9be4		a5 25		lda $25		                lda tmp1+1
.9be6		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9be7		69 00		adc #$00	                adc #0          ; we only need the carry
.9be9		85 25		sta $25		                sta tmp1+1
.9beb		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9bed		88		dey		                dey
.9bee						_string_loop:
.9bee		b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9bf0		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9bf2		b0 07		bcs $9bfb	                bcs _check_char
.9bf4		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bf6		90 03		bcc $9bfb	                bcc _check_char
.9bf8		18		clc		                clc
.9bf9		69 20		adc #$20	                adc #$20
.9bfb						_check_char:
.9bfb		d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9bfd		d0 3a		bne $9c39	                bne _next_entry_tmp1
.9bff		88		dey		                dey
.9c00		d0 ec		bne $9bee	                bne _string_loop
.9c02						_success_tmp1:
.9c02		68		pla		                pla             ; Restore tmp1 from the return stack.
.9c03		85 25		sta $25		                sta tmp1+1
.9c05		68		pla		                pla
.9c06		85 24		sta $24		                sta tmp1
.9c08						_success:
.9c08		e8		inx		                inx
.9c09		e8		inx		                inx
.9c0a		a5 24		lda $24		                lda tmp1
.9c0c		95 00		sta $00,x	                sta 0,x
.9c0e		a5 25		lda $25		                lda tmp1+1
.9c10		95 01		sta $01,x	                sta 1,x
.9c12		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( nt nt )
.9c15		20 ba 95	jsr $95ba	                jsr xt_name_to_int      ; ( nt xt )
.9c18		20 58 a1	jsr $a158	                jsr xt_swap             ; ( xt nt )
.9c1b		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c1d		f6 00		inc $00,x	                inc 0,x
.9c1f		d0 02		bne $9c23	                bne +
.9c21		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c23						+
.9c23		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c25		29 04		and #$04	                and #IM
.9c27		d0 08		bne $9c31	                bne _immediate          ; bit set, we're immediate
.9c29		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c2b		95 00		sta $00,x	                sta 0,x
.9c2d		95 01		sta $01,x	                sta 1,x
.9c2f		80 28		bra $9c59	                bra _done_nodrop
.9c31						_immediate:
.9c31		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c33		95 00		sta $00,x	                sta 0,x
.9c35		74 01		stz $01,x	                stz 1,x
.9c37		80 20		bra $9c59	                bra _done_nodrop
.9c39						_next_entry_tmp1:
.9c39		68		pla		                pla             ; Restore tmp1 from the return stack.
.9c3a		85 25		sta $25		                sta tmp1+1
.9c3c		68		pla		                pla
.9c3d		85 24		sta $24		                sta tmp1
.9c3f						_next_entry:
.9c3f		a0 02		ldy #$02	                ldy #2
.9c41		b1 24		lda ($24),y	                lda (tmp1),y
.9c43		48		pha		                pha
.9c44		c8		iny		                iny
.9c45		b1 24		lda ($24),y	                lda (tmp1),y
.9c47		85 25		sta $25		                sta tmp1+1
.9c49		68		pla		                pla
.9c4a		85 24		sta $24		                sta tmp1
.9c4c		05 25		ora $25		                ora tmp1+1
.9c4e		f0 03		beq $9c53	                beq _fail_done
.9c50		4c be 9b	jmp $9bbe	                jmp _loop
.9c53						_fail_done:
.9c53		74 02		stz $02,x	                stz 2,x         ; failure flag
.9c55		74 03		stz $03,x	                stz 3,x
.9c57						_done:
.9c57		e8		inx		                inx
.9c58		e8		inx		                inx
.9c59						_done_nodrop:
.9c59						z_search_wordlist:
.9c59		60		rts		                rts
.9c5a						xt_see:
.9c5a		20 b8 98	jsr $98b8	                jsr xt_parse_name       ; ( addr u )
.9c5d		20 9e 8f	jsr $8f9e	                jsr xt_find_name        ; ( nt | 0 )
.9c60		b5 00		lda $00,x	                lda 0,x
.9c62		15 01		ora $01,x	                ora 1,x
.9c64		d0 05		bne $9c6b	                bne +
.9c66		a9 05		lda #$05	                lda #err_noname
.9c68		4c 5d d9	jmp $d95d	                jmp error
.9c6b						+
.9c6b		20 3a 89	jsr $893a	                jsr xt_cr
.9c6e		a5 18		lda $18		                lda base
.9c70		48		pha		                pha
.9c71		20 40 91	jsr $9140	                jsr xt_hex
.9c74		a9 09		lda #$09	                lda #str_see_nt
.9c76		20 83 d9	jsr $d983	                jsr print_string_no_lf
.9c79		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( nt nt )
.9c7c		20 d8 a4	jsr $a4d8	                jsr xt_u_dot
.9c7f		20 c8 a0	jsr $a0c8	                jsr xt_space            ; ( nt )
.9c82		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( nt nt )
.9c85		20 ba 95	jsr $95ba	                jsr xt_name_to_int      ; ( nt xt )
.9c88		a9 0a		lda #$0a	                lda #str_see_xt
.9c8a		20 83 d9	jsr $d983	                jsr print_string_no_lf
.9c8d		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( nt xt xt )
.9c90		20 d8 a4	jsr $a4d8	                jsr xt_u_dot
.9c93		20 3a 89	jsr $893a	                jsr xt_cr               ; ( nt xt )
.9c96		a9 08		lda #$08	                lda #str_see_flags
.9c98		20 83 d9	jsr $d983	                jsr print_string_no_lf
.9c9b		20 6c 98	jsr $986c	                jsr xt_over             ; ( nt xt nt )
.9c9e		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9ca1		20 43 8f	jsr $8f43	                jsr xt_fetch            ; ( nt xt flags )
.9ca4		b5 00		lda $00,x	                lda 0,x
.9ca6		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9ca8						_flag_loop:
.9ca8		48		pha		                pha
.9ca9		29 01		and #$01	                and #%00000001
.9cab		18		clc		                clc
.9cac		69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cae		20 b9 8d	jsr $8db9	                jsr emit_a
.9cb1		20 c8 a0	jsr $a0c8	                jsr xt_space
.9cb4		68		pla		                pla
.9cb5		6a		ror a		                ror                     ; Next flag
.9cb6		88		dey		                dey
.9cb7		d0 ef		bne $9ca8	                bne _flag_loop
.9cb9		20 3a 89	jsr $893a	                jsr xt_cr
.9cbc		e8		inx		                inx
.9cbd		e8		inx		                inx                     ; ( nt xt )
.9cbe		a9 0b		lda #$0b	                lda #str_see_size
.9cc0		20 83 d9	jsr $d983	                jsr print_string_no_lf
.9cc3		20 58 a1	jsr $a158	                jsr xt_swap             ; ( xt nt )
.9cc6		20 1f a7	jsr $a71f	                jsr xt_wordsize         ; ( xt u )
.9cc9		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9ccc		20 7c 8a	jsr $8a7c	                jsr xt_decimal
.9ccf		20 d8 a4	jsr $a4d8	                jsr xt_u_dot            ; ( xt u )
.9cd2		20 40 91	jsr $9140	                jsr xt_hex
.9cd5		20 3a 89	jsr $893a	                jsr xt_cr
.9cd8		20 62 a3	jsr $a362	                jsr xt_two_dup          ; ( xt u xt u )
.9cdb		20 f7 8c	jsr $8cf7	                jsr xt_dump
.9cde		20 3a 89	jsr $893a	                jsr xt_cr
.9ce1		20 11 8b	jsr $8b11	                jsr xt_disasm
.9ce4		68		pla		                pla
.9ce5		85 18		sta $18		                sta base
.9ce7		60		rts		z_see:          rts
.9ce8						xt_set_current:
.9ce8		20 47 d9	jsr $d947	                jsr underflow_1
.9ceb		a0 04		ldy #$04	                ldy #current_offset
.9ced		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9cef		91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9cf1		e8		inx		                inx
.9cf2		e8		inx		                inx
.9cf3		60		rts		z_set_current:  rts
.9cf4						xt_set_order:
.9cf4		a9 ff		lda #$ff	                lda #$FF
.9cf6		d5 01		cmp $01,x	                cmp 1,x
.9cf8		d0 12		bne $9d0c	                bne _start
.9cfa		d5 00		cmp $00,x	                cmp 0,x
.9cfc		d0 0e		bne $9d0c	                bne _start
.9cfe		ca		dex		                dex             ; Make room for the count.
.9cff		ca		dex		                dex
.9d00		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d02		a9 03		lda #$03	                lda #3
.9d04		95 02		sta $02,x	                sta 2,x
.9d06		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d08		a9 01		lda #$01	                lda #1
.9d0a		95 00		sta $00,x	                sta 0,x
.9d0c						_start:
.9d0c		a0 1e		ldy #$1e	                ldy #num_order_offset
.9d0e		b5 00		lda $00,x	                lda 0,x
.9d10		91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d12		85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d14		e8		inx		                inx             ; Drop the count off the data stack.
.9d15		e8		inx		                inx
.9d16		a5 24		lda $24		                lda tmp1
.9d18		f0 0d		beq $9d27	                beq _done       ; If zero, there are no wordlists.
.9d1a		a0 1f		ldy #$1f	                ldy #search_order_offset
.9d1c						_loop:
.9d1c		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d1e		91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d20		c8		iny		                iny
.9d21		e8		inx		                inx
.9d22		e8		inx		                inx
.9d23		c6 24		dec $24		                dec tmp1
.9d25		d0 f5		bne $9d1c	                bne _loop
.9d27						_done:
.9d27		60		rts		z_set_order:    rts
.9d28						xt_s_quote:
.9d28		64 26		stz $26		                stz tmp2
.9d2a		64 27		stz $27		                stz tmp2+1
.9d2c						s_quote_start:
.9d2c		ca		dex		                dex
.9d2d		ca		dex		                dex
.9d2e		ca		dex		                dex
.9d2f		ca		dex		                dex
.9d30		a9 4c		lda #$4c	                lda #$4C
.9d32		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9d35		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9d38		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9d3b		a5 00		lda $00		                lda cp
.9d3d		95 02		sta $02,x	                sta 2,x
.9d3f		a5 01		lda $01		                lda cp+1
.9d41		95 03		sta $03,x	                sta 3,x
.9d43						_savechars_loop:
.9d43		a5 0d		lda $0d		                lda toin+1              ; MSB
.9d45		c5 0b		cmp $0b		                cmp ciblen+1
.9d47		90 2a		bcc $9d73	                bcc _input_fine         ; unsigned comparison
.9d49		a5 0c		lda $0c		                lda toin                ; LSB
.9d4b		c5 0a		cmp $0a		                cmp ciblen
.9d4d		90 24		bcc $9d73	                bcc _input_fine
.9d4f		a5 26		lda $26		                lda tmp2
.9d51		48		pha		                pha
.9d52		a5 27		lda $27		                lda tmp2+1
.9d54		48		pha		                pha
.9d55		a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d57		48		pha		                pha
.9d58		20 d1 9a	jsr $9ad1	                jsr xt_refill           ; ( -- f )
.9d5b		68		pla		                pla
.9d5c		85 28		sta $28		                sta tmp3
.9d5e		68		pla		                pla
.9d5f		85 27		sta $27		                sta tmp2+1
.9d61		68		pla		                pla
.9d62		85 26		sta $26		                sta tmp2
.9d64		b5 00		lda $00,x	                lda 0,x
.9d66		15 01		ora $01,x	                ora 1,x
.9d68		d0 05		bne $9d6f	                bne _refill_ok
.9d6a		a9 06		lda #$06	                lda #err_refill
.9d6c		4c 5d d9	jmp $d95d	                jmp error
.9d6f						_refill_ok:
.9d6f		e8		inx		                inx
.9d70		e8		inx		                inx
.9d71		80 d0		bra $9d43	                bra _savechars_loop
.9d73						_input_fine:
.9d73		a5 08		lda $08		                lda cib
.9d75		18		clc		                clc
.9d76		65 0c		adc $0c		                adc toin        ; LSB
.9d78		85 24		sta $24		                sta tmp1
.9d7a		a5 09		lda $09		                lda cib+1
.9d7c		65 0d		adc $0d		                adc toin+1      ; MSB
.9d7e		85 25		sta $25		                sta tmp1+1
.9d80		b2 24		lda ($24)	                lda (tmp1)
.9d82		24 26		bit $26		                bit tmp2
.9d84		30 03		bmi $9d89	                bmi _handle_escapes    ; Only checking bit 7
.9d86		4c 12 9e	jmp $9e12	                jmp _regular_char
.9d89						_handle_escapes:
.9d89		24 27		bit $27		                bit tmp2+1
.9d8b		30 03		bmi $9d90	                bmi _escaped
.9d8d		4c 08 9e	jmp $9e08	                jmp _not_escaped
.9d90						_escaped:
.9d90		70 3c		bvs $9dce	                bvs _check_esc_chars
.9d92		a9 01		lda #$01	                lda #1
.9d94		24 27		bit $27		                bit tmp2+1
.9d96		d0 10		bne $9da8	                bne _esc_x_second_digit
.9d98		e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9d9a		b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9d9c		20 6a 9b	jsr $9b6a	                jsr convert_hex_value
.9d9f		0a		asl a		                asl
.9da0		0a		asl a		                asl
.9da1		0a		asl a		                asl
.9da2		0a		asl a		                asl
.9da3		85 28		sta $28		                sta tmp3    ; Save it for later.
.9da5		4c 19 9e	jmp $9e19	                jmp _next_character
.9da8						_esc_x_second_digit:
.9da8		64 27		stz $27		                stz tmp2+1
.9daa		b2 24		lda ($24)	                lda (tmp1)
.9dac		20 6a 9b	jsr $9b6a	                jsr convert_hex_value
.9daf		05 28		ora $28		                ora tmp3
.9db1		4c 16 9e	jmp $9e16	                jmp _save_character
.9db4						_esc_tr_table:
>9db4		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9db5		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9db6		00 00				    .byte   0,0             ; c, d no escape
>9db8		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9db9		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9dba		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9dbf		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9dc0		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9dc1		0a				    .byte   10              ; n behaves like l --> lf
>9dc2		00 00				    .byte   0,0             ; o,p
>9dc4		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9dc5		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9dc6		00				    .byte   0               ; s
>9dc7		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9dc8		00				    .byte   0               ; u
>9dc9		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9dca		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9dcd		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9dce						_check_esc_chars:
.9dce		64 27		stz $27		                stz tmp2+1
.9dd0		c9 61		cmp #$61	                cmp #'a'
.9dd2		30 1a		bmi $9dee	                bmi _check_esc_quote
.9dd4		c9 7b		cmp #$7b	                cmp #'z'+1
.9dd6		10 16		bpl $9dee	                bpl _check_esc_quote
.9dd8		a8		tay		                tay
.9dd9		b9 53 9d	lda $9d53,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9ddc		d0 03		bne $9de1	                bne _esc_replace
.9dde		98		tya		                tya                     ; revert if no translation
.9ddf		80 0d		bra $9dee	                bra _check_esc_quote
.9de1		10 33		bpl $9e16	_esc_replace:   bpl _save_character     ; simple replacement
.9de3		29 7f		and #$7f	                and #$7f                ; clear hi bit
.9de5		f0 2f		beq $9e16	                beq _save_character     ; NUL we can just output
.9de7		20 ed d7	jsr $d7ed	                jsr cmpl_a              ; else output first char (CR)
.9dea		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9dec		80 28		bra $9e16	                bra _save_character
.9dee						_check_esc_quote:
.9dee		c9 22		cmp #$22	                cmp #$22
.9df0		d0 04		bne $9df6	                bne _check_esc_x
.9df2		a9 22		lda #$22	                lda #34
.9df4		80 20		bra $9e16	                bra _save_character
.9df6						_check_esc_x:
.9df6		c9 78		cmp #$78	                cmp #'x'
.9df8		d0 06		bne $9e00	                bne _check_esc_backslash
.9dfa		a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9dfc		85 27		sta $27		                sta tmp2+1
.9dfe		80 19		bra $9e19	                bra _next_character
.9e00						_check_esc_backslash:
.9e00		c9 5c		cmp #$5c	                cmp #$5C
.9e02		d0 04		bne $9e08	                bne _not_escaped
.9e04		a9 5c		lda #$5c	                lda #92
.9e06		80 0e		bra $9e16	                bra _save_character
.9e08						_not_escaped:
.9e08		c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e0a		d0 06		bne $9e12	                bne _regular_char
.9e0c		a9 ff		lda #$ff	                lda #$FF
.9e0e		85 27		sta $27		                sta tmp2+1
.9e10		80 07		bra $9e19	                bra _next_character
.9e12						_regular_char:
.9e12		c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e14		f0 0c		beq $9e22	                beq _found_string_end
.9e16						_save_character:
.9e16		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9e19						_next_character:
.9e19		e6 0c		inc $0c		                inc toin
.9e1b		d0 02		bne $9e1f	                bne _savechars_loop_longjump
.9e1d		e6 0d		inc $0d		                inc toin+1
.9e1f						_savechars_loop_longjump:
.9e1f		4c 43 9d	jmp $9d43	                jmp _savechars_loop
.9e22						_found_string_end:
.9e22		e6 0c		inc $0c		                inc toin
.9e24		d0 02		bne $9e28	                bne +
.9e26		e6 0d		inc $0d		                inc toin+1
.9e28						+
.9e28		a5 00		lda $00		                lda cp
.9e2a		38		sec		                sec
.9e2b		f5 02		sbc $02,x	                sbc 2,x
.9e2d		95 00		sta $00,x	                sta 0,x         ; LSB
.9e2f		a5 01		lda $01		                lda cp+1
.9e31		f5 03		sbc $03,x	                sbc 3,x
.9e33		95 01		sta $01,x	                sta 1,x         ; MSB
.9e35		b5 02		lda $02,x	                lda 2,x
.9e37		38		sec		                sec
.9e38		e9 02		sbc #$02	                sbc #2
.9e3a		85 24		sta $24		                sta tmp1
.9e3c		b5 03		lda $03,x	                lda 3,x
.9e3e		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e40		85 25		sta $25		                sta tmp1+1
.9e42		a5 00		lda $00		                lda cp
.9e44		92 24		sta ($24)	                sta (tmp1)
.9e46		a0 01		ldy #$01	                ldy #1
.9e48		a5 01		lda $01		                lda cp+1
.9e4a		91 24		sta ($24),y	                sta (tmp1),y
.9e4c		a5 16		lda $16		                lda state
.9e4e		05 17		ora $17		                ora state+1             ; paranoid
.9e50		f0 03		beq $9e55	                beq _done
.9e52		20 39 a0	jsr $a039	                jsr sliteral_const_str         ; ( addr u -- )
.9e55						_done:
.9e55		60		rts		z_s_quote:      rts
.9e56						xt_s_to_d:
.9e56		20 47 d9	jsr $d947	                jsr underflow_1
.9e59		ca		dex		                dex
.9e5a		ca		dex		                dex
.9e5b		74 00		stz $00,x	                stz 0,x
.9e5d		74 01		stz $01,x	                stz 1,x
.9e5f		b5 03		lda $03,x	                lda 3,x
.9e61		10 04		bpl $9e67	                bpl _done
.9e63		d6 00		dec $00,x	                dec 0,x
.9e65		d6 01		dec $01,x	                dec 1,x
.9e67						_done:
.9e67		60		rts		z_s_to_d:       rts
.9e68						xt_save_buffers:
.9e68		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e6a		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9e6c		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9e6e		d0 12		bne $9e82	                bne _done       ; Either not used or not dirty = done!
.9e70		20 79 83	jsr $8379	                jsr xt_blkbuffer
.9e73		20 6b 85	jsr $856b	                jsr xt_buffblocknum
.9e76		20 43 8f	jsr $8f43	                jsr xt_fetch
.9e79		20 26 85	jsr $8526	                jsr xt_block_write
.9e7c		a9 01		lda #$01	                lda #1
.9e7e		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e80		91 1e		sta ($1e),y	                sta (up),y
.9e82						_done:
.9e82		60		rts		z_save_buffers: rts
.9e83						xt_scr:
.9e83		ca		dex		                dex
.9e84		ca		dex		                dex
.9e85		18		clc		                clc
.9e86		a5 1e		lda $1e		                lda up
.9e88		69 02		adc #$02	                adc #scr_offset ; Add offset
.9e8a		95 00		sta $00,x	                sta 0,x
.9e8c		a5 1f		lda $1f		                lda up+1
.9e8e		69 00		adc #$00	                adc #0          ; Adding carry
.9e90		95 01		sta $01,x	                sta 1,x
.9e92		60		rts		z_scr:          rts
.9e93						xt_search:
.9e93		20 56 d9	jsr $d956	                jsr underflow_4
.9e96		b5 00		lda $00,x	                lda 0,x
.9e98		15 01		ora $01,x	                ora 1,x
.9e9a		d0 0b		bne $9ea7	                bne _start_search
.9e9c		e8		inx		                inx             ; Remove u2
.9e9d		e8		inx		                inx
.9e9e		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ea0		95 00		sta $00,x	                sta 0,x
.9ea2		95 01		sta $01,x	                sta 1,x
.9ea4		4c 31 9f	jmp $9f31	                jmp z_search
.9ea7						_start_search:
.9ea7		20 52 a7	jsr $a752	                jsr xt_zero
.9eaa						_search_loop:
.9eaa		18		clc		                clc
.9eab		b5 00		lda $00,x	                lda 0,x
.9ead		75 02		adc $02,x	                adc 2,x
.9eaf		85 24		sta $24		                sta tmp1
.9eb1		b5 01		lda $01,x	                lda 1,x
.9eb3		75 03		adc $03,x	                adc 3,x
.9eb5		d5 07		cmp $07,x	                cmp 7,x
.9eb7		90 12		bcc $9ecb	                bcc _init_comparison ; Obviously less
.9eb9		d0 06		bne $9ec1	                bne _not_found
.9ebb		b5 06		lda $06,x	                lda 6,x
.9ebd		c5 24		cmp $24		                cmp tmp1
.9ebf		b0 0a		bcs $9ecb	                bcs _init_comparison
.9ec1						_not_found:
.9ec1		e8		inx		                inx             ; Remove offset
.9ec2		e8		inx		                inx
.9ec3		e8		inx		                inx             ; Remove u2
.9ec4		e8		inx		                inx
.9ec5		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9ec7		74 01		stz $01,x	                stz 1,x
.9ec9		80 66		bra $9f31	                bra z_search
.9ecb						_init_comparison:
.9ecb		18		clc		                clc
.9ecc		b5 08		lda $08,x	                lda 8,x
.9ece		75 00		adc $00,x	                adc 0,x
.9ed0		85 24		sta $24		                sta tmp1
.9ed2		b5 09		lda $09,x	                lda 9,x
.9ed4		75 01		adc $01,x	                adc 1,x
.9ed6		85 25		sta $25		                sta tmp1+1
.9ed8		b5 04		lda $04,x	                lda 4,x
.9eda		85 26		sta $26		                sta tmp2
.9edc		b5 05		lda $05,x	                lda 5,x
.9ede		85 27		sta $27		                sta tmp2+1
.9ee0		b5 02		lda $02,x	                lda 2,x
.9ee2		85 28		sta $28		                sta tmp3
.9ee4		b5 03		lda $03,x	                lda 3,x
.9ee6		85 29		sta $29		                sta tmp3+1
.9ee8						_comparison_loop:
.9ee8		b2 24		lda ($24)	                lda (tmp1)
.9eea		d2 26		cmp ($26)	                cmp (tmp2)
.9eec		f0 05		beq $9ef3	                beq _letters_match
.9eee		20 f6 97	jsr $97f6	                jsr xt_one_plus
.9ef1		80 b7		bra $9eaa	                bra _search_loop
.9ef3						_letters_match:
.9ef3		e6 24		inc $24		                inc tmp1
.9ef5		d0 02		bne $9ef9	                bne +
.9ef7		e6 25		inc $25		                inc tmp1+1
.9ef9						+
.9ef9		e6 26		inc $26		                inc tmp2
.9efb		d0 02		bne $9eff	                bne +
.9efd		e6 27		inc $27		                inc tmp2+1
.9eff						+
.9eff		a5 28		lda $28		                lda tmp3
.9f01		d0 02		bne $9f05	                bne +
.9f03		c6 29		dec $29		                dec tmp3+1
.9f05						+
.9f05		c6 28		dec $28		                dec tmp3
.9f07		a5 28		lda $28		                lda tmp3
.9f09		05 29		ora $29		                ora tmp3+1
.9f0b		d0 db		bne $9ee8	                bne _comparison_loop ; Check the next letter
.9f0d		18		clc		                clc
.9f0e		b5 00		lda $00,x	                lda 0,x
.9f10		75 08		adc $08,x	                adc 8,x
.9f12		95 08		sta $08,x	                sta 8,x
.9f14		b5 01		lda $01,x	                lda 1,x
.9f16		75 09		adc $09,x	                adc 9,x
.9f18		95 09		sta $09,x	                sta 9,x
.9f1a		38		sec		                sec
.9f1b		b5 06		lda $06,x	                lda 6,x
.9f1d		f5 00		sbc $00,x	                sbc 0,x
.9f1f		95 06		sta $06,x	                sta 6,x
.9f21		b5 07		lda $07,x	                lda 7,x
.9f23		f5 01		sbc $01,x	                sbc 1,x
.9f25		95 07		sta $07,x	                sta 7,x
.9f27		e8		inx		                inx             ; drop offset
.9f28		e8		inx		                inx
.9f29		e8		inx		                inx             ; drop u2
.9f2a		e8		inx		                inx
.9f2b		a9 ff		lda #$ff	                lda #$FF
.9f2d		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f2f		95 01		sta $01,x	                sta 1,x
.9f31		60		rts		z_search:       rts
.9f32						xt_semicolon:
.9f32		24 20		bit $20		                bit status
.9f34		70 11		bvs $9f47	                bvs _colonword
.9f36		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f38		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9f3b		ca		dex		                dex
.9f3c		ca		dex		                dex
.9f3d		a5 04		lda $04		                lda workword
.9f3f		95 00		sta $00,x	                sta 0,x
.9f41		a5 05		lda $05		                lda workword+1
.9f43		95 01		sta $01,x	                sta 1,x
.9f45		80 45		bra $9f8c	                bra _semicolon_done
.9f47						_colonword:
.9f47		a0 06		ldy #$06	                ldy #6
.9f49		a5 00		lda $00		                lda cp
.9f4b		91 04		sta ($04),y	                sta (workword),y
.9f4d		c8		iny		                iny
.9f4e		a5 01		lda $01		                lda cp+1
.9f50		91 04		sta ($04),y	                sta (workword),y
.9f52		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f54		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9f57		24 20		bit $20		                bit status
.9f59		10 26		bpl $9f81	                bpl _new_word   ; Bit 7 is clear = new word
.9f5b		ca		dex		                dex
.9f5c		ca		dex		                dex
.9f5d		ca		dex		                dex
.9f5e		ca		dex		                dex
.9f5f		b2 04		lda ($04)	                lda (workword)
.9f61		95 00		sta $00,x	                sta 0,x
.9f63		74 01		stz $01,x	                stz 1,x
.9f65		a5 04		lda $04		                lda workword
.9f67		18		clc		                clc
.9f68		69 08		adc #$08	                adc #8
.9f6a		95 02		sta $02,x	                sta 2,x
.9f6c		a5 05		lda $05		                lda workword+1
.9f6e		69 00		adc #$00	                adc #0                  ; only want carry
.9f70		95 03		sta $03,x	                sta 3,x
.9f72		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9f74		20 83 d9	jsr $d983	                jsr print_string_no_lf
.9f77		20 ad a4	jsr $a4ad	                jsr xt_type
.9f7a		20 c8 a0	jsr $a0c8	                jsr xt_space
.9f7d		a9 80		lda #$80	                lda #%10000000
.9f7f		14 20		trb $20		                trb status
.9f81						_new_word:
.9f81		a5 04		lda $04		                lda workword
.9f83		85 02		sta $02		                sta dp
.9f85		a5 05		lda $05		                lda workword+1
.9f87		85 03		sta $03		                sta dp+1
.9f89		20 8f d8	jsr $d88f	                jsr dp_to_current       ; Save the updated DP to the
.9f8c						_semicolon_done:
.9f8c		64 16		stz $16		                stz state
.9f8e		64 17		stz $17		                stz state+1
.9f90		60		rts		z_semicolon:    rts
.9f91						xt_sign:
.9f91		20 47 d9	jsr $d947	                jsr underflow_1
.9f94		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9f96		30 04		bmi $9f9c	                bmi _minus
.9f98		e8		inx		                inx
.9f99		e8		inx		                inx
.9f9a		80 09		bra $9fa5	                bra _done
.9f9c						_minus:
.9f9c		a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9f9e		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9fa0		74 01		stz $01,x	                stz 1,x         ; paranoid
.9fa2		20 9a 91	jsr $919a	                jsr xt_hold
.9fa5						_done:
.9fa5		60		rts		z_sign:         rts
.9fa6						xt_slash:
.9fa6		a9 00		lda #$00	                lda #0
.9fa8		48		pha		                pha
.9fa9		80 03		bra $9fae	                bra slashmod_common
.9fab						xt_slash_mod:
.9fab		a9 ff		lda #$ff	                lda #$FF
.9fad		48		pha		                pha             ; falls through to _common
.9fae						slashmod_common:
.9fae		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >R
.9fb1		20 56 9e	jsr $9e56	                jsr xt_s_to_d           ; S>D
.9fb4		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; R>
.9fb7		20 7f a0	jsr $a07f	                jsr xt_sm_slash_rem     ; SM/REM
.9fba		68		pla		                pla
.9fbb		d0 05		bne $9fc2	                bne _done
.9fbd		20 58 a1	jsr $a158	                jsr xt_swap
.9fc0		e8		inx		                inx             ; DROP
.9fc1		e8		inx		                inx
.9fc2						_done:
.9fc2						z_slash_mod:
.9fc2		60		rts		z_slash:        rts
.9fc3						xt_slash_string:
.9fc3		20 51 d9	jsr $d951	                jsr underflow_3
.9fc6		18		clc		                clc             ; 3OS+TOS
.9fc7		b5 00		lda $00,x	                lda 0,x
.9fc9		75 04		adc $04,x	                adc 4,x
.9fcb		95 04		sta $04,x	                sta 4,x
.9fcd		b5 01		lda $01,x	                lda 1,x
.9fcf		75 05		adc $05,x	                adc 5,x
.9fd1		95 05		sta $05,x	                sta 5,x
.9fd3		38		sec		                sec             ; NOS-TOS
.9fd4		b5 02		lda $02,x	                lda 2,x
.9fd6		f5 00		sbc $00,x	                sbc 0,x
.9fd8		95 02		sta $02,x	                sta 2,x
.9fda		b5 03		lda $03,x	                lda 3,x
.9fdc		f5 01		sbc $01,x	                sbc 1,x
.9fde		95 03		sta $03,x	                sta 3,x
.9fe0		e8		inx		                inx
.9fe1		e8		inx		                inx
.9fe2		60		rts		z_slash_string: rts
.9fe3						xt_sliteral:
.9fe3		20 4c d9	jsr $d94c	                jsr underflow_2
.9fe6		a9 4c		lda #$4c	                lda #$4C
.9fe8		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9feb		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9fee		20 ed d7	jsr $d7ed	                jsr cmpl_a
.9ff1		8a		txa		                txa
.9ff2		38		sec		                sec
.9ff3		e9 06		sbc #$06	                sbc #6
.9ff5		aa		tax		                tax
.9ff6		b5 08		lda $08,x	                lda 8,x
.9ff8		95 04		sta $04,x	                sta 4,x
.9ffa		b5 09		lda $09,x	                lda 9,x
.9ffc		95 05		sta $05,x	                sta 5,x
.9ffe		b5 06		lda $06,x	                lda 6,x
.a000		95 00		sta $00,x	                sta 0,x
.a002		b5 07		lda $07,x	                lda 7,x
.a004		95 01		sta $01,x	                sta 1,x
.a006		a5 00		lda $00		                lda cp
.a008		95 08		sta $08,x	                sta 8,x
.a00a		95 02		sta $02,x	                sta 2,x
.a00c		a5 01		lda $01		                lda cp+1
.a00e		95 09		sta $09,x	                sta 9,x
.a010		95 03		sta $03,x	                sta 3,x
.a012		20 9b 95	jsr $959b	                jsr xt_move
.a015		18		clc		                clc
.a016		a5 00		lda $00		                lda cp
.a018		75 00		adc $00,x	                adc 0,x
.a01a		85 00		sta $00		                sta cp
.a01c		a5 01		lda $01		                lda cp+1
.a01e		75 01		adc $01,x	                adc 1,x
.a020		85 01		sta $01		                sta cp+1
.a022		b5 02		lda $02,x	                lda 2,x
.a024		38		sec		                sec
.a025		e9 02		sbc #$02	                sbc #2
.a027		85 24		sta $24		                sta tmp1
.a029		b5 03		lda $03,x	                lda 3,x
.a02b		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a02d		85 25		sta $25		                sta tmp1+1
.a02f		a5 00		lda $00		                lda cp
.a031		92 24		sta ($24)	                sta (tmp1)
.a033		a0 01		ldy #$01	                ldy #1
.a035		a5 01		lda $01		                lda cp+1
.a037		91 24		sta ($24),y	                sta (tmp1),y
.a039						sliteral_const_str:
.a039		a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a03b		a9 53		lda #$53	                lda #<sliteral_runtime
.a03d		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.a040		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a042		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a044		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.a047		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a049		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a04b		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.a04e		e8		inx		                inx
.a04f		e8		inx		                inx
.a050		e8		inx		                inx
.a051		e8		inx		                inx
.a052		60		rts		z_sliteral:     rts
.a053						sliteral_runtime:
.a053		ca		dex		                dex
.a054		ca		dex		                dex
.a055		ca		dex		                dex
.a056		ca		dex		                dex
.a057		68		pla		                pla
.a058		85 24		sta $24		                sta tmp1        ; LSB of address
.a05a		68		pla		                pla
.a05b		85 25		sta $25		                sta tmp1+1      ; MSB of address
.a05d		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a05f		b1 24		lda ($24),y	                lda (tmp1),y
.a061		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a063		c8		iny		                iny
.a064		b1 24		lda ($24),y	                lda (tmp1),y
.a066		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a068		c8		iny		                iny
.a069		b1 24		lda ($24),y	                lda (tmp1),y
.a06b		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a06d		c8		iny		                iny
.a06e		b1 24		lda ($24),y	                lda (tmp1),y
.a070		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a072		18		clc		                clc
.a073		a5 24		lda $24		                lda tmp1
.a075		69 04		adc #$04	                adc #4
.a077		a8		tay		                tay             ; LSB
.a078		a5 25		lda $25		                lda tmp1+1
.a07a		69 00		adc #$00	                adc #0          ; we only need carry
.a07c		48		pha		                pha             ; MSB
.a07d		5a		phy		                phy
.a07e		60		rts		                rts
.a07f						xt_sm_slash_rem:
.a07f		20 51 d9	jsr $d951	                jsr underflow_3 ; contains double number
.a082		b5 03		lda $03,x	                lda 3,x
.a084		48		pha		                pha
.a085		b5 01		lda $01,x	                lda 1,x
.a087		55 03		eor $03,x	                eor 3,x
.a089		48		pha		                pha
.a08a		20 dd 80	jsr $80dd	                jsr xt_abs
.a08d		e8		inx		                inx             ; pretend we pushed n1 to R
.a08e		e8		inx		                inx
.a08f		20 5d 8a	jsr $8a5d	                jsr xt_dabs
.a092		ca		dex		                dex
.a093		ca		dex		                dex
.a094		20 64 a5	jsr $a564	                jsr xt_um_slash_mod     ; UM/MOD
.a097		68		pla		                pla
.a098		10 03		bpl $a09d	                bpl +
.a09a		20 fc 95	jsr $95fc	                jsr xt_negate
.a09d						+
.a09d		68		pla		                pla
.a09e		10 07		bpl $a0a7	                bpl _done
.a0a0		e8		inx		                inx             ; pretend we pushed quotient to R
.a0a1		e8		inx		                inx
.a0a2		20 fc 95	jsr $95fc	                jsr xt_negate
.a0a5		ca		dex		                dex
.a0a6		ca		dex		                dex
.a0a7						_done:
.a0a7		60		rts		z_sm_slash_rem: rts
.a0a8						xt_source:
.a0a8		ca		dex		                dex
.a0a9		ca		dex		                dex
.a0aa		a5 08		lda $08		                lda cib
.a0ac		95 00		sta $00,x	                sta 0,x
.a0ae		a5 09		lda $09		                lda cib+1
.a0b0		95 01		sta $01,x	                sta 1,x
.a0b2		ca		dex		                dex
.a0b3		ca		dex		                dex
.a0b4		a5 0a		lda $0a		                lda ciblen
.a0b6		95 00		sta $00,x	                sta 0,x
.a0b8		a5 0b		lda $0b		                lda ciblen+1
.a0ba		95 01		sta $01,x	                sta 1,x
.a0bc		60		rts		z_source:       rts
.a0bd						xt_source_id:
.a0bd		ca		dex		                dex
.a0be		ca		dex		                dex
.a0bf		a5 06		lda $06		                lda insrc
.a0c1		95 00		sta $00,x	                sta 0,x
.a0c3		a5 07		lda $07		                lda insrc+1
.a0c5		95 01		sta $01,x	                sta 1,x
.a0c7		60		rts		z_source_id:    rts
.a0c8						xt_space:
.a0c8		a9 20		lda #$20	                lda #AscSP
.a0ca		20 b9 8d	jsr $8db9	                jsr emit_a
.a0cd		60		rts		z_space:        rts
.a0ce						xt_spaces:
.a0ce		20 47 d9	jsr $d947	                jsr underflow_1
.a0d1		20 52 a7	jsr $a752	                jsr xt_zero
.a0d4		20 f1 94	jsr $94f1	                jsr xt_max
.a0d7		b5 00		lda $00,x	                lda 0,x
.a0d9		15 01		ora $01,x	                ora 1,x
.a0db		f0 2a		beq $a107	                beq _done
.a0dd		b4 01		ldy $01,x	                ldy 1,x
.a0df		d0 0c		bne $a0ed	                bne _lots_of_spaces
.a0e1		b4 00		ldy $00,x	                ldy 0,x
.a0e3						_quick_loop:
.a0e3		a9 20		lda #$20	                lda #AscSP
.a0e5		20 b9 8d	jsr $8db9	                jsr emit_a
.a0e8		88		dey		                dey
.a0e9		f0 1c		beq $a107	                beq _done
.a0eb		80 f6		bra $a0e3	                bra _quick_loop
.a0ed						_lots_of_spaces:
.a0ed		b4 00		ldy $00,x	                ldy 0,x
.a0ef						_first_slow_loop:
.a0ef		f0 08		beq $a0f9	                beq _slow_outer_loop
.a0f1		a9 20		lda #$20	                lda #AscSP
.a0f3		20 b9 8d	jsr $8db9	                jsr emit_a
.a0f6		88		dey		                dey
.a0f7		80 f6		bra $a0ef	                bra _first_slow_loop
.a0f9						_slow_outer_loop:
.a0f9		a0 00		ldy #$00	                ldy #00
.a0fb						_slow_inner_loop:
.a0fb		a9 20		lda #$20	                lda #AscSP
.a0fd		20 b9 8d	jsr $8db9	                jsr emit_a
.a100		88		dey		                dey
.a101		d0 f8		bne $a0fb	                bne _slow_inner_loop
.a103		d6 01		dec $01,x	                dec 1,x
.a105		d0 f2		bne $a0f9	                bne _slow_outer_loop
.a107						_done:
.a107		e8		inx		                inx             ; drop
.a108		e8		inx		                inx
.a109		60		rts		z_spaces:       rts
.a10a						xt_star:
.a10a		20 4c d9	jsr $d94c	                jsr underflow_2
.a10d		20 a6 a5	jsr $a5a6	                jsr xt_um_star
.a110		e8		inx		                inx
.a111		e8		inx		                inx
.a112		60		rts		z_star:         rts
.a113						xt_star_slash:
.a113		20 1c a1	jsr $a11c	                jsr xt_star_slash_mod
.a116		20 58 a1	jsr $a158	                jsr xt_swap
.a119		e8		inx		                inx
.a11a		e8		inx		                inx
.a11b						z_star_slash:
.a11b		60		rts		                rts
.a11c						xt_star_slash_mod:
.a11c		20 51 d9	jsr $d951	                jsr underflow_3
.a11f		20 1a a3	jsr $a31a	                jsr xt_to_r
.a122		20 67 94	jsr $9467	                jsr xt_m_star
.a125		20 6b 9a	jsr $9a6b	                jsr xt_r_from
.a128		20 7f a0	jsr $a07f	                jsr xt_sm_slash_rem
.a12b						z_star_slash_mod:
.a12b		60		rts		                rts
.a12c						xt_state:
.a12c		ca		dex		                dex
.a12d		ca		dex		                dex
.a12e		a9 16		lda #$16	                lda #<state
.a130		95 00		sta $00,x	                sta 0,x
.a132		a9 00		lda #$00	                lda #>state
.a134		95 01		sta $01,x	                sta 1,x
.a136		60		rts		z_state:        rts
.a137						xt_store:
.a137		20 4c d9	jsr $d94c	                jsr underflow_2
.a13a		b5 02		lda $02,x	                lda 2,x         ; LSB
.a13c		81 00		sta ($00,x)	                sta (0,x)
.a13e		f6 00		inc $00,x	                inc 0,x
.a140		d0 02		bne $a144	                bne +
.a142		f6 01		inc $01,x	                inc 1,x
.a144						+
.a144		b5 03		lda $03,x	                lda 3,x         ; MSB
.a146		81 00		sta ($00,x)	                sta (0,x)
.a148		e8		inx		                inx             ; 2DROP
.a149		e8		inx		                inx
.a14a		e8		inx		                inx
.a14b		e8		inx		                inx
.a14c		60		rts		z_store:        rts
.a14d						xt_strip_underflow:
.a14d		ca		dex		                dex
.a14e		ca		dex		                dex
.a14f		a9 1c		lda #$1c	                lda #<uf_strip
.a151		95 00		sta $00,x	                sta 0,x
.a153		a9 00		lda #$00	                lda #>uf_strip
.a155		95 01		sta $01,x	                sta 1,x
.a157						z_strip_underflow:
.a157		60		rts		                rts
.a158						xt_swap:
.a158		20 4c d9	jsr $d94c	                jsr underflow_2
.a15b		b5 00		lda $00,x	                lda 0,x         ; LSB
.a15d		b4 02		ldy $02,x	                ldy 2,x
.a15f		95 02		sta $02,x	                sta 2,x
.a161		94 00		sty $00,x	                sty 0,x
.a163		b5 01		lda $01,x	                lda 1,x         ; MSB
.a165		b4 03		ldy $03,x	                ldy 3,x
.a167		95 03		sta $03,x	                sta 3,x
.a169		94 01		sty $01,x	                sty 1,x
.a16b		60		rts		z_swap:         rts
.a16c						xt_then:
.a16c		20 35 91	jsr $9135	                jsr xt_here
.a16f		20 58 a1	jsr $a158	                jsr xt_swap
.a172		20 37 a1	jsr $a137	                jsr xt_store
.a175		60		rts		z_then:         rts
.a176						xt_thru:
.a176		20 4c d9	jsr $d94c	                jsr underflow_2
.a179		b5 01		lda $01,x	                lda 1,x
.a17b		48		pha		                pha
.a17c		b5 00		lda $00,x	                lda 0,x
.a17e		48		pha		                pha
.a17f		e8		inx		                inx
.a180		e8		inx		                inx
.a181						_thru_loop:
.a181		b5 01		lda $01,x	                lda 1,x
.a183		48		pha		                pha
.a184		b5 00		lda $00,x	                lda 0,x
.a186		48		pha		                pha
.a187		20 8d 93	jsr $938d	                jsr xt_load
.a18a		68		pla		                pla
.a18b		85 24		sta $24		                sta tmp1
.a18d		68		pla		                pla
.a18e		85 25		sta $25		                sta tmp1+1
.a190		68		pla		                pla
.a191		85 26		sta $26		                sta tmp2
.a193		68		pla		                pla
.a194		85 27		sta $27		                sta tmp2+1
.a196		c5 25		cmp $25		                cmp tmp1+1
.a198		d0 08		bne $a1a2	                bne _next_screen
.a19a		a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a19c		c5 24		cmp $24		                cmp tmp1
.a19e		d0 02		bne $a1a2	                bne _next_screen
.a1a0		80 18		bra $a1ba	                bra _done       ; We just did the last screen.
.a1a2						_next_screen:
.a1a2		a5 27		lda $27		                lda tmp2+1
.a1a4		48		pha		                pha
.a1a5		a5 26		lda $26		                lda tmp2
.a1a7		48		pha		                pha
.a1a8		e6 24		inc $24		                inc tmp1
.a1aa		d0 02		bne $a1ae	                bne +
.a1ac		e6 25		inc $25		                inc tmp1+1
.a1ae						+
.a1ae		ca		dex		                dex
.a1af		ca		dex		                dex
.a1b0		a5 24		lda $24		                lda tmp1
.a1b2		95 00		sta $00,x	                sta 0,x
.a1b4		a5 25		lda $25		                lda tmp1+1
.a1b6		95 01		sta $01,x	                sta 1,x
.a1b8		80 c7		bra $a181	                bra _thru_loop
.a1ba						_done:
.a1ba		60		rts		z_thru:         rts
.a1bb						xt_tick:
.a1bb		20 b8 98	jsr $98b8	                jsr xt_parse_name       ; ( -- addr u )
.a1be		b5 00		lda $00,x	                lda 0,x
.a1c0		15 01		ora $01,x	                ora 1,x
.a1c2		d0 05		bne $a1c9	                bne +
.a1c4		a9 05		lda #$05	                lda #err_noname
.a1c6		4c 5d d9	jmp $d95d	                jmp error
.a1c9						+
.a1c9		20 9e 8f	jsr $8f9e	                jsr xt_find_name        ; ( addr u -- nt )
.a1cc		b5 00		lda $00,x	                lda 0,x
.a1ce		15 01		ora $01,x	                ora 1,x
.a1d0		d0 05		bne $a1d7	                bne +
.a1d2		a9 08		lda #$08	                lda #err_syntax
.a1d4		4c 5d d9	jmp $d95d	                jmp error
.a1d7						+
.a1d7		20 ba 95	jsr $95ba	                jsr xt_name_to_int      ; ( nt -- xt )
.a1da		60		rts		z_tick:         rts
.a1db						xt_to:
.a1db		20 bb a1	jsr $a1bb	                jsr xt_tick             ; ( [n] xt )
.a1de		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a1e0		18		clc		                clc
.a1e1		69 03		adc #$03	                adc #3
.a1e3		85 24		sta $24		                sta tmp1
.a1e5		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a1e7		69 00		adc #$00	                adc #0                  ; we just want the carry
.a1e9		85 25		sta $25		                sta tmp1+1
.a1eb		e8		inx		                inx
.a1ec		e8		inx		                inx                     ; ( [n] )
.a1ed		a5 16		lda $16		                lda state
.a1ef		05 17		ora $17		                ora state+1
.a1f1		f0 34		beq $a227	                beq _interpret
.a1f3		a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a1f5		a9 b5		lda #$b5	                lda #$B5
.a1f7		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.a1fa		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a1fc		20 ed d7	jsr $d7ed	                jsr cmpl_a
.a1ff		a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a201		a5 24		lda $24		                lda tmp1
.a203		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.a206		a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a208		a9 b5		lda #$b5	                lda #$B5
.a20a		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.a20d		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a20f		20 ed d7	jsr $d7ed	                jsr cmpl_a
.a212		e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a214		d0 02		bne $a218	                bne +
.a216		e6 25		inc $25		                inc tmp1+1
.a218						+
.a218		a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a21a		a5 24		lda $24		                lda tmp1
.a21c		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.a21f		a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a221		98		tya		                tya
.a222		20 e9 d7	jsr $d7e9	                jsr cmpl_word
.a225		80 0f		bra $a236	                bra _done
.a227						_interpret:
.a227		20 47 d9	jsr $d947	                jsr underflow_1
.a22a		b5 00		lda $00,x	                lda 0,x
.a22c		92 24		sta ($24)	                sta (tmp1)              ; LSB
.a22e		a0 01		ldy #$01	                ldy #1
.a230		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a232		91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a234		e8		inx		                inx                     ; DROP
.a235		e8		inx		                inx
.a236						_done:
.a236		60		rts		z_to:           rts
.a237						xt_to_body:
.a237		20 47 d9	jsr $d947	                jsr underflow_1
.a23a		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( xt xt )
.a23d		20 39 92	jsr $9239	                jsr xt_int_to_name      ; ( xt nt )
.a240		f6 00		inc $00,x	                inc 0,x
.a242		d0 02		bne $a246	                bne +
.a244		f6 01		inc $01,x	                inc 1,x
.a246						+
.a246		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a248		29 20		and #$20	                and #HC
.a24a		f0 0d		beq $a259	                beq _no_cfa
.a24c		18		clc		                clc
.a24d		b5 02		lda $02,x	                lda 2,x         ; LSB
.a24f		69 03		adc #$03	                adc #3
.a251		95 02		sta $02,x	                sta 2,x
.a253		b5 03		lda $03,x	                lda 3,x         ; MSB
.a255		69 00		adc #$00	                adc #0          ; we conly care about the carry
.a257		95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a259						_no_cfa:
.a259		e8		inx		                inx             ; get rid of the nt
.a25a		e8		inx		                inx
.a25b						_done:
.a25b		60		rts		z_to_body:      rts
.a25c						xt_to_in:
.a25c		ca		dex		                dex
.a25d		ca		dex		                dex
.a25e		a9 0c		lda #$0c	                lda #<toin
.a260		95 00		sta $00,x	                sta 0,x
.a262		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a264		95 01		sta $01,x	                sta 1,x
.a266		60		rts		z_to_in:        rts
.a267						xt_to_number:
.a267		20 56 d9	jsr $d956	                jsr underflow_4
.a26a		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a26c		85 36		sta $36		                sta scratch
.a26e		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a270		85 37		sta $37		                sta scratch+1
.a272		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a274		85 38		sta $38		                sta scratch+2
.a276		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a278		85 39		sta $39		                sta scratch+3
.a27a		ca		dex		                dex
.a27b		ca		dex		                dex
.a27c						_loop:
.a27c		a1 04		lda ($04,x)	                lda (4,x)
.a27e		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a280		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a282		20 dc 8a	jsr $8adc	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a285		b5 00		lda $00,x	                lda 0,x
.a287		d0 04		bne $a28d	                bne _digit_ok
.a289		e8		inx		                inx
.a28a		e8		inx		                inx
.a28b		80 67		bra $a2f4	                bra _done       ; ( ud-lo ud-hi addr u char )
.a28d						_digit_ok:
.a28d		b5 02		lda $02,x	                lda 2,x
.a28f		85 3a		sta $3a		                sta scratch+4
.a291		b5 03		lda $03,x	                lda 3,x
.a293		85 3b		sta $3b		                sta scratch+5
.a295		a5 38		lda $38		                lda scratch+2
.a297		95 02		sta $02,x	                sta 2,x         ; NOS
.a299		a5 39		lda $39		                lda scratch+3
.a29b		95 03		sta $03,x	                sta 3,x
.a29d		a5 18		lda $18		                lda base
.a29f		95 00		sta $00,x	                sta 0,x         ; TOS
.a2a1		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a2a3		20 a6 a5	jsr $a5a6	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2a6		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2a8		85 3c		sta $3c		                sta scratch+6
.a2aa		b5 03		lda $03,x	                lda 3,x
.a2ac		85 3d		sta $3d		                sta scratch+7
.a2ae		a5 36		lda $36		                lda scratch
.a2b0		95 02		sta $02,x	                sta 2,x
.a2b2		a5 37		lda $37		                lda scratch+1
.a2b4		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a2b6		a5 18		lda $18		                lda base
.a2b8		95 00		sta $00,x	                sta 0,x
.a2ba		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a2bc		20 a6 a5	jsr $a5a6	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a2bf		b5 00		lda $00,x	                lda 0,x
.a2c1		85 38		sta $38		                sta scratch+2
.a2c3		b5 01		lda $01,x	                lda 1,x
.a2c5		85 39		sta $39		                sta scratch+3
.a2c7		b5 02		lda $02,x	                lda 2,x
.a2c9		85 36		sta $36		                sta scratch
.a2cb		b5 03		lda $03,x	                lda 3,x
.a2cd		85 37		sta $37		                sta scratch+1
.a2cf		18		clc		                clc
.a2d0		a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a2d2		65 3a		adc $3a		                adc scratch+4   ; n LSB
.a2d4		85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a2d6		a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a2d8		65 3b		adc $3b		                adc scratch+5   ; n MSB
.a2da		85 37		sta $37		                sta scratch+1
.a2dc		a5 38		lda $38		                lda scratch+2   ; LSB
.a2de		65 3c		adc $3c		                adc scratch+6
.a2e0		85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a2e2		a5 39		lda $39		                lda scratch+3   ; MSB
.a2e4		65 3d		adc $3d		                adc scratch+7
.a2e6		85 39		sta $39		                sta scratch+3
.a2e8		e8		inx		                inx
.a2e9		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a2ea		f6 04		inc $04,x	                inc 4,x
.a2ec		d0 02		bne $a2f0	                bne +
.a2ee		f6 05		inc $05,x	                inc 5,x
.a2f0						+
.a2f0		d6 02		dec $02,x	                dec 2,x
.a2f2		d0 88		bne $a27c	                bne _loop
.a2f4						_done:
.a2f4		e8		inx		                inx
.a2f5		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a2f6		a5 36		lda $36		                lda scratch     ; new ud-lo
.a2f8		95 06		sta $06,x	                sta 6,x
.a2fa		a5 37		lda $37		                lda scratch+1
.a2fc		95 07		sta $07,x	                sta 7,x
.a2fe		a5 38		lda $38		                lda scratch+2
.a300		95 04		sta $04,x	                sta 4,x
.a302		a5 39		lda $39		                lda scratch+3
.a304		95 05		sta $05,x	                sta 5,x
.a306		60		rts		z_to_number:    rts
.a307						xt_to_order:
.a307		20 1a a3	jsr $a31a	                jsr xt_to_r
.a30a		20 f7 90	jsr $90f7	                jsr xt_get_order
.a30d		20 6b 9a	jsr $9a6b	                jsr xt_r_from
.a310		20 58 a1	jsr $a158	                jsr xt_swap
.a313		20 f6 97	jsr $97f6	                jsr xt_one_plus
.a316		20 f4 9c	jsr $9cf4	                jsr xt_set_order
.a319		60		rts		z_to_order:     rts
.a31a						xt_to_r:
.a31a		68		pla		                pla             ; LSB
.a31b		85 2c		sta $2c		                sta tmptos
.a31d		7a		ply		                ply             ; MSB
.a31e		20 47 d9	jsr $d947	                jsr underflow_1
.a321		b5 01		lda $01,x	                lda 1,x         ; MSB
.a323		48		pha		                pha
.a324		b5 00		lda $00,x	                lda 0,x         ; LSB
.a326		48		pha		                pha
.a327		e8		inx		                inx
.a328		e8		inx		                inx
.a329		5a		phy		                phy             ; MSB
.a32a		a5 2c		lda $2c		                lda tmptos
.a32c		48		pha		                pha             ; LSB
.a32d		60		rts		z_to_r:         rts
.a32e						xt_true:
.a32e		ca		dex		                dex
.a32f		ca		dex		                dex
.a330		a9 ff		lda #$ff	                lda #$FF
.a332		95 00		sta $00,x	                sta 0,x
.a334		95 01		sta $01,x	                sta 1,x
.a336		60		rts		z_true:         rts
.a337						xt_tuck:
.a337		20 4c d9	jsr $d94c	                jsr underflow_2
.a33a		ca		dex		                dex
.a33b		ca		dex		                dex
.a33c		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a33e		b5 02		lda $02,x	                lda 2,x
.a340		95 04		sta $04,x	                sta 4,x
.a342		94 02		sty $02,x	                sty 2,x
.a344		95 00		sta $00,x	                sta 0,x
.a346		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a348		b5 03		lda $03,x	                lda 3,x
.a34a		95 05		sta $05,x	                sta 5,x
.a34c		94 03		sty $03,x	                sty 3,x         ; bba
.a34e		95 01		sta $01,x	                sta 1,x         ; baa
.a350		60		rts		z_tuck:         rts
.a351						xt_assembler_wordlist:
.a351						xt_two:
.a351		ca		dex		                dex
.a352		ca		dex		                dex
.a353		a9 02		lda #$02	                lda #2
.a355		95 00		sta $00,x	                sta 0,x
.a357		74 01		stz $01,x	                stz 1,x
.a359						z_assembler_wordlist:
.a359		60		rts		z_two:          rts
.a35a						xt_two_drop:
.a35a		20 4c d9	jsr $d94c	                jsr underflow_2
.a35d		e8		inx		                inx
.a35e		e8		inx		                inx
.a35f		e8		inx		                inx
.a360		e8		inx		                inx
.a361		60		rts		z_two_drop:     rts
.a362						xt_two_dup:
.a362		20 4c d9	jsr $d94c	                jsr underflow_2
.a365		ca		dex		                dex
.a366		ca		dex		                dex
.a367		ca		dex		                dex
.a368		ca		dex		                dex
.a369		b5 04		lda $04,x	                lda 4,x         ; TOS
.a36b		95 00		sta $00,x	                sta 0,x
.a36d		b5 05		lda $05,x	                lda 5,x
.a36f		95 01		sta $01,x	                sta 1,x
.a371		b5 06		lda $06,x	                lda 6,x         ; NOS
.a373		95 02		sta $02,x	                sta 2,x
.a375		b5 07		lda $07,x	                lda 7,x
.a377		95 03		sta $03,x	                sta 3,x
.a379		60		rts		z_two_dup:      rts
.a37a						xt_two_fetch:
.a37a		20 47 d9	jsr $d947	                jsr underflow_1
.a37d		b5 00		lda $00,x	                lda 0,x
.a37f		85 24		sta $24		                sta tmp1
.a381		b4 01		ldy $01,x	                ldy 1,x
.a383		84 25		sty $25		                sty tmp1+1
.a385		ca		dex		                dex             ; reuse one stack element
.a386		ca		dex		                dex
.a387		b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a389		95 00		sta $00,x	                sta 0,x
.a38b		a0 01		ldy #$01	                ldy #1          ; copy next
.a38d		b1 24		lda ($24),y	                lda (tmp1),y
.a38f		95 01		sta $01,x	                sta 1,x
.a391		c8		iny		                iny             ; copy next
.a392		b1 24		lda ($24),y	                lda (tmp1),y
.a394		95 02		sta $02,x	                sta 2,x
.a396		c8		iny		                iny             ; copy next
.a397		b1 24		lda ($24),y	                lda (tmp1),y
.a399		95 03		sta $03,x	                sta 3,x
.a39b		60		rts		z_two_fetch:    rts
.a39c						xt_two_over:
.a39c		20 56 d9	jsr $d956	                jsr underflow_4
.a39f		ca		dex		                dex
.a3a0		ca		dex		                dex
.a3a1		ca		dex		                dex
.a3a2		ca		dex		                dex
.a3a3		b5 08		lda $08,x	                lda 8,x
.a3a5		95 00		sta $00,x	                sta 0,x
.a3a7		b5 09		lda $09,x	                lda 9,x
.a3a9		95 01		sta $01,x	                sta 1,x
.a3ab		b5 0a		lda $0a,x	                lda 10,x
.a3ad		95 02		sta $02,x	                sta 2,x
.a3af		b5 0b		lda $0b,x	                lda 11,x
.a3b1		95 03		sta $03,x	                sta 3,x
.a3b3		60		rts		z_two_over:     rts
.a3b4						xt_two_r_fetch:
.a3b4		ca		dex		                dex
.a3b5		ca		dex		                dex
.a3b6		ca		dex		                dex
.a3b7		ca		dex		                dex
.a3b8		8a		txa		                txa
.a3b9		ba		tsx		                tsx
.a3ba		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a3bb		7a		ply		                ply
.a3bc		aa		tax		                tax
.a3bd		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a3c0		95 00		sta $00,x	                sta 0,x
.a3c2		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a3c5		95 01		sta $01,x	                sta 1,x
.a3c7		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a3ca		95 02		sta $02,x	                sta 2,x
.a3cc		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a3cf		95 03		sta $03,x	                sta 3,x
.a3d1		60		rts		z_two_r_fetch:  rts
.a3d2						xt_two_r_from:
.a3d2		68		pla		                pla                     ; LSB
.a3d3		85 24		sta $24		                sta tmp1
.a3d5		68		pla		                pla                     ; MSB
.a3d6		85 25		sta $25		                sta tmp1+1
.a3d8		ca		dex		                dex
.a3d9		ca		dex		                dex
.a3da		ca		dex		                dex
.a3db		ca		dex		                dex
.a3dc		68		pla		                pla                     ; LSB
.a3dd		95 00		sta $00,x	                sta 0,x
.a3df		68		pla		                pla                     ; MSB
.a3e0		95 01		sta $01,x	                sta 1,x
.a3e2		68		pla		                pla                     ; LSB
.a3e3		95 02		sta $02,x	                sta 2,x
.a3e5		68		pla		                pla                     ; MSB
.a3e6		95 03		sta $03,x	                sta 3,x
.a3e8		a5 25		lda $25		                lda tmp1+1              ; MSB
.a3ea		48		pha		                pha
.a3eb		a5 24		lda $24		                lda tmp1                ; LSB
.a3ed		48		pha		                pha
.a3ee		60		rts		z_two_r_from:   rts
.a3ef						xt_two_slash:
.a3ef		20 47 d9	jsr $d947	                jsr underflow_1
.a3f2		b5 01		lda $01,x	                lda 1,x
.a3f4		0a		asl a		                asl                     ; save the sign
.a3f5		76 01		ror $01,x	                ror 1,x
.a3f7		76 00		ror $00,x	                ror 0,x
.a3f9		60		rts		z_two_slash:    rts
.a3fa						xt_two_star:
.a3fa						xt_cells:
.a3fa		20 47 d9	jsr $d947	                jsr underflow_1
.a3fd		16 00		asl $00,x	                asl 0,x
.a3ff		36 01		rol $01,x	                rol 1,x
.a401						z_cells:
.a401		60		rts		z_two_star:     rts
.a402						xt_two_store:
.a402		20 51 d9	jsr $d951	                jsr underflow_3
.a405		b5 00		lda $00,x	                lda 0,x
.a407		85 24		sta $24		                sta tmp1
.a409		b4 01		ldy $01,x	                ldy 1,x
.a40b		84 25		sty $25		                sty tmp1+1
.a40d		e8		inx		                inx
.a40e		e8		inx		                inx
.a40f		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a411		92 24		sta ($24)	                sta (tmp1)
.a413		b5 01		lda $01,x	                lda 1,x         ; copy next
.a415		a0 01		ldy #$01	                ldy #1
.a417		91 24		sta ($24),y	                sta (tmp1),y
.a419		b5 02		lda $02,x	                lda 2,x         ; copy next
.a41b		c8		iny		                iny
.a41c		91 24		sta ($24),y	                sta (tmp1),y
.a41e		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a420		c8		iny		                iny
.a421		91 24		sta ($24),y	                sta (tmp1),y
.a423		e8		inx		                inx             ; 2DROP
.a424		e8		inx		                inx
.a425		e8		inx		                inx
.a426		e8		inx		                inx
.a427		60		rts		z_two_store:    rts
.a428						xt_two_swap:
.a428		20 56 d9	jsr $d956	                jsr underflow_4
.a42b		b5 00		lda $00,x	                lda 0,x
.a42d		b4 04		ldy $04,x	                ldy 4,x
.a42f		95 04		sta $04,x	                sta 4,x
.a431		94 00		sty $00,x	                sty 0,x
.a433		b5 01		lda $01,x	                lda 1,x
.a435		b4 05		ldy $05,x	                ldy 5,x
.a437		95 05		sta $05,x	                sta 5,x
.a439		94 01		sty $01,x	                sty 1,x
.a43b		b5 02		lda $02,x	                lda 2,x
.a43d		b4 06		ldy $06,x	                ldy 6,x
.a43f		95 06		sta $06,x	                sta 6,x
.a441		94 02		sty $02,x	                sty 2,x
.a443		b5 03		lda $03,x	                lda 3,x
.a445		b4 07		ldy $07,x	                ldy 7,x
.a447		95 07		sta $07,x	                sta 7,x
.a449		94 03		sty $03,x	                sty 3,x
.a44b		60		rts		z_two_swap:     rts
.a44c						xt_two_to_r:
.a44c		68		pla		                pla             ; LSB
.a44d		85 24		sta $24		                sta tmp1
.a44f		68		pla		                pla             ; MSB
.a450		85 25		sta $25		                sta tmp1+1
.a452		20 4c d9	jsr $d94c	                jsr underflow_2
.a455		b5 03		lda $03,x	                lda 3,x         ; MSB
.a457		48		pha		                pha
.a458		b5 02		lda $02,x	                lda 2,x         ; LSB
.a45a		48		pha		                pha
.a45b		b5 01		lda $01,x	                lda 1,x         ; MSB
.a45d		48		pha		                pha
.a45e		b5 00		lda $00,x	                lda 0,x         ; LSB
.a460		48		pha		                pha
.a461		e8		inx		                inx
.a462		e8		inx		                inx
.a463		e8		inx		                inx
.a464		e8		inx		                inx
.a465		a5 25		lda $25		                lda tmp1+1      ; MSB
.a467		48		pha		                pha
.a468		a5 24		lda $24		                lda tmp1        ; LSB
.a46a		48		pha		                pha
.a46b		60		rts		z_two_to_r:     rts
.a46c						xt_two_constant:
.a46c		20 4c d9	jsr $d94c	                jsr underflow_2
.a46f		20 40 89	jsr $8940	                jsr xt_create
.a472		20 58 a1	jsr $a158	                jsr xt_swap
.a475		20 34 87	jsr $8734	                jsr xt_comma
.a478		20 34 87	jsr $8734	                jsr xt_comma
.a47b		20 c7 8b	jsr $8bc7	                jsr does_runtime    ; does> turns into these two routines.
.a47e		20 23 d8	jsr $d823	                jsr dodoes
.a481		20 72 8d	jsr $8d72	                jsr xt_dup
.a484		20 43 8f	jsr $8f43	                jsr xt_fetch
.a487		20 58 a1	jsr $a158	                jsr xt_swap
.a48a		20 e7 85	jsr $85e7	                jsr xt_cell_plus
.a48d		20 43 8f	jsr $8f43	                jsr xt_fetch
.a490		60		rts		z_two_constant: rts
.a491						xt_two_literal:
.a491		20 4c d9	jsr $d94c	                jsr underflow_2 ; double number
.a494		20 58 a1	jsr $a158	                jsr xt_swap
.a497		20 4b 93	jsr $934b	                jsr xt_literal
.a49a		20 4b 93	jsr $934b	                jsr xt_literal
.a49d		60		rts		z_two_literal:  rts
.a49e						xt_two_variable:
.a49e		20 40 89	jsr $8940	                jsr xt_create
.a4a1		ca		dex		                dex
.a4a2		ca		dex		                dex
.a4a3		a9 04		lda #$04	                lda #4
.a4a5		95 00		sta $00,x	                sta 0,x
.a4a7		74 01		stz $01,x	                stz 1,x
.a4a9		20 4f 82	jsr $824f	                jsr xt_allot
.a4ac		60		rts		z_two_variable: rts
.a4ad						xt_type:
.a4ad		20 4c d9	jsr $d94c	                jsr underflow_2
.a4b0		b5 02		lda $02,x	                lda 2,x
.a4b2		85 24		sta $24		                sta tmp1
.a4b4		b5 03		lda $03,x	                lda 3,x
.a4b6		85 25		sta $25		                sta tmp1+1
.a4b8						_loop:
.a4b8		b5 00		lda $00,x	                lda 0,x
.a4ba		15 01		ora $01,x	                ora 1,x
.a4bc		f0 15		beq $a4d3	                beq _done
.a4be		b2 24		lda ($24)	                lda (tmp1)
.a4c0		20 b9 8d	jsr $8db9	                jsr emit_a      ; avoids stack foolery
.a4c3		e6 24		inc $24		                inc tmp1
.a4c5		d0 02		bne $a4c9	                bne +
.a4c7		e6 25		inc $25		                inc tmp1+1
.a4c9						+
.a4c9		b5 00		lda $00,x	                lda 0,x
.a4cb		d0 02		bne $a4cf	                bne +
.a4cd		d6 01		dec $01,x	                dec 1,x
.a4cf						+
.a4cf		d6 00		dec $00,x	                dec 0,x
.a4d1		80 e5		bra $a4b8	                bra _loop
.a4d3						_done:
.a4d3		e8		inx		                inx
.a4d4		e8		inx		                inx
.a4d5		e8		inx		                inx
.a4d6		e8		inx		                inx
.a4d7		60		rts		z_type:         rts
.a4d8						xt_u_dot:
.a4d8		20 47 d9	jsr $d947	                jsr underflow_1
.a4db		20 b4 d9	jsr $d9b4	                jsr print_u
.a4de		a9 20		lda #$20	                lda #AscSP
.a4e0		20 b9 8d	jsr $8db9	                jsr emit_a
.a4e3		60		rts		z_u_dot:        rts
.a4e4						xt_u_dot_r:
.a4e4		20 4c d9	jsr $d94c	                jsr underflow_2
.a4e7		20 1a a3	jsr $a31a	                jsr xt_to_r
.a4ea		20 52 a7	jsr $a752	                jsr xt_zero
.a4ed		20 1b 93	jsr $931b	                jsr xt_less_number_sign
.a4f0		20 b7 97	jsr $97b7	                jsr xt_number_sign_s
.a4f3		20 95 97	jsr $9795	                jsr xt_number_sign_greater
.a4f6		20 6b 9a	jsr $9a6b	                jsr xt_r_from
.a4f9		20 6c 98	jsr $986c	                jsr xt_over
.a4fc		20 29 95	jsr $9529	                jsr xt_minus
.a4ff		20 ce a0	jsr $a0ce	                jsr xt_spaces
.a502		20 ad a4	jsr $a4ad	                jsr xt_type
.a505		60		rts		z_u_dot_r:      rts
.a506						xt_u_greater_than:
.a506		20 4c d9	jsr $d94c	                jsr underflow_2
.a509		b5 00		lda $00,x	                lda 0,x
.a50b		d5 02		cmp $02,x	                cmp 2,x
.a50d		b5 01		lda $01,x	                lda 1,x
.a50f		f5 03		sbc $03,x	                sbc 3,x
.a511		e8		inx		                inx
.a512		e8		inx		                inx
.a513		a9 00		lda #$00	                lda #0
.a515		69 ff		adc #$ff	                adc #$ff
.a517		95 00		sta $00,x	                sta 0,x         ; store flag
.a519		95 01		sta $01,x	                sta 1,x
.a51b		60		rts		z_u_greater_than:    rts
.a51c						xt_u_less_than:
.a51c		20 4c d9	jsr $d94c	                jsr underflow_2
.a51f		b5 02		lda $02,x	                lda 2,x
.a521		d5 00		cmp $00,x	                cmp 0,x
.a523		b5 03		lda $03,x	                lda 3,x
.a525		f5 01		sbc $01,x	                sbc 1,x
.a527		e8		inx		                inx
.a528		e8		inx		                inx
.a529		a9 00		lda #$00	                lda #0
.a52b		69 ff		adc #$ff	                adc #$ff
.a52d		95 00		sta $00,x	                sta 0,x         ; store flag
.a52f		95 01		sta $01,x	                sta 1,x
.a531		60		rts		z_u_less_than:    rts
.a532						xt_ud_dot:
.a532		20 4c d9	jsr $d94c	                jsr underflow_2 ; double number
.a535		20 1b 93	jsr $931b	                jsr xt_less_number_sign
.a538		20 b7 97	jsr $97b7	                jsr xt_number_sign_s
.a53b		20 95 97	jsr $9795	                jsr xt_number_sign_greater
.a53e		20 ad a4	jsr $a4ad	                jsr xt_type
.a541		20 c8 a0	jsr $a0c8	                jsr xt_space
.a544		60		rts		z_ud_dot:        rts
.a545						xt_ud_dot_r:
.a545		20 51 d9	jsr $d951	                jsr underflow_3
.a548		20 1a a3	jsr $a31a	                jsr xt_to_r
.a54b		20 1b 93	jsr $931b	                jsr xt_less_number_sign
.a54e		20 b7 97	jsr $97b7	                jsr xt_number_sign_s
.a551		20 95 97	jsr $9795	                jsr xt_number_sign_greater
.a554		20 6b 9a	jsr $9a6b	                jsr xt_r_from
.a557		20 6c 98	jsr $986c	                jsr xt_over
.a55a		20 29 95	jsr $9529	                jsr xt_minus
.a55d		20 ce a0	jsr $a0ce	                jsr xt_spaces
.a560		20 ad a4	jsr $a4ad	                jsr xt_type
.a563		60		rts		z_ud_dot_r:      rts
.a564						xt_um_slash_mod:
.a564		20 51 d9	jsr $d951	                jsr underflow_3
.a567		b5 00		lda $00,x	                lda 0,x
.a569		15 01		ora $01,x	                ora 1,x
.a56b		d0 05		bne $a572	                bne _not_zero
.a56d		a9 04		lda #$04	                lda #err_divzero
.a56f		4c 5d d9	jmp $d95d	                jmp error
.a572						_not_zero:
.a572		a9 11		lda #$11	                lda #17
.a574		85 2c		sta $2c		                sta tmptos
.a576						_loop:
.a576		36 04		rol $04,x	                rol 4,x
.a578		36 05		rol $05,x	                rol 5,x
.a57a		c6 2c		dec $2c		                dec tmptos
.a57c		f0 22		beq $a5a0	                beq _done
.a57e		36 02		rol $02,x	                rol 2,x
.a580		36 03		rol $03,x	                rol 3,x
.a582		64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a584		26 24		rol $24		                rol tmp1
.a586		38		sec		                sec
.a587		b5 02		lda $02,x	                lda 2,x
.a589		f5 00		sbc $00,x	                sbc 0,x
.a58b		85 25		sta $25		                sta tmp1+1
.a58d		b5 03		lda $03,x	                lda 3,x
.a58f		f5 01		sbc $01,x	                sbc 1,x
.a591		a8		tay		                tay
.a592		a5 24		lda $24		                lda tmp1
.a594		e9 00		sbc #$00	                sbc #0
.a596		90 de		bcc $a576	                bcc _loop
.a598		a5 25		lda $25		                lda tmp1+1
.a59a		95 02		sta $02,x	                sta 2,x
.a59c		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a59e		80 d6		bra $a576	                bra _loop
.a5a0						_done:
.a5a0		e8		inx		                inx
.a5a1		e8		inx		                inx
.a5a2		20 58 a1	jsr $a158	                jsr xt_swap
.a5a5		60		rts		z_um_slash_mod: rts
.a5a6						xt_um_star:
.a5a6		20 4c d9	jsr $d94c	                jsr underflow_2
.a5a9		18		clc		                clc
.a5aa		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a5ac		e9 00		sbc #$00	                sbc #0
.a5ae		85 26		sta $26		                sta tmp2
.a5b0		b5 01		lda $01,x	                lda 1,x
.a5b2		e9 00		sbc #$00	                sbc #0
.a5b4		90 31		bcc $a5e7	                bcc _zero       ; is TOS zero?
.a5b6		85 27		sta $27		                sta tmp2+1
.a5b8		a9 00		lda #$00	                lda #0
.a5ba		85 24		sta $24		                sta tmp1
.a5bc		86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a5be		ca		dex		                dex
.a5bf		ca		dex		                dex
.a5c0						_outer_loop:
.a5c0		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a5c2		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a5c4						_inner_loop:
.a5c4		90 0c		bcc $a5d2	                bcc _no_add
.a5c6		85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a5c8		a5 24		lda $24		                lda tmp1
.a5ca		65 26		adc $26		                adc tmp2
.a5cc		85 24		sta $24		                sta tmp1
.a5ce		a5 25		lda $25		                lda tmp1+1
.a5d0		65 27		adc $27		                adc tmp2+1
.a5d2						_no_add:
.a5d2		6a		ror a		                ror
.a5d3		66 24		ror $24		                ror tmp1
.a5d5		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a5d7		88		dey		                dey
.a5d8		d0 ea		bne $a5c4	                bne _inner_loop ; go back for one more shift?
.a5da		e8		inx		                inx
.a5db		e4 28		cpx $28		                cpx tmp3
.a5dd		d0 e1		bne $a5c0	                bne _outer_loop ; go back for eight more shifts?
.a5df		95 01		sta $01,x	                sta 1,x
.a5e1		a5 24		lda $24		                lda tmp1
.a5e3		95 00		sta $00,x	                sta 0,x
.a5e5		80 04		bra $a5eb	                bra _done
.a5e7						_zero:
.a5e7		74 02		stz $02,x	                stz 2,x
.a5e9		74 03		stz $03,x	                stz 3,x
.a5eb						_done:
.a5eb		60		rts		z_um_star:      rts
.a5ec						xt_unloop:
.a5ec		68		pla		                pla
.a5ed		68		pla		                pla
.a5ee		68		pla		                pla
.a5ef		68		pla		                pla
.a5f0		68		pla		                pla
.a5f1		68		pla		                pla
.a5f2		60		rts		z_unloop:       rts
.a5f3						xt_until:
.a5f3		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.a5f5		a9 d5		lda #$d5	                lda #<zero_branch_runtime
.a5f7		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.a5fa		20 34 87	jsr $8734	                jsr xt_comma
.a5fd		60		rts		z_until:        rts
.a5fe						xt_unused:
.a5fe		ca		dex		                dex
.a5ff		ca		dex		                dex
.a600		a9 00		lda #$00	                lda #<cp_end
.a602		38		sec		                sec
.a603		e5 00		sbc $00		                sbc cp
.a605		95 00		sta $00,x	                sta 0,x
.a607		a9 7c		lda #$7c	                lda #>cp_end
.a609		e5 01		sbc $01		                sbc cp+1
.a60b		95 01		sta $01,x	                sta 1,x
.a60d		60		rts		z_unused:       rts
.a60e						xt_update:
.a60e		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a610		b1 1e		lda ($1e),y	                lda (up),y
.a612		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a614		91 1e		sta ($1e),y	                sta (up),y
.a616		60		rts		z_update:       rts
.a617						xt_useraddr:
.a617		ca		dex		                dex
.a618		ca		dex		                dex
.a619		a9 1e		lda #$1e	                lda #<up
.a61b		95 00		sta $00,x	                sta 0,x
.a61d		a9 00		lda #$00	                lda #>up
.a61f		95 01		sta $01,x	                sta 1,x
.a621		60		rts		z_useraddr:     rts
.a622						xt_variable:
.a622		20 40 89	jsr $8940	                jsr xt_create
.a625		a9 00		lda #$00	                lda #0
.a627		92 00		sta ($00)	                sta (cp)
.a629		e6 00		inc $00		                inc cp
.a62b		d0 02		bne $a62f	                bne +
.a62d		e6 01		inc $01		                inc cp+1
.a62f						+
.a62f		92 00		sta ($00)	                sta (cp)
.a631		e6 00		inc $00		                inc cp
.a633		d0 02		bne $a637	                bne +
.a635		e6 01		inc $01		                inc cp+1
.a637						+
.a637		20 08 89	jsr $8908	                jsr adjust_z
.a63a		60		rts		z_variable:     rts
.a63b						xt_while:
.a63b		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.a63d		a9 d5		lda #$d5	                lda #<zero_branch_runtime
.a63f		20 dd d7	jsr $d7dd	                jsr cmpl_subroutine
.a642		20 35 91	jsr $9135	                jsr xt_here
.a645		20 52 a7	jsr $a752	                jsr xt_zero
.a648		20 34 87	jsr $8734	                jsr xt_comma
.a64b		20 58 a1	jsr $a158	                jsr xt_swap
.a64e		60		rts		z_while:        rts
.a64f						xt_within:
.a64f		20 51 d9	jsr $d951	                jsr underflow_3
.a652		20 6c 98	jsr $986c	                jsr xt_over
.a655		20 29 95	jsr $9529	                jsr xt_minus
.a658		20 1a a3	jsr $a31a	                jsr xt_to_r
.a65b		20 29 95	jsr $9529	                jsr xt_minus
.a65e		20 6b 9a	jsr $9a6b	                jsr xt_r_from
.a661		20 1c a5	jsr $a51c	                jsr xt_u_less_than
.a664		60		rts		z_within:       rts
.a665						xt_word:
.a665		20 47 d9	jsr $d947	                jsr underflow_1
.a668		a4 0c		ldy $0c		                ldy toin                ; >IN
.a66a						_loop:
.a66a		c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a66c		f0 09		beq $a677	                beq _found_char
.a66e		b1 08		lda ($08),y	                lda (cib),y
.a670		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a672		d0 03		bne $a677	                bne _found_char
.a674		c8		iny		                iny
.a675		80 f3		bra $a66a	                bra _loop
.a677						_found_char:
.a677		84 0c		sty $0c		                sty toin
.a679		20 13 99	jsr $9913	                jsr xt_parse            ; Returns ( addr u )
.a67c		b5 00		lda $00,x	                lda 0,x
.a67e		92 00		sta ($00)	                sta (cp)                ; Save length of string
.a680		48		pha		                pha                     ; Keep copy of length for later
.a681		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( addr u u )
.a684		a5 00		lda $00		                lda cp
.a686		18		clc		                clc
.a687		69 01		adc #$01	                adc #1
.a689		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a68b		a5 01		lda $01		                lda cp+1
.a68d		69 00		adc #$00	                adc #0
.a68f		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a691		20 9b 95	jsr $959b	                jsr xt_move
.a694		ca		dex		                dex
.a695		ca		dex		                dex
.a696		a5 00		lda $00		                lda cp
.a698		95 00		sta $00,x	                sta 0,x
.a69a		a5 01		lda $01		                lda cp+1
.a69c		95 01		sta $01,x	                sta 1,x
.a69e		68		pla		                pla                     ; length of string
.a69f		18		clc		                clc
.a6a0		65 00		adc $00		                adc cp
.a6a2		85 00		sta $00		                sta cp
.a6a4		a5 01		lda $01		                lda cp+1
.a6a6		69 00		adc #$00	                adc #0                  ; we only need the carry
.a6a8		85 01		sta $01		                sta cp+1
.a6aa		60		rts		z_word:         rts
.a6ab						xt_wordlist:
.a6ab		a0 05		ldy #$05	                ldy #num_wordlists_offset
.a6ad		b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a6af		c9 0c		cmp #$0c	                cmp #max_wordlists
.a6b1		d0 05		bne $a6b8	                bne _ok
.a6b3		a9 0b		lda #$0b	                lda #err_wordlist
.a6b5		4c 5d d9	jmp $d95d	                jmp error
.a6b8						_ok:
.a6b8		1a		inc a		                ina             ; Increment the wordlist#
.a6b9		91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a6bb		ca		dex		                dex             ; and put it on the stack.
.a6bc		ca		dex		                dex
.a6bd		95 00		sta $00,x	                sta 0,x
.a6bf		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a6c1		60		rts		z_wordlist:     rts
.a6c2						xt_words:
.a6c2		20 3a 89	jsr $893a	                jsr xt_cr
.a6c5		a9 00		lda #$00	                lda #0
.a6c7		48		pha		                pha
.a6c8		ca		dex		                dex                     ; Make room on the stack for
.a6c9		ca		dex		                dex                     ; a dictionary pointer.
.a6ca		64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a6cc						_wordlist_loop:
.a6cc		a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a6ce		a5 28		lda $28		                lda tmp3
.a6d0		d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a6d2		d0 02		bne $a6d6	                bne _have_wordlist
.a6d4		80 45		bra $a71b	                bra _words_done
.a6d6						_have_wordlist:
.a6d6		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a6d7		69 1f		adc #$1f	                adc #search_order_offset
.a6d9		a8		tay		                tay
.a6da		b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a6dc		0a		asl a		                asl                     ; Turn offset into cells offset.
.a6dd		18		clc		                clc
.a6de		69 06		adc #$06	                adc #wordlists_offset
.a6e0		a8		tay		                tay
.a6e1		b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a6e3		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a6e5		c8		iny		                iny
.a6e6		b1 1e		lda ($1e),y	                lda (up),y
.a6e8		95 01		sta $01,x	                sta 1,x
.a6ea						_loop:
.a6ea		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( nt nt )
.a6ed		20 d7 95	jsr $95d7	                jsr xt_name_to_string   ; ( nt addr u )
.a6f0		68		pla		                pla
.a6f1		18		clc		                clc
.a6f2		75 00		adc $00,x	                adc 0,x
.a6f4		1a		inc a		                ina                     ; don't forget the space between words
.a6f5		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a6f7		90 06		bcc $a6ff	                bcc +
.a6f9		20 3a 89	jsr $893a	                jsr xt_cr
.a6fc		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a6fe		1a		inc a		                ina                     ; with length of this word.
.a6ff						+
.a6ff		48		pha		                pha
.a700		20 ad a4	jsr $a4ad	                jsr xt_type             ; ( nt )
.a703		a9 20		lda #$20	                lda #AscSP
.a705		20 b9 8d	jsr $8db9	                jsr emit_a
.a708		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+
.a70b		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+
.a70e		20 43 8f	jsr $8f43	                jsr xt_fetch            ; @ ( nt+1 )
.a711		b5 00		lda $00,x	                lda 0,x
.a713		15 01		ora $01,x	                ora 1,x
.a715		d0 d3		bne $a6ea	                bne _loop
.a717		e6 28		inc $28		                inc tmp3
.a719		80 b1		bra $a6cc	                bra _wordlist_loop
.a71b						_words_done:
.a71b		68		pla		                pla                     ; dump counter
.a71c		e8		inx		                inx
.a71d		e8		inx		                inx
.a71e		60		rts		z_words:        rts
.a71f						xt_wordsize:
.a71f		20 47 d9	jsr $d947	                jsr underflow_1
.a722		b5 00		lda $00,x	                lda 0,x
.a724		85 24		sta $24		                sta tmp1
.a726		b5 01		lda $01,x	                lda 1,x
.a728		85 25		sta $25		                sta tmp1+1
.a72a		a0 06		ldy #$06	                ldy #6
.a72c		b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a72e		88		dey		                dey
.a72f		88		dey		                dey
.a730		38		sec		                sec
.a731		f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a733		95 00		sta $00,x	                sta 0,x
.a735		a0 07		ldy #$07	                ldy #7
.a737		b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a739		88		dey		                dey
.a73a		88		dey		                dey
.a73b		f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a73d		95 01		sta $01,x	                sta 1,x
.a73f		60		rts		z_wordsize:     rts
.a740						xt_xor:
.a740		20 4c d9	jsr $d94c	                jsr underflow_2
.a743		b5 00		lda $00,x	                lda 0,x
.a745		55 02		eor $02,x	                eor 2,x
.a747		95 02		sta $02,x	                sta 2,x
.a749		b5 01		lda $01,x	                lda 1,x
.a74b		55 03		eor $03,x	                eor 3,x
.a74d		95 03		sta $03,x	                sta 3,x
.a74f		e8		inx		                inx
.a750		e8		inx		                inx
.a751		60		rts		z_xor:          rts
.a752						xt_case:
.a752						xt_forth_wordlist:
.a752						xt_zero:
.a752		ca		dex		                dex             ; push
.a753		ca		dex		                dex
.a754		74 00		stz $00,x	                stz 0,x
.a756		74 01		stz $01,x	                stz 1,x
.a758						z_case:
.a758						z_forth_wordlist:
.a758						z_zero:
.a758		60		rts		                rts
.a759						xt_zero_equal:
.a759		20 47 d9	jsr $d947	                jsr underflow_1
.a75c		b5 00		lda $00,x	                lda 0,x
.a75e		15 01		ora $01,x	                ora 1,x
.a760		f0 02		beq $a764	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.a762		a9 ff		lda #$ff	                lda #$ff        ; else set A inverse of the FALSE (0) we want
.a764						_zero:
.a764		49 ff		eor #$ff	                eor #$ff        ; now just invert
.a766						_store:
.a766		95 00		sta $00,x	                sta 0,x
.a768		95 01		sta $01,x	                sta 1,x
.a76a		60		rts		z_zero_equal:   rts
.a76b						xt_zero_greater:
.a76b		20 47 d9	jsr $d947	                jsr underflow_1
.a76e		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a770		b5 01		lda $01,x	                lda 1,x         ; MSB
.a772		30 05		bmi $a779	                bmi _done       ; TOS is negative, keep FLASE
.a774		15 00		ora $00,x	                ora 0,x
.a776		f0 01		beq $a779	                beq _done       ; TOS is zero, keep FALSE
.a778		88		dey		                dey             ; TOS is postive, make true
.a779						_done:
.a779		98		tya		                tya
.a77a		95 00		sta $00,x	                sta 0,x
.a77c		95 01		sta $01,x	                sta 1,x
.a77e		60		rts		z_zero_greater: rts
.a77f						xt_zero_less:
.a77f		20 47 d9	jsr $d947	                jsr underflow_1
.a782		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a784		b5 01		lda $01,x	                lda 1,x         ; MSB
.a786		10 01		bpl $a789	                bpl _done       ; TOS is positive, so keep FALSE
.a788		88		dey		                dey             ; TOS is negative, make TRUE
.a789						_done:
.a789		98		tya		                tya
.a78a		95 00		sta $00,x	                sta 0,x
.a78c		95 01		sta $01,x	                sta 1,x
.a78e		60		rts		z_zero_less:    rts
.a78f						xt_zero_unequal:
.a78f		20 47 d9	jsr $d947	                jsr underflow_1
.a792		b5 00		lda $00,x	                lda 0,x
.a794		15 01		ora $01,x	                ora 1,x
.a796		f0 02		beq $a79a	                beq _zero
.a798		a9 ff		lda #$ff	                lda #$ff
.a79a						_zero:
.a79a		95 00		sta $00,x	                sta 0,x
.a79c		95 01		sta $01,x	                sta 1,x
.a79e		60		rts		z_zero_unequal: rts
.a79f						xt_editor_screen_helper:
.a79f		20 72 8d	jsr $8d72	                jsr xt_dup
.a7a2		20 83 9e	jsr $9e83	                jsr xt_scr
.a7a5		20 37 a1	jsr $a137	                jsr xt_store
.a7a8		20 7b 85	jsr $857b	                jsr xt_buffer
.a7ab						z_editor_screen_helper:
.a7ab		60		rts		                rts
.a7ac						xt_editor_enter_screen:
.a7ac		20 9f a7	jsr $a79f	                jsr xt_editor_screen_helper
.a7af		20 f1 8c	jsr $8cf1	                jsr xt_drop
.a7b2		64 2e		stz $2e		                stz editor1
.a7b4						_prompt_loop:
.a7b4		ca		dex		                dex
.a7b5		ca		dex		                dex
.a7b6		a5 2e		lda $2e		                lda editor1
.a7b8		95 00		sta $00,x	                sta 0,x
.a7ba		74 01		stz $01,x	                stz 1,x
.a7bc		20 81 a8	jsr $a881	                jsr xt_editor_o
.a7bf		e6 2e		inc $2e		                inc editor1
.a7c1		a9 10		lda #$10	                lda #16
.a7c3		c5 2e		cmp $2e		                cmp editor1
.a7c5		d0 ed		bne $a7b4	                bne _prompt_loop
.a7c7						z_editor_enter_screen:
.a7c7		60		rts		                rts
.a7c8						xt_editor_erase_screen:
.a7c8		20 9f a7	jsr $a79f	                jsr xt_editor_screen_helper
.a7cb		ca		dex		                dex
.a7cc		ca		dex		                dex
.a7cd		74 00		stz $00,x	                stz 0,x
.a7cf		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a7d1		95 01		sta $01,x	                sta 1,x
.a7d3		20 ad 8e	jsr $8ead	                jsr xt_blank
.a7d6		20 0e a6	jsr $a60e	                jsr xt_update
.a7d9						z_editor_erase_screen:
.a7d9		60		rts		                rts
.a7da						xt_editor_el:
.a7da		20 68 a8	jsr $a868	                jsr xt_editor_line
.a7dd		ca		dex		                dex
.a7de		ca		dex		                dex
.a7df		a9 40		lda #$40	                lda #64
.a7e1		95 00		sta $00,x	                sta 0,x
.a7e3		74 01		stz $01,x	                stz 1,x
.a7e5		20 ad 8e	jsr $8ead	                jsr xt_blank
.a7e8		20 0e a6	jsr $a60e	                jsr xt_update
.a7eb		60		rts		z_editor_el:    rts
.a7ec						xt_editor_l:
.a7ec		ca		dex		                dex             ; Put SCR on the stack.
.a7ed		ca		dex		                dex
.a7ee		a0 02		ldy #$02	                ldy #scr_offset
.a7f0		b1 1e		lda ($1e),y	                lda (up),y
.a7f2		95 00		sta $00,x	                sta 0,x
.a7f4		c8		iny		                iny
.a7f5		b1 1e		lda ($1e),y	                lda (up),y
.a7f7		95 01		sta $01,x	                sta 1,x
.a7f9		20 87 83	jsr $8387	                jsr xt_block    ; Get the current screen.
.a7fc		20 3a 89	jsr $893a	                jsr xt_cr
.a7ff		80 08		bra $a809	                bra _after_screen_msg
.a801						_screen_msg:
>a801		53 63 72 65 65 6e 20 23		                .text "Screen #"
.a809						_after_screen_msg:
.a809		20 53 a0	jsr $a053	                jsr sliteral_runtime
>a80c		01 a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a810		20 ad a4	jsr $a4ad	                jsr xt_type
.a813		20 83 9e	jsr $9e83	                jsr xt_scr
.a816		20 43 8f	jsr $8f43	                jsr xt_fetch
.a819		ca		dex		                dex
.a81a		ca		dex		                dex
.a81b		a9 04		lda #$04	                lda #4          ; four spaces
.a81d		95 00		sta $00,x	                sta 0,x
.a81f		74 01		stz $01,x	                stz 1,x
.a821		20 e4 a4	jsr $a4e4	                jsr xt_u_dot_r
.a824		64 28		stz $28		                stz tmp3
.a826						_line_loop:
.a826		20 3a 89	jsr $893a	                jsr xt_cr
.a829		ca		dex		                dex
.a82a		ca		dex		                dex
.a82b		ca		dex		                dex
.a82c		ca		dex		                dex
.a82d		74 03		stz $03,x	                stz 3,x
.a82f		a5 28		lda $28		                lda tmp3
.a831		95 02		sta $02,x	                sta 2,x
.a833		74 01		stz $01,x	                stz 1,x
.a835		a9 02		lda #$02	                lda #2
.a837		95 00		sta $00,x	                sta 0,x
.a839		20 e4 a4	jsr $a4e4	                jsr xt_u_dot_r
.a83c		20 c8 a0	jsr $a0c8	                jsr xt_space
.a83f		20 72 8d	jsr $8d72	                jsr xt_dup
.a842		ca		dex		                dex
.a843		ca		dex		                dex
.a844		a9 40		lda #$40	                lda #64
.a846		95 00		sta $00,x	                sta 0,x
.a848		74 01		stz $01,x	                stz 1,x
.a84a		20 ad a4	jsr $a4ad	                jsr xt_type
.a84d		18		clc		                clc
.a84e		a9 40		lda #$40	                lda #64
.a850		75 00		adc $00,x	                adc 0,x
.a852		95 00		sta $00,x	                sta 0,x
.a854		b5 01		lda $01,x	                lda 1,x
.a856		69 00		adc #$00	                adc #0      ; Add carry
.a858		95 01		sta $01,x	                sta 1,x
.a85a		e6 28		inc $28		                inc tmp3
.a85c		a5 28		lda $28		                lda tmp3
.a85e		c9 10		cmp #$10	                cmp #16
.a860		d0 c4		bne $a826	                bne _line_loop
.a862		20 3a 89	jsr $893a	                jsr xt_cr
.a865		e8		inx		                inx
.a866		e8		inx		                inx
.a867		60		rts		z_editor_l:            rts
.a868						xt_editor_line:
.a868		20 47 d9	jsr $d947	                jsr underflow_1
.a86b		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a86d						_shift_tos_left:
.a86d		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a86f		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a871		88		dey		                dey
.a872		d0 f9		bne $a86d	                bne _shift_tos_left
.a874		20 83 9e	jsr $9e83	                jsr xt_scr
.a877		20 43 8f	jsr $8f43	                jsr xt_fetch
.a87a		20 87 83	jsr $8387	                jsr xt_block
.a87d		20 bc 99	jsr $99bc	                jsr xt_plus
.a880		60		rts		z_editor_line:  rts
.a881						xt_editor_o:
.a881		20 3a 89	jsr $893a	                jsr xt_cr
.a884		20 72 8d	jsr $8d72	                jsr xt_dup
.a887		20 51 a3	jsr $a351	                jsr xt_two
.a88a		20 e4 a4	jsr $a4e4	                jsr xt_u_dot_r
.a88d		20 c8 a0	jsr $a0c8	                jsr xt_space
.a890		a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a892		20 b9 8d	jsr $8db9	                jsr emit_a
.a895		20 c8 a0	jsr $a0c8	                jsr xt_space
.a898		20 68 a8	jsr $a868	                jsr xt_editor_line
.a89b		20 72 8d	jsr $8d72	                jsr xt_dup      ; Save a copy of the line address for later.
.a89e		ca		dex		                dex
.a89f		ca		dex		                dex
.a8a0		a9 40		lda #$40	                lda #64         ; chars/line
.a8a2		95 00		sta $00,x	                sta 0,x
.a8a4		74 01		stz $01,x	                stz 1,x
.a8a6		20 f2 80	jsr $80f2	                jsr xt_accept
.a8a9		20 72 8d	jsr $8d72	                jsr xt_dup
.a8ac		20 47 96	jsr $9647	                jsr xt_not_rote ; -rot
.a8af		20 bc 99	jsr $99bc	                jsr xt_plus
.a8b2		ca		dex		                dex
.a8b3		ca		dex		                dex
.a8b4		a9 40		lda #$40	                lda #64         ; chars/line
.a8b6		95 00		sta $00,x	                sta 0,x
.a8b8		74 01		stz $01,x	                stz 1,x
.a8ba		20 30 9b	jsr $9b30	                jsr xt_rot
.a8bd		20 29 95	jsr $9529	                jsr xt_minus
.a8c0		20 ad 8e	jsr $8ead	                jsr xt_blank
.a8c3		20 0e a6	jsr $a60e	                jsr xt_update
.a8c6		60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
=126						turnkey   = zpage_end-1    ; word to resume in pre-compiled image
.a8c7						cold_zp_table:
>a8c7	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>a8c9	0002	4e bd				dp:         .word dictionary_start  ; Dictionary Pointer
>a8cb	0004	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>a8cd	0006	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>a8cf	0008	00 02				cib:        .word buffer0           ; address of current input buffer
>a8d1	000a	00 00				ciblen:     .word 0                 ; length of current input buffer
>a8d3	000c	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>a8d5	000e	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>a8d7	0010	27 f0				output:     .word kernel_putc       ; vector for EMIT
>a8d9	0012	21 f0				input:      .word kernel_getc       ; vector for KEY
>a8db	0014	00 00				havekey:    .word 0                 ; vector for KEY?
>a8dd	0016	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>a8df	0018	0a 00				base:       .word 10                ; number radix, default decimal
>a8e1	001a	14 00				nc_limit:   .word 20                ; byte limit for Native Compile size
>a8e3	001c	00 00				uf_strip:   .word 0                 ; flag to strip underflow detection code (0 off)
>a8e5	001e	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>a8e7	0020	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>a8e9	0022					tmpbranch:  .word ?         ; temporary storage for 0BRANCH, BRANCH only
>a8eb	0024					tmp1:       .word ?         ; temporary storage
>a8ed	0026					tmp2:       .word ?         ; temporary storage
>a8ef	0028					tmp3:       .word ?         ; temporary storage (especially for print)
>a8f1	002a					tmpdsp:     .word ?         ; temporary DSP (X) storage (two bytes)
>a8f3	002c					tmptos:     .word ?         ; temporary TOS storage
>a8f5	002e					editor1:    .word ?         ; temporary for editors
>a8f7	0030					editor2:    .word ?         ; temporary for editors
>a8f9	0032					editor3:    .word ?         ; temporary for editors
>a8fb	0034					tohold:     .word ?         ; pointer for formatted output
>a8fd	0036					scratch:    .word ?         ; 8 byte scratchpad (see UM/MOD)
.a8e9						cold_zp_table_end:
.a8e9						cold_user_table:
>a8e9	0000	00 00				blk_offset:             .word 0         ; BLK
>a8eb	0002	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
>a8ed	0004	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>a8ee	0005	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.a8ef	0006					wordlists_offset:
>a8ef	0006	4e bd				    .word dictionary_start              ; FORTH-WORDLIST
>a8f1	0008	96 cb				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>a8f3	000a	e6 cb				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>a8f5	000c	55 cb				    .word root_dictionary_start         ; ROOT-WORDLIST
>a8f7	000e	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>a8ff	0016	00 00 00 00 00 00 00 00
>a907	001e	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.a908	001f					search_order_offset:
>a908	001f	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>a910	0027	00
>a911	0028	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>a913	002a	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>a915	002c	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>a917	002e	21 85				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>a919	0030	21 85				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.a91b						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0a  ; line feed
=$0d						AscCR   = $0d  ; carriage return
=$1b						AscESC  = $1b  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7f  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a91b						assembler:
.a91b						xt_asm_adc_h:
.a91b		a9 69		lda #$69	                lda #$69
.a91d		4c 76 ac	jmp $ac76	                jmp asm_common
.a920						z_asm_adc_h:
.a920						xt_asm_adc_x:
.a920		a9 7d		lda #$7d	                lda #$7D
.a922		4c 76 ac	jmp $ac76	                jmp asm_common
.a925						z_asm_adc_x:
.a925						xt_asm_adc_y:
.a925		a9 79		lda #$79	                lda #$79
.a927		4c 76 ac	jmp $ac76	                jmp asm_common
.a92a						z_asm_adc_y:
.a92a						xt_asm_adc_z:
.a92a		a9 65		lda #$65	                lda #$65
.a92c		4c 76 ac	jmp $ac76	                jmp asm_common
.a92f						z_asm_adc_z:
.a92f						xt_asm_adc_zi:
.a92f		a9 72		lda #$72	                lda #$72
.a931		4c 76 ac	jmp $ac76	                jmp asm_common
.a934						z_asm_adc_zi:
.a934						xt_asm_adc_ziy:
.a934		a9 71		lda #$71	                lda #$71
.a936		4c 76 ac	jmp $ac76	                jmp asm_common
.a939						z_asm_adc_ziy:
.a939						xt_asm_adc_zx:
.a939		a9 75		lda #$75	                lda #$75
.a93b		4c 76 ac	jmp $ac76	                jmp asm_common
.a93e						z_asm_adc_zx:
.a93e						xt_asm_adc_zxi:
.a93e		a9 61		lda #$61	                lda #$61
.a940		4c 76 ac	jmp $ac76	                jmp asm_common
.a943						z_asm_adc_zxi:
.a943						xt_asm_and:
.a943		a9 2d		lda #$2d	                lda #$2D
.a945		4c 76 ac	jmp $ac76	                jmp asm_common
.a948						z_asm_and:
.a948						xt_asm_and_h:
.a948		a9 29		lda #$29	                lda #$29
.a94a		4c 76 ac	jmp $ac76	                jmp asm_common
.a94d						z_asm_and_h:
.a94d						xt_asm_and_x:
.a94d		a9 3d		lda #$3d	                lda #$3D
.a94f		4c 76 ac	jmp $ac76	                jmp asm_common
.a952						z_asm_and_x:
.a952						xt_asm_and_y:
.a952		a9 39		lda #$39	                lda #$39
.a954		4c 76 ac	jmp $ac76	                jmp asm_common
.a957						z_asm_and_y:
.a957						xt_asm_and_z:
.a957		a9 25		lda #$25	                lda #$25
.a959		4c 76 ac	jmp $ac76	                jmp asm_common
.a95c						z_asm_and_z:
.a95c						xt_asm_and_zi:
.a95c		a9 32		lda #$32	                lda #$32
.a95e		4c 76 ac	jmp $ac76	                jmp asm_common
.a961						z_asm_and_zi:
.a961						xt_asm_and_ziy:
.a961		a9 31		lda #$31	                lda #$31
.a963		4c 76 ac	jmp $ac76	                jmp asm_common
.a966						z_asm_and_ziy:
.a966						xt_asm_and_zx:
.a966		a9 35		lda #$35	                lda #$35
.a968		4c 76 ac	jmp $ac76	                jmp asm_common
.a96b						z_asm_and_zx:
.a96b						xt_asm_and_zxi:
.a96b		a9 21		lda #$21	                lda #$21
.a96d		4c 76 ac	jmp $ac76	                jmp asm_common
.a970						z_asm_and_zxi:
.a970						xt_asm_asl:
.a970		a9 0e		lda #$0e	                lda #$0E
.a972		4c 76 ac	jmp $ac76	                jmp asm_common
.a975						z_asm_asl:
.a975						xt_asm_asl_a:
.a975		a9 0a		lda #$0a	                lda #$0A
.a977		4c 76 ac	jmp $ac76	                jmp asm_common
.a97a						z_asm_asl_a:
.a97a						xt_asm_asl_x:
.a97a		a9 1e		lda #$1e	                lda #$1E
.a97c		4c 76 ac	jmp $ac76	                jmp asm_common
.a97f						z_asm_asl_x:
.a97f						xt_asm_asl_z:
.a97f		a9 06		lda #$06	                lda #$06
.a981		4c 76 ac	jmp $ac76	                jmp asm_common
.a984						z_asm_asl_z:
.a984						xt_asm_asl_zx:
.a984		a9 16		lda #$16	                lda #$16
.a986		4c 76 ac	jmp $ac76	                jmp asm_common
.a989						z_asm_asl_zx:
.a989						xt_asm_bcc:
.a989		a9 90		lda #$90	                lda #$90
.a98b		4c 76 ac	jmp $ac76	                jmp asm_common
.a98e						z_asm_bcc:
.a98e						xt_asm_bcs:
.a98e		a9 b0		lda #$b0	                lda #$B0
.a990		a0 02		ldy #$02	                ldy #2
.a992		4c 76 ac	jmp $ac76	                jmp asm_common
.a995						z_asm_bcs:
.a995						xt_asm_beq:
.a995		a9 f0		lda #$f0	                lda #$F0
.a997		4c 76 ac	jmp $ac76	                jmp asm_common
.a99a						z_asm_beq:
.a99a						xt_asm_bit:
.a99a		a9 2c		lda #$2c	                lda #$2C
.a99c		4c 76 ac	jmp $ac76	                jmp asm_common
.a99f						z_asm_bit:
.a99f						xt_asm_bit_h:
.a99f		a9 89		lda #$89	                lda #$89
.a9a1		4c 76 ac	jmp $ac76	                jmp asm_common
.a9a4						z_asm_bit_h:
.a9a4						xt_asm_bit_x:
.a9a4		a9 3c		lda #$3c	                lda #$3C
.a9a6		4c 76 ac	jmp $ac76	                jmp asm_common
.a9a9						z_asm_bit_x:
.a9a9						xt_asm_bit_z:
.a9a9		a9 24		lda #$24	                lda #$24
.a9ab		4c 76 ac	jmp $ac76	                jmp asm_common
.a9ae						z_asm_bit_z:
.a9ae						xt_asm_bit_zx:
.a9ae		a9 34		lda #$34	                lda #$34
.a9b0		4c 76 ac	jmp $ac76	                jmp asm_common
.a9b3						z_asm_bit_zx:
.a9b3						xt_asm_bmi:
.a9b3		a9 30		lda #$30	                lda #$30
.a9b5		4c 76 ac	jmp $ac76	                jmp asm_common
.a9b8						z_asm_bmi:
.a9b8						xt_asm_bne:
.a9b8		a9 d0		lda #$d0	                lda #$D0
.a9ba		4c 76 ac	jmp $ac76	                jmp asm_common
.a9bd						z_asm_bne:
.a9bd						xt_asm_bpl:
.a9bd		a9 10		lda #$10	                lda #$10
.a9bf		4c 76 ac	jmp $ac76	                jmp asm_common
.a9c2						z_asm_bpl:
.a9c2						xt_asm_bra:
.a9c2		a9 80		lda #$80	                lda #$80
.a9c4		4c 76 ac	jmp $ac76	                jmp asm_common
.a9c7						z_asm_bra:
.a9c7						xt_asm_brk:
.a9c7		a9 00		lda #$00	                lda #$00
.a9c9		4c 76 ac	jmp $ac76	                jmp asm_common
.a9cc						z_asm_brk:
.a9cc						xt_asm_bvc:
.a9cc		a9 50		lda #$50	                lda #$50
.a9ce		4c 76 ac	jmp $ac76	                jmp asm_common
.a9d1						z_asm_bvc:
.a9d1						xt_asm_bvs:
.a9d1		a9 70		lda #$70	                lda #$70
.a9d3		4c 76 ac	jmp $ac76	                jmp asm_common
.a9d6						z_asm_bvs:
.a9d6						xt_asm_clc:
.a9d6		a9 18		lda #$18	                lda #$18
.a9d8		4c 76 ac	jmp $ac76	                jmp asm_common
.a9db						z_asm_clc:
.a9db						xt_asm_cld:
.a9db		a9 d8		lda #$d8	                lda #$D8
.a9dd		4c 76 ac	jmp $ac76	                jmp asm_common
.a9e0						z_asm_cld:
.a9e0						xt_asm_cli:
.a9e0		a9 58		lda #$58	                lda #$58
.a9e2		4c 76 ac	jmp $ac76	                jmp asm_common
.a9e5						z_asm_cli:
.a9e5						xt_asm_clv:
.a9e5		a9 b8		lda #$b8	                lda #$B8
.a9e7		4c 76 ac	jmp $ac76	                jmp asm_common
.a9ea						z_asm_clv:
.a9ea						xt_asm_cmp:
.a9ea		a9 cd		lda #$cd	                lda #$CD
.a9ec		4c 76 ac	jmp $ac76	                jmp asm_common
.a9ef						z_asm_cmp:
.a9ef						xt_asm_cmp_h:
.a9ef		a9 c9		lda #$c9	                lda #$C9
.a9f1		4c 76 ac	jmp $ac76	                jmp asm_common
.a9f4						z_asm_cmp_h:
.a9f4						xt_asm_cmp_x:
.a9f4		a9 dd		lda #$dd	                lda #$DD
.a9f6		4c 76 ac	jmp $ac76	                jmp asm_common
.a9f9						z_asm_cmp_x:
.a9f9						xt_asm_cmp_y:
.a9f9		a9 d9		lda #$d9	                lda #$D9
.a9fb		4c 76 ac	jmp $ac76	                jmp asm_common
.a9fe						z_asm_cmp_y:
.a9fe						xt_asm_cmp_z:
.a9fe		a9 c5		lda #$c5	                lda #$C5
.aa00		4c 76 ac	jmp $ac76	                jmp asm_common
.aa03						z_asm_cmp_z:
.aa03						xt_asm_cmp_zi:
.aa03		a9 d2		lda #$d2	                lda #$D2
.aa05		4c 76 ac	jmp $ac76	                jmp asm_common
.aa08						z_asm_cmp_zi:
.aa08						xt_asm_cmp_ziy:
.aa08		a9 d1		lda #$d1	                lda #$D1
.aa0a		4c 76 ac	jmp $ac76	                jmp asm_common
.aa0d						z_asm_cmp_ziy:
.aa0d						xt_asm_cmp_zx:
.aa0d		a9 d5		lda #$d5	                lda #$D5
.aa0f		4c 76 ac	jmp $ac76	                jmp asm_common
.aa12						z_asm_cmp_zx:
.aa12						xt_asm_cmp_zxi:
.aa12		a9 c1		lda #$c1	                lda #$C1
.aa14		4c 76 ac	jmp $ac76	                jmp asm_common
.aa17						z_asm_cmp_zxi:
.aa17						xt_asm_cpx:
.aa17		a9 ec		lda #$ec	                lda #$EC
.aa19		4c 76 ac	jmp $ac76	                jmp asm_common
.aa1c						z_asm_cpx:
.aa1c						xt_asm_cpx_h:
.aa1c		a9 e0		lda #$e0	                lda #$E0
.aa1e		4c 76 ac	jmp $ac76	                jmp asm_common
.aa21						z_asm_cpx_h:
.aa21						xt_asm_cpx_z:
.aa21		a9 e4		lda #$e4	                lda #$E4
.aa23		4c 76 ac	jmp $ac76	                jmp asm_common
.aa26						z_asm_cpx_z:
.aa26						xt_asm_cpy:
.aa26		a9 cc		lda #$cc	                lda #$CC
.aa28		a0 03		ldy #$03	                ldy #3
.aa2a		4c 76 ac	jmp $ac76	                jmp asm_common
.aa2d						z_asm_cpy:
.aa2d						xt_asm_cpy_h:
.aa2d		a9 c0		lda #$c0	                lda #$C0
.aa2f		4c 76 ac	jmp $ac76	                jmp asm_common
.aa32						z_asm_cpy_h:
.aa32						xt_asm_cpy_z:
.aa32		a9 c4		lda #$c4	                lda #$C4
.aa34		4c 76 ac	jmp $ac76	                jmp asm_common
.aa37						z_asm_cpy_z:
.aa37						xt_asm_dec:
.aa37		a9 ce		lda #$ce	                lda #$CE
.aa39		4c 76 ac	jmp $ac76	                jmp asm_common
.aa3c						z_asm_dec:
.aa3c						xt_asm_dec_a:
.aa3c		a9 3a		lda #$3a	                lda #$3A
.aa3e		4c 76 ac	jmp $ac76	                jmp asm_common
.aa41						z_asm_dec_a:
.aa41						xt_asm_dec_x:
.aa41		a9 de		lda #$de	                lda #$DE
.aa43		4c 76 ac	jmp $ac76	                jmp asm_common
.aa46						z_asm_dec_x:
.aa46						xt_asm_dec_z:
.aa46		a9 c6		lda #$c6	                lda #$C6
.aa48		4c 76 ac	jmp $ac76	                jmp asm_common
.aa4b						z_asm_dec_z:
.aa4b						xt_asm_dec_zx:
.aa4b		a9 d6		lda #$d6	                lda #$D6
.aa4d		4c 76 ac	jmp $ac76	                jmp asm_common
.aa50						z_asm_dec_zx:
.aa50						xt_asm_dex:
.aa50		a9 ca		lda #$ca	                lda #$CA
.aa52		4c 76 ac	jmp $ac76	                jmp asm_common
.aa55						z_asm_dex:
.aa55						xt_asm_dey:
.aa55		a9 88		lda #$88	                lda #$88
.aa57		4c 76 ac	jmp $ac76	                jmp asm_common
.aa5a						z_asm_dey:
.aa5a						xt_asm_eor:
.aa5a		a9 4d		lda #$4d	                lda #$4D
.aa5c		4c 76 ac	jmp $ac76	                jmp asm_common
.aa5f						z_asm_eor:
.aa5f						xt_asm_eor_h:
.aa5f		a9 49		lda #$49	                lda #$49
.aa61		4c 76 ac	jmp $ac76	                jmp asm_common
.aa64						z_asm_eor_h:
.aa64						xt_asm_eor_x:
.aa64		a9 5d		lda #$5d	                lda #$5D
.aa66		4c 76 ac	jmp $ac76	                jmp asm_common
.aa69						z_asm_eor_x:
.aa69						xt_asm_eor_y:
.aa69		a9 59		lda #$59	                lda #$59
.aa6b		4c 76 ac	jmp $ac76	                jmp asm_common
.aa6e						z_asm_eor_y:
.aa6e						xt_asm_eor_z:
.aa6e		a9 45		lda #$45	                lda #$45
.aa70		4c 76 ac	jmp $ac76	                jmp asm_common
.aa73						z_asm_eor_z:
.aa73						xt_asm_eor_zi:
.aa73		a9 52		lda #$52	                lda #$52
.aa75		4c 76 ac	jmp $ac76	                jmp asm_common
.aa78						z_asm_eor_zi:
.aa78						xt_asm_eor_ziy:
.aa78		a9 51		lda #$51	                lda #$51
.aa7a		4c 76 ac	jmp $ac76	                jmp asm_common
.aa7d						z_asm_eor_ziy:
.aa7d						xt_asm_eor_zx:
.aa7d		a9 55		lda #$55	                lda #$55
.aa7f		4c 76 ac	jmp $ac76	                jmp asm_common
.aa82						z_asm_eor_zx:
.aa82						xt_asm_eor_zxi:
.aa82		a9 41		lda #$41	                lda #$41
.aa84		4c 76 ac	jmp $ac76	                jmp asm_common
.aa87						z_asm_eor_zxi:
.aa87						xt_asm_inc:
.aa87		a9 ee		lda #$ee	                lda #$EE
.aa89		4c 76 ac	jmp $ac76	                jmp asm_common
.aa8c						z_asm_inc:
.aa8c						xt_asm_inc_a:
.aa8c		a9 1a		lda #$1a	                lda #$1A
.aa8e		4c 76 ac	jmp $ac76	                jmp asm_common
.aa91						z_asm_inc_a:
.aa91						xt_asm_inc_x:
.aa91		a9 fe		lda #$fe	                lda #$FE
.aa93		4c 76 ac	jmp $ac76	                jmp asm_common
.aa96						z_asm_inc_x:
.aa96						xt_asm_inc_z:
.aa96		a9 e6		lda #$e6	                lda #$E6
.aa98		4c 76 ac	jmp $ac76	                jmp asm_common
.aa9b						z_asm_inc_z:
.aa9b						xt_asm_inc_zx:
.aa9b		a9 f6		lda #$f6	                lda #$F6
.aa9d		4c 76 ac	jmp $ac76	                jmp asm_common
.aaa0						z_asm_inc_zx:
.aaa0						xt_asm_inx:
.aaa0		a9 e8		lda #$e8	                lda #$E8
.aaa2		4c 76 ac	jmp $ac76	                jmp asm_common
.aaa5						z_asm_inx:
.aaa5						xt_asm_iny:
.aaa5		a9 c8		lda #$c8	                lda #$C8
.aaa7		4c 76 ac	jmp $ac76	                jmp asm_common
.aaaa						z_asm_iny:
.aaaa						xt_asm_jmp:
.aaaa		a9 4c		lda #$4c	                lda #$4C
.aaac		4c 76 ac	jmp $ac76	                jmp asm_common
.aaaf						z_asm_jmp:
.aaaf						xt_asm_jmp_i:
.aaaf		a9 6c		lda #$6c	                lda #$6C
.aab1		4c 76 ac	jmp $ac76	                jmp asm_common
.aab4						z_asm_jmp_i:
.aab4						xt_asm_jmp_xi:
.aab4		a9 7c		lda #$7c	                lda #$7C
.aab6		4c 76 ac	jmp $ac76	                jmp asm_common
.aab9						z_asm_jmp_xi:
.aab9						xt_asm_jsr:
.aab9		a9 20		lda #$20	                lda #$20
.aabb		4c 76 ac	jmp $ac76	                jmp asm_common
.aabe						z_asm_jsr:
.aabe						xt_asm_lda:
.aabe		a9 ad		lda #$ad	                lda #$AD
.aac0		4c 76 ac	jmp $ac76	                jmp asm_common
.aac3						z_asm_lda:
.aac3						xt_asm_lda_h:
.aac3		a9 a9		lda #$a9	                lda #$A9
.aac5		4c 76 ac	jmp $ac76	                jmp asm_common
.aac8						z_asm_lda_h:
.aac8						xt_asm_lda_x:
.aac8		a9 bd		lda #$bd	                lda #$BD
.aaca		4c 76 ac	jmp $ac76	                jmp asm_common
.aacd						z_asm_lda_x:
.aacd						xt_asm_lda_y:
.aacd		a9 b9		lda #$b9	                lda #$B9
.aacf		4c 76 ac	jmp $ac76	                jmp asm_common
.aad2						z_asm_lda_y:
.aad2						xt_asm_lda_z:
.aad2		a9 a5		lda #$a5	                lda #$A5
.aad4		4c 76 ac	jmp $ac76	                jmp asm_common
.aad7						z_asm_lda_z:
.aad7						xt_asm_lda_zi:
.aad7		a9 b2		lda #$b2	                lda #$B2
.aad9		4c 76 ac	jmp $ac76	                jmp asm_common
.aadc						z_asm_lda_zi:
.aadc						xt_asm_lda_ziy:
.aadc		a9 b1		lda #$b1	                lda #$B1
.aade		4c 76 ac	jmp $ac76	                jmp asm_common
.aae1						z_asm_lda_ziy:
.aae1						xt_asm_lda_zx:
.aae1		a9 b5		lda #$b5	                lda #$B5
.aae3		4c 76 ac	jmp $ac76	                jmp asm_common
.aae6						z_asm_lda_zx:
.aae6						xt_asm_lda_zxi:
.aae6		a9 a1		lda #$a1	                lda #$A1
.aae8		4c 76 ac	jmp $ac76	                jmp asm_common
.aaeb						z_asm_lda_zxi:
.aaeb						xt_asm_ldx:
.aaeb		a9 ae		lda #$ae	                lda #$AE
.aaed		4c 76 ac	jmp $ac76	                jmp asm_common
.aaf0						z_asm_ldx:
.aaf0						xt_asm_ldx_h:
.aaf0		a9 a2		lda #$a2	                lda #$A2
.aaf2		4c 76 ac	jmp $ac76	                jmp asm_common
.aaf5						z_asm_ldx_h:
.aaf5						xt_asm_ldx_y:
.aaf5		a9 be		lda #$be	                lda #$BE
.aaf7		4c 76 ac	jmp $ac76	                jmp asm_common
.aafa						z_asm_ldx_y:
.aafa						xt_asm_ldx_z:
.aafa		a9 a6		lda #$a6	                lda #$A6
.aafc		4c 76 ac	jmp $ac76	                jmp asm_common
.aaff						z_asm_ldx_z:
.aaff						xt_asm_ldx_zy:
.aaff		a9 b6		lda #$b6	                lda #$B6
.ab01		4c 76 ac	jmp $ac76	                jmp asm_common
.ab04						z_asm_ldx_zy:
.ab04						xt_asm_ldy:
.ab04		a9 ac		lda #$ac	                lda #$AC
.ab06		4c 76 ac	jmp $ac76	                jmp asm_common
.ab09						z_asm_ldy:
.ab09						xt_asm_ldy_h:
.ab09		a9 a0		lda #$a0	                lda #$A0
.ab0b		4c 76 ac	jmp $ac76	                jmp asm_common
.ab0e						z_asm_ldy_h:
.ab0e						xt_asm_ldy_x:
.ab0e		a9 bc		lda #$bc	                lda #$BC
.ab10		4c 76 ac	jmp $ac76	                jmp asm_common
.ab13						z_asm_ldy_x:
.ab13						xt_asm_ldy_z:
.ab13		a9 a4		lda #$a4	                lda #$A4
.ab15		4c 76 ac	jmp $ac76	                jmp asm_common
.ab18						z_asm_ldy_z:
.ab18						xt_asm_ldy_zx:
.ab18		a9 b4		lda #$b4	                lda #$B4
.ab1a		4c 76 ac	jmp $ac76	                jmp asm_common
.ab1d						z_asm_ldy_zx:
.ab1d						xt_asm_lsr:
.ab1d		a9 4e		lda #$4e	                lda #$4E
.ab1f		4c 76 ac	jmp $ac76	                jmp asm_common
.ab22						z_asm_lsr:
.ab22						xt_asm_lsr_a:
.ab22		a9 4a		lda #$4a	                lda #$4A
.ab24		4c 76 ac	jmp $ac76	                jmp asm_common
.ab27						z_asm_lsr_a:
.ab27						xt_asm_lsr_x:
.ab27		a9 5e		lda #$5e	                lda #$5E
.ab29		4c 76 ac	jmp $ac76	                jmp asm_common
.ab2c						z_asm_lsr_x:
.ab2c						xt_asm_lsr_z:
.ab2c		a9 46		lda #$46	                lda #$46
.ab2e		4c 76 ac	jmp $ac76	                jmp asm_common
.ab31						z_asm_lsr_z:
.ab31						xt_asm_lsr_zx:
.ab31		a9 56		lda #$56	                lda #$56
.ab33		4c 76 ac	jmp $ac76	                jmp asm_common
.ab36						z_asm_lsr_zx:
.ab36						xt_asm_nop:
.ab36		a9 ea		lda #$ea	                lda #$EA
.ab38		4c 76 ac	jmp $ac76	                jmp asm_common
.ab3b						z_asm_nop:
.ab3b						xt_asm_ora:
.ab3b		a9 0d		lda #$0d	                lda #$0D
.ab3d		4c 76 ac	jmp $ac76	                jmp asm_common
.ab40						z_asm_ora:
.ab40						xt_asm_ora_h:
.ab40		a9 09		lda #$09	                lda #$09
.ab42		4c 76 ac	jmp $ac76	                jmp asm_common
.ab45						z_asm_ora_h:
.ab45						xt_asm_ora_x:
.ab45		a9 1d		lda #$1d	                lda #$1D
.ab47		4c 76 ac	jmp $ac76	                jmp asm_common
.ab4a						z_asm_ora_x:
.ab4a						xt_asm_ora_y:
.ab4a		a9 19		lda #$19	                lda #$19
.ab4c		4c 76 ac	jmp $ac76	                jmp asm_common
.ab4f						z_asm_ora_y:
.ab4f						xt_asm_ora_z:
.ab4f		a9 05		lda #$05	                lda #$05
.ab51		4c 76 ac	jmp $ac76	                jmp asm_common
.ab54						z_asm_ora_z:
.ab54						xt_asm_ora_zi:
.ab54		a9 12		lda #$12	                lda #$12
.ab56		a0 02		ldy #$02	                ldy #2
.ab58		4c 76 ac	jmp $ac76	                jmp asm_common
.ab5b						z_asm_ora_zi:
.ab5b						xt_asm_ora_ziy:
.ab5b		a9 11		lda #$11	                lda #$11
.ab5d		4c 76 ac	jmp $ac76	                jmp asm_common
.ab60						z_asm_ora_ziy:
.ab60						xt_asm_ora_zx:
.ab60		a9 15		lda #$15	                lda #$15
.ab62		4c 76 ac	jmp $ac76	                jmp asm_common
.ab65						z_asm_ora_zx:
.ab65						xt_asm_ora_zxi:
.ab65		a9 01		lda #$01	                lda #$01
.ab67		4c 76 ac	jmp $ac76	                jmp asm_common
.ab6a						z_asm_ora_zxi:
.ab6a						xt_asm_pha:
.ab6a		a9 48		lda #$48	                lda #$48
.ab6c		4c 76 ac	jmp $ac76	                jmp asm_common
.ab6f						z_asm_pha:
.ab6f						xt_asm_php:
.ab6f		a9 08		lda #$08	                lda #$08
.ab71		4c 76 ac	jmp $ac76	                jmp asm_common
.ab74						z_asm_php:
.ab74						xt_asm_phx:
.ab74		a9 da		lda #$da	                lda #$DA
.ab76		4c 76 ac	jmp $ac76	                jmp asm_common
.ab79						z_asm_phx:
.ab79						xt_asm_phy:
.ab79		a9 5a		lda #$5a	                lda #$5A
.ab7b		4c 76 ac	jmp $ac76	                jmp asm_common
.ab7e						z_asm_phy:
.ab7e						xt_asm_pla:
.ab7e		a9 68		lda #$68	                lda #$68
.ab80		4c 76 ac	jmp $ac76	                jmp asm_common
.ab83						z_asm_pla:
.ab83						xt_asm_plp:
.ab83		a9 28		lda #$28	                lda #$28
.ab85		4c 76 ac	jmp $ac76	                jmp asm_common
.ab88						z_asm_plp:
.ab88						xt_asm_plx:
.ab88		a9 fa		lda #$fa	                lda #$FA
.ab8a		4c 76 ac	jmp $ac76	                jmp asm_common
.ab8d						z_asm_plx:
.ab8d						xt_asm_ply:
.ab8d		a9 7a		lda #$7a	                lda #$7A
.ab8f		4c 76 ac	jmp $ac76	                jmp asm_common
.ab92						z_asm_ply:
.ab92						xt_asm_rol:
.ab92		a9 2e		lda #$2e	                lda #$2E
.ab94		4c 76 ac	jmp $ac76	                jmp asm_common
.ab97						z_asm_rol:
.ab97						xt_asm_rol_a:
.ab97		a9 2a		lda #$2a	                lda #$2A
.ab99		4c 76 ac	jmp $ac76	                jmp asm_common
.ab9c						z_asm_rol_a:
.ab9c						xt_asm_rol_x:
.ab9c		a9 3e		lda #$3e	                lda #$3E
.ab9e		4c 76 ac	jmp $ac76	                jmp asm_common
.aba1						z_asm_rol_x:
.aba1						xt_asm_rol_z:
.aba1		a9 26		lda #$26	                lda #$26
.aba3		4c 76 ac	jmp $ac76	                jmp asm_common
.aba6						z_asm_rol_z:
.aba6						xt_asm_rol_zx:
.aba6		a9 36		lda #$36	                lda #$36
.aba8		4c 76 ac	jmp $ac76	                jmp asm_common
.abab						z_asm_rol_zx:
.abab						xt_asm_ror:
.abab		a9 6e		lda #$6e	                lda #$6E
.abad		4c 76 ac	jmp $ac76	                jmp asm_common
.abb0						z_asm_ror:
.abb0						xt_asm_ror_a:
.abb0		a9 6a		lda #$6a	                lda #$6A
.abb2		4c 76 ac	jmp $ac76	                jmp asm_common
.abb5						z_asm_ror_a:
.abb5						xt_asm_ror_x:
.abb5		a9 7e		lda #$7e	                lda #$7E
.abb7		4c 76 ac	jmp $ac76	                jmp asm_common
.abba						z_asm_ror_x:
.abba						xt_asm_ror_z:
.abba		a9 66		lda #$66	                lda #$66
.abbc		4c 76 ac	jmp $ac76	                jmp asm_common
.abbf						z_asm_ror_z:
.abbf						xt_asm_ror_zx:
.abbf		a9 76		lda #$76	                lda #$76
.abc1		4c 76 ac	jmp $ac76	                jmp asm_common
.abc4						z_asm_ror_zx:
.abc4						xt_asm_rti:
.abc4		a9 40		lda #$40	                lda #$40
.abc6		4c 76 ac	jmp $ac76	                jmp asm_common
.abc9						z_asm_rti:
.abc9						xt_asm_rts:
.abc9		a9 60		lda #$60	                lda #$60
.abcb		4c 76 ac	jmp $ac76	                jmp asm_common
.abce						z_asm_rts:
.abce						xt_asm_sbc:
.abce		a9 ed		lda #$ed	                lda #$ED
.abd0		4c 76 ac	jmp $ac76	                jmp asm_common
.abd3						z_asm_sbc:
.abd3						xt_asm_sbc_h:
.abd3		a9 e9		lda #$e9	                lda #$E9
.abd5		4c 76 ac	jmp $ac76	                jmp asm_common
.abd8						z_asm_sbc_h:
.abd8						xt_asm_sbc_x:
.abd8		a9 fd		lda #$fd	                lda #$FD
.abda		4c 76 ac	jmp $ac76	                jmp asm_common
.abdd						z_asm_sbc_x:
.abdd						xt_asm_sbc_y:
.abdd		a9 f9		lda #$f9	                lda #$F9
.abdf		4c 76 ac	jmp $ac76	                jmp asm_common
.abe2						z_asm_sbc_y:
.abe2						xt_asm_sbc_z:
.abe2		a9 e5		lda #$e5	                lda #$E5
.abe4		4c 76 ac	jmp $ac76	                jmp asm_common
.abe7						z_asm_sbc_z:
.abe7						xt_asm_sbc_zi:
.abe7		a9 f2		lda #$f2	                lda #$F2
.abe9		4c 76 ac	jmp $ac76	                jmp asm_common
.abec						z_asm_sbc_zi:
.abec						xt_asm_sbc_ziy:
.abec		a9 f1		lda #$f1	                lda #$F1
.abee		4c 76 ac	jmp $ac76	                jmp asm_common
.abf1						z_asm_sbc_ziy:
.abf1						xt_asm_sbc_zx:
.abf1		a9 f5		lda #$f5	                lda #$F5
.abf3		4c 76 ac	jmp $ac76	                jmp asm_common
.abf6						z_asm_sbc_zx:
.abf6						xt_asm_sbc_zxi:
.abf6		a9 e1		lda #$e1	                lda #$E1
.abf8		80 7c		bra $ac76	                bra asm_common  ; <-- limit for BRA instead of JMP
.abfa						z_asm_sbc_zxi:
.abfa						xt_asm_sec:
.abfa		a9 38		lda #$38	                lda #$38
.abfc		80 78		bra $ac76	                bra asm_common
.abfe						z_asm_sec:
.abfe						xt_asm_sed:
.abfe		a9 f8		lda #$f8	                lda #$F8
.ac00		80 74		bra $ac76	                bra asm_common
.ac02						z_asm_sed:
.ac02						xt_asm_sei:
.ac02		a9 78		lda #$78	                lda #$78
.ac04		80 70		bra $ac76	                bra asm_common
.ac06						z_asm_sei:
.ac06						xt_asm_sta:
.ac06		a9 8d		lda #$8d	                lda #$8D
.ac08		80 6c		bra $ac76	                bra asm_common
.ac0a						z_asm_sta:
.ac0a						xt_asm_sta_x:
.ac0a		a9 9d		lda #$9d	                lda #$9D
.ac0c		80 68		bra $ac76	                bra asm_common
.ac0e						z_asm_sta_x:
.ac0e						xt_asm_sta_y:
.ac0e		a9 99		lda #$99	                lda #$99
.ac10		80 64		bra $ac76	                bra asm_common
.ac12						z_asm_sta_y:
.ac12						xt_asm_sta_z:
.ac12		a9 85		lda #$85	                lda #$85
.ac14		80 60		bra $ac76	                bra asm_common
.ac16						z_asm_sta_z:
.ac16						xt_asm_sta_zi:
.ac16		a9 92		lda #$92	                lda #$92
.ac18		80 5c		bra $ac76	                bra asm_common
.ac1a						z_asm_sta_zi:
.ac1a						xt_asm_sta_ziy:
.ac1a		a9 91		lda #$91	                lda #$91
.ac1c		80 58		bra $ac76	                bra asm_common
.ac1e						z_asm_sta_ziy:
.ac1e						xt_asm_sta_zx:
.ac1e		a9 95		lda #$95	                lda #$95
.ac20		80 54		bra $ac76	                bra asm_common
.ac22						z_asm_sta_zx:
.ac22						xt_asm_sta_zxi:
.ac22		a9 81		lda #$81	                lda #$81
.ac24		80 50		bra $ac76	                bra asm_common
.ac26						z_asm_sta_zxi:
.ac26						xt_asm_stx:
.ac26		a9 8e		lda #$8e	                lda #$8E
.ac28		80 4c		bra $ac76	                bra asm_common
.ac2a						z_asm_stx:
.ac2a						xt_asm_stx_z:
.ac2a		a9 86		lda #$86	                lda #$86
.ac2c		80 48		bra $ac76	                bra asm_common
.ac2e						z_asm_stx_z:
.ac2e						xt_asm_stx_zy:
.ac2e		a9 96		lda #$96	                lda #$96
.ac30		80 44		bra $ac76	                bra asm_common
.ac32						z_asm_stx_zy:
.ac32						xt_asm_sty:
.ac32		a9 8c		lda #$8c	                lda #$8C
.ac34		80 40		bra $ac76	                bra asm_common
.ac36						z_asm_sty:
.ac36						xt_asm_sty_z:
.ac36		a9 84		lda #$84	                lda #$84
.ac38		80 3c		bra $ac76	                bra asm_common
.ac3a						z_asm_sty_z:
.ac3a						xt_asm_sty_zx:
.ac3a		a9 94		lda #$94	                lda #$94
.ac3c		80 38		bra $ac76	                bra asm_common
.ac3e						z_asm_sty_zx:
.ac3e						xt_asm_stz:
.ac3e		a9 9c		lda #$9c	                lda #$9C
.ac40		80 34		bra $ac76	                bra asm_common
.ac42						z_asm_stz:
.ac42						xt_asm_stz_x:
.ac42		a9 9e		lda #$9e	                lda #$9E
.ac44		80 30		bra $ac76	                bra asm_common
.ac46						z_asm_stz_x:
.ac46						xt_asm_stz_z:
.ac46		a9 64		lda #$64	                lda #$64
.ac48		80 2c		bra $ac76	                bra asm_common
.ac4a						z_asm_stz_z:
.ac4a						xt_asm_stz_zx:
.ac4a		a9 74		lda #$74	                lda #$74
.ac4c		80 28		bra $ac76	                bra asm_common
.ac4e						z_asm_stz_zx:
.ac4e						xt_asm_tax:
.ac4e		a9 aa		lda #$aa	                lda #$AA
.ac50		80 24		bra $ac76	                bra asm_common
.ac52						z_asm_tax:
.ac52						xt_asm_tay:
.ac52		a9 a8		lda #$a8	                lda #$A8
.ac54		80 20		bra $ac76	                bra asm_common
.ac56						z_asm_tay:
.ac56						xt_asm_trb:
.ac56		a9 1c		lda #$1c	                lda #$1C
.ac58		80 1c		bra $ac76	                bra asm_common
.ac5a						z_asm_trb:
.ac5a						xt_asm_trb_z:
.ac5a		a9 14		lda #$14	                lda #$14
.ac5c		80 18		bra $ac76	                bra asm_common
.ac5e						z_asm_trb_z:
.ac5e						xt_asm_tsb:
.ac5e		a9 0c		lda #$0c	                lda #$0C
.ac60		80 14		bra $ac76	                bra asm_common
.ac62						z_asm_tsb:
.ac62						xt_asm_tsb_z:
.ac62		a9 04		lda #$04	                lda #$04
.ac64		80 10		bra $ac76	                bra asm_common
.ac66						z_asm_tsb_z:
.ac66						xt_asm_tsx:
.ac66		a9 ba		lda #$ba	                lda #$BA
.ac68		80 0c		bra $ac76	                bra asm_common
.ac6a						z_asm_tsx:
.ac6a						xt_asm_txa:
.ac6a		a9 8a		lda #$8a	                lda #$8A
.ac6c		80 08		bra $ac76	                bra asm_common
.ac6e						z_asm_txa:
.ac6e						xt_asm_txs:
.ac6e		a9 9a		lda #$9a	                lda #$9A
.ac70		80 04		bra $ac76	                bra asm_common
.ac72						z_asm_txs:
.ac72						xt_asm_tya:
.ac72		a9 98		lda #$98	                lda #$98
.ac74		80 00		bra $ac76	                bra asm_common
.ac76						z_asm_tya:
.ac76						asm_common:
.ac76		a8		tay		                tay
.ac77		20 ed d7	jsr $d7ed	                jsr cmpl_a
.ac7a		a9 43		lda #$43	                lda #<oc_index_table
.ac7c		85 26		sta $26		                sta tmp2
.ac7e		a9 af		lda #$af	                lda #>oc_index_table
.ac80		85 27		sta $27		                sta tmp2+1
.ac82		98		tya		                tya             ; retrieve opcode
.ac83		0a		asl a		                asl             ; times two for offset
.ac84		90 02		bcc $ac88	                bcc +
.ac86		e6 27		inc $27		                inc tmp2+1
.ac88						+
.ac88		a8		tay		                tay             ; use Y as the index
.ac89		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac8b		85 28		sta $28		                sta tmp3
.ac8d		c8		iny		                iny
.ac8e		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac90		85 29		sta $29		                sta tmp3+1
.ac92		b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac94		2a		rol a		                rol
.ac95		2a		rol a		                rol
.ac96		2a		rol a		                rol             ; Three times because we go through Carry
.ac97		29 03		and #$03	                and #%00000011
.ac99		a8		tay		                tay
.ac9a		88		dey		                dey
.ac9b		f0 12		beq $acaf	                beq _done
.ac9d		20 47 d9	jsr $d947	                jsr underflow_1
.aca0		b5 00		lda $00,x	                lda 0,x
.aca2		20 ed d7	jsr $d7ed	                jsr cmpl_a      ; does not use Y
.aca5		88		dey		                dey
.aca6		f0 05		beq $acad	                beq _done_drop
.aca8		b5 01		lda $01,x	                lda 1,x
.acaa		20 ed d7	jsr $d7ed	                jsr cmpl_a      ; Fall through to _done_drop
.acad						_done_drop:
.acad		e8		inx		                inx
.acae		e8		inx		                inx             ; Fall through to _done
.acaf						_done:
.acaf		60		rts		                rts             ; Returns to original caller
.acb0						xt_asm_push_a:
.acb0		a0 00		ldy #$00	                ldy #0
.acb2						_loop:
.acb2		b9 c0 ac	lda $acc0,y	                lda asm_push_a_data,y
.acb5		c9 ff		cmp #$ff	                cmp #$FF
.acb7		f0 06		beq $acbf	                beq _done
.acb9		20 ed d7	jsr $d7ed	                jsr cmpl_a      ; does not change Y
.acbc		c8		iny		                iny
.acbd		80 f3		bra $acb2	                bra _loop
.acbf						_done:
.acbf						z_asm_push_a:
.acbf		60		rts		                rts
.acc0						asm_push_a_data:
>acc0		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acc6		ff				        .byte $FF               ; terminator
.acc7						xt_asm_back_jump:
.acc7						z_asm_back_jump:
.acc7		60		rts		                rts
.acc8						xt_asm_back_branch:
.acc8		20 35 91	jsr $9135	                jsr xt_here             ; ( addr-l addr-h )
.accb		20 29 95	jsr $9529	                jsr xt_minus            ; ( offset )
.acce		3a		dec a		                dea
.accf		3a		dec a		                dea
.acd0						z_asm_back_branch:
.acd0		60		rts		                rts
.acd1						assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acd1						disassembler:
.acd1		20 3a 89	jsr $893a	                jsr xt_cr       ; ( addr u )
.acd4						_byte_loop:
.acd4		20 6c 98	jsr $986c	                jsr xt_over     ; ( addr u addr )
.acd7		20 d8 a4	jsr $a4d8	                jsr xt_u_dot    ; ( addr u )
.acda		20 c8 a0	jsr $a0c8	                jsr xt_space
.acdd		a9 43		lda #$43	                lda #<oc_index_table
.acdf		85 26		sta $26		                sta tmp2
.ace1		a9 af		lda #$af	                lda #>oc_index_table
.ace3		85 27		sta $27		                sta tmp2+1
.ace5		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.ace7		85 36		sta $36		                sta scratch     ; Save opcode
.ace9		0a		asl a		                asl             ; multiply by two for offset
.acea		90 02		bcc $acee	                bcc +
.acec		e6 27		inc $27		                inc tmp2+1      ; we're on second page
.acee						+
.acee		a8		tay		                tay             ; use Y as the index
.acef		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.acf1		85 28		sta $28		                sta tmp3
.acf3		48		pha		                pha
.acf4		c8		iny		                iny
.acf5		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acf7		85 29		sta $29		                sta tmp3+1
.acf9		48		pha		                pha
.acfa		b2 28		lda ($28)	                lda (tmp3)
.acfc		a8		tay		                tay                     ; save copy of lengths byte
.acfd		10 3c		bpl $ad3b	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.acff		20 52 a7	jsr $a752	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ad02		f6 04		inc $04,x	                inc 4,x
.ad04		d0 02		bne $ad08	                bne +
.ad06		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ad08						+
.ad08		b5 02		lda $02,x	                lda 2,x
.ad0a		d0 02		bne $ad0e	                bne +
.ad0c		d6 03		dec $03,x	                dec 3,x
.ad0e						+
.ad0e		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.ad10		a1 04		lda ($04,x)	                lda (4,x)
.ad12		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.ad14		85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.ad16		98		tya		                tya                     ; retrieve copy of lengths byte
.ad17		2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad18		10 14		bpl $ad2e	                bpl _print_operand
.ad1a		f6 04		inc $04,x	                inc 4,x
.ad1c		d0 02		bne $ad20	                bne +
.ad1e		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad20						+
.ad20		b5 02		lda $02,x	                lda 2,x
.ad22		d0 02		bne $ad26	                bne +
.ad24		d6 03		dec $03,x	                dec 3,x
.ad26						+
.ad26		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad28		a1 04		lda ($04,x)	                lda (4,x)
.ad2a		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad2c		85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad2e						_print_operand:
.ad2e		ca		dex		                dex
.ad2f		ca		dex		                dex
.ad30		a9 05		lda #$05	                lda #5
.ad32		95 00		sta $00,x	                sta 0,x
.ad34		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad36		20 e4 a4	jsr $a4e4	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad39		80 0b		bra $ad46	                bra _print_mnemonic
.ad3b						_no_operand:
.ad3b		ca		dex		                dex
.ad3c		ca		dex		                dex
.ad3d		a9 05		lda #$05	                lda #5
.ad3f		95 00		sta $00,x	                sta 0,x
.ad41		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad43		20 ce a0	jsr $a0ce	                jsr xt_spaces           ; ( addr u )
.ad46						_print_mnemonic:
.ad46		20 c8 a0	jsr $a0c8	                jsr xt_space
.ad49		ca		dex		                dex
.ad4a		ca		dex		                dex                     ; ( addr u ? )
.ad4b		68		pla		                pla                     ; MSB
.ad4c		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad4e		68		pla		                pla                     ; LSB
.ad4f		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad51		20 26 89	jsr $8926	                jsr xt_count            ; ( addr u addr-o u-o )
.ad54		74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad56		b5 00		lda $00,x	                lda 0,x
.ad58		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad5a		95 00		sta $00,x	                sta 0,x
.ad5c		20 ad a4	jsr $a4ad	                jsr xt_type             ; ( addr u )
.ad5f		a5 36		lda $36		                lda scratch
.ad61		c9 20		cmp #$20	                cmp #$20
.ad63		d0 52		bne $adb7	                bne _not_jsr
.ad65		ca		dex		                dex
.ad66		ca		dex		                dex
.ad67		a9 05		lda #$05	                lda #5
.ad69		95 00		sta $00,x	                sta 0,x
.ad6b		74 01		stz $01,x	                stz 1,x
.ad6d		20 ce a0	jsr $a0ce	                jsr xt_spaces
.ad70		a0 14		ldy #$14	                ldy #(_end_handlers - _special_handlers - 4)
.ad72		b9 9f ad	lda $ad9f,y	_check_handler: lda _special_handlers,y
.ad75		c5 37		cmp $37		                cmp scratch+1
.ad77		d0 07		bne $ad80	                bne _next_handler
.ad79		b9 a0 ad	lda $ada0,y	                lda _special_handlers+1,y
.ad7c		c5 38		cmp $38		                cmp scratch+2
.ad7e		f0 0c		beq $ad8c	                beq _run_handler
.ad80		88		dey		_next_handler:  dey
.ad81		88		dey		                dey
.ad82		88		dey		                dey
.ad83		88		dey		                dey
.ad84		10 ec		bpl $ad72	                bpl _check_handler
.ad86						_not_special:
.ad86		20 f3 ae	jsr $aef3	                jsr disasm_jsr
.ad89		4c 21 ae	jmp $ae21	                jmp _printing_done
.ad8c						_run_handler:
.ad8c		b9 a1 ad	lda $ada1,y	                lda _special_handlers+2,y
.ad8f		85 39		sta $39		                sta scratch+3
.ad91		b9 a2 ad	lda $ada2,y	                lda _special_handlers+3,y
.ad94		85 3a		sta $3a		                sta scratch+4
.ad96		20 9c ad	jsr $ad9c	                jsr _dispatch_handler
.ad99		4c 21 ae	jmp $ae21	                jmp _printing_done
.ad9c						_dispatch_handler:
.ad9c		6c 39 00	jmp ($0039)	                jmp (scratch+3)
.ad9f						_special_handlers:
>ad9f		59 93 b5 ae			    .word literal_runtime,      disasm_literal
>ada3		78 93 d3 ae			    .word byte_runtime,         disasm_byte_literal
>ada7		53 a0 67 ae			    .word sliteral_runtime,     disasm_sliteral
>adab		d5 91 9e ae			    .word zero_branch_runtime,  disasm_0branch
>adaf		9e 8d a3 ae			    .word branch_runtime,       disasm_branch
>adb3		73 8b aa ae			    .word do_runtime,           disasm_do
.adb7						_end_handlers:
.adb7						_not_jsr:
.adb7		c9 4c		cmp #$4c	                cmp #$4C
.adb9		d0 2c		bne $ade7	                bne _not_jmp
.adbb		a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.adbd		85 39		sta $39		                sta scratch+3
.adbf		a5 38		lda $38		                lda scratch+2
.adc1		85 3a		sta $3a		                sta scratch+4
.adc3		b2 39		lda ($39)	                lda (scratch+3)
.adc5		c9 20		cmp #$20	                cmp #$20 ; check for JSR
.adc7		d0 58		bne $ae21	                bne _printing_done
.adc9		e6 39		inc $39		                inc scratch+3
.adcb		d0 02		bne $adcf	                bne +
.adcd		e6 3a		inc $3a		                inc scratch+4
.adcf						+
.adcf		b2 39		lda ($39)	                lda (scratch+3)
.add1		c9 53		cmp #$53	                cmp #<sliteral_runtime
.add3		d0 4c		bne $ae21	                bne _printing_done
.add5		e6 39		inc $39		                inc scratch+3
.add7		d0 02		bne $addb	                bne +
.add9		e6 3a		inc $3a		                inc scratch+4
.addb						+
.addb		b2 39		lda ($39)	                lda (scratch+3)
.addd		c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.addf		d0 40		bne $ae21	                bne _printing_done
.ade1		20 3d ae	jsr $ae3d	                jsr disasm_sliteral_jump
.ade4		4c 21 ae	jmp $ae21	                jmp _printing_done
.ade7						_not_jmp:
.ade7		c9 80		cmp #$80	                cmp #$80            ; is it bra?
.ade9		f0 06		beq $adf1	                beq _is_rel
.adeb		29 1f		and #$1f	                and #$1f
.aded		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.adef		d0 30		bne $ae21	                bne _printing_done
.adf1						_is_rel:
.adf1		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.adf3		ca		dex		                dex
.adf4		ca		dex		                dex
.adf5		74 01		stz $01,x	                stz 1,x
.adf7		a5 37		lda $37		                lda scratch+1
.adf9		95 00		sta $00,x	                sta 0,x
.adfb		10 04		bpl $ae01	                bpl +
.adfd		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.adff		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.ae01		38		sec		+               sec                 ; start counting from address after opcode
.ae02		75 04		adc $04,x	                adc 4,x
.ae04		95 00		sta $00,x	                sta 0,x
.ae06		b5 01		lda $01,x	                lda 1,x
.ae08		75 05		adc $05,x	                adc 5,x
.ae0a		95 01		sta $01,x	                sta 1,x
.ae0c		5a		phy		                phy                 ; save the direction indicator
.ae0d		ca		dex		                dex
.ae0e		ca		dex		                dex
.ae0f		a9 09		lda #$09	                lda #9
.ae11		95 00		sta $00,x	                sta 0,x
.ae13		74 01		stz $01,x	                stz 1,x
.ae15		20 e4 a4	jsr $a4e4	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.ae18		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.ae1a		20 b9 8d	jsr $8db9	                jsr emit_a
.ae1d		68		pla		                pla
.ae1e		20 b9 8d	jsr $8db9	                jsr emit_a
.ae21						_printing_done:
.ae21		20 3a 89	jsr $893a	                jsr xt_cr
.ae24		f6 02		inc $02,x	                inc 2,x
.ae26		d0 02		bne $ae2a	                bne +
.ae28		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae2a						+
.ae2a		20 ea 97	jsr $97ea	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae2d		b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae2f		15 01		ora $01,x	                ora 1,x
.ae31		f0 07		beq $ae3a	                beq _done
.ae33		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae35		30 03		bmi $ae3a	                bmi _done
.ae37		4c d4 ac	jmp $acd4	                jmp _byte_loop          ; out of range for BRA
.ae3a						_done:
.ae3a		4c 5a a3	jmp $a35a	                jmp xt_two_drop         ; JSR/RTS
.ae3d						disasm_sliteral_jump:
.ae3d		20 58 a1	jsr $a158	                jsr xt_swap
.ae40		ca		dex		                dex
.ae41		ca		dex		                dex
.ae42		a5 37		lda $37		                lda scratch+1
.ae44		95 00		sta $00,x	                sta 0,x
.ae46		a5 38		lda $38		                lda scratch+2
.ae48		95 01		sta $01,x	                sta 1,x
.ae4a		20 58 a1	jsr $a158	                jsr xt_swap
.ae4d		20 29 95	jsr $9529	                jsr xt_minus
.ae50		20 ea 97	jsr $97ea	                jsr xt_one_minus
.ae53		20 29 95	jsr $9529	                jsr xt_minus
.ae56		ca		dex		                dex
.ae57		ca		dex		                dex
.ae58		a5 37		lda $37		                lda scratch+1
.ae5a		95 00		sta $00,x	                sta 0,x
.ae5c		a5 38		lda $38		                lda scratch+2
.ae5e		95 01		sta $01,x	                sta 1,x
.ae60		20 ea 97	jsr $97ea	                jsr xt_one_minus
.ae63		20 58 a1	jsr $a158	                jsr xt_swap ; ( new_addr new_n )
.ae66		60		rts		                rts
.ae67						disasm_sliteral:
.ae67		a9 53		lda #$53	                lda #'S'
.ae69		20 b9 8d	jsr $8db9	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae6c		a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.ae6e		20 83 d9	jsr $d983	                jsr print_string_no_lf
.ae71		20 58 a1	jsr $a158	                jsr xt_swap             ; switch to (u addr)
.ae74		20 f6 97	jsr $97f6	                jsr xt_one_plus
.ae77		20 72 8d	jsr $8d72	                jsr xt_dup
.ae7a		20 43 8f	jsr $8f43	                jsr xt_fetch
.ae7d		20 d8 a4	jsr $a4d8	                jsr xt_u_dot            ; Print the address of the string
.ae80		20 51 a3	jsr $a351	                jsr xt_two
.ae83		20 bc 99	jsr $99bc	                jsr xt_plus
.ae86		20 72 8d	jsr $8d72	                jsr xt_dup
.ae89		20 3b 9a	jsr $9a3b	                jsr xt_question         ; Print the length of the string
.ae8c		20 f6 97	jsr $97f6	                jsr xt_one_plus
.ae8f		20 58 a1	jsr $a158	                jsr xt_swap            ; ( addr+4 u )
.ae92		ca		dex		                dex
.ae93		ca		dex		                dex
.ae94		a9 04		lda #$04	                lda #4
.ae96		95 00		sta $00,x	                sta 0,x
.ae98		74 01		stz $01,x	                stz 1,x
.ae9a		20 29 95	jsr $9529	                jsr xt_minus            ; ( addr+4 u-4 )
.ae9d		60		rts		                rts
.ae9e						disasm_0branch:
.ae9e		a9 30		lda #$30	                lda #'0'
.aea0		20 b9 8d	jsr $8db9	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.aea3						disasm_branch:
.aea3		a9 0e		lda #$0e	                lda #str_disasm_bra
.aea5		20 83 d9	jsr $d983	                jsr print_string_no_lf ; "BRANCH "
.aea8		80 10		bra $aeba	                bra disasm_print_literal
.aeaa						disasm_do:
.aeaa		a9 44		lda #$44	                lda #'D'
.aeac		20 b9 8d	jsr $8db9	                jsr emit_a
.aeaf		a9 4f		lda #$4f	                lda #'O'
.aeb1		20 b9 8d	jsr $8db9	                jsr emit_a
.aeb4		60		rts		                rts
.aeb5						disasm_literal:
.aeb5		a9 0c		lda #$0c	                lda #str_disasm_lit
.aeb7		20 83 d9	jsr $d983	                jsr print_string_no_lf ; "LITERAL "
.aeba						disasm_print_literal:
.aeba		20 58 a1	jsr $a158	                jsr xt_swap ; switch to (u addr)
.aebd		20 f6 97	jsr $97f6	                jsr xt_one_plus
.aec0		20 72 8d	jsr $8d72	                jsr xt_dup
.aec3		20 3b 9a	jsr $9a3b	                jsr xt_question ; Print the value at the address
.aec6		20 f6 97	jsr $97f6	                jsr xt_one_plus
.aec9		20 58 a1	jsr $a158	                jsr xt_swap ; (addr+2 u)
.aecc		20 ea 97	jsr $97ea	                jsr xt_one_minus
.aecf		20 ea 97	jsr $97ea	                jsr xt_one_minus ; (addr+2 u-2)
.aed2		60		rts		                rts
.aed3						disasm_byte_literal:
.aed3		a9 42		lda #$42	                lda #'B'
.aed5		20 b9 8d	jsr $8db9	                jsr emit_a ; Add leading B
.aed8		a9 0c		lda #$0c	                lda #str_disasm_lit
.aeda		20 83 d9	jsr $d983	                jsr print_string_no_lf ; "LITERAL "
.aedd		20 58 a1	jsr $a158	                jsr xt_swap ; switch to (u addr)
.aee0		20 f6 97	jsr $97f6	                jsr xt_one_plus
.aee3		20 72 8d	jsr $8d72	                jsr xt_dup
.aee6		20 d1 85	jsr $85d1	                jsr xt_c_fetch  ; Print byte at the address
.aee9		20 f9 8b	jsr $8bf9	                jsr xt_dot
.aeec		20 58 a1	jsr $a158	                jsr xt_swap ; (addr+1 u)
.aeef		20 ea 97	jsr $97ea	                jsr xt_one_minus ; (addr+1 u-1)
.aef2		60		rts		                rts
.aef3						disasm_jsr:
.aef3		ca		dex		                dex
.aef4		ca		dex		                dex
.aef5		a5 37		lda $37		                lda scratch+1
.aef7		95 00		sta $00,x	                sta 0,x
.aef9		a5 38		lda $38		                lda scratch+2
.aefb		95 01		sta $01,x	                sta 1,x
.aefd		20 39 92	jsr $9239	                jsr xt_int_to_name
.af00		b5 00		lda $00,x	                lda 0,x
.af02		15 01		ora $01,x	                ora 1,x
.af04		f0 07		beq $af0d	                beq _disasm_no_nt
.af06		20 d7 95	jsr $95d7	                jsr xt_name_to_string
.af09		20 ad a4	jsr $a4ad	                jsr xt_type
.af0c		60		rts		                rts
.af0d						_disasm_no_nt:
.af0d		20 f1 8c	jsr $8cf1	                jsr xt_drop ; the 0 indicating no name token
.af10		ca		dex		                dex
.af11		ca		dex		                dex
.af12		a5 37		lda $37		                lda scratch+1
.af14		95 00		sta $00,x	                sta 0,x
.af16		a5 38		lda $38		                lda scratch+2
.af18		95 01		sta $01,x	                sta 1,x
.af1a		ca		dex		                dex
.af1b		ca		dex		                dex
.af1c		a9 47		lda #$47	                lda #<underflow_1
.af1e		95 00		sta $00,x	                sta 0,x
.af20		a9 d9		lda #$d9	                lda #>underflow_1
.af22		95 01		sta $01,x	                sta 1,x
.af24		20 61 d8	jsr $d861	                jsr compare_16bit
.af27		f0 02		beq $af2b	                beq _disasm_jsr_uflow_check_upper
.af29		b0 14		bcs $af3f	                bcs _disasm_jsr_unknown
.af2b						_disasm_jsr_uflow_check_upper:
.af2b		a9 56		lda #$56	                lda #<underflow_4
.af2d		95 00		sta $00,x	                sta 0,x
.af2f		a9 d9		lda #$d9	                lda #>underflow_4
.af31		95 01		sta $01,x	                sta 1,x
.af33		20 61 d8	jsr $d861	                jsr compare_16bit
.af36		f0 02		beq $af3a	                beq _disasm_jsr_soc
.af38		90 05		bcc $af3f	                bcc _disasm_jsr_unknown
.af3a						_disasm_jsr_soc:
.af3a		a9 0d		lda #$0d	                lda #str_disasm_sdc
.af3c		20 83 d9	jsr $d983	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.af3f						_disasm_jsr_unknown:
.af3f		20 5a a3	jsr $a35a	                jsr xt_two_drop
.af42		60		rts		                rts
.af43						oc_index_table:
>af43		43 b1 47 b1 db b5 db b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>af4b		4f b1 55 b1 5b b1 db b5
>af53		61 b1 65 b1 6b b1 db b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af5b		71 b1 75 b1 79 b1 7d b1
>af63		82 b1 86 b1 8e b1 db b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af6b		95 b1 9b b1 a2 b1 a9 b1
>af73		b0 b1 b4 b1 ba b1 db b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af7b		c0 b1 c4 b1 db b5 ca b1
>af83		d0 b1 d4 b1 db b5 db b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af8b		dc b1 e2 b1 e8 b1 ee b1
>af93		f5 b1 f9 b1 ff b1 db b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af9b		05 b2 09 b2 0e b2 12 b2
>afa3		17 b2 1b b2 23 b2 db b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>afab		2a b2 32 b2 39 b2 40 b2
>afb3		47 b2 4b b2 51 b2 db b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>afbb		57 b2 5d b2 63 b2 7d b1
>afc3		6e b2 72 b2 db b5 db b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>afcb		db b5 7a b2 80 b2 86 b2
>afd3		8d b2 91 b2 97 b2 db b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>afdb		9d b2 a1 b2 a5 b2 a9 b2
>afe3		ae b2 b2 b2 ba b2 db b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>afeb		db b5 c1 b2 c8 b2 cf b2
>aff3		d6 b2 da b2 e0 b2 db b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>affb		db b5 db b5 ea b2 f0 b2
>b003		f5 b2 f9 b2 db b5 db b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b00b		01 b3 07 b3 0d b3 13 b3
>b013		1a b3 1e b3 24 b3 db b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>b01b		2a b3 30 b3 34 b3 38 b3
>b023		3d b3 41 b3 49 b3 db b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b02b		50 b3 57 b3 5e b3 65 b3
>b033		6c b3 70 b3 76 b3 db b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>b03b		7a b3 81 b3 87 b3 8d b3
>b043		92 b3 96 b3 db b5 db b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b04b		9e b3 a4 b3 aa b3 db b5
>b053		b0 b3 b4 b3 ba b3 db b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b05b		be b3 c2 b3 c6 b3 ca b3
>b063		cf b3 d3 b3 db b3 db b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b06b		e2 b3 e9 b3 f0 b3 f7 b3
>b073		fe b3 02 b4 08 b4 db b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b07b		0c b4 10 b4 16 b4 1c b4
>b083		21 b4 27 b4 2f b4 db b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b08b		35 b4 3b b4 41 b4 47 b4
>b093		4e b4 52 b4 58 b4 db b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b09b		5c b4 60 b4 64 b4 68 b4
>b0a3		6d b4 71 b4 79 b4 db b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b0ab		80 b4 87 b4 8e b4 95 b4
>b0b3		9c b4 a0 b4 a6 b4 db b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b0bb		aa b4 b0 b4 b6 b4 bc b4
>b0c3		c1 b4 c7 b4 db b5 db b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b0cb		cf b4 d5 b4 db b4 e1 b4
>b0d3		e8 b4 ec b4 f2 b4 db b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b0db		f6 b4 fa b4 fe b4 02 b5
>b0e3		07 b5 0b b5 13 b5 db b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b0eb		db b5 1a b5 21 b5 28 b5
>b0f3		2f b5 33 b5 39 b5 db b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0fb		db b5 3d b5 43 b5 49 b5
>b103		4e b5 54 b5 db b5 db b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b10b		5c b5 62 b5 68 b5 6e b5
>b113		75 b5 79 b5 7f b5 db b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b11b		83 b5 87 b5 8b b5 8f b5
>b123		94 b5 98 b5 a0 b5 db b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b12b		db b5 a7 b5 ae b5 b5 b5
>b133		bc b5 c0 b5 c6 b5 db b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b13b		db b5 ca b5 d0 b5 d6 b5
.b143						oc_table:
>b143		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b147		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b14f		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b155		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b15b		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b161		43 70 68 70				oc08:	.text 1*64+3, "php"
>b165		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b16b		45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b171		c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b175		c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b179		c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b17d		c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b182		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b186		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b18e		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b195		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b19b		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b1a2		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b1a9		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b1b0		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b1b4		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b1ba		45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b1c0		c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b1c4		c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b1ca		c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b1d0		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b1d4		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b1dc		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b1e2		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b1e8		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b1ee		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1f5		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1f9		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1ff		45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b205		c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b209		c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b20e		c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b212		c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b217		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b21b		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b223		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b22a		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b232		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b239		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b240		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b247		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b24b		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b251		45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b257		c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b25d		c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b263		c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b269		c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b26e		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b272		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b27a		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b280		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b286		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b28d		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b291		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b297		45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b29d		c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b2a1		c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b2a5		c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b2a9		c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b2ae		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b2b2		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b2ba		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b2c1		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b2c8		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b2cf		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b2d6		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b2da		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b2e0		43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b2e4		c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b2ea		c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2f0		c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2f5		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2f9		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b301		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b307		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b30d		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b313		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b31a		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b31e		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b324		45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b32a		c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b330		c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b334		c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b338		c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b33d		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b341		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b349		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b350		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b357		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b35e		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b365		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b36c		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b370		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b376		43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b37a		c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b381		c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b387		c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b38d		c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b392		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b396		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b39e		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b3a4		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b3aa		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b3b0		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b3b4		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b3ba		43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b3be		c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b3c2		c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b3c6		c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b3ca		c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b3cf		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b3d3		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b3db		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b3e2		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b3e9		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3f0		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3f7		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3fe		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b402		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b408		43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b40c		c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b410		c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b416		c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b41c		c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b421		85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b427		87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b42f		85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b435		85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b43b		85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b441		85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b447		86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b44e		43 74 61 79				oca8:	.text 1*64+3, "tay"
>b452		85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b458		43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b45c		c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b460		c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b464		c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b468		c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b46d		83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b471		87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b479		86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b480		86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b487		86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b48e		86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b495		86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b49c		43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b4a0		c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b4a6		43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b4aa		c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b4b0		c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b4b6		c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b4bc		c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b4c1		85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b4c7		87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b4cf		85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b4d5		85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b4db		85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b4e1		86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b4e8		43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b4ec		85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4f2		43 64 65 78				occa:	.text 1*64+3, "dex"
>b4f6		c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4fa		c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4fe		c3 64 65 63				occe:	.text 3*64+3, "dec"
>b502		c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b507		83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b50b		87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b513		86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b51a		86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b521		86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b528		86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b52f		43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b533		c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b539		43 70 68 78				ocda:	.text 1*64+3, "phx"
>b53d		c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b543		c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b549		c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b54e		85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b554		87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b55c		85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b562		85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b568		85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b56e		86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b575		43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b579		85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b57f		43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b583		c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b587		c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b58b		c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b58f		c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b594		83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b598		87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b5a0		86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b5a7		86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b5ae		86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b5b5		86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b5bc		43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b5c0		c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b5c6		43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b5ca		c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b5d0		c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b5d6		c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b5db		01 3f					oc__:	.text 1, "?"
.b5dd						disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=$002e						ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=$0030						ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=$0032						ed_flags = editor3  ; Flags used by ed, where
.b5dd						ed6502:
.b5dd		a5 18		lda $18		                lda base
.b5df		85 33		sta $33		                sta editor3+1
.b5e1		a9 0a		lda #$0a	                lda #10
.b5e3		85 18		sta $18		                sta base
.b5e5		64 2e		stz $2e		                stz ed_head
.b5e7		64 2f		stz $2f		                stz ed_head+1
.b5e9		64 30		stz $30		                stz ed_cur
.b5eb		64 31		stz $31		                stz ed_cur+1
.b5ed		64 32		stz $32		                stz ed_flags
.b5ef		20 52 a7	jsr $a752	                jsr xt_zero
.b5f2		20 52 a7	jsr $a752	                jsr xt_zero             ; ( addr-t u-t )
.b5f5		20 3a 89	jsr $893a	                jsr xt_cr
.b5f8						ed_input_loop:
.b5f8		a9 81		lda #$81	                lda #%10000001
.b5fa		14 32		trb $32		                trb ed_flags
.b5fc		20 d7 ba	jsr $bad7	                jsr ed_get_input
.b5ff		a5 0a		lda $0a		                lda ciblen
.b601		d0 1f		bne $b622	                bne _command_mode
.b603		ca		dex		                dex
.b604		ca		dex		                dex                     ; ( addr-t u-t ? )
.b605		a5 30		lda $30		                lda ed_cur
.b607		95 00		sta $00,x	                sta 0,x
.b609		a5 31		lda $31		                lda ed_cur+1
.b60b		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b60d		a9 80		lda #$80	                lda #%10000000
.b60f		04 32		tsb $32		                tsb ed_flags
.b611		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b614		20 f3 ba	jsr $baf3	                jsr ed_is_valid_line
.b617		b0 03		bcs $b61c	                bcs +
.b619		4c c7 ba	jmp $bac7	                jmp ed_error_1drop
.b61c						+
.b61c		20 52 a7	jsr $a752	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b61f		4c ed b6	jmp $b6ed	                jmp _line_number_only_from_external
.b622						_command_mode:
.b622		20 52 a7	jsr $a752	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b625		20 52 a7	jsr $a752	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b628						_prefix_dot:
.b628		b2 08		lda ($08)	                lda (cib)
.b62a		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b62c		d0 3a		bne $b668	                bne _prefix_dollar
.b62e		20 e8 ba	jsr $bae8	                jsr ed_have_text
.b631		a5 30		lda $30		                lda ed_cur
.b633		95 02		sta $02,x	                sta 2,x
.b635		a5 31		lda $31		                lda ed_cur+1
.b637		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b639		a9 80		lda #$80	                lda #%10000000
.b63b		04 32		tsb $32		                tsb ed_flags
.b63d		a5 0a		lda $0a		                lda ciblen
.b63f		3a		dec a		                dea                     ; sets Z if A was 1
.b640		d0 03		bne $b645	                bne +
.b642		4c ed b6	jmp $b6ed	                jmp _line_number_only_from_external
.b645						+
.b645		ca		dex		                dex
.b646		ca		dex		                dex
.b647		ca		dex		                dex
.b648		ca		dex		                dex
.b649		a5 08		lda $08		                lda cib
.b64b		95 02		sta $02,x	                sta 2,x
.b64d		a5 09		lda $09		                lda cib+1
.b64f		95 03		sta $03,x	                sta 3,x
.b651		a5 0a		lda $0a		                lda ciblen
.b653		95 00		sta $00,x	                sta 0,x
.b655		a5 0b		lda $0b		                lda ciblen+1
.b657		95 01		sta $01,x	                sta 1,x
.b659		20 ea 97	jsr $97ea	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b65c		20 58 a1	jsr $a158	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b65f		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b662		20 58 a1	jsr $a158	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b665		4c 45 b7	jmp $b745	                jmp _check_for_para2
.b668						_prefix_dollar:
.b668		b2 08		lda ($08)	                lda (cib)
.b66a		c9 24		cmp #$24	                cmp #'$'
.b66c		d0 1c		bne $b68a	                bne _prefix_percent
.b66e		20 e8 ba	jsr $bae8	                jsr ed_have_text
.b671		e8		inx		                inx
.b672		e8		inx		                inx                     ; ( addr-t u-t 0 )
.b673		20 15 bb	jsr $bb15	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b676		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b679		a9 80		lda #$80	                lda #%10000000
.b67b		04 32		tsb $32		                tsb ed_flags
.b67d		a5 0a		lda $0a		                lda ciblen
.b67f		3a		dec a		                dea                     ; sets Z if A was 1
.b680		d0 03		bne $b685	                bne +
.b682		4c ed b6	jmp $b6ed	                jmp _line_number_only_from_external
.b685						+
.b685		a0 01		ldy #$01	                ldy #01
.b687		4c c1 b7	jmp $b7c1	                jmp _check_command
.b68a						_prefix_percent:
.b68a		b2 08		lda ($08)	                lda (cib)
.b68c		c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b68e		f0 04		beq $b694	                beq _whole_text
.b690		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b692		d0 17		bne $b6ab	                bne _prefix_semicolon
.b694						_whole_text:
.b694		20 e8 ba	jsr $bae8	                jsr ed_have_text
.b697		a9 01		lda #$01	                lda #01
.b699		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b69b		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b69d						_semicolon_entry:
.b69d		e8		inx		                inx
.b69e		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b69f		20 15 bb	jsr $bb15	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b6a2		a9 80		lda #$80	                lda #%10000000
.b6a4		04 32		tsb $32		                tsb ed_flags
.b6a6		a0 01		ldy #$01	                ldy #01
.b6a8		4c c1 b7	jmp $b7c1	                jmp _check_command
.b6ab						_prefix_semicolon:
.b6ab		b2 08		lda ($08)	                lda (cib)
.b6ad		c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b6af		d0 0d		bne $b6be	                bne _prefix_number
.b6b1		20 e8 ba	jsr $bae8	                jsr ed_have_text
.b6b4		a5 30		lda $30		                lda ed_cur
.b6b6		95 02		sta $02,x	                sta 2,x
.b6b8		a5 31		lda $31		                lda ed_cur+1
.b6ba		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b6bc		80 df		bra $b69d	                bra _semicolon_entry
.b6be						_prefix_number:
.b6be		20 52 a7	jsr $a752	                jsr xt_zero
.b6c1		20 52 a7	jsr $a752	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b6c4		ca		dex		                dex
.b6c5		ca		dex		                dex
.b6c6		ca		dex		                dex
.b6c7		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b6c8		a5 08		lda $08		                lda cib
.b6ca		95 02		sta $02,x	                sta 2,x
.b6cc		a5 09		lda $09		                lda cib+1
.b6ce		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b6d0		a5 0a		lda $0a		                lda ciblen
.b6d2		95 00		sta $00,x	                sta 0,x
.b6d4		a5 0b		lda $0b		                lda ciblen+1
.b6d6		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b6d8		20 67 a2	jsr $a267	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b6db		b5 00		lda $00,x	                lda 0,x
.b6dd		15 01		ora $01,x	                ora 1,x
.b6df		d0 24		bne $b705	                bne _have_unconverted_chars
.b6e1		e8		inx		                inx
.b6e2		e8		inx		                inx
.b6e3		e8		inx		                inx
.b6e4		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b6e5		20 57 8a	jsr $8a57	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b6e8		20 47 96	jsr $9647	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b6eb		e8		inx		                inx
.b6ec		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b6ed						_line_number_only_from_external:
.b6ed		20 58 a1	jsr $a158	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6f0		20 f3 ba	jsr $baf3	                jsr ed_is_valid_line
.b6f3		b0 03		bcs $b6f8	                bcs +
.b6f5		4c c5 ba	jmp $bac5	                jmp ed_error_2drop
.b6f8						+
.b6f8		20 58 a1	jsr $a158	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6fb		20 82 bb	jsr $bb82	                jsr ed_para1_to_cur
.b6fe		a9 80		lda #$80	                lda #%10000000
.b700		04 32		tsb $32		                tsb ed_flags
.b702		4c a0 b9	jmp $b9a0	                jmp ed_cmd_p_from_external
.b705						_have_unconverted_chars:
.b705		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b708		ca		dex		                dex
.b709		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b70a		a5 0a		lda $0a		                lda ciblen
.b70c		95 00		sta $00,x	                sta 0,x
.b70e		a5 0b		lda $0b		                lda ciblen+1
.b710		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b712		20 91 8e	jsr $8e91	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b715		b5 00		lda $00,x	                lda 0,x
.b717		15 01		ora $01,x	                ora 1,x
.b719		f0 0e		beq $b729	                beq _no_command_yet
.b71b		8a		txa		                txa
.b71c		18		clc		                clc
.b71d		69 0a		adc #$0a	                adc #10
.b71f		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b720		a9 80		lda #$80	                lda #%10000000
.b722		14 32		trb $32		                trb ed_flags
.b724		a0 00		ldy #$00	                ldy #00
.b726		4c c1 b7	jmp $b7c1	                jmp _check_command
.b729						_no_command_yet:
.b729		e8		inx		                inx
.b72a		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b72b		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b72e		20 47 96	jsr $9647	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b731		20 57 8a	jsr $8a57	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b734		b5 00		lda $00,x	                lda 0,x                 ; LSB
.b736		95 06		sta $06,x	                sta 6,x
.b738		b5 01		lda $01,x	                lda 1,x                 ; MSB
.b73a		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b73c		e8		inx		                inx
.b73d		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b73e		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b741		a9 80		lda #$80	                lda #%10000000
.b743		04 32		tsb $32		                tsb ed_flags
.b745						_check_for_para2:
.b745		a1 02		lda ($02,x)	                lda (2,x)
.b747		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b749		f0 0d		beq $b758	                beq _got_comma
.b74b		38		sec		                sec
.b74c		a5 0a		lda $0a		                lda ciblen
.b74e		f5 00		sbc $00,x	                sbc 0,x
.b750		a8		tay		                tay
.b751		e8		inx		                inx
.b752		e8		inx		                inx
.b753		e8		inx		                inx
.b754		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b755		4c c1 b7	jmp $b7c1	                jmp _check_command
.b758						_got_comma:
.b758		f6 02		inc $02,x	                inc 2,x
.b75a		d0 02		bne $b75e	                bne +
.b75c		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b75e						+
.b75e		b5 01		lda $01,x	                lda 1,x
.b760		f0 02		beq $b764	                beq +
.b762		d6 01		dec $01,x	                dec 1,x
.b764						+
.b764		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b766		a1 02		lda ($02,x)	                lda (2,x)
.b768		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b76a		d0 14		bne $b780	                bne _para2_not_dollar
.b76c		38		sec		                sec
.b76d		a5 0a		lda $0a		                lda ciblen
.b76f		f5 02		sbc $02,x	                sbc 2,x
.b771		a8		tay		                tay
.b772		c8		iny		                iny
.b773		5a		phy		                phy
.b774		8a		txa		                txa
.b775		18		clc		                clc
.b776		69 06		adc #$06	                adc #06
.b778		aa		tax		                tax                     ; ( addr-t u-t para1 )
.b779		20 15 bb	jsr $bb15	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b77c		7a		ply		                ply
.b77d		4c c1 b7	jmp $b7c1	                jmp _check_command
.b780						_para2_not_dollar:
.b780		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b783		20 52 a7	jsr $a752	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b786		20 52 a7	jsr $a752	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b789		20 30 9b	jsr $9b30	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b78c		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b78f		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b792		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b795		20 67 a2	jsr $a267	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b798		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b79b		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b79e		20 91 8e	jsr $8e91	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b7a1		b5 00		lda $00,x	                lda 0,x
.b7a3		15 01		ora $01,x	                ora 1,x
.b7a5		f0 08		beq $b7af	                beq _second_number
.b7a7		8a		txa		                txa
.b7a8		18		clc		                clc
.b7a9		69 0c		adc #$0c	                adc #12
.b7ab		aa		tax		                tax                     ; back to ( addr-t u-t )
.b7ac		4c c9 ba	jmp $bac9	                jmp ed_error
.b7af						_second_number:
.b7af		e8		inx		                inx
.b7b0		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b7b1		38		sec		                sec
.b7b2		a5 0a		lda $0a		                lda ciblen
.b7b4		f5 00		sbc $00,x	                sbc 0,x
.b7b6		48		pha		                pha
.b7b7		20 5a a3	jsr $a35a	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b7ba		20 57 8a	jsr $8a57	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b7bd		20 1b 96	jsr $961b	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b7c0		7a		ply		                ply
.b7c1						_check_command:
.b7c1		24 32		bit $32		                bit ed_flags
.b7c3		30 08		bmi $b7cd	                bmi _check_command_have_arg
.b7c5		a5 30		lda $30		                lda ed_cur
.b7c7		95 02		sta $02,x	                sta 2,x
.b7c9		a5 31		lda $31		                lda ed_cur+1
.b7cb		95 03		sta $03,x	                sta 3,x
.b7cd						_check_command_have_arg:
.b7cd		b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b7cf		85 24		sta $24		                sta tmp1
.b7d1		da		phx		                phx
.b7d2		a2 00		ldx #$00	                ldx #00
.b7d4						_cmd_loop:
.b7d4		bd ad bb	lda $bbad,x	                lda ed_cmd_list,x
.b7d7		f0 07		beq $b7e0	                beq _illegal_command    ; zero marks end of list
.b7d9		c5 24		cmp $24		                cmp tmp1
.b7db		f0 07		beq $b7e4	                beq _found_cmd
.b7dd		e8		inx		                inx
.b7de		80 f4		bra $b7d4	                bra _cmd_loop
.b7e0						_illegal_command:
.b7e0		fa		plx		                plx
.b7e1		4c c5 ba	jmp $bac5	                jmp ed_error_2drop
.b7e4						_found_cmd:
.b7e4		8a		txa		                txa
.b7e5		0a		asl a		                asl
.b7e6		aa		tax		                tax                     ; X * 2 for table
.b7e7		7c b8 bb	jmp ($bbb8,x)	                jmp (ed_cmd_table,x)
.b7ea						ed_next_command:
.b7ea		e8		inx		                inx
.b7eb		e8		inx		                inx
.b7ec		e8		inx		                inx
.b7ed		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b7ee						_next_command_empty:
.b7ee		4c f8 b5	jmp $b5f8	                jmp ed_input_loop
.b7f1						ed_all_done:
.b7f1		64 0a		stz $0a		                stz ciblen
.b7f3		64 0b		stz $0b		                stz ciblen+1
.b7f5		20 5a a3	jsr $a35a	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7f8		a5 33		lda $33		                lda editor3+1
.b7fa		85 18		sta $18		                sta base
.b7fc		60		rts		                rts
.b7fd						ed_cmd_a:
.b7fd		fa		plx		                plx
.b7fe		e8		inx		                inx
.b7ff		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b800						ed_entry_cmd_i:
.b800						ed_cmd_a_have_para:
.b800		20 4b bb	jsr $bb4b	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b803		20 3a 89	jsr $893a	                jsr xt_cr
.b806						_next_string_loop:
.b806		20 d7 ba	jsr $bad7	                jsr ed_get_input
.b809		b2 08		lda ($08)	                lda (cib)
.b80b		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b80d		d0 16		bne $b825	                bne _add_line
.b80f		a4 0a		ldy $0a		                ldy ciblen
.b811		c0 01		cpy #$01	                cpy #01
.b813		d0 10		bne $b825	                bne _add_line
.b815		a4 0b		ldy $0b		                ldy ciblen+1
.b817		d0 0c		bne $b825	                bne _add_line
.b819		e8		inx		                inx
.b81a		e8		inx		                inx
.b81b		a9 40		lda #$40	                lda #%01000000
.b81d		04 32		tsb $32		                tsb ed_flags
.b81f		20 3a 89	jsr $893a	                jsr xt_cr
.b822		4c f8 b5	jmp $b5f8	                jmp ed_input_loop
.b825						_add_line:
.b825		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b828		20 35 91	jsr $9135	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b82b		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b82e		20 43 8f	jsr $8f43	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b831		20 34 87	jsr $8734	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b834		20 37 a3	jsr $a337	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b837		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b83a		20 37 a1	jsr $a137	                jsr xt_store            ; ! ( addr-t u-t here )
.b83d		20 35 91	jsr $9135	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b840		a5 00		lda $00		                lda cp
.b842		18		clc		                clc
.b843		69 04		adc #$04	                adc #04
.b845		85 00		sta $00		                sta cp
.b847		90 02		bcc $b84b	                bcc +
.b849		e6 01		inc $01		                inc cp+1
.b84b						+
.b84b		e6 30		inc $30		                inc ed_cur
.b84d		d0 02		bne $b851	                bne +
.b84f		e6 31		inc $31		                inc ed_cur+1
.b851						+
.b851		20 35 91	jsr $9135	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b854		20 72 8d	jsr $8d72	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b857		ca		dex		                dex
.b858		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b859		a5 08		lda $08		                lda cib
.b85b		95 00		sta $00,x	                sta 0,x
.b85d		a5 09		lda $09		                lda cib+1
.b85f		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b861		20 58 a1	jsr $a158	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b864		ca		dex		                dex
.b865		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b866		a5 0a		lda $0a		                lda ciblen
.b868		95 00		sta $00,x	                sta 0,x
.b86a		a5 0b		lda $0b		                lda ciblen+1
.b86c		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b86e		20 9b 95	jsr $959b	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b871		18		clc		                clc
.b872		a5 00		lda $00		                lda cp
.b874		65 0a		adc $0a		                adc ciblen
.b876		85 00		sta $00		                sta cp
.b878		90 06		bcc $b880	                bcc +
.b87a		a5 01		lda $01		                lda cp+1
.b87c		65 0b		adc $0b		                adc ciblen+1
.b87e		85 01		sta $01		                sta cp+1
.b880						+
.b880		20 6c 98	jsr $986c	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b883		20 37 a1	jsr $a137	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b886		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+
.b889		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b88c		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b88f		a5 0a		lda $0a		                lda ciblen
.b891		95 02		sta $02,x	                sta 2,x
.b893		a5 0b		lda $0b		                lda ciblen+1
.b895		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b897		20 37 a1	jsr $a137	                jsr xt_store            ; ! ( addr-t u-t here )
.b89a		20 3a 89	jsr $893a	                jsr xt_cr
.b89d		4c 06 b8	jmp $b806	                jmp _next_string_loop
.b8a0						ed_cmd_d:
.b8a0		fa		plx		                plx
.b8a1		20 e8 ba	jsr $bae8	                jsr ed_have_text
.b8a4		20 3d bb	jsr $bb3d	                jsr ed_no_line_zero
.b8a7		b5 00		lda $00,x	                lda 0,x
.b8a9		15 01		ora $01,x	                ora 1,x
.b8ab		d0 08		bne $b8b5	                bne +
.b8ad		20 6c 98	jsr $986c	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b8b0		20 f2 b8	jsr $b8f2	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b8b3		80 33		bra $b8e8	                bra _cmd_d_done
.b8b5						+
.b8b5		20 f3 ba	jsr $baf3	                jsr ed_is_valid_line      ; result is in C flag
.b8b8		b0 03		bcs $b8bd	                bcs _cmd_d_loop
.b8ba		4c c5 ba	jmp $bac5	                jmp ed_error_2drop
.b8bd						_cmd_d_loop:
.b8bd		20 62 a3	jsr $a362	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b8c0		20 20 91	jsr $9120	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b8c3		b5 00		lda $00,x	                lda 0,x
.b8c5		15 01		ora $01,x	                ora 1,x
.b8c7		d0 0d		bne $b8d6	                bne _cmd_d_done_with_flag
.b8c9		e8		inx		                inx
.b8ca		e8		inx		                inx                     ; Get rid of the flag from >
.b8cb		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b8ce		20 f2 b8	jsr $b8f2	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b8d1		20 ea 97	jsr $97ea	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b8d4		80 e7		bra $b8bd	                bra _cmd_d_loop
.b8d6						_cmd_d_done_with_flag:
.b8d6		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b8d7		e8		inx		                inx
.b8d8		b5 02		lda $02,x	                lda 2,x
.b8da		d0 02		bne $b8de	                bne +
.b8dc		d6 03		dec $03,x	                dec 3,x
.b8de						+
.b8de		d6 02		dec $02,x	                dec 2,x
.b8e0		b5 02		lda $02,x	                lda 2,x
.b8e2		85 30		sta $30		                sta ed_cur
.b8e4		b5 03		lda $03,x	                lda 3,x
.b8e6		85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b8e8						_cmd_d_done:
.b8e8		a9 40		lda #$40	                lda #%01000000
.b8ea		04 32		tsb $32		                tsb ed_flags
.b8ec		20 3a 89	jsr $893a	                jsr xt_cr
.b8ef		4c ea b7	jmp $b7ea	                jmp ed_next_command
.b8f2						_cmd_d_common:
.b8f2		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8f5		20 4b bb	jsr $bb4b	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8f8		20 43 8f	jsr $8f43	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8fb		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8fe		20 ea 97	jsr $97ea	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b901		20 4b bb	jsr $bb4b	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b904		20 37 a1	jsr $a137	                jsr xt_store            ; ! ( addr-t u-t )
.b907		60		rts		                rts
.b908						ed_cmd_equ:
.b908		fa		plx		                plx
.b909		a5 2e		lda $2e		                lda ed_head
.b90b		05 2f		ora $2f		                ora ed_head+1
.b90d		d0 08		bne $b917	                bne _cmd_equ_have_text
.b90f		ca		dex		                dex
.b910		ca		dex		                dex
.b911		74 00		stz $00,x	                stz 0,x
.b913		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b915		80 21		bra $b938	                bra _cmd_equ_done
.b917						_cmd_equ_have_text:
.b917		20 3d bb	jsr $bb3d	                jsr ed_no_line_zero
.b91a		24 32		bit $32		                bit ed_flags
.b91c		30 0c		bmi $b92a	                bmi _cmd_equ_have_para
.b91e		ca		dex		                dex
.b91f		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b920		a5 30		lda $30		                lda ed_cur
.b922		95 00		sta $00,x	                sta 0,x
.b924		a5 31		lda $31		                lda ed_cur+1
.b926		95 01		sta $01,x	                sta 1,x
.b928		80 0e		bra $b938	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b92a						_cmd_equ_have_para:
.b92a		b5 00		lda $00,x	                lda 0,x
.b92c		15 01		ora $01,x	                ora 1,x
.b92e		d0 05		bne $b935	                bne _cmd_equ_two_paras
.b930		20 6c 98	jsr $986c	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b933		80 03		bra $b938	                bra _cmd_equ_done
.b935						_cmd_equ_two_paras:
.b935		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b938						_cmd_equ_done:
.b938		20 3a 89	jsr $893a	                jsr xt_cr               ; number goes on new line
.b93b		20 d8 a4	jsr $a4d8	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b93e		20 3a 89	jsr $893a	                jsr xt_cr
.b941		4c ea b7	jmp $b7ea	                jmp ed_next_command
.b944						ed_cmd_f:
.b944		fa		plx		                plx
.b945		24 32		bit $32		                bit ed_flags
.b947		30 17		bmi $b960	                bmi _cmd_f_have_para
.b949		20 3a 89	jsr $893a	                jsr xt_cr
.b94c		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b94f		20 30 9b	jsr $9b30	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b952		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b955		20 d8 a4	jsr $a4d8	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b958		20 47 96	jsr $9647	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b95b		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b95e		80 11		bra $b971	                bra _cmd_f_done
.b960						_cmd_f_have_para:
.b960		20 6c 98	jsr $986c	                jsr xt_over
.b963		20 3a 89	jsr $893a	                jsr xt_cr
.b966		20 d8 a4	jsr $a4d8	                jsr xt_u_dot
.b969		b5 02		lda $02,x	                lda 2,x
.b96b		95 06		sta $06,x	                sta 6,x
.b96d		b5 03		lda $03,x	                lda 3,x
.b96f		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b971						_cmd_f_done:
.b971		20 3a 89	jsr $893a	                jsr xt_cr
.b974		4c ea b7	jmp $b7ea	                jmp ed_next_command
.b977						ed_cmd_i:
.b977		fa		plx		                plx
.b978		e8		inx		                inx
.b979		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b97a		24 32		bit $32		                bit ed_flags
.b97c		30 08		bmi $b986	                bmi _cmd_i_have_para
.b97e		a5 30		lda $30		                lda ed_cur
.b980		95 00		sta $00,x	                sta 0,x
.b982		a5 31		lda $31		                lda ed_cur+1
.b984		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b986						_cmd_i_have_para:
.b986		b5 00		lda $00,x	                lda 0,x
.b988		15 01		ora $01,x	                ora 1,x
.b98a		f0 09		beq $b995	                beq _cmd_i_done
.b98c		20 ea 97	jsr $97ea	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b98f		20 52 a7	jsr $a752	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b992		20 f1 94	jsr $94f1	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b995						_cmd_i_done:
.b995		4c 00 b8	jmp $b800	                jmp ed_entry_cmd_i
.b998						ed_cmd_n:
.b998		fa		plx		                plx
.b999		a9 01		lda #$01	                lda #%00000001
.b99b		04 32		tsb $32		                tsb ed_flags
.b99d		80 05		bra $b9a4	                bra ed_cmd_p_entry_for_cmd_n
.b99f						ed_cmd_p:
.b99f		fa		plx		                plx
.b9a0						ed_cmd_p_from_external:
.b9a0		a9 01		lda #$01	                lda #%00000001
.b9a2		14 32		trb $32		                trb ed_flags
.b9a4						ed_cmd_p_entry_for_cmd_n:
.b9a4		20 e8 ba	jsr $bae8	                jsr ed_have_text
.b9a7		20 3d bb	jsr $bb3d	                jsr ed_no_line_zero
.b9aa		20 3a 89	jsr $893a	                jsr xt_cr
.b9ad		b5 00		lda $00,x	                lda 0,x
.b9af		15 01		ora $01,x	                ora 1,x
.b9b1		d0 10		bne $b9c3	                bne _cmd_p_loop
.b9b3		b5 02		lda $02,x	                lda 2,x
.b9b5		85 30		sta $30		                sta ed_cur
.b9b7		b5 03		lda $03,x	                lda 3,x
.b9b9		85 31		sta $31		                sta ed_cur+1
.b9bb		20 6c 98	jsr $986c	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b9be		20 ec b9	jsr $b9ec	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9c1		80 26		bra $b9e9	                bra _cmd_p_all_done
.b9c3						_cmd_p_loop:
.b9c3		20 62 a3	jsr $a362	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b9c6		20 20 91	jsr $9120	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b9c9		b5 00		lda $00,x	                lda 0,x
.b9cb		15 01		ora $01,x	                ora 1,x
.b9cd		d0 10		bne $b9df	                bne _cmd_p_done
.b9cf		e8		inx		                inx
.b9d0		e8		inx		                inx                     ; Get rid of the flag from >
.b9d1		20 6c 98	jsr $986c	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b9d4		20 ec b9	jsr $b9ec	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9d7		f6 02		inc $02,x	                inc 2,x
.b9d9		d0 02		bne $b9dd	                bne +
.b9db		f6 03		inc $03,x	                inc 3,x
.b9dd						+
.b9dd		80 e4		bra $b9c3	                bra _cmd_p_loop
.b9df						_cmd_p_done:
.b9df		e8		inx		                inx
.b9e0		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b9e1		b5 00		lda $00,x	                lda 0,x
.b9e3		85 30		sta $30		                sta ed_cur
.b9e5		b5 01		lda $01,x	                lda 1,x
.b9e7		85 31		sta $31		                sta ed_cur+1
.b9e9						_cmd_p_all_done:
.b9e9		4c ea b7	jmp $b7ea	                jmp ed_next_command
.b9ec						_cmd_p_common:
.b9ec		a5 32		lda $32		                lda ed_flags
.b9ee		4a		lsr a		                lsr                     ; bit 0 now in carry
.b9ef		90 0b		bcc $b9fc	                bcc _cmd_p_common_no_num
.b9f1		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9f4		20 d8 a4	jsr $a4d8	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9f7		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9f9		20 b9 8d	jsr $8db9	                jsr emit_a
.b9fc						_cmd_p_common_no_num:
.b9fc		20 4b bb	jsr $bb4b	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9ff		20 8b bb	jsr $bb8b	                jsr ed_print_addr
.ba02		60		rts		                rts
.ba03						ed_cmd_q:
.ba03		fa		plx		                plx
.ba04		24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.ba06		50 03		bvc $ba0b	                bvc +
.ba08		4c c5 ba	jmp $bac5	                jmp ed_error_2drop
.ba0b						+
.ba0b		4c f1 b7	jmp $b7f1	                jmp ed_all_done            ; can't fall thru because of PLX
.ba0e						ed_cmd_qq:
.ba0e		fa		plx		                plx
.ba0f		4c f1 b7	jmp $b7f1	                jmp ed_all_done
.ba12						ed_cmd_w:
.ba12		fa		plx		                plx
.ba13		20 e8 ba	jsr $bae8	                jsr ed_have_text
.ba16		24 32		bit $32		                bit ed_flags
.ba18		30 13		bmi $ba2d	                bmi _cmd_w_have_para
.ba1a		b5 06		lda $06,x	                lda 6,x
.ba1c		15 07		ora $07,x	                ora 7,x
.ba1e		d0 03		bne $ba23	                bne +
.ba20		4c c5 ba	jmp $bac5	                jmp ed_error_2drop
.ba23						+
.ba23		b5 06		lda $06,x	                lda 6,x
.ba25		95 02		sta $02,x	                sta 2,x
.ba27		b5 07		lda $07,x	                lda 7,x
.ba29		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.ba2b		80 08		bra $ba35	                bra _cmd_w_para_ready
.ba2d						_cmd_w_have_para:
.ba2d		b5 02		lda $02,x	                lda 2,x
.ba2f		95 06		sta $06,x	                sta 6,x
.ba31		b5 03		lda $03,x	                lda 3,x
.ba33		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ba35						_cmd_w_para_ready:
.ba35		a9 2e		lda #$2e	                lda #<ed_head
.ba37		95 00		sta $00,x	                sta 0,x
.ba39		a9 00		lda #$00	                lda #>ed_head
.ba3b		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ba3d		20 6c 98	jsr $986c	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ba40		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ba43						_cmd_w_loop:
.ba43		20 43 8f	jsr $8f43	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ba46		b5 00		lda $00,x	                lda 0,x
.ba48		15 01		ora $01,x	                ora 1,x
.ba4a		f0 55		beq $baa1	                beq _cmd_w_eol
.ba4c		20 62 a3	jsr $a362	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba4f		20 4c a4	jsr $a44c	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba52		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba55		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba58		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba5b		20 43 8f	jsr $8f43	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba5e		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba61		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba64		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba67		20 43 8f	jsr $8f43	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba6a		20 47 96	jsr $9647	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba6d		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba70		20 30 9b	jsr $9b30	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba73		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba76		20 1a a3	jsr $a31a	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba79		20 9b 95	jsr $959b	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba7c		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba7f		20 d2 a3	jsr $a3d2	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba82		20 47 96	jsr $9647	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba85		20 bc 99	jsr $99bc	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba88		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba8b		ca		dex		                dex
.ba8c		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba8d		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba8f		95 00		sta $00,x	                sta 0,x
.ba91		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba93		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba96		20 37 a1	jsr $a137	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba99		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba9c		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba9f		80 a2		bra $ba43	                bra _cmd_w_loop
.baa1						_cmd_w_eol:
.baa1		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.baa4		20 6b 9a	jsr $9a6b	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.baa7		20 29 95	jsr $9529	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.baaa		b5 00		lda $00,x	                lda 0,x
.baac		95 04		sta $04,x	                sta 4,x
.baae		b5 01		lda $01,x	                lda 1,x
.bab0		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.bab2		20 3a 89	jsr $893a	                jsr xt_cr
.bab5		20 72 8d	jsr $8d72	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.bab8		20 d8 a4	jsr $a4d8	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.babb		20 3a 89	jsr $893a	                jsr xt_cr
.babe		a9 40		lda #$40	                lda #%01000000
.bac0		14 32		trb $32		                trb ed_flags
.bac2		4c ea b7	jmp $b7ea	                jmp ed_next_command
.bac5						ed_error_2drop:
.bac5		e8		inx		                inx
.bac6		e8		inx		                inx                     ; drop through to _error_1drop
.bac7						ed_error_1drop:
.bac7		e8		inx		                inx
.bac8		e8		inx		                inx                     ; drop through to _error
.bac9						ed_error:
.bac9		20 3a 89	jsr $893a	                jsr xt_cr
.bacc		a9 3f		lda #$3f	                lda #'?'
.bace		20 b9 8d	jsr $8db9	                jsr emit_a
.bad1		20 3a 89	jsr $893a	                jsr xt_cr
.bad4		4c f8 b5	jmp $b5f8	                jmp ed_input_loop
.bad7						ed_get_input:
.bad7		20 d1 9a	jsr $9ad1	                jsr xt_refill           ;  ( addr-t u-t f )
.bada		b5 00		lda $00,x	                lda 0,x
.badc		15 01		ora $01,x	                ora 1,x
.bade		d0 05		bne $bae5	                bne +
.bae0		7a		ply		                ply
.bae1		7a		ply		                ply
.bae2		4c c7 ba	jmp $bac7	                jmp ed_error_1drop
.bae5						+
.bae5		e8		inx		                inx
.bae6		e8		inx		                inx
.bae7		60		rts		                rts
.bae8						ed_have_text:
.bae8		a5 2e		lda $2e		                lda ed_head
.baea		05 2f		ora $2f		                ora ed_head+1
.baec		d0 04		bne $baf2	                bne +
.baee		7a		ply		                ply
.baef		7a		ply		                ply
.baf0		80 d7		bra $bac9	                bra ed_error
.baf2						+
.baf2		60		rts		                rts
.baf3						ed_is_valid_line:
.baf3		38		sec		                sec                             ; default is legal line number
.baf4		b5 00		lda $00,x	                lda 0,x
.baf6		15 01		ora $01,x	                ora 1,x
.baf8		f0 19		beq $bb13	                beq _is_valid_line_nope_zero    ; ( n )
.bafa		20 72 8d	jsr $8d72	                jsr xt_dup                      ; DUP ( n n )
.bafd		20 15 bb	jsr $bb15	                jsr ed_last_line                  ; ( n n last )
.bb00		20 58 a1	jsr $a158	                jsr xt_swap                     ; SWAP ( n last n )
.bb03		20 29 93	jsr $9329	                jsr xt_less_than                ; < ( n f )
.bb06		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.bb08		15 01		ora $01,x	                ora 1,x
.bb0a		d0 05		bne $bb11	                bne _is_valid_line_too_small
.bb0c		e8		inx		                inx
.bb0d		e8		inx		                inx                     ; DROP flag ( n )
.bb0e		38		sec		                sec                     ; Who knows what's happened to C by now
.bb0f		80 03		bra $bb14	                bra _is_valid_line_done ; only one exit from this routine
.bb11						_is_valid_line_too_small:
.bb11		e8		inx		                inx
.bb12		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.bb13						_is_valid_line_nope_zero:
.bb13		18		clc		                clc                     ; drop through to _is_valid_line_done
.bb14						_is_valid_line_done:
.bb14		60		rts		                rts
.bb15						ed_last_line:
.bb15		64 24		stz $24		                stz tmp1
.bb17		64 25		stz $25		                stz tmp1+1
.bb19		ca		dex		                dex
.bb1a		ca		dex		                dex                     ; ( ? )
.bb1b		a9 2e		lda #$2e	                lda #<ed_head
.bb1d		95 00		sta $00,x	                sta 0,x
.bb1f		a9 00		lda #$00	                lda #>ed_head
.bb21		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.bb23						_last_line_loop:
.bb23		20 43 8f	jsr $8f43	                jsr xt_fetch            ; ( addr | 0 )
.bb26		b5 00		lda $00,x	                lda 0,x
.bb28		15 01		ora $01,x	                ora 1,x
.bb2a		f0 08		beq $bb34	                beq _last_line_done
.bb2c		e6 24		inc $24		                inc tmp1
.bb2e		d0 02		bne $bb32	                bne +
.bb30		e6 25		inc $25		                inc tmp1+1
.bb32						+
.bb32		80 ef		bra $bb23	                bra _last_line_loop
.bb34						_last_line_done:
.bb34		a5 24		lda $24		                lda tmp1
.bb36		95 00		sta $00,x	                sta 0,x
.bb38		a5 25		lda $25		                lda tmp1+1
.bb3a		95 01		sta $01,x	                sta 1,x                 ; ( u )
.bb3c		60		rts		                rts
.bb3d						ed_no_line_zero:
.bb3d		b5 02		lda $02,x	                lda 2,x
.bb3f		15 03		ora $03,x	                ora 3,x
.bb41		d0 07		bne $bb4a	                bne _no_line_zero_done
.bb43		24 32		bit $32		                bit ed_flags
.bb45		10 03		bpl $bb4a	                bpl _no_line_zero_done
.bb47		4c c5 ba	jmp $bac5	                jmp ed_error_2drop
.bb4a						_no_line_zero_done:
.bb4a		60		rts		                rts
.bb4b						ed_num_to_addr:
.bb4b		ca		dex		                dex
.bb4c		ca		dex		                dex                     ; ( u ? )
.bb4d		a9 2e		lda #$2e	                lda #<ed_head
.bb4f		95 00		sta $00,x	                sta 0,x
.bb51		a9 00		lda #$00	                lda #>ed_head
.bb53		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb55		b5 02		lda $02,x	                lda 2,x
.bb57		15 03		ora $03,x	                ora 3,x
.bb59		d0 05		bne $bb60	                bne _num_to_addr_loop
.bb5b		20 1b 96	jsr $961b	                jsr xt_nip              ; ( addr-h )
.bb5e		80 21		bra $bb81	                bra _num_to_addr_done
.bb60						_num_to_addr_loop:
.bb60		20 43 8f	jsr $8f43	                jsr xt_fetch            ; @ ( u addr1 )
.bb63		b5 00		lda $00,x	                lda 0,x
.bb65		15 01		ora $01,x	                ora 1,x
.bb67		d0 05		bne $bb6e	                bne +
.bb69		20 1b 96	jsr $961b	                jsr xt_nip              ; NIP ( addr1 )
.bb6c		80 13		bra $bb81	                bra _num_to_addr_done
.bb6e						+
.bb6e		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( addr1 u )
.bb71		20 ea 97	jsr $97ea	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb74		b5 00		lda $00,x	                lda 0,x
.bb76		15 01		ora $01,x	                ora 1,x
.bb78		f0 05		beq $bb7f	                beq _num_to_addr_finished
.bb7a		20 58 a1	jsr $a158	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb7d		80 e1		bra $bb60	                bra _num_to_addr_loop
.bb7f						_num_to_addr_finished:
.bb7f		e8		inx		                inx
.bb80		e8		inx		                inx                     ; ( addr )
.bb81						_num_to_addr_done:
.bb81		60		rts		                rts
.bb82						ed_para1_to_cur:
.bb82		b5 02		lda $02,x	                lda 2,x
.bb84		85 30		sta $30		                sta ed_cur
.bb86		b5 03		lda $03,x	                lda 3,x
.bb88		85 31		sta $31		                sta ed_cur+1
.bb8a		60		rts		                rts
.bb8b						ed_print_addr:
.bb8b		20 f6 97	jsr $97f6	                jsr xt_one_plus
.bb8e		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; ( addr+2 )
.bb91		20 72 8d	jsr $8d72	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb94		20 f6 97	jsr $97f6	                jsr xt_one_plus
.bb97		20 f6 97	jsr $97f6	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb9a		20 43 8f	jsr $8f43	                jsr xt_fetch            ; ( addr+2 u-s )
.bb9d		20 58 a1	jsr $a158	                jsr xt_swap             ; ( u-s addr+2 )
.bba0		20 43 8f	jsr $8f43	                jsr xt_fetch            ; ( u-s addr-s )
.bba3		20 58 a1	jsr $a158	                jsr xt_swap             ; ( addr-s u-s )
.bba6		20 ad a4	jsr $a4ad	                jsr xt_type
.bba9		20 3a 89	jsr $893a	                jsr xt_cr
.bbac		60		rts		                rts
>bbad		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bbb5		71 51 00
.bbb8						ed_cmd_table:
>bbb8		fd b7 44 b9 77 b9 a0 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bbc0		9f b9 98 b9
>bbc4		08 b9 12 ba 03 ba 0e ba		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bbcc						ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bbcc						forth_words_start:
>bbcc		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bbd4		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bbe4		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bbf4		20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bc04		20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bc14		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bc24		2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bc34		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bc44		77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bc54		20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc64		69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc74		4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc84		28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc94		65 78 69 74 29 20 63 72 20
.bc9d						forth_words_end:
.bc9d						user_words_start:
>bc9d		20 3a 6e 6f 6e 61 6d 65		.binary "user_words.asc"
>bca5		20 2d 31 20 24 63 30 31 31 20 63 21 20 30 20 24
>bcb5		63 30 31 30 20 63 21 20 24 63 30 31 31 20 63 40
>bcc5		20 30 3d 20 69 66 20 30 20 24 34 30 30 20 62 6c
>bcd5		6b 2d 72 65 61 64 20 24 34 30 30 20 40 20 24 34
>bce5		36 35 34 20 3d 20 69 66 20 24 34 30 34 20 24 34
>bcf5		30 32 20 40 20 65 76 61 6c 75 61 74 65 20 65 6c
>bd05		73 65 20 2e 22 20 62 61 64 20 62 6f 6f 74 20 62
>bd15		6c 6f 63 6b 22 20 43 52 20 74 68 65 6e 20 65 6c
>bd25		73 65 20 2e 22 20 6e 6f 20 62 6c 6f 63 6b 20 64
>bd35		65 76 69 63 65 22 20 43 52 20 74 68 65 6e 20 3b
>bd45		20 65 78 65 63 75 74 65 20
.bd4e						user_words_end:

;******  Processing file: platform/../headers.asm

.bd4e						dictionary_start:
.bd4e						nt_drop:
>bd4e		04 10				        .byte 4, UF
>bd50		5a bd f1 8c f6 8c		        .word nt_dup, xt_drop, z_drop
>bd56		64 72 6f 70			        .text "drop"
.bd5a						nt_dup:
>bd5a		03 10				        .byte 3, UF
>bd5c		65 bd 72 8d 7f 8d		        .word nt_swap, xt_dup, z_dup
>bd62		64 75 70			        .text "dup"
.bd65						nt_swap:
>bd65		04 10				        .byte 4, UF
>bd67		71 bd 58 a1 6b a1		        .word nt_store, xt_swap, z_swap
>bd6d		73 77 61 70			        .text "swap"
.bd71						nt_store:
>bd71		01 10				        .byte 1, UF
>bd73		7a bd 37 a1 4c a1		        .word nt_fetch, xt_store, z_store
>bd79		21				        .text "!"
.bd7a						nt_fetch:
>bd7a		01 10				        .byte 1, UF
>bd7c		83 bd 43 8f 55 8f		        .word nt_over, xt_fetch, z_fetch
>bd82		40				        .text "@"
.bd83						nt_over:
>bd83		04 10				        .byte 4, UF
>bd85		8f bd 6c 98 79 98		        .word nt_to_r, xt_over, z_over
>bd8b		6f 76 65 72			        .text "over"
.bd8f						nt_to_r:
>bd8f		02 11				        .byte 2, CO+UF ; native is special case
>bd91		99 bd 1a a3 2d a3		        .word nt_r_from, xt_to_r, z_to_r
>bd97		3e 72				        .text ">r"
.bd99						nt_r_from:
>bd99		02 01				        .byte 2, CO    ; native is special case
>bd9b		a3 bd 6b 9a 7b 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bda1		72 3e				        .text "r>"
.bda3						nt_r_fetch:
>bda3		02 01				        .byte 2, CO    ; native is special case
>bda5		ad bd 56 9a 6a 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bdab		72 40				        .text "r@"
.bdad						nt_nip:
>bdad		03 10				        .byte 3, UF
>bdaf		b8 bd 1b 96 28 96		        .word nt_rot, xt_nip, z_nip
>bdb5		6e 69 70			        .text "nip"
.bdb8						nt_rot:
>bdb8		03 10				        .byte 3, UF
>bdba		c3 bd 30 9b 4b 9b		        .word nt_not_rote, xt_rot, z_rot
>bdc0		72 6f 74			        .text "rot"
.bdc3						nt_not_rote:
>bdc3		04 10				        .byte 4, UF
>bdc5		cf bd 47 96 62 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bdcb		2d 72 6f 74			        .text "-rot"
.bdcf						nt_tuck:
>bdcf		04 10				        .byte 4, UF
>bdd1		db bd 37 a3 50 a3		        .word nt_comma, xt_tuck, z_tuck
>bdd7		74 75 63 6b			        .text "tuck"
.bddb						nt_comma:
>bddb		01 10				        .byte 1, UF
>bddd		e4 bd 34 87 4d 87		        .word nt_c_fetch, xt_comma, z_comma
>bde3		2c				        .text ","
.bde4						nt_c_fetch:
>bde4		02 10				        .byte 2, UF
>bde6		ee bd d1 85 da 85		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bdec		63 40				        .text "c@"
.bdee						nt_c_store:
>bdee		02 10				        .byte 2, UF
>bdf0		f8 bd db 85 e6 85		        .word nt_plus_store, xt_c_store, z_c_store
>bdf6		63 21				        .text "c!"
.bdf8						nt_plus_store:
>bdf8		02 10				        .byte 2, UF
>bdfa		02 be cf 99 ee 99		        .word nt_execute, xt_plus_store, z_plus_store
>be00		2b 21				        .text "+!"
.be02						nt_execute:
>be02		07 10				        .byte 7, UF
>be04		11 be 00 8f 06 8f		        .word nt_emit, xt_execute, z_execute
>be0a		65 78 65 63 75 74 65		        .text "execute"
.be11						nt_emit:
>be11		04 18				        .byte 4, NN+UF
>be13		1d be b2 8d bc 8d		        .word nt_type, xt_emit, z_emit
>be19		65 6d 69 74			        .text "emit"
.be1d						nt_type:
>be1d		04 10				        .byte 4, UF
>be1f		29 be ad a4 d7 a4		        .word nt_dot, xt_type, z_type
>be25		74 79 70 65			        .text "type"
.be29						nt_dot:
>be29		01 10				        .byte 1, UF
>be2b		32 be f9 8b 1a 8c		        .word nt_u_dot, xt_dot, z_dot
>be31		2e				        .text "."
.be32						nt_u_dot:
>be32		02 10				        .byte 2, UF
>be34		3c be d8 a4 e3 a4		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>be3a		75 2e				        .text "u."
.be3c						nt_u_dot_r:
>be3c		03 10				        .byte 3, UF
>be3e		47 be e4 a4 05 a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>be44		75 2e 72			        .text "u.r"
.be47						nt_dot_r:
>be47		02 10				        .byte 2, UF
>be49		51 be 35 8c 62 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>be4f		2e 72				        .text ".r"
.be51						nt_d_dot:
>be51		02 10				        .byte 2, UF
>be53		5b be a7 8c c5 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>be59		64 2e				        .text "d."
.be5b						nt_d_dot_r:
>be5b		03 10				        .byte 3, UF
>be5d		66 be c6 8c f0 8c		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>be63		64 2e 72			        .text "d.r"
.be66						nt_ud_dot:
>be66		03 10				        .byte 3, UF
>be68		71 be 32 a5 44 a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>be6e		75 64 2e			        .text "ud."
.be71						nt_ud_dot_r:
>be71		04 10				        .byte 4, UF
>be73		7d be 45 a5 63 a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>be79		75 64 2e 72			        .text "ud.r"
.be7d						nt_question:
>be7d		01 00				        .byte 1, 0
>be7f		86 be 3b 9a 41 9a		        .word nt_false, xt_question, z_question
>be85		3f				        .text "?"
.be86						nt_false:
>be86		05 00				        .byte 5, 0
>be88		93 be 3c 8f 42 8f		        .word nt_true, xt_false, z_false
>be8e		66 61 6c 73 65			        .text "false"
.be93						nt_true:
>be93		04 00				        .byte 4, 0
>be95		9f be 2e a3 36 a3		        .word nt_space, xt_true, z_true
>be9b		74 72 75 65			        .text "true"
.be9f						nt_space:
>be9f		05 00				        .byte 5, 0
>bea1		ac be c8 a0 cd a0		        .word nt_zero, xt_space, z_space
>bea7		73 70 61 63 65			        .text "space"
.beac						nt_zero:
>beac		01 00				        .byte 1, 0
>beae		b5 be 52 a7 58 a7		        .word nt_one, xt_zero, z_zero
>beb4		30				        .text "0"
.beb5						nt_one:
>beb5		01 00				        .byte 1, 0
>beb7		be be e1 97 e9 97		        .word nt_two, xt_one, z_one
>bebd		31				        .text "1"
.bebe						nt_two:
>bebe		01 00				        .byte 1, 0
>bec0		c7 be 51 a3 59 a3		        .word nt_two_dup, xt_two, z_two
>bec6		32				        .text "2"
.bec7						nt_two_dup:
>bec7		04 10				        .byte 4, UF
>bec9		d3 be 62 a3 79 a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>becf		32 64 75 70			        .text "2dup"
.bed3						nt_question_dup:
>bed3		04 10				        .byte 4, UF
>bed5		df be 42 9a 55 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bedb		3f 64 75 70			        .text "?dup"
.bedf						nt_plus:
>bedf		01 10				        .byte 1, UF
>bee1		e8 be bc 99 ce 99		        .word nt_minus, xt_plus, z_plus
>bee7		2b				        .text "+"
.bee8						nt_minus:
>bee8		01 10				        .byte 1, UF
>beea		f1 be 29 95 3b 95		        .word nt_one_minus, xt_minus, z_minus
>bef0		2d				        .text "-"
.bef1						nt_one_minus:
>bef1		02 10				        .byte 2, UF
>bef3		fb be ea 97 f5 97		        .word nt_one_plus, xt_one_minus, z_one_minus
>bef9		31 2d				        .text "1-"
.befb						nt_one_plus:
>befb		02 10				        .byte 2, UF
>befd		05 bf f6 97 ff 97		        .word nt_two_star, xt_one_plus, z_one_plus
>bf03		31 2b				        .text "1+"
.bf05						nt_two_star:
>bf05		02 10				        .byte 2, UF
>bf07		0f bf fa a3 01 a4		        .word nt_two_slash, xt_two_star, z_two_star
>bf0d		32 2a				        .text "2*"
.bf0f						nt_two_slash:
>bf0f		02 10				        .byte 2, UF
>bf11		19 bf ef a3 f9 a3		        .word nt_abs, xt_two_slash, z_two_slash
>bf17		32 2f				        .text "2/"
.bf19						nt_abs:
>bf19		03 10				        .byte 3, UF
>bf1b		24 bf dd 80 f1 80		        .word nt_dabs, xt_abs, z_abs
>bf21		61 62 73			        .text "abs"
.bf24						nt_dabs:
>bf24		04 10				        .byte 4, UF
>bf26		30 bf 5d 8a 7b 8a		        .word nt_and, xt_dabs, z_dabs
>bf2c		64 61 62 73			        .text "dabs"
.bf30						nt_and:
>bf30		03 10				        .byte 3, UF
>bf32		3b bf e2 82 f3 82		        .word nt_or, xt_and, z_and
>bf38		61 6e 64			        .text "and"
.bf3b						nt_or:
>bf3b		02 10				        .byte 2, UF
>bf3d		45 bf 0c 98 1d 98		        .word nt_xor, xt_or, z_or
>bf43		6f 72				        .text "or"
.bf45						nt_xor:
>bf45		03 10				        .byte 3, UF
>bf47		50 bf 40 a7 51 a7		        .word nt_rshift, xt_xor, z_xor
>bf4d		78 6f 72			        .text "xor"
.bf50						nt_rshift:
>bf50		06 10				        .byte 6, UF
>bf52		5e bf 4c 9b 5f 9b		        .word nt_lshift, xt_rshift, z_rshift
>bf58		72 73 68 69 66 74		        .text "rshift"
.bf5e						nt_lshift:
>bf5e		06 10				        .byte 6, UF
>bf60		6c bf 53 94 66 94		        .word nt_pick, xt_lshift, z_lshift
>bf66		6c 73 68 69 66 74		        .text "lshift"
.bf6c						nt_pick:
>bf6c		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bf6e		78 bf ab 99 bb 99		        .word nt_char, xt_pick, z_pick
>bf74		70 69 63 6b			        .text "pick"
.bf78						nt_char:
>bf78		04 00				        .byte 4, 0
>bf7a		84 bf f7 85 0d 86		        .word nt_bracket_char, xt_char, z_char
>bf80		63 68 61 72			        .text "char"
.bf84						nt_bracket_char:
>bf84		06 05				        .byte 6, CO+IM
>bf86		92 bf 5d 85 63 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bf8c		5b 63 68 61 72 5d		        .text "[char]"
.bf92						nt_char_plus:
>bf92		05 00				        .byte 5, 0
>bf94		9f bf f6 97 ff 97		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bf9a		63 68 61 72 2b			        .text "char+"
.bf9f						nt_chars:
>bf9f		05 12				        .byte 5, AN+UF   ; deleted during compile
>bfa1		ac bf 0e 86 11 86		        .word nt_cells, xt_chars, z_chars
>bfa7		63 68 61 72 73			        .text "chars"
.bfac						nt_cells:
>bfac		05 00				        .byte 5, 0
>bfae		b9 bf fa a3 01 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bfb4		63 65 6c 6c 73			        .text "cells"
.bfb9						nt_cell_plus:
>bfb9		05 10				        .byte 5, UF
>bfbb		c6 bf e7 85 f6 85		        .word nt_here, xt_cell_plus, z_cell_plus
>bfc1		63 65 6c 6c 2b			        .text "cell+"
.bfc6						nt_here:
>bfc6		04 00				        .byte 4, 0
>bfc8		d2 bf 35 91 3f 91		        .word nt_equal, xt_here, z_here
>bfce		68 65 72 65			        .text "here"
.bfd2						nt_equal:
>bfd2		01 10				        .byte 1, UF
>bfd4		db bf 91 8e ac 8e		        .word nt_not_equals, xt_equal, z_equal
>bfda		3d				        .text "="
.bfdb						nt_not_equals:
>bfdb		02 10				        .byte 2, UF
>bfdd		e5 bf 29 96 46 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bfe3		3c 3e				        .text "<>"
.bfe5						nt_less_than:
>bfe5		01 10				        .byte 1, UF
>bfe7		ee bf 29 93 3d 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bfed		3c				        .text "<"
.bfee						nt_u_less_than:
>bfee		02 10				        .byte 2, UF
>bff0		f8 bf 1c a5 31 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bff6		75 3c				        .text "u<"
.bff8						nt_u_greater_than:
>bff8		02 10				        .byte 2, UF
>bffa		02 c0 06 a5 1b a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>c000		75 3e				        .text "u>"
.c002						nt_greater_than:
>c002		01 10				        .byte 1, UF
>c004		0b c0 20 91 34 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>c00a		3e				        .text ">"
.c00b						nt_zero_equal:
>c00b		02 10				        .byte 2, UF
>c00d		15 c0 59 a7 6a a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>c013		30 3d				        .text "0="
.c015						nt_zero_unequal:
>c015		03 10				        .byte 3, UF
>c017		20 c0 8f a7 9e a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>c01d		30 3c 3e			        .text "0<>"
.c020						nt_zero_greater:
>c020		02 10				        .byte 2, UF
>c022		2a c0 6b a7 7e a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>c028		30 3e				        .text "0>"
.c02a						nt_zero_less:
>c02a		02 10				        .byte 2, UF
>c02c		34 c0 7f a7 8e a7		        .word nt_min, xt_zero_less, z_zero_less
>c032		30 3c				        .text "0<"
.c034						nt_min:
>c034		03 10				        .byte 3, UF
>c036		3f c0 0d 95 28 95		        .word nt_max, xt_min, z_min
>c03c		6d 69 6e			        .text "min"
.c03f						nt_max:
>c03f		03 10				        .byte 3, UF
>c041		4a c0 f1 94 0c 95		        .word nt_two_drop, xt_max, z_max
>c047		6d 61 78			        .text "max"
.c04a						nt_two_drop:
>c04a		05 10				        .byte 5, UF
>c04c		57 c0 5a a3 61 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>c052		32 64 72 6f 70			        .text "2drop"
.c057						nt_two_swap:
>c057		05 10				        .byte 5, UF
>c059		64 c0 28 a4 4b a4		        .word nt_two_over, xt_two_swap, z_two_swap
>c05f		32 73 77 61 70			        .text "2swap"
.c064						nt_two_over:
>c064		05 10				        .byte 5, UF
>c066		71 c0 9c a3 b3 a3		        .word nt_two_store, xt_two_over, z_two_over
>c06c		32 6f 76 65 72			        .text "2over"
.c071						nt_two_store:
>c071		02 10				        .byte 2, UF
>c073		7b c0 02 a4 27 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>c079		32 21				        .text "2!"
.c07b						nt_two_fetch:
>c07b		02 10				        .byte 2, UF
>c07d		85 c0 7a a3 9b a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>c083		32 40				        .text "2@"
.c085						nt_two_variable:
>c085		09 00				        .byte 9, 0
>c087		96 c0 9e a4 ac a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>c08d		32 76 61 72 69 61 62 6c		        .text "2variable"
>c095		65
.c096						nt_two_constant:
>c096		09 10				        .byte 9, UF
>c098		a7 c0 6c a4 90 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>c09e		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>c0a6		74
.c0a7						nt_two_literal:
>c0a7		08 14				        .byte 8, UF+IM
>c0a9		b7 c0 91 a4 9d a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>c0af		32 6c 69 74 65 72 61 6c		        .text "2literal"
.c0b7						nt_two_r_fetch:
>c0b7		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>c0b9		c2 c0 b4 a3 d1 a3		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>c0bf		32 72 40			        .text "2r@"
.c0c2						nt_two_r_from:
>c0c2		03 01				        .byte 3, CO             ; native is special case
>c0c4		cd c0 d2 a3 ee a3		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>c0ca		32 72 3e			        .text "2r>"
.c0cd						nt_two_to_r:
>c0cd		03 11				        .byte 3, CO+UF          ; native is special case
>c0cf		d8 c0 4c a4 6b a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>c0d5		32 3e 72			        .text "2>r"
.c0d8						nt_invert:
>c0d8		06 10				        .byte 6, UF
>c0da		e6 c0 ac 92 bb 92		        .word nt_negate, xt_invert, z_invert
>c0e0		69 6e 76 65 72 74		        .text "invert"
.c0e6						nt_negate:
>c0e6		06 10				        .byte 6, UF
>c0e8		f4 c0 fc 95 0c 96		        .word nt_dnegate, xt_negate, z_negate
>c0ee		6e 65 67 61 74 65		        .text "negate"
.c0f4						nt_dnegate:
>c0f4		07 10				        .byte 7, UF
>c0f6		03 c1 18 8b 32 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>c0fc		64 6e 65 67 61 74 65		        .text "dnegate"
.c103						nt_c_comma:
>c103		02 10				        .byte 2, UF
>c105		0d c1 c6 85 d0 85		        .word nt_bounds, xt_c_comma, z_c_comma
>c10b		63 2c				        .text "c,"
.c10d						nt_bounds:
>c10d		06 10				        .byte 6, UF
>c10f		1b c1 44 85 5c 85		        .word nt_spaces, xt_bounds, z_bounds
>c115		62 6f 75 6e 64 73		        .text "bounds"
.c11b						nt_spaces:
>c11b		06 10				        .byte 6, UF
>c11d		29 c1 ce a0 09 a1		        .word nt_bl, xt_spaces, z_spaces
>c123		73 70 61 63 65 73		        .text "spaces"
.c129						nt_bl:
>c129		02 00				        .byte 2, 0
>c12b		33 c1 60 83 68 83		        .word nt_minus_trailing, xt_bl, z_bl
>c131		62 6c				        .text "bl"
.c133						nt_minus_trailing:
>c133		09 10				        .byte 9, UF
>c135		44 c1 55 95 91 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c13b		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c143		67
.c144						nt_minus_leading:
>c144		08 10				        .byte 8, UF
>c146		54 c1 3c 95 54 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c14c		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c154						nt_slash_string:
>c154		07 10				        .byte 7, UF
>c156		63 c1 c3 9f e2 9f		        .word nt_refill, xt_slash_string, z_slash_string
>c15c		2f 73 74 72 69 6e 67		        .text "/string"
.c163						nt_refill:
>c163		06 00				        .byte 6, 0
>c165		71 c1 d1 9a 12 9b		        .word nt_accept, xt_refill, z_refill
>c16b		72 65 66 69 6c 6c		        .text "refill"
.c171						nt_accept:
>c171		06 18				        .byte 6, UF+NN
>c173		7f c1 f2 80 ea 81		        .word nt_input_to_r, xt_accept, z_accept
>c179		61 63 63 65 70 74		        .text "accept"
.c17f						nt_input_to_r:
>c17f		07 08				        .byte 7, NN
>c181		8e c1 23 92 38 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c187		69 6e 70 75 74 3e 72		        .text "input>r"
.c18e						nt_r_to_input:
>c18e		07 08				        .byte 7, NN
>c190		9d c1 7c 9a 93 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c196		72 3e 69 6e 70 75 74		        .text "r>input"
.c19d						nt_unused:
>c19d		06 00				        .byte 6, 0
>c19f		ab c1 fe a5 0d a6		        .word nt_depth, xt_unused, z_unused
>c1a5		75 6e 75 73 65 64		        .text "unused"
.c1ab						nt_depth:
>c1ab		05 00				        .byte 5, 0
>c1ad		b8 c1 cd 8a db 8a		        .word nt_key, xt_depth, z_depth
>c1b3		64 65 70 74 68			        .text "depth"
.c1b8						nt_key:
>c1b8		03 00				        .byte 3, 0
>c1ba		c3 c1 ef 92 f8 92		        .word nt_allot, xt_key, z_key
>c1c0		6b 65 79			        .text "key"
.c1c3						nt_allot:
>c1c3		05 10				        .byte 5, UF
>c1c5		d0 c1 4f 82 b7 82		        .word nt_create, xt_allot, z_allot
>c1cb		61 6c 6c 6f 74			        .text "allot"
.c1d0						nt_create:
>c1d0		06 00				        .byte 6, 0
>c1d2		de c1 40 89 14 8a		        .word nt_does, xt_create, z_create
>c1d8		63 72 65 61 74 65		        .text "create"
.c1de						nt_does:
>c1de		05 05				        .byte 5, CO+IM
>c1e0		eb c1 b8 8b c6 8b		        .word nt_variable, xt_does, z_does
>c1e6		64 6f 65 73 3e			        .text "does>"
.c1eb						nt_variable:
>c1eb		08 00				        .byte 8, 0
>c1ed		fb c1 22 a6 3a a6		        .word nt_constant, xt_variable, z_variable
>c1f3		76 61 72 69 61 62 6c 65		        .text "variable"
.c1fb						nt_constant:
>c1fb		08 10				        .byte 8, UF
>c1fd		0b c2 e8 88 25 89		        .word nt_value, xt_constant, z_constant
>c203		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c20b						nt_value:
>c20b		05 10				        .byte 5, UF
>c20d		18 c2 e8 88 25 89		        .word nt_to, xt_constant, z_constant
>c213		76 61 6c 75 65			        .text "value"
.c218						nt_to:
>c218		02 0c				        .byte 2, NN+IM
>c21a		22 c2 db a1 36 a2		        .word nt_s_to_d, xt_to, z_to
>c220		74 6f				        .text "to"
.c222						nt_s_to_d:
>c222		03 10				        .byte 3, UF
>c224		2d c2 56 9e 67 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c22a		73 3e 64			        .text "s>d"
.c22d						nt_d_to_s:
>c22d		03 10				        .byte 3, UF
>c22f		38 c2 57 8a 5c 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c235		64 3e 73			        .text "d>s"
.c238						nt_d_minus:
>c238		02 10				        .byte 2, UF
>c23a		42 c2 15 8a 35 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c240		64 2d				        .text "d-"
.c242						nt_d_plus:
>c242		02 10				        .byte 2, UF
>c244		4c c2 36 8a 56 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c24a		64 2b				        .text "d+"
.c24c						nt_erase:
>c24c		05 00				        .byte 5, 0      ; underflow checked by FILL
>c24e		59 c2 b7 8e ff 8e		        .word nt_blank, xt_erase, z_erase
>c254		65 72 61 73 65			        .text "erase"
.c259						nt_blank:
>c259		05 00				        .byte 5, 0     ; underflow checked by FILL
>c25b		66 c2 ad 8e ff 8e		        .word nt_fill, xt_blank, z_blank
>c261		62 6c 61 6e 6b			        .text "blank"
.c266						nt_fill:
>c266		04 10				        .byte 4, UF
>c268		72 c2 bd 8e ff 8e		        .word nt_find_name, xt_fill, z_fill
>c26e		66 69 6c 6c			        .text "fill"
.c272						nt_find_name:
>c272		09 10				        .byte 9, UF
>c274		83 c2 9e 8f 49 90		        .word nt_tick, xt_find_name, z_find_name
>c27a		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c282		65
.c283						nt_tick:
>c283		01 00				        .byte 1, 0
>c285		8c c2 bb a1 da a1		        .word nt_bracket_tick, xt_tick, z_tick
>c28b		27				        .text "'"
.c28c						nt_bracket_tick:
>c28c		03 05				        .byte 3, CO+IM
>c28e		97 c2 64 85 6a 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c294		5b 27 5d			        .text "[']"
.c297						nt_name_to_int:
>c297		08 10				        .byte 8, UF
>c299		a7 c2 ba 95 d6 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c29f		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c2a7						nt_int_to_name:
>c2a7		08 10				        .byte 8, UF
>c2a9		b7 c2 39 92 ab 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c2af		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c2b7						nt_name_to_string:
>c2b7		0b 10				        .byte 11, UF
>c2b9		ca c2 d7 95 f0 95		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c2bf		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c2c7		69 6e 67
.c2ca						nt_to_body:
>c2ca		05 10				        .byte 5, UF
>c2cc		d7 c2 37 a2 5b a2		        .word nt_defer, xt_to_body, z_to_body
>c2d2		3e 62 6f 64 79			        .text ">body"
.c2d7						nt_defer:
>c2d7		05 00				        .byte 5, 0
>c2d9		e4 c2 83 8a b5 8a		        .word nt_latestxt, xt_defer, z_defer
>c2df		64 65 66 65 72			        .text "defer"
.c2e4						nt_latestxt:
>c2e4		08 00				        .byte 8, 0
>c2e6		f4 c2 0a 93 10 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c2ec		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c2f4						nt_latestnt:
>c2f4		08 00				        .byte 8, 0
>c2f6		04 c3 fc 92 09 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c2fc		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c304						nt_parse_name:
>c304		0a 08				        .byte 10, NN
>c306		16 c3 b8 98 aa 99		        .word nt_parse, xt_parse_name, z_parse_name
>c30c		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c314		6d 65
.c316						nt_parse:
>c316		05 10				        .byte 5, UF
>c318		23 c3 13 99 aa 99		        .word nt_execute_parsing, xt_parse, z_parse
>c31e		70 61 72 73 65			        .text "parse"
.c323						nt_execute_parsing:
>c323		0f 10				        .byte 15, UF
>c325		3a c3 14 8f 3a 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c32b		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c333		70 61 72 73 69 6e 67
.c33a						nt_source:
>c33a		06 00				        .byte 6, 0
>c33c		48 c3 a8 a0 bc a0		        .word nt_source_id, xt_source, z_source
>c342		73 6f 75 72 63 65		        .text "source"
.c348						nt_source_id:
>c348		09 00				        .byte 9, 0
>c34a		59 c3 bd a0 c7 a0		        .word nt_colon, xt_source_id, z_source_id
>c350		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c358		64
.c359						nt_colon:
>c359		01 00				        .byte 1, 0
>c35b		62 c3 d5 86 17 87		        .word nt_semicolon, xt_colon, z_colon
>c361		3a				        .text ":"
.c362						nt_semicolon:
>c362		01 05				        .byte 1, CO+IM
>c364		6b c3 32 9f 90 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c36a		3b				        .text ";"
.c36b						nt_colon_noname:
>c36b		07 00				        .byte 7, 0
>c36d		7a c3 18 87 33 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c373		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c37a						nt_compile_comma:
>c37a		08 18				        .byte 8, UF+NN
>c37c		8a c3 b3 87 db 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c382		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c38a						nt_left_bracket:
>c38a		01 05				        .byte 1, IM+CO
>c38c		93 c3 16 93 1a 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c392		5b				        .text "["
.c393						nt_right_bracket:
>c393		01 04				        .byte 1, IM
>c395		9c c3 20 9b 26 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c39b		5d				        .text "]"
.c39c						nt_literal:
>c39c		07 15				        .byte 7, IM+CO+UF
>c39e		ab c3 4b 93 58 93		        .word nt_sliteral, xt_literal, z_literal
>c3a4		6c 69 74 65 72 61 6c		        .text "literal"
.c3ab						nt_sliteral:
>c3ab		08 15				        .byte 8, CO+IM+UF
>c3ad		bb c3 e3 9f 52 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c3b3		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c3bb						nt_dot_quote:
>c3bb		02 05				        .byte 2, CO+IM
>c3bd		c5 c3 2a 8c 34 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c3c3		2e 22				        .text ".", $22
.c3c5						nt_s_quote:
>c3c5		02 0c				        .byte 2, IM+NN
>c3c7		cf c3 28 9d 55 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c3cd		73 22				        .text "s", $22
.c3cf						nt_s_backslash_quote:
>c3cf		03 04				        .byte 3, IM
>c3d1		da c3 60 9b 69 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c3d7		73 5c 22			        .text "s", $5C, $22
.c3da						nt_postpone:
>c3da		08 05				        .byte 8, IM+CO
>c3dc		ea c3 ef 99 2d 9a		        .word nt_immediate, xt_postpone, z_postpone
>c3e2		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c3ea						nt_immediate:
>c3ea		09 00				        .byte 9, 0
>c3ec		fb c3 0c 92 17 92		        .word nt_compile_only, xt_immediate, z_immediate
>c3f2		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c3fa		65
.c3fb						nt_compile_only:
>c3fb		0c 00				        .byte 12, 0
>c3fd		0f c4 dc 88 e7 88		        .word nt_never_native, xt_compile_only, z_compile_only
>c403		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c40b		6f 6e 6c 79
.c40f						nt_never_native:
>c40f		0c 00				        .byte 12, 0
>c411		23 c4 0d 96 1a 96		        .word nt_always_native, xt_never_native, z_never_native
>c417		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c41f		74 69 76 65
.c423						nt_always_native:
>c423		0d 00				        .byte 13, 0
>c425		38 c4 d4 82 e1 82		        .word nt_allow_native, xt_always_native, z_always_native
>c42b		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c433		61 74 69 76 65
.c438						nt_allow_native:
>c438		0c 00				        .byte 12, 0
>c43a		4c c4 b8 82 c3 82		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c440		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c448		74 69 76 65
.c44c						nt_nc_limit:
>c44c		08 00				        .byte 8, 0
>c44e		5c c4 f1 95 fb 95		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c454		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c45c						nt_strip_underflow:
>c45c		0f 00				        .byte 15, 0
>c45e		73 c4 4d a1 57 a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c464		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c46c		64 65 72 66 6c 6f 77
.c473						nt_abort:
>c473		05 00				        .byte 5, 0
>c475		80 c4 70 80 bd 80		        .word nt_abort_quote, xt_abort, z_abort
>c47b		61 62 6f 72 74			        .text "abort"
.c480						nt_abort_quote:
>c480		06 0d				        .byte 6, CO+IM+NN
>c482		8e c4 bd 80 c7 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c488		61 62 6f 72 74 22		        .text "abort", $22
.c48e						nt_do:
>c48e		02 0d				        .byte 2, CO+IM+NN
>c490		98 c4 39 8b 72 8b		        .word nt_question_do, xt_do, z_do
>c496		64 6f				        .text "do"
.c498						nt_question_do:
>c498		03 0d				        .byte 3, CO+IM+NN
>c49a		a3 c4 33 8b 72 8b		        .word nt_i, xt_question_do, z_question_do
>c4a0		3f 64 6f			        .text "?do"
.c4a3						nt_i:
>c4a3		01 03				        .byte 1, AN+CO
>c4a5		ac c4 ac 91 c3 91		        .word nt_j, xt_i, z_i
>c4ab		69				        .text "i"
.c4ac						nt_j:
>c4ac		01 03				        .byte 1, AN+CO
>c4ae		b5 c4 d5 92 ee 92		        .word nt_loop, xt_j, z_j
>c4b4		6a				        .text "j"
.c4b5						nt_loop:
>c4b5		04 05				        .byte 4, CO+IM
>c4b7		c1 c4 d1 93 2e 94		        .word nt_plus_loop, xt_loop, z_loop
>c4bd		6c 6f 6f 70			        .text "loop"
.c4c1						nt_plus_loop:
>c4c1		05 05				        .byte 5, CO+IM
>c4c3		ce c4 e2 93 2e 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c4c9		2b 6c 6f 6f 70			        .text "+loop"
.c4ce						nt_exit:
>c4ce		04 03				        .byte 4, AN+CO
>c4d0		da c4 3b 8f 3c 8f		        .word nt_unloop, xt_exit, z_exit
>c4d6		65 78 69 74			        .text "exit"
.c4da						nt_unloop:
>c4da		06 03				        .byte 6, AN+CO
>c4dc		e8 c4 ec a5 f2 a5		        .word nt_leave, xt_unloop, z_unloop
>c4e2		75 6e 6c 6f 6f 70		        .text "unloop"
.c4e8						nt_leave:
>c4e8		05 03				        .byte 5, AN+CO
>c4ea		f5 c4 11 93 16 93		        .word nt_recurse, xt_leave, z_leave
>c4f0		6c 65 61 76 65			        .text "leave"
.c4f5						nt_recurse:
>c4f5		07 0d				        .byte 7, CO+IM+NN
>c4f7		04 c5 94 9a d0 9a		        .word nt_quit, xt_recurse, z_recurse
>c4fd		72 65 63 75 72 73 65		        .text "recurse"
.c504						nt_quit:
>c504		04 00				        .byte 4, 0
>c506		10 c5 72 80 bd 80		        .word nt_begin, xt_quit, z_quit
>c50c		71 75 69 74			        .text "quit"
.c510						nt_begin:
>c510		05 07				        .byte 5, AN+CO+IM
>c512		1d c5 56 83 59 83		        .word nt_again, xt_begin, z_begin
>c518		62 65 67 69 6e			        .text "begin"
.c51d						nt_again:
>c51d		05 17				        .byte 5, AN+CO+IM+UF
>c51f		2a c5 2d 82 4d 82		        .word nt_state, xt_again, z_again
>c525		61 67 61 69 6e			        .text "again"
.c52a						nt_state:
>c52a		05 00				        .byte 5, 0
>c52c		37 c5 2c a1 36 a1		        .word nt_evaluate, xt_state, z_state
>c532		73 74 61 74 65			        .text "state"
.c537						nt_evaluate:
>c537		08 10				        .byte 8, UF
>c539		47 c5 98 90 eb 90		        .word nt_base, xt_evaluate, z_evaluate
>c53f		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c547						nt_base:
>c547		04 00				        .byte 4, 0
>c549		53 c5 4d 83 55 83		        .word nt_digit_question, xt_base, z_base
>c54f		62 61 73 65			        .text "base"
.c553						nt_digit_question:
>c553		06 10				        .byte 6, UF
>c555		61 c5 dc 8a 10 8b		        .word nt_number, xt_digit_question, z_digit_question
>c55b		64 69 67 69 74 3f		        .text "digit?"
.c561						nt_number:
>c561		06 10				        .byte 6, UF
>c563		6f c5 63 96 5f 97		        .word nt_to_number, xt_number, z_number
>c569		6e 75 6d 62 65 72		        .text "number"
.c56f						nt_to_number:
>c56f		07 10				        .byte 7, UF
>c571		7e c5 67 a2 06 a3		        .word nt_hex, xt_to_number, z_to_number
>c577		3e 6e 75 6d 62 65 72		        .text ">number"
.c57e						nt_hex:
>c57e		03 00				        .byte 3, 0
>c580		89 c5 40 91 46 91		        .word nt_decimal, xt_hex, z_hex
>c586		68 65 78			        .text "hex"
.c589						nt_decimal:
>c589		07 00				        .byte 7, 0
>c58b		98 c5 7c 8a 82 8a		        .word nt_count, xt_decimal, z_decimal
>c591		64 65 63 69 6d 61 6c		        .text "decimal"
.c598						nt_count:
>c598		05 10				        .byte 5, UF
>c59a		a5 c5 26 89 39 89		        .word nt_m_star, xt_count, z_count
>c5a0		63 6f 75 6e 74			        .text "count"
.c5a5						nt_m_star:
>c5a5		02 10				        .byte 2, UF
>c5a7		af c5 67 94 81 94		        .word nt_um_star, xt_m_star, z_m_star
>c5ad		6d 2a				        .text "m*"
.c5af						nt_um_star:
>c5af		03 10				        .byte 3, UF
>c5b1		ba c5 a6 a5 eb a5		        .word nt_star, xt_um_star, z_um_star
>c5b7		75 6d 2a			        .text "um*"
.c5ba						nt_star:
>c5ba		01 10				        .byte 1, UF
>c5bc		c3 c5 0a a1 12 a1		        .word nt_um_slash_mod, xt_star, z_star
>c5c2		2a				        .text "*"
.c5c3						nt_um_slash_mod:
>c5c3		06 10				        .byte 6, UF
>c5c5		d1 c5 64 a5 a5 a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c5cb		75 6d 2f 6d 6f 64		        .text "um/mod"
.c5d1						nt_sm_slash_rem:
>c5d1		06 10				        .byte 6, UF
>c5d3		df c5 7f a0 a7 a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c5d9		73 6d 2f 72 65 6d		        .text "sm/rem"
.c5df						nt_fm_slash_mod:
>c5df		06 10				        .byte 6, UF
>c5e1		ed c5 54 90 8a 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c5e7		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c5ed						nt_slash:
>c5ed		01 10				        .byte 1, UF
>c5ef		f6 c5 a6 9f c2 9f		        .word nt_slash_mod, xt_slash, z_slash
>c5f5		2f				        .text "/"
.c5f6						nt_slash_mod:
>c5f6		04 10				        .byte 4, UF
>c5f8		02 c6 ab 9f c2 9f		        .word nt_mod, xt_slash_mod, z_slash_mod
>c5fe		2f 6d 6f 64			        .text "/mod"
.c602						nt_mod:
>c602		03 10				        .byte 3, UF
>c604		0d c6 92 95 9a 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c60a		6d 6f 64			        .text "mod"
.c60d						nt_star_slash_mod:
>c60d		05 10				        .byte 5, UF
>c60f		1a c6 1c a1 2b a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c615		2a 2f 6d 6f 64			        .text "*/mod"
.c61a						nt_star_slash:
>c61a		02 10				        .byte 2, UF
>c61c		24 c6 13 a1 1b a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c622		2a 2f				        .text "*/"
.c624						nt_backslash:
>c624		01 04				        .byte 1, IM
>c626		2d c6 22 83 4c 83		        .word nt_move, xt_backslash, z_backslash
>c62c		5c				        .byte $5c
.c62d						nt_move:
>c62d		04 18				        .byte 4, NN+UF
>c62f		39 c6 9b 95 b9 95		        .word nt_cmove_up, xt_move, z_move
>c635		6d 6f 76 65			        .text "move"
.c639						nt_cmove_up:
>c639		06 10				        .byte 6, UF
>c63b		47 c6 9a 86 d4 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c641		63 6d 6f 76 65 3e		        .text "cmove>"
.c647						nt_cmove:
>c647		05 10				        .byte 5, UF
>c649		54 c6 5f 86 99 86		        .word nt_pad, xt_cmove, z_cmove
>c64f		63 6d 6f 76 65			        .text "cmove"
.c654						nt_pad:
>c654		03 00				        .byte 3, 0
>c656		5f c6 7a 98 89 98		        .word nt_cleave, xt_pad, z_pad
>c65c		70 61 64			        .text "pad"
.c65f						nt_cleave:
>c65f		06 10				        .byte 6, UF
>c661		6d c6 12 86 5e 86		        .word nt_hexstore, xt_cleave, z_cleave
>c667		63 6c 65 61 76 65		        .text "cleave"
.c66d						nt_hexstore:
>c66d		08 10				        .byte 8, UF
>c66f		7d c6 47 91 99 91		        .word nt_within, xt_hexstore, z_hexstore
>c675		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c67d						nt_within:
>c67d		06 10				        .byte 6, UF
>c67f		8b c6 4f a6 64 a6		        .word nt_to_in, xt_within, z_within
>c685		77 69 74 68 69 6e		        .text "within"
.c68b						nt_to_in:
>c68b		03 00				        .byte 3, 0
>c68d		96 c6 5c a2 66 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c693		3e 69 6e			        .text ">in"
.c696						nt_less_number_sign:
>c696		02 00				        .byte 2, 0
>c698		a0 c6 1b 93 28 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c69e		3c 23				        .text "<#"
.c6a0						nt_number_sign:
>c6a0		01 10				        .byte 1, UF
>c6a2		a9 c6 60 97 94 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c6a8		23				        .text "#"
.c6a9						nt_number_sign_s:
>c6a9		02 10				        .byte 2, UF
>c6ab		b3 c6 b7 97 c7 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c6b1		23 73				        .text "#s"
.c6b3						nt_number_sign_greater:
>c6b3		02 10				        .byte 2, UF
>c6b5		bd c6 95 97 b6 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c6bb		23 3e				        .text "#>"
.c6bd						nt_hold:
>c6bd		04 10				        .byte 4, UF
>c6bf		c9 c6 9a 91 ab 91		        .word nt_sign, xt_hold, z_hold
>c6c5		68 6f 6c 64			        .text "hold"
.c6c9						nt_sign:
>c6c9		04 10				        .byte 4, UF
>c6cb		d5 c6 91 9f a5 9f		        .word nt_output, xt_sign, z_sign
>c6d1		73 69 67 6e			        .text "sign"
.c6d5						nt_output:
>c6d5		06 00				        .byte 6, 0
>c6d7		e3 c6 61 98 6b 98		        .word nt_input, xt_output, z_output
>c6dd		6f 75 74 70 75 74		        .text "output"
.c6e3						nt_input:
>c6e3		05 00				        .byte 5, 0
>c6e5		f0 c6 18 92 22 92		        .word nt_cr, xt_input, z_input
>c6eb		69 6e 70 75 74			        .text "input"
.c6f0						nt_cr:
>c6f0		02 00				        .byte 2, 0
>c6f2		fa c6 3a 89 3f 89		        .word nt_page, xt_cr, z_cr
>c6f8		63 72				        .text "cr"
.c6fa						nt_page:
>c6fa		04 00				        .byte 4, 0
>c6fc		06 c7 8a 98 a7 98		        .word nt_at_xy, xt_page, z_page
>c702		70 61 67 65			        .text "page"
.c706						nt_at_xy:
>c706		05 10				        .byte 5, UF
>c708		13 c7 f4 82 21 83		        .word nt_marker, xt_at_xy, z_at_xy
>c70e		61 74 2d 78 79			        .text "at-xy"
.c713						nt_marker:
>c713		06 04				        .byte 6, IM
>c715		21 c7 82 94 bf 94		        .word nt_words, xt_marker, z_marker
>c71b		6d 61 72 6b 65 72		        .text "marker"
.c721						nt_words:
>c721		05 00				        .byte 5, 0
>c723		2e c7 c2 a6 1e a7		        .word nt_wordsize, xt_words, z_words
>c729		77 6f 72 64 73			        .text "words"
.c72e						nt_wordsize:
>c72e		08 10				        .byte 8, UF
>c730		3e c7 1f a7 3f a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c736		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c73e						nt_aligned:
>c73e		07 00				        .byte 7, 0
>c740		4d c7 4e 82 4e 82		        .word nt_align, xt_align, z_align
>c746		61 6c 69 67 6e 65 64		        .text "aligned"
.c74d						nt_align:
>c74d		05 00				        .byte 5, 0
>c74f		5a c7 4e 82 4e 82		        .word nt_bell, xt_align, z_align
>c755		61 6c 69 67 6e			        .text "align"
.c75a						nt_bell:
>c75a		04 00				        .byte 4, 0
>c75c		66 c7 5a 83 5f 83		        .word nt_dump, xt_bell, z_bell
>c762		62 65 6c 6c			        .text "bell"
.c766						nt_dump:
>c766		04 10				        .byte 4, UF
>c768		72 c7 f7 8c 5d 8d		        .word nt_dot_s, xt_dump, z_dump
>c76e		64 75 6d 70			        .text "dump"
.c772						nt_dot_s:
>c772		02 00				        .byte 2, 0
>c774		7c c7 63 8c a6 8c		        .word +, xt_dot_s, z_dot_s
>c77a		2e 73				        .text ".s"
.c77c						+
.c77c						nt_disasm:
>c77c		06 10				        .byte 6, UF
>c77e		8a c7 11 8b 17 8b		        .word +, xt_disasm, z_disasm
>c784		64 69 73 61 73 6d		        .text "disasm"
.c78a						+
.c78a						nt_compare:
>c78a		07 10				        .byte 7, UF
>c78c		99 c7 4e 87 b2 87		        .word nt_search, xt_compare, z_compare
>c792		63 6f 6d 70 61 72 65		        .text "compare"
.c799						nt_search:
>c799		06 18				        .byte 6, UF+NN
>c79b		a7 c7 93 9e 31 9f		        .word +, xt_search, z_search
>c7a1		73 65 61 72 63 68		        .text "search"
.c7a7						+
.c7a7						nt_environment_q:
>c7a7		0c 10				        .byte 12, UF
>c7a9		bb c7 d8 8d 54 8e		        .word +, xt_environment_q, z_environment_q
>c7af		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c7b7		65 6e 74 3f
.c7bb						+
.c7bb						nt_find:
>c7bb		04 10				        .byte 4, UF
>c7bd		c7 c7 56 8f 9d 8f		        .word nt_word, xt_find, z_find
>c7c3		66 69 6e 64			        .text "find"
.c7c7						nt_word:
>c7c7		04 10				        .byte 4, UF
>c7c9		d3 c7 65 a6 aa a6		        .word nt_paren, xt_word, z_word
>c7cf		77 6f 72 64			        .text "word"
.c7d3						nt_paren:
>c7d3		01 04				        .byte 1, IM
>c7d5		dc c7 a8 98 b7 98		        .word nt_dot_paren, xt_paren, z_paren
>c7db		28				        .text "("
.c7dc						nt_dot_paren:
>c7dc		02 04				        .byte 2, IM
>c7de		e6 c7 1b 8c 29 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c7e4		2e 28				        .text ".("
.c7e6						nt_if:
>c7e6		02 0d				        .byte 2, IM+CO+NN
>c7e8		f0 c7 c4 91 d4 91		        .word nt_then, xt_if, z_if
>c7ee		69 66				        .text "if"
.c7f0						nt_then:
>c7f0		04 0d				        .byte 4, IM+CO+NN
>c7f2		fc c7 6c a1 75 a1		        .word nt_else, xt_then, z_then
>c7f8		74 68 65 6e			        .text "then"
.c7fc						nt_else:
>c7fc		04 0d				        .byte 4, IM+CO+NN
>c7fe		08 c8 84 8d 9d 8d		        .word nt_repeat, xt_else, z_else
>c804		65 6c 73 65			        .text "else"
.c808						nt_repeat:
>c808		06 0d				        .byte 6, IM+CO+NN
>c80a		16 c8 13 9b 1f 9b		        .word nt_until, xt_repeat, z_repeat
>c810		72 65 70 65 61 74		        .text "repeat"
.c816						nt_until:
>c816		05 0d				        .byte 5, IM+CO+NN
>c818		23 c8 f3 a5 fd a5		        .word nt_while, xt_until, z_until
>c81e		75 6e 74 69 6c			        .text "until"
.c823						nt_while:
>c823		05 0d				        .byte 5, IM+CO+NN
>c825		30 c8 3b a6 4e a6		        .word nt_case, xt_while, z_while
>c82b		77 68 69 6c 65			        .text "while"
.c830						nt_case:
>c830		04 0d				        .byte 4, IM+CO+NN
>c832		3c c8 52 a7 58 a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c838		63 61 73 65			        .text "case"
.c83c						nt_of:
>c83c		02 0d				        .byte 2, IM+CO+NN
>c83e		46 c8 c8 97 e0 97		        .word nt_endof, xt_of, z_of
>c844		6f 66				        .text "of"
.c846						nt_endof:
>c846		05 0d				        .byte 5, IM+CO+NN
>c848		53 c8 84 8d 9d 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c84e		65 6e 64 6f 66			        .text "endof"
.c853						nt_endcase:
>c853		07 0d				        .byte 7, IM+CO+NN
>c855		62 c8 c3 8d d7 8d		        .word nt_defer_fetch, xt_endcase, z_endcase
>c85b		65 6e 64 63 61 73 65		        .text "endcase"
.c862						nt_defer_fetch:
>c862		06 00				        .byte 6, 0
>c864		70 c8 b6 8a bc 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c86a		64 65 66 65 72 40		        .text "defer@"
.c870						nt_defer_store:
>c870		06 00				        .byte 6, 0
>c872		7e c8 bd 8a c3 8a		        .word nt_is, xt_defer_store, z_defer_store
>c878		64 65 66 65 72 21		        .text "defer!"
.c87e						nt_is:
>c87e		02 04				        .byte 2, IM
>c880		88 c8 bc 92 d4 92		        .word nt_action_of, xt_is, z_is
>c886		69 73				        .text "is"
.c888						nt_action_of:
>c888		09 04				        .byte 9, IM
>c88a		99 c8 14 82 2c 82		        .word nt_useraddr, xt_action_of, z_action_of
>c890		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c898		66
.c899						nt_useraddr:
>c899		08 00				        .byte 8, 0
>c89b		a9 c8 17 a6 21 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c8a1		75 73 65 72 61 64 64 72		        .text "useraddr"
.c8a9						nt_buffer_colon:
>c8a9		07 00				        .byte 7, 0
>c8ab		b8 c8 ac 85 b2 85		        .word +, xt_buffer_colon, z_buffer_colon
>c8b1		62 75 66 66 65 72 3a		        .text "buffer:"
.c8b8						+
.c8b8						nt_buffstatus:
>c8b8		0a 00				        .byte 10, 0
>c8ba		ca c8 b3 85 c2 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c8c0		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c8c8		75 73
.c8ca						nt_buffblocknum:
>c8ca		0c 00				        .byte 12, 0
>c8cc		de c8 6b 85 7a 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c8d2		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c8da		6b 6e 75 6d
.c8de						nt_blkbuffer:
>c8de		09 00				        .byte 9, 0
>c8e0		ef c8 79 83 86 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c8e6		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c8ee		72
.c8ef						nt_scr:
>c8ef		03 00				        .byte 3, 0
>c8f1		fa c8 83 9e 92 9e		        .word nt_blk, xt_scr, z_scr
>c8f7		73 63 72			        .text "scr"
.c8fa						nt_blk:
>c8fa		03 00				        .byte 3, 0
>c8fc		05 c9 69 83 78 83		        .word nt_block_write, xt_blk, z_blk
>c902		62 6c 6b			        .text "blk"
.c905						nt_block_write:
>c905		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c907		18 c9 26 85 34 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c90d		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c915		69 74 65
.c918						nt_block_write_vector:
>c918		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c91a		32 c9 34 85 43 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c920		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c928		69 74 65 2d 76 65 63 74 6f 72
.c932						nt_block_read:
>c932		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c934		44 c9 03 85 11 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c93a		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c942		61 64
.c944						nt_block_read_vector:
>c944		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c946		5d c9 11 85 20 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c94c		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c954		61 64 2d 76 65 63 74 6f 72
.c95d						nt_save_buffers:
>c95d		0c 00				        .byte 12, 0
>c95f		71 c9 68 9e 82 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c965		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c96d		66 65 72 73
.c971						nt_block:
>c971		05 00				        .byte 5, 0
>c973		7e c9 87 83 d9 83		        .word nt_update, xt_block, z_block
>c979		62 6c 6f 63 6b			        .text "block"
.c97e						nt_update:
>c97e		06 00				        .byte 6, 0
>c980		8c c9 0e a6 16 a6		        .word nt_buffer, xt_update, z_update
>c986		75 70 64 61 74 65		        .text "update"
.c98c						nt_buffer:
>c98c		06 00				        .byte 6, 0
>c98e		9a c9 7b 85 ab 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c994		62 75 66 66 65 72		        .text "buffer"
.c99a						nt_empty_buffers:
>c99a		0d 00				        .byte 13, 0
>c99c		af c9 bc 8d c2 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c9a2		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c9aa		66 66 65 72 73
.c9af						nt_flush:
>c9af		05 00				        .byte 5, 0
>c9b1		bc c9 4a 90 53 90		        .word nt_load, xt_flush, z_flush
>c9b7		66 6c 75 73 68			        .text "flush"
.c9bc						nt_load:
>c9bc		04 10				        .byte 4, UF
>c9be		c8 c9 8d 93 d0 93		        .word nt_thru, xt_load, z_load
>c9c4		6c 6f 61 64			        .text "load"
.c9c8						nt_thru:
>c9c8		04 10				        .byte 4, UF
>c9ca		d4 c9 76 a1 ba a1		        .word nt_list, xt_thru, z_thru
>c9d0		74 68 72 75			        .text "thru"
.c9d4						nt_list:
>c9d4		04 10				        .byte 4, UF
>c9d6		e0 c9 3e 93 4a 93		        .word +, xt_list, z_list
>c9dc		6c 69 73 74			        .text "list"
.c9e0						+
.c9e0						nt_block_ramdrive_init:
>c9e0		13 10				        .byte 19, UF
>c9e2		fb c9 da 83 02 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c9e8		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c9f0		6d 64 72 69 76 65 2d 69 6e 69 74
.c9fb						+
.c9fb						nt_definitions:
>c9fb		0b 00				        .byte 11, 0
>c9fd		0e ca c4 8a cc 8a		        .word nt_wordlist, xt_definitions, z_definitions
>ca03		64 65 66 69 6e 69 74 69		        .text "definitions"
>ca0b		6f 6e 73
.ca0e						nt_wordlist:
>ca0e		08 00				        .byte 8, 0
>ca10		1e ca ab a6 c1 a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>ca16		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.ca1e						nt_search_wordlist:
>ca1e		0f 10				        .byte 15, UF
>ca20		35 ca 79 9b 59 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>ca26		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>ca2e		6f 72 64 6c 69 73 74
.ca35						nt_set_current:
>ca35		0b 10				        .byte 11, UF
>ca37		48 ca e8 9c f3 9c		        .word nt_get_current, xt_set_current, z_set_current
>ca3d		73 65 74 2d 63 75 72 72		        .text "set-current"
>ca45		65 6e 74
.ca48						nt_get_current:
>ca48		0b 00				        .byte 11, 0
>ca4a		5b ca ec 90 f6 90		        .word nt_set_order, xt_get_current, z_get_current
>ca50		67 65 74 2d 63 75 72 72		        .text "get-current"
>ca58		65 6e 74
.ca5b						nt_set_order:
>ca5b		09 00				        .byte 9, 0
>ca5d		6c ca f4 9c 27 9d		        .word nt_get_order, xt_set_order, z_set_order
>ca63		73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca6b		72
.ca6c						nt_get_order:
>ca6c		09 00				        .byte 9, 0
>ca6e		7d ca f7 90 1f 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>ca74		67 65 74 2d 6f 72 64 65		        .text "get-order"
>ca7c		72
.ca7d						nt_root_wordlist:
>ca7d		0d 00				        .byte 13, 0
>ca7f		92 ca 27 9b 2f 9b		        .word +, xt_root_wordlist, z_root_wordlist
>ca85		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>ca8d		64 6c 69 73 74
.ca92						+
.ca92						nt_assembler_wordlist:
>ca92		12 00				        .byte 18, 0
>ca94		ac ca 51 a3 59 a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>ca9a		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>caa2		72 2d 77 6f 72 64 6c 69 73 74
.caac						+
.caac						nt_editor_wordlist:
>caac		0f 00				        .byte 15, 0
>caae		c3 ca e1 97 e9 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>cab4		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>cabc		6f 72 64 6c 69 73 74
.cac3						+
.cac3						nt_forth_wordlist:
>cac3		0e 00				        .byte 14, 0
>cac5		d9 ca 52 a7 58 a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>cacb		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>cad3		72 64 6c 69 73 74
.cad9						nt_only:
>cad9		04 00				        .byte 4, 0
>cadb		e5 ca 00 98 0b 98		        .word nt_also, xt_only, z_only
>cae1		6f 6e 6c 79			        .text "only"
.cae5						nt_also:
>cae5		04 00				        .byte 4, 0
>cae7		f1 ca c4 82 d3 82		        .word nt_previous, xt_also, z_also
>caed		61 6c 73 6f			        .text "also"
.caf1						nt_previous:
>caf1		08 00				        .byte 8, 0
>caf3		01 cb 2e 9a 3a 9a		        .word nt_to_order, xt_previous, z_previous
>caf9		70 72 65 76 69 6f 75 73		        .text "previous"
.cb01						nt_to_order:
>cb01		06 00				        .byte 6, 0
>cb03		0f cb 07 a3 19 a3		        .word nt_order, xt_to_order, z_to_order
>cb09		3e 6f 72 64 65 72		        .text ">order"
.cb0f						nt_order:
>cb0f		05 00				        .byte 5, 0
>cb11		1c cb 1e 98 48 98		        .word nt_forth, xt_order, z_order
>cb17		6f 72 64 65 72			        .text "order"
.cb1c						nt_forth:
>cb1c		05 00				        .byte 5, 0
>cb1e		29 cb 8b 90 91 90		        .word +, xt_forth, z_forth
>cb24		66 6f 72 74 68			        .text "forth"
.cb29						+
>cb29		03 08				nt_see: .byte 3, NN
>cb2b		34 cb 5a 9c e7 9c		        .word +, xt_see, z_see
>cb31		73 65 65			        .text "see"
.cb34						+
.cb34						nt_ed:
>cb34		02 08				        .byte 2, NN
>cb36		3e cb 80 8d 83 8d		        .word +, xt_ed, z_ed
>cb3c		65 64				        .text "ed"
.cb3e						+
.cb3e						nt_cold:
>cb3e		04 00				        .byte 4, 0
>cb40		4a cb 00 80 bd 80		        .word nt_bye, xt_cold, z_cold
>cb46		63 6f 6c 64			        .text "cold"
.cb4a						nt_bye:
>cb4a		03				        .byte 3         ; length of word strings
>cb4b		00				        .byte 0         ; status byte
>cb4c		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>cb4e		c3 85				        .word xt_bye    ; start of code block (xt of this word)
>cb50		c6 85				        .word z_bye     ; end of code (RTS)
>cb52		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.cb55						root_dictionary_start:
.cb55						nt_root_set_order:
>cb55		09 00				        .byte 9, 0
>cb57		66 cb f4 9c 27 9d		        .word nt_root_forth, xt_set_order, z_set_order
>cb5d		73 65 74 2d 6f 72 64 65		        .text "set-order"
>cb65		72
.cb66						nt_root_forth:
>cb66		05 00				        .byte 5, 0
>cb68		73 cb 8b 90 91 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>cb6e		66 6f 72 74 68			        .text "forth"
.cb73						nt_root_forth_wordlist:
>cb73		0e 00				        .byte 14, 0
>cb75		89 cb 52 a7 58 a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>cb7b		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>cb83		72 64 6c 69 73 74
.cb89						nt_root_words:
>cb89		05 00				        .byte 5, 0
>cb8b		00 00 c2 a6 1e a7		        .word 0000, xt_words, z_words
>cb91		77 6f 72 64 73			        .text "words"
.cb96						editor_dictionary_start:
.cb96						nt_editor_o:
>cb96		01 00				        .byte 1, 0
>cb98		9f cb 81 a8 c6 a8		        .word nt_editor_line, xt_editor_o, z_editor_o
>cb9e		6f				        .text "o"
.cb9f						nt_editor_line:
>cb9f		04 10				        .byte 4, UF
>cba1		ab cb 68 a8 80 a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>cba7		6c 69 6e 65			        .text "line"
.cbab						nt_editor_l:
>cbab		01 00				        .byte 1, 0
>cbad		b4 cb ec a7 67 a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cbb3		6c				        .text "l"
.cbb4						nt_editor_el:
>cbb4		02 00				        .byte 2, 0
>cbb6		be cb da a7 eb a7		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cbbc		65 6c				        .text "el"
.cbbe						nt_editor_erase_screen:
>cbbe		0c 00				        .byte 12, 0
>cbc0		d2 cb c8 a7 d9 a7		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cbc6		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cbce		72 65 65 6e
.cbd2						nt_editor_enter_screen:
>cbd2		0c 00				        .byte 12, 0
>cbd4		00 00 ac a7 c7 a7		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cbda		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cbe2		72 65 65 6e
.cbe6						assembler_dictionary_start:
.cbe6						nt_asm_adc_h:
>cbe6		05 0c						.byte 5, IM+NN
>cbe8		f3 cb				                .word nt_asm_adc_x
>cbea		1b a9 20 a9					.word xt_asm_adc_h, z_asm_adc_h
>cbee		61 64 63 2e 23					.text "adc.#"
.cbf3						nt_asm_adc_x:
>cbf3		05 0c						.byte 5, IM+NN
>cbf5		00 cc				                .word nt_asm_adc_y
>cbf7		20 a9 25 a9					.word xt_asm_adc_x, z_asm_adc_x
>cbfb		61 64 63 2e 78					.text "adc.x"
.cc00						nt_asm_adc_y:
>cc00		05 0c						.byte 5, IM+NN
>cc02		0d cc				                .word nt_asm_adc_z
>cc04		25 a9 2a a9					.word xt_asm_adc_y, z_asm_adc_y
>cc08		61 64 63 2e 79					.text "adc.y"
.cc0d						nt_asm_adc_z:
>cc0d		05 0c						.byte 5, IM+NN
>cc0f		1a cc				                .word nt_asm_adc_zi
>cc11		2a a9 2f a9					.word xt_asm_adc_z, z_asm_adc_z
>cc15		61 64 63 2e 7a					.text "adc.z"
.cc1a						nt_asm_adc_zi:
>cc1a		06 0c						.byte 6, IM+NN
>cc1c		28 cc				                .word nt_asm_adc_ziy
>cc1e		2f a9 34 a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cc22		61 64 63 2e 7a 69				.text "adc.zi"
.cc28						nt_asm_adc_ziy:
>cc28		07 0c						.byte 7, IM+NN
>cc2a		37 cc				                .word nt_asm_adc_zx
>cc2c		34 a9 39 a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cc30		61 64 63 2e 7a 69 79				.text "adc.ziy"
.cc37						nt_asm_adc_zx:
>cc37		06 0c						.byte 6, IM+NN
>cc39		45 cc				                .word nt_asm_adc_zxi
>cc3b		39 a9 3e a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cc3f		61 64 63 2e 7a 78				.text "adc.zx"
.cc45						nt_asm_adc_zxi:
>cc45		07 0c						.byte 7, IM+NN
>cc47		54 cc				                .word nt_asm_and
>cc49		3e a9 43 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cc4d		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cc54						nt_asm_and:
>cc54		04 0c						.byte 4, IM+NN
>cc56		60 cc				                .word nt_asm_and_h
>cc58		43 a9 48 a9					.word xt_asm_and, z_asm_and
>cc5c		61 6e 64 2e					.text "and."
.cc60						nt_asm_and_h:
>cc60		05 0c						.byte 5, IM+NN
>cc62		6d cc				                .word nt_asm_and_x
>cc64		48 a9 4d a9					.word xt_asm_and_h, z_asm_and_h
>cc68		61 6e 64 2e 23					.text "and.#"
.cc6d						nt_asm_and_x:
>cc6d		05 0c						.byte 5, IM+NN
>cc6f		7a cc				                .word nt_asm_and_y
>cc71		4d a9 52 a9					.word xt_asm_and_x, z_asm_and_x
>cc75		61 6e 64 2e 78					.text "and.x"
.cc7a						nt_asm_and_y:
>cc7a		05 0c						.byte 5, IM+NN
>cc7c		87 cc				                .word nt_asm_and_z
>cc7e		52 a9 57 a9					.word xt_asm_and_y, z_asm_and_y
>cc82		61 6e 64 2e 79					.text "and.y"
.cc87						nt_asm_and_z:
>cc87		05 0c						.byte 5, IM+NN
>cc89		94 cc				                .word nt_asm_and_zi
>cc8b		57 a9 5c a9					.word xt_asm_and_z, z_asm_and_z
>cc8f		61 6e 64 2e 7a					.text "and.z"
.cc94						nt_asm_and_zi:
>cc94		06 0c						.byte 6, IM+NN
>cc96		a2 cc				                .word nt_asm_and_ziy
>cc98		5c a9 61 a9					.word xt_asm_and_zi, z_asm_and_zi
>cc9c		61 6e 64 2e 7a 69				.text "and.zi"
.cca2						nt_asm_and_ziy:
>cca2		07 0c						.byte 7, IM+NN
>cca4		b1 cc				                .word nt_asm_and_zx
>cca6		61 a9 66 a9					.word xt_asm_and_ziy, z_asm_and_ziy
>ccaa		61 6e 64 2e 7a 69 79				.text "and.ziy"
.ccb1						nt_asm_and_zx:
>ccb1		06 0c						.byte 6, IM+NN
>ccb3		bf cc				                .word nt_asm_and_zxi
>ccb5		66 a9 6b a9					.word xt_asm_and_zx, z_asm_and_zx
>ccb9		61 6e 64 2e 7a 78				.text "and.zx"
.ccbf						nt_asm_and_zxi:
>ccbf		07 0c						.byte 7, IM+NN
>ccc1		ce cc				                .word nt_asm_asl
>ccc3		6b a9 70 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>ccc7		61 6e 64 2e 7a 78 69				.text "and.zxi"
.ccce						nt_asm_asl:
>ccce		03 0c						.byte 3, IM+NN
>ccd0		d9 cc				                .word nt_asm_asl_a
>ccd2		70 a9 75 a9					.word xt_asm_asl, z_asm_asl
>ccd6		61 73 6c					.text "asl"
.ccd9						nt_asm_asl_a:
>ccd9		05 0c						.byte 5, IM+NN
>ccdb		e6 cc				                .word nt_asm_asl_x
>ccdd		75 a9 7a a9					.word xt_asm_asl_a, z_asm_asl_a
>cce1		61 73 6c 2e 61					.text "asl.a"
.cce6						nt_asm_asl_x:
>cce6		05 0c						.byte 5, IM+NN
>cce8		f3 cc				                .word nt_asm_asl_z
>ccea		7a a9 7f a9					.word xt_asm_asl_x, z_asm_asl_x
>ccee		61 73 6c 2e 78					.text "asl.x"
.ccf3						nt_asm_asl_z:
>ccf3		05 0c						.byte 5, IM+NN
>ccf5		00 cd				                .word nt_asm_asl_zx
>ccf7		7f a9 84 a9					.word xt_asm_asl_z, z_asm_asl_z
>ccfb		61 73 6c 2e 7a					.text "asl.z"
.cd00						nt_asm_asl_zx:
>cd00		06 0c						.byte 6, IM+NN
>cd02		0e cd				                .word nt_asm_bcc
>cd04		84 a9 89 a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cd08		61 73 6c 2e 7a 78				.text "asl.zx"
.cd0e						nt_asm_bcc:
>cd0e		03 0c						.byte 3, IM+NN
>cd10		19 cd				                .word nt_asm_bcs
>cd12		89 a9 8e a9					.word xt_asm_bcc, z_asm_bcc
>cd16		62 63 63					.text "bcc"
.cd19						nt_asm_bcs:
>cd19		03 0c						.byte 3, IM+NN
>cd1b		24 cd				                .word nt_asm_beq
>cd1d		8e a9 95 a9					.word xt_asm_bcs, z_asm_bcs
>cd21		62 63 73					.text "bcs"
.cd24						nt_asm_beq:
>cd24		03 0c						.byte 3, IM+NN
>cd26		2f cd				                .word nt_asm_bit
>cd28		95 a9 9a a9					.word xt_asm_beq, z_asm_beq
>cd2c		62 65 71					.text "beq"
.cd2f						nt_asm_bit:
>cd2f		03 0c						.byte 3, IM+NN
>cd31		3a cd				                .word nt_asm_bit_h
>cd33		9a a9 9f a9					.word xt_asm_bit, z_asm_bit
>cd37		62 69 74					.text "bit"
.cd3a						nt_asm_bit_h:
>cd3a		05 0c						.byte 5, IM+NN
>cd3c		47 cd				                .word nt_asm_bit_x
>cd3e		9f a9 a4 a9					.word xt_asm_bit_h, z_asm_bit_h
>cd42		62 69 74 2e 23					.text "bit.#"
.cd47						nt_asm_bit_x:
>cd47		05 0c						.byte 5, IM+NN
>cd49		54 cd				                .word nt_asm_bit_z
>cd4b		a4 a9 a9 a9					.word xt_asm_bit_x, z_asm_bit_x
>cd4f		62 69 74 2e 78					.text "bit.x"
.cd54						nt_asm_bit_z:
>cd54		05 0c						.byte 5, IM+NN
>cd56		61 cd				                .word nt_asm_bit_zx
>cd58		a9 a9 ae a9					.word xt_asm_bit_z, z_asm_bit_z
>cd5c		62 69 74 2e 7a					.text "bit.z"
.cd61						nt_asm_bit_zx:
>cd61		06 0c						.byte 6, IM+NN
>cd63		6f cd				                .word nt_asm_bmi
>cd65		ae a9 b3 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cd69		62 69 74 2e 7a 78				.text "bit.zx"
.cd6f						nt_asm_bmi:
>cd6f		03 0c						.byte 3, IM+NN
>cd71		7a cd				                .word nt_asm_bne
>cd73		b3 a9 b8 a9					.word xt_asm_bmi, z_asm_bmi
>cd77		62 6d 69					.text "bmi"
.cd7a						nt_asm_bne:
>cd7a		03 0c						.byte 3, IM+NN
>cd7c		85 cd				                .word nt_asm_bpl
>cd7e		b8 a9 bd a9					.word xt_asm_bne, z_asm_bne
>cd82		62 6e 65					.text "bne"
.cd85						nt_asm_bpl:
>cd85		03 0c						.byte 3, IM+NN
>cd87		90 cd				                .word nt_asm_bra
>cd89		bd a9 c2 a9					.word xt_asm_bpl, z_asm_bpl
>cd8d		62 70 6c					.text "bpl"
.cd90						nt_asm_bra:
>cd90		03 0c						.byte 3, IM+NN
>cd92		9b cd				                .word nt_asm_brk
>cd94		c2 a9 c7 a9					.word xt_asm_bra, z_asm_bra
>cd98		62 72 61					.text "bra"
.cd9b						nt_asm_brk:
>cd9b		03 0c						.byte 3, IM+NN
>cd9d		a6 cd				                .word nt_asm_bvc
>cd9f		c7 a9 cc a9					.word xt_asm_brk, z_asm_brk
>cda3		62 72 6b					.text "brk"
.cda6						nt_asm_bvc:
>cda6		03 0c						.byte 3, IM+NN
>cda8		b1 cd				                .word nt_asm_bvs
>cdaa		cc a9 d1 a9					.word xt_asm_bvc, z_asm_bvc
>cdae		62 76 63					.text "bvc"
.cdb1						nt_asm_bvs:
>cdb1		03 0c						.byte 3, IM+NN
>cdb3		bc cd				                .word nt_asm_clc
>cdb5		d1 a9 d6 a9					.word xt_asm_bvs, z_asm_bvs
>cdb9		62 76 73					.text "bvs"
.cdbc						nt_asm_clc:
>cdbc		03 0c						.byte 3, IM+NN
>cdbe		c7 cd				                .word nt_asm_cld
>cdc0		d6 a9 db a9					.word xt_asm_clc, z_asm_clc
>cdc4		63 6c 63					.text "clc"
.cdc7						nt_asm_cld:
>cdc7		03 0c						.byte 3, IM+NN
>cdc9		d2 cd				                .word nt_asm_cli
>cdcb		db a9 e0 a9					.word xt_asm_cld, z_asm_cld
>cdcf		63 6c 64					.text "cld"
.cdd2						nt_asm_cli:
>cdd2		03 0c						.byte 3, IM+NN
>cdd4		dd cd				                .word nt_asm_clv
>cdd6		e0 a9 e5 a9					.word xt_asm_cli, z_asm_cli
>cdda		63 6c 69					.text "cli"
.cddd						nt_asm_clv:
>cddd		03 0c						.byte 3, IM+NN
>cddf		e8 cd				                .word nt_asm_cmp
>cde1		e5 a9 ea a9					.word xt_asm_clv, z_asm_clv
>cde5		63 6c 76					.text "clv"
.cde8						nt_asm_cmp:
>cde8		03 0c						.byte 3, IM+NN
>cdea		f3 cd				                .word nt_asm_cmp_h
>cdec		ea a9 ef a9					.word xt_asm_cmp, z_asm_cmp
>cdf0		63 6d 70					.text "cmp"
.cdf3						nt_asm_cmp_h:
>cdf3		05 0c						.byte 5, IM+NN
>cdf5		00 ce				                .word nt_asm_cmp_x
>cdf7		ef a9 f4 a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cdfb		63 6d 70 2e 23					.text "cmp.#"
.ce00						nt_asm_cmp_x:
>ce00		05 0c						.byte 5, IM+NN
>ce02		0d ce				                .word nt_asm_cmp_y
>ce04		f4 a9 f9 a9					.word xt_asm_cmp_x, z_asm_cmp_x
>ce08		63 6d 70 2e 78					.text "cmp.x"
.ce0d						nt_asm_cmp_y:
>ce0d		05 0c						.byte 5, IM+NN
>ce0f		1a ce				                .word nt_asm_cmp_z
>ce11		f9 a9 fe a9					.word xt_asm_cmp_y, z_asm_cmp_y
>ce15		63 6d 70 2e 79					.text "cmp.y"
.ce1a						nt_asm_cmp_z:
>ce1a		05 0c						.byte 5, IM+NN
>ce1c		27 ce				                .word nt_asm_cmp_zi
>ce1e		fe a9 03 aa					.word xt_asm_cmp_z, z_asm_cmp_z
>ce22		63 6d 70 2e 7a					.text "cmp.z"
.ce27						nt_asm_cmp_zi:
>ce27		06 0c						.byte 6, IM+NN
>ce29		35 ce				                .word nt_asm_cmp_ziy
>ce2b		03 aa 08 aa					.word xt_asm_cmp_zi, z_asm_cmp_zi
>ce2f		63 6d 70 2e 7a 69				.text "cmp.zi"
.ce35						nt_asm_cmp_ziy:
>ce35		07 0c						.byte 7, IM+NN
>ce37		44 ce				                .word nt_asm_cmp_zx
>ce39		08 aa 0d aa					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>ce3d		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.ce44						nt_asm_cmp_zx:
>ce44		06 0c						.byte 6, IM+NN
>ce46		52 ce				                .word nt_asm_cmp_zxi
>ce48		0d aa 12 aa					.word xt_asm_cmp_zx, z_asm_cmp_zx
>ce4c		63 6d 70 2e 7a 78				.text "cmp.zx"
.ce52						nt_asm_cmp_zxi:
>ce52		07 0c						.byte 7, IM+NN
>ce54		61 ce				                .word nt_asm_cpx
>ce56		12 aa 17 aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>ce5a		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.ce61						nt_asm_cpx:
>ce61		03 0c						.byte 3, IM+NN
>ce63		6c ce				                .word nt_asm_cpx_h
>ce65		17 aa 1c aa					.word xt_asm_cpx, z_asm_cpx
>ce69		63 70 78					.text "cpx"
.ce6c						nt_asm_cpx_h:
>ce6c		05 0c						.byte 5, IM+NN
>ce6e		79 ce				                .word nt_asm_cpx_z
>ce70		1c aa 21 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>ce74		63 70 78 2e 23					.text "cpx.#"
.ce79						nt_asm_cpx_z:
>ce79		05 0c						.byte 5, IM+NN
>ce7b		86 ce				                .word nt_asm_cpy
>ce7d		21 aa 26 aa					.word xt_asm_cpx_z, z_asm_cpx_z
>ce81		63 70 78 2e 7a					.text "cpx.z"
.ce86						nt_asm_cpy:
>ce86		03 0c						.byte 3, IM+NN
>ce88		91 ce				                .word nt_asm_cpy_h
>ce8a		26 aa 2d aa					.word xt_asm_cpy, z_asm_cpy
>ce8e		63 70 79					.text "cpy"
.ce91						nt_asm_cpy_h:
>ce91		05 0c						.byte 5, IM+NN
>ce93		9e ce				                .word nt_asm_cpy_z
>ce95		2d aa 32 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>ce99		63 70 79 2e 23					.text "cpy.#"
.ce9e						nt_asm_cpy_z:
>ce9e		05 0c						.byte 5, IM+NN
>cea0		ab ce				                .word nt_asm_dec
>cea2		32 aa 37 aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cea6		63 70 79 2e 7a					.text "cpy.z"
.ceab						nt_asm_dec:
>ceab		03 0c						.byte 3, IM+NN
>cead		b6 ce				                .word nt_asm_dec_a
>ceaf		37 aa 3c aa					.word xt_asm_dec, z_asm_dec
>ceb3		64 65 63					.text "dec"
.ceb6						nt_asm_dec_a:
>ceb6		05 0c						.byte 5, IM+NN
>ceb8		c3 ce				                .word nt_asm_dec_x
>ceba		3c aa 41 aa					.word xt_asm_dec_a, z_asm_dec_a
>cebe		64 65 63 2e 61					.text "dec.a"
.cec3						nt_asm_dec_x:
>cec3		05 0c						.byte 5, IM+NN
>cec5		d0 ce				                .word nt_asm_dec_z
>cec7		41 aa 46 aa					.word xt_asm_dec_x, z_asm_dec_x
>cecb		64 65 63 2e 78					.text "dec.x"
.ced0						nt_asm_dec_z:
>ced0		05 0c						.byte 5, IM+NN
>ced2		dd ce				                .word nt_asm_dec_zx
>ced4		46 aa 4b aa					.word xt_asm_dec_z, z_asm_dec_z
>ced8		64 65 63 2e 7a					.text "dec.z"
.cedd						nt_asm_dec_zx:
>cedd		06 0c						.byte 6, IM+NN
>cedf		eb ce				                .word nt_asm_dex
>cee1		4b aa 50 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cee5		64 65 63 2e 7a 78				.text "dec.zx"
.ceeb						nt_asm_dex:
>ceeb		03 0c						.byte 3, IM+NN
>ceed		f6 ce				                .word nt_asm_dey
>ceef		50 aa 55 aa					.word xt_asm_dex, z_asm_dex
>cef3		64 65 78					.text "dex"
.cef6						nt_asm_dey:
>cef6		03 0c						.byte 3, IM+NN
>cef8		01 cf				                .word nt_asm_eor
>cefa		55 aa 5a aa					.word xt_asm_dey, z_asm_dey
>cefe		64 65 79					.text "dey"
.cf01						nt_asm_eor:
>cf01		03 0c						.byte 3, IM+NN
>cf03		0c cf				                .word nt_asm_eor_h
>cf05		5a aa 5f aa					.word xt_asm_eor, z_asm_eor
>cf09		65 6f 72					.text "eor"
.cf0c						nt_asm_eor_h:
>cf0c		05 0c						.byte 5, IM+NN
>cf0e		19 cf				                .word nt_asm_eor_x
>cf10		5f aa 64 aa					.word xt_asm_eor_h, z_asm_eor_h
>cf14		65 6f 72 2e 23					.text "eor.#"
.cf19						nt_asm_eor_x:
>cf19		05 0c						.byte 5, IM+NN
>cf1b		26 cf				                .word nt_asm_eor_y
>cf1d		64 aa 69 aa					.word xt_asm_eor_x, z_asm_eor_x
>cf21		65 6f 72 2e 78					.text "eor.x"
.cf26						nt_asm_eor_y:
>cf26		05 0c						.byte 5, IM+NN
>cf28		33 cf				                .word nt_asm_eor_z
>cf2a		69 aa 6e aa					.word xt_asm_eor_y, z_asm_eor_y
>cf2e		65 6f 72 2e 79					.text "eor.y"
.cf33						nt_asm_eor_z:
>cf33		05 0c						.byte 5, IM+NN
>cf35		40 cf				                .word nt_asm_eor_zi
>cf37		6e aa 73 aa					.word xt_asm_eor_z, z_asm_eor_z
>cf3b		65 6f 72 2e 7a					.text "eor.z"
.cf40						nt_asm_eor_zi:
>cf40		06 0c						.byte 6, IM+NN
>cf42		4e cf				                .word nt_asm_eor_ziy
>cf44		73 aa 78 aa					.word xt_asm_eor_zi, z_asm_eor_zi
>cf48		65 6f 72 2e 7a 69				.text "eor.zi"
.cf4e						nt_asm_eor_ziy:
>cf4e		07 0c						.byte 7, IM+NN
>cf50		5d cf				                .word nt_asm_eor_zx
>cf52		78 aa 7d aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cf56		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cf5d						nt_asm_eor_zx:
>cf5d		06 0c						.byte 6, IM+NN
>cf5f		6b cf				                .word nt_asm_eor_zxi
>cf61		7d aa 82 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>cf65		65 6f 72 2e 7a 78				.text "eor.zx"
.cf6b						nt_asm_eor_zxi:
>cf6b		07 0c						.byte 7, IM+NN
>cf6d		7a cf				                .word nt_asm_inc
>cf6f		82 aa 87 aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cf73		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cf7a						nt_asm_inc:
>cf7a		03 0c						.byte 3, IM+NN
>cf7c		85 cf				                .word nt_asm_inc_a
>cf7e		87 aa 8c aa					.word xt_asm_inc, z_asm_inc
>cf82		69 6e 63					.text "inc"
.cf85						nt_asm_inc_a:
>cf85		05 0c						.byte 5, IM+NN
>cf87		92 cf				                .word nt_asm_inc_x
>cf89		8c aa 91 aa					.word xt_asm_inc_a, z_asm_inc_a
>cf8d		69 6e 63 2e 61					.text "inc.a"
.cf92						nt_asm_inc_x:
>cf92		05 0c						.byte 5, IM+NN
>cf94		9f cf				                .word nt_asm_inc_z
>cf96		91 aa 96 aa					.word xt_asm_inc_x, z_asm_inc_x
>cf9a		69 6e 63 2e 78					.text "inc.x"
.cf9f						nt_asm_inc_z:
>cf9f		05 0c						.byte 5, IM+NN
>cfa1		ac cf				                .word nt_asm_inc_zx
>cfa3		96 aa 9b aa					.word xt_asm_inc_z, z_asm_inc_z
>cfa7		69 6e 63 2e 7a					.text "inc.z"
.cfac						nt_asm_inc_zx:
>cfac		06 0c						.byte 6, IM+NN
>cfae		ba cf				                .word nt_asm_inx
>cfb0		9b aa a0 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>cfb4		69 6e 63 2e 7a 78				.text "inc.zx"
.cfba						nt_asm_inx:
>cfba		03 0c						.byte 3, IM+NN
>cfbc		c5 cf				                .word nt_asm_iny
>cfbe		a0 aa a5 aa					.word xt_asm_inx, z_asm_inx
>cfc2		69 6e 78					.text "inx"
.cfc5						nt_asm_iny:
>cfc5		03 0c						.byte 3, IM+NN
>cfc7		d0 cf				                .word nt_asm_jmp
>cfc9		a5 aa aa aa					.word xt_asm_iny, z_asm_iny
>cfcd		69 6e 79					.text "iny"
.cfd0						nt_asm_jmp:
>cfd0		03 0c						.byte 3, IM+NN
>cfd2		db cf				                .word nt_asm_jmp_i
>cfd4		aa aa af aa					.word xt_asm_jmp, z_asm_jmp
>cfd8		6a 6d 70					.text "jmp"
.cfdb						nt_asm_jmp_i:
>cfdb		05 0c						.byte 5, IM+NN
>cfdd		e8 cf				                .word nt_asm_jmp_xi
>cfdf		af aa b4 aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cfe3		6a 6d 70 2e 69					.text "jmp.i"
.cfe8						nt_asm_jmp_xi:
>cfe8		06 0c						.byte 6, IM+NN
>cfea		f6 cf				                .word nt_asm_jsr
>cfec		b4 aa b9 aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cff0		6a 6d 70 2e 78 69				.text "jmp.xi"
.cff6						nt_asm_jsr:
>cff6		03 0c						.byte 3, IM+NN
>cff8		01 d0				                .word nt_asm_lda
>cffa		b9 aa be aa					.word xt_asm_jsr, z_asm_jsr
>cffe		6a 73 72					.text "jsr"
.d001						nt_asm_lda:
>d001		03 0c						.byte 3, IM+NN
>d003		0c d0				                .word nt_asm_lda_h
>d005		be aa c3 aa					.word xt_asm_lda, z_asm_lda
>d009		6c 64 61					.text "lda"
.d00c						nt_asm_lda_h:
>d00c		05 0c						.byte 5, IM+NN
>d00e		19 d0				                .word nt_asm_lda_x
>d010		c3 aa c8 aa					.word xt_asm_lda_h, z_asm_lda_h
>d014		6c 64 61 2e 23					.text "lda.#"
.d019						nt_asm_lda_x:
>d019		05 0c						.byte 5, IM+NN
>d01b		26 d0				                .word nt_asm_lda_y
>d01d		c8 aa cd aa					.word xt_asm_lda_x, z_asm_lda_x
>d021		6c 64 61 2e 78					.text "lda.x"
.d026						nt_asm_lda_y:
>d026		05 0c						.byte 5, IM+NN
>d028		33 d0				                .word nt_asm_lda_z
>d02a		cd aa d2 aa					.word xt_asm_lda_y, z_asm_lda_y
>d02e		6c 64 61 2e 79					.text "lda.y"
.d033						nt_asm_lda_z:
>d033		05 0c						.byte 5, IM+NN
>d035		40 d0				                .word nt_asm_lda_zi
>d037		d2 aa d7 aa					.word xt_asm_lda_z, z_asm_lda_z
>d03b		6c 64 61 2e 7a					.text "lda.z"
.d040						nt_asm_lda_zi:
>d040		06 0c						.byte 6, IM+NN
>d042		4e d0				                .word nt_asm_lda_ziy
>d044		d7 aa dc aa					.word xt_asm_lda_zi, z_asm_lda_zi
>d048		6c 64 61 2e 7a 69				.text "lda.zi"
.d04e						nt_asm_lda_ziy:
>d04e		07 0c						.byte 7, IM+NN
>d050		5d d0				                .word nt_asm_lda_zx
>d052		dc aa e1 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>d056		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.d05d						nt_asm_lda_zx:
>d05d		06 0c						.byte 6, IM+NN
>d05f		6b d0				                .word nt_asm_lda_zxi
>d061		e1 aa e6 aa					.word xt_asm_lda_zx, z_asm_lda_zx
>d065		6c 64 61 2e 7a 78				.text "lda.zx"
.d06b						nt_asm_lda_zxi:
>d06b		07 0c						.byte 7, IM+NN
>d06d		7a d0				                .word nt_asm_ldx
>d06f		e6 aa eb aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>d073		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.d07a						nt_asm_ldx:
>d07a		03 0c						.byte 3, IM+NN
>d07c		85 d0				                .word nt_asm_ldx_h
>d07e		eb aa f0 aa					.word xt_asm_ldx, z_asm_ldx
>d082		6c 64 78					.text "ldx"
.d085						nt_asm_ldx_h:
>d085		05 0c						.byte 5, IM+NN
>d087		92 d0				                .word nt_asm_ldx_y
>d089		f0 aa f5 aa					.word xt_asm_ldx_h, z_asm_ldx_h
>d08d		6c 64 78 2e 23					.text "ldx.#"
.d092						nt_asm_ldx_y:
>d092		05 0c						.byte 5, IM+NN
>d094		9f d0				                .word nt_asm_ldx_z
>d096		f5 aa fa aa					.word xt_asm_ldx_y, z_asm_ldx_y
>d09a		6c 64 78 2e 79					.text "ldx.y"
.d09f						nt_asm_ldx_z:
>d09f		05 0c						.byte 5, IM+NN
>d0a1		ac d0				                .word nt_asm_ldx_zy
>d0a3		fa aa ff aa					.word xt_asm_ldx_z, z_asm_ldx_z
>d0a7		6c 64 78 2e 7a					.text "ldx.z"
.d0ac						nt_asm_ldx_zy:
>d0ac		06 0c						.byte 6, IM+NN
>d0ae		ba d0				                .word nt_asm_ldy
>d0b0		ff aa 04 ab					.word xt_asm_ldx_zy, z_asm_ldx_zy
>d0b4		6c 64 78 2e 7a 79				.text "ldx.zy"
.d0ba						nt_asm_ldy:
>d0ba		03 0c						.byte 3, IM+NN
>d0bc		c5 d0				                .word nt_asm_ldy_h
>d0be		04 ab 09 ab					.word xt_asm_ldy, z_asm_ldy
>d0c2		6c 64 79					.text "ldy"
.d0c5						nt_asm_ldy_h:
>d0c5		05 0c						.byte 5, IM+NN
>d0c7		d2 d0				                .word nt_asm_ldy_x
>d0c9		09 ab 0e ab					.word xt_asm_ldy_h, z_asm_ldy_h
>d0cd		6c 64 79 2e 23					.text "ldy.#"
.d0d2						nt_asm_ldy_x:
>d0d2		05 0c						.byte 5, IM+NN
>d0d4		df d0				                .word nt_asm_ldy_z
>d0d6		0e ab 13 ab					.word xt_asm_ldy_x, z_asm_ldy_x
>d0da		6c 64 79 2e 78					.text "ldy.x"
.d0df						nt_asm_ldy_z:
>d0df		05 0c						.byte 5, IM+NN
>d0e1		ec d0				                .word nt_asm_ldy_zx
>d0e3		13 ab 18 ab					.word xt_asm_ldy_z, z_asm_ldy_z
>d0e7		6c 64 79 2e 7a					.text "ldy.z"
.d0ec						nt_asm_ldy_zx:
>d0ec		06 0c						.byte 6, IM+NN
>d0ee		fa d0				                .word nt_asm_lsr
>d0f0		18 ab 1d ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>d0f4		6c 64 79 2e 7a 78				.text "ldy.zx"
.d0fa						nt_asm_lsr:
>d0fa		03 0c						.byte 3, IM+NN
>d0fc		05 d1				                .word nt_asm_lsr_a
>d0fe		1d ab 22 ab					.word xt_asm_lsr, z_asm_lsr
>d102		6c 73 72					.text "lsr"
.d105						nt_asm_lsr_a:
>d105		05 0c						.byte 5, IM+NN
>d107		12 d1				                .word nt_asm_lsr_x
>d109		22 ab 27 ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d10d		6c 73 72 2e 61					.text "lsr.a"
.d112						nt_asm_lsr_x:
>d112		05 0c						.byte 5, IM+NN
>d114		1f d1				                .word nt_asm_lsr_z
>d116		27 ab 2c ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d11a		6c 73 72 2e 78					.text "lsr.x"
.d11f						nt_asm_lsr_z:
>d11f		05 0c						.byte 5, IM+NN
>d121		2c d1				                .word nt_asm_lsr_zx
>d123		2c ab 31 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d127		6c 73 72 2e 7a					.text "lsr.z"
.d12c						nt_asm_lsr_zx:
>d12c		06 0c						.byte 6, IM+NN
>d12e		3a d1				                .word nt_asm_nop
>d130		31 ab 36 ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d134		6c 73 72 2e 7a 78				.text "lsr.zx"
.d13a						nt_asm_nop:
>d13a		03 0c						.byte 3, IM+NN
>d13c		45 d1				                .word nt_asm_ora
>d13e		36 ab 3b ab					.word xt_asm_nop, z_asm_nop
>d142		6e 6f 70					.text "nop"
.d145						nt_asm_ora:
>d145		03 0c						.byte 3, IM+NN
>d147		50 d1				                .word nt_asm_ora_h
>d149		3b ab 40 ab					.word xt_asm_ora, z_asm_ora
>d14d		6f 72 61					.text "ora"
.d150						nt_asm_ora_h:
>d150		05 0c						.byte 5, IM+NN
>d152		5d d1				                .word nt_asm_ora_x
>d154		40 ab 45 ab					.word xt_asm_ora_h, z_asm_ora_h
>d158		6f 72 61 2e 23					.text "ora.#"
.d15d						nt_asm_ora_x:
>d15d		05 0c						.byte 5, IM+NN
>d15f		6a d1				                .word nt_asm_ora_y
>d161		45 ab 4a ab					.word xt_asm_ora_x, z_asm_ora_x
>d165		6f 72 61 2e 78					.text "ora.x"
.d16a						nt_asm_ora_y:
>d16a		05 0c						.byte 5, IM+NN
>d16c		77 d1				                .word nt_asm_ora_z
>d16e		4a ab 4f ab					.word xt_asm_ora_y, z_asm_ora_y
>d172		6f 72 61 2e 79					.text "ora.y"
.d177						nt_asm_ora_z:
>d177		05 0c						.byte 5, IM+NN
>d179		84 d1				                .word nt_asm_ora_zi
>d17b		4f ab 54 ab					.word xt_asm_ora_z, z_asm_ora_z
>d17f		6f 72 61 2e 7a					.text "ora.z"
.d184						nt_asm_ora_zi:
>d184		06 0c						.byte 6, IM+NN
>d186		92 d1				                .word nt_asm_ora_ziy
>d188		54 ab 5b ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d18c		6f 72 61 2e 7a 69				.text "ora.zi"
.d192						nt_asm_ora_ziy:
>d192		07 0c						.byte 7, IM+NN
>d194		a1 d1				                .word nt_asm_ora_zx
>d196		5b ab 60 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d19a		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d1a1						nt_asm_ora_zx:
>d1a1		06 0c						.byte 6, IM+NN
>d1a3		af d1				                .word nt_asm_ora_zxi
>d1a5		60 ab 65 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d1a9		6f 72 61 2e 7a 78				.text "ora.zx"
.d1af						nt_asm_ora_zxi:
>d1af		07 0c						.byte 7, IM+NN
>d1b1		be d1				                .word nt_asm_pha
>d1b3		65 ab 6a ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d1b7		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d1be						nt_asm_pha:
>d1be		03 0c						.byte 3, IM+NN
>d1c0		c9 d1				                .word nt_asm_php
>d1c2		6a ab 6f ab					.word xt_asm_pha, z_asm_pha
>d1c6		70 68 61					.text "pha"
.d1c9						nt_asm_php:
>d1c9		03 0c						.byte 3, IM+NN
>d1cb		d4 d1				                .word nt_asm_phx
>d1cd		6f ab 74 ab					.word xt_asm_php, z_asm_php
>d1d1		70 68 70					.text "php"
.d1d4						nt_asm_phx:
>d1d4		03 0c						.byte 3, IM+NN
>d1d6		df d1				                .word nt_asm_phy
>d1d8		74 ab 79 ab					.word xt_asm_phx, z_asm_phx
>d1dc		70 68 78					.text "phx"
.d1df						nt_asm_phy:
>d1df		03 0c						.byte 3, IM+NN
>d1e1		ea d1				                .word nt_asm_pla
>d1e3		79 ab 7e ab					.word xt_asm_phy, z_asm_phy
>d1e7		70 68 79					.text "phy"
.d1ea						nt_asm_pla:
>d1ea		03 0c						.byte 3, IM+NN
>d1ec		f5 d1				                .word nt_asm_plp
>d1ee		7e ab 83 ab					.word xt_asm_pla, z_asm_pla
>d1f2		70 6c 61					.text "pla"
.d1f5						nt_asm_plp:
>d1f5		03 0c						.byte 3, IM+NN
>d1f7		00 d2				                .word nt_asm_plx
>d1f9		83 ab 88 ab					.word xt_asm_plp, z_asm_plp
>d1fd		70 6c 70					.text "plp"
.d200						nt_asm_plx:
>d200		03 0c						.byte 3, IM+NN
>d202		0b d2				                .word nt_asm_ply
>d204		88 ab 8d ab					.word xt_asm_plx, z_asm_plx
>d208		70 6c 78					.text "plx"
.d20b						nt_asm_ply:
>d20b		03 0c						.byte 3, IM+NN
>d20d		16 d2				                .word nt_asm_rol
>d20f		8d ab 92 ab					.word xt_asm_ply, z_asm_ply
>d213		70 6c 79					.text "ply"
.d216						nt_asm_rol:
>d216		03 0c						.byte 3, IM+NN
>d218		21 d2				                .word nt_asm_rol_a
>d21a		92 ab 97 ab					.word xt_asm_rol, z_asm_rol
>d21e		72 6f 6c					.text "rol"
.d221						nt_asm_rol_a:
>d221		05 0c						.byte 5, IM+NN
>d223		2e d2				                .word nt_asm_rol_x
>d225		97 ab 9c ab					.word xt_asm_rol_a, z_asm_rol_a
>d229		72 6f 6c 2e 61					.text "rol.a"
.d22e						nt_asm_rol_x:
>d22e		05 0c						.byte 5, IM+NN
>d230		3b d2				                .word nt_asm_rol_z
>d232		9c ab a1 ab					.word xt_asm_rol_x, z_asm_rol_x
>d236		72 6f 6c 2e 78					.text "rol.x"
.d23b						nt_asm_rol_z:
>d23b		05 0c						.byte 5, IM+NN
>d23d		48 d2				                .word nt_asm_rol_zx
>d23f		a1 ab a6 ab					.word xt_asm_rol_z, z_asm_rol_z
>d243		72 6f 6c 2e 7a					.text "rol.z"
.d248						nt_asm_rol_zx:
>d248		06 0c						.byte 6, IM+NN
>d24a		56 d2				                .word nt_asm_ror
>d24c		a6 ab ab ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d250		72 6f 6c 2e 7a 78				.text "rol.zx"
.d256						nt_asm_ror:
>d256		03 0c						.byte 3, IM+NN
>d258		61 d2				                .word nt_asm_ror_a
>d25a		ab ab b0 ab					.word xt_asm_ror, z_asm_ror
>d25e		72 6f 72					.text "ror"
.d261						nt_asm_ror_a:
>d261		05 0c						.byte 5, IM+NN
>d263		6e d2				                .word nt_asm_ror_x
>d265		b0 ab b5 ab					.word xt_asm_ror_a, z_asm_ror_a
>d269		72 6f 72 2e 61					.text "ror.a"
.d26e						nt_asm_ror_x:
>d26e		05 0c						.byte 5, IM+NN
>d270		7b d2				                .word nt_asm_ror_z
>d272		b5 ab ba ab					.word xt_asm_ror_x, z_asm_ror_x
>d276		72 6f 72 2e 78					.text "ror.x"
.d27b						nt_asm_ror_z:
>d27b		05 0c						.byte 5, IM+NN
>d27d		88 d2				                .word nt_asm_ror_zx
>d27f		ba ab bf ab					.word xt_asm_ror_z, z_asm_ror_z
>d283		72 6f 72 2e 7a					.text "ror.z"
.d288						nt_asm_ror_zx:
>d288		06 0c						.byte 6, IM+NN
>d28a		96 d2				                .word nt_asm_rti
>d28c		bf ab c4 ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d290		72 6f 72 2e 7a 78				.text "ror.zx"
.d296						nt_asm_rti:
>d296		03 0c						.byte 3, IM+NN
>d298		a1 d2				                .word nt_asm_rts
>d29a		c4 ab c9 ab					.word xt_asm_rti, z_asm_rti
>d29e		72 74 69					.text "rti"
.d2a1						nt_asm_rts:
>d2a1		03 0c						.byte 3, IM+NN
>d2a3		ac d2				                .word nt_asm_sbc
>d2a5		c9 ab ce ab					.word xt_asm_rts, z_asm_rts
>d2a9		72 74 73					.text "rts"
.d2ac						nt_asm_sbc:
>d2ac		03 0c						.byte 3, IM+NN
>d2ae		b7 d2				                .word nt_asm_sbc_h
>d2b0		ce ab d3 ab					.word xt_asm_sbc, z_asm_sbc
>d2b4		73 62 63					.text "sbc"
.d2b7						nt_asm_sbc_h:
>d2b7		05 0c						.byte 5, IM+NN
>d2b9		c4 d2				                .word nt_asm_sbc_x
>d2bb		d3 ab d8 ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d2bf		73 62 63 2e 23					.text "sbc.#"
.d2c4						nt_asm_sbc_x:
>d2c4		05 0c						.byte 5, IM+NN
>d2c6		d1 d2				                .word nt_asm_sbc_y
>d2c8		d8 ab dd ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d2cc		73 62 63 2e 78					.text "sbc.x"
.d2d1						nt_asm_sbc_y:
>d2d1		05 0c						.byte 5, IM+NN
>d2d3		de d2				                .word nt_asm_sbc_z
>d2d5		dd ab e2 ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d2d9		73 62 63 2e 79					.text "sbc.y"
.d2de						nt_asm_sbc_z:
>d2de		05 0c						.byte 5, IM+NN
>d2e0		eb d2				                .word nt_asm_sbc_zi
>d2e2		e2 ab e7 ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d2e6		73 62 63 2e 7a					.text "sbc.z"
.d2eb						nt_asm_sbc_zi:
>d2eb		06 0c						.byte 6, IM+NN
>d2ed		f9 d2				                .word nt_asm_sbc_ziy
>d2ef		e7 ab ec ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d2f3		73 62 63 2e 7a 69				.text "sbc.zi"
.d2f9						nt_asm_sbc_ziy:
>d2f9		07 0c						.byte 7, IM+NN
>d2fb		08 d3				                .word nt_asm_sbc_zx
>d2fd		ec ab f1 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d301		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d308						nt_asm_sbc_zx:
>d308		06 0c						.byte 6, IM+NN
>d30a		16 d3				                .word nt_asm_sbc_zxi
>d30c		f1 ab f6 ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d310		73 62 63 2e 7a 78				.text "sbc.zx"
.d316						nt_asm_sbc_zxi:
>d316		07 0c						.byte 7, IM+NN
>d318		25 d3				                .word nt_asm_sec
>d31a		f6 ab fa ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d31e		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d325						nt_asm_sec:
>d325		03 0c						.byte 3, IM+NN
>d327		30 d3				                .word nt_asm_sed
>d329		fa ab fe ab					.word xt_asm_sec, z_asm_sec
>d32d		73 65 63					.text "sec"
.d330						nt_asm_sed:
>d330		03 0c						.byte 3, IM+NN
>d332		3b d3				                .word nt_asm_sei
>d334		fe ab 02 ac					.word xt_asm_sed, z_asm_sed
>d338		73 65 64					.text "sed"
.d33b						nt_asm_sei:
>d33b		03 0c						.byte 3, IM+NN
>d33d		46 d3				                .word nt_asm_sta
>d33f		02 ac 06 ac					.word xt_asm_sei, z_asm_sei
>d343		73 65 69					.text "sei"
.d346						nt_asm_sta:
>d346		03 0c						.byte 3, IM+NN
>d348		51 d3				                .word nt_asm_sta_x
>d34a		06 ac 0a ac					.word xt_asm_sta, z_asm_sta
>d34e		73 74 61					.text "sta"
.d351						nt_asm_sta_x:
>d351		05 0c						.byte 5, IM+NN
>d353		5e d3				                .word nt_asm_sta_y
>d355		0a ac 0e ac					.word xt_asm_sta_x, z_asm_sta_x
>d359		73 74 61 2e 78					.text "sta.x"
.d35e						nt_asm_sta_y:
>d35e		05 0c						.byte 5, IM+NN
>d360		6b d3				                .word nt_asm_sta_z
>d362		0e ac 12 ac					.word xt_asm_sta_y, z_asm_sta_y
>d366		73 74 61 2e 79					.text "sta.y"
.d36b						nt_asm_sta_z:
>d36b		05 0c						.byte 5, IM+NN
>d36d		78 d3				                .word nt_asm_sta_zi
>d36f		12 ac 16 ac					.word xt_asm_sta_z, z_asm_sta_z
>d373		73 74 61 2e 7a					.text "sta.z"
.d378						nt_asm_sta_zi:
>d378		06 0c						.byte 6, IM+NN
>d37a		86 d3				                .word nt_asm_sta_ziy
>d37c		16 ac 1a ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d380		73 74 61 2e 7a 69				.text "sta.zi"
.d386						nt_asm_sta_ziy:
>d386		07 0c						.byte 7, IM+NN
>d388		95 d3				                .word nt_asm_sta_zx
>d38a		1a ac 1e ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d38e		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d395						nt_asm_sta_zx:
>d395		06 0c						.byte 6, IM+NN
>d397		a3 d3				                .word nt_asm_sta_zxi
>d399		1e ac 22 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d39d		73 74 61 2e 7a 78				.text "sta.zx"
.d3a3						nt_asm_sta_zxi:
>d3a3		07 0c						.byte 7, IM+NN
>d3a5		b2 d3				                .word nt_asm_stx
>d3a7		22 ac 26 ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d3ab		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d3b2						nt_asm_stx:
>d3b2		03 0c						.byte 3, IM+NN
>d3b4		bd d3				                .word nt_asm_stx_z
>d3b6		26 ac 2a ac					.word xt_asm_stx, z_asm_stx
>d3ba		73 74 78					.text "stx"
.d3bd						nt_asm_stx_z:
>d3bd		05 0c						.byte 5, IM+NN
>d3bf		ca d3				                .word nt_asm_stx_zy
>d3c1		2a ac 2e ac					.word xt_asm_stx_z, z_asm_stx_z
>d3c5		73 74 78 2e 7a					.text "stx.z"
.d3ca						nt_asm_stx_zy:
>d3ca		06 0c						.byte 6, IM+NN
>d3cc		d8 d3				                .word nt_asm_sty
>d3ce		2e ac 32 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d3d2		73 74 78 2e 7a 79				.text "stx.zy"
.d3d8						nt_asm_sty:
>d3d8		03 0c						.byte 3, IM+NN
>d3da		e3 d3				                .word nt_asm_sty_z
>d3dc		32 ac 36 ac					.word xt_asm_sty, z_asm_sty
>d3e0		73 74 79					.text "sty"
.d3e3						nt_asm_sty_z:
>d3e3		05 0c						.byte 5, IM+NN
>d3e5		f0 d3				                .word nt_asm_sty_zx
>d3e7		36 ac 3a ac					.word xt_asm_sty_z, z_asm_sty_z
>d3eb		73 74 79 2e 7a					.text "sty.z"
.d3f0						nt_asm_sty_zx:
>d3f0		06 0c						.byte 6, IM+NN
>d3f2		fe d3				                .word nt_asm_stz
>d3f4		3a ac 3e ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d3f8		73 74 79 2e 7a 78				.text "sty.zx"
.d3fe						nt_asm_stz:
>d3fe		03 0c						.byte 3, IM+NN
>d400		09 d4				                .word nt_asm_stz_x
>d402		3e ac 42 ac					.word xt_asm_stz, z_asm_stz
>d406		73 74 7a					.text "stz"
.d409						nt_asm_stz_x:
>d409		05 0c						.byte 5, IM+NN
>d40b		16 d4				                .word nt_asm_stz_z
>d40d		42 ac 46 ac					.word xt_asm_stz_x, z_asm_stz_x
>d411		73 74 7a 2e 78					.text "stz.x"
.d416						nt_asm_stz_z:
>d416		05 0c						.byte 5, IM+NN
>d418		23 d4				                .word nt_asm_stz_zx
>d41a		46 ac 4a ac					.word xt_asm_stz_z, z_asm_stz_z
>d41e		73 74 7a 2e 7a					.text "stz.z"
.d423						nt_asm_stz_zx:
>d423		06 0c						.byte 6, IM+NN
>d425		31 d4				                .word nt_asm_tax
>d427		4a ac 4e ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d42b		73 74 7a 2e 7a 78				.text "stz.zx"
.d431						nt_asm_tax:
>d431		03 0c						.byte 3, IM+NN
>d433		3c d4				                .word nt_asm_tay
>d435		4e ac 52 ac					.word xt_asm_tax, z_asm_tax
>d439		74 61 78					.text "tax"
.d43c						nt_asm_tay:
>d43c		03 0c						.byte 3, IM+NN
>d43e		47 d4				                .word nt_asm_trb
>d440		52 ac 56 ac					.word xt_asm_tay, z_asm_tay
>d444		74 61 79					.text "tay"
.d447						nt_asm_trb:
>d447		03 0c						.byte 3, IM+NN
>d449		52 d4				                .word nt_asm_trb_z
>d44b		56 ac 5a ac					.word xt_asm_trb, z_asm_trb
>d44f		74 72 62					.text "trb"
.d452						nt_asm_trb_z:
>d452		05 0c						.byte 5, IM+NN
>d454		5f d4				                .word nt_asm_tsb
>d456		5a ac 5e ac					.word xt_asm_trb_z, z_asm_trb_z
>d45a		74 72 62 2e 7a					.text "trb.z"
.d45f						nt_asm_tsb:
>d45f		03 0c						.byte 3, IM+NN
>d461		6a d4				                .word nt_asm_tsb_z
>d463		5e ac 62 ac					.word xt_asm_tsb, z_asm_tsb
>d467		74 73 62					.text "tsb"
.d46a						nt_asm_tsb_z:
>d46a		05 0c						.byte 5, IM+NN
>d46c		77 d4				                .word nt_asm_tsx
>d46e		62 ac 66 ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d472		74 73 62 2e 7a					.text "tsb.z"
.d477						nt_asm_tsx:
>d477		03 0c						.byte 3, IM+NN
>d479		82 d4				                .word nt_asm_txa
>d47b		66 ac 6a ac					.word xt_asm_tsx, z_asm_tsx
>d47f		74 73 78					.text "tsx"
.d482						nt_asm_txa:
>d482		03 0c						.byte 3, IM+NN
>d484		8d d4				                .word nt_asm_txs
>d486		6a ac 6e ac					.word xt_asm_txa, z_asm_txa
>d48a		74 78 61					.text "txa"
.d48d						nt_asm_txs:
>d48d		03 0c						.byte 3, IM+NN
>d48f		98 d4				                .word nt_asm_tya
>d491		6e ac 72 ac					.word xt_asm_txs, z_asm_txs
>d495		74 78 73					.text "txs"
.d498						nt_asm_tya:
>d498		03 0c						.byte 3, IM+NN
>d49a		a3 d4				                .word nt_asm_arrow
>d49c		72 ac 76 ac					.word xt_asm_tya, z_asm_tya
>d4a0		74 79 61					.text "tya"
.d4a3						nt_asm_arrow:
>d4a3		03 04				                .byte 3, IM
>d4a5		ae d4				                .word nt_asm_back_jump
>d4a7		35 91 3f 91			                .word xt_asm_arrow, z_asm_arrow
>d4ab		2d 2d 3e			                .text "-->"
.d4ae						nt_asm_back_jump:
>d4ae		02 04				                .byte 2, IM
>d4b0		b8 d4				                .word nt_asm_back_branch
>d4b2		c7 ac c7 ac			                .word xt_asm_back_jump, z_asm_back_jump
>d4b6		3c 6a				                .text "<j"
.d4b8						nt_asm_back_branch:
>d4b8		02 04				                .byte 2, IM
>d4ba		c2 d4				                .word nt_asm_push_a
>d4bc		c8 ac d0 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d4c0		3c 62				                .text "<b"
.d4c2						nt_asm_push_a:
>d4c2		06 0c				                .byte 6, IM+NN
>d4c4		00 00				                .word 0000
>d4c6		b0 ac bf ac			                .word xt_asm_push_a, z_asm_push_a
>d4ca		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix
=1						ix += 1
=1						str_compile        = ix
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_sdc     = ix
=14						ix += 1
=14						str_disasm_bra     = ix
=15						ix += 1
.d4d0						string_table:
>d4d0		ee d4 f2 d4 fc d4 07 d5		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d4d8		3e d5 36 d5 2b d5 45 d5		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d4e0		4b d5 67 d5 6c d5 71 d5		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d4e8		82 d5 8b d5 9d d5		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 12-14
>d4ee		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d4f2		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d4fa		64 00
>d4fc		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d504		64 20 00
>d507		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d50f		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d51f		4f 50 51 52 53 54 55 56 57 58 59 5a
>d52b		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d533		72 20 00
>d536		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d53e		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d545		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d54b		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d553		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d563		29 3a 20 00
>d567		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d56c		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d571		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d579		63 69 6d 61 6c 29 3a 20 00
>d582		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d58a		00
>d58b		53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d593		50 54 48 20 43 48 45 43 4b 00
>d59d		42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d5a5						error_table:
>d5a5		c1 d5 e2 d5 02 d6 23 d6		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d5ad		40 d6 51 d6 61 d6 8f d6		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d5b5		a7 d6 c8 d6 dd d6 f9 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d5bd		10 d7 4f d7			        .word es_blockwords, es_returnstack                     ; 12-13
>d5c1		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d5c9		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d5d9		65 20 6d 65 6d 6f 72 79 00
>d5e2		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d5ea		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d5fa		20 52 45 46 49 4c 4c 00
>d602		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d60a		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d61a		6e 6c 79 20 77 6f 72 64 00
>d623		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d62b		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d63b		20 79 65 74 00
>d640		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d648		20 62 79 20 7a 65 72 6f 00
>d651		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d659		66 61 69 6c 75 72 65 00
>d661		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d669		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d679		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d689		64 20 2d 31 29 00
>d68f		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d697		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d6a7		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d6af		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d6bf		64 20 6e 75 6d 62 65 72 00
>d6c8		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d6d0		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d6dd		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d6e5		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d6f5		4c 4f 54 00
>d6f9		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d701		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d710		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d718		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d728		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d738		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d748		56 45 43 54 4f 52 00
>d74f		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d757		74 61 63 6b 3a 00
>d75d		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d765		44 2d 53 54 52 49 4e 47
>d76d		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d773		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d778		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d780		2d 55 4e 49 54 2d 42 49 54 53
>d78a		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d792		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d79a		52
>d79b		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d7a1		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d7a7		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d7af		53 54 41 43 4b 2d 43 45 4c 4c 53
>d7ba		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d7c2		45 4c 4c 53
>d7c6		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d7ce		54 53
>d7d0		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d7d6		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d7dd						cmpl_subroutine:
.d7dd		48		pha		                pha             ; save LSB of address
.d7de		a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d7e0		80 03		bra $d7e5	                bra cmpl_common
.d7e2						cmpl_jump:
.d7e2		48		pha		                pha             ; save LSB of address
.d7e3		a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d7e5						cmpl_common:
.d7e5		20 ed d7	jsr $d7ed	                jsr cmpl_a      ; compile opcode
.d7e8		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d7e9						cmpl_word:
.d7e9		20 ed d7	jsr $d7ed	                jsr cmpl_a      ; compile LSB of address
.d7ec		98		tya		                tya             ; fall thru for MSB
.d7ed						cmpl_a:
.d7ed		92 00		sta ($00)	                sta (cp)
.d7ef		e6 00		inc $00		                inc cp
.d7f1		d0 02		bne $d7f5	                bne _done
.d7f3		e6 01		inc $01		                inc cp+1
.d7f5						_done:
.d7f5		60		rts		                rts
.d7f6						doconst:
.d7f6		ca		dex		                dex             ; make room for constant
.d7f7		ca		dex		                dex
.d7f8		68		pla		                pla             ; LSB of return address
.d7f9		85 24		sta $24		                sta tmp1
.d7fb		68		pla		                pla             ; MSB of return address
.d7fc		85 25		sta $25		                sta tmp1+1
.d7fe		a0 01		ldy #$01	                ldy #1
.d800		b1 24		lda ($24),y	                lda (tmp1),y
.d802		95 00		sta $00,x	                sta 0,x
.d804		c8		iny		                iny
.d805		b1 24		lda ($24),y	                lda (tmp1),y
.d807		95 01		sta $01,x	                sta 1,x
.d809		60		rts		                rts
.d80a						dodefer:
.d80a		68		pla		                pla             ; LSB
.d80b		85 24		sta $24		                sta tmp1
.d80d		68		pla		                pla             ; MSB
.d80e		85 25		sta $25		                sta tmp1+1
.d810		a0 01		ldy #$01	                ldy #1
.d812		b1 24		lda ($24),y	                lda (tmp1),y
.d814		85 26		sta $26		                sta tmp2
.d816		c8		iny		                iny
.d817		b1 24		lda ($24),y	                lda (tmp1),y
.d819		85 27		sta $27		                sta tmp2+1
.d81b		6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d81e						defer_error:
.d81e		a9 03		lda #$03	                lda #err_defer
.d820		4c 5d d9	jmp $d95d	                jmp error
.d823						dodoes:
.d823		7a		ply		                ply             ; LSB
.d824		68		pla		                pla             ; MSB
.d825		c8		iny		                iny
.d826		d0 01		bne $d829	                bne +
.d828		1a		inc a		                ina
.d829						+
.d829		84 26		sty $26		                sty tmp2
.d82b		85 27		sta $27		                sta tmp2+1
.d82d		ca		dex		                dex
.d82e		ca		dex		                dex
.d82f		7a		ply		                ply
.d830		68		pla		                pla
.d831		c8		iny		                iny
.d832		d0 01		bne $d835	                bne +
.d834		1a		inc a		                ina
.d835						+
.d835		94 00		sty $00,x	                sty 0,x         ; LSB
.d837		95 01		sta $01,x	                sta 1,x         ; MSB
.d839		6c 26 00	jmp ($0026)	                jmp (tmp2)
.d83c						dovar:
.d83c		7a		ply		                ply             ; LSB
.d83d		68		pla		                pla             ; MSB
.d83e		c8		iny		                iny
.d83f		d0 01		bne $d842	                bne +
.d841		1a		inc a		                ina
.d842						+
.d842		ca		dex		                dex
.d843		ca		dex		                dex
.d844		95 01		sta $01,x	                sta 1,x
.d846		98		tya		                tya
.d847		95 00		sta $00,x	                sta 0,x
.d849		60		rts		                rts
.d84a						byte_to_ascii:
.d84a		48		pha		                pha
.d84b		4a		lsr a		                lsr             ; convert high nibble first
.d84c		4a		lsr a		                lsr
.d84d		4a		lsr a		                lsr
.d84e		4a		lsr a		                lsr
.d84f		20 53 d8	jsr $d853	                jsr _nibble_to_ascii
.d852		68		pla		                pla
.d853						_nibble_to_ascii:
.d853		29 0f		and #$0f	                and #$0F
.d855		09 30		ora #$30	                ora #'0'
.d857		c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d859		90 02		bcc $d85d	                bcc +
.d85b		69 06		adc #$06	                adc #$06
.d85d		4c b9 8d	jmp $8db9	+               jmp emit_a
.d860		60		rts		                rts
.d861						compare_16bit:
.d861		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d863		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d865		f0 0a		beq $d871	                beq _equal
.d867		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d869		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d86b		09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d86d		70 08		bvs $d877	                bvs _overflow
.d86f		80 08		bra $d879	                bra _not_equal
.d871						_equal:
.d871		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d873		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d875		50 04		bvc $d87b	                bvc _done
.d877						_overflow:
.d877		49 80		eor #$80	                eor #$80                ; complement negative flag
.d879						_not_equal:
.d879		09 01		ora #$01	                ora #1                  ; if overflow, we can't be equal
.d87b						_done:
.d87b		60		rts		                rts
.d87c						current_to_dp:
.d87c		a0 04		ldy #$04	                ldy #current_offset
.d87e		b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d880		0a		asl a		                asl             ; turn it into an offset (in cells)
.d881		18		clc		                clc
.d882		69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d884		a8		tay		                tay
.d885		b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d887		85 02		sta $02		                sta dp
.d889		c8		iny		                iny
.d88a		b1 1e		lda ($1e),y	                lda (up),y
.d88c		85 03		sta $03		                sta dp+1
.d88e		60		rts		                rts
.d88f						dp_to_current:
.d88f		a0 04		ldy #$04	                ldy #current_offset
.d891		b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d893		0a		asl a		                asl             ; turn it into an offset (in cells)
.d894		18		clc		                clc
.d895		69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d897		a8		tay		                tay
.d898		a5 02		lda $02		                lda dp
.d89a		91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d89c		c8		iny		                iny
.d89d		a5 03		lda $03		                lda dp+1
.d89f		91 1e		sta ($1e),y	                sta (up),y
.d8a1		60		rts		                rts
.d8a2						interpret:
.d8a2						_loop:
.d8a2		20 b8 98	jsr $98b8	                jsr xt_parse_name       ; ( "string" -- addr u )
.d8a5		b5 00		lda $00,x	                lda 0,x
.d8a7		15 01		ora $01,x	                ora 1,x
.d8a9		f0 7d		beq $d928	                beq _line_done
.d8ab		20 62 a3	jsr $a362	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d8ae		20 9e 8f	jsr $8f9e	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d8b1		b5 00		lda $00,x	                lda 0,x
.d8b3		15 01		ora $01,x	                ora 1,x
.d8b5		d0 35		bne $d8ec	                bne _got_name_token
.d8b7		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d8b8		e8		inx		                inx
.d8b9		20 63 96	jsr $9663	                jsr xt_number           ; ( addr u -- u|d )
.d8bc		a5 16		lda $16		                lda state
.d8be		f0 e2		beq $d8a2	                beq _loop
.d8c0		a9 20		lda #$20	                lda #$20
.d8c2		24 20		bit $20		                bit status
.d8c4		f0 06		beq $d8cc	                beq _single_number
.d8c6		20 58 a1	jsr $a158	                jsr xt_swap
.d8c9		20 d1 d8	jsr $d8d1	                jsr _add_lit
.d8cc						_single_number:
.d8cc		20 d1 d8	jsr $d8d1	                jsr _add_lit
.d8cf		80 d1		bra $d8a2	                bra _loop
.d8d1		b5 01		lda $01,x	_add_lit:       lda 1,x
.d8d3		f0 06		beq $d8db	                beq _byte_rt
.d8d5		a0 93		ldy #$93	                ldy #>literal_runtime
.d8d7		a9 59		lda #$59	                lda #<literal_runtime
.d8d9		80 04		bra $d8df	                bra _cmpl_rt
.d8db		a0 93		ldy #$93	_byte_rt:       ldy #>byte_runtime
.d8dd		a9 78		lda #$78	                lda #<byte_runtime
.d8df		20 dd d7	jsr $d7dd	_cmpl_rt:       jsr cmpl_subroutine
.d8e2		b5 01		lda $01,x	                lda 1,x
.d8e4		f0 03		beq $d8e9	                beq _c_comma
.d8e6		4c 34 87	jmp $8734	                jmp xt_comma
.d8e9		4c c6 85	jmp $85c6	_c_comma:       jmp xt_c_comma
.d8ec						_got_name_token:
.d8ec		b5 00		lda $00,x	                lda 0,x
.d8ee		95 04		sta $04,x	                sta 4,x
.d8f0		b5 01		lda $01,x	                lda 1,x
.d8f2		95 05		sta $05,x	                sta 5,x
.d8f4		e8		inx		                inx
.d8f5		e8		inx		                inx
.d8f6		e8		inx		                inx
.d8f7		e8		inx		                inx                     ; ( nt )
.d8f8		b5 00		lda $00,x	                lda 0,x
.d8fa		85 22		sta $22		                sta tmpbranch
.d8fc		b5 01		lda $01,x	                lda 1,x
.d8fe		85 23		sta $23		                sta tmpbranch+1
.d900		20 ba 95	jsr $95ba	                jsr xt_name_to_int      ; ( nt - xt )
.d903		a5 16		lda $16		                lda state
.d905		d0 13		bne $d91a	                bne _compile
.d907		a0 01		ldy #$01	                ldy #1
.d909		b1 22		lda ($22),y	                lda (tmpbranch),y
.d90b		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d90d		f0 05		beq $d914	                beq _interpret
.d90f		a9 02		lda #$02	                lda #err_compileonly
.d911		4c 5d d9	jmp $d95d	                jmp error
.d914						_interpret:
.d914		20 00 8f	jsr $8f00	                jsr xt_execute
.d917		4c a2 d8	jmp $d8a2	                jmp _loop
.d91a						_compile:
.d91a		a0 01		ldy #$01	                ldy #1
.d91c		b1 22		lda ($22),y	                lda (tmpbranch),y
.d91e		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d920		d0 f2		bne $d914	                bne _interpret          ; IMMEDIATE word, execute right now
.d922		20 b3 87	jsr $87b3	                jsr xt_compile_comma
.d925		4c a2 d8	jmp $d8a2	                jmp _loop
.d928						_line_done:
.d928		e8		inx		                inx
.d929		e8		inx		                inx
.d92a		e8		inx		                inx
.d92b		e8		inx		                inx
.d92c		60		rts		                rts
.d92d						is_printable:
.d92d		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d92f		90 08		bcc $d939	                bcc _done
.d931		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d933		b0 03		bcs $d938	                bcs _failed
.d935		38		sec		                sec
.d936		80 01		bra $d939	                bra _done
.d938						_failed:
.d938		18		clc		                clc
.d939						_done:
.d939		60		rts		                rts
.d93a						is_whitespace:
.d93a		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d93c		90 08		bcc $d946	                bcc _done
.d93e		c9 21		cmp #$21	                cmp #AscSP+1
.d940		b0 03		bcs $d945	                bcs _failed
.d942		38		sec		                sec
.d943		80 01		bra $d946	                bra _done
.d945						_failed:
.d945		18		clc		                clc
.d946						_done:
.d946		60		rts		                rts
.d947						underflow_1:
.d947		e0 77		cpx #$77	                cpx #dsp0-1
.d949		10 10		bpl $d95b	                bpl underflow_error
.d94b		60		rts		                rts
.d94c						underflow_2:
.d94c		e0 75		cpx #$75	                cpx #dsp0-3
.d94e		10 0b		bpl $d95b	                bpl underflow_error
.d950		60		rts		                rts
.d951						underflow_3:
.d951		e0 73		cpx #$73	                cpx #dsp0-5
.d953		10 06		bpl $d95b	                bpl underflow_error
.d955		60		rts		                rts
.d956						underflow_4:
.d956		e0 71		cpx #$71	                cpx #dsp0-7
.d958		10 01		bpl $d95b	                bpl underflow_error
.d95a		60		rts		                rts
.d95b						underflow_error:
.d95b		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d95d						error:
.d95d		48		pha		                pha                     ; save error
.d95e		20 9d d9	jsr $d99d	                jsr print_error
.d961		20 3a 89	jsr $893a	                jsr xt_cr
.d964		68		pla		                pla
.d965		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d967		d0 17		bne $d980	                bne _no_underflow
.d969		a9 0d		lda #$0d	                lda #err_returnstack
.d96b		20 9d d9	jsr $d99d	                jsr print_error
.d96e		ba		tsx		                tsx
.d96f						-
.d96f		e8		inx		                inx
.d970		f0 0b		beq $d97d	                beq +
.d972		20 c8 a0	jsr $a0c8	                jsr xt_space
.d975		bd 00 01	lda $0100,x	                lda $100,x
.d978		20 4a d8	jsr $d84a	                jsr byte_to_ascii
.d97b		80 f2		bra $d96f	                bra -
.d97d						+
.d97d		20 3a 89	jsr $893a	                jsr xt_cr
.d980						_no_underflow:
.d980		4c 70 80	jmp $8070	                jmp xt_abort            ; no jsr, as we clobber return stack
.d983						print_string_no_lf:
.d983		0a		asl a		                asl
.d984		a8		tay		                tay
.d985		b9 d0 d4	lda $d4d0,y	                lda string_table,y
.d988		85 28		sta $28		                sta tmp3                ; LSB
.d98a		c8		iny		                iny
.d98b		b9 d0 d4	lda $d4d0,y	                lda string_table,y
.d98e		85 29		sta $29		                sta tmp3+1              ; MSB
.d990						print_common:
.d990		a0 00		ldy #$00	                ldy #0
.d992						_loop:
.d992		b1 28		lda ($28),y	                lda (tmp3),y
.d994		f0 06		beq $d99c	                beq _done               ; strings are zero-terminated
.d996		20 b9 8d	jsr $8db9	                jsr emit_a              ; allows vectoring via output
.d999		c8		iny		                iny
.d99a		80 f6		bra $d992	                bra _loop
.d99c						_done:
.d99c		60		rts		                rts
.d99d						print_error:
.d99d		0a		asl a		                asl
.d99e		a8		tay		                tay
.d99f		b9 a5 d5	lda $d5a5,y	                lda error_table,y
.d9a2		85 28		sta $28		                sta tmp3                ; LSB
.d9a4		c8		iny		                iny
.d9a5		b9 a5 d5	lda $d5a5,y	                lda error_table,y
.d9a8		85 29		sta $29		                sta tmp3+1              ; MSB
.d9aa		20 90 d9	jsr $d990	                jsr print_common
.d9ad		60		rts		                rts
.d9ae						print_string:
.d9ae		20 83 d9	jsr $d983	                jsr print_string_no_lf
.d9b1		4c 3a 89	jmp $893a	                jmp xt_cr               ; JSR/RTS because never compiled
.d9b4						print_u:
.d9b4		20 52 a7	jsr $a752	                jsr xt_zero                     ; 0
.d9b7		20 1b 93	jsr $931b	                jsr xt_less_number_sign         ; <#
.d9ba		20 b7 97	jsr $97b7	                jsr xt_number_sign_s            ; #S
.d9bd		20 95 97	jsr $9795	                jsr xt_number_sign_greater      ; #>
.d9c0		4c ad a4	jmp $a4ad	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010						v_nmi:
.f010						v_reset:
.f010						v_irq:
.f010						kernel_init:
.f010		78		sei		                sei             ; Disable interrupts
.f011		a2 00		ldx #$00	                ldx #0
.f013		bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016		f0 06		beq $f01e	                beq _done
.f018		20 27 f0	jsr $f027	                jsr kernel_putc
.f01b		e8		inx		                inx
.f01c		80 f5		bra $f013	                bra -
.f01e						_done:
.f01e		4c 00 80	jmp $8000	                jmp forth
.f021						kernel_getc:
.f021						_loop:
.f021		ad 04 f0	lda $f004	                lda $f004
.f024		f0 fb		beq $f021	                beq _loop
.f026		60		rts		                rts
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta $f001
.f02a		60		rts		                rts
.f02b						platform_bye:
.f02b		00		brk #		                brk
.f02c						s_kernel_id:
>f02c		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		10 f0				.word v_nmi
>fffc		10 f0				.word v_reset
>fffe		10 f0				.word v_irq

;******  End of listing
