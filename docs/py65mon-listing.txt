
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Sat Apr  6 20:12:59 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../native_words.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd ab a8	lda $a8ab,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad ab a8	lda $a8ab	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 c9 a8	lda $a8c9,y	                lda cold_user_table,y
.8024		91 08		sta ($08),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad c9 a8	lda $a8c9	                lda cold_user_table
.802c		92 08		sta ($08)	                sta (up)
.802e		20 fb 88	jsr $88fb	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 93		lda #$93	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 bb		lda #$bb	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 87 90	jsr $9087	                jsr xt_evaluate
.8048		9c 00 7c	stz $7c00	                stz hist_buff
.804b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057		9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060						xt_abort:
.8060		a2 78		ldx #$78	                ldx #dsp0
.8062						xt_quit:
.8062		8a		txa		                txa             ; Save the DSP that we just defined
.8063		a2 ff		ldx #$ff	                ldx #rsp0
.8065		9a		txs		                txs
.8066		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067		64 04		stz $04		                stz ip
.8069		64 05		stz $05		                stz ip+1
.806b		64 0a		stz $0a		                stz insrc
.806d		64 0b		stz $0b		                stz insrc+1
.806f		a9 00		lda #$00	                lda #0
.8071		a0 04		ldy #$04	                ldy #blk_offset
.8073		91 08		sta ($08),y	                sta (up),y
.8075		c8		iny		                iny
.8076		91 08		sta ($08),y	                sta (up),y
.8078		a9 fc		lda #$fc	                lda #(256-4)
.807a		85 1f		sta $1f		                sta loopctrl
.807c		64 1a		stz $1a		                stz state
.807e		64 1b		stz $1b		                stz state+1
.8080						_get_line:
.8080		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8082		85 0c		sta $0c		                sta cib
.8084		a9 02		lda #$02	                lda #>buffer0
.8086		85 0d		sta $0d		                sta cib+1
.8088		64 0e		stz $0e		                stz ciblen
.808a		64 0f		stz $0f		                stz ciblen+1
.808c		20 c4 9a	jsr $9ac4	                jsr xt_refill           ; ( -- f )
.808f		b5 00		lda $00,x	                lda 0,x
.8091		d0 05		bne $8098	                bne _success
.8093		a9 06		lda #$06	                lda #err_refill
.8095		4c 89 d8	jmp $d889	                jmp error
.8098						_success:
.8098		e8		inx		                inx                     ; drop
.8099		e8		inx		                inx
.809a		20 e0 d7	jsr $d7e0	                jsr interpret
.809d		e0 78		cpx #$78	                cpx #dsp0
.809f		f0 05		beq $80a6	                beq _stack_ok
.80a1		90 03		bcc $80a6	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a3		4c 87 d8	jmp $d887	                jmp underflow_error
.80a6						_stack_ok:
.80a6		a5 1a		lda $1a		                lda state
.80a8		f0 02		beq $80ac	                beq _print
.80aa		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80ac						_print:
.80ac		20 da d8	jsr $d8da	                jsr print_string
.80af		80 cf		bra $8080	                bra _get_line
.80b1						z_cold:
.80b1						z_abort:
.80b1						z_quit:
.80b1						xt_abort_quote:
.80b1		20 14 9d	jsr $9d14	                jsr xt_s_quote          ; S"
.80b4		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b6		a9 bc		lda #$bc	                lda #<abort_quote_runtime
.80b8		20 0c d7	jsr $d70c	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80bb		60		rts		z_abort_quote:  rts
.80bc						abort_quote_runtime:
.80bc		b5 04		lda $04,x	                lda 4,x
.80be		15 05		ora $05,x	                ora 5,x
.80c0		f0 09		beq $80cb	                beq _done       ; if FALSE, we're done
.80c2		20 7e a4	jsr $a47e	                jsr xt_type
.80c5		20 fb 88	jsr $88fb	                jsr xt_cr
.80c8		4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.80cb						_done:
.80cb		8a		txa		                txa
.80cc		18		clc		                clc
.80cd		69 06		adc #$06	                adc #6
.80cf		aa		tax		                tax
.80d0		60		rts		                rts
.80d1						xt_abs:
.80d1		20 73 d8	jsr $d873	                jsr underflow_1
.80d4		b5 01		lda $01,x	                lda 1,x
.80d6		10 0d		bpl $80e5	                bpl _done       ; positive number, easy money!
.80d8		38		sec		                sec
.80d9		a9 00		lda #$00	                lda #0
.80db		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80dd		95 00		sta $00,x	                sta 0,x
.80df		a9 00		lda #$00	                lda #0          ; MSB
.80e1		f5 01		sbc $01,x	                sbc 1,x
.80e3		95 01		sta $01,x	                sta 1,x
.80e5						_done:
.80e5		60		rts		z_abs:          rts
.80e6						xt_accept:
.80e6		20 78 d8	jsr $d878	                jsr underflow_2
.80e9		b5 00		lda $00,x	                lda 0,x
.80eb		15 01		ora $01,x	                ora 1,x
.80ed		d0 09		bne $80f8	                bne _not_zero
.80ef		e8		inx		                inx
.80f0		e8		inx		                inx
.80f1		74 00		stz $00,x	                stz 0,x
.80f3		74 01		stz $01,x	                stz 1,x
.80f5		4c c4 81	jmp $81c4	                jmp accept_done
.80f8						_not_zero:
.80f8		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80fa		85 27		sta $27		                sta tmp2
.80fc		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fe		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8100		85 25		sta $25		                sta tmp1
.8102		b5 03		lda $03,x	                lda 3,x
.8104		85 26		sta $26		                sta tmp1+1
.8106		e8		inx		                inx
.8107		e8		inx		                inx
.8108		a0 00		ldy #$00	                ldy #0
.810a		a5 1c		lda $1c		                lda status
.810c		29 f7		and #$f7	                and #$f7
.810e		1a		inc a		               ina
.810f		09 08		ora #$08	                ora #$08
.8111		85 1c		sta $1c		                sta status
.8113						accept_loop:
.8113		20 e3 92	jsr $92e3	                jsr key_a
.8116		c9 0a		cmp #$0a	                cmp #AscLF
.8118		f0 20		beq $813a	                beq _eol
.811a		c9 0d		cmp #$0d	                cmp #AscCR
.811c		f0 1c		beq $813a	                beq _eol
.811e		c9 08		cmp #$08	                cmp #AscBS
.8120		f0 22		beq $8144	                beq _backspace
.8122		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8124		f0 1e		beq $8144	                beq _backspace
.8126		c9 10		cmp #$10	                cmp #AscCP
.8128		f0 36		beq $8160	                beq _ctrl_p
.812a		c9 0e		cmp #$0e	                cmp #AscCN
.812c		f0 44		beq $8172	                beq _ctrl_n
.812e		91 25		sta ($25),y	                sta (tmp1),y
.8130		c8		iny		                iny
.8131		20 a8 8d	jsr $8da8	                jsr emit_a
.8134		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8136		d0 db		bne $8113	                bne accept_loop       ; fall through if buffer limit reached
.8138		80 03		bra $813d	                bra _buffer_full
.813a						_eol:
.813a		20 a9 a0	jsr $a0a9	                jsr xt_space    ; print final space
.813d						_buffer_full:
.813d		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813f		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.8141		4c c4 81	jmp $81c4	                jmp accept_done
.8144						_backspace:
.8144		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8146		d0 06		bne $814e	                bne +
.8148		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.814a		20 a8 8d	jsr $8da8	                jsr emit_a
.814d		c8		iny		                iny
.814e						+
.814e		88		dey		                dey
.814f		a9 08		lda #$08	                lda #AscBS      ; move back one
.8151		20 a8 8d	jsr $8da8	                jsr emit_a
.8154		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8156		20 a8 8d	jsr $8da8	                jsr emit_a
.8159		a9 08		lda #$08	                lda #AscBS      ; move back over space
.815b		20 a8 8d	jsr $8da8	                jsr emit_a
.815e		80 b3		bra $8113	                bra accept_loop
.8160						_ctrl_p:
.8160		a5 1c		lda $1c		                lda status
.8162		29 07		and #$07	                and #7
.8164		d0 08		bne $816e	                bne _ctrl_p_dec
.8166		a5 1c		lda $1c		                lda status
.8168		09 07		ora #$07	                ora #7
.816a		85 1c		sta $1c		                sta status
.816c		80 11		bra $817f	                bra _recall_history
.816e						_ctrl_p_dec:
.816e		c6 1c		dec $1c		                dec status
.8170		80 0d		bra $817f	                bra _recall_history
.8172						_ctrl_n:
.8172		a9 08		lda #$08	                lda #$8
.8174		24 1c		bit $1c		                bit status
.8176		d0 07		bne $817f	                bne _recall_history
.8178		a5 1c		lda $1c		                lda status
.817a		29 f7		and #$f7	                and #$f7
.817c		1a		inc a		               ina
.817d		85 1c		sta $1c		                sta status
.817f						_recall_history:
.817f		a9 08		lda #$08	                lda #%00001000
.8181		14 1c		trb $1c		                trb status
.8183		20 df 81	jsr $81df	                jsr accept_total_recall
.8186		a9 0d		lda #$0d	                lda #AscCR
.8188		20 a8 8d	jsr $8da8	                jsr emit_a
.818b						input_clear:
.818b		c0 00		cpy #$00	                cpy #0
.818d		f0 08		beq $8197	                beq input_cleared
.818f		a9 20		lda #$20	                lda #AscSP
.8191		20 a8 8d	jsr $8da8	                jsr emit_a
.8194		88		dey		                dey
.8195		80 f4		bra $818b	                bra input_clear
.8197						input_cleared:
.8197		a9 0d		lda #$0d	                lda #AscCR
.8199		20 a8 8d	jsr $8da8	                jsr emit_a
.819c		b1 29		lda ($29),y	                lda (tmp3),y
.819e		85 1d		sta $1d		                sta status+1
.81a0		e6 29		inc $29		                inc tmp3
.81a2		d0 02		bne $81a6	                bne +           ; Increment the upper byte on carry.
.81a4		e6 2a		inc $2a		                inc tmp3+1
.81a6						+
.81a6		a9 0d		lda #$0d	                lda #AscCR
.81a8		20 a8 8d	jsr $8da8	                jsr emit_a
.81ab						_history_loop:
.81ab		c4 1d		cpy $1d		                cpy status+1
.81ad		d0 03		bne $81b2	                bne +
.81af		4c 13 81	jmp $8113	                jmp accept_loop       ; Needs a long jump
.81b2						+
.81b2		c4 27		cpy $27		                cpy tmp2
.81b4		f0 0a		beq $81c0	                beq _hist_filled_buffer
.81b6		b1 29		lda ($29),y	                lda (tmp3),y
.81b8		91 25		sta ($25),y	                sta (tmp1),y
.81ba		20 a8 8d	jsr $8da8	                jsr emit_a
.81bd		c8		iny		                iny
.81be		80 eb		bra $81ab	                bra _history_loop
.81c0						_hist_filled_buffer:
.81c0		88		dey		                dey
.81c1		4c 13 81	jmp $8113	                jmp accept_loop
.81c4						accept_done:
.81c4		20 df 81	jsr $81df	                jsr accept_total_recall
.81c7		85 1d		sta $1d		                sta status+1
.81c9		a0 00		ldy #$00	                ldy #0
.81cb		91 29		sta ($29),y	                sta (tmp3),y
.81cd		e6 29		inc $29		                inc tmp3
.81cf		d0 02		bne $81d3	                bne +           ; Increment the upper byte on carry.
.81d1		e6 2a		inc $2a		                inc tmp3+1
.81d3						+
.81d3						_save_history_loop:
.81d3		c4 1d		cpy $1d		                cpy status+1
.81d5		f0 07		beq $81de	                beq _save_history_done
.81d7		b1 25		lda ($25),y	                lda (tmp1),y
.81d9		91 29		sta ($29),y	                sta (tmp3),y
.81db		c8		iny		                iny
.81dc		80 f5		bra $81d3	                bra _save_history_loop
.81de						_save_history_done:
.81de						z_accept:
.81de		60		rts		                rts
.81df						accept_total_recall:
.81df		a9 00		lda #$00	                lda #<hist_buff
.81e1		85 29		sta $29		                sta tmp3
.81e3		a9 7c		lda #$7c	                lda #>hist_buff
.81e5		85 2a		sta $2a		                sta tmp3+1
.81e7		a5 1c		lda $1c		                lda status
.81e9		6a		ror a		                ror
.81ea		29 03		and #$03	                and #3
.81ec		18		clc		                clc
.81ed		65 2a		adc $2a		                adc tmp3+1
.81ef		85 2a		sta $2a		                sta tmp3+1
.81f1		a5 1c		lda $1c		                lda status
.81f3		6a		ror a		                ror             ; Rotate through carry into msb.
.81f4		6a		ror a		                ror
.81f5		29 80		and #$80	                and #$80
.81f7		18		clc		                clc
.81f8		65 29		adc $29		                adc tmp3
.81fa		85 29		sta $29		                sta tmp3
.81fc		90 02		bcc $8200	                bcc +           ; Increment the upper byte on carry.
.81fe		e6 2a		inc $2a		                inc tmp3+1
.8200						+
.8200		98		tya		                tya
.8201		c9 80		cmp #$80	                cmp #$80
.8203		90 02		bcc $8207	                bcc +
.8205		a9 7f		lda #$7f	                lda #$7F
.8207						+
.8207		60		rts		                rts
.8208						xt_action_of:
.8208		a5 1a		lda $1a		                lda state
.820a		05 1b		ora $1b		                ora state+1
.820c		f0 0c		beq $821a	                beq _interpreting
.820e						_compiling:
.820e		20 37 85	jsr $8537	                jsr xt_bracket_tick
.8211		a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.8213		a9 77		lda #$77	                lda #<xt_defer_fetch
.8215		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.8218		80 06		bra $8220	                bra _done
.821a						_interpreting:
.821a		20 8c a1	jsr $a18c	                jsr xt_tick
.821d		20 77 8a	jsr $8a77	                jsr xt_defer_fetch
.8220						_done:
.8220		60		rts		z_action_of:           rts
.8221						xt_again:
.8221		20 73 d8	jsr $d873	                jsr underflow_1
.8224		a0 00		ldy #$00	                ldy #0
.8226		a9 4c		lda #$4c	                lda #$4C        ; JMP
.8228		91 00		sta ($00),y	                sta (cp),y
.822a		c8		iny		                iny
.822b		b5 00		lda $00,x	                lda 0,x         ; LSB of address
.822d		91 00		sta ($00),y	                sta (cp),y
.822f		c8		iny		                iny
.8230		b5 01		lda $01,x	                lda 1,x         ; MSB of address
.8232		91 00		sta ($00),y	                sta (cp),y
.8234		c8		iny		                iny
.8235		98		tya		                tya
.8236		18		clc		                clc
.8237		65 00		adc $00		                adc cp
.8239		85 00		sta $00		                sta cp
.823b		90 02		bcc $823f	                bcc _done
.823d		e6 01		inc $01		                inc cp+1
.823f						_done:
.823f		e8		inx		                inx
.8240		e8		inx		                inx
.8241		60		rts		z_again:        rts
.8242						xt_align:
.8242						xt_aligned:
.8242						z_align:
.8242		60		rts		z_aligned:      rts             ; stripped out during native compile
.8243						xt_allot:
.8243		20 73 d8	jsr $d873	                jsr underflow_1
.8246		b5 01		lda $01,x	                lda 1,x
.8248		30 22		bmi $826c	                bmi _release
.824a		18		clc		                clc
.824b		a5 00		lda $00		                lda cp
.824d		75 00		adc $00,x	                adc 0,x
.824f		85 00		sta $00		                sta cp
.8251		a5 01		lda $01		                lda cp+1
.8253		75 01		adc $01,x	                adc 1,x
.8255		85 01		sta $01		                sta cp+1
.8257		a0 00		ldy #$00	                ldy #<cp_end
.8259		c4 00		cpy $00		                cpy cp
.825b		a9 7c		lda #$7c	                lda #>cp_end
.825d		e5 01		sbc $01		                sbc cp+1
.825f		b0 48		bcs $82a9	                bcs _done               ; we're fine.
.8261		84 00		sty $00		                sty cp                  ; still #<cp_end
.8263		a9 7c		lda #$7c	                lda #>cp_end
.8265		85 01		sta $01		                sta cp+1
.8267		a9 00		lda #$00	                lda #err_allot
.8269		4c 89 d8	jmp $d889	                jmp error
.826c						_release:
.826c		ca		dex		                dex
.826d		ca		dex		                dex
.826e		a5 00		lda $00		                lda cp
.8270		95 00		sta $00,x	                sta 0,x
.8272		a5 01		lda $01		                lda cp+1
.8274		95 01		sta $01,x	                sta 1,x
.8276		20 af 99	jsr $99af	                jsr xt_plus                     ; new CP is now TOS
.8279		ca		dex		                dex
.827a		ca		dex		                dex                             ; new CP now NOS
.827b		a9 00		lda #$00	                lda #<cp0
.827d		95 00		sta $00,x	                sta 0,x
.827f		a9 03		lda #$03	                lda #>cp0
.8281		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8283		20 9f d7	jsr $d79f	                jsr compare_16bit               ; still ( CP CP0 )
.8286		f0 17		beq $829f	                beq _nega_done
.8288		30 15		bmi $829f	                bmi _nega_done
.828a		a9 00		lda #$00	                lda #<cp0
.828c		85 00		sta $00		                sta cp
.828e		a9 03		lda #$03	                lda #>cp0
.8290		85 01		sta $01		                sta cp+1
.8292		a9 75		lda #$75	                lda #<dictionary_start
.8294		85 02		sta $02		                sta dp
.8296		a9 bc		lda #$bc	                lda #>dictionary_start
.8298		85 03		sta $03		                sta dp+1
.829a		a9 0a		lda #$0a	                lda #err_negallot
.829c		4c 89 d8	jmp $d889	                jmp error
.829f						_nega_done:
.829f		b5 02		lda $02,x	                lda 2,x
.82a1		85 00		sta $00		                sta cp
.82a3		b5 03		lda $03,x	                lda 3,x
.82a5		85 01		sta $01		                sta cp+1
.82a7		e8		inx		                inx
.82a8		e8		inx		                inx                     ; drop through to _done
.82a9						_done:
.82a9		e8		inx		                inx
.82aa		e8		inx		                inx
.82ab						z_allot:
.82ab		60		rts		                rts
.82ac						xt_allow_native:
.82ac		20 ba d7	jsr $d7ba	                jsr current_to_dp
.82af		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82b1		b1 02		lda ($02),y	                lda (dp),y
.82b3		29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.82b5		91 02		sta ($02),y	                sta (dp),y
.82b7						z_allow_native:
.82b7		60		rts		                rts
.82b8						xt_also:
.82b8		20 e6 90	jsr $90e6	                jsr xt_get_order
.82bb		20 5f 98	jsr $985f	                jsr xt_over
.82be		20 33 a1	jsr $a133	                jsr xt_swap
.82c1		20 e9 97	jsr $97e9	                jsr xt_one_plus
.82c4		20 e0 9c	jsr $9ce0	                jsr xt_set_order
.82c7		60		rts		z_also:         rts
.82c8						xt_always_native:
.82c8		20 ba d7	jsr $d7ba	                jsr current_to_dp
.82cb		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82cd		b1 02		lda ($02),y	                lda (dp),y
.82cf		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.82d1		29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.82d3		91 02		sta ($02),y	                sta (dp),y
.82d5						z_always_native:
.82d5		60		rts		                rts
.82d6						xt_and:
.82d6		20 78 d8	jsr $d878	                jsr underflow_2
.82d9		b5 00		lda $00,x	                lda 0,x
.82db		35 02		and $02,x	                and 2,x
.82dd		95 02		sta $02,x	                sta 2,x
.82df		b5 01		lda $01,x	                lda 1,x
.82e1		35 03		and $03,x	                and 3,x
.82e3		95 03		sta $03,x	                sta 3,x
.82e5		e8		inx		                inx
.82e6		e8		inx		                inx
.82e7		60		rts		z_and:          rts
.82e8						xt_at_xy:
.82e8		20 78 d8	jsr $d878	                jsr underflow_2
.82eb		a5 18		lda $18		                lda base
.82ed		48		pha		                pha
.82ee		a9 0a		lda #$0a	                lda #10
.82f0		85 18		sta $18		                sta base
.82f2		a9 1b		lda #$1b	                lda #AscESC
.82f4		20 a8 8d	jsr $8da8	                jsr emit_a
.82f7		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.82f9		20 a8 8d	jsr $8da8	                jsr emit_a
.82fc		20 e9 97	jsr $97e9	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82ff		20 e0 d8	jsr $d8e0	                jsr print_u
.8302		a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8304		20 a8 8d	jsr $8da8	                jsr emit_a
.8307		20 e9 97	jsr $97e9	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.830a		20 e0 d8	jsr $d8e0	                jsr print_u
.830d		a9 48		lda #$48	                lda #'H'
.830f		20 a8 8d	jsr $8da8	                jsr emit_a
.8312		68		pla		                pla
.8313		85 18		sta $18		                sta base
.8315		60		rts		z_at_xy:        rts
.8316						xt_backslash:
.8316		a0 04		ldy #$04	                ldy #blk_offset
.8318		b1 08		lda ($08),y	                lda (up),y
.831a		c8		iny		                iny
.831b		11 08		ora ($08),y	                ora (up),y
.831d		f0 19		beq $8338	                beq backslash_not_block
.831f		a5 10		lda $10		                lda toin
.8321		29 3f		and #$3f	                and #$3F
.8323		f0 1b		beq $8340	                beq z_backslash
.8325		c9 01		cmp #$01	                cmp #$01
.8327		f0 17		beq $8340	                beq z_backslash
.8329		a5 10		lda $10		                lda toin
.832b		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.832d		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.832e		69 40		adc #$40	                adc #$40
.8330		85 10		sta $10		                sta toin
.8332		90 0c		bcc $8340	                bcc z_backslash
.8334		e6 11		inc $11		                inc toin+1
.8336		80 08		bra $8340	                bra z_backslash
.8338						backslash_not_block:
.8338		a5 0e		lda $0e		                lda ciblen
.833a		85 10		sta $10		                sta toin
.833c		a5 0f		lda $0f		                lda ciblen+1
.833e		85 11		sta $11		                sta toin+1
.8340		60		rts		z_backslash:    rts
.8341						xt_base:
.8341		ca		dex		                dex
.8342		ca		dex		                dex
.8343		a9 18		lda #$18	                lda #<base
.8345		95 00		sta $00,x	                sta 0,x         ; LSB
.8347		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8349		60		rts		z_base:         rts
.834a						xt_begin:
.834a		20 24 91	jsr $9124	                jsr xt_here
.834d		60		rts		z_begin:        rts
.834e						xt_bell:
.834e		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.8350		20 a8 8d	jsr $8da8	                jsr emit_a
.8353		60		rts		z_bell:         rts
.8354						xt_bl:
.8354		ca		dex		                dex
.8355		ca		dex		                dex
.8356		a9 20		lda #$20	                lda #AscSP
.8358		95 00		sta $00,x	                sta 0,x
.835a		74 01		stz $01,x	                stz 1,x
.835c		60		rts		z_bl:           rts
.835d						xt_blk:
.835d		a9 04		lda #$04	                lda #blk_offset
.835f		4c 79 d7	jmp $d779	                jmp push_upvar_tos
.8362						z_blk:
.8362						xt_blkbuffer:
.8362		ca		dex		                dex
.8363		ca		dex		                dex
.8364		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.8366		b1 08		lda ($08),y	                lda (up),y
.8368		95 00		sta $00,x	                sta 0,x
.836a		c8		iny		                iny             ; Move along to the next byte
.836b		b1 08		lda ($08),y	                lda (up),y
.836d		95 01		sta $01,x	                sta 1,x
.836f		60		rts		z_blkbuffer:    rts
.8370						xt_block:
.8370		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.8372		b1 08		lda ($08),y	                lda (up),y
.8374		d5 00		cmp $00,x	                cmp 0,x
.8376		d0 0f		bne $8387	                bne _not_in_buffer
.8378		c8		iny		                iny
.8379		b1 08		lda ($08),y	                lda (up),y
.837b		d5 01		cmp $01,x	                cmp 1,x
.837d		d0 08		bne $8387	                bne _not_in_buffer
.837f		a0 30		ldy #$30	                ldy #buffstatus_offset
.8381		b1 08		lda ($08),y	                lda (up),y
.8383		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.8385		d0 30		bne $83b7	                bne _done       ; It's already in the buffer and in use.
.8387						_not_in_buffer:
.8387		a0 30		ldy #$30	                ldy #buffstatus_offset
.8389		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.838b		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.838d		d0 0c		bne $839b	                bne _buffer_available ; Unused or not dirty = available
.838f		20 62 83	jsr $8362	                jsr xt_blkbuffer
.8392		20 3e 85	jsr $853e	                jsr xt_buffblocknum
.8395		20 32 8f	jsr $8f32	                jsr xt_fetch
.8398		20 04 85	jsr $8504	                jsr xt_block_write
.839b						_buffer_available:
.839b		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.839d		b5 00		lda $00,x	                lda 0,x
.839f		91 08		sta ($08),y	                sta (up),y
.83a1		c8		iny		                iny
.83a2		b5 01		lda $01,x	                lda 1,x
.83a4		91 08		sta ($08),y	                sta (up),y
.83a6		20 62 83	jsr $8362	                jsr xt_blkbuffer
.83a9		20 33 a1	jsr $a133	                jsr xt_swap
.83ac		20 ec 84	jsr $84ec	                jsr xt_block_read
.83af		a9 01		lda #$01	                lda #1
.83b1		a0 30		ldy #$30	                ldy #buffstatus_offset
.83b3		91 08		sta ($08),y	                sta (up),y
.83b5		ca		dex		                dex
.83b6		ca		dex		                dex
.83b7						_done:
.83b7		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.83b9		b1 08		lda ($08),y	                lda (up),y
.83bb		95 00		sta $00,x	                sta 0,x
.83bd		c8		iny		                iny
.83be		b1 08		lda ($08),y	                lda (up),y
.83c0		95 01		sta $01,x	                sta 1,x
.83c2		60		rts		z_block:        rts
.83c3						xt_block_ramdrive_init:
.83c3		20 73 d8	jsr $d873	                jsr underflow_1
.83c6		4c e1 84	jmp $84e1	                jmp _after_ramdrive_code
.83c9						_ramdrive_code:
>83c9		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>83d1		77 61 70 20 64 65 63 69 6d 61 6c
>83dc		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>83e3		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>83e7		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>83ef		20 72 61 6d 64 72 69 76 65
>83f8		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8400		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>840e		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8416		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8426		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8436		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>843e		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>844d		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>8455		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8465		31 30 32 34 20 6d 6f 76 65 20 3b
>8470		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>8478		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>8488		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>8498		20 21
>849a		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84a2		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84b2		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>84c2		6f 72 20 21
>84c6		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>84ce		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>84de		65 20 21
.84e1						_after_ramdrive_code:
.84e1		20 34 a0	jsr $a034	                jsr sliteral_runtime
>84e4		c9 83 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.84e8		20 87 90	jsr $9087	                jsr xt_evaluate
.84eb						z_block_ramdrive_init:
.84eb		60		rts		                rts
.84ec						xt_block_read:
.84ec		a0 32		ldy #$32	                ldy #blockread_offset
.84ee		b1 08		lda ($08),y	                lda (up),y
.84f0		85 25		sta $25		                sta tmp1
.84f2		c8		iny		                iny
.84f3		b1 08		lda ($08),y	                lda (up),y
.84f5		85 26		sta $26		                sta tmp1+1
.84f7		6c 25 00	jmp ($0025)	                jmp (tmp1)
.84fa						z_block_read:
.84fa						xt_block_read_vector:
.84fa		a9 32		lda #$32	                lda #blockread_offset
.84fc		4c 79 d7	jmp $d779	                jmp push_upvar_tos
.84ff						z_block_read_vector:
.84ff						xt_block_word_error:
.84ff		a9 0c		lda #$0c	                lda #err_blockwords
.8501		4c 89 d8	jmp $d889	                jmp error       ; no RTS needed
.8504						z_block_word_error:
.8504						xt_block_write:
.8504		a0 34		ldy #$34	                ldy #blockwrite_offset
.8506		b1 08		lda ($08),y	                lda (up),y
.8508		85 25		sta $25		                sta tmp1
.850a		c8		iny		                iny
.850b		b1 08		lda ($08),y	                lda (up),y
.850d		85 26		sta $26		                sta tmp1+1
.850f		6c 25 00	jmp ($0025)	                jmp (tmp1)
.8512						z_block_write:
.8512						xt_block_write_vector:
.8512		a9 34		lda #$34	                lda #blockwrite_offset
.8514		4c 79 d7	jmp $d779	                jmp push_upvar_tos
.8517						z_block_write_vector:
.8517						xt_bounds:
.8517		20 78 d8	jsr $d878	                jsr underflow_2
.851a		18		clc		                clc
.851b		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.851d		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.851f		75 02		adc $02,x	                adc 2,x
.8521		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8523		94 00		sty $00,x	                sty 0,x
.8525		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.8527		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8529		75 03		adc $03,x	                adc 3,x
.852b		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.852d		94 01		sty $01,x	                sty 1,x
.852f		60		rts		z_bounds:       rts
.8530						xt_bracket_char:
.8530		20 b4 85	jsr $85b4	                jsr xt_char
.8533		20 4e 93	jsr $934e	                jsr xt_literal
.8536		60		rts		z_bracket_char: rts
.8537						xt_bracket_tick:
.8537		20 8c a1	jsr $a18c	                jsr xt_tick
.853a		20 4e 93	jsr $934e	                jsr xt_literal
.853d		60		rts		z_bracket_tick: rts
.853e						xt_buffblocknum:
.853e		a9 2e		lda #$2e	                lda #buffblocknum_offset
.8540		4c 79 d7	jmp $d779	                jmp push_upvar_tos
.8543						z_buffblocknum:
.8543						xt_buffer:
.8543		a0 30		ldy #$30	                ldy #buffstatus_offset
.8545		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.8547		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8549		d0 0c		bne $8557	                bne _buffer_available ; Unused or not dirty = available
.854b		20 62 83	jsr $8362	                jsr xt_blkbuffer
.854e		20 3e 85	jsr $853e	                jsr xt_buffblocknum
.8551		20 32 8f	jsr $8f32	                jsr xt_fetch
.8554		20 04 85	jsr $8504	                jsr xt_block_write
.8557						_buffer_available:
.8557		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.8559		b5 00		lda $00,x	                lda 0,x
.855b		91 08		sta ($08),y	                sta (up),y
.855d		c8		iny		                iny
.855e		b5 01		lda $01,x	                lda 1,x
.8560		91 08		sta ($08),y	                sta (up),y
.8562		a9 01		lda #$01	                lda #1
.8564		a0 30		ldy #$30	                ldy #buffstatus_offset
.8566		91 08		sta ($08),y	                sta (up),y
.8568						_done:
.8568		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.856a		b1 08		lda ($08),y	                lda (up),y
.856c		95 00		sta $00,x	                sta 0,x
.856e		c8		iny		                iny
.856f		b1 08		lda ($08),y	                lda (up),y
.8571		95 01		sta $01,x	                sta 1,x
.8573		60		rts		z_buffer:       rts
.8574						xt_buffer_colon:
.8574		20 01 89	jsr $8901	                jsr xt_create
.8577		20 43 82	jsr $8243	                jsr xt_allot
.857a		60		rts		z_buffer_colon: rts
.857b						xt_buffstatus:
.857b		a9 30		lda #$30	                lda #buffstatus_offset
.857d		4c 79 d7	jmp $d779	                jmp push_upvar_tos
.8580						z_buffstatus:
.8580						xt_bye:
.8580		4c 2b f0	jmp $f02b	                jmp platform_bye
.8583						z_bye:
.8583						xt_c_comma:
.8583		20 73 d8	jsr $d873	                jsr underflow_1
.8586		b5 00		lda $00,x	                lda 0,x
.8588		20 1c d7	jsr $d71c	                jsr cmpl_a
.858b		e8		inx		                inx
.858c		e8		inx		                inx
.858d		60		rts		z_c_comma:      rts
.858e						xt_c_fetch:
.858e		20 73 d8	jsr $d873	                jsr underflow_1
.8591		a1 00		lda ($00,x)	                lda (0,x)
.8593		95 00		sta $00,x	                sta 0,x
.8595		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8597		60		rts		z_c_fetch:      rts
.8598						xt_c_store:
.8598		20 78 d8	jsr $d878	                jsr underflow_2
.859b		b5 02		lda $02,x	                lda 2,x
.859d		81 00		sta ($00,x)	                sta (0,x)
.859f		e8		inx		                inx
.85a0		e8		inx		                inx
.85a1		e8		inx		                inx
.85a2		e8		inx		                inx
.85a3		60		rts		z_c_store:      rts
.85a4						xt_cell_plus:
.85a4		20 73 d8	jsr $d873	                jsr underflow_1
.85a7		f6 00		inc $00,x	                inc 0,x
.85a9		d0 02		bne $85ad	                bne +
.85ab		f6 01		inc $01,x	                inc 1,x
.85ad						+
.85ad		f6 00		inc $00,x	                inc 0,x
.85af		d0 02		bne $85b3	                bne _done
.85b1		f6 01		inc $01,x	                inc 1,x
.85b3						_done:
.85b3		60		rts		z_cell_plus:    rts
.85b4						xt_char:
.85b4		20 ab 98	jsr $98ab	                jsr xt_parse_name
.85b7		b5 00		lda $00,x	                lda 0,x
.85b9		15 01		ora $01,x	                ora 1,x
.85bb		d0 05		bne $85c2	                bne _not_empty
.85bd		a9 05		lda #$05	                lda #err_noname
.85bf		4c 89 d8	jmp $d889	                jmp error
.85c2						_not_empty:
.85c2		e8		inx		                inx             ; drop number of characters, leave addr
.85c3		e8		inx		                inx
.85c4		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.85c6		95 00		sta $00,x	                sta 0,x
.85c8		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.85ca		60		rts		z_char:         rts
.85cb						xt_chars:
.85cb		20 73 d8	jsr $d873	                jsr underflow_1
.85ce		60		rts		z_chars:        rts
.85cf						xt_cleave:
.85cf		20 78 d8	jsr $d878	                jsr underflow_2
.85d2		20 38 95	jsr $9538	                jsr xt_minus_leading    ; -LEADING ( addr u )
.85d5		20 0d 92	jsr $920d	                jsr xt_input_to_r       ; save old imput state
.85d8		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.85da		85 0e		sta $0e		                sta ciblen
.85dc		b5 01		lda $01,x	                lda 1,x
.85de		85 0f		sta $0f		                sta ciblen+1
.85e0		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.85e2		85 0c		sta $0c		                sta cib
.85e4		b5 03		lda $03,x	                lda 3,x
.85e6		85 0d		sta $0d		                sta cib+1
.85e8		64 10		stz $10		                stz toin        ; >IN pointer is zero
.85ea		64 11		stz $11		                stz toin+1
.85ec		20 ab 98	jsr $98ab	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.85ef		b5 00		lda $00,x	                lda 0,x
.85f1		15 01		ora $01,x	                ora 1,x
.85f3		f0 23		beq $8618	                beq _done
.85f5		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.85f7		38		sec		                sec
.85f8		f5 00		sbc $00,x	                sbc 0,x
.85fa		95 04		sta $04,x	                sta 4,x
.85fc		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.85fe		f5 01		sbc $01,x	                sbc 1,x
.8600		95 05		sta $05,x	                sta 5,x
.8602		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8604		18		clc		                clc
.8605		75 00		adc $00,x	                adc 0,x
.8607		95 06		sta $06,x	                sta 6,x
.8609		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.860b		75 01		adc $01,x	                adc 1,x
.860d		95 07		sta $07,x	                sta 7,x
.860f		20 f9 a3	jsr $a3f9	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.8612		20 38 95	jsr $9538	                jsr xt_minus_leading
.8615		20 f9 a3	jsr $a3f9	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.8618						_done:
.8618		20 6f 9a	jsr $9a6f	                jsr xt_r_to_input
.861b		60		rts		z_cleave:       rts
.861c						xt_cmove:
.861c		20 7d d8	jsr $d87d	                jsr underflow_3
.861f		b5 02		lda $02,x	                lda 2,x
.8621		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.8623		b5 03		lda $03,x	                lda 3,x
.8625		85 28		sta $28		                sta tmp2+1
.8627		b5 04		lda $04,x	                lda 4,x
.8629		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.862b		b5 05		lda $05,x	                lda 5,x
.862d		85 26		sta $26		                sta tmp1+1
.862f		a0 00		ldy #$00	                ldy #0
.8631		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.8633		f0 0f		beq $8644	                beq _dopartial
.8635						_page:
.8635		b1 25		lda ($25),y	                lda (tmp1),y
.8637		91 27		sta ($27),y	                sta (tmp2),y
.8639		c8		iny		                iny
.863a		d0 f9		bne $8635	                bne _page
.863c		e6 26		inc $26		                inc tmp1+1
.863e		e6 28		inc $28		                inc tmp2+1
.8640		d6 01		dec $01,x	                dec 1,x
.8642		d0 f1		bne $8635	                bne _page
.8644						_dopartial:
.8644		b5 00		lda $00,x	                lda 0,x         ; length of last page
.8646		f0 09		beq $8651	                beq _done
.8648						_partial:
.8648		b1 25		lda ($25),y	                lda (tmp1),y
.864a		91 27		sta ($27),y	                sta (tmp2),y
.864c		c8		iny		                iny
.864d		d6 00		dec $00,x	                dec 0,x
.864f		d0 f7		bne $8648	                bne _partial
.8651						_done:
.8651		8a		txa		                txa
.8652		18		clc		                clc
.8653		69 06		adc #$06	                adc #6
.8655		aa		tax		                tax
.8656		60		rts		z_cmove:        rts
.8657						xt_cmove_up:
.8657		20 7d d8	jsr $d87d	                jsr underflow_3
.865a		b5 02		lda $02,x	                lda 2,x
.865c		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.865e		b5 03		lda $03,x	                lda 3,x
.8660		18		clc		                clc
.8661		75 01		adc $01,x	                adc 1,x
.8663		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.8665		b5 04		lda $04,x	                lda 4,x
.8667		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.8669		b5 05		lda $05,x	                lda 5,x
.866b		18		clc		                clc
.866c		75 01		adc $01,x	                adc 1,x
.866e		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.8670		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.8672		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.8674		f0 0e		beq $8684	                beq _nopartial
.8676						_outerloop:
.8676		88		dey		                dey
.8677		f0 07		beq $8680	                beq _finishpage
.8679						_innerloop:
.8679		b1 25		lda ($25),y	                lda (tmp1),y
.867b		91 27		sta ($27),y	                sta (tmp2),y
.867d		88		dey		                dey
.867e		d0 f9		bne $8679	                bne _innerloop
.8680						_finishpage:
.8680		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.8682		92 27		sta ($27)	                sta (tmp2)
.8684						_nopartial:
.8684		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.8686		c6 28		dec $28		                dec tmp2+1
.8688		d6 01		dec $01,x	                dec 1,x
.868a		d0 ea		bne $8676	                bne _outerloop
.868c						_done:
.868c		8a		txa		                txa
.868d		18		clc		                clc
.868e		69 06		adc #$06	                adc #6
.8690		aa		tax		                tax
.8691		60		rts		z_cmove_up:     rts
.8692						xt_colon:
.8692		a5 1a		lda $1a		                lda state
.8694		05 1b		ora $1b		                ora state+1
.8696		f0 05		beq $869d	                beq +
.8698		a9 07		lda #$07	                lda #err_state
.869a		4c 89 d8	jmp $d889	                jmp error
.869d						+
.869d		c6 1a		dec $1a		                dec state
.869f		c6 1b		dec $1b		                dec state+1
.86a1		a9 40		lda #$40	                lda #%01000000
.86a3		04 1c		tsb $1c		                tsb status
.86a5		20 ba d7	jsr $d7ba	                jsr current_to_dp
.86a8		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.86aa		48		pha		                pha
.86ab		a5 02		lda $02		                lda dp
.86ad		48		pha		                pha
.86ae		a9 80		lda #$80	                lda #%10000000
.86b0		04 1c		tsb $1c		                tsb status
.86b2		20 01 89	jsr $8901	                jsr xt_create
.86b5		20 ba d7	jsr $d7ba	                jsr current_to_dp   ; This might be able to be omitted
.86b8		a5 02		lda $02		                lda dp
.86ba		85 06		sta $06		                sta workword
.86bc		a5 03		lda $03		                lda dp+1
.86be		85 07		sta $07		                sta workword+1
.86c0		68		pla		                pla
.86c1		85 02		sta $02		                sta dp
.86c3		68		pla		                pla
.86c4		85 03		sta $03		                sta dp+1
.86c6		20 cd d7	jsr $d7cd	                jsr dp_to_current
.86c9		a5 00		lda $00		                lda cp
.86cb		38		sec		                sec
.86cc		e9 03		sbc #$03	                sbc #3
.86ce		85 00		sta $00		                sta cp
.86d0		b0 02		bcs $86d4	                bcs _done
.86d2		c6 01		dec $01		                dec cp+1
.86d4						_done:
.86d4		60		rts		z_colon:        rts
.86d5						xt_colon_noname:
.86d5		a5 1a		lda $1a		                lda state
.86d7		05 1b		ora $1b		                ora state+1
.86d9		f0 05		beq $86e0	                beq +
.86db		a9 07		lda #$07	                lda #err_state
.86dd		4c 89 d8	jmp $d889	                jmp error
.86e0						+
.86e0		c6 1a		dec $1a		                dec state
.86e2		c6 1b		dec $1b		                dec state+1
.86e4		a9 40		lda #$40	                lda #%01000000
.86e6		14 1c		trb $1c		                trb status
.86e8		a5 00		lda $00		                lda cp
.86ea		85 06		sta $06		                sta workword
.86ec		a5 01		lda $01		                lda cp+1
.86ee		85 07		sta $07		                sta workword+1
.86f0						_done:
.86f0		60		rts		z_colon_noname:        rts
.86f1						xt_comma:
.86f1		20 73 d8	jsr $d873	                jsr underflow_1
.86f4		b5 00		lda $00,x	                lda 0,x
.86f6		92 00		sta ($00)	                sta (cp)
.86f8		e6 00		inc $00		                inc cp
.86fa		d0 02		bne $86fe	                bne +
.86fc		e6 01		inc $01		                inc cp+1
.86fe						+
.86fe		b5 01		lda $01,x	                lda 1,x
.8700		92 00		sta ($00)	                sta (cp)
.8702		e6 00		inc $00		                inc cp
.8704		d0 02		bne $8708	                bne _done
.8706		e6 01		inc $01		                inc cp+1
.8708						_done:
.8708		e8		inx		                inx
.8709		e8		inx		                inx
.870a		60		rts		z_comma:        rts
.870b						xt_compare:
.870b		20 82 d8	jsr $d882	                jsr underflow_4
.870e		b5 02		lda $02,x	                lda 2,x
.8710		85 27		sta $27		                sta tmp2
.8712		b5 03		lda $03,x	                lda 3,x
.8714		85 28		sta $28		                sta tmp2+1
.8716		b5 06		lda $06,x	                lda 6,x
.8718		85 25		sta $25		                sta tmp1
.871a		b5 07		lda $07,x	                lda 7,x
.871c		85 26		sta $26		                sta tmp1+1
.871e						_compare_loop:
.871e		b5 04		lda $04,x	                lda 4,x
.8720		15 05		ora $05,x	                ora 5,x
.8722		f0 2c		beq $8750	                beq _str1_done
.8724		b5 00		lda $00,x	                lda 0,x
.8726		15 01		ora $01,x	                ora 1,x
.8728		f0 3a		beq $8764	                beq _greater    ; Str2 empty first
.872a						_check_letter:
.872a		b2 25		lda ($25)	                lda (tmp1)
.872c		d2 27		cmp ($27)	                cmp (tmp2)
.872e		90 26		bcc $8756	                bcc _less
.8730		d0 32		bne $8764	                bne _greater
.8732						_next_letter:
.8732		e6 25		inc $25		                inc tmp1
.8734		d0 02		bne $8738	                bne +
.8736		e6 26		inc $26		                inc tmp1+1
.8738						+
.8738		e6 27		inc $27		                inc tmp2
.873a		d0 02		bne $873e	                bne +
.873c		e6 28		inc $28		                inc tmp2+1
.873e						+
.873e		b5 04		lda $04,x	                lda 4,x
.8740		d0 02		bne $8744	                bne +
.8742		d6 05		dec $05,x	                dec 5,x
.8744						+
.8744		d6 04		dec $04,x	                dec 4,x
.8746		b5 00		lda $00,x	                lda 0,x
.8748		d0 02		bne $874c	                bne +
.874a		d6 01		dec $01,x	                dec 1,x
.874c						+
.874c		d6 00		dec $00,x	                dec 0,x
.874e		80 ce		bra $871e	                bra _compare_loop
.8750						_str1_done:
.8750		b5 00		lda $00,x	                lda 0,x
.8752		15 01		ora $01,x	                ora 1,x
.8754		f0 08		beq $875e	                beq _equal      ; Both out of letters
.8756						_less:
.8756		a9 ff		lda #$ff	                lda #$FF
.8758		95 06		sta $06,x	                sta 6,x
.875a		95 07		sta $07,x	                sta 7,x
.875c		80 0c		bra $876a	                bra _done
.875e						_equal:
.875e		74 06		stz $06,x	                stz 6,x
.8760		74 07		stz $07,x	                stz 7,x
.8762		80 06		bra $876a	                bra _done
.8764						_greater:
.8764		a9 01		lda #$01	                lda #1
.8766		95 06		sta $06,x	                sta 6,x
.8768		74 07		stz $07,x	                stz 7,x
.876a						_done:
.876a		8a		txa		                txa
.876b		18		clc		                clc
.876c		69 06		adc #$06	                adc #6
.876e		aa		tax		                tax
.876f		60		rts		z_compare:      rts
.8770						xt_compile_comma:
.8770		20 73 d8	jsr $d873	                jsr underflow_1
.8773		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8775		48		pha		                pha
.8776		b5 00		lda $00,x	                lda 0,x
.8778		48		pha		                pha                     ; LSB
.8779		20 23 92	jsr $9223	                jsr xt_int_to_name      ; ( xt -- nt )
.877c		b5 00		lda $00,x	                lda 0,x
.877e		15 01		ora $01,x	                ora 1,x
.8780		d0 03		bne $8785	                bne _check_nt
.8782		4c 82 88	jmp $8882	                jmp compile_as_jump
.8785						_check_nt:
.8785		b5 00		lda $00,x	                lda 0,x
.8787		85 23		sta $23		                sta tmptos
.8789		b5 01		lda $01,x	                lda 1,x
.878b		85 24		sta $24		                sta tmptos+1
.878d		f6 00		inc $00,x	                inc 0,x
.878f		d0 02		bne $8793	                bne +
.8791		f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.8793						+
.8793		a1 00		lda ($00,x)	                lda (0,x)
.8795		85 29		sta $29		                sta tmp3                ; keep copy of status byte for NN
.8797		29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8799		f0 0d		beq $87a8	                beq _compile_check
.879b		a5 23		lda $23		                lda tmptos
.879d		95 00		sta $00,x	                sta 0,x
.879f		a5 24		lda $24		                lda tmptos+1
.87a1		95 01		sta $01,x	                sta 1,x
.87a3		20 03 a7	jsr $a703	                jsr xt_wordsize         ; ( nt -- u )
.87a6		80 28		bra $87d0	                bra _compile_as_code
.87a8						_compile_check:
.87a8		a5 29		lda $29		                lda tmp3
.87aa		29 08		and #$08	                and #NN
.87ac		f0 03		beq $87b1	                beq _check_size_limit
.87ae		4c 82 88	jmp $8882	                jmp compile_as_jump    ; too far for BRA
.87b1						_check_size_limit:
.87b1		a5 23		lda $23		                lda tmptos
.87b3		95 00		sta $00,x	                sta 0,x
.87b5		a5 24		lda $24		                lda tmptos+1
.87b7		95 01		sta $01,x	                sta 1,x
.87b9		20 03 a7	jsr $a703	                jsr xt_wordsize         ; ( nt -- u )
.87bc		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.87be		b5 01		lda $01,x	                lda 1,x
.87c0		d1 08		cmp ($08),y	                cmp (up),y
.87c2		90 0c		bcc $87d0	                bcc _compile_as_code    ; user-defined limit MSB
.87c4		d0 07		bne $87cd	                bne _jumpto_compile_as_jump
.87c6		88		dey		                dey
.87c7		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.87c9		d5 00		cmp $00,x	                cmp 0,x
.87cb		10 03		bpl $87d0	                bpl _compile_as_code    ; Allow native compiling for less
.87cd						_jumpto_compile_as_jump:
.87cd		4c 82 88	jmp $8882	                jmp compile_as_jump    ; too far for BRA
.87d0						_compile_as_code:
.87d0		ca		dex		                dex
.87d1		ca		dex		                dex                     ; ( -- u ? )
.87d2		ca		dex		                dex
.87d3		ca		dex		                dex                     ; ( -- u ? ? )
.87d4		b5 04		lda $04,x	                lda 4,x
.87d6		95 00		sta $00,x	                sta 0,x                 ; LSB of u
.87d8		b5 05		lda $05,x	                lda 5,x
.87da		95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.87dc		68		pla		                pla
.87dd		95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.87df		68		pla		                pla
.87e0		95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.87e2		a5 00		lda $00		                lda cp                  ; LSB of cp
.87e4		95 02		sta $02,x	                sta 2,x
.87e6		a5 01		lda $01		                lda cp+1
.87e8		95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.87ea		a0 00		ldy #$00	                ldy #0
.87ec						_strip_loop:
.87ec		b9 70 88	lda $8870,y	                lda strip_table,y      ; LSB of first word
.87ef		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.87f1		d0 07		bne $87fa	                bne _next_entry
.87f3		b9 71 88	lda $8871,y	                lda strip_table+1,y
.87f6		d5 05		cmp $05,x	                cmp 5,x
.87f8		f0 0c		beq $8806	                beq _found_entry
.87fa						_next_entry:
.87fa		b9 70 88	lda $8870,y	                lda strip_table,y      ; pointing to LSB
.87fd		19 71 88	ora $8871,y	                ora strip_table+1,y    ; get MSB
.8800		f0 22		beq $8824	                beq _underflow_strip    ; table done, let's get out of here
.8802		c8		iny		                iny
.8803		c8		iny		                iny
.8804		80 e6		bra $87ec	                bra _strip_loop
.8806						_found_entry:
.8806		98		tya		                tya
.8807		4a		lsr a		                lsr
.8808		a8		tay		                tay
.8809		b9 7c 88	lda $887c,y	                lda strip_size,y
.880c		85 23		sta $23		                sta tmptos              ; save a copy
.880e		18		clc		                clc
.880f		75 04		adc $04,x	                adc 4,x
.8811		95 04		sta $04,x	                sta 4,x
.8813		90 02		bcc $8817	                bcc+
.8815		f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8817						+
.8817		06 23		asl $23		                asl tmptos
.8819		38		sec		                sec
.881a		b5 00		lda $00,x	                lda 0,x
.881c		e5 23		sbc $23		                sbc tmptos
.881e		95 00		sta $00,x	                sta 0,x
.8820		b0 02		bcs $8824	                bcs +
.8822		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8824						+
.8824						_underflow_strip:
.8824		a0 02		ldy #$02	                ldy #uf_strip_offset
.8826		b1 08		lda ($08),y	                lda (up),y
.8828		c8		iny		                iny
.8829		11 08		ora ($08),y	                ora (up),y
.882b		f0 1c		beq $8849	                beq cmpl_inline
.882d		a5 29		lda $29		                lda tmp3
.882f		29 10		and #$10	                and #UF
.8831		f0 16		beq $8849	                beq cmpl_inline
.8833		18		clc		                clc
.8834		b5 04		lda $04,x	                lda 4,x
.8836		69 03		adc #$03	                adc #3
.8838		95 04		sta $04,x	                sta 4,x
.883a		90 02		bcc $883e	                bcc +
.883c		f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.883e						+
.883e		38		sec		                sec
.883f		b5 00		lda $00,x	                lda 0,x
.8841		e9 03		sbc #$03	                sbc #3
.8843		95 00		sta $00,x	                sta 0,x
.8845		b0 02		bcs $8849	                bcs +
.8847		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.8849						+
.8849						cmpl_inline:
.8849		b5 01		lda $01,x	                lda 1,x                 ; MSB
.884b		48		pha		                pha
.884c		b5 00		lda $00,x	                lda 0,x                 ; LSB
.884e		48		pha		                pha
.884f		20 97 95	jsr $9597	                jsr xt_move
.8852		18		clc		                clc
.8853		68		pla		                pla                     ; LSB
.8854		65 00		adc $00		                adc cp
.8856		85 00		sta $00		                sta cp
.8858		68		pla		                pla                     ; MSB
.8859		65 01		adc $01		                adc cp+1
.885b		85 01		sta $01		                sta cp+1
.885d		60		rts		                rts
.885e						cmpl_inline_y:
.885e		ca		dex		                dex             ; set up stack as ( src dst n -- )
.885f		ca		dex		                dex
.8860		ca		dex		                dex
.8861		ca		dex		                dex
.8862		94 00		sty $00,x	                sty 0,x
.8864		74 01		stz $01,x	                stz 1,x             ; assume < 256 bytes
.8866		a5 00		lda $00		                lda cp
.8868		95 02		sta $02,x	                sta 2,x
.886a		a5 01		lda $01		                lda cp+1
.886c		95 03		sta $03,x	                sta 3,x
.886e		80 d9		bra $8849	                bra cmpl_inline
.8870						strip_table:
>8870		5e 9a 49 9a eb a2		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>8876		1d a4 a3 a3 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.887c						strip_size:
>887c		04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.8882						compile_as_jump:
.8882		a9 20		lda #$20	                lda #$20
.8884		92 00		sta ($00)	                sta (cp)
.8886		a0 01		ldy #$01	                ldy #1
.8888		68		pla		                pla             ; LSB
.8889		91 00		sta ($00),y	                sta (cp),y
.888b		c8		iny		                iny
.888c		68		pla		                pla             ; MSB
.888d		91 00		sta ($00),y	                sta (cp),y
.888f		a9 03		lda #$03	                lda #3
.8891		18		clc		                clc
.8892		65 00		adc $00		                adc cp
.8894		85 00		sta $00		                sta cp
.8896		90 02		bcc $889a	                bcc +
.8898		e6 01		inc $01		                inc cp+1
.889a						+
.889a		e8		inx		                inx             ; drop xt
.889b		e8		inx		                inx
.889c						z_compile_comma:
.889c		60		rts		                rts
.889d						xt_compile_only:
.889d		20 ba d7	jsr $d7ba	                jsr current_to_dp
.88a0		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.88a2		b1 02		lda ($02),y	                lda (dp),y
.88a4		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.88a6		91 02		sta ($02),y	                sta (dp),y
.88a8		60		rts		z_compile_only: rts
.88a9						xt_value:
.88a9						xt_constant:
.88a9		20 73 d8	jsr $d873	                jsr underflow_1
.88ac		20 01 89	jsr $8901	                jsr xt_create
.88af		38		sec		                sec
.88b0		a5 00		lda $00		                lda cp
.88b2		e9 02		sbc #$02	                sbc #2
.88b4		85 25		sta $25		                sta tmp1
.88b6		a5 01		lda $01		                lda cp+1
.88b8		e9 00		sbc #$00	                sbc #0
.88ba		85 26		sta $26		                sta tmp1+1
.88bc		a9 25		lda #$25	                lda #<doconst           ; LSB of DOCONST
.88be		92 25		sta ($25)	                sta (tmp1)
.88c0		a0 01		ldy #$01	                ldy #1
.88c2		a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.88c4		91 25		sta ($25),y	                sta (tmp1),y
.88c6		20 f1 86	jsr $86f1	                jsr xt_comma            ; drop through to adjust_z
.88c9						adjust_z:
.88c9		20 e6 92	jsr $92e6	                jsr xt_latestnt         ; gives us ( -- nt )
.88cc		b5 00		lda $00,x	                lda 0,x
.88ce		85 25		sta $25		                sta tmp1
.88d0		b5 01		lda $01,x	                lda 1,x
.88d2		85 26		sta $26		                sta tmp1+1
.88d4		a0 06		ldy #$06	                ldy #6
.88d6		b1 25		lda ($25),y	                lda (tmp1),y
.88d8		18		clc		                clc
.88d9		69 02		adc #$02	                adc #2
.88db		91 25		sta ($25),y	                sta (tmp1),y
.88dd		c8		iny		                iny
.88de		b1 25		lda ($25),y	                lda (tmp1),y
.88e0		69 00		adc #$00	                adc #0                  ; only need carry
.88e2		91 25		sta ($25),y	                sta (tmp1),y
.88e4		e8		inx		                inx
.88e5		e8		inx		                inx
.88e6						z_value:
.88e6		60		rts		z_constant:     rts
.88e7						xt_count:
.88e7		20 73 d8	jsr $d873	                jsr underflow_1
.88ea		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.88ec		a8		tay		                tay
.88ed		f6 00		inc $00,x	                inc 0,x         ; LSB
.88ef		d0 02		bne $88f3	                bne +
.88f1		f6 01		inc $01,x	                inc 1,x         ; MSB
.88f3		98		tya		+               tya
.88f4		ca		dex		                dex
.88f5		ca		dex		                dex
.88f6		95 00		sta $00,x	                sta 0,x         ; LSB
.88f8		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.88fa		60		rts		z_count:        rts
.88fb						xt_cr:
.88fb		a9 0a		lda #$0a	                lda #AscLF
.88fd		20 a8 8d	jsr $8da8	                jsr emit_a
.8900		60		rts		z_cr:           rts
.8901						xt_create:
.8901		20 ab 98	jsr $98ab	                jsr xt_parse_name       ; ( addr u )
.8904		b5 00		lda $00,x	                lda 0,x
.8906		15 01		ora $01,x	                ora 1,x
.8908		d0 05		bne $890f	                bne _got_name
.890a		a9 05		lda #$05	                lda #err_noname
.890c		4c 89 d8	jmp $d889	                jmp error
.890f						_got_name:
.890f		74 01		stz $01,x	                stz 1,x
.8911		20 33 a3	jsr $a333	                jsr xt_two_dup          ; ( addr u addr u )
.8914		20 8d 8f	jsr $8f8d	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8917		b5 00		lda $00,x	                lda 0,x
.8919		15 01		ora $01,x	                ora 1,x
.891b		f0 1e		beq $893b	                beq _new_name           ; We haven't seen this one before.
.891d		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.891e		e8		inx		                inx
.891f		24 1c		bit $1c		                bit status
.8921		10 08		bpl $892b	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8923		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8925		05 1c		ora $1c		                ora status
.8927		85 1c		sta $1c		                sta status
.8929		80 18		bra $8943	                bra _process_name
.892b						_redefined_name:
.892b		a9 02		lda #$02	                lda #str_redefined
.892d		20 af d8	jsr $d8af	                jsr print_string_no_lf
.8930		20 33 a3	jsr $a333	                jsr xt_two_dup           ; ( addr u addr u )
.8933		20 7e a4	jsr $a47e	                jsr xt_type
.8936		20 a9 a0	jsr $a0a9	                jsr xt_space
.8939		80 08		bra $8943	                bra _process_name
.893b						_new_name:
.893b		e8		inx		                inx                     ; Drop flag (0) from find-name.
.893c		e8		inx		                inx
.893d		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.893f		25 1c		and $1c		                and status
.8941		85 1c		sta $1c		                sta status
.8943						_process_name:
.8943		b5 00		lda $00,x	                lda 0,x
.8945		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8947		a5 00		lda $00		                lda cp
.8949		85 25		sta $25		                sta tmp1
.894b		a5 01		lda $01		                lda cp+1
.894d		85 26		sta $26		                sta tmp1+1
.894f		b5 00		lda $00,x	                lda 0,x
.8951		18		clc		                clc
.8952		69 08		adc #$08	                adc #8
.8954		85 29		sta $29		                sta tmp3                ; total header length
.8956		18		clc		                clc
.8957		69 03		adc #$03	                adc #3
.8959		95 00		sta $00,x	                sta 0,x
.895b		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.895d		20 43 82	jsr $8243	                jsr xt_allot    ; ( addr )
.8960		20 ba d7	jsr $d7ba	                jsr current_to_dp
.8963		a0 00		ldy #$00	                ldy #0
.8965		a5 27		lda $27		                lda tmp2
.8967		91 25		sta ($25),y	                sta (tmp1),y
.8969		a9 08		lda #$08	                lda #NN
.896b		09 20		ora #$20	                ora #HC
.896d		c8		iny		                iny
.896e		91 25		sta ($25),y	                sta (tmp1),y
.8970		c8		iny		                iny
.8971		a5 02		lda $02		                lda dp
.8973		91 25		sta ($25),y	                sta (tmp1),y
.8975		c8		iny		                iny
.8976		a5 03		lda $03		                lda dp+1
.8978		91 25		sta ($25),y	                sta (tmp1),y
.897a		c8		iny		                iny
.897b		a5 26		lda $26		                lda tmp1+1
.897d		85 03		sta $03		                sta dp+1
.897f		a5 25		lda $25		                lda tmp1
.8981		85 02		sta $02		                sta dp
.8983		18		clc		                clc
.8984		65 29		adc $29		                adc tmp3        ; add total header length
.8986		91 25		sta ($25),y	                sta (tmp1),y
.8988		48		pha		                pha             ; we need this in the next step
.8989		c8		iny		                iny
.898a		a5 26		lda $26		                lda tmp1+1
.898c		69 00		adc #$00	                adc #0          ; only need the carry
.898e		91 25		sta ($25),y	                sta (tmp1),y
.8990		c8		iny		                iny
.8991		68		pla		                pla             ; LSB of "z_" address
.8992		18		clc		                clc
.8993		69 03		adc #$03	                adc #3
.8995		91 25		sta ($25),y	                sta (tmp1),y
.8997		88		dey		                dey             ; get the MSB of xt back
.8998		b1 25		lda ($25),y	                lda (tmp1),y
.899a		69 00		adc #$00	                adc #0          ; only need the carry
.899c		c8		iny		                iny
.899d		c8		iny		                iny
.899e		91 25		sta ($25),y	                sta (tmp1),y
.89a0		c8		iny		                iny
.89a1		b5 00		lda $00,x	                lda 0,x
.89a3		38		sec		                sec
.89a4		e9 08		sbc #$08	                sbc #8
.89a6		85 23		sta $23		                sta tmptos
.89a8		b5 01		lda $01,x	                lda 1,x
.89aa		e9 00		sbc #$00	                sbc #0          ; only need carry
.89ac		85 24		sta $24		                sta tmptos+1
.89ae						_name_loop:
.89ae		b1 23		lda ($23),y	                lda (tmptos),y
.89b0		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.89b2		b0 07		bcs $89bb	                bcs _store_name
.89b4		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.89b6		90 03		bcc $89bb	                bcc _store_name
.89b8		18		clc		                clc
.89b9		69 20		adc #$20	                adc #$20
.89bb						_store_name:
.89bb		91 25		sta ($25),y	                sta (tmp1),y
.89bd		c8		iny		                iny
.89be		c6 27		dec $27		                dec tmp2
.89c0		d0 ec		bne $89ae	                bne _name_loop
.89c2		a9 20		lda #$20	                lda #$20        ; opcode of JSR
.89c4		91 25		sta ($25),y	                sta (tmp1),y
.89c6		c8		iny		                iny
.89c7		a9 6b		lda #$6b	                lda #<dovar
.89c9		91 25		sta ($25),y	                sta (tmp1),y
.89cb		c8		iny		                iny
.89cc		a9 d7		lda #$d7	                lda #>dovar
.89ce		91 25		sta ($25),y	                sta (tmp1),y
.89d0		20 cd d7	jsr $d7cd	                jsr dp_to_current
.89d3		e8		inx		                inx
.89d4		e8		inx		                inx
.89d5		60		rts		z_create:       rts
.89d6						xt_d_minus:
.89d6		20 82 d8	jsr $d882	                jsr underflow_4 ; two double numbers
.89d9		38		sec		                sec
.89da		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.89dc		f5 02		sbc $02,x	                sbc 2,x
.89de		95 06		sta $06,x	                sta 6,x
.89e0		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.89e2		f5 03		sbc $03,x	                sbc 3,x
.89e4		95 07		sta $07,x	                sta 7,x
.89e6		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.89e8		f5 00		sbc $00,x	                sbc 0,x
.89ea		95 04		sta $04,x	                sta 4,x
.89ec		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.89ee		f5 01		sbc $01,x	                sbc 1,x
.89f0		95 05		sta $05,x	                sta 5,x
.89f2		e8		inx		                inx
.89f3		e8		inx		                inx
.89f4		e8		inx		                inx
.89f5		e8		inx		                inx
.89f6		60		rts		z_d_minus:      rts
.89f7						xt_d_plus:
.89f7		20 82 d8	jsr $d882	                jsr underflow_4 ; two double numbers
.89fa		18		clc		                clc
.89fb		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.89fd		75 06		adc $06,x	                adc 6,x
.89ff		95 06		sta $06,x	                sta 6,x
.8a01		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a03		75 07		adc $07,x	                adc 7,x
.8a05		95 07		sta $07,x	                sta 7,x
.8a07		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a09		75 04		adc $04,x	                adc 4,x
.8a0b		95 04		sta $04,x	                sta 4,x
.8a0d		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a0f		75 05		adc $05,x	                adc 5,x
.8a11		95 05		sta $05,x	                sta 5,x
.8a13		e8		inx		                inx
.8a14		e8		inx		                inx
.8a15		e8		inx		                inx
.8a16		e8		inx		                inx
.8a17		60		rts		z_d_plus:       rts
.8a18						xt_d_to_s:
.8a18		20 78 d8	jsr $d878	                jsr underflow_2
.8a1b		e8		inx		                inx
.8a1c		e8		inx		                inx
.8a1d		60		rts		z_d_to_s:       rts
.8a1e						xt_dabs:
.8a1e		20 78 d8	jsr $d878	                jsr underflow_2 ; double number
.8a21		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a23		10 17		bpl $8a3c	                bpl _done       ; positive, we get off light
.8a25		a0 00		ldy #$00	                ldy #0
.8a27		38		sec		                sec
.8a28		98		tya		                tya
.8a29		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a2b		95 02		sta $02,x	                sta 2,x
.8a2d		98		tya		                tya
.8a2e		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a30		95 03		sta $03,x	                sta 3,x
.8a32		98		tya		                tya
.8a33		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a35		95 00		sta $00,x	                sta 0,x
.8a37		98		tya		                tya
.8a38		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a3a		95 01		sta $01,x	                sta 1,x
.8a3c						_done:
.8a3c		60		rts		z_dabs:         rts
.8a3d						xt_decimal:
.8a3d		a9 0a		lda #$0a	                lda #10
.8a3f		85 18		sta $18		                sta base
.8a41		64 19		stz $19		                stz base+1              ; paranoid
.8a43		60		rts		z_decimal:      rts
.8a44						xt_defer:
.8a44		20 01 89	jsr $8901	                jsr xt_create
.8a47		a5 00		lda $00		                lda cp          ; LSB
.8a49		38		sec		                sec
.8a4a		e9 02		sbc #$02	                sbc #2
.8a4c		85 25		sta $25		                sta tmp1
.8a4e		a5 01		lda $01		                lda cp+1        ; MSB
.8a50		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8a52		85 26		sta $26		                sta tmp1+1
.8a54		a0 00		ldy #$00	                ldy #0
.8a56		a9 39		lda #$39	                lda #<dodefer   ; LSB
.8a58		91 25		sta ($25),y	                sta (tmp1),y
.8a5a		c8		iny		                iny
.8a5b		a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8a5d		91 25		sta ($25),y	                sta (tmp1),y
.8a5f		a9 4d		lda #$4d	                lda #<defer_error
.8a61		92 00		sta ($00)	                sta (cp)
.8a63		e6 00		inc $00		                inc cp
.8a65		d0 02		bne $8a69	                bne +
.8a67		e6 01		inc $01		                inc cp+1
.8a69						+
.8a69		a9 d7		lda #$d7	                lda #>defer_error
.8a6b		92 00		sta ($00)	                sta (cp)
.8a6d		e6 00		inc $00		                inc cp
.8a6f		d0 02		bne $8a73	                bne +
.8a71		e6 01		inc $01		                inc cp+1
.8a73						+
.8a73		20 c9 88	jsr $88c9	                jsr adjust_z    ; adjust header to correct length
.8a76		60		rts		z_defer:        rts
.8a77						xt_defer_fetch:
.8a77		20 08 a2	jsr $a208	                jsr xt_to_body
.8a7a		20 32 8f	jsr $8f32	                jsr xt_fetch
.8a7d		60		rts		z_defer_fetch:  rts
.8a7e						xt_defer_store:
.8a7e		20 08 a2	jsr $a208	                jsr xt_to_body
.8a81		20 18 a1	jsr $a118	                jsr xt_store
.8a84		60		rts		z_defer_store:  rts
.8a85						xt_definitions:
.8a85		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.8a87		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8a89		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.8a8b		91 08		sta ($08),y	                sta (up),y
.8a8d		60		rts		z_definitions:  rts
.8a8e						xt_depth:
.8a8e		a9 78		lda #$78	                lda #dsp0
.8a90		86 1e		stx $1e		                stx tmpdsp
.8a92		38		sec		                sec
.8a93		e5 1e		sbc $1e		                sbc tmpdsp
.8a95		4a		lsr a		                lsr
.8a96		ca		dex		                dex
.8a97		ca		dex		                dex
.8a98		95 00		sta $00,x	                sta 0,x
.8a9a		74 01		stz $01,x	                stz 1,x
.8a9c		60		rts		z_depth:        rts
.8a9d						xt_digit_question:
.8a9d		20 73 d8	jsr $d873	                jsr underflow_1
.8aa0		ca		dex		                dex
.8aa1		ca		dex		                dex
.8aa2		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8aa4		74 01		stz $01,x	                stz 1,x
.8aa6		74 03		stz $03,x	                stz 3,x                 ; paranoid
.8aa8		b5 02		lda $02,x	                lda 2,x
.8aaa		c9 30		cmp #$30	                cmp #'0'
.8aac		90 23		bcc $8ad1	                bcc _done               ; failure flag already set
.8aae		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8ab0		90 12		bcc $8ac4	                bcc _checkbase
.8ab2		c9 41		cmp #$41	                cmp #'A'
.8ab4		90 1b		bcc $8ad1	                bcc _done               ; failure flag is already set
.8ab6		c9 61		cmp #$61	                cmp #'a'
.8ab8		90 07		bcc $8ac1	                bcc _case_done          ; not lower case, too low
.8aba		c9 7b		cmp #$7b	                cmp #'z'+1
.8abc		b0 03		bcs $8ac1	                bcs _case_done          ; not lower case, too high
.8abe		18		clc		                clc                     ; just right
.8abf		69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8ac1						_case_done:
.8ac1		38		sec		                sec
.8ac2		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8ac4						_checkbase:
.8ac4		38		sec		                sec
.8ac5		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8ac7		c5 18		cmp $18		                cmp base
.8ac9		b0 06		bcs $8ad1	                bcs _done               ; already have false flag
.8acb		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8acd		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8acf		d6 01		dec $01,x	                dec 1,x
.8ad1						_done:
.8ad1						z_digit_question:
.8ad1		60		rts		                rts
.8ad2						xt_disasm:
.8ad2		20 78 d8	jsr $d878	                jsr underflow_2
.8ad5		20 b5 ac	jsr $acb5	                jsr disassembler
.8ad8		60		rts		z_disasm:       rts
.8ad9						xt_dnegate:
.8ad9		20 78 d8	jsr $d878	                jsr underflow_2 ; double number
.8adc		a0 00		ldy #$00	     		ldy #0
.8ade		38		sec		                sec
.8adf		98		tya		                tya
.8ae0		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8ae2		95 02		sta $02,x	                sta 2,x
.8ae4		98		tya		                tya
.8ae5		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8ae7		95 03		sta $03,x	                sta 3,x
.8ae9		98		tya		                tya
.8aea		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8aec		95 00		sta $00,x	                sta 0,x
.8aee		98		tya		                tya
.8aef		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8af1		95 01		sta $01,x	                sta 1,x
.8af3		60		rts		z_dnegate:      rts
.8af4						xt_question_do:
.8af4		a0 01		ldy #$01	                ldy #1                  ; 1 is ?DO, jump to common code
.8af6		80 02		bra $8afa	                bra do_common           ; skip flag for DO
.8af8						xt_do:
.8af8		a0 00		ldy #$00	                ldy #0                ; 0 is DO, drop through to DO_COMMON
.8afa						do_common:
.8afa		f0 19		beq $8b15	                beq _compile_do
.8afc		ca		dex		                dex
.8afd		ca		dex		                dex
.8afe		a9 32		lda #$32	                lda #<question_do_runtime
.8b00		95 00		sta $00,x	                sta 0,x
.8b02		a9 8b		lda #$8b	                lda #>question_do_runtime
.8b04		95 01		sta $01,x	                sta 1,x
.8b06		a0 10		ldy #$10	                ldy #question_do_runtime_end-question_do_runtime
.8b08		20 5e 88	jsr $885e	                jsr cmpl_inline_y
.8b0b		a5 00		lda $00		                lda cp
.8b0d		a4 01		ldy $01		                ldy cp+1
.8b0f		20 1c d7	jsr $d71c	                jsr cmpl_a      ; write two arbitrary placeholder bytes
.8b12		20 1c d7	jsr $d71c	                jsr cmpl_a
.8b15						_compile_do:
.8b15		ca		dex		                dex
.8b16		ca		dex		                dex
.8b17		95 00		sta $00,x	                sta 0,x
.8b19		98		tya		                tya
.8b1a		95 01		sta $01,x	                sta 1,x
.8b1c		ca		dex		                dex
.8b1d		ca		dex		                dex
.8b1e		a5 21		lda $21		                lda loopleave
.8b20		95 00		sta $00,x	                sta 0,x
.8b22		a5 22		lda $22		                lda loopleave+1
.8b24		95 01		sta $01,x	                sta 1,x
.8b26		64 22		stz $22		                stz loopleave+1
.8b28		a0 8b		ldy #$8b	                ldy #>do_runtime
.8b2a		a9 42		lda #$42	                lda #<do_runtime
.8b2c		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.8b2f		4c 24 91	jmp $9124	                jmp xt_here
.8b32						z_question_do:
.8b32						z_do:
.8b32						question_do_runtime:
.8b32		20 33 a3	jsr $a333	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8b35		20 80 8e	jsr $8e80	                jsr xt_equal            ; ( -- n1 n2 f )
.8b38		20 c1 91	jsr $91c1	                jsr zero_test_runtime   ; consume f, setting Z
.8b3b		f0 07		beq $8b44	                beq question_do_runtime_end+2
.8b3d		e8		inx		                inx                     ; drop loop limits
.8b3e		e8		inx		                inx
.8b3f		e8		inx		                inx
.8b40		e8		inx		                inx
>8b41		4c				                .byte $4c              ; jmp
.8b42						question_do_runtime_end:
.8b42						do_runtime:
.8b42		a4 1f		ldy $1f		                ldy loopctrl
.8b44		30 05		bmi $8b4b	                bmi +                   ; is this the first LCB?
.8b46		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.8b48		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.8b4b						+
.8b4b		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.8b4c		c8		iny		                iny
.8b4d		c8		iny		                iny
.8b4e		c8		iny		                iny
.8b4f		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.8b51		38		sec		                sec
.8b52		a9 00		lda #$00	                lda #0
.8b54		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.8b56		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.8b59		a9 80		lda #$80	                lda #$80
.8b5b		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.8b5d		99 03 01	sta $0103,y	                sta loopfufa+1,y
.8b60		18		clc		                clc
.8b61		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.8b63		79 02 01	adc $0102,y	                adc loopfufa,y
.8b66		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.8b68		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.8b6a		79 03 01	adc $0103,y	                adc loopfufa+1,y
.8b6d		99 01 01	sta $0101,y	                sta loopindex+1,y
.8b70		e8		inx		                inx                 ; clean up the stack
.8b71		e8		inx		                inx
.8b72		e8		inx		                inx
.8b73		e8		inx		                inx
.8b74		60		rts		                rts
.8b75						xt_does:
.8b75		a0 8b		ldy #$8b	                ldy #>does_runtime
.8b77		a9 84		lda #$84	                lda #<does_runtime
.8b79		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.8b7c		a0 d7		ldy #$d7	                ldy #>dodoes
.8b7e		a9 52		lda #$52	                lda #<dodoes
.8b80		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.8b83		60		rts		z_does:         rts
.8b84						does_runtime:
.8b84		7a		ply		                ply             ; LSB
.8b85		68		pla		                pla             ; MSB
.8b86		c8		iny		                iny
.8b87		d0 01		bne $8b8a	                bne +
.8b89		1a		inc a		                ina
.8b8a						+
.8b8a		84 25		sty $25		                sty tmp1
.8b8c		85 26		sta $26		                sta tmp1+1
.8b8e		20 ba d7	jsr $d7ba	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8b91		a5 02		lda $02		                lda dp
.8b93		18		clc		                clc
.8b94		69 04		adc #$04	                adc #4
.8b96		85 27		sta $27		                sta tmp2
.8b98		a5 03		lda $03		                lda dp+1
.8b9a		69 00		adc #$00	                adc #0          ; we only care about the carry
.8b9c		85 28		sta $28		                sta tmp2+1
.8b9e		b2 27		lda ($27)	                lda (tmp2)
.8ba0		18		clc		                clc
.8ba1		69 01		adc #$01	                adc #1
.8ba3		85 29		sta $29		                sta tmp3
.8ba5		a0 01		ldy #$01	                ldy #1
.8ba7		b1 27		lda ($27),y	                lda (tmp2),y
.8ba9		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bab		85 2a		sta $2a		                sta tmp3+1
.8bad		a5 25		lda $25		                lda tmp1        ; LSB
.8baf		92 29		sta ($29)	                sta (tmp3)
.8bb1		a5 26		lda $26		                lda tmp1+1
.8bb3		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.8bb5		60		rts		                rts
.8bb6						xt_dot:
.8bb6		20 73 d8	jsr $d873	                jsr underflow_1
.8bb9		20 2f 8d	jsr $8d2f	                jsr xt_dup                      ; ( n n )
.8bbc		20 d1 80	jsr $80d1	                jsr xt_abs                      ; ( n u )
.8bbf		20 36 a7	jsr $a736	                jsr xt_zero                     ; ( n u 0 )
.8bc2		20 1e 93	jsr $931e	                jsr xt_less_number_sign         ; ( n u 0 )
.8bc5		20 aa 97	jsr $97aa	                jsr xt_number_sign_s            ; ( n ud )
.8bc8		20 1c 9b	jsr $9b1c	                jsr xt_rot                      ; ( ud n )
.8bcb		20 72 9f	jsr $9f72	                jsr xt_sign                     ; ( ud )
.8bce		20 88 97	jsr $9788	                jsr xt_number_sign_greater      ; ( addr u )
.8bd1		20 7e a4	jsr $a47e	                jsr xt_type
.8bd4		20 a9 a0	jsr $a0a9	                jsr xt_space
.8bd7		60		rts		z_dot:          rts
.8bd8						xt_dot_paren:
.8bd8		ca		dex		                dex
.8bd9		ca		dex		                dex
.8bda		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8bdc		95 00		sta $00,x	                sta 0,x
.8bde		74 01		stz $01,x	                stz 1,x
.8be0		20 06 99	jsr $9906	                jsr xt_parse
.8be3		20 7e a4	jsr $a47e	                jsr xt_type
.8be6		60		rts		z_dot_paren:    rts
.8be7						xt_dot_quote:
.8be7		20 14 9d	jsr $9d14	                jsr xt_s_quote
.8bea		a0 a4		ldy #$a4	                ldy #>xt_type
.8bec		a9 7e		lda #$7e	                lda #<xt_type
.8bee		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.8bf1		60		rts		z_dot_quote:    rts
.8bf2						xt_dot_r:
.8bf2		20 78 d8	jsr $d878	                jsr underflow_2
.8bf5		20 eb a2	jsr $a2eb	                jsr xt_to_r
.8bf8		20 2f 8d	jsr $8d2f	                jsr xt_dup
.8bfb		20 d1 80	jsr $80d1	                jsr xt_abs
.8bfe		20 36 a7	jsr $a736	                jsr xt_zero
.8c01		20 1e 93	jsr $931e	                jsr xt_less_number_sign
.8c04		20 aa 97	jsr $97aa	                jsr xt_number_sign_s
.8c07		20 1c 9b	jsr $9b1c	                jsr xt_rot
.8c0a		20 72 9f	jsr $9f72	                jsr xt_sign
.8c0d		20 88 97	jsr $9788	                jsr xt_number_sign_greater
.8c10		20 5e 9a	jsr $9a5e	                jsr xt_r_from
.8c13		20 5f 98	jsr $985f	                jsr xt_over
.8c16		20 25 95	jsr $9525	                jsr xt_minus
.8c19		20 af a0	jsr $a0af	                jsr xt_spaces
.8c1c		20 7e a4	jsr $a47e	                jsr xt_type
.8c1f		60		rts		z_dot_r:        rts
.8c20						xt_dot_s:
.8c20		20 8e 8a	jsr $8a8e	                jsr xt_depth    ; ( -- u )
.8c23		a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c25		20 a8 8d	jsr $8da8	                jsr emit_a
.8c28		b5 00		lda $00,x	                lda 0,x
.8c2a		48		pha		                pha
.8c2b		ca		dex		                dex             ; DUP
.8c2c		ca		dex		                dex
.8c2d		95 00		sta $00,x	                sta 0,x
.8c2f		74 01		stz $01,x	                stz 1,x
.8c31		20 e0 d8	jsr $d8e0	                jsr print_u
.8c34		a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8c36		20 a8 8d	jsr $8da8	                jsr emit_a
.8c39		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8c3b		20 a8 8d	jsr $8da8	                jsr emit_a
.8c3e		e8		inx		                inx
.8c3f		e8		inx		                inx
.8c40		e0 78		cpx #$78	                cpx #dsp0
.8c42		f0 1e		beq $8c62	                beq _done
.8c44						_have_stack:
.8c44		7a		ply		                ply
.8c45		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8c47		85 29		sta $29		                sta tmp3
.8c49		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.8c4b						_loop:
.8c4b		ca		dex		                dex
.8c4c		ca		dex		                dex
.8c4d		b2 29		lda ($29)	                lda (tmp3)
.8c4f		95 01		sta $01,x	                sta 1,x
.8c51		c6 29		dec $29		                dec tmp3
.8c53		b2 29		lda ($29)	                lda (tmp3)
.8c55		95 00		sta $00,x	                sta 0,x
.8c57		c6 29		dec $29		                dec tmp3
.8c59		5a		phy		                phy
.8c5a		20 b6 8b	jsr $8bb6	                jsr xt_dot
.8c5d		7a		ply		                ply
.8c5e		88		dey		                dey
.8c5f		d0 ea		bne $8c4b	                bne _loop
.8c61		48		pha		                pha             ; dummy to balance stack
.8c62						_done:
.8c62		68		pla		                pla
.8c63		60		rts		z_dot_s:        rts
.8c64						xt_d_dot:
.8c64		20 78 d8	jsr $d878	                jsr underflow_2
.8c67		20 08 a3	jsr $a308	                jsr xt_tuck
.8c6a		20 1e 8a	jsr $8a1e	                jsr xt_dabs
.8c6d		20 1e 93	jsr $931e	                jsr xt_less_number_sign
.8c70		20 aa 97	jsr $97aa	                jsr xt_number_sign_s
.8c73		20 1c 9b	jsr $9b1c	                jsr xt_rot
.8c76		20 72 9f	jsr $9f72	                jsr xt_sign
.8c79		20 88 97	jsr $9788	                jsr xt_number_sign_greater
.8c7c		20 7e a4	jsr $a47e	                jsr xt_type
.8c7f		20 a9 a0	jsr $a0a9	                jsr xt_space
.8c82		60		rts		z_d_dot:        rts
.8c83						xt_d_dot_r:
.8c83		20 7d d8	jsr $d87d	                jsr underflow_3
.8c86		20 eb a2	jsr $a2eb	                jsr xt_to_r
.8c89		20 08 a3	jsr $a308	                jsr xt_tuck
.8c8c		20 1e 8a	jsr $8a1e	                jsr xt_dabs
.8c8f		20 1e 93	jsr $931e	                jsr xt_less_number_sign
.8c92		20 aa 97	jsr $97aa	                jsr xt_number_sign_s
.8c95		20 1c 9b	jsr $9b1c	                jsr xt_rot
.8c98		20 72 9f	jsr $9f72	                jsr xt_sign
.8c9b		20 88 97	jsr $9788	                jsr xt_number_sign_greater
.8c9e		20 5e 9a	jsr $9a5e	                jsr xt_r_from
.8ca1		20 5f 98	jsr $985f	                jsr xt_over
.8ca4		20 25 95	jsr $9525	                jsr xt_minus
.8ca7		20 af a0	jsr $a0af	                jsr xt_spaces
.8caa		20 7e a4	jsr $a47e	                jsr xt_type
.8cad		60		rts		z_d_dot_r:      rts
.8cae						xt_drop:
.8cae		20 73 d8	jsr $d873	                jsr underflow_1
.8cb1		e8		inx		                inx
.8cb2		e8		inx		                inx
.8cb3		60		rts		z_drop:         rts
.8cb4						xt_dump:
.8cb4		20 78 d8	jsr $d878	                jsr underflow_2
.8cb7						_row:
.8cb7		a0 10		ldy #$10	                ldy #16
.8cb9		64 27		stz $27		                stz tmp2
.8cbb		20 fb 88	jsr $88fb	                jsr xt_cr
.8cbe		b5 03		lda $03,x	                lda 3,x
.8cc0		20 88 d7	jsr $d788	                jsr byte_to_ascii
.8cc3		b5 02		lda $02,x	                lda 2,x
.8cc5		20 88 d7	jsr $d788	                jsr byte_to_ascii
.8cc8		20 a9 a0	jsr $a0a9	                jsr xt_space
.8ccb		20 a9 a0	jsr $a0a9	                jsr xt_space
.8cce						_loop:
.8cce		b5 00		lda $00,x	                lda 0,x
.8cd0		15 01		ora $01,x	                ora 1,x
.8cd2		f0 39		beq $8d0d	                beq _all_printed
.8cd4		a1 02		lda ($02,x)	                lda (2,x)
.8cd6		48		pha		                pha                     ; byte_to_ascii destroys A
.8cd7		20 88 d7	jsr $d788	                jsr byte_to_ascii
.8cda		20 a9 a0	jsr $a0a9	                jsr xt_space
.8cdd		68		pla		                pla
.8cde		20 59 d8	jsr $d859	                jsr is_printable
.8ce1		b0 02		bcs $8ce5	                bcs _printable
.8ce3		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8ce5						_printable:
.8ce5		5a		phy		                phy                     ; save counter
.8ce6		a4 27		ldy $27		                ldy tmp2
.8ce8		91 00		sta ($00),y	                sta (cp),y
.8cea		e6 27		inc $27		                inc tmp2
.8cec		7a		ply		                ply
.8ced		c0 09		cpy #$09	                cpy #9
.8cef		d0 03		bne $8cf4	                bne _next_char
.8cf1		20 a9 a0	jsr $a0a9	                jsr xt_space
.8cf4						_next_char:
.8cf4		f6 02		inc $02,x	                inc 2,x
.8cf6		d0 02		bne $8cfa	                bne _counter
.8cf8		f6 03		inc $03,x	                inc 3,x
.8cfa						_counter:
.8cfa		b5 00		lda $00,x	                lda 0,x
.8cfc		d0 02		bne $8d00	                bne +
.8cfe		d6 01		dec $01,x	                dec 1,x
.8d00						+
.8d00		d6 00		dec $00,x	                dec 0,x
.8d02		88		dey		                dey
.8d03		d0 c9		bne $8cce	                bne _loop               ; next byte
.8d05		20 a9 a0	jsr $a0a9	                jsr xt_space
.8d08		20 1b 8d	jsr $8d1b	                jsr dump_print_ascii
.8d0b		80 aa		bra $8cb7	                bra _row                ; new row
.8d0d						_all_printed:
.8d0d		a5 27		lda $27		                lda tmp2
.8d0f		f0 06		beq $8d17	                beq _done
.8d11		20 a9 a0	jsr $a0a9	                jsr xt_space
.8d14		20 1b 8d	jsr $8d1b	                jsr dump_print_ascii
.8d17						_done:
.8d17		20 2b a3	jsr $a32b	                jsr xt_two_drop         ; one byte less than 4x INX
.8d1a		60		rts		z_dump:         rts
.8d1b						dump_print_ascii:
.8d1b		a0 00		ldy #$00	                ldy #0
.8d1d						_ascii_loop:
.8d1d		b1 00		lda ($00),y	                lda (cp),y
.8d1f		20 a8 8d	jsr $8da8	                jsr emit_a
.8d22		c8		iny		                iny
.8d23		c0 08		cpy #$08	                cpy #8
.8d25		d0 03		bne $8d2a	                bne +
.8d27		20 a9 a0	jsr $a0a9	                jsr xt_space
.8d2a						+
.8d2a		c6 27		dec $27		                dec tmp2
.8d2c		d0 ef		bne $8d1d	                bne _ascii_loop
.8d2e		60		rts		                rts
.8d2f						xt_dup:
.8d2f		20 73 d8	jsr $d873	                jsr underflow_1
.8d32		ca		dex		                dex
.8d33		ca		dex		                dex
.8d34		b5 02		lda $02,x	                lda 2,x         ; LSB
.8d36		95 00		sta $00,x	                sta 0,x
.8d38		b5 03		lda $03,x	                lda 3,x         ; MSB
.8d3a		95 01		sta $01,x	                sta 1,x
.8d3c		60		rts		z_dup:          rts
.8d3d						xt_ed:
.8d3d		20 a4 b5	jsr $b5a4	                jsr ed6502      ; kept in separate file
.8d40		60		rts		z_ed:           rts
.8d41						xt_else:
.8d41						xt_endof:
.8d41		a9 4c		lda #$4c	                lda #$4c        ; jmp opcode
.8d43		20 1c d7	jsr $d71c	                jsr cmpl_a
.8d46		20 24 91	jsr $9124	                jsr xt_here
.8d49		20 36 a7	jsr $a736	                jsr xt_zero
.8d4c		20 f1 86	jsr $86f1	                jsr xt_comma
.8d4f		20 33 a1	jsr $a133	                jsr xt_swap         ; ( target orig )
.8d52						xt_then:
.8d52		20 24 91	jsr $9124	                jsr xt_here
.8d55		a1 02		lda ($02,x)	                lda (2,x)           ; get LSB at orig
.8d57		1a		inc a		                ina                 ; was LSB $ff?  (only check for $xxff)
.8d58		d0 3b		bne $8d95	                bne _no_opt
.8d5a		20 33 a3	jsr $a333	                jsr xt_two_dup
.8d5d		20 33 a1	jsr $a133	                jsr xt_swap
.8d60		20 25 95	jsr $9525	                jsr xt_minus        ; ( C: orig here offset )
.8d63		b5 01		lda $01,x	                lda 1,x
.8d65		d0 2c		bne $8d93	                bne _too_far        ; MSB must be zero
.8d67		b5 00		lda $00,x	                lda 0,x
.8d69		3a		dec a		                dea                 ; we want here - orig - 2
.8d6a		3a		dec a		                dea                 ; don't care about carry
.8d6b		30 26		bmi $8d93	                bmi _too_far        ; up to 127 is ok
.8d6d		95 00		sta $00,x	                sta 0,x             ; stash offset - 2
.8d6f		38		sec		                sec                 ; put orig - 2 in tmp1
.8d70		b5 04		lda $04,x	                lda 4,x
.8d72		e9 02		sbc #$02	                sbc #2
.8d74		85 25		sta $25		                sta tmp1
.8d76		b5 05		lda $05,x	                lda 5,x
.8d78		e9 00		sbc #$00	                sbc #0
.8d7a		85 26		sta $26		                sta tmp1+1
.8d7c		a0 00		ldy #$00	                ldy #0
.8d7e						-
.8d7e		b9 9d 8d	lda $8d9d,y	                lda beq_opt+1,y               ; skip the jsr
.8d81		91 25		sta ($25),y	                sta (tmp1),y
.8d83		c8		iny		                iny
.8d84		c0 03		cpy #$03	                cpy #(beq_opt_end-beq_opt-2)  ; three bytes, skip jsr and offset
.8d86		d0 f6		bne $8d7e	                bne -
.8d88		b5 00		lda $00,x	                lda 0,x             ; write the offset
.8d8a		91 25		sta ($25),y	                sta (tmp1),y
.8d8c		e8		inx		                inx                 ; clear the stack
.8d8d		e8		inx		                inx
.8d8e		e8		inx		                inx
.8d8f		e8		inx		                inx
.8d90		e8		inx		                inx
.8d91		e8		inx		                inx
.8d92		60		rts		                rts                 ; all done
.8d93						_too_far:
.8d93		e8		inx		                inx                 ; discard the offset we calculated
.8d94		e8		inx		                inx
.8d95						_no_opt:
.8d95		20 33 a1	jsr $a133	                jsr xt_swap
.8d98		20 18 a1	jsr $a118	                jsr xt_store
.8d9b						z_else:
.8d9b						z_endof:
.8d9b		60		rts		z_then:         rts
.8d9c						beq_opt:
.8d9c		20 c1 91	jsr $91c1	                jsr zero_test_runtime       ; replaces jsr zero_branch_runtime
.8d9f		f0 00		beq $8da1	                beq beq_opt_end             ; the beq overwrites the placeholder
.8da1						beq_opt_end:
.8da1						xt_emit:
.8da1		20 73 d8	jsr $d873	                jsr underflow_1
.8da4		b5 00		lda $00,x	                lda 0,x
.8da6		e8		inx		                inx
.8da7		e8		inx		                inx
.8da8						emit_a:
.8da8		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.8dab						z_emit:
.8dab						xt_empty_buffers:
.8dab		a0 30		ldy #$30	                ldy #buffstatus_offset
.8dad		a9 00		lda #$00	                lda #0
.8daf		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.8db1						z_empty_buffers:
.8db1		60		rts		                rts
.8db2						xt_endcase:
.8db2		a0 8c		ldy #$8c	                ldy #>xt_drop
.8db4		a9 ae		lda #$ae	                lda #<xt_drop
.8db6		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.8db9						_endcase_loop:
.8db9		b5 00		lda $00,x	                lda 0,x
.8dbb		15 01		ora $01,x	                ora 1,x
.8dbd		f0 05		beq $8dc4	                beq _done
.8dbf		20 52 8d	jsr $8d52	                jsr xt_then
.8dc2		80 f5		bra $8db9	                bra _endcase_loop
.8dc4						_done:
.8dc4		e8		inx		                inx
.8dc5		e8		inx		                inx
.8dc6		60		rts		z_endcase:      rts
.8dc7						xt_environment_q:
.8dc7		20 73 d8	jsr $d873	                jsr underflow_1
.8dca		a0 00		ldy #$00	                ldy #00                 ; counter for table
.8dcc		5a		phy		                phy
.8dcd						_table_loop:
.8dcd		20 33 a3	jsr $a333	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8dd0		ca		dex		                dex
.8dd1		ca		dex		                dex                     ; ( addr u addr u ? )
.8dd2		b9 44 8e	lda $8e44,y	                lda env_table_single,y
.8dd5		95 00		sta $00,x	                sta 0,x
.8dd7		c8		iny		                iny
.8dd8		b9 44 8e	lda $8e44,y	                lda env_table_single,y
.8ddb		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8ddd		c8		iny		                iny
.8dde		15 00		ora $00,x	                ora 0,x
.8de0		f0 4d		beq $8e2f	                beq _table_done
.8de2		5a		phy		                phy                     ; save Y, which is used by COUNT
.8de3		20 e7 88	jsr $88e7	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8de6		20 0b 87	jsr $870b	                jsr xt_compare          ; ( addr u f )
.8de9		7a		ply		                ply
.8dea		b5 00		lda $00,x	                lda 0,x
.8dec		15 01		ora $01,x	                ora 1,x
.8dee		f0 04		beq $8df4	                beq _got_result
.8df0		e8		inx		                inx                     ; DROP, now ( addr u )
.8df1		e8		inx		                inx
.8df2		80 d9		bra $8dcd	                bra _table_loop
.8df4						_got_result:
.8df4		e8		inx		                inx                     ; drop flag, now ( addr u )
.8df5		e8		inx		                inx
.8df6		88		dey		                dey                     ; go back to index we had
.8df7		88		dey		                dey
.8df8		68		pla		                pla
.8df9		d0 0d		bne $8e08	                bne _double_result
.8dfb		b9 62 8e	lda $8e62,y	                lda env_results_single,y
.8dfe		95 02		sta $02,x	                sta 2,x
.8e00		c8		iny		                iny
.8e01		b9 62 8e	lda $8e62,y	                lda env_results_single,y
.8e04		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e06		80 1f		bra $8e27	                bra _set_flag
.8e08						_double_result:
.8e08		ca		dex		                dex                     ; ( addr u ? )
.8e09		ca		dex		                dex
.8e0a		98		tya		                tya
.8e0b		38		sec		                sec
.8e0c		e9 18		sbc #$18	                sbc #24
.8e0e		0a		asl a		                asl
.8e0f		a8		tay		                tay
.8e10		b9 78 8e	lda $8e78,y	                lda env_results_double,y
.8e13		95 02		sta $02,x	                sta 2,x
.8e15		c8		iny		                iny
.8e16		b9 78 8e	lda $8e78,y	                lda env_results_double,y
.8e19		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e1b		c8		iny		                iny
.8e1c		b9 78 8e	lda $8e78,y	                lda env_results_double,y
.8e1f		95 04		sta $04,x	                sta 4,x
.8e21		c8		iny		                iny
.8e22		b9 78 8e	lda $8e78,y	                lda env_results_double,y
.8e25		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e27						_set_flag:
.8e27		a9 ff		lda #$ff	                lda #$ff
.8e29		95 00		sta $00,x	                sta 0,x
.8e2b		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e2d		80 14		bra $8e43	                bra _done
.8e2f						_table_done:
.8e2f		68		pla		                pla
.8e30		d0 09		bne $8e3b	                bne _no_match
.8e32		1a		inc a		                ina
.8e33		48		pha		                pha
.8e34		8a		txa		                txa
.8e35		18		clc		                clc
.8e36		69 06		adc #$06	                adc #6                  ; skip six bytes
.8e38		aa		tax		                tax                     ; ( addr u )
.8e39		80 92		bra $8dcd	                bra _table_loop
.8e3b						_no_match:
.8e3b		8a		txa		                txa
.8e3c		18		clc		                clc
.8e3d		69 0a		adc #$0a	                adc #10
.8e3f		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e40		20 2b 8f	jsr $8f2b	                jsr xt_false
.8e43						_done:
.8e43						z_environment_q:
.8e43		60		rts		                rts
.8e44						env_table_single:
>8e44		8c d6 9c d6 a2 d6 a7 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e4c		b9 d6
>8e4e		c1 d6 ca d6 d0 d6 d6 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e56		e9 d6 f5 d6 00 00		        .word envs_sc, envs_wl, 0000
.8e5c						env_table_double:
>8e5c		ff d6 05 d7 00 00		        .word envs_max_d, envs_max_ud, 0000
.8e62						env_results_single:
>8e62		ff 00				        .word $00FF     ; /COUNTED-STRING
>8e64		ff 00				        .word $00FF     ; /HOLD
>8e66		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8e68		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8e6a		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8e6c		ff 00				        .word $00FF     ; MAX-CHAR
>8e6e		ff 7f				        .word $7FFF     ; MAX-N
>8e70		ff ff				        .word $FFFF     ; MAX-U
>8e72		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8e74		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8e76		09 00				        .word $0009     ; WORDLISTS
.8e78						env_results_double:
>8e78		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8e7c		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8e80						xt_equal:
.8e80		20 78 d8	jsr $d878	                jsr underflow_2
.8e83		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8e85		d5 02		cmp $02,x	                cmp 2,x
.8e87		d0 0a		bne $8e93	                bne _false
.8e89		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8e8b		d5 03		cmp $03,x	                cmp 3,x
.8e8d		d0 04		bne $8e93	                bne _false
.8e8f		a9 ff		lda #$ff	                lda #$ff
.8e91		80 02		bra $8e95	                bra _done
.8e93		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8e95		95 02		sta $02,x	_done:          sta 2,x
.8e97		95 03		sta $03,x	                sta 3,x
.8e99		e8		inx		                inx
.8e9a		e8		inx		                inx
.8e9b		60		rts		z_equal:        rts
.8e9c						xt_blank:
.8e9c		ca		dex		                dex
.8e9d		ca		dex		                dex
.8e9e		a9 20		lda #$20	                lda #AscSP
.8ea0		95 00		sta $00,x	                sta 0,x
.8ea2		74 01		stz $01,x	                stz 1,x
.8ea4		80 06		bra $8eac	                bra xt_fill     ; skip over code for ERASE
.8ea6						xt_erase:
.8ea6		ca		dex		                dex
.8ea7		ca		dex		                dex
.8ea8		74 00		stz $00,x	                stz 0,x
.8eaa		74 01		stz $01,x	                stz 1,x
.8eac						xt_fill:
.8eac		20 7d d8	jsr $d87d	                jsr underflow_3
.8eaf		b5 04		lda $04,x	                lda 4,x         ; LSB
.8eb1		85 25		sta $25		                sta tmp1
.8eb3		b5 05		lda $05,x	                lda 5,x
.8eb5		85 26		sta $26		                sta tmp1+1
.8eb7		b5 02		lda $02,x	                lda 2,x
.8eb9		85 27		sta $27		                sta tmp2
.8ebb		b5 03		lda $03,x	                lda 3,x
.8ebd		85 28		sta $28		                sta tmp2+1
.8ebf		b5 00		lda $00,x	                lda 0,x
.8ec1		a8		tay		                tay
.8ec2						_loop:
.8ec2		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8ec4		c5 26		cmp $26		                cmp tmp1+1
.8ec6		90 21		bcc $8ee9	                bcc _done               ; RAM_END < TMP1, so leave
.8ec8		d0 06		bne $8ed0	                bne _check_counter      ; RAM_END is not smaller and not equal
.8eca		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8ecc		c5 25		cmp $25		                cmp tmp1
.8ece		90 19		bcc $8ee9	                bcc _done               ; RAM_END < TMP1, so leave
.8ed0						_check_counter:
.8ed0		a5 27		lda $27		                lda tmp2
.8ed2		05 28		ora $28		                ora tmp2+1
.8ed4		f0 13		beq $8ee9	                beq _done
.8ed6		98		tya		                tya
.8ed7		92 25		sta ($25)	                sta (tmp1)
.8ed9		a5 27		lda $27		                lda tmp2
.8edb		d0 02		bne $8edf	                bne +
.8edd		c6 28		dec $28		                dec tmp2+1
.8edf		c6 27		dec $27		+               dec tmp2
.8ee1		e6 25		inc $25		                inc tmp1
.8ee3		d0 dd		bne $8ec2	                bne _loop
.8ee5		e6 26		inc $26		                inc tmp1+1
.8ee7		80 d9		bra $8ec2	                bra _loop
.8ee9						_done:
.8ee9		8a		txa		                txa
.8eea		18		clc		                clc
.8eeb		69 06		adc #$06	                adc #6
.8eed		aa		tax		                tax
.8eee						z_blank:
.8eee						z_erase:
.8eee		60		rts		z_fill:         rts
.8eef						xt_execute:
.8eef		20 73 d8	jsr $d873	                jsr underflow_1
.8ef2		20 f6 8e	jsr $8ef6	                jsr doexecute   ; do not combine to JMP (native coding)
.8ef5		60		rts		z_execute:      rts
.8ef6						doexecute:
.8ef6		b5 00		lda $00,x	                lda 0,x
.8ef8		85 04		sta $04		                sta ip
.8efa		b5 01		lda $01,x	                lda 1,x
.8efc		85 05		sta $05		                sta ip+1
.8efe		e8		inx		                inx
.8eff		e8		inx		                inx
.8f00		6c 04 00	jmp ($0004)	                jmp (ip)
.8f03						xt_execute_parsing:
.8f03		20 7d d8	jsr $d87d	                jsr underflow_3
.8f06		20 0d 92	jsr $920d	                jsr xt_input_to_r       ; save normal input for later
.8f09		20 3d 96	jsr $963d	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f0c		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f0e		85 0e		sta $0e		                sta ciblen
.8f10		b5 01		lda $01,x	                lda 1,x
.8f12		85 0f		sta $0f		                sta ciblen+1
.8f14		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f16		85 0c		sta $0c		                sta cib
.8f18		b5 03		lda $03,x	                lda 3,x
.8f1a		85 0d		sta $0d		                sta cib+1
.8f1c		64 10		stz $10		                stz toin                ; Set >IN to zero
.8f1e		64 11		stz $11		                stz toin+1
.8f20		20 2b a3	jsr $a32b	                jsr xt_two_drop         ; 2DROP ( xt )
.8f23		20 ef 8e	jsr $8eef	                jsr xt_execute
.8f26		20 6f 9a	jsr $9a6f	                jsr xt_r_to_input
.8f29						z_execute_parsing:
.8f29		60		rts		                rts
.8f2a						xt_exit:
.8f2a		60		rts		                rts             ; keep before z_exit
.8f2b						z_exit:
.8f2b						xt_false:
.8f2b		ca		dex		                dex
.8f2c		ca		dex		                dex
.8f2d		74 00		stz $00,x	                stz 0,x
.8f2f		74 01		stz $01,x	                stz 1,x
.8f31		60		rts		z_false:        rts
.8f32						xt_fetch:
.8f32		20 73 d8	jsr $d873	                jsr underflow_1
.8f35		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f37		a8		tay		                tay
.8f38		f6 00		inc $00,x	                inc 0,x
.8f3a		d0 02		bne $8f3e	                bne +
.8f3c		f6 01		inc $01,x	                inc 1,x
.8f3e						+
.8f3e		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f40		95 01		sta $01,x	                sta 1,x
.8f42		94 00		sty $00,x	                sty 0,x
.8f44		60		rts		z_fetch:        rts
.8f45						xt_find:
.8f45		20 73 d8	jsr $d873	                jsr underflow_1
.8f48		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f4a		48		pha		                pha
.8f4b		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f4d		48		pha		                pha
.8f4e		20 e7 88	jsr $88e7	                jsr xt_count            ; ( caddr -- addr u )
.8f51		20 8d 8f	jsr $8f8d	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f54		b5 00		lda $00,x	                lda 0,x
.8f56		15 01		ora $01,x	                ora 1,x
.8f58		d0 0b		bne $8f65	                bne _found_word
.8f5a		20 2b 8f	jsr $8f2b	                jsr xt_false            ; ( 0 0 )
.8f5d		68		pla		                pla                     ; LSB of address
.8f5e		95 02		sta $02,x	                sta 2,x
.8f60		68		pla		                pla
.8f61		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8f63		80 27		bra $8f8c	                bra _done               ; ( addr 0 )
.8f65						_found_word:
.8f65		68		pla		                pla
.8f66		68		pla		                pla
.8f67		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( nt nt )
.8f6a		20 b6 95	jsr $95b6	                jsr xt_name_to_int      ; ( nt xt )
.8f6d		20 33 a1	jsr $a133	                jsr xt_swap             ; ( xt nt )
.8f70		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8f72		f6 00		inc $00,x	                inc 0,x
.8f74		d0 02		bne $8f78	                bne +
.8f76		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8f78						+
.8f78		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8f7a		29 04		and #$04	                and #IM
.8f7c		d0 08		bne $8f86	                bne _immediate          ; bit set, we're immediate
.8f7e		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8f80		95 00		sta $00,x	                sta 0,x
.8f82		95 01		sta $01,x	                sta 1,x
.8f84		80 06		bra $8f8c	                bra _done
.8f86						_immediate:
.8f86		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8f88		95 00		sta $00,x	                sta 0,x
.8f8a		74 01		stz $01,x	                stz 1,x
.8f8c						_done:
.8f8c		60		rts		z_find:         rts
.8f8d						xt_find_name:
.8f8d		20 78 d8	jsr $d878	                jsr underflow_2
.8f90		b5 00		lda $00,x	                lda 0,x
.8f92		15 01		ora $01,x	                ora 1,x
.8f94		d0 03		bne $8f99	                bne _nonempty
.8f96		4c 32 90	jmp $9032	                jmp _fail_done
.8f99						_nonempty:
.8f99		64 29		stz $29		                stz tmp3                ; Start at the beginning
.8f9b						_wordlist_loop:
.8f9b		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8f9d		a5 29		lda $29		                lda tmp3
.8f9f		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.8fa1		d0 03		bne $8fa6	                bne _have_string
.8fa3		4c 32 90	jmp $9032	                jmp _fail_done
.8fa6						_have_string:
.8fa6		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fa7		69 23		adc #$23	                adc #search_order_offset
.8fa9		a8		tay		                tay
.8faa		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.8fac		0a		asl a		                asl                     ; Turn offset into cells offset.
.8fad		18		clc		                clc
.8fae		69 0a		adc #$0a	                adc #wordlists_offset
.8fb0		a8		tay		                tay
.8fb1		b1 08		lda ($08),y	                lda (up),y
.8fb3		85 25		sta $25		                sta tmp1
.8fb5		c8		iny		                iny
.8fb6		b1 08		lda ($08),y	                lda (up),y
.8fb8		85 26		sta $26		                sta tmp1+1
.8fba		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.8fbc		85 27		sta $27		                sta tmp2
.8fbe		b5 03		lda $03,x	                lda 3,x
.8fc0		85 28		sta $28		                sta tmp2+1
.8fc2						_loop:
.8fc2		b2 25		lda ($25)	                lda (tmp1)
.8fc4		d5 00		cmp $00,x	                cmp 0,x
.8fc6		d0 54		bne $901c	                bne _next_entry
.8fc8						_compare_string:
.8fc8		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.8fca		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.8fcc		b0 07		bcs $8fd5	                bcs _compare_first
.8fce		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8fd0		90 03		bcc $8fd5	                bcc _compare_first
.8fd2		18		clc		                clc
.8fd3		69 20		adc #$20	                adc #$20
.8fd5						_compare_first:
.8fd5		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.8fd7		d1 25		cmp ($25),y	                cmp (tmp1),y    ; first character of current word
.8fd9		d0 41		bne $901c	                bne _next_entry
.8fdb		b5 00		lda $00,x	                lda 0,x
.8fdd		3a		dec a		                dea
.8fde		f0 2c		beq $900c	                beq _success
.8fe0		a5 25		lda $25		                lda tmp1
.8fe2		48		pha		                pha             ; Preserve tmp1 on the return stack.
.8fe3		18		clc		                clc
.8fe4		69 08		adc #$08	                adc #8
.8fe6		85 25		sta $25		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.8fe8		a5 26		lda $26		                lda tmp1+1
.8fea		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.8feb		69 00		adc #$00	                adc #0          ; we only need the carry
.8fed		85 26		sta $26		                sta tmp1+1
.8fef		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.8ff1		88		dey		                dey
.8ff2						_string_loop:
.8ff2		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.8ff4		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8ff6		b0 07		bcs $8fff	                bcs _check_char
.8ff8		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8ffa		90 03		bcc $8fff	                bcc _check_char
.8ffc		18		clc		                clc
.8ffd		69 20		adc #$20	                adc #$20
.8fff						_check_char:
.8fff		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.9001		d0 13		bne $9016	                bne _next_entry_tmp1
.9003		88		dey		                dey
.9004		d0 ec		bne $8ff2	                bne _string_loop
.9006						_success_tmp1:
.9006		68		pla		                pla             ; Restore tmp1 from the return stack.
.9007		85 26		sta $26		                sta tmp1+1
.9009		68		pla		                pla
.900a		85 25		sta $25		                sta tmp1
.900c						_success:
.900c		a5 25		lda $25		                lda tmp1
.900e		95 02		sta $02,x	                sta 2,x
.9010		a5 26		lda $26		                lda tmp1+1
.9012		95 03		sta $03,x	                sta 3,x
.9014		80 20		bra $9036	                bra _done
.9016						_next_entry_tmp1:
.9016		68		pla		                pla             ; Restore tmp1 from the return stack.
.9017		85 26		sta $26		                sta tmp1+1
.9019		68		pla		                pla
.901a		85 25		sta $25		                sta tmp1
.901c						_next_entry:
.901c		a0 02		ldy #$02	                ldy #2
.901e		b1 25		lda ($25),y	                lda (tmp1),y
.9020		48		pha		                pha
.9021		c8		iny		                iny
.9022		b1 25		lda ($25),y	                lda (tmp1),y
.9024		85 26		sta $26		                sta tmp1+1
.9026		68		pla		                pla
.9027		85 25		sta $25		                sta tmp1
.9029		05 26		ora $26		                ora tmp1+1
.902b		d0 95		bne $8fc2	                bne _loop
.902d		e6 29		inc $29		                inc tmp3
.902f		4c 9b 8f	jmp $8f9b	                jmp _wordlist_loop
.9032						_fail_done:
.9032		74 02		stz $02,x	                stz 2,x         ; failure flag
.9034		74 03		stz $03,x	                stz 3,x
.9036						_done:
.9036		e8		inx		                inx
.9037		e8		inx		                inx
.9038		60		rts		z_find_name:    rts
.9039						xt_flush:
.9039		20 54 9e	jsr $9e54	                jsr xt_save_buffers
.903c		a0 30		ldy #$30	                ldy #buffstatus_offset
.903e		a9 00		lda #$00	                lda #0
.9040		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.9042						z_flush:
.9042		60		rts		                rts
.9043						xt_fm_slash_mod:
.9043		20 7d d8	jsr $d87d	                jsr underflow_3
.9046		64 27		stz $27		                stz tmp2        ; default: n is positive
.9048		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.904a		10 0e		bpl $905a	                bpl _check_d
.904c		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.904e		20 f2 95	jsr $95f2	                jsr xt_negate   ; NEGATE
.9051		20 eb a2	jsr $a2eb	                jsr xt_to_r     ; >R
.9054		20 d9 8a	jsr $8ad9	                jsr xt_dnegate  ; DNEGATE
.9057		20 5e 9a	jsr $9a5e	                jsr xt_r_from   ; R>
.905a						_check_d:
.905a		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.905c		10 0d		bpl $906b	                bpl _multiply
.905e		18		clc		                clc
.905f		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.9061		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.9063		95 02		sta $02,x	                sta 2,x
.9065		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9067		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.9069		95 03		sta $03,x	                sta 3,x
.906b						_multiply:
.906b		20 35 a5	jsr $a535	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.906e		a5 27		lda $27		                lda tmp2
.9070		f0 07		beq $9079	                beq _done
.9072		e8		inx		                inx             ; pretend that we SWAP
.9073		e8		inx		                inx
.9074		20 f2 95	jsr $95f2	                jsr xt_negate
.9077		ca		dex		                dex
.9078		ca		dex		                dex
.9079						_done:
.9079		60		rts		z_fm_slash_mod: rts
.907a						xt_forth:
.907a		a0 23		ldy #$23	                ldy #search_order_offset
.907c		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.907e		91 08		sta ($08),y	                sta (up),y
.9080						z_forth:
.9080		60		rts		                rts
.9081						load_evaluate:
.9081		a9 ff		lda #$ff	                lda #$FF
.9083		85 25		sta $25		                sta tmp1
.9085		80 11		bra $9098	                bra load_evaluate_start
.9087						xt_evaluate:
.9087		20 78 d8	jsr $d878	                jsr underflow_2
.908a		64 25		stz $25		                stz tmp1
.908c		b5 00		lda $00,x	                lda 0,x
.908e		15 01		ora $01,x	                ora 1,x
.9090		d0 06		bne $9098	                bne evaluate_got_work
.9092		e8		inx		                inx
.9093		e8		inx		                inx
.9094		e8		inx		                inx
.9095		e8		inx		                inx
.9096		80 42		bra $90da	                bra evaluate_done
.9098						load_evaluate_start:
.9098						evaluate_got_work:
.9098		a0 05		ldy #$05	                ldy #blk_offset+1
.909a		b1 08		lda ($08),y	                lda (up),y
.909c		48		pha		                pha
.909d		88		dey		                dey
.909e		b1 08		lda ($08),y	                lda (up),y
.90a0		48		pha		                pha
.90a1		a5 25		lda $25		                lda tmp1
.90a3		d0 05		bne $90aa	                bne _nozero
.90a5		91 08		sta ($08),y	                sta (up),y
.90a7		c8		iny		                iny
.90a8		91 08		sta ($08),y	                sta (up),y
.90aa						_nozero:
.90aa		20 0d 92	jsr $920d	                jsr xt_input_to_r
.90ad		a9 ff		lda #$ff	                lda #$ff
.90af		85 0a		sta $0a		                sta insrc
.90b1		85 0b		sta $0b		                sta insrc+1
.90b3		64 10		stz $10		                stz toin
.90b5		64 11		stz $11		                stz toin+1
.90b7		b5 00		lda $00,x	                lda 0,x
.90b9		85 0e		sta $0e		                sta ciblen
.90bb		b5 01		lda $01,x	                lda 1,x
.90bd		85 0f		sta $0f		                sta ciblen+1
.90bf		b5 02		lda $02,x	                lda 2,x
.90c1		85 0c		sta $0c		                sta cib
.90c3		b5 03		lda $03,x	                lda 3,x
.90c5		85 0d		sta $0d		                sta cib+1
.90c7		e8		inx		                inx             ; A clean stack is a clean mind
.90c8		e8		inx		                inx
.90c9		e8		inx		                inx
.90ca		e8		inx		                inx
.90cb		20 e0 d7	jsr $d7e0	                jsr interpret   ; ( -- )
.90ce		20 6f 9a	jsr $9a6f	                jsr xt_r_to_input
.90d1		a0 04		ldy #$04	                ldy #blk_offset
.90d3		68		pla		                pla
.90d4		91 08		sta ($08),y	                sta (up),y
.90d6		c8		iny		                iny
.90d7		68		pla		                pla
.90d8		91 08		sta ($08),y	                sta (up),y
.90da						evaluate_done:
.90da		60		rts		z_evaluate:     rts
.90db						xt_get_current:
.90db		ca		dex		                dex
.90dc		ca		dex		                dex
.90dd		a0 08		ldy #$08	                ldy #current_offset
.90df		b1 08		lda ($08),y	                lda (up),y
.90e1		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.90e3		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.90e5		60		rts		z_get_current:  rts
.90e6						xt_get_order:
.90e6		a0 22		ldy #$22	                ldy #num_order_offset
.90e8		b1 08		lda ($08),y	                lda (up),y
.90ea		85 25		sta $25		                sta tmp1
.90ec		f0 16		beq $9104	                beq _done       ; If zero, there are no wordlists.
.90ee						_loop:
.90ee		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.90f0		a9 23		lda #$23	                lda #search_order_offset
.90f2		18		clc		                clc
.90f3		65 25		adc $25		                adc tmp1
.90f5		a8		tay		                tay
.90f6		ca		dex		                dex
.90f7		ca		dex		                dex
.90f8		b1 08		lda ($08),y	                lda (up),y
.90fa		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.90fc		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.90fe		a9 00		lda #$00	                lda #0
.9100		c5 25		cmp $25		                cmp tmp1
.9102		d0 ea		bne $90ee	                bne _loop
.9104						_done:
.9104		ca		dex		                dex
.9105		ca		dex		                dex
.9106		a0 22		ldy #$22	                ldy #num_order_offset
.9108		b1 08		lda ($08),y	                lda (up),y
.910a		95 00		sta $00,x	                sta 0,x
.910c		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.910e		60		rts		z_get_order:    rts
.910f						xt_greater_than:
.910f		20 78 d8	jsr $d878	                jsr underflow_2
.9112		a0 00		ldy #$00	                ldy #0          ; default false
.9114		20 9f d7	jsr $d79f	                jsr compare_16bit
.9117		f0 03		beq $911c	                beq _false
.9119		10 01		bpl $911c	                bpl _false
.911b		88		dey		                dey
.911c						_false:
.911c		98		tya		                tya
.911d		e8		inx		                inx
.911e		e8		inx		                inx
.911f		95 00		sta $00,x	                sta 0,x
.9121		95 01		sta $01,x	                sta 1,x
.9123		60		rts		z_greater_than: rts
.9124						xt_here:
.9124						xt_asm_arrow:
.9124		ca		dex		                dex
.9125		ca		dex		                dex
.9126		a5 00		lda $00		                lda cp
.9128		95 00		sta $00,x	                sta 0,x
.912a		a5 01		lda $01		                lda cp+1
.912c		95 01		sta $01,x	                sta 1,x
.912e						z_asm_arrow:
.912e		60		rts		z_here:         rts
.912f						xt_hex:
.912f		a9 10		lda #$10	                lda #16
.9131		85 18		sta $18		                sta base
.9133		64 19		stz $19		                stz base+1              ; paranoid
.9135		60		rts		z_hex:          rts
.9136						xt_hexstore:
.9136		20 7d d8	jsr $d87d	                jsr underflow_3
.9139		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; Save copy of original address
.913c		20 1d a4	jsr $a41d	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.913f						_loop:
.913f		b5 00		lda $00,x	                lda 0,x
.9141		15 01		ora $01,x	                ora 1,x
.9143		f0 36		beq $917b	                beq _done
.9145		20 cf 85	jsr $85cf	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9148		20 1d a4	jsr $a41d	                jsr xt_two_to_r
.914b		20 36 a7	jsr $a736	                jsr xt_zero
.914e		20 36 a7	jsr $a736	                jsr xt_zero
.9151		20 a3 a3	jsr $a3a3	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9154		20 38 a2	jsr $a238	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9157		b5 00		lda $00,x	                lda 0,x
.9159		15 01		ora $01,x	                ora 1,x
.915b		d0 17		bne $9174	                bne _have_chars_left
.915d		20 2b a3	jsr $a32b	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9160		20 18 8a	jsr $8a18	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9163		20 49 9a	jsr $9a49	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9166		20 98 85	jsr $8598	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9169		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; R>
.916c		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+
.916f		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9172		80 cb		bra $913f	                bra _loop
.9174						_have_chars_left:
.9174		8a		txa		                txa
.9175		18		clc		                clc
.9176		69 08		adc #$08	                adc #8
.9178		aa		tax		                tax
.9179		80 c4		bra $913f	                bra _loop
.917b						_done:
.917b		e8		inx		                inx
.917c		e8		inx		                inx
.917d		e8		inx		                inx
.917e		e8		inx		                inx                     ; 2DROP
.917f		20 a3 a3	jsr $a3a3	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9182		20 33 a1	jsr $a133	                jsr xt_swap
.9185		20 25 95	jsr $9525	                jsr xt_minus            ; ( n )
.9188		60		rts		z_hexstore:     rts
.9189						xt_hold:
.9189		20 73 d8	jsr $d873	                jsr underflow_1
.918c		a5 2b		lda $2b		                lda tohold
.918e		d0 02		bne $9192	                bne +
.9190		c6 2c		dec $2c		                dec tohold+1
.9192						+
.9192		c6 2b		dec $2b		                dec tohold
.9194		b5 00		lda $00,x	                lda 0,x
.9196		92 2b		sta ($2b)	                sta (tohold)
.9198		e8		inx		                inx
.9199		e8		inx		                inx
.919a		60		rts		z_hold:         rts
.919b						xt_i:
.919b		ca		dex		                dex
.919c		ca		dex		                dex
.919d		a4 1f		ldy $1f		                ldy loopctrl
.919f		38		sec		                sec
.91a0		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.91a2		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.91a5		95 00		sta $00,x	                sta 0,x
.91a7		b9 01 01	lda $0101,y	                lda loopindex+1,y
.91aa		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.91ad		95 01		sta $01,x	                sta 1,x
.91af		60		rts		z_i:            rts
.91b0						xt_if:
.91b0		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.91b2		a9 cb		lda #$cb	                lda #<zero_branch_runtime
.91b4		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.91b7		20 24 91	jsr $9124	                jsr xt_here
.91ba		20 ff a2	jsr $a2ff	                jsr xt_true
.91bd		20 f1 86	jsr $86f1	                jsr xt_comma
.91c0		60		rts		z_if:           rts
.91c1						zero_test_runtime:
.91c1		e8		inx		                inx
.91c2		e8		inx		                inx
.91c3		b5 fe		lda $fe,x	                lda $fe,x           ; wraparound so inx doesn't wreck Z status
.91c5		15 ff		ora $ff,x	                ora $ff,x
.91c7		60		rts		                rts
.91c8		d0 03		bne $91cd	                bne zero_test_footer_end+2  ; branch fwd if non-zero
>91ca		4c				                .byte $4c                   ; else JMP back
.91cb						zero_test_footer_end:
.91cb						zero_branch_runtime:
.91cb		68		pla		                pla
.91cc		85 25		sta $25		                sta tmp1
.91ce		68		pla		                pla
.91cf		85 26		sta $26		                sta tmp1+1
.91d1		b5 00		lda $00,x	                lda 0,x
.91d3		15 01		ora $01,x	                ora 1,x
.91d5		f0 0d		beq $91e4	                beq _zero
.91d7		a5 25		lda $25		                lda tmp1        ; LSB
.91d9		18		clc		                clc
.91da		69 03		adc #$03	                adc #3          ; add one to RTS address plus two address bytes
.91dc		85 25		sta $25		                sta tmp1
.91de		90 11		bcc $91f1	                bcc _jump
.91e0		e6 26		inc $26		                inc tmp1+1      ; MSB
.91e2		80 0d		bra $91f1	                bra _jump
.91e4						_zero:
.91e4		a0 01		ldy #$01	                ldy #1
.91e6		b1 25		lda ($25),y	                lda (tmp1),y
.91e8		48		pha		                pha
.91e9		c8		iny		                iny
.91ea		b1 25		lda ($25),y	                lda (tmp1),y
.91ec		85 26		sta $26		                sta tmp1+1
.91ee		68		pla		                pla
.91ef		85 25		sta $25		                sta tmp1
.91f1						_jump:
.91f1		e8		inx		                inx
.91f2		e8		inx		                inx
.91f3		6c 25 00	jmp ($0025)	                jmp (tmp1)
.91f6						xt_immediate:
.91f6		20 ba d7	jsr $d7ba	                jsr current_to_dp
.91f9		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.91fb		b1 02		lda ($02),y	                lda (dp),y
.91fd		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.91ff		91 02		sta ($02),y	                sta (dp),y
.9201		60		rts		z_immediate:    rts
.9202						xt_input:
.9202		ca		dex		                dex
.9203		ca		dex		                dex
.9204		a9 14		lda #$14	                lda #<input
.9206		95 00		sta $00,x	                sta 0,x
.9208		a9 00		lda #$00	                lda #>input
.920a		95 01		sta $01,x	                sta 1,x
.920c		60		rts		z_input:        rts
.920d						xt_input_to_r:
.920d		68		pla		                pla
.920e		85 25		sta $25		                sta tmp1
.9210		68		pla		                pla
.9211		85 26		sta $26		                sta tmp1+1
.9213		a0 07		ldy #$07	                ldy #7
.9215						_loop:
.9215		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9218		48		pha		                pha
.9219		88		dey		                dey
.921a		10 f9		bpl $9215	                bpl _loop
.921c		a5 26		lda $26		                lda tmp1+1
.921e		48		pha		                pha
.921f		a5 25		lda $25		                lda tmp1
.9221		48		pha		                pha
.9222		60		rts		z_input_to_r: 	rts
.9223						xt_int_to_name:
.9223		20 73 d8	jsr $d873	                jsr underflow_1
.9226		ca		dex		                dex
.9227		ca		dex		                dex
.9228		74 00		stz $00,x	                stz 0,x
.922a		74 01		stz $01,x	                stz 1,x
.922c						_wordlist_loop:
.922c		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.922e		0a		asl a		                asl                     ; Turn offset into cells offset.
.922f		18		clc		                clc
.9230		69 0a		adc #$0a	                adc #wordlists_offset
.9232		a8		tay		                tay
.9233		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9235		85 27		sta $27		                sta tmp2                ; into tmp2
.9237		c8		iny		                iny
.9238		b1 08		lda ($08),y	                lda (up),y
.923a		85 28		sta $28		                sta tmp2+1
.923c		a5 27		lda $27		                lda tmp2
.923e		05 28		ora $28		                ora tmp2+1
.9240		f0 38		beq $927a	                beq _next_wordlist
.9242		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9244		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9246		b5 03		lda $03,x	                lda 3,x
.9248		85 2a		sta $2a		                sta tmp3+1
.924a						_loop:
.924a		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.924c		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.924e		c5 29		cmp $29		                cmp tmp3
.9250		d0 07		bne $9259	                bne _no_match
.9252		c8		iny		                iny
.9253		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9255		c5 2a		cmp $2a		                cmp tmp3+1
.9257		f0 32		beq $928b	                beq _match
.9259						_no_match:
.9259		18		clc		                clc
.925a		a5 27		lda $27		                lda tmp2
.925c		69 02		adc #$02	                adc #2
.925e		85 27		sta $27		                sta tmp2
.9260		a5 28		lda $28		                lda tmp2+1
.9262		69 00		adc #$00	                adc #0          ; only care about carry
.9264		85 28		sta $28		                sta tmp2+1
.9266		a0 00		ldy #$00	                ldy #0
.9268		b1 27		lda ($27),y	                lda (tmp2),y
.926a		48		pha		                pha
.926b		c8		iny		                iny
.926c		11 27		ora ($27),y	                ora (tmp2),y
.926e		f0 09		beq $9279	                beq _zero
.9270		b1 27		lda ($27),y	                lda (tmp2),y
.9272		85 28		sta $28		                sta tmp2+1
.9274		68		pla		                pla
.9275		85 27		sta $27		                sta tmp2
.9277		80 d1		bra $924a	                bra _loop
.9279						_zero:
.9279		68		pla		                pla             ; Leftover from above loop
.927a						_next_wordlist:
.927a		b5 00		lda $00,x	                lda 0,x
.927c		1a		inc a		                ina
.927d		95 00		sta $00,x	                sta 0,x
.927f		c9 0c		cmp #$0c	                cmp #max_wordlists
.9281		d0 a9		bne $922c	                bne _wordlist_loop
.9283		e8		inx		                inx
.9284		e8		inx		                inx
.9285		74 00		stz $00,x	                stz 0,x
.9287		74 01		stz $01,x	                stz 1,x
.9289		80 0a		bra $9295	                bra z_int_to_name
.928b						_match:
.928b		e8		inx		                inx
.928c		e8		inx		                inx
.928d		a5 27		lda $27		                lda tmp2
.928f		95 00		sta $00,x	                sta 0,x
.9291		a5 28		lda $28		                lda tmp2+1
.9293		95 01		sta $01,x	                sta 1,x
.9295		60		rts		z_int_to_name:  rts
.9296						xt_invert:
.9296		20 73 d8	jsr $d873	                jsr underflow_1
.9299		a9 ff		lda #$ff	                lda #$FF
.929b		55 00		eor $00,x	                eor 0,x         ; LSB
.929d		95 00		sta $00,x	                sta 0,x
.929f		a9 ff		lda #$ff	                lda #$FF
.92a1		55 01		eor $01,x	                eor 1,x         ; MSB
.92a3		95 01		sta $01,x	                sta 1,x
.92a5		60		rts		z_invert:       rts
.92a6						xt_is:
.92a6		a5 1a		lda $1a		                lda state
.92a8		05 1b		ora $1b		                ora state+1
.92aa		f0 0c		beq $92b8	                beq _interpreting
.92ac						_compiling:
.92ac		20 37 85	jsr $8537	                jsr xt_bracket_tick
.92af		a0 8a		ldy #$8a	                ldy #>xt_defer_store
.92b1		a9 7e		lda #$7e	                lda #<xt_defer_store
.92b3		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.92b6		80 06		bra $92be	                bra _done
.92b8						_interpreting:
.92b8		20 8c a1	jsr $a18c	                jsr xt_tick
.92bb		20 7e 8a	jsr $8a7e	                jsr xt_defer_store
.92be						_done:
.92be		60		rts		z_is:           rts
.92bf						xt_j:
.92bf		ca		dex		                dex                 ; make space on the stack
.92c0		ca		dex		                dex
.92c1		a5 1f		lda $1f		                lda loopctrl
.92c3		38		sec		                sec
.92c4		e9 04		sbc #$04	                sbc #4
.92c6		a8		tay		                tay
.92c7		38		sec		                sec
.92c8		b9 00 01	lda $0100,y	                lda loopindex,y
.92cb		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.92ce		95 00		sta $00,x	                sta 0,x
.92d0		b9 01 01	lda $0101,y	                lda loopindex+1,y
.92d3		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.92d6		95 01		sta $01,x	                sta 1,x
.92d8		60		rts		z_j:            rts
.92d9						xt_key:
.92d9		20 e3 92	jsr $92e3	                jsr key_a               ; returns char in A
.92dc		ca		dex		                dex
.92dd		ca		dex		                dex
.92de		95 00		sta $00,x	                sta 0,x
.92e0		74 01		stz $01,x	                stz 1,x
.92e2		60		rts		z_key:          rts
.92e3						key_a:
.92e3		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.92e6						xt_latestnt:
.92e6		ca		dex		                dex
.92e7		ca		dex		                dex
.92e8		20 ba d7	jsr $d7ba	                jsr current_to_dp
.92eb		a5 02		lda $02		                lda dp
.92ed		95 00		sta $00,x	                sta 0,x
.92ef		a5 03		lda $03		                lda dp+1
.92f1		95 01		sta $01,x	                sta 1,x
.92f3		60		rts		z_latestnt:     rts
.92f4						xt_latestxt:
.92f4		20 e6 92	jsr $92e6	                jsr xt_latestnt         ; ( nt )
.92f7		20 b6 95	jsr $95b6	                jsr xt_name_to_int      ; ( xt )
.92fa		60		rts		z_latestxt:     rts
.92fb						xt_leave:
.92fb		a9 4c		lda #$4c	                lda #$4c
.92fd		20 1c d7	jsr $d71c	                jsr cmpl_a      ; emit the JMP
.9300		a5 21		lda $21		                lda loopleave   ; chain the prior leave address
.9302		20 1c d7	jsr $d71c	                jsr cmpl_a
.9305		a5 22		lda $22		                lda loopleave+1
.9307		20 1c d7	jsr $d71c	                jsr cmpl_a
.930a		38		sec		                sec
.930b		a5 00		lda $00		                lda cp
.930d		e9 02		sbc #$02	                sbc #2
.930f		85 21		sta $21		                sta loopleave
.9311		a5 01		lda $01		                lda cp+1
.9313		b0 01		bcs $9316	                bcs +
.9315		3a		dec a		                dea
.9316		85 22		sta $22		+               sta loopleave+1
.9318						z_leave:
.9318		60		rts		                rts
.9319						xt_left_bracket:
.9319		64 1a		stz $1a		                stz state
.931b		64 1b		stz $1b		                stz state+1
.931d		60		rts		z_left_bracket: rts
.931e						xt_less_number_sign:
.931e		20 6d 98	jsr $986d	                jsr xt_pad      ; ( addr )
.9321		b5 00		lda $00,x	                lda 0,x
.9323		85 2b		sta $2b		                sta tohold
.9325		b5 01		lda $01,x	                lda 1,x
.9327		85 2c		sta $2c		                sta tohold+1
.9329		e8		inx		                inx
.932a		e8		inx		                inx
.932b						z_less_number_sign:
.932b		60		rts		                rts
.932c						xt_less_than:
.932c		20 78 d8	jsr $d878	                jsr underflow_2
.932f		a0 00		ldy #$00	                ldy #0          ; default false
.9331		20 9f d7	jsr $d79f	                jsr compare_16bit
.9334		f0 03		beq $9339	                beq _false
.9336		30 01		bmi $9339	                bmi _false
.9338		88		dey		                dey
.9339						_false:
.9339		98		tya		                tya
.933a		e8		inx		                inx
.933b		e8		inx		                inx
.933c		95 00		sta $00,x	                sta 0,x
.933e		95 01		sta $01,x	                sta 1,x
.9340		60		rts		z_less_than:    rts
.9341						xt_list:
.9341		20 73 d8	jsr $d873	                jsr underflow_1
.9344		20 6f 9e	jsr $9e6f	                jsr xt_scr
.9347		20 18 a1	jsr $a118	                jsr xt_store
.934a		20 d0 a7	jsr $a7d0	                jsr xt_editor_l
.934d		60		rts		z_list:         rts
.934e						xt_literal:
.934e		20 73 d8	jsr $d873	                jsr underflow_1
.9351		a0 93		ldy #$93	                ldy #>literal_runtime
.9353		a9 5c		lda #$5c	                lda #<literal_runtime
.9355		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.9358		20 f1 86	jsr $86f1	                jsr xt_comma
.935b		60		rts		z_literal:      rts
.935c						literal_runtime:
.935c		ca		dex		                dex
.935d		ca		dex		                dex
.935e		68		pla		                pla             ; LSB
.935f		85 25		sta $25		                sta tmp1
.9361		68		pla		                pla             ; MSB
.9362		85 26		sta $26		                sta tmp1+1
.9364		a0 01		ldy #$01	                ldy #1
.9366		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.9368		95 00		sta $00,x	                sta 0,x
.936a		c8		iny		                iny
.936b		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.936d		95 01		sta $01,x	                sta 1,x
.936f		98		tya		                tya
.9370		18		clc		                clc
.9371		65 25		adc $25		                adc tmp1
.9373		a8		tay		                tay
.9374		a5 26		lda $26		                lda tmp1+1
.9376		69 00		adc #$00	                adc #0
.9378		48		pha		                pha
.9379		5a		phy		                phy
.937a		60		rts		                rts
.937b						xt_load:
.937b		20 73 d8	jsr $d873	                jsr underflow_1
.937e		a0 05		ldy #$05	                ldy #blk_offset+1
.9380		b1 08		lda ($08),y	                lda (up),y
.9382		48		pha		                pha
.9383		88		dey		                dey
.9384		b1 08		lda ($08),y	                lda (up),y
.9386		48		pha		                pha
.9387		b5 00		lda $00,x	                lda 0,x
.9389		91 08		sta ($08),y	                sta (up),y
.938b		c8		iny		                iny
.938c		b5 01		lda $01,x	                lda 1,x
.938e		91 08		sta ($08),y	                sta (up),y
.9390		20 70 83	jsr $8370	                jsr xt_block
.9393		ca		dex		                dex
.9394		ca		dex		                dex
.9395		a9 04		lda #$04	                lda #4
.9397		95 01		sta $01,x	                sta 1,x
.9399		74 00		stz $00,x	                stz 0,x
.939b		20 81 90	jsr $9081	                jsr load_evaluate
.939e		a0 04		ldy #$04	                ldy #blk_offset
.93a0		68		pla		                pla
.93a1		91 08		sta ($08),y	                sta (up),y
.93a3		c8		iny		                iny
.93a4		68		pla		                pla
.93a5		91 08		sta ($08),y	                sta (up),y
.93a7		88		dey		                dey
.93a8		11 08		ora ($08),y	                ora (up),y
.93aa		f0 12		beq $93be	                beq _done
.93ac		ca		dex		                dex
.93ad		ca		dex		                dex
.93ae		a0 04		ldy #$04	                ldy #blk_offset
.93b0		b1 08		lda ($08),y	                lda (up),y
.93b2		95 00		sta $00,x	                sta 0,x
.93b4		c8		iny		                iny
.93b5		b1 08		lda ($08),y	                lda (up),y
.93b7		95 01		sta $01,x	                sta 1,x
.93b9		20 70 83	jsr $8370	                jsr xt_block
.93bc		e8		inx		                inx
.93bd		e8		inx		                inx
.93be						_done:
.93be		60		rts		z_load:         rts
.93bf						xt_loop:
.93bf		ca		dex		                dex
.93c0		ca		dex		                dex
.93c1		a9 22		lda #$22	                lda #<loop_runtime
.93c3		95 00		sta $00,x	                sta 0,x
.93c5		a9 94		lda #$94	                lda #>loop_runtime
.93c7		95 01		sta $01,x	                sta 1,x
.93c9		a0 12		ldy #$12	                ldy #loop_runtime_end-loop_runtime
.93cb		20 5e 88	jsr $885e	                jsr cmpl_inline_y
.93ce		80 0f		bra $93df	                bra xt_loop_common
.93d0						xt_plus_loop:
.93d0		ca		dex		                dex
.93d1		ca		dex		                dex
.93d2		a9 34		lda #$34	                lda #<plus_loop_runtime
.93d4		95 00		sta $00,x	                sta 0,x
.93d6		a9 94		lda #$94	                lda #>plus_loop_runtime
.93d8		95 01		sta $01,x	                sta 1,x
.93da		a0 1b		ldy #$1b	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93dc		20 5e 88	jsr $885e	                jsr cmpl_inline_y
.93df						xt_loop_common:
.93df		20 f1 86	jsr $86f1	                jsr xt_comma
.93e2		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.93e4		f0 19		beq $93ff	                beq _noleave
.93e6						_next:
.93e6		a0 01		ldy #$01	                ldy #1
.93e8		b1 21		lda ($21),y	                lda (loopleave),y
.93ea		48		pha		                pha
.93eb		a5 01		lda $01		                lda cp+1
.93ed		91 21		sta ($21),y	                sta (loopleave),y
.93ef		88		dey		                dey
.93f0		b1 21		lda ($21),y	                lda (loopleave),y
.93f2		48		pha		                pha
.93f3		a5 00		lda $00		                lda cp
.93f5		91 21		sta ($21),y	                sta (loopleave),y
.93f7		68		pla		                pla
.93f8		85 21		sta $21		                sta loopleave
.93fa		68		pla		                pla
.93fb		85 22		sta $22		                sta loopleave+1
.93fd		d0 e7		bne $93e6	                bne _next
.93ff						_noleave:
.93ff		b5 00		lda $00,x	                lda 0,x
.9401		85 21		sta $21		                sta loopleave
.9403		b5 01		lda $01,x	                lda 1,x
.9405		85 22		sta $22		                sta loopleave+1
.9407		a9 bd		lda #$bd	                lda #<xt_unloop
.9409		95 00		sta $00,x	                sta 0,x
.940b		a9 a5		lda #$a5	                lda #>xt_unloop
.940d		95 01		sta $01,x	                sta 1,x
.940f		20 70 87	jsr $8770	                jsr xt_compile_comma
.9412		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.9414		f0 09		beq $941f	                beq +
.9416		20 24 91	jsr $9124	                jsr xt_here
.9419		20 33 a1	jsr $a133	                jsr xt_swap
.941c		4c 18 a1	jmp $a118	                jmp xt_store            ; write here as ?DO jmp target and return
.941f		e8		inx		+               inx                     ; drop the ignored word for DO
.9420		e8		inx		                inx
.9421						z_loop:
.9421		60		rts		z_plus_loop:    rts
.9422						loop_runtime:
.9422		e6 20		inc $20		                inc loopidx0        ; increment the LSB of loopindex
.9424		d0 0d		bne $9433	                bne _repeat         ; avoid expensive test most of the time
.9426		a4 1f		ldy $1f		                ldy loopctrl
.9428		b9 01 01	lda $0101,y	_chkv:          lda loopindex+1,y
.942b		1a		inc a		                ina
.942c		c9 80		cmp #$80	                cmp #$80
.942e		f0 06		beq $9436	                beq _repeat+3       ; done?  skip jmp back
.9430		99 01 01	sta $0101,y	                sta loopindex+1,y
.9433						_repeat:
>9433		4c				                .byte $4C
.9434						loop_runtime_end:
.9434						plus_loop_runtime:
.9434		18		clc		                clc
.9435		b5 00		lda $00,x	                lda 0,x             ; LSB of step
.9437		65 20		adc $20		                adc loopidx0
.9439		85 20		sta $20		                sta loopidx0
.943b		e8		inx		                inx                 ; dump step from TOS before MSB test
.943c		e8		inx		                inx                 ; since we might skip it
.943d		b5 ff		lda $ff,x	                lda $ff,x           ; MSB of step since 1,x == -1,x+2
.943f		d0 02		bne $9443	                bne _chkv           ; if it's non-zero we have to check
.9441		90 0b		bcc $944e	                bcc _repeat         ; but if 0 and no carry, we're good
.9443		b8		clv		_chkv:          clv
.9444		a4 1f		ldy $1f		                ldy loopctrl        ; get LCB offset
.9446		79 01 01	adc $0101,y	                adc loopindex+1,y   ; MSB of index
.9449		99 01 01	sta $0101,y	                sta loopindex+1,y   ; put MSB of index back on stack
.944c		70 03		bvs $9451	                bvs _repeat+3     ; skip over JMP instruction
.944e						_repeat:
>944e		4c				                .byte $4C
.944f						plus_loop_runtime_end:
.944f						xt_lshift:
.944f		20 78 d8	jsr $d878	                jsr underflow_2
.9452		b5 00		lda $00,x	                lda 0,x
.9454		29 0f		and #$0f	                and #%00001111
.9456		f0 08		beq $9460	                beq _done
.9458		a8		tay		                tay
.9459						_loop:
.9459		16 02		asl $02,x	                asl 2,x
.945b		36 03		rol $03,x	                rol 3,x
.945d		88		dey		                dey
.945e		d0 f9		bne $9459	                bne _loop
.9460						_done:
.9460		e8		inx		                inx
.9461		e8		inx		                inx
.9462		60		rts		z_lshift:       rts
.9463						xt_m_star:
.9463		20 78 d8	jsr $d878	                jsr underflow_2
.9466		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9468		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.946a		48		pha		                pha
.946b		20 d1 80	jsr $80d1	                jsr xt_abs
.946e		20 33 a1	jsr $a133	                jsr xt_swap
.9471		20 d1 80	jsr $80d1	                jsr xt_abs
.9474		20 77 a5	jsr $a577	                jsr xt_um_star          ; ( d )
.9477		68		pla		                pla
.9478		10 03		bpl $947d	                bpl _done
.947a		20 d9 8a	jsr $8ad9	                jsr xt_dnegate
.947d						_done:
.947d		60		rts		z_m_star:       rts
.947e						xt_marker:
.947e		20 ba d7	jsr $d7ba	                jsr current_to_dp
.9481		a5 02		lda $02		                lda dp
.9483		48		pha		                pha
.9484		a5 03		lda $03		                lda dp+1
.9486		48		pha		                pha
.9487		a5 00		lda $00		                lda cp
.9489		48		pha		                pha
.948a		a5 01		lda $01		                lda cp+1
.948c		48		pha		                pha
.948d		20 01 89	jsr $8901	                jsr xt_create
.9490		a5 00		lda $00		                lda cp          ; LSB
.9492		38		sec		                sec
.9493		e9 02		sbc #$02	                sbc #2
.9495		85 00		sta $00		                sta cp
.9497		a5 01		lda $01		                lda cp+1        ; MSB
.9499		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.949b		85 01		sta $01		                sta cp+1
.949d		a0 94		ldy #$94	                ldy #>marker_runtime
.949f		a9 bc		lda #$bc	                lda #<marker_runtime
.94a1		20 18 d7	jsr $d718	                jsr cmpl_word
.94a4		7a		ply		                ply                     ; MSB
.94a5		68		pla		                pla                     ; LSB
.94a6		20 18 d7	jsr $d718	                jsr cmpl_word
.94a9		7a		ply		                ply                     ; MSB
.94aa		68		pla		                pla                     ; LSB
.94ab		20 18 d7	jsr $d718	                jsr cmpl_word
.94ae		a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94b0						_marker_loop:
.94b0		b1 08		lda ($08),y	                lda (up),y
.94b2		20 1c d7	jsr $d71c	                jsr cmpl_a
.94b5		c8		iny		                iny
.94b6		98		tya		                tya
.94b7		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94b9		d0 f5		bne $94b0	                bne _marker_loop
.94bb		60		rts		z_marker:       rts
.94bc						marker_runtime:
.94bc		68		pla		                pla
.94bd		85 25		sta $25		                sta tmp1        ; LSB of address
.94bf		68		pla		                pla
.94c0		85 26		sta $26		                sta tmp1+1      ; MSB of address
.94c2		e6 25		inc $25		                inc tmp1
.94c4		d0 02		bne $94c8	                bne +
.94c6		e6 26		inc $26		                inc tmp1+1
.94c8						+
.94c8		a0 00		ldy #$00	                ldy #0
.94ca		b1 25		lda ($25),y	                lda (tmp1),y
.94cc		85 00		sta $00		                sta cp
.94ce		c8		iny		                iny
.94cf		b1 25		lda ($25),y	                lda (tmp1),y
.94d1		85 01		sta $01		                sta cp+1
.94d3		c8		iny		                iny
.94d4		b1 25		lda ($25),y	                lda (tmp1),y
.94d6		85 02		sta $02		                sta dp
.94d8		c8		iny		                iny
.94d9		b1 25		lda ($25),y	                lda (tmp1),y
.94db		85 03		sta $03		                sta dp+1
.94dd		a0 04		ldy #$04	                ldy #4
.94df						_marker_restore_loop:
.94df		b1 25		lda ($25),y	                lda (tmp1), y
.94e1		91 08		sta ($08),y	                sta (up), y
.94e3		c8		iny		                iny
.94e4		98		tya		                tya
.94e5		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94e7		d0 f6		bne $94df	                bne _marker_restore_loop
.94e9		20 cd d7	jsr $d7cd	                jsr dp_to_current       ; Move the CURRENT DP back.
.94ec		60		rts		                rts
.94ed						xt_max:
.94ed		20 78 d8	jsr $d878	                jsr underflow_2
.94f0		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.94f2		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.94f4		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.94f6		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.94f8		50 02		bvc $94fc	                bvc _no_overflow
.94fa		49 80		eor #$80	                eor #$80        ; complement negative flag
.94fc						_no_overflow:
.94fc		30 08		bmi $9506	                bmi _keep_nos
.94fe		b5 00		lda $00,x	                lda 0,x
.9500		95 02		sta $02,x	                sta 2,x
.9502		b5 01		lda $01,x	                lda 1,x
.9504		95 03		sta $03,x	                sta 3,x
.9506						_keep_nos:
.9506		e8		inx		                inx
.9507		e8		inx		                inx
.9508		60		rts		z_max:          rts
.9509						xt_min:
.9509		20 78 d8	jsr $d878	                jsr underflow_2
.950c		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.950e		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.9510		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9512		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9514		50 02		bvc $9518	                bvc _no_overflow
.9516		49 80		eor #$80	                eor #$80
.9518						_no_overflow:
.9518		10 08		bpl $9522	                bpl _keep_nos
.951a		b5 00		lda $00,x	                lda 0,x
.951c		95 02		sta $02,x	                sta 2,x
.951e		b5 01		lda $01,x	                lda 1,x
.9520		95 03		sta $03,x	                sta 3,x
.9522						_keep_nos:
.9522		e8		inx		                inx
.9523		e8		inx		                inx
.9524		60		rts		z_min:          rts
.9525						xt_minus:
.9525		20 78 d8	jsr $d878	                jsr underflow_2
.9528		38		sec		                sec
.9529		b5 02		lda $02,x	                lda 2,x         ; LSB
.952b		f5 00		sbc $00,x	                sbc 0,x
.952d		95 02		sta $02,x	                sta 2,x
.952f		b5 03		lda $03,x	                lda 3,x         ; MSB
.9531		f5 01		sbc $01,x	                sbc 1,x
.9533		95 03		sta $03,x	                sta 3,x
.9535		e8		inx		                inx
.9536		e8		inx		                inx
.9537		60		rts		z_minus:        rts
.9538						xt_minus_leading:
.9538		20 78 d8	jsr $d878	                jsr underflow_2
.953b						_loop:
.953b		b5 00		lda $00,x	                lda 0,x
.953d		15 01		ora $01,x	                ora 1,x
.953f		f0 0f		beq $9550	                beq _done
.9541		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9543		20 66 d8	jsr $d866	                jsr is_whitespace
.9546		90 08		bcc $9550	                bcc _done
.9548		20 d4 97	jsr $97d4	                jsr xt_one              ; ( addr u 1 )
.954b		20 a4 9f	jsr $9fa4	                jsr xt_slash_string     ; ( addr+ u-1 )
.954e		80 eb		bra $953b	                bra _loop
.9550						_done:
.9550						z_minus_leading:
.9550		60		rts		                rts
.9551						xt_minus_trailing:
.9551		20 78 d8	jsr $d878	                jsr underflow_2
.9554		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9556		15 01		ora $01,x	                ora 1,x         ; MSB of n
.9558		f0 33		beq $958d	                beq _done
.955a		18		clc		                clc
.955b		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.955d		75 00		adc $00,x	                adc 0,x
.955f		85 25		sta $25		                sta tmp1
.9561		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.9563		75 01		adc $01,x	                adc 1,x
.9565		85 26		sta $26		                sta tmp1+1
.9567		a5 25		lda $25		                lda tmp1
.9569		d0 02		bne $956d	                bne +
.956b		c6 26		dec $26		                dec tmp1+1
.956d						+
.956d		c6 25		dec $25		                dec tmp1
.956f						_loop:
.956f		b2 25		lda ($25)	                lda (tmp1)
.9571		c9 20		cmp #$20	                cmp #AscSP
.9573		d0 18		bne $958d	                bne _done
.9575		a5 25		lda $25		                lda tmp1
.9577		d0 02		bne $957b	                bne +
.9579		c6 26		dec $26		                dec tmp1+1
.957b						+
.957b		c6 25		dec $25		                dec tmp1
.957d		b5 00		lda $00,x	                lda 0,x
.957f		d0 02		bne $9583	                bne +
.9581		d6 01		dec $01,x	                dec 1,x
.9583						+
.9583		d6 00		dec $00,x	                dec 0,x
.9585		b5 00		lda $00,x	                lda 0,x
.9587		15 01		ora $01,x	                ora 1,x
.9589		f0 02		beq $958d	                beq _done       ; Count has reached zero - we're done!
.958b		80 e2		bra $956f	                bra _loop
.958d						_done:
.958d						z_minus_trailing:
.958d		60		rts		                rts
.958e						xt_mod:
.958e		20 78 d8	jsr $d878	                jsr underflow_2
.9591		20 8c 9f	jsr $9f8c	                jsr xt_slash_mod
.9594		e8		inx		                inx             ; DROP
.9595		e8		inx		                inx
.9596						z_mod:
.9596		60		rts		                rts
.9597						xt_move:
.9597		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.9599		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.959b		f0 05		beq $95a2	                beq _lsb                ; wasn't helpful, move to LSB
.959d		b0 0e		bcs $95ad	                bcs _to_move_up         ; we want CMOVE>
.959f		4c 1c 86	jmp $861c	                jmp xt_cmove            ; JSR/RTS
.95a2						_lsb:
.95a2		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95a4		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95a6		f0 08		beq $95b0	                beq _equal              ; LSB is equal as well
.95a8		b0 03		bcs $95ad	                bcs _to_move_up         ; we want CMOVE>
.95aa		4c 1c 86	jmp $861c	                jmp xt_cmove            ; JSR/RTS
.95ad						_to_move_up:
.95ad		4c 57 86	jmp $8657	                jmp xt_cmove_up         ; JSR/RTS
.95b0						_equal:
.95b0		8a		txa		                txa
.95b1		18		clc		                clc
.95b2		69 06		adc #$06	                adc #6
.95b4		aa		tax		                tax
.95b5		60		rts		z_move:         rts
.95b6						xt_name_to_int:
.95b6		20 73 d8	jsr $d873	                jsr underflow_1
.95b9		b5 00		lda $00,x	                lda 0,x
.95bb		18		clc		                clc
.95bc		69 04		adc #$04	                adc #4
.95be		85 29		sta $29		                sta tmp3
.95c0		b5 01		lda $01,x	                lda 1,x
.95c2		90 01		bcc $95c5	                bcc _done
.95c4		1a		inc a		                ina
.95c5						_done:
.95c5		85 2a		sta $2a		                sta tmp3+1
.95c7		a0 00		ldy #$00	                ldy #0
.95c9		b1 29		lda ($29),y	                lda (tmp3),y
.95cb		95 00		sta $00,x	                sta 0,x
.95cd		c8		iny		                iny
.95ce		b1 29		lda ($29),y	                lda (tmp3),y
.95d0		95 01		sta $01,x	                sta 1,x
.95d2		60		rts		z_name_to_int:  rts
.95d3						xt_name_to_string:
.95d3		20 73 d8	jsr $d873	                jsr underflow_1
.95d6		ca		dex		                dex
.95d7		ca		dex		                dex
.95d8		a1 02		lda ($02,x)	                lda (2,x)
.95da		95 00		sta $00,x	                sta 0,x
.95dc		74 01		stz $01,x	                stz 1,x
.95de		b5 02		lda $02,x	                lda 2,x         ; LSB
.95e0		18		clc		                clc
.95e1		69 08		adc #$08	                adc #8
.95e3		a8		tay		                tay
.95e4		b5 03		lda $03,x	                lda 3,x         ; MSB
.95e6		69 00		adc #$00	                adc #0          ; just need carry
.95e8		95 03		sta $03,x	                sta 3,x
.95ea		94 02		sty $02,x	                sty 2,x
.95ec						z_name_to_string:
.95ec		60		rts		                rts
.95ed						xt_nc_limit:
.95ed		a9 00		lda #$00	                lda #nc_limit_offset
.95ef		4c 79 d7	jmp $d779	                jmp push_upvar_tos
.95f2						z_nc_limit:
.95f2						xt_negate:
.95f2		20 73 d8	jsr $d873	                jsr underflow_1
.95f5		a9 00		lda #$00	        	lda #0
.95f7		38		sec		                sec
.95f8		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.95fa		95 00		sta $00,x	                sta 0,x
.95fc		a9 00		lda #$00	                lda #0
.95fe		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9600		95 01		sta $01,x	                sta 1,x
.9602		60		rts		z_negate:       rts
.9603						xt_never_native:
.9603		20 ba d7	jsr $d7ba	                jsr current_to_dp
.9606		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9608		b1 02		lda ($02),y	                lda (dp),y
.960a		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.960c		29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.960e		91 02		sta ($02),y	                sta (dp),y
.9610						z_never_native:
.9610		60		rts		                rts
.9611						xt_nip:
.9611		20 78 d8	jsr $d878	                jsr underflow_2
.9614		b5 00		lda $00,x	                lda 0,x         ; LSB
.9616		95 02		sta $02,x	                sta 2,x
.9618		b5 01		lda $01,x	                lda 1,x         ; MSB
.961a		95 03		sta $03,x	                sta 3,x
.961c		e8		inx		                inx
.961d		e8		inx		                inx
.961e		60		rts		z_nip:          rts
.961f						xt_not_equals:
.961f		20 78 d8	jsr $d878	                jsr underflow_2
.9622		a0 00		ldy #$00	                ldy #0                  ; default is true
.9624		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9626		d5 02		cmp $02,x	                cmp 2,x
.9628		d0 0a		bne $9634	                bne _not_equal
.962a		b5 01		lda $01,x	                lda 1,x                 ; MSB
.962c		d5 03		cmp $03,x	                cmp 3,x
.962e		d0 04		bne $9634	                bne _not_equal
.9630		a9 ff		lda #$ff	                lda #$FF
.9632		80 01		bra $9635	                bra _done
.9634						_not_equal:
.9634		88		dey		                dey                     ; drop thru to done
.9635						_done:
.9635		98		tya		                tya
.9636		e8		inx		                inx
.9637		e8		inx		                inx
.9638		95 00		sta $00,x	                sta 0,x
.963a		95 01		sta $01,x	                sta 1,x
.963c		60		rts		z_not_equals:   rts
.963d						xt_not_rote:
.963d		20 7d d8	jsr $d87d	                jsr underflow_3
.9640		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9642		b5 03		lda $03,x	                lda 3,x
.9644		95 01		sta $01,x	                sta 1,x
.9646		b5 05		lda $05,x	                lda 5,x
.9648		95 03		sta $03,x	                sta 3,x
.964a		94 05		sty $05,x	                sty 5,x
.964c		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.964e		b5 02		lda $02,x	                lda 2,x
.9650		95 00		sta $00,x	                sta 0,x
.9652		b5 04		lda $04,x	                lda 4,x
.9654		95 02		sta $02,x	                sta 2,x
.9656		94 04		sty $04,x	                sty 4,x
.9658		60		rts		z_not_rote:     rts
.9659						xt_number:
.9659		20 78 d8	jsr $d878	                jsr underflow_2
.965c		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.965e		a5 18		lda $18		                lda base
.9660		48		pha		                pha
.9661		20 33 a3	jsr $a333	                jsr xt_two_dup
.9664		a1 02		lda ($02,x)	                lda (2,x)
.9666						_check_dec:
.9666		c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.9668		d0 04		bne $966e	                bne _check_hex
.966a		a9 0a		lda #$0a	                lda #$0A
.966c		80 42		bra $96b0	                bra _base_changed
.966e						_check_hex:
.966e		c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.9670		d0 04		bne $9676	                bne _check_binary
.9672		a9 10		lda #$10	                lda #$10
.9674		80 3a		bra $96b0	                bra _base_changed
.9676						_check_binary:
.9676		c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.9678		d0 04		bne $967e	                bne _check_char
.967a		a9 02		lda #$02	                lda #$02
.967c		80 32		bra $96b0	                bra _base_changed
.967e						_check_char:
.967e		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.9680		d0 3a		bne $96bc	                bne _check_minus
.9682		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9684		c9 03		cmp #$03	                cmp #$03
.9686		d0 26		bne $96ae	                bne _not_a_char
.9688		b5 01		lda $01,x	                lda 1,x
.968a		d0 22		bne $96ae	                bne _not_a_char ; No compare needed to check for non-zero.
.968c		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.968e		18		clc		                clc
.968f		69 02		adc #$02	                adc #2          ; length of string
.9691		85 23		sta $23		                sta tmptos
.9693		b5 03		lda $03,x	                lda 3,x
.9695		69 00		adc #$00	                adc #0          ; only need carry
.9697		85 24		sta $24		                sta tmptos+1
.9699		b2 23		lda ($23)	                lda (tmptos)
.969b		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.969d		d0 0f		bne $96ae	                bne _not_a_char
.969f		f6 02		inc $02,x	                inc 2,x
.96a1		d0 02		bne $96a5	                bne +
.96a3		f6 03		inc $03,x	                inc 3,x
.96a5						+
.96a5		a1 02		lda ($02,x)	                lda (2,x)
.96a7		95 02		sta $02,x	                sta 2,x
.96a9		74 03		stz $03,x	                stz 3,x
.96ab		4c 2e 97	jmp $972e	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96ae						_not_a_char:
.96ae		80 5c		bra $970c	                bra _number_error
.96b0						_base_changed:
.96b0		85 18		sta $18		                sta base        ; Switch to the new base
.96b2		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96b4		d0 02		bne $96b8	                bne +
.96b6		f6 03		inc $03,x	                inc 3,x
.96b8						+
.96b8		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96ba		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96bc						_check_minus:
.96bc		c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96be		d0 0c		bne $96cc	                bne _check_dot
.96c0		a9 80		lda #$80	                lda #$80
.96c2		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.96c4		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96c6		d0 02		bne $96ca	                bne +
.96c8		f6 03		inc $03,x	                inc 3,x
.96ca						+
.96ca		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96cc						_check_dot:
.96cc		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96ce		18		clc		                clc
.96cf		75 00		adc $00,x	                adc 0,x         ; length of string
.96d1		85 23		sta $23		                sta tmptos
.96d3		b5 03		lda $03,x	                lda 3,x
.96d5		69 00		adc #$00	                adc #0          ; only need carry
.96d7		85 24		sta $24		                sta tmptos+1
.96d9		a5 23		lda $23		                lda tmptos
.96db		d0 02		bne $96df	                bne +
.96dd		c6 24		dec $24		                dec tmptos+1
.96df						+
.96df		c6 23		dec $23		                dec tmptos
.96e1		b2 23		lda ($23)	                lda (tmptos)
.96e3		c9 2e		cmp #$2e	                cmp #'.'
.96e5		d0 04		bne $96eb	                bne _main
.96e7		e6 1e		inc $1e		                inc tmpdsp
.96e9		d6 00		dec $00,x	                dec 0,x
.96eb						_main:
.96eb		ca		dex		                dex
.96ec		ca		dex		                dex
.96ed		ca		dex		                dex
.96ee		ca		dex		                dex
.96ef		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.96f1		95 00		sta $00,x	                sta 0,x
.96f3		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.96f5		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.96f7		95 02		sta $02,x	                sta 2,x
.96f9		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.96fb		95 03		sta $03,x	                sta 3,x
.96fd		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.96ff		74 05		stz $05,x	                stz 5,x
.9701		74 06		stz $06,x	                stz 6,x
.9703		74 07		stz $07,x	                stz 7,x
.9705		20 38 a2	jsr $a238	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9708		b5 00		lda $00,x	                lda 0,x
.970a		f0 1e		beq $972a	                beq _all_converted
.970c						_number_error:
.970c		20 2b a3	jsr $a32b	                jsr xt_two_drop ; >NUMBER modified addr u
.970f		20 2b a3	jsr $a32b	                jsr xt_two_drop ; ud   (partially converted number)
.9712		a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9714		20 a8 8d	jsr $8da8	                jsr emit_a
.9717		20 7e a4	jsr $a47e	                jsr xt_type
.971a		a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.971c		20 a8 8d	jsr $8da8	                jsr emit_a
.971f		20 a9 a0	jsr $a0a9	                jsr xt_space
.9722		68		pla		                pla
.9723		85 18		sta $18		                sta base
.9725		a9 08		lda #$08	                lda #err_syntax
.9727		4c 89 d8	jmp $d889	                jmp error
.972a						_all_converted:
.972a		e8		inx		                inx ; Drop the current addr u
.972b		e8		inx		                inx
.972c		e8		inx		                inx
.972d		e8		inx		                inx
.972e						_drop_original_string:
.972e		20 f9 a3	jsr $a3f9	                jsr xt_two_swap  ; Drop the original addr u
.9731		20 2b a3	jsr $a32b	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9734		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9736		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9738		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9739		f0 0a		beq $9745	                beq _single
.973b		98		tya		                tya
.973c		04 1c		tsb $1c		                tsb status
.973e		90 0f		bcc $974f	                bcc _done       ; no minus, all done
.9740		20 d9 8a	jsr $8ad9	                jsr xt_dnegate
.9743		80 0a		bra $974f	                bra _done
.9745						_single:
.9745		e8		inx		                inx
.9746		e8		inx		                inx
.9747		98		tya		                tya
.9748		14 1c		trb $1c		                trb status
.974a		90 03		bcc $974f	                bcc _done       ; no minus, all done
.974c		20 f2 95	jsr $95f2	                jsr xt_negate
.974f						_done:
.974f		68		pla		                pla
.9750		85 18		sta $18		                sta base
.9752		60		rts		z_number:       rts
.9753						xt_number_sign:
.9753		20 78 d8	jsr $d878	                jsr underflow_2         ; double number
.9756		20 41 83	jsr $8341	                jsr xt_base
.9759		20 32 8f	jsr $8f32	                jsr xt_fetch            ; ( ud1 base )
.975c		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >r
.975f		20 36 a7	jsr $a736	                jsr xt_zero             ; 0
.9762		20 49 9a	jsr $9a49	                jsr xt_r_fetch          ; r@
.9765		20 35 a5	jsr $a535	                jsr xt_um_slash_mod     ; um/mod
.9768		20 1c 9b	jsr $9b1c	                jsr xt_rot              ; rot
.976b		20 1c 9b	jsr $9b1c	                jsr xt_rot              ; rot
.976e		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; r>
.9771		20 35 a5	jsr $a535	                jsr xt_um_slash_mod     ; um/mod
.9774		20 1c 9b	jsr $9b1c	                jsr xt_rot              ; rot
.9777		20 1c 9b	jsr $9b1c	                jsr xt_rot              ; ( ud rem )
.977a		b5 00		lda $00,x	                lda 0,x
.977c		a8		tay		                tay
.977d		b9 30 d4	lda $d430,y	                lda s_abc_upper,y
.9780		95 00		sta $00,x	                sta 0,x
.9782		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.9784		20 89 91	jsr $9189	                jsr xt_hold
.9787						z_number_sign:
.9787		60		rts		                rts
.9788						xt_number_sign_greater:
.9788		20 78 d8	jsr $d878	                jsr underflow_2         ; double number
.978b		a5 2b		lda $2b		                lda tohold
.978d		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.978f		95 02		sta $02,x	                sta 2,x
.9791		a5 2c		lda $2c		                lda tohold+1
.9793		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.9795		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.9797		20 6d 98	jsr $986d	                jsr xt_pad      ; ( addr addr pad )
.979a		38		sec		                sec
.979b		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.979d		f5 02		sbc $02,x	                sbc 2,x
.979f		95 02		sta $02,x	                sta 2,x
.97a1		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97a3		f5 03		sbc $03,x	                sbc 3,x
.97a5		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97a7		e8		inx		                inx
.97a8		e8		inx		                inx
.97a9						z_number_sign_greater:
.97a9		60		rts		                rts
.97aa						xt_number_sign_s:
.97aa		20 78 d8	jsr $d878	                jsr underflow_2
.97ad						_loop:
.97ad		20 53 97	jsr $9753	                jsr xt_number_sign
.97b0		b5 00		lda $00,x	                lda 0,x
.97b2		15 01		ora $01,x	                ora 1,x
.97b4		15 02		ora $02,x	                ora 2,x
.97b6		15 03		ora $03,x	                ora 3,x
.97b8		d0 f3		bne $97ad	                bne _loop
.97ba						z_number_sign_s:
.97ba		60		rts		                rts
.97bb						xt_of:
.97bb		a0 98		ldy #$98	                ldy #>xt_over
.97bd		a9 5f		lda #$5f	                lda #<xt_over
.97bf		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.97c2		a0 8e		ldy #$8e	                ldy #>xt_equal
.97c4		a9 80		lda #$80	                lda #<xt_equal
.97c6		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.97c9		20 b0 91	jsr $91b0	                jsr xt_if
.97cc		a0 8c		ldy #$8c	                ldy #>xt_drop
.97ce		a9 ae		lda #$ae	                lda #<xt_drop
.97d0		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.97d3		60		rts		z_of:           rts
.97d4						xt_editor_wordlist:
.97d4						xt_one:
.97d4		ca		dex		                dex
.97d5		ca		dex		                dex
.97d6		a9 01		lda #$01	                lda #1
.97d8		95 00		sta $00,x	                sta 0,x
.97da		74 01		stz $01,x	                stz 1,x
.97dc						z_editor_wordlist:
.97dc						z_one:
.97dc		60		rts		                rts
.97dd						xt_one_minus:
.97dd		20 73 d8	jsr $d873	                jsr underflow_1
.97e0		b5 00		lda $00,x	                lda 0,x
.97e2		d0 02		bne $97e6	                bne +
.97e4		d6 01		dec $01,x	                dec 1,x
.97e6						+
.97e6		d6 00		dec $00,x	                dec 0,x
.97e8		60		rts		z_one_minus:    rts
.97e9						xt_char_plus:
.97e9						xt_one_plus:
.97e9		20 73 d8	jsr $d873	                jsr underflow_1
.97ec		f6 00		inc $00,x	                inc 0,x
.97ee		d0 02		bne $97f2	                bne _done
.97f0		f6 01		inc $01,x	                inc 1,x
.97f2						_done:
.97f2						z_char_plus:
.97f2		60		rts		z_one_plus:     rts
.97f3						xt_only:
.97f3		ca		dex		                dex
.97f4		ca		dex		                dex
.97f5		a9 ff		lda #$ff	                lda #$FF
.97f7		95 00		sta $00,x	                sta 0,x
.97f9		95 01		sta $01,x	                sta 1,x
.97fb		20 e0 9c	jsr $9ce0	                jsr xt_set_order
.97fe		60		rts		z_only:         rts
.97ff						xt_or:
.97ff		20 78 d8	jsr $d878	                jsr underflow_2
.9802		b5 00		lda $00,x	                lda 0,x
.9804		15 02		ora $02,x	                ora 2,x
.9806		95 02		sta $02,x	                sta 2,x
.9808		b5 01		lda $01,x	                lda 1,x
.980a		15 03		ora $03,x	                ora 3,x
.980c		95 03		sta $03,x	                sta 3,x
.980e		e8		inx		                inx
.980f		e8		inx		                inx
.9810		60		rts		z_or:           rts
.9811						xt_order:
.9811		20 fb 88	jsr $88fb	                jsr xt_cr
.9814		20 e6 90	jsr $90e6	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.9817		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9819		f0 1e		beq $9839	                beq _drop_done
.981b						_have_wordlists:
.981b		a8		tay		                tay
.981c						_loop:
.981c		e8		inx		                inx
.981d		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.981e		b5 00		lda $00,x	                lda 0,x
.9820		5a		phy		                phy
.9821		20 3c 98	jsr $983c	                jsr order_print_wid_string   ; internal helper function
.9824		7a		ply		                ply
.9825		88		dey		                dey
.9826		d0 f4		bne $981c	                bne _loop
.9828		20 a9 a0	jsr $a0a9	                jsr xt_space
.982b		20 a9 a0	jsr $a0a9	                jsr xt_space
.982e		20 db 90	jsr $90db	                jsr xt_get_current      ; ( wid )
.9831		b5 00		lda $00,x	                lda 0,x
.9833		20 3c 98	jsr $983c	                jsr order_print_wid_string
.9836		20 fb 88	jsr $88fb	                jsr xt_cr
.9839						_drop_done:
.9839		e8		inx		                inx
.983a		e8		inx		                inx
.983b						z_order:
.983b		60		rts		                rts
.983c						order_print_wid_string:
.983c		c9 04		cmp #$04	                cmp #4
.983e		90 09		bcc $9849	                bcc _output_string      ; less than 4, print a real string
.9840		ca		dex		                dex
.9841		ca		dex		                dex
.9842		95 00		sta $00,x	                sta 0,x
.9844		74 01		stz $01,x	                stz 1,x
.9846		4c a9 a4	jmp $a4a9	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.9849						_output_string:
.9849		a8		tay		                tay
.984a		b9 50 98	lda $9850,y	                lda _wid_data,y
.984d		4c af d8	jmp $d8af	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9850						_wid_data:
>9850		04				        .byte str_wid_forth            ; WID 0: "Forth"
>9851		05				        .byte str_wid_editor           ; WID 1: "Editor"
>9852		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9853		07				        .byte str_wid_root             ; WID 3: "Root"
.9854						xt_output:
.9854		ca		dex		                dex
.9855		ca		dex		                dex
.9856		a9 12		lda #$12	                lda #<output
.9858		95 00		sta $00,x	                sta 0,x
.985a		a9 00		lda #$00	                lda #>output
.985c		95 01		sta $01,x	                sta 1,x
.985e		60		rts		z_output:       rts
.985f						xt_over:
.985f		20 78 d8	jsr $d878	                jsr underflow_2
.9862		ca		dex		                dex
.9863		ca		dex		                dex
.9864		b5 04		lda $04,x	                lda 4,x         ; LSB
.9866		95 00		sta $00,x	                sta 0,x
.9868		b5 05		lda $05,x	                lda 5,x         ; MSB
.986a		95 01		sta $01,x	                sta 1,x
.986c		60		rts		z_over:         rts
.986d						xt_pad:
.986d		ca		dex		                dex
.986e		ca		dex		                dex
.986f		a5 00		lda $00		                lda cp
.9871		18		clc		                clc
.9872		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.9874		95 00		sta $00,x	                sta 0,x
.9876		a5 01		lda $01		                lda cp+1
.9878		69 00		adc #$00	                adc #0          ; only need carry
.987a		95 01		sta $01,x	                sta 1,x
.987c		60		rts		z_pad:          rts
.987d						xt_page:
.987d		a9 1b		lda #$1b	                lda #AscESC
.987f		20 a8 8d	jsr $8da8	                jsr emit_a
.9882		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.9884		20 a8 8d	jsr $8da8	                jsr emit_a
.9887		a9 32		lda #$32	                lda #'2'
.9889		20 a8 8d	jsr $8da8	                jsr emit_a
.988c		a9 4a		lda #$4a	                lda #'J'
.988e		20 a8 8d	jsr $8da8	                jsr emit_a
.9891		20 36 a7	jsr $a736	                jsr xt_zero
.9894		20 36 a7	jsr $a736	                jsr xt_zero
.9897		20 e8 82	jsr $82e8	                jsr xt_at_xy
.989a		60		rts		z_page:         rts
.989b						xt_paren:
.989b		ca		dex		                dex
.989c		ca		dex		                dex
.989d		a9 29		lda #$29	                lda #41     ; Right parenthesis
.989f		95 00		sta $00,x	                sta 0,x
.98a1		74 01		stz $01,x	                stz 1,x
.98a3		20 06 99	jsr $9906	                jsr xt_parse
.98a6		e8		inx		                inx
.98a7		e8		inx		                inx
.98a8		e8		inx		                inx
.98a9		e8		inx		                inx
.98aa		60		rts		z_paren:        rts
.98ab						xt_parse_name:
.98ab		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.98ad		38		sec		                sec
.98ae		e5 10		sbc $10		                sbc toin
.98b0		85 25		sta $25		                sta tmp1
.98b2		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.98b4		e5 11		sbc $11		                sbc toin+1
.98b6		85 26		sta $26		                sta tmp1+1
.98b8		a5 25		lda $25		                lda tmp1
.98ba		05 26		ora $26		                ora tmp1+1
.98bc		f0 28		beq $98e6	                beq _empty_line
.98be		a5 0c		lda $0c		                lda cib
.98c0		18		clc		                clc
.98c1		65 10		adc $10		                adc toin
.98c3		85 27		sta $27		                sta tmp2                ; LSB of first character
.98c5		a5 0d		lda $0d		                lda cib+1
.98c7		65 11		adc $11		                adc toin+1
.98c9		85 28		sta $28		                sta tmp2+1              ; MSB
.98cb						_skip_loop:
.98cb		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.98cd		20 66 d8	jsr $d866	                jsr is_whitespace
.98d0		90 1f		bcc $98f1	                bcc _char_found
.98d2		e6 27		inc $27		                inc tmp2
.98d4		d0 02		bne $98d8	                bne +
.98d6		e6 28		inc $28		                inc tmp2+1
.98d8						+
.98d8		a5 25		lda $25		                lda tmp1
.98da		d0 02		bne $98de	                bne +
.98dc		c6 26		dec $26		                dec tmp1+1
.98de		c6 25		dec $25		+               dec tmp1
.98e0		a5 25		lda $25		                lda tmp1
.98e2		05 26		ora $26		                ora tmp1+1
.98e4		d0 e5		bne $98cb	                bne _skip_loop          ; fall through if empty line
.98e6						_empty_line:
.98e6		ca		dex		                dex
.98e7		ca		dex		                dex
.98e8		ca		dex		                dex
.98e9		ca		dex		                dex
.98ea		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.98ec		74 01		stz $01,x	                stz 1,x
.98ee		4c 9d 99	jmp $999d	                jmp z_parse_name        ; skip over PARSE
.98f1						_char_found:
.98f1		a5 27		lda $27		                lda tmp2
.98f3		38		sec		                sec
.98f4		e5 0c		sbc $0c		                sbc cib
.98f6		85 10		sta $10		                sta toin
.98f8		a5 28		lda $28		                lda tmp2+1
.98fa		e5 0d		sbc $0d		                sbc cib+1
.98fc		85 11		sta $11		                sta toin+1
.98fe		ca		dex		                dex
.98ff		ca		dex		                dex
.9900		a9 20		lda #$20	                lda #AscSP
.9902		95 00		sta $00,x	                sta 0,x
.9904		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.9906						xt_parse:
.9906		20 73 d8	jsr $d873	                jsr underflow_1
.9909		a5 0e		lda $0e		                lda ciblen
.990b		05 0f		ora $0f		                ora ciblen+1
.990d		f0 0c		beq $991b	                beq _abort_parse
.990f		a5 11		lda $11		                lda toin+1              ; MSB
.9911		c5 0f		cmp $0f		                cmp ciblen+1
.9913		90 0e		bcc $9923	                bcc _go_parse           ; unsigned comparison
.9915		a5 10		lda $10		                lda toin                ; LSB
.9917		c5 0e		cmp $0e		                cmp ciblen
.9919		90 08		bcc $9923	                bcc _go_parse
.991b						_abort_parse:
.991b		ca		dex		                dex
.991c		ca		dex		                dex
.991d		74 00		stz $00,x	                stz 0,x
.991f		74 01		stz $01,x	                stz 1,x
.9921		80 7a		bra $999d	                bra _done
.9923						_go_parse:
.9923		b5 00		lda $00,x	                lda 0,x
.9925		85 23		sta $23		                sta tmptos
.9927		ca		dex		                dex
.9928		ca		dex		                dex
.9929		a5 0c		lda $0c		                lda cib
.992b		18		clc		                clc
.992c		65 10		adc $10		                adc toin        ; LSB
.992e		85 25		sta $25		                sta tmp1
.9930		85 27		sta $27		                sta tmp2
.9932		95 02		sta $02,x	                sta 2,x
.9934		a5 0d		lda $0d		                lda cib+1
.9936		65 11		adc $11		                adc toin+1      ; MSB
.9938		85 26		sta $26		                sta tmp1+1
.993a		85 28		sta $28		                sta tmp2+1
.993c		95 03		sta $03,x	                sta 3,x
.993e		a5 0c		lda $0c		                lda cib
.9940		18		clc		                clc
.9941		65 0e		adc $0e		                adc ciblen
.9943		85 29		sta $29		                sta tmp3
.9945		a5 0d		lda $0d		                lda cib+1
.9947		65 0f		adc $0f		                adc ciblen+1
.9949		85 2a		sta $2a		                sta tmp3+1
.994b		64 24		stz $24		                stz tmptos+1
.994d						_loop:
.994d		a5 27		lda $27		                lda tmp2
.994f		c5 29		cmp $29		                cmp tmp3
.9951		d0 06		bne $9959	                bne _not_empty
.9953		a5 28		lda $28		                lda tmp2+1
.9955		c5 2a		cmp $2a		                cmp tmp3+1
.9957		f0 1d		beq $9976	                beq _eol
.9959						_not_empty:
.9959		b2 27		lda ($27)	                lda (tmp2)
.995b		a4 23		ldy $23		                ldy tmptos
.995d		c0 20		cpy #$20	                cpy #AscSP
.995f		d0 07		bne $9968	                bne _not_whitespace
.9961		20 66 d8	jsr $d866	                jsr is_whitespace
.9964		90 02		bcc $9968	                bcc _not_whitespace
.9966		80 0c		bra $9974	                bra _found_delimiter
.9968						_not_whitespace:
.9968		c5 23		cmp $23		                cmp tmptos
.996a		f0 08		beq $9974	                beq _found_delimiter
.996c		e6 27		inc $27		                inc tmp2
.996e		d0 dd		bne $994d	                bne _loop
.9970		e6 28		inc $28		                inc tmp2+1
.9972		80 d9		bra $994d	                bra _loop
.9974						_found_delimiter:
.9974		e6 24		inc $24		                inc tmptos+1
.9976						_eol:
.9976		a5 27		lda $27		                lda tmp2
.9978		38		sec		                sec
.9979		e5 25		sbc $25		                sbc tmp1
.997b		95 00		sta $00,x	                sta 0,x
.997d		a5 28		lda $28		                lda tmp2+1
.997f		e5 26		sbc $26		                sbc tmp1+1
.9981		95 01		sta $01,x	                sta 1,x
.9983		a5 27		lda $27		                lda tmp2
.9985		38		sec		                sec
.9986		e5 0c		sbc $0c		                sbc cib
.9988		85 10		sta $10		                sta toin
.998a		a5 28		lda $28		                lda tmp2+1
.998c		e5 0d		sbc $0d		                sbc cib+1
.998e		85 11		sta $11		                sta toin+1
.9990		a5 10		lda $10		                lda toin
.9992		18		clc		                clc
.9993		65 24		adc $24		                adc tmptos+1
.9995		85 10		sta $10		                sta toin
.9997		a5 11		lda $11		                lda toin+1
.9999		69 00		adc #$00	                adc #0          ; we only need the carry
.999b		85 11		sta $11		                sta toin+1
.999d						_done:
.999d						z_parse_name:
.999d		60		rts		z_parse:        rts
.999e						xt_pick:
.999e		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99a0		8a		txa		                txa
.99a1		75 00		adc $00,x	                adc 0,x
.99a3		a8		tay		                tay
.99a4		b9 02 00	lda $0002,y	                lda 0002,y
.99a7		95 00		sta $00,x	                sta 0,x
.99a9		b9 03 00	lda $0003,y	                lda 0003,y
.99ac		95 01		sta $01,x	                sta 1,x
.99ae		60		rts		z_pick:         rts
.99af						xt_plus:
.99af		20 78 d8	jsr $d878	                jsr underflow_2
.99b2		18		clc		                clc
.99b3		b5 00		lda $00,x	                lda 0,x         ; LSB
.99b5		75 02		adc $02,x	                adc 2,x
.99b7		95 02		sta $02,x	                sta 2,x
.99b9		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99bb		75 03		adc $03,x	                adc 3,x
.99bd		95 03		sta $03,x	                sta 3,x
.99bf		e8		inx		                inx
.99c0		e8		inx		                inx
.99c1		60		rts		z_plus:         rts
.99c2						xt_plus_store:
.99c2		20 78 d8	jsr $d878	                jsr underflow_2
.99c5		b5 00		lda $00,x	                lda 0,x
.99c7		85 25		sta $25		                sta tmp1
.99c9		b5 01		lda $01,x	                lda 1,x
.99cb		85 26		sta $26		                sta tmp1+1
.99cd		a0 00		ldy #$00	                ldy #0          ; LSB
.99cf		b1 25		lda ($25),y	                lda (tmp1),y
.99d1		18		clc		                clc
.99d2		75 02		adc $02,x	                adc 2,x
.99d4		91 25		sta ($25),y	                sta (tmp1),y
.99d6		c8		iny		                iny             ; MSB
.99d7		b1 25		lda ($25),y	                lda (tmp1),y
.99d9		75 03		adc $03,x	                adc 3,x
.99db		91 25		sta ($25),y	                sta (tmp1),y
.99dd		e8		inx		                inx
.99de		e8		inx		                inx
.99df		e8		inx		                inx
.99e0		e8		inx		                inx
.99e1		60		rts		z_plus_store:   rts
.99e2						xt_postpone:
.99e2		20 ab 98	jsr $98ab	                jsr xt_parse_name               ; ( -- addr n )
.99e5		b5 00		lda $00,x	                lda 0,x
.99e7		15 01		ora $01,x	                ora 1,x
.99e9		d0 05		bne $99f0	                bne +
.99eb		a9 05		lda #$05	                lda #err_noname
.99ed		4c 89 d8	jmp $d889	                jmp error
.99f0						+
.99f0		20 8d 8f	jsr $8f8d	                jsr xt_find_name                ; ( -- nt | 0 )
.99f3		d0 05		bne $99fa	                bne +
.99f5		a9 05		lda #$05	                lda #err_noname
.99f7		4c 89 d8	jmp $d889	                jmp error
.99fa						+
.99fa		b5 00		lda $00,x	                lda 0,x
.99fc		85 25		sta $25		                sta tmp1
.99fe		b5 01		lda $01,x	                lda 1,x
.9a00		85 26		sta $26		                sta tmp1+1
.9a02		20 b6 95	jsr $95b6	                jsr xt_name_to_int              ; ( nt -- xt )
.9a05		e6 25		inc $25		                inc tmp1
.9a07		d0 02		bne $9a0b	                bne +
.9a09		e6 26		inc $26		                inc tmp1+1
.9a0b						+
.9a0b		b2 25		lda ($25)	                lda (tmp1)
.9a0d		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a0f		f0 05		beq $9a16	                beq _not_immediate
.9a11		20 70 87	jsr $8770	                jsr xt_compile_comma
.9a14		80 0a		bra $9a20	                bra _done
.9a16						_not_immediate:
.9a16		20 4e 93	jsr $934e	                jsr xt_literal
.9a19		a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a1b		a9 70		lda #$70	                lda #<xt_compile_comma
.9a1d		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.9a20						_done:
.9a20		60		rts		z_postpone:     rts
.9a21						xt_previous:
.9a21		20 e6 90	jsr $90e6	                jsr xt_get_order
.9a24		20 11 96	jsr $9611	                jsr xt_nip
.9a27		20 dd 97	jsr $97dd	                jsr xt_one_minus
.9a2a		20 e0 9c	jsr $9ce0	                jsr xt_set_order
.9a2d		60		rts		z_previous:     rts
.9a2e						xt_question:
.9a2e		20 32 8f	jsr $8f32	                jsr xt_fetch
.9a31		20 b6 8b	jsr $8bb6	                jsr xt_dot
.9a34		60		rts		z_question:     rts
.9a35						xt_question_dup:
.9a35		20 73 d8	jsr $d873	                jsr underflow_1
.9a38		b5 00		lda $00,x	                lda 0,x
.9a3a		15 01		ora $01,x	                ora 1,x
.9a3c		f0 0a		beq $9a48	                beq _done
.9a3e		ca		dex		                dex
.9a3f		ca		dex		                dex
.9a40		b5 02		lda $02,x	                lda 2,x
.9a42		95 00		sta $00,x	                sta 0,x
.9a44		b5 03		lda $03,x	                lda 3,x
.9a46		95 01		sta $01,x	                sta 1,x
.9a48						_done:
.9a48		60		rts		z_question_dup: rts
.9a49						xt_r_fetch:
.9a49		7a		ply		                ply             ; LSB
.9a4a		84 25		sty $25		                sty tmp1
.9a4c		7a		ply		                ply             ; MSB
.9a4d		ca		dex		                dex
.9a4e		ca		dex		                dex
.9a4f		68		pla		                pla             ; LSB
.9a50		95 00		sta $00,x	                sta 0,x
.9a52		68		pla		                pla             ; MSB
.9a53		95 01		sta $01,x	                sta 1,x
.9a55		48		pha		                pha
.9a56		b5 00		lda $00,x	                lda 0,x
.9a58		48		pha		                pha
.9a59		5a		phy		                phy             ; MSB
.9a5a		a4 25		ldy $25		                ldy tmp1
.9a5c		5a		phy		                phy             ; LSB
.9a5d		60		rts		z_r_fetch:      rts
.9a5e						xt_r_from:
.9a5e		68		pla		                pla             ; LSB
.9a5f		85 23		sta $23		                sta tmptos
.9a61		7a		ply		                ply             ; MSB
.9a62		ca		dex		                dex
.9a63		ca		dex		                dex
.9a64		68		pla		                pla             ; LSB
.9a65		95 00		sta $00,x	                sta 0,x
.9a67		68		pla		                pla             ; MSB
.9a68		95 01		sta $01,x	                sta 1,x
.9a6a		5a		phy		                phy             ; MSB
.9a6b		a5 23		lda $23		                lda tmptos
.9a6d		48		pha		                pha             ; LSB
.9a6e		60		rts		z_r_from:       rts
.9a6f						xt_r_to_input:
.9a6f		68		pla		                pla
.9a70		85 25		sta $25		                sta tmp1
.9a72		68		pla		                pla
.9a73		85 26		sta $26		                sta tmp1+1
.9a75		a0 00		ldy #$00	                ldy #0
.9a77						_loop:
.9a77		68		pla		                pla
.9a78		99 0a 00	sta $000a,y	                sta insrc,y
.9a7b		c8		iny		                iny
.9a7c		c0 08		cpy #$08	                cpy #8
.9a7e		d0 f7		bne $9a77	                bne _loop
.9a80		a5 26		lda $26		                lda tmp1+1
.9a82		48		pha		                pha
.9a83		a5 25		lda $25		                lda tmp1
.9a85		48		pha		                pha
.9a86		60		rts		z_r_to_input: 	rts
.9a87						xt_recurse:
.9a87		a0 00		ldy #$00	                ldy #0
.9a89		a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9a8b		91 00		sta ($00),y	                sta (cp),y
.9a8d		c8		iny		                iny
.9a8e		24 1c		bit $1c		                bit status
.9a90		70 0c		bvs $9a9e	                bvs _nt_in_workword
.9a92		a5 06		lda $06		                lda workword
.9a94		91 00		sta ($00),y	                sta (cp),y
.9a96		c8		iny		                iny
.9a97		a5 07		lda $07		                lda workword+1
.9a99		91 00		sta ($00),y	                sta (cp),y
.9a9b		c8		iny		                iny
.9a9c		80 1b		bra $9ab9	                bra _update_cp
.9a9e						_nt_in_workword:
.9a9e		a5 06		lda $06		                lda workword            ; LSB
.9aa0		18		clc		                clc
.9aa1		69 04		adc #$04	                adc #4
.9aa3		85 25		sta $25		                sta tmp1
.9aa5		a5 07		lda $07		                lda workword+1          ; MSB
.9aa7		69 00		adc #$00	                adc #0
.9aa9		85 26		sta $26		                sta tmp1+1
.9aab		b2 25		lda ($25)	                lda (tmp1)
.9aad		91 00		sta ($00),y	                sta (cp),y
.9aaf		5a		phy		                phy
.9ab0		a0 01		ldy #$01	                ldy #1
.9ab2		b1 25		lda ($25),y	                lda (tmp1),y
.9ab4		7a		ply		                ply
.9ab5		c8		iny		                iny
.9ab6		91 00		sta ($00),y	                sta (cp),y
.9ab8		c8		iny		                iny
.9ab9						_update_cp:
.9ab9		98		tya		                tya
.9aba		18		clc		                clc
.9abb		65 00		adc $00		                adc cp
.9abd		85 00		sta $00		                sta cp
.9abf		90 02		bcc $9ac3	                bcc _done
.9ac1		e6 01		inc $01		                inc cp+1
.9ac3						_done:
.9ac3		60		rts		z_recurse:      rts
.9ac4						xt_refill:
.9ac4		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.9ac6		d0 2d		bne $9af5	                bne _src_not_kbd
.9ac8		ca		dex		                dex
.9ac9		ca		dex		                dex
.9aca		ca		dex		                dex
.9acb		ca		dex		                dex
.9acc		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.9ace		95 02		sta $02,x	                sta 2,x
.9ad0		a5 0d		lda $0d		                lda cib+1
.9ad2		95 03		sta $03,x	                sta 3,x
.9ad4		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.9ad6		64 0f		stz $0f		                stz ciblen+1
.9ad8		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9ada		95 00		sta $00,x	                sta 0,x
.9adc		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9ade		20 e6 80	jsr $80e6	                jsr xt_accept           ; ( addr n1 -- n2)
.9ae1		b5 00		lda $00,x	                lda 0,x
.9ae3		85 0e		sta $0e		                sta ciblen
.9ae5		b5 01		lda $01,x	                lda 1,x
.9ae7		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.9ae9		64 10		stz $10		                stz toin
.9aeb		64 11		stz $11		                stz toin+1
.9aed		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9aef		95 00		sta $00,x	                sta 0,x
.9af1		95 01		sta $01,x	                sta 1,x
.9af3		80 10		bra $9b05	                bra _done
.9af5						_src_not_kbd:
.9af5		1a		inc a		                ina
.9af6		d0 08		bne $9b00	                bne _src_not_string
.9af8		ca		dex		                dex
.9af9		ca		dex		                dex
.9afa		74 00		stz $00,x	                stz 0,x
.9afc		74 01		stz $01,x	                stz 1,x
.9afe		80 05		bra $9b05	                bra z_refill
.9b00						_src_not_string:
.9b00		a9 01		lda #$01	                lda #err_badsource
.9b02		4c 89 d8	jmp $d889	                jmp error
.9b05						_done:
.9b05		60		rts		z_refill:       rts
.9b06						xt_repeat:
.9b06		20 21 82	jsr $8221	                jsr xt_again
.9b09		4c 52 8d	jmp $8d52	                jmp xt_then
.9b0c						z_repeat:
.9b0c						xt_right_bracket:
.9b0c		a9 ff		lda #$ff	                lda #$FF
.9b0e		85 1a		sta $1a		                sta state
.9b10		85 1b		sta $1b		                sta state+1
.9b12						z_right_bracket:
.9b12		60		rts		                rts
.9b13						xt_root_wordlist:
.9b13		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b14		ca		dex		                dex
.9b15		a9 03		lda #$03	                lda #3
.9b17		95 00		sta $00,x	                sta 0,x
.9b19		74 01		stz $01,x	                stz 1,x
.9b1b						z_root_wordlist:
.9b1b		60		rts		                rts
.9b1c						xt_rot:
.9b1c		20 7d d8	jsr $d87d	                jsr underflow_3
.9b1f		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b21		b5 03		lda $03,x	                lda 3,x
.9b23		95 05		sta $05,x	                sta 5,x
.9b25		b5 01		lda $01,x	                lda 1,x
.9b27		95 03		sta $03,x	                sta 3,x
.9b29		94 01		sty $01,x	                sty 1,x
.9b2b		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b2d		b5 02		lda $02,x	                lda 2,x
.9b2f		95 04		sta $04,x	                sta 4,x
.9b31		b5 00		lda $00,x	                lda 0,x
.9b33		95 02		sta $02,x	                sta 2,x
.9b35		94 00		sty $00,x	                sty 0,x
.9b37		60		rts		z_rot:          rts
.9b38						xt_rshift:
.9b38		20 78 d8	jsr $d878	                jsr underflow_2
.9b3b		b5 00		lda $00,x	                lda 0,x
.9b3d		29 0f		and #$0f	                and #%00001111
.9b3f		f0 08		beq $9b49	                beq _done               ; if 0 shifts, quit
.9b41		a8		tay		                tay
.9b42						_loop:
.9b42		56 03		lsr $03,x	                lsr 3,x
.9b44		76 02		ror $02,x	                ror 2,x
.9b46		88		dey		                dey
.9b47		d0 f9		bne $9b42	                bne _loop
.9b49						_done:
.9b49		e8		inx		                inx
.9b4a		e8		inx		                inx
.9b4b		60		rts		z_rshift:       rts
.9b4c						xt_s_backslash_quote:
.9b4c		a9 ff		lda #$ff	                lda #$FF
.9b4e		85 27		sta $27		                sta tmp2
.9b50		64 28		stz $28		                stz tmp2+1
.9b52		20 18 9d	jsr $9d18	                jsr s_quote_start
.9b55						_done:
.9b55						z_s_backslash_quote:
.9b55		60		rts		                rts
.9b56						convert_hex_value:
.9b56		c9 41		cmp #$41	        cmp #'A'
.9b58		90 07		bcc $9b61	        bcc _digit
.9b5a		29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b5c		38		sec		        sec
.9b5d		e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b5f		80 03		bra $9b64	        bra _done
.9b61						_digit:
.9b61		38		sec		        sec
.9b62		e9 30		sbc #$30	        sbc #'0'
.9b64						_done:
.9b64		60		rts		        rts
.9b65						xt_search_wordlist:
.9b65		20 7d d8	jsr $d87d	                jsr underflow_3
.9b68		a5 08		lda $08		                lda up
.9b6a		18		clc		                clc
.9b6b		69 0a		adc #$0a	                adc #wordlists_offset
.9b6d		85 27		sta $27		                sta tmp2
.9b6f		a5 09		lda $09		                lda up+1
.9b71		69 00		adc #$00	                adc #0          ; Adding carry
.9b73		85 28		sta $28		                sta tmp2+1
.9b75		b5 00		lda $00,x	                lda 0,x
.9b77		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9b78		65 27		adc $27		                adc tmp2
.9b7a		85 27		sta $27		                sta tmp2
.9b7c		90 02		bcc $9b80	                bcc +
.9b7e		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.9b80						+
.9b80		e8		inx		                inx
.9b81		e8		inx		                inx
.9b82		b5 00		lda $00,x	                lda 0,x
.9b84		15 01		ora $01,x	                ora 1,x
.9b86		d0 03		bne $9b8b	                bne _check_wordlist
.9b88		4c 43 9c	jmp $9c43	                jmp _done
.9b8b						_check_wordlist:
.9b8b		a5 27		lda $27		                lda tmp2
.9b8d		05 28		ora $28		                ora tmp2+1
.9b8f		d0 03		bne $9b94	                bne _have_string
.9b91		4c 43 9c	jmp $9c43	                jmp _done
.9b94						_have_string:
.9b94		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.9b96		85 25		sta $25		                sta tmp1
.9b98		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.9b9a		d0 02		bne $9b9e	                bne +
.9b9c		e6 28		inc $28		                inc tmp2+1
.9b9e						+
.9b9e		b2 27		lda ($27)	                lda (tmp2)
.9ba0		85 26		sta $26		                sta tmp1+1
.9ba2		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9ba4		85 27		sta $27		                sta tmp2
.9ba6		b5 03		lda $03,x	                lda 3,x
.9ba8		85 28		sta $28		                sta tmp2+1
.9baa						_loop:
.9baa		b2 25		lda ($25)	                lda (tmp1)
.9bac		d5 00		cmp $00,x	                cmp 0,x
.9bae		d0 7b		bne $9c2b	                bne _next_entry
.9bb0						_compare_string:
.9bb0		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.9bb2		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bb4		b0 07		bcs $9bbd	                bcs _compare_first
.9bb6		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bb8		90 03		bcc $9bbd	                bcc _compare_first
.9bba		18		clc		                clc
.9bbb		69 20		adc #$20	                adc #$20
.9bbd						_compare_first:
.9bbd		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9bbf		d1 25		cmp ($25),y	                cmp (tmp1),y    ; first character of current word
.9bc1		d0 68		bne $9c2b	                bne _next_entry
.9bc3		b5 00		lda $00,x	                lda 0,x
.9bc5		3a		dec a		                dea
.9bc6		f0 2c		beq $9bf4	                beq _success
.9bc8		a5 25		lda $25		                lda tmp1
.9bca		48		pha		                pha             ; Preserve tmp1 on the return stack.
.9bcb		18		clc		                clc
.9bcc		69 08		adc #$08	                adc #8
.9bce		85 25		sta $25		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9bd0		a5 26		lda $26		                lda tmp1+1
.9bd2		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9bd3		69 00		adc #$00	                adc #0          ; we only need the carry
.9bd5		85 26		sta $26		                sta tmp1+1
.9bd7		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9bd9		88		dey		                dey
.9bda						_string_loop:
.9bda		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.9bdc		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9bde		b0 07		bcs $9be7	                bcs _check_char
.9be0		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9be2		90 03		bcc $9be7	                bcc _check_char
.9be4		18		clc		                clc
.9be5		69 20		adc #$20	                adc #$20
.9be7						_check_char:
.9be7		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.9be9		d0 3a		bne $9c25	                bne _next_entry_tmp1
.9beb		88		dey		                dey
.9bec		d0 ec		bne $9bda	                bne _string_loop
.9bee						_success_tmp1:
.9bee		68		pla		                pla             ; Restore tmp1 from the return stack.
.9bef		85 26		sta $26		                sta tmp1+1
.9bf1		68		pla		                pla
.9bf2		85 25		sta $25		                sta tmp1
.9bf4						_success:
.9bf4		e8		inx		                inx
.9bf5		e8		inx		                inx
.9bf6		a5 25		lda $25		                lda tmp1
.9bf8		95 00		sta $00,x	                sta 0,x
.9bfa		a5 26		lda $26		                lda tmp1+1
.9bfc		95 01		sta $01,x	                sta 1,x
.9bfe		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( nt nt )
.9c01		20 b6 95	jsr $95b6	                jsr xt_name_to_int      ; ( nt xt )
.9c04		20 33 a1	jsr $a133	                jsr xt_swap             ; ( xt nt )
.9c07		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c09		f6 00		inc $00,x	                inc 0,x
.9c0b		d0 02		bne $9c0f	                bne +
.9c0d		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c0f						+
.9c0f		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c11		29 04		and #$04	                and #IM
.9c13		d0 08		bne $9c1d	                bne _immediate          ; bit set, we're immediate
.9c15		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c17		95 00		sta $00,x	                sta 0,x
.9c19		95 01		sta $01,x	                sta 1,x
.9c1b		80 28		bra $9c45	                bra _done_nodrop
.9c1d						_immediate:
.9c1d		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c1f		95 00		sta $00,x	                sta 0,x
.9c21		74 01		stz $01,x	                stz 1,x
.9c23		80 20		bra $9c45	                bra _done_nodrop
.9c25						_next_entry_tmp1:
.9c25		68		pla		                pla             ; Restore tmp1 from the return stack.
.9c26		85 26		sta $26		                sta tmp1+1
.9c28		68		pla		                pla
.9c29		85 25		sta $25		                sta tmp1
.9c2b						_next_entry:
.9c2b		a0 02		ldy #$02	                ldy #2
.9c2d		b1 25		lda ($25),y	                lda (tmp1),y
.9c2f		48		pha		                pha
.9c30		c8		iny		                iny
.9c31		b1 25		lda ($25),y	                lda (tmp1),y
.9c33		85 26		sta $26		                sta tmp1+1
.9c35		68		pla		                pla
.9c36		85 25		sta $25		                sta tmp1
.9c38		05 26		ora $26		                ora tmp1+1
.9c3a		f0 03		beq $9c3f	                beq _fail_done
.9c3c		4c aa 9b	jmp $9baa	                jmp _loop
.9c3f						_fail_done:
.9c3f		74 02		stz $02,x	                stz 2,x         ; failure flag
.9c41		74 03		stz $03,x	                stz 3,x
.9c43						_done:
.9c43		e8		inx		                inx
.9c44		e8		inx		                inx
.9c45						_done_nodrop:
.9c45						z_search_wordlist:
.9c45		60		rts		                rts
.9c46						xt_see:
.9c46		20 ab 98	jsr $98ab	                jsr xt_parse_name       ; ( addr u )
.9c49		20 8d 8f	jsr $8f8d	                jsr xt_find_name        ; ( nt | 0 )
.9c4c		b5 00		lda $00,x	                lda 0,x
.9c4e		15 01		ora $01,x	                ora 1,x
.9c50		d0 05		bne $9c57	                bne +
.9c52		a9 05		lda #$05	                lda #err_noname
.9c54		4c 89 d8	jmp $d889	                jmp error
.9c57						+
.9c57		20 fb 88	jsr $88fb	                jsr xt_cr
.9c5a		a5 18		lda $18		                lda base
.9c5c		48		pha		                pha
.9c5d		20 2f 91	jsr $912f	                jsr xt_hex
.9c60		a9 09		lda #$09	                lda #str_see_nt
.9c62		20 af d8	jsr $d8af	                jsr print_string_no_lf
.9c65		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( nt nt )
.9c68		20 a9 a4	jsr $a4a9	                jsr xt_u_dot
.9c6b		20 a9 a0	jsr $a0a9	                jsr xt_space            ; ( nt )
.9c6e		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( nt nt )
.9c71		20 b6 95	jsr $95b6	                jsr xt_name_to_int      ; ( nt xt )
.9c74		a9 0a		lda #$0a	                lda #str_see_xt
.9c76		20 af d8	jsr $d8af	                jsr print_string_no_lf
.9c79		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( nt xt xt )
.9c7c		20 a9 a4	jsr $a4a9	                jsr xt_u_dot
.9c7f		20 fb 88	jsr $88fb	                jsr xt_cr               ; ( nt xt )
.9c82		a9 08		lda #$08	                lda #str_see_flags
.9c84		20 af d8	jsr $d8af	                jsr print_string_no_lf
.9c87		20 5f 98	jsr $985f	                jsr xt_over             ; ( nt xt nt )
.9c8a		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9c8d		20 32 8f	jsr $8f32	                jsr xt_fetch            ; ( nt xt flags )
.9c90		b5 00		lda $00,x	                lda 0,x
.9c92		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9c94						_flag_loop:
.9c94		48		pha		                pha
.9c95		29 01		and #$01	                and #%00000001
.9c97		18		clc		                clc
.9c98		69 30		adc #$30	                adc #$30                ; ASCII "0"
.9c9a		20 a8 8d	jsr $8da8	                jsr emit_a
.9c9d		20 a9 a0	jsr $a0a9	                jsr xt_space
.9ca0		68		pla		                pla
.9ca1		6a		ror a		                ror                     ; Next flag
.9ca2		88		dey		                dey
.9ca3		d0 ef		bne $9c94	                bne _flag_loop
.9ca5		20 fb 88	jsr $88fb	                jsr xt_cr
.9ca8		e8		inx		                inx
.9ca9		e8		inx		                inx                     ; ( nt xt )
.9caa		a9 0b		lda #$0b	                lda #str_see_size
.9cac		20 af d8	jsr $d8af	                jsr print_string_no_lf
.9caf		20 33 a1	jsr $a133	                jsr xt_swap             ; ( xt nt )
.9cb2		20 03 a7	jsr $a703	                jsr xt_wordsize         ; ( xt u )
.9cb5		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cb8		20 3d 8a	jsr $8a3d	                jsr xt_decimal
.9cbb		20 a9 a4	jsr $a4a9	                jsr xt_u_dot            ; ( xt u )
.9cbe		20 2f 91	jsr $912f	                jsr xt_hex
.9cc1		20 fb 88	jsr $88fb	                jsr xt_cr
.9cc4		20 33 a3	jsr $a333	                jsr xt_two_dup          ; ( xt u xt u )
.9cc7		20 b4 8c	jsr $8cb4	                jsr xt_dump
.9cca		20 fb 88	jsr $88fb	                jsr xt_cr
.9ccd		20 d2 8a	jsr $8ad2	                jsr xt_disasm
.9cd0		68		pla		                pla
.9cd1		85 18		sta $18		                sta base
.9cd3		60		rts		z_see:          rts
.9cd4						xt_set_current:
.9cd4		20 73 d8	jsr $d873	                jsr underflow_1
.9cd7		a0 08		ldy #$08	                ldy #current_offset
.9cd9		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9cdb		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.9cdd		e8		inx		                inx
.9cde		e8		inx		                inx
.9cdf		60		rts		z_set_current:  rts
.9ce0						xt_set_order:
.9ce0		a9 ff		lda #$ff	                lda #$FF
.9ce2		d5 01		cmp $01,x	                cmp 1,x
.9ce4		d0 12		bne $9cf8	                bne _start
.9ce6		d5 00		cmp $00,x	                cmp 0,x
.9ce8		d0 0e		bne $9cf8	                bne _start
.9cea		ca		dex		                dex             ; Make room for the count.
.9ceb		ca		dex		                dex
.9cec		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9cee		a9 03		lda #$03	                lda #3
.9cf0		95 02		sta $02,x	                sta 2,x
.9cf2		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9cf4		a9 01		lda #$01	                lda #1
.9cf6		95 00		sta $00,x	                sta 0,x
.9cf8						_start:
.9cf8		a0 22		ldy #$22	                ldy #num_order_offset
.9cfa		b5 00		lda $00,x	                lda 0,x
.9cfc		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.9cfe		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.9d00		e8		inx		                inx             ; Drop the count off the data stack.
.9d01		e8		inx		                inx
.9d02		a5 25		lda $25		                lda tmp1
.9d04		f0 0d		beq $9d13	                beq _done       ; If zero, there are no wordlists.
.9d06		a0 23		ldy #$23	                ldy #search_order_offset
.9d08						_loop:
.9d08		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d0a		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.9d0c		c8		iny		                iny
.9d0d		e8		inx		                inx
.9d0e		e8		inx		                inx
.9d0f		c6 25		dec $25		                dec tmp1
.9d11		d0 f5		bne $9d08	                bne _loop
.9d13						_done:
.9d13		60		rts		z_set_order:    rts
.9d14						xt_s_quote:
.9d14		64 27		stz $27		                stz tmp2
.9d16		64 28		stz $28		                stz tmp2+1
.9d18						s_quote_start:
.9d18		ca		dex		                dex
.9d19		ca		dex		                dex
.9d1a		ca		dex		                dex
.9d1b		ca		dex		                dex
.9d1c		a9 4c		lda #$4c	                lda #$4C
.9d1e		20 1c d7	jsr $d71c	                jsr cmpl_a
.9d21		20 1c d7	jsr $d71c	                jsr cmpl_a
.9d24		20 1c d7	jsr $d71c	                jsr cmpl_a
.9d27		a5 00		lda $00		                lda cp
.9d29		95 02		sta $02,x	                sta 2,x
.9d2b		a5 01		lda $01		                lda cp+1
.9d2d		95 03		sta $03,x	                sta 3,x
.9d2f						_savechars_loop:
.9d2f		a5 11		lda $11		                lda toin+1              ; MSB
.9d31		c5 0f		cmp $0f		                cmp ciblen+1
.9d33		90 2a		bcc $9d5f	                bcc _input_fine         ; unsigned comparison
.9d35		a5 10		lda $10		                lda toin                ; LSB
.9d37		c5 0e		cmp $0e		                cmp ciblen
.9d39		90 24		bcc $9d5f	                bcc _input_fine
.9d3b		a5 27		lda $27		                lda tmp2
.9d3d		48		pha		                pha
.9d3e		a5 28		lda $28		                lda tmp2+1
.9d40		48		pha		                pha
.9d41		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d43		48		pha		                pha
.9d44		20 c4 9a	jsr $9ac4	                jsr xt_refill           ; ( -- f )
.9d47		68		pla		                pla
.9d48		85 29		sta $29		                sta tmp3
.9d4a		68		pla		                pla
.9d4b		85 28		sta $28		                sta tmp2+1
.9d4d		68		pla		                pla
.9d4e		85 27		sta $27		                sta tmp2
.9d50		b5 00		lda $00,x	                lda 0,x
.9d52		15 01		ora $01,x	                ora 1,x
.9d54		d0 05		bne $9d5b	                bne _refill_ok
.9d56		a9 06		lda #$06	                lda #err_refill
.9d58		4c 89 d8	jmp $d889	                jmp error
.9d5b						_refill_ok:
.9d5b		e8		inx		                inx
.9d5c		e8		inx		                inx
.9d5d		80 d0		bra $9d2f	                bra _savechars_loop
.9d5f						_input_fine:
.9d5f		a5 0c		lda $0c		                lda cib
.9d61		18		clc		                clc
.9d62		65 10		adc $10		                adc toin        ; LSB
.9d64		85 25		sta $25		                sta tmp1
.9d66		a5 0d		lda $0d		                lda cib+1
.9d68		65 11		adc $11		                adc toin+1      ; MSB
.9d6a		85 26		sta $26		                sta tmp1+1
.9d6c		b2 25		lda ($25)	                lda (tmp1)
.9d6e		24 27		bit $27		                bit tmp2
.9d70		30 03		bmi $9d75	                bmi _handle_escapes    ; Only checking bit 7
.9d72		4c fe 9d	jmp $9dfe	                jmp _regular_char
.9d75						_handle_escapes:
.9d75		24 28		bit $28		                bit tmp2+1
.9d77		30 03		bmi $9d7c	                bmi _escaped
.9d79		4c f4 9d	jmp $9df4	                jmp _not_escaped
.9d7c						_escaped:
.9d7c		70 3c		bvs $9dba	                bvs _check_esc_chars
.9d7e		a9 01		lda #$01	                lda #1
.9d80		24 28		bit $28		                bit tmp2+1
.9d82		d0 10		bne $9d94	                bne _esc_x_second_digit
.9d84		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.9d86		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.9d88		20 56 9b	jsr $9b56	                jsr convert_hex_value
.9d8b		0a		asl a		                asl
.9d8c		0a		asl a		                asl
.9d8d		0a		asl a		                asl
.9d8e		0a		asl a		                asl
.9d8f		85 29		sta $29		                sta tmp3    ; Save it for later.
.9d91		4c 05 9e	jmp $9e05	                jmp _next_character
.9d94						_esc_x_second_digit:
.9d94		64 28		stz $28		                stz tmp2+1
.9d96		b2 25		lda ($25)	                lda (tmp1)
.9d98		20 56 9b	jsr $9b56	                jsr convert_hex_value
.9d9b		05 29		ora $29		                ora tmp3
.9d9d		4c 02 9e	jmp $9e02	                jmp _save_character
.9da0						_esc_tr_table:
>9da0		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9da1		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9da2		00 00				    .byte   0,0             ; c, d no escape
>9da4		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9da5		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9da6		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9dab		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9dac		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9dad		0a				    .byte   10              ; n behaves like l --> lf
>9dae		00 00				    .byte   0,0             ; o,p
>9db0		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9db1		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9db2		00				    .byte   0               ; s
>9db3		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9db4		00				    .byte   0               ; u
>9db5		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9db6		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9db9		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9dba						_check_esc_chars:
.9dba		64 28		stz $28		                stz tmp2+1
.9dbc		c9 61		cmp #$61	                cmp #'a'
.9dbe		30 1a		bmi $9dda	                bmi _check_esc_quote
.9dc0		c9 7b		cmp #$7b	                cmp #'z'+1
.9dc2		10 16		bpl $9dda	                bpl _check_esc_quote
.9dc4		a8		tay		                tay
.9dc5		b9 3f 9d	lda $9d3f,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9dc8		d0 03		bne $9dcd	                bne _esc_replace
.9dca		98		tya		                tya                     ; revert if no translation
.9dcb		80 0d		bra $9dda	                bra _check_esc_quote
.9dcd		10 33		bpl $9e02	_esc_replace:   bpl _save_character     ; simple replacement
.9dcf		29 7f		and #$7f	                and #$7f                ; clear hi bit
.9dd1		f0 2f		beq $9e02	                beq _save_character     ; NUL we can just output
.9dd3		20 1c d7	jsr $d71c	                jsr cmpl_a              ; else output first char (CR)
.9dd6		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9dd8		80 28		bra $9e02	                bra _save_character
.9dda						_check_esc_quote:
.9dda		c9 22		cmp #$22	                cmp #$22
.9ddc		d0 04		bne $9de2	                bne _check_esc_x
.9dde		a9 22		lda #$22	                lda #34
.9de0		80 20		bra $9e02	                bra _save_character
.9de2						_check_esc_x:
.9de2		c9 78		cmp #$78	                cmp #'x'
.9de4		d0 06		bne $9dec	                bne _check_esc_backslash
.9de6		a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9de8		85 28		sta $28		                sta tmp2+1
.9dea		80 19		bra $9e05	                bra _next_character
.9dec						_check_esc_backslash:
.9dec		c9 5c		cmp #$5c	                cmp #$5C
.9dee		d0 04		bne $9df4	                bne _not_escaped
.9df0		a9 5c		lda #$5c	                lda #92
.9df2		80 0e		bra $9e02	                bra _save_character
.9df4						_not_escaped:
.9df4		c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9df6		d0 06		bne $9dfe	                bne _regular_char
.9df8		a9 ff		lda #$ff	                lda #$FF
.9dfa		85 28		sta $28		                sta tmp2+1
.9dfc		80 07		bra $9e05	                bra _next_character
.9dfe						_regular_char:
.9dfe		c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e00		f0 0c		beq $9e0e	                beq _found_string_end
.9e02						_save_character:
.9e02		20 1c d7	jsr $d71c	                jsr cmpl_a
.9e05						_next_character:
.9e05		e6 10		inc $10		                inc toin
.9e07		d0 02		bne $9e0b	                bne _savechars_loop_longjump
.9e09		e6 11		inc $11		                inc toin+1
.9e0b						_savechars_loop_longjump:
.9e0b		4c 2f 9d	jmp $9d2f	                jmp _savechars_loop
.9e0e						_found_string_end:
.9e0e		e6 10		inc $10		                inc toin
.9e10		d0 02		bne $9e14	                bne +
.9e12		e6 11		inc $11		                inc toin+1
.9e14						+
.9e14		a5 00		lda $00		                lda cp
.9e16		38		sec		                sec
.9e17		f5 02		sbc $02,x	                sbc 2,x
.9e19		95 00		sta $00,x	                sta 0,x         ; LSB
.9e1b		a5 01		lda $01		                lda cp+1
.9e1d		f5 03		sbc $03,x	                sbc 3,x
.9e1f		95 01		sta $01,x	                sta 1,x         ; MSB
.9e21		b5 02		lda $02,x	                lda 2,x
.9e23		38		sec		                sec
.9e24		e9 02		sbc #$02	                sbc #2
.9e26		85 25		sta $25		                sta tmp1
.9e28		b5 03		lda $03,x	                lda 3,x
.9e2a		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e2c		85 26		sta $26		                sta tmp1+1
.9e2e		a5 00		lda $00		                lda cp
.9e30		92 25		sta ($25)	                sta (tmp1)
.9e32		a0 01		ldy #$01	                ldy #1
.9e34		a5 01		lda $01		                lda cp+1
.9e36		91 25		sta ($25),y	                sta (tmp1),y
.9e38		a5 1a		lda $1a		                lda state
.9e3a		05 1b		ora $1b		                ora state+1             ; paranoid
.9e3c		f0 03		beq $9e41	                beq _done
.9e3e		20 1a a0	jsr $a01a	                jsr sliteral_const_str         ; ( addr u -- )
.9e41						_done:
.9e41		60		rts		z_s_quote:      rts
.9e42						xt_s_to_d:
.9e42		20 73 d8	jsr $d873	                jsr underflow_1
.9e45		ca		dex		                dex
.9e46		ca		dex		                dex
.9e47		74 00		stz $00,x	                stz 0,x
.9e49		74 01		stz $01,x	                stz 1,x
.9e4b		b5 03		lda $03,x	                lda 3,x
.9e4d		10 04		bpl $9e53	                bpl _done
.9e4f		d6 00		dec $00,x	                dec 0,x
.9e51		d6 01		dec $01,x	                dec 1,x
.9e53						_done:
.9e53		60		rts		z_s_to_d:       rts
.9e54						xt_save_buffers:
.9e54		a0 30		ldy #$30	                ldy #buffstatus_offset
.9e56		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9e58		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9e5a		d0 12		bne $9e6e	                bne _done       ; Either not used or not dirty = done!
.9e5c		20 62 83	jsr $8362	                jsr xt_blkbuffer
.9e5f		20 3e 85	jsr $853e	                jsr xt_buffblocknum
.9e62		20 32 8f	jsr $8f32	                jsr xt_fetch
.9e65		20 04 85	jsr $8504	                jsr xt_block_write
.9e68		a9 01		lda #$01	                lda #1
.9e6a		a0 30		ldy #$30	                ldy #buffstatus_offset
.9e6c		91 08		sta ($08),y	                sta (up),y
.9e6e						_done:
.9e6e		60		rts		z_save_buffers: rts
.9e6f						xt_scr:
.9e6f		a9 06		lda #$06	                lda #scr_offset
.9e71		4c 79 d7	jmp $d779	                jmp push_upvar_tos
.9e74						z_scr:
.9e74						xt_search:
.9e74		20 82 d8	jsr $d882	                jsr underflow_4
.9e77		b5 00		lda $00,x	                lda 0,x
.9e79		15 01		ora $01,x	                ora 1,x
.9e7b		d0 0b		bne $9e88	                bne _start_search
.9e7d		e8		inx		                inx             ; Remove u2
.9e7e		e8		inx		                inx
.9e7f		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9e81		95 00		sta $00,x	                sta 0,x
.9e83		95 01		sta $01,x	                sta 1,x
.9e85		4c 12 9f	jmp $9f12	                jmp z_search
.9e88						_start_search:
.9e88		20 36 a7	jsr $a736	                jsr xt_zero
.9e8b						_search_loop:
.9e8b		18		clc		                clc
.9e8c		b5 00		lda $00,x	                lda 0,x
.9e8e		75 02		adc $02,x	                adc 2,x
.9e90		85 25		sta $25		                sta tmp1
.9e92		b5 01		lda $01,x	                lda 1,x
.9e94		75 03		adc $03,x	                adc 3,x
.9e96		d5 07		cmp $07,x	                cmp 7,x
.9e98		90 12		bcc $9eac	                bcc _init_comparison ; Obviously less
.9e9a		d0 06		bne $9ea2	                bne _not_found
.9e9c		b5 06		lda $06,x	                lda 6,x
.9e9e		c5 25		cmp $25		                cmp tmp1
.9ea0		b0 0a		bcs $9eac	                bcs _init_comparison
.9ea2						_not_found:
.9ea2		e8		inx		                inx             ; Remove offset
.9ea3		e8		inx		                inx
.9ea4		e8		inx		                inx             ; Remove u2
.9ea5		e8		inx		                inx
.9ea6		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9ea8		74 01		stz $01,x	                stz 1,x
.9eaa		80 66		bra $9f12	                bra z_search
.9eac						_init_comparison:
.9eac		18		clc		                clc
.9ead		b5 08		lda $08,x	                lda 8,x
.9eaf		75 00		adc $00,x	                adc 0,x
.9eb1		85 25		sta $25		                sta tmp1
.9eb3		b5 09		lda $09,x	                lda 9,x
.9eb5		75 01		adc $01,x	                adc 1,x
.9eb7		85 26		sta $26		                sta tmp1+1
.9eb9		b5 04		lda $04,x	                lda 4,x
.9ebb		85 27		sta $27		                sta tmp2
.9ebd		b5 05		lda $05,x	                lda 5,x
.9ebf		85 28		sta $28		                sta tmp2+1
.9ec1		b5 02		lda $02,x	                lda 2,x
.9ec3		85 29		sta $29		                sta tmp3
.9ec5		b5 03		lda $03,x	                lda 3,x
.9ec7		85 2a		sta $2a		                sta tmp3+1
.9ec9						_comparison_loop:
.9ec9		b2 25		lda ($25)	                lda (tmp1)
.9ecb		d2 27		cmp ($27)	                cmp (tmp2)
.9ecd		f0 05		beq $9ed4	                beq _letters_match
.9ecf		20 e9 97	jsr $97e9	                jsr xt_one_plus
.9ed2		80 b7		bra $9e8b	                bra _search_loop
.9ed4						_letters_match:
.9ed4		e6 25		inc $25		                inc tmp1
.9ed6		d0 02		bne $9eda	                bne +
.9ed8		e6 26		inc $26		                inc tmp1+1
.9eda						+
.9eda		e6 27		inc $27		                inc tmp2
.9edc		d0 02		bne $9ee0	                bne +
.9ede		e6 28		inc $28		                inc tmp2+1
.9ee0						+
.9ee0		a5 29		lda $29		                lda tmp3
.9ee2		d0 02		bne $9ee6	                bne +
.9ee4		c6 2a		dec $2a		                dec tmp3+1
.9ee6						+
.9ee6		c6 29		dec $29		                dec tmp3
.9ee8		a5 29		lda $29		                lda tmp3
.9eea		05 2a		ora $2a		                ora tmp3+1
.9eec		d0 db		bne $9ec9	                bne _comparison_loop ; Check the next letter
.9eee		18		clc		                clc
.9eef		b5 00		lda $00,x	                lda 0,x
.9ef1		75 08		adc $08,x	                adc 8,x
.9ef3		95 08		sta $08,x	                sta 8,x
.9ef5		b5 01		lda $01,x	                lda 1,x
.9ef7		75 09		adc $09,x	                adc 9,x
.9ef9		95 09		sta $09,x	                sta 9,x
.9efb		38		sec		                sec
.9efc		b5 06		lda $06,x	                lda 6,x
.9efe		f5 00		sbc $00,x	                sbc 0,x
.9f00		95 06		sta $06,x	                sta 6,x
.9f02		b5 07		lda $07,x	                lda 7,x
.9f04		f5 01		sbc $01,x	                sbc 1,x
.9f06		95 07		sta $07,x	                sta 7,x
.9f08		e8		inx		                inx             ; drop offset
.9f09		e8		inx		                inx
.9f0a		e8		inx		                inx             ; drop u2
.9f0b		e8		inx		                inx
.9f0c		a9 ff		lda #$ff	                lda #$FF
.9f0e		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f10		95 01		sta $01,x	                sta 1,x
.9f12		60		rts		z_search:       rts
.9f13						xt_semicolon:
.9f13		24 1c		bit $1c		                bit status
.9f15		70 11		bvs $9f28	                bvs _colonword
.9f17		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f19		20 1c d7	jsr $d71c	                jsr cmpl_a
.9f1c		ca		dex		                dex
.9f1d		ca		dex		                dex
.9f1e		a5 06		lda $06		                lda workword
.9f20		95 00		sta $00,x	                sta 0,x
.9f22		a5 07		lda $07		                lda workword+1
.9f24		95 01		sta $01,x	                sta 1,x
.9f26		80 45		bra $9f6d	                bra _semicolon_done
.9f28						_colonword:
.9f28		a0 06		ldy #$06	                ldy #6
.9f2a		a5 00		lda $00		                lda cp
.9f2c		91 06		sta ($06),y	                sta (workword),y
.9f2e		c8		iny		                iny
.9f2f		a5 01		lda $01		                lda cp+1
.9f31		91 06		sta ($06),y	                sta (workword),y
.9f33		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f35		20 1c d7	jsr $d71c	                jsr cmpl_a
.9f38		24 1c		bit $1c		                bit status
.9f3a		10 26		bpl $9f62	                bpl _new_word   ; Bit 7 is clear = new word
.9f3c		ca		dex		                dex
.9f3d		ca		dex		                dex
.9f3e		ca		dex		                dex
.9f3f		ca		dex		                dex
.9f40		b2 06		lda ($06)	                lda (workword)
.9f42		95 00		sta $00,x	                sta 0,x
.9f44		74 01		stz $01,x	                stz 1,x
.9f46		a5 06		lda $06		                lda workword
.9f48		18		clc		                clc
.9f49		69 08		adc #$08	                adc #8
.9f4b		95 02		sta $02,x	                sta 2,x
.9f4d		a5 07		lda $07		                lda workword+1
.9f4f		69 00		adc #$00	                adc #0                  ; only want carry
.9f51		95 03		sta $03,x	                sta 3,x
.9f53		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9f55		20 af d8	jsr $d8af	                jsr print_string_no_lf
.9f58		20 7e a4	jsr $a47e	                jsr xt_type
.9f5b		20 a9 a0	jsr $a0a9	                jsr xt_space
.9f5e		a9 80		lda #$80	                lda #%10000000
.9f60		14 1c		trb $1c		                trb status
.9f62						_new_word:
.9f62		a5 06		lda $06		                lda workword
.9f64		85 02		sta $02		                sta dp
.9f66		a5 07		lda $07		                lda workword+1
.9f68		85 03		sta $03		                sta dp+1
.9f6a		20 cd d7	jsr $d7cd	                jsr dp_to_current       ; Save the updated DP to the
.9f6d						_semicolon_done:
.9f6d		64 1a		stz $1a		                stz state
.9f6f		64 1b		stz $1b		                stz state+1
.9f71		60		rts		z_semicolon:    rts
.9f72						xt_sign:
.9f72		20 73 d8	jsr $d873	                jsr underflow_1
.9f75		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9f77		30 04		bmi $9f7d	                bmi _minus
.9f79		e8		inx		                inx
.9f7a		e8		inx		                inx
.9f7b		80 09		bra $9f86	                bra _done
.9f7d						_minus:
.9f7d		a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9f7f		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9f81		74 01		stz $01,x	                stz 1,x         ; paranoid
.9f83		20 89 91	jsr $9189	                jsr xt_hold
.9f86						_done:
.9f86		60		rts		z_sign:         rts
.9f87						xt_slash:
.9f87		a9 00		lda #$00	                lda #0
.9f89		48		pha		                pha
.9f8a		80 03		bra $9f8f	                bra slashmod_common
.9f8c						xt_slash_mod:
.9f8c		a9 ff		lda #$ff	                lda #$FF
.9f8e		48		pha		                pha             ; falls through to _common
.9f8f						slashmod_common:
.9f8f		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >R
.9f92		20 42 9e	jsr $9e42	                jsr xt_s_to_d           ; S>D
.9f95		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; R>
.9f98		20 60 a0	jsr $a060	                jsr xt_sm_slash_rem     ; SM/REM
.9f9b		68		pla		                pla
.9f9c		d0 05		bne $9fa3	                bne _done
.9f9e		20 33 a1	jsr $a133	                jsr xt_swap
.9fa1		e8		inx		                inx             ; DROP
.9fa2		e8		inx		                inx
.9fa3						_done:
.9fa3						z_slash_mod:
.9fa3		60		rts		z_slash:        rts
.9fa4						xt_slash_string:
.9fa4		20 7d d8	jsr $d87d	                jsr underflow_3
.9fa7		18		clc		                clc             ; 3OS+TOS
.9fa8		b5 00		lda $00,x	                lda 0,x
.9faa		75 04		adc $04,x	                adc 4,x
.9fac		95 04		sta $04,x	                sta 4,x
.9fae		b5 01		lda $01,x	                lda 1,x
.9fb0		75 05		adc $05,x	                adc 5,x
.9fb2		95 05		sta $05,x	                sta 5,x
.9fb4		38		sec		                sec             ; NOS-TOS
.9fb5		b5 02		lda $02,x	                lda 2,x
.9fb7		f5 00		sbc $00,x	                sbc 0,x
.9fb9		95 02		sta $02,x	                sta 2,x
.9fbb		b5 03		lda $03,x	                lda 3,x
.9fbd		f5 01		sbc $01,x	                sbc 1,x
.9fbf		95 03		sta $03,x	                sta 3,x
.9fc1		e8		inx		                inx
.9fc2		e8		inx		                inx
.9fc3		60		rts		z_slash_string: rts
.9fc4						xt_sliteral:
.9fc4		20 78 d8	jsr $d878	                jsr underflow_2
.9fc7		a9 4c		lda #$4c	                lda #$4C
.9fc9		20 1c d7	jsr $d71c	                jsr cmpl_a
.9fcc		20 1c d7	jsr $d71c	                jsr cmpl_a
.9fcf		20 1c d7	jsr $d71c	                jsr cmpl_a
.9fd2		8a		txa		                txa
.9fd3		38		sec		                sec
.9fd4		e9 06		sbc #$06	                sbc #6
.9fd6		aa		tax		                tax
.9fd7		b5 08		lda $08,x	                lda 8,x
.9fd9		95 04		sta $04,x	                sta 4,x
.9fdb		b5 09		lda $09,x	                lda 9,x
.9fdd		95 05		sta $05,x	                sta 5,x
.9fdf		b5 06		lda $06,x	                lda 6,x
.9fe1		95 00		sta $00,x	                sta 0,x
.9fe3		b5 07		lda $07,x	                lda 7,x
.9fe5		95 01		sta $01,x	                sta 1,x
.9fe7		a5 00		lda $00		                lda cp
.9fe9		95 08		sta $08,x	                sta 8,x
.9feb		95 02		sta $02,x	                sta 2,x
.9fed		a5 01		lda $01		                lda cp+1
.9fef		95 09		sta $09,x	                sta 9,x
.9ff1		95 03		sta $03,x	                sta 3,x
.9ff3		20 97 95	jsr $9597	                jsr xt_move
.9ff6		18		clc		                clc
.9ff7		a5 00		lda $00		                lda cp
.9ff9		75 00		adc $00,x	                adc 0,x
.9ffb		85 00		sta $00		                sta cp
.9ffd		a5 01		lda $01		                lda cp+1
.9fff		75 01		adc $01,x	                adc 1,x
.a001		85 01		sta $01		                sta cp+1
.a003		b5 02		lda $02,x	                lda 2,x
.a005		38		sec		                sec
.a006		e9 02		sbc #$02	                sbc #2
.a008		85 25		sta $25		                sta tmp1
.a00a		b5 03		lda $03,x	                lda 3,x
.a00c		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a00e		85 26		sta $26		                sta tmp1+1
.a010		a5 00		lda $00		                lda cp
.a012		92 25		sta ($25)	                sta (tmp1)
.a014		a0 01		ldy #$01	                ldy #1
.a016		a5 01		lda $01		                lda cp+1
.a018		91 25		sta ($25),y	                sta (tmp1),y
.a01a						sliteral_const_str:
.a01a		a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a01c		a9 34		lda #$34	                lda #<sliteral_runtime
.a01e		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.a021		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a023		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a025		20 18 d7	jsr $d718	                jsr cmpl_word
.a028		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a02a		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a02c		20 18 d7	jsr $d718	                jsr cmpl_word
.a02f		e8		inx		                inx
.a030		e8		inx		                inx
.a031		e8		inx		                inx
.a032		e8		inx		                inx
.a033		60		rts		z_sliteral:     rts
.a034						sliteral_runtime:
.a034		ca		dex		                dex
.a035		ca		dex		                dex
.a036		ca		dex		                dex
.a037		ca		dex		                dex
.a038		68		pla		                pla
.a039		85 25		sta $25		                sta tmp1        ; LSB of address
.a03b		68		pla		                pla
.a03c		85 26		sta $26		                sta tmp1+1      ; MSB of address
.a03e		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a040		b1 25		lda ($25),y	                lda (tmp1),y
.a042		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a044		c8		iny		                iny
.a045		b1 25		lda ($25),y	                lda (tmp1),y
.a047		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a049		c8		iny		                iny
.a04a		b1 25		lda ($25),y	                lda (tmp1),y
.a04c		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a04e		c8		iny		                iny
.a04f		b1 25		lda ($25),y	                lda (tmp1),y
.a051		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a053		18		clc		                clc
.a054		a5 25		lda $25		                lda tmp1
.a056		69 04		adc #$04	                adc #4
.a058		a8		tay		                tay             ; LSB
.a059		a5 26		lda $26		                lda tmp1+1
.a05b		69 00		adc #$00	                adc #0          ; we only need carry
.a05d		48		pha		                pha             ; MSB
.a05e		5a		phy		                phy
.a05f		60		rts		                rts
.a060						xt_sm_slash_rem:
.a060		20 7d d8	jsr $d87d	                jsr underflow_3 ; contains double number
.a063		b5 03		lda $03,x	                lda 3,x
.a065		48		pha		                pha
.a066		b5 01		lda $01,x	                lda 1,x
.a068		55 03		eor $03,x	                eor 3,x
.a06a		48		pha		                pha
.a06b		20 d1 80	jsr $80d1	                jsr xt_abs
.a06e		e8		inx		                inx             ; pretend we pushed n1 to R
.a06f		e8		inx		                inx
.a070		20 1e 8a	jsr $8a1e	                jsr xt_dabs
.a073		ca		dex		                dex
.a074		ca		dex		                dex
.a075		20 35 a5	jsr $a535	                jsr xt_um_slash_mod     ; UM/MOD
.a078		68		pla		                pla
.a079		10 03		bpl $a07e	                bpl +
.a07b		20 f2 95	jsr $95f2	                jsr xt_negate
.a07e						+
.a07e		68		pla		                pla
.a07f		10 07		bpl $a088	                bpl _done
.a081		e8		inx		                inx             ; pretend we pushed quotient to R
.a082		e8		inx		                inx
.a083		20 f2 95	jsr $95f2	                jsr xt_negate
.a086		ca		dex		                dex
.a087		ca		dex		                dex
.a088						_done:
.a088		60		rts		z_sm_slash_rem: rts
.a089						xt_source:
.a089		ca		dex		                dex
.a08a		ca		dex		                dex
.a08b		a5 0c		lda $0c		                lda cib
.a08d		95 00		sta $00,x	                sta 0,x
.a08f		a5 0d		lda $0d		                lda cib+1
.a091		95 01		sta $01,x	                sta 1,x
.a093		ca		dex		                dex
.a094		ca		dex		                dex
.a095		a5 0e		lda $0e		                lda ciblen
.a097		95 00		sta $00,x	                sta 0,x
.a099		a5 0f		lda $0f		                lda ciblen+1
.a09b		95 01		sta $01,x	                sta 1,x
.a09d		60		rts		z_source:       rts
.a09e						xt_source_id:
.a09e		ca		dex		                dex
.a09f		ca		dex		                dex
.a0a0		a5 0a		lda $0a		                lda insrc
.a0a2		95 00		sta $00,x	                sta 0,x
.a0a4		a5 0b		lda $0b		                lda insrc+1
.a0a6		95 01		sta $01,x	                sta 1,x
.a0a8		60		rts		z_source_id:    rts
.a0a9						xt_space:
.a0a9		a9 20		lda #$20	                lda #AscSP
.a0ab		20 a8 8d	jsr $8da8	                jsr emit_a
.a0ae		60		rts		z_space:        rts
.a0af						xt_spaces:
.a0af		20 73 d8	jsr $d873	                jsr underflow_1
.a0b2		20 36 a7	jsr $a736	                jsr xt_zero
.a0b5		20 ed 94	jsr $94ed	                jsr xt_max
.a0b8		b5 00		lda $00,x	                lda 0,x
.a0ba		15 01		ora $01,x	                ora 1,x
.a0bc		f0 2a		beq $a0e8	                beq _done
.a0be		b4 01		ldy $01,x	                ldy 1,x
.a0c0		d0 0c		bne $a0ce	                bne _lots_of_spaces
.a0c2		b4 00		ldy $00,x	                ldy 0,x
.a0c4						_quick_loop:
.a0c4		a9 20		lda #$20	                lda #AscSP
.a0c6		20 a8 8d	jsr $8da8	                jsr emit_a
.a0c9		88		dey		                dey
.a0ca		f0 1c		beq $a0e8	                beq _done
.a0cc		80 f6		bra $a0c4	                bra _quick_loop
.a0ce						_lots_of_spaces:
.a0ce		b4 00		ldy $00,x	                ldy 0,x
.a0d0						_first_slow_loop:
.a0d0		f0 08		beq $a0da	                beq _slow_outer_loop
.a0d2		a9 20		lda #$20	                lda #AscSP
.a0d4		20 a8 8d	jsr $8da8	                jsr emit_a
.a0d7		88		dey		                dey
.a0d8		80 f6		bra $a0d0	                bra _first_slow_loop
.a0da						_slow_outer_loop:
.a0da		a0 00		ldy #$00	                ldy #00
.a0dc						_slow_inner_loop:
.a0dc		a9 20		lda #$20	                lda #AscSP
.a0de		20 a8 8d	jsr $8da8	                jsr emit_a
.a0e1		88		dey		                dey
.a0e2		d0 f8		bne $a0dc	                bne _slow_inner_loop
.a0e4		d6 01		dec $01,x	                dec 1,x
.a0e6		d0 f2		bne $a0da	                bne _slow_outer_loop
.a0e8						_done:
.a0e8		e8		inx		                inx             ; drop
.a0e9		e8		inx		                inx
.a0ea		60		rts		z_spaces:       rts
.a0eb						xt_star:
.a0eb		20 78 d8	jsr $d878	                jsr underflow_2
.a0ee		20 77 a5	jsr $a577	                jsr xt_um_star
.a0f1		e8		inx		                inx
.a0f2		e8		inx		                inx
.a0f3		60		rts		z_star:         rts
.a0f4						xt_star_slash:
.a0f4		20 fd a0	jsr $a0fd	                jsr xt_star_slash_mod
.a0f7		20 33 a1	jsr $a133	                jsr xt_swap
.a0fa		e8		inx		                inx
.a0fb		e8		inx		                inx
.a0fc						z_star_slash:
.a0fc		60		rts		                rts
.a0fd						xt_star_slash_mod:
.a0fd		20 7d d8	jsr $d87d	                jsr underflow_3
.a100		20 eb a2	jsr $a2eb	                jsr xt_to_r
.a103		20 63 94	jsr $9463	                jsr xt_m_star
.a106		20 5e 9a	jsr $9a5e	                jsr xt_r_from
.a109		20 60 a0	jsr $a060	                jsr xt_sm_slash_rem
.a10c						z_star_slash_mod:
.a10c		60		rts		                rts
.a10d						xt_state:
.a10d		ca		dex		                dex
.a10e		ca		dex		                dex
.a10f		a9 1a		lda #$1a	                lda #<state
.a111		95 00		sta $00,x	                sta 0,x
.a113		a9 00		lda #$00	                lda #>state
.a115		95 01		sta $01,x	                sta 1,x
.a117		60		rts		z_state:        rts
.a118						xt_store:
.a118		20 78 d8	jsr $d878	                jsr underflow_2
.a11b		b5 02		lda $02,x	                lda 2,x         ; LSB
.a11d		81 00		sta ($00,x)	                sta (0,x)
.a11f		f6 00		inc $00,x	                inc 0,x
.a121		d0 02		bne $a125	                bne +
.a123		f6 01		inc $01,x	                inc 1,x
.a125						+
.a125		b5 03		lda $03,x	                lda 3,x         ; MSB
.a127		81 00		sta ($00,x)	                sta (0,x)
.a129		e8		inx		                inx             ; 2DROP
.a12a		e8		inx		                inx
.a12b		e8		inx		                inx
.a12c		e8		inx		                inx
.a12d		60		rts		z_store:        rts
.a12e						xt_strip_underflow:
.a12e		a9 02		lda #$02	                lda #uf_strip_offset
.a130		4c 79 d7	jmp $d779	                jmp push_upvar_tos
.a133						z_strip_underflow:
.a133						xt_swap:
.a133		20 78 d8	jsr $d878	                jsr underflow_2
.a136		b5 00		lda $00,x	                lda 0,x         ; LSB
.a138		b4 02		ldy $02,x	                ldy 2,x
.a13a		95 02		sta $02,x	                sta 2,x
.a13c		94 00		sty $00,x	                sty 0,x
.a13e		b5 01		lda $01,x	                lda 1,x         ; MSB
.a140		b4 03		ldy $03,x	                ldy 3,x
.a142		95 03		sta $03,x	                sta 3,x
.a144		94 01		sty $01,x	                sty 1,x
.a146		60		rts		z_swap:         rts
.a147						xt_thru:
.a147		20 78 d8	jsr $d878	                jsr underflow_2
.a14a		b5 01		lda $01,x	                lda 1,x
.a14c		48		pha		                pha
.a14d		b5 00		lda $00,x	                lda 0,x
.a14f		48		pha		                pha
.a150		e8		inx		                inx
.a151		e8		inx		                inx
.a152						_thru_loop:
.a152		b5 01		lda $01,x	                lda 1,x
.a154		48		pha		                pha
.a155		b5 00		lda $00,x	                lda 0,x
.a157		48		pha		                pha
.a158		20 7b 93	jsr $937b	                jsr xt_load
.a15b		68		pla		                pla
.a15c		85 25		sta $25		                sta tmp1
.a15e		68		pla		                pla
.a15f		85 26		sta $26		                sta tmp1+1
.a161		68		pla		                pla
.a162		85 27		sta $27		                sta tmp2
.a164		68		pla		                pla
.a165		85 28		sta $28		                sta tmp2+1
.a167		c5 26		cmp $26		                cmp tmp1+1
.a169		d0 08		bne $a173	                bne _next_screen
.a16b		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.a16d		c5 25		cmp $25		                cmp tmp1
.a16f		d0 02		bne $a173	                bne _next_screen
.a171		80 18		bra $a18b	                bra _done       ; We just did the last screen.
.a173						_next_screen:
.a173		a5 28		lda $28		                lda tmp2+1
.a175		48		pha		                pha
.a176		a5 27		lda $27		                lda tmp2
.a178		48		pha		                pha
.a179		e6 25		inc $25		                inc tmp1
.a17b		d0 02		bne $a17f	                bne +
.a17d		e6 26		inc $26		                inc tmp1+1
.a17f						+
.a17f		ca		dex		                dex
.a180		ca		dex		                dex
.a181		a5 25		lda $25		                lda tmp1
.a183		95 00		sta $00,x	                sta 0,x
.a185		a5 26		lda $26		                lda tmp1+1
.a187		95 01		sta $01,x	                sta 1,x
.a189		80 c7		bra $a152	                bra _thru_loop
.a18b						_done:
.a18b		60		rts		z_thru:         rts
.a18c						xt_tick:
.a18c		20 ab 98	jsr $98ab	                jsr xt_parse_name       ; ( -- addr u )
.a18f		b5 00		lda $00,x	                lda 0,x
.a191		15 01		ora $01,x	                ora 1,x
.a193		d0 05		bne $a19a	                bne +
.a195		a9 05		lda #$05	                lda #err_noname
.a197		4c 89 d8	jmp $d889	                jmp error
.a19a						+
.a19a		20 8d 8f	jsr $8f8d	                jsr xt_find_name        ; ( addr u -- nt )
.a19d		b5 00		lda $00,x	                lda 0,x
.a19f		15 01		ora $01,x	                ora 1,x
.a1a1		d0 05		bne $a1a8	                bne +
.a1a3		a9 08		lda #$08	                lda #err_syntax
.a1a5		4c 89 d8	jmp $d889	                jmp error
.a1a8						+
.a1a8		20 b6 95	jsr $95b6	                jsr xt_name_to_int      ; ( nt -- xt )
.a1ab		60		rts		z_tick:         rts
.a1ac						xt_to:
.a1ac		20 8c a1	jsr $a18c	                jsr xt_tick             ; ( [n] xt )
.a1af		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a1b1		18		clc		                clc
.a1b2		69 03		adc #$03	                adc #3
.a1b4		85 25		sta $25		                sta tmp1
.a1b6		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a1b8		69 00		adc #$00	                adc #0                  ; we just want the carry
.a1ba		85 26		sta $26		                sta tmp1+1
.a1bc		e8		inx		                inx
.a1bd		e8		inx		                inx                     ; ( [n] )
.a1be		a5 1a		lda $1a		                lda state
.a1c0		05 1b		ora $1b		                ora state+1
.a1c2		f0 34		beq $a1f8	                beq _interpret
.a1c4		a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a1c6		a9 b5		lda #$b5	                lda #$B5
.a1c8		20 18 d7	jsr $d718	                jsr cmpl_word
.a1cb		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a1cd		20 1c d7	jsr $d71c	                jsr cmpl_a
.a1d0		a4 26		ldy $26		                ldy tmp1+1              ; MSB goes in Y
.a1d2		a5 25		lda $25		                lda tmp1
.a1d4		20 18 d7	jsr $d718	                jsr cmpl_word
.a1d7		a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a1d9		a9 b5		lda #$b5	                lda #$B5
.a1db		20 18 d7	jsr $d718	                jsr cmpl_word
.a1de		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a1e0		20 1c d7	jsr $d71c	                jsr cmpl_a
.a1e3		e6 25		inc $25		                inc tmp1                ; Calculate MSB
.a1e5		d0 02		bne $a1e9	                bne +
.a1e7		e6 26		inc $26		                inc tmp1+1
.a1e9						+
.a1e9		a4 26		ldy $26		                ldy tmp1+1              ; MSB goes in Y
.a1eb		a5 25		lda $25		                lda tmp1
.a1ed		20 18 d7	jsr $d718	                jsr cmpl_word
.a1f0		a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a1f2		98		tya		                tya
.a1f3		20 18 d7	jsr $d718	                jsr cmpl_word
.a1f6		80 0f		bra $a207	                bra _done
.a1f8						_interpret:
.a1f8		20 73 d8	jsr $d873	                jsr underflow_1
.a1fb		b5 00		lda $00,x	                lda 0,x
.a1fd		92 25		sta ($25)	                sta (tmp1)              ; LSB
.a1ff		a0 01		ldy #$01	                ldy #1
.a201		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a203		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.a205		e8		inx		                inx                     ; DROP
.a206		e8		inx		                inx
.a207						_done:
.a207		60		rts		z_to:           rts
.a208						xt_to_body:
.a208		20 73 d8	jsr $d873	                jsr underflow_1
.a20b		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( xt xt )
.a20e		20 23 92	jsr $9223	                jsr xt_int_to_name      ; ( xt nt )
.a211		f6 00		inc $00,x	                inc 0,x
.a213		d0 02		bne $a217	                bne +
.a215		f6 01		inc $01,x	                inc 1,x
.a217						+
.a217		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a219		29 20		and #$20	                and #HC
.a21b		f0 0d		beq $a22a	                beq _no_cfa
.a21d		18		clc		                clc
.a21e		b5 02		lda $02,x	                lda 2,x         ; LSB
.a220		69 03		adc #$03	                adc #3
.a222		95 02		sta $02,x	                sta 2,x
.a224		b5 03		lda $03,x	                lda 3,x         ; MSB
.a226		69 00		adc #$00	                adc #0          ; we conly care about the carry
.a228		95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a22a						_no_cfa:
.a22a		e8		inx		                inx             ; get rid of the nt
.a22b		e8		inx		                inx
.a22c						_done:
.a22c		60		rts		z_to_body:      rts
.a22d						xt_to_in:
.a22d		ca		dex		                dex
.a22e		ca		dex		                dex
.a22f		a9 10		lda #$10	                lda #<toin
.a231		95 00		sta $00,x	                sta 0,x
.a233		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a235		95 01		sta $01,x	                sta 1,x
.a237		60		rts		z_to_in:        rts
.a238						xt_to_number:
.a238		20 82 d8	jsr $d882	                jsr underflow_4
.a23b		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a23d		85 2d		sta $2d		                sta scratch
.a23f		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a241		85 2e		sta $2e		                sta scratch+1
.a243		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a245		85 2f		sta $2f		                sta scratch+2
.a247		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a249		85 30		sta $30		                sta scratch+3
.a24b		ca		dex		                dex
.a24c		ca		dex		                dex
.a24d						_loop:
.a24d		a1 04		lda ($04,x)	                lda (4,x)
.a24f		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a251		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a253		20 9d 8a	jsr $8a9d	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a256		b5 00		lda $00,x	                lda 0,x
.a258		d0 04		bne $a25e	                bne _digit_ok
.a25a		e8		inx		                inx
.a25b		e8		inx		                inx
.a25c		80 67		bra $a2c5	                bra _done       ; ( ud-lo ud-hi addr u char )
.a25e						_digit_ok:
.a25e		b5 02		lda $02,x	                lda 2,x
.a260		85 31		sta $31		                sta scratch+4
.a262		b5 03		lda $03,x	                lda 3,x
.a264		85 32		sta $32		                sta scratch+5
.a266		a5 2f		lda $2f		                lda scratch+2
.a268		95 02		sta $02,x	                sta 2,x         ; NOS
.a26a		a5 30		lda $30		                lda scratch+3
.a26c		95 03		sta $03,x	                sta 3,x
.a26e		a5 18		lda $18		                lda base
.a270		95 00		sta $00,x	                sta 0,x         ; TOS
.a272		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a274		20 77 a5	jsr $a577	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a277		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a279		85 33		sta $33		                sta scratch+6
.a27b		b5 03		lda $03,x	                lda 3,x
.a27d		85 34		sta $34		                sta scratch+7
.a27f		a5 2d		lda $2d		                lda scratch
.a281		95 02		sta $02,x	                sta 2,x
.a283		a5 2e		lda $2e		                lda scratch+1
.a285		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a287		a5 18		lda $18		                lda base
.a289		95 00		sta $00,x	                sta 0,x
.a28b		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a28d		20 77 a5	jsr $a577	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a290		b5 00		lda $00,x	                lda 0,x
.a292		85 2f		sta $2f		                sta scratch+2
.a294		b5 01		lda $01,x	                lda 1,x
.a296		85 30		sta $30		                sta scratch+3
.a298		b5 02		lda $02,x	                lda 2,x
.a29a		85 2d		sta $2d		                sta scratch
.a29c		b5 03		lda $03,x	                lda 3,x
.a29e		85 2e		sta $2e		                sta scratch+1
.a2a0		18		clc		                clc
.a2a1		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.a2a3		65 31		adc $31		                adc scratch+4   ; n LSB
.a2a5		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.a2a7		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.a2a9		65 32		adc $32		                adc scratch+5   ; n MSB
.a2ab		85 2e		sta $2e		                sta scratch+1
.a2ad		a5 2f		lda $2f		                lda scratch+2   ; LSB
.a2af		65 33		adc $33		                adc scratch+6
.a2b1		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.a2b3		a5 30		lda $30		                lda scratch+3   ; MSB
.a2b5		65 34		adc $34		                adc scratch+7
.a2b7		85 30		sta $30		                sta scratch+3
.a2b9		e8		inx		                inx
.a2ba		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a2bb		f6 04		inc $04,x	                inc 4,x
.a2bd		d0 02		bne $a2c1	                bne +
.a2bf		f6 05		inc $05,x	                inc 5,x
.a2c1						+
.a2c1		d6 02		dec $02,x	                dec 2,x
.a2c3		d0 88		bne $a24d	                bne _loop
.a2c5						_done:
.a2c5		e8		inx		                inx
.a2c6		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a2c7		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.a2c9		95 06		sta $06,x	                sta 6,x
.a2cb		a5 2e		lda $2e		                lda scratch+1
.a2cd		95 07		sta $07,x	                sta 7,x
.a2cf		a5 2f		lda $2f		                lda scratch+2
.a2d1		95 04		sta $04,x	                sta 4,x
.a2d3		a5 30		lda $30		                lda scratch+3
.a2d5		95 05		sta $05,x	                sta 5,x
.a2d7		60		rts		z_to_number:    rts
.a2d8						xt_to_order:
.a2d8		20 eb a2	jsr $a2eb	                jsr xt_to_r
.a2db		20 e6 90	jsr $90e6	                jsr xt_get_order
.a2de		20 5e 9a	jsr $9a5e	                jsr xt_r_from
.a2e1		20 33 a1	jsr $a133	                jsr xt_swap
.a2e4		20 e9 97	jsr $97e9	                jsr xt_one_plus
.a2e7		20 e0 9c	jsr $9ce0	                jsr xt_set_order
.a2ea		60		rts		z_to_order:     rts
.a2eb						xt_to_r:
.a2eb		68		pla		                pla             ; LSB
.a2ec		85 23		sta $23		                sta tmptos
.a2ee		7a		ply		                ply             ; MSB
.a2ef		20 73 d8	jsr $d873	                jsr underflow_1
.a2f2		b5 01		lda $01,x	                lda 1,x         ; MSB
.a2f4		48		pha		                pha
.a2f5		b5 00		lda $00,x	                lda 0,x         ; LSB
.a2f7		48		pha		                pha
.a2f8		e8		inx		                inx
.a2f9		e8		inx		                inx
.a2fa		5a		phy		                phy             ; MSB
.a2fb		a5 23		lda $23		                lda tmptos
.a2fd		48		pha		                pha             ; LSB
.a2fe		60		rts		z_to_r:         rts
.a2ff						xt_true:
.a2ff		ca		dex		                dex
.a300		ca		dex		                dex
.a301		a9 ff		lda #$ff	                lda #$FF
.a303		95 00		sta $00,x	                sta 0,x
.a305		95 01		sta $01,x	                sta 1,x
.a307		60		rts		z_true:         rts
.a308						xt_tuck:
.a308		20 78 d8	jsr $d878	                jsr underflow_2
.a30b		ca		dex		                dex
.a30c		ca		dex		                dex
.a30d		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a30f		b5 02		lda $02,x	                lda 2,x
.a311		95 04		sta $04,x	                sta 4,x
.a313		94 02		sty $02,x	                sty 2,x
.a315		95 00		sta $00,x	                sta 0,x
.a317		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a319		b5 03		lda $03,x	                lda 3,x
.a31b		95 05		sta $05,x	                sta 5,x
.a31d		94 03		sty $03,x	                sty 3,x         ; bba
.a31f		95 01		sta $01,x	                sta 1,x         ; baa
.a321		60		rts		z_tuck:         rts
.a322						xt_assembler_wordlist:
.a322						xt_two:
.a322		ca		dex		                dex
.a323		ca		dex		                dex
.a324		a9 02		lda #$02	                lda #2
.a326		95 00		sta $00,x	                sta 0,x
.a328		74 01		stz $01,x	                stz 1,x
.a32a						z_assembler_wordlist:
.a32a		60		rts		z_two:          rts
.a32b						xt_two_drop:
.a32b		20 78 d8	jsr $d878	                jsr underflow_2
.a32e		e8		inx		                inx
.a32f		e8		inx		                inx
.a330		e8		inx		                inx
.a331		e8		inx		                inx
.a332		60		rts		z_two_drop:     rts
.a333						xt_two_dup:
.a333		20 78 d8	jsr $d878	                jsr underflow_2
.a336		ca		dex		                dex
.a337		ca		dex		                dex
.a338		ca		dex		                dex
.a339		ca		dex		                dex
.a33a		b5 04		lda $04,x	                lda 4,x         ; TOS
.a33c		95 00		sta $00,x	                sta 0,x
.a33e		b5 05		lda $05,x	                lda 5,x
.a340		95 01		sta $01,x	                sta 1,x
.a342		b5 06		lda $06,x	                lda 6,x         ; NOS
.a344		95 02		sta $02,x	                sta 2,x
.a346		b5 07		lda $07,x	                lda 7,x
.a348		95 03		sta $03,x	                sta 3,x
.a34a		60		rts		z_two_dup:      rts
.a34b						xt_two_fetch:
.a34b		20 73 d8	jsr $d873	                jsr underflow_1
.a34e		b5 00		lda $00,x	                lda 0,x
.a350		85 25		sta $25		                sta tmp1
.a352		b4 01		ldy $01,x	                ldy 1,x
.a354		84 26		sty $26		                sty tmp1+1
.a356		ca		dex		                dex             ; reuse one stack element
.a357		ca		dex		                dex
.a358		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.a35a		95 00		sta $00,x	                sta 0,x
.a35c		a0 01		ldy #$01	                ldy #1          ; copy next
.a35e		b1 25		lda ($25),y	                lda (tmp1),y
.a360		95 01		sta $01,x	                sta 1,x
.a362		c8		iny		                iny             ; copy next
.a363		b1 25		lda ($25),y	                lda (tmp1),y
.a365		95 02		sta $02,x	                sta 2,x
.a367		c8		iny		                iny             ; copy next
.a368		b1 25		lda ($25),y	                lda (tmp1),y
.a36a		95 03		sta $03,x	                sta 3,x
.a36c		60		rts		z_two_fetch:    rts
.a36d						xt_two_over:
.a36d		20 82 d8	jsr $d882	                jsr underflow_4
.a370		ca		dex		                dex
.a371		ca		dex		                dex
.a372		ca		dex		                dex
.a373		ca		dex		                dex
.a374		b5 08		lda $08,x	                lda 8,x
.a376		95 00		sta $00,x	                sta 0,x
.a378		b5 09		lda $09,x	                lda 9,x
.a37a		95 01		sta $01,x	                sta 1,x
.a37c		b5 0a		lda $0a,x	                lda 10,x
.a37e		95 02		sta $02,x	                sta 2,x
.a380		b5 0b		lda $0b,x	                lda 11,x
.a382		95 03		sta $03,x	                sta 3,x
.a384		60		rts		z_two_over:     rts
.a385						xt_two_r_fetch:
.a385		ca		dex		                dex
.a386		ca		dex		                dex
.a387		ca		dex		                dex
.a388		ca		dex		                dex
.a389		8a		txa		                txa
.a38a		ba		tsx		                tsx
.a38b		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a38c		7a		ply		                ply
.a38d		aa		tax		                tax
.a38e		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a391		95 00		sta $00,x	                sta 0,x
.a393		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a396		95 01		sta $01,x	                sta 1,x
.a398		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a39b		95 02		sta $02,x	                sta 2,x
.a39d		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a3a0		95 03		sta $03,x	                sta 3,x
.a3a2		60		rts		z_two_r_fetch:  rts
.a3a3						xt_two_r_from:
.a3a3		68		pla		                pla                     ; LSB
.a3a4		85 25		sta $25		                sta tmp1
.a3a6		68		pla		                pla                     ; MSB
.a3a7		85 26		sta $26		                sta tmp1+1
.a3a9		ca		dex		                dex
.a3aa		ca		dex		                dex
.a3ab		ca		dex		                dex
.a3ac		ca		dex		                dex
.a3ad		68		pla		                pla                     ; LSB
.a3ae		95 00		sta $00,x	                sta 0,x
.a3b0		68		pla		                pla                     ; MSB
.a3b1		95 01		sta $01,x	                sta 1,x
.a3b3		68		pla		                pla                     ; LSB
.a3b4		95 02		sta $02,x	                sta 2,x
.a3b6		68		pla		                pla                     ; MSB
.a3b7		95 03		sta $03,x	                sta 3,x
.a3b9		a5 26		lda $26		                lda tmp1+1              ; MSB
.a3bb		48		pha		                pha
.a3bc		a5 25		lda $25		                lda tmp1                ; LSB
.a3be		48		pha		                pha
.a3bf		60		rts		z_two_r_from:   rts
.a3c0						xt_two_slash:
.a3c0		20 73 d8	jsr $d873	                jsr underflow_1
.a3c3		b5 01		lda $01,x	                lda 1,x
.a3c5		0a		asl a		                asl                     ; save the sign
.a3c6		76 01		ror $01,x	                ror 1,x
.a3c8		76 00		ror $00,x	                ror 0,x
.a3ca		60		rts		z_two_slash:    rts
.a3cb						xt_two_star:
.a3cb						xt_cells:
.a3cb		20 73 d8	jsr $d873	                jsr underflow_1
.a3ce		16 00		asl $00,x	                asl 0,x
.a3d0		36 01		rol $01,x	                rol 1,x
.a3d2						z_cells:
.a3d2		60		rts		z_two_star:     rts
.a3d3						xt_two_store:
.a3d3		20 7d d8	jsr $d87d	                jsr underflow_3
.a3d6		b5 00		lda $00,x	                lda 0,x
.a3d8		85 25		sta $25		                sta tmp1
.a3da		b4 01		ldy $01,x	                ldy 1,x
.a3dc		84 26		sty $26		                sty tmp1+1
.a3de		e8		inx		                inx
.a3df		e8		inx		                inx
.a3e0		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a3e2		92 25		sta ($25)	                sta (tmp1)
.a3e4		b5 01		lda $01,x	                lda 1,x         ; copy next
.a3e6		a0 01		ldy #$01	                ldy #1
.a3e8		91 25		sta ($25),y	                sta (tmp1),y
.a3ea		b5 02		lda $02,x	                lda 2,x         ; copy next
.a3ec		c8		iny		                iny
.a3ed		91 25		sta ($25),y	                sta (tmp1),y
.a3ef		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a3f1		c8		iny		                iny
.a3f2		91 25		sta ($25),y	                sta (tmp1),y
.a3f4		e8		inx		                inx             ; 2DROP
.a3f5		e8		inx		                inx
.a3f6		e8		inx		                inx
.a3f7		e8		inx		                inx
.a3f8		60		rts		z_two_store:    rts
.a3f9						xt_two_swap:
.a3f9		20 82 d8	jsr $d882	                jsr underflow_4
.a3fc		b5 00		lda $00,x	                lda 0,x
.a3fe		b4 04		ldy $04,x	                ldy 4,x
.a400		95 04		sta $04,x	                sta 4,x
.a402		94 00		sty $00,x	                sty 0,x
.a404		b5 01		lda $01,x	                lda 1,x
.a406		b4 05		ldy $05,x	                ldy 5,x
.a408		95 05		sta $05,x	                sta 5,x
.a40a		94 01		sty $01,x	                sty 1,x
.a40c		b5 02		lda $02,x	                lda 2,x
.a40e		b4 06		ldy $06,x	                ldy 6,x
.a410		95 06		sta $06,x	                sta 6,x
.a412		94 02		sty $02,x	                sty 2,x
.a414		b5 03		lda $03,x	                lda 3,x
.a416		b4 07		ldy $07,x	                ldy 7,x
.a418		95 07		sta $07,x	                sta 7,x
.a41a		94 03		sty $03,x	                sty 3,x
.a41c		60		rts		z_two_swap:     rts
.a41d						xt_two_to_r:
.a41d		68		pla		                pla             ; LSB
.a41e		85 25		sta $25		                sta tmp1
.a420		68		pla		                pla             ; MSB
.a421		85 26		sta $26		                sta tmp1+1
.a423		20 78 d8	jsr $d878	                jsr underflow_2
.a426		b5 03		lda $03,x	                lda 3,x         ; MSB
.a428		48		pha		                pha
.a429		b5 02		lda $02,x	                lda 2,x         ; LSB
.a42b		48		pha		                pha
.a42c		b5 01		lda $01,x	                lda 1,x         ; MSB
.a42e		48		pha		                pha
.a42f		b5 00		lda $00,x	                lda 0,x         ; LSB
.a431		48		pha		                pha
.a432		e8		inx		                inx
.a433		e8		inx		                inx
.a434		e8		inx		                inx
.a435		e8		inx		                inx
.a436		a5 26		lda $26		                lda tmp1+1      ; MSB
.a438		48		pha		                pha
.a439		a5 25		lda $25		                lda tmp1        ; LSB
.a43b		48		pha		                pha
.a43c		60		rts		z_two_to_r:     rts
.a43d						xt_two_constant:
.a43d		20 78 d8	jsr $d878	                jsr underflow_2
.a440		20 01 89	jsr $8901	                jsr xt_create
.a443		20 33 a1	jsr $a133	                jsr xt_swap
.a446		20 f1 86	jsr $86f1	                jsr xt_comma
.a449		20 f1 86	jsr $86f1	                jsr xt_comma
.a44c		20 84 8b	jsr $8b84	                jsr does_runtime    ; does> turns into these two routines.
.a44f		20 52 d7	jsr $d752	                jsr dodoes
.a452		20 2f 8d	jsr $8d2f	                jsr xt_dup
.a455		20 32 8f	jsr $8f32	                jsr xt_fetch
.a458		20 33 a1	jsr $a133	                jsr xt_swap
.a45b		20 a4 85	jsr $85a4	                jsr xt_cell_plus
.a45e		20 32 8f	jsr $8f32	                jsr xt_fetch
.a461		60		rts		z_two_constant: rts
.a462						xt_two_literal:
.a462		20 78 d8	jsr $d878	                jsr underflow_2 ; double number
.a465		20 33 a1	jsr $a133	                jsr xt_swap
.a468		20 4e 93	jsr $934e	                jsr xt_literal
.a46b		20 4e 93	jsr $934e	                jsr xt_literal
.a46e		60		rts		z_two_literal:  rts
.a46f						xt_two_variable:
.a46f		20 01 89	jsr $8901	                jsr xt_create
.a472		ca		dex		                dex
.a473		ca		dex		                dex
.a474		a9 04		lda #$04	                lda #4
.a476		95 00		sta $00,x	                sta 0,x
.a478		74 01		stz $01,x	                stz 1,x
.a47a		20 43 82	jsr $8243	                jsr xt_allot
.a47d		60		rts		z_two_variable: rts
.a47e						xt_type:
.a47e		20 78 d8	jsr $d878	                jsr underflow_2
.a481		b5 02		lda $02,x	                lda 2,x
.a483		85 25		sta $25		                sta tmp1
.a485		b5 03		lda $03,x	                lda 3,x
.a487		85 26		sta $26		                sta tmp1+1
.a489						_loop:
.a489		b5 00		lda $00,x	                lda 0,x
.a48b		15 01		ora $01,x	                ora 1,x
.a48d		f0 15		beq $a4a4	                beq _done
.a48f		b2 25		lda ($25)	                lda (tmp1)
.a491		20 a8 8d	jsr $8da8	                jsr emit_a      ; avoids stack foolery
.a494		e6 25		inc $25		                inc tmp1
.a496		d0 02		bne $a49a	                bne +
.a498		e6 26		inc $26		                inc tmp1+1
.a49a						+
.a49a		b5 00		lda $00,x	                lda 0,x
.a49c		d0 02		bne $a4a0	                bne +
.a49e		d6 01		dec $01,x	                dec 1,x
.a4a0						+
.a4a0		d6 00		dec $00,x	                dec 0,x
.a4a2		80 e5		bra $a489	                bra _loop
.a4a4						_done:
.a4a4		e8		inx		                inx
.a4a5		e8		inx		                inx
.a4a6		e8		inx		                inx
.a4a7		e8		inx		                inx
.a4a8		60		rts		z_type:         rts
.a4a9						xt_u_dot:
.a4a9		20 73 d8	jsr $d873	                jsr underflow_1
.a4ac		20 e0 d8	jsr $d8e0	                jsr print_u
.a4af		a9 20		lda #$20	                lda #AscSP
.a4b1		20 a8 8d	jsr $8da8	                jsr emit_a
.a4b4		60		rts		z_u_dot:        rts
.a4b5						xt_u_dot_r:
.a4b5		20 78 d8	jsr $d878	                jsr underflow_2
.a4b8		20 eb a2	jsr $a2eb	                jsr xt_to_r
.a4bb		20 36 a7	jsr $a736	                jsr xt_zero
.a4be		20 1e 93	jsr $931e	                jsr xt_less_number_sign
.a4c1		20 aa 97	jsr $97aa	                jsr xt_number_sign_s
.a4c4		20 88 97	jsr $9788	                jsr xt_number_sign_greater
.a4c7		20 5e 9a	jsr $9a5e	                jsr xt_r_from
.a4ca		20 5f 98	jsr $985f	                jsr xt_over
.a4cd		20 25 95	jsr $9525	                jsr xt_minus
.a4d0		20 af a0	jsr $a0af	                jsr xt_spaces
.a4d3		20 7e a4	jsr $a47e	                jsr xt_type
.a4d6		60		rts		z_u_dot_r:      rts
.a4d7						xt_u_greater_than:
.a4d7		20 78 d8	jsr $d878	                jsr underflow_2
.a4da		b5 00		lda $00,x	                lda 0,x
.a4dc		d5 02		cmp $02,x	                cmp 2,x
.a4de		b5 01		lda $01,x	                lda 1,x
.a4e0		f5 03		sbc $03,x	                sbc 3,x
.a4e2		e8		inx		                inx
.a4e3		e8		inx		                inx
.a4e4		a9 00		lda #$00	                lda #0
.a4e6		69 ff		adc #$ff	                adc #$ff
.a4e8		95 00		sta $00,x	                sta 0,x         ; store flag
.a4ea		95 01		sta $01,x	                sta 1,x
.a4ec		60		rts		z_u_greater_than:    rts
.a4ed						xt_u_less_than:
.a4ed		20 78 d8	jsr $d878	                jsr underflow_2
.a4f0		b5 02		lda $02,x	                lda 2,x
.a4f2		d5 00		cmp $00,x	                cmp 0,x
.a4f4		b5 03		lda $03,x	                lda 3,x
.a4f6		f5 01		sbc $01,x	                sbc 1,x
.a4f8		e8		inx		                inx
.a4f9		e8		inx		                inx
.a4fa		a9 00		lda #$00	                lda #0
.a4fc		69 ff		adc #$ff	                adc #$ff
.a4fe		95 00		sta $00,x	                sta 0,x         ; store flag
.a500		95 01		sta $01,x	                sta 1,x
.a502		60		rts		z_u_less_than:    rts
.a503						xt_ud_dot:
.a503		20 78 d8	jsr $d878	                jsr underflow_2 ; double number
.a506		20 1e 93	jsr $931e	                jsr xt_less_number_sign
.a509		20 aa 97	jsr $97aa	                jsr xt_number_sign_s
.a50c		20 88 97	jsr $9788	                jsr xt_number_sign_greater
.a50f		20 7e a4	jsr $a47e	                jsr xt_type
.a512		20 a9 a0	jsr $a0a9	                jsr xt_space
.a515		60		rts		z_ud_dot:        rts
.a516						xt_ud_dot_r:
.a516		20 7d d8	jsr $d87d	                jsr underflow_3
.a519		20 eb a2	jsr $a2eb	                jsr xt_to_r
.a51c		20 1e 93	jsr $931e	                jsr xt_less_number_sign
.a51f		20 aa 97	jsr $97aa	                jsr xt_number_sign_s
.a522		20 88 97	jsr $9788	                jsr xt_number_sign_greater
.a525		20 5e 9a	jsr $9a5e	                jsr xt_r_from
.a528		20 5f 98	jsr $985f	                jsr xt_over
.a52b		20 25 95	jsr $9525	                jsr xt_minus
.a52e		20 af a0	jsr $a0af	                jsr xt_spaces
.a531		20 7e a4	jsr $a47e	                jsr xt_type
.a534		60		rts		z_ud_dot_r:      rts
.a535						xt_um_slash_mod:
.a535		20 7d d8	jsr $d87d	                jsr underflow_3
.a538		b5 00		lda $00,x	                lda 0,x
.a53a		15 01		ora $01,x	                ora 1,x
.a53c		d0 05		bne $a543	                bne _not_zero
.a53e		a9 04		lda #$04	                lda #err_divzero
.a540		4c 89 d8	jmp $d889	                jmp error
.a543						_not_zero:
.a543		a9 11		lda #$11	                lda #17
.a545		85 23		sta $23		                sta tmptos
.a547						_loop:
.a547		36 04		rol $04,x	                rol 4,x
.a549		36 05		rol $05,x	                rol 5,x
.a54b		c6 23		dec $23		                dec tmptos
.a54d		f0 22		beq $a571	                beq _done
.a54f		36 02		rol $02,x	                rol 2,x
.a551		36 03		rol $03,x	                rol 3,x
.a553		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a555		26 25		rol $25		                rol tmp1
.a557		38		sec		                sec
.a558		b5 02		lda $02,x	                lda 2,x
.a55a		f5 00		sbc $00,x	                sbc 0,x
.a55c		85 26		sta $26		                sta tmp1+1
.a55e		b5 03		lda $03,x	                lda 3,x
.a560		f5 01		sbc $01,x	                sbc 1,x
.a562		a8		tay		                tay
.a563		a5 25		lda $25		                lda tmp1
.a565		e9 00		sbc #$00	                sbc #0
.a567		90 de		bcc $a547	                bcc _loop
.a569		a5 26		lda $26		                lda tmp1+1
.a56b		95 02		sta $02,x	                sta 2,x
.a56d		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a56f		80 d6		bra $a547	                bra _loop
.a571						_done:
.a571		e8		inx		                inx
.a572		e8		inx		                inx
.a573		20 33 a1	jsr $a133	                jsr xt_swap
.a576		60		rts		z_um_slash_mod: rts
.a577						xt_um_star:
.a577		20 78 d8	jsr $d878	                jsr underflow_2
.a57a		18		clc		                clc
.a57b		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a57d		e9 00		sbc #$00	                sbc #0
.a57f		85 27		sta $27		                sta tmp2
.a581		b5 01		lda $01,x	                lda 1,x
.a583		e9 00		sbc #$00	                sbc #0
.a585		90 31		bcc $a5b8	                bcc _zero       ; is TOS zero?
.a587		85 28		sta $28		                sta tmp2+1
.a589		a9 00		lda #$00	                lda #0
.a58b		85 25		sta $25		                sta tmp1
.a58d		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.a58f		ca		dex		                dex
.a590		ca		dex		                dex
.a591						_outer_loop:
.a591		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a593		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a595						_inner_loop:
.a595		90 0c		bcc $a5a3	                bcc _no_add
.a597		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.a599		a5 25		lda $25		                lda tmp1
.a59b		65 27		adc $27		                adc tmp2
.a59d		85 25		sta $25		                sta tmp1
.a59f		a5 26		lda $26		                lda tmp1+1
.a5a1		65 28		adc $28		                adc tmp2+1
.a5a3						_no_add:
.a5a3		6a		ror a		                ror
.a5a4		66 25		ror $25		                ror tmp1
.a5a6		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a5a8		88		dey		                dey
.a5a9		d0 ea		bne $a595	                bne _inner_loop ; go back for one more shift?
.a5ab		e8		inx		                inx
.a5ac		e4 29		cpx $29		                cpx tmp3
.a5ae		d0 e1		bne $a591	                bne _outer_loop ; go back for eight more shifts?
.a5b0		95 01		sta $01,x	                sta 1,x
.a5b2		a5 25		lda $25		                lda tmp1
.a5b4		95 00		sta $00,x	                sta 0,x
.a5b6		80 04		bra $a5bc	                bra _done
.a5b8						_zero:
.a5b8		74 02		stz $02,x	                stz 2,x
.a5ba		74 03		stz $03,x	                stz 3,x
.a5bc						_done:
.a5bc		60		rts		z_um_star:      rts
.a5bd						xt_unloop:
.a5bd		a4 1f		ldy $1f		                ldy loopctrl
.a5bf		88		dey		                dey
.a5c0		88		dey		                dey
.a5c1		88		dey		                dey
.a5c2		88		dey		                dey
.a5c3		84 1f		sty $1f		                sty loopctrl
.a5c5		30 05		bmi $a5cc	                bmi z_unloop            ; no active loops?
.a5c7		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.a5ca		85 20		sta $20		                sta loopidx0
.a5cc		60		rts		z_unloop:       rts
.a5cd						xt_until:
.a5cd		a0 00		ldy #$00	                ldy #0
.a5cf						-
.a5cf		b9 c1 91	lda $91c1,y	                lda zero_test_runtime,y
.a5d2		c9 60		cmp #$60	                cmp #$60            ; skip RTS
.a5d4		f0 03		beq $a5d9	                beq +
.a5d6		20 1c d7	jsr $d71c	                jsr cmpl_a
.a5d9						+
.a5d9		c8		iny		                iny
.a5da		c0 0a		cpy #$0a	                cpy #(zero_test_footer_end - zero_test_runtime)
.a5dc		d0 f1		bne $a5cf	                bne -
.a5de		20 f1 86	jsr $86f1	                jsr xt_comma
.a5e1		60		rts		z_until:        rts
.a5e2						xt_unused:
.a5e2		ca		dex		                dex
.a5e3		ca		dex		                dex
.a5e4		a9 00		lda #$00	                lda #<cp_end
.a5e6		38		sec		                sec
.a5e7		e5 00		sbc $00		                sbc cp
.a5e9		95 00		sta $00,x	                sta 0,x
.a5eb		a9 7c		lda #$7c	                lda #>cp_end
.a5ed		e5 01		sbc $01		                sbc cp+1
.a5ef		95 01		sta $01,x	                sta 1,x
.a5f1		60		rts		z_unused:       rts
.a5f2						xt_update:
.a5f2		a0 30		ldy #$30	                ldy #buffstatus_offset
.a5f4		b1 08		lda ($08),y	                lda (up),y
.a5f6		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a5f8		91 08		sta ($08),y	                sta (up),y
.a5fa		60		rts		z_update:       rts
.a5fb						xt_useraddr:
.a5fb		ca		dex		                dex
.a5fc		ca		dex		                dex
.a5fd		a9 08		lda #$08	                lda #<up
.a5ff		95 00		sta $00,x	                sta 0,x
.a601		a9 00		lda #$00	                lda #>up
.a603		95 01		sta $01,x	                sta 1,x
.a605		60		rts		z_useraddr:     rts
.a606						xt_variable:
.a606		20 01 89	jsr $8901	                jsr xt_create
.a609		a9 00		lda #$00	                lda #0
.a60b		92 00		sta ($00)	                sta (cp)
.a60d		e6 00		inc $00		                inc cp
.a60f		d0 02		bne $a613	                bne +
.a611		e6 01		inc $01		                inc cp+1
.a613						+
.a613		92 00		sta ($00)	                sta (cp)
.a615		e6 00		inc $00		                inc cp
.a617		d0 02		bne $a61b	                bne +
.a619		e6 01		inc $01		                inc cp+1
.a61b						+
.a61b		20 c9 88	jsr $88c9	                jsr adjust_z
.a61e		60		rts		z_variable:     rts
.a61f						xt_while:
.a61f		a0 91		ldy #$91	                ldy #>zero_branch_runtime
.a621		a9 cb		lda #$cb	                lda #<zero_branch_runtime
.a623		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.a626		20 24 91	jsr $9124	                jsr xt_here
.a629		20 ff a2	jsr $a2ff	                jsr xt_true
.a62c		20 f1 86	jsr $86f1	                jsr xt_comma
.a62f		20 33 a1	jsr $a133	                jsr xt_swap
.a632		60		rts		z_while:        rts
.a633						xt_within:
.a633		20 7d d8	jsr $d87d	                jsr underflow_3
.a636		20 5f 98	jsr $985f	                jsr xt_over
.a639		20 25 95	jsr $9525	                jsr xt_minus
.a63c		20 eb a2	jsr $a2eb	                jsr xt_to_r
.a63f		20 25 95	jsr $9525	                jsr xt_minus
.a642		20 5e 9a	jsr $9a5e	                jsr xt_r_from
.a645		20 ed a4	jsr $a4ed	                jsr xt_u_less_than
.a648		60		rts		z_within:       rts
.a649						xt_word:
.a649		20 73 d8	jsr $d873	                jsr underflow_1
.a64c		a4 10		ldy $10		                ldy toin                ; >IN
.a64e						_loop:
.a64e		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.a650		f0 09		beq $a65b	                beq _found_char
.a652		b1 0c		lda ($0c),y	                lda (cib),y
.a654		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a656		d0 03		bne $a65b	                bne _found_char
.a658		c8		iny		                iny
.a659		80 f3		bra $a64e	                bra _loop
.a65b						_found_char:
.a65b		84 10		sty $10		                sty toin
.a65d		20 06 99	jsr $9906	                jsr xt_parse            ; Returns ( addr u )
.a660		b5 00		lda $00,x	                lda 0,x
.a662		92 00		sta ($00)	                sta (cp)                ; Save length of string
.a664		48		pha		                pha                     ; Keep copy of length for later
.a665		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( addr u u )
.a668		a5 00		lda $00		                lda cp
.a66a		18		clc		                clc
.a66b		69 01		adc #$01	                adc #1
.a66d		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a66f		a5 01		lda $01		                lda cp+1
.a671		69 00		adc #$00	                adc #0
.a673		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a675		20 97 95	jsr $9597	                jsr xt_move
.a678		ca		dex		                dex
.a679		ca		dex		                dex
.a67a		a5 00		lda $00		                lda cp
.a67c		95 00		sta $00,x	                sta 0,x
.a67e		a5 01		lda $01		                lda cp+1
.a680		95 01		sta $01,x	                sta 1,x
.a682		68		pla		                pla                     ; length of string
.a683		18		clc		                clc
.a684		65 00		adc $00		                adc cp
.a686		85 00		sta $00		                sta cp
.a688		a5 01		lda $01		                lda cp+1
.a68a		69 00		adc #$00	                adc #0                  ; we only need the carry
.a68c		85 01		sta $01		                sta cp+1
.a68e		60		rts		z_word:         rts
.a68f						xt_wordlist:
.a68f		a0 09		ldy #$09	                ldy #num_wordlists_offset
.a691		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.a693		c9 0c		cmp #$0c	                cmp #max_wordlists
.a695		d0 05		bne $a69c	                bne _ok
.a697		a9 0b		lda #$0b	                lda #err_wordlist
.a699		4c 89 d8	jmp $d889	                jmp error
.a69c						_ok:
.a69c		1a		inc a		                ina             ; Increment the wordlist#
.a69d		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.a69f		ca		dex		                dex             ; and put it on the stack.
.a6a0		ca		dex		                dex
.a6a1		95 00		sta $00,x	                sta 0,x
.a6a3		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a6a5		60		rts		z_wordlist:     rts
.a6a6						xt_words:
.a6a6		20 fb 88	jsr $88fb	                jsr xt_cr
.a6a9		a9 00		lda #$00	                lda #0
.a6ab		48		pha		                pha
.a6ac		ca		dex		                dex                     ; Make room on the stack for
.a6ad		ca		dex		                dex                     ; a dictionary pointer.
.a6ae		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.a6b0						_wordlist_loop:
.a6b0		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a6b2		a5 29		lda $29		                lda tmp3
.a6b4		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.a6b6		d0 02		bne $a6ba	                bne _have_wordlist
.a6b8		80 45		bra $a6ff	                bra _words_done
.a6ba						_have_wordlist:
.a6ba		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a6bb		69 23		adc #$23	                adc #search_order_offset
.a6bd		a8		tay		                tay
.a6be		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.a6c0		0a		asl a		                asl                     ; Turn offset into cells offset.
.a6c1		18		clc		                clc
.a6c2		69 0a		adc #$0a	                adc #wordlists_offset
.a6c4		a8		tay		                tay
.a6c5		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.a6c7		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a6c9		c8		iny		                iny
.a6ca		b1 08		lda ($08),y	                lda (up),y
.a6cc		95 01		sta $01,x	                sta 1,x
.a6ce						_loop:
.a6ce		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( nt nt )
.a6d1		20 d3 95	jsr $95d3	                jsr xt_name_to_string   ; ( nt addr u )
.a6d4		68		pla		                pla
.a6d5		18		clc		                clc
.a6d6		75 00		adc $00,x	                adc 0,x
.a6d8		1a		inc a		                ina                     ; don't forget the space between words
.a6d9		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a6db		90 06		bcc $a6e3	                bcc +
.a6dd		20 fb 88	jsr $88fb	                jsr xt_cr
.a6e0		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a6e2		1a		inc a		                ina                     ; with length of this word.
.a6e3						+
.a6e3		48		pha		                pha
.a6e4		20 7e a4	jsr $a47e	                jsr xt_type             ; ( nt )
.a6e7		a9 20		lda #$20	                lda #AscSP
.a6e9		20 a8 8d	jsr $8da8	                jsr emit_a
.a6ec		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+
.a6ef		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+
.a6f2		20 32 8f	jsr $8f32	                jsr xt_fetch            ; @ ( nt+1 )
.a6f5		b5 00		lda $00,x	                lda 0,x
.a6f7		15 01		ora $01,x	                ora 1,x
.a6f9		d0 d3		bne $a6ce	                bne _loop
.a6fb		e6 29		inc $29		                inc tmp3
.a6fd		80 b1		bra $a6b0	                bra _wordlist_loop
.a6ff						_words_done:
.a6ff		68		pla		                pla                     ; dump counter
.a700		e8		inx		                inx
.a701		e8		inx		                inx
.a702		60		rts		z_words:        rts
.a703						xt_wordsize:
.a703		20 73 d8	jsr $d873	                jsr underflow_1
.a706		b5 00		lda $00,x	                lda 0,x
.a708		85 25		sta $25		                sta tmp1
.a70a		b5 01		lda $01,x	                lda 1,x
.a70c		85 26		sta $26		                sta tmp1+1
.a70e		a0 06		ldy #$06	                ldy #6
.a710		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.a712		88		dey		                dey
.a713		88		dey		                dey
.a714		38		sec		                sec
.a715		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.a717		95 00		sta $00,x	                sta 0,x
.a719		a0 07		ldy #$07	                ldy #7
.a71b		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.a71d		88		dey		                dey
.a71e		88		dey		                dey
.a71f		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.a721		95 01		sta $01,x	                sta 1,x
.a723		60		rts		z_wordsize:     rts
.a724						xt_xor:
.a724		20 78 d8	jsr $d878	                jsr underflow_2
.a727		b5 00		lda $00,x	                lda 0,x
.a729		55 02		eor $02,x	                eor 2,x
.a72b		95 02		sta $02,x	                sta 2,x
.a72d		b5 01		lda $01,x	                lda 1,x
.a72f		55 03		eor $03,x	                eor 3,x
.a731		95 03		sta $03,x	                sta 3,x
.a733		e8		inx		                inx
.a734		e8		inx		                inx
.a735		60		rts		z_xor:          rts
.a736						xt_case:
.a736						xt_forth_wordlist:
.a736						xt_zero:
.a736		ca		dex		                dex             ; push
.a737		ca		dex		                dex
.a738		74 00		stz $00,x	                stz 0,x
.a73a		74 01		stz $01,x	                stz 1,x
.a73c						z_case:
.a73c						z_forth_wordlist:
.a73c						z_zero:
.a73c		60		rts		                rts
.a73d						xt_zero_equal:
.a73d		20 73 d8	jsr $d873	                jsr underflow_1
.a740		b5 00		lda $00,x	                lda 0,x
.a742		15 01		ora $01,x	                ora 1,x
.a744		f0 02		beq $a748	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.a746		a9 ff		lda #$ff	                lda #$ff        ; else set A inverse of the FALSE (0) we want
.a748						_zero:
.a748		49 ff		eor #$ff	                eor #$ff        ; now just invert
.a74a						_store:
.a74a		95 00		sta $00,x	                sta 0,x
.a74c		95 01		sta $01,x	                sta 1,x
.a74e		60		rts		z_zero_equal:   rts
.a74f						xt_zero_greater:
.a74f		20 73 d8	jsr $d873	                jsr underflow_1
.a752		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a754		b5 01		lda $01,x	                lda 1,x         ; MSB
.a756		30 05		bmi $a75d	                bmi _done       ; TOS is negative, keep FLASE
.a758		15 00		ora $00,x	                ora 0,x
.a75a		f0 01		beq $a75d	                beq _done       ; TOS is zero, keep FALSE
.a75c		88		dey		                dey             ; TOS is postive, make true
.a75d						_done:
.a75d		98		tya		                tya
.a75e		95 00		sta $00,x	                sta 0,x
.a760		95 01		sta $01,x	                sta 1,x
.a762		60		rts		z_zero_greater: rts
.a763						xt_zero_less:
.a763		20 73 d8	jsr $d873	                jsr underflow_1
.a766		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a768		b5 01		lda $01,x	                lda 1,x         ; MSB
.a76a		10 01		bpl $a76d	                bpl _done       ; TOS is positive, so keep FALSE
.a76c		88		dey		                dey             ; TOS is negative, make TRUE
.a76d						_done:
.a76d		98		tya		                tya
.a76e		95 00		sta $00,x	                sta 0,x
.a770		95 01		sta $01,x	                sta 1,x
.a772		60		rts		z_zero_less:    rts
.a773						xt_zero_unequal:
.a773		20 73 d8	jsr $d873	                jsr underflow_1
.a776		b5 00		lda $00,x	                lda 0,x
.a778		15 01		ora $01,x	                ora 1,x
.a77a		f0 02		beq $a77e	                beq _zero
.a77c		a9 ff		lda #$ff	                lda #$ff
.a77e						_zero:
.a77e		95 00		sta $00,x	                sta 0,x
.a780		95 01		sta $01,x	                sta 1,x
.a782		60		rts		z_zero_unequal: rts
.a783						xt_editor_screen_helper:
.a783		20 2f 8d	jsr $8d2f	                jsr xt_dup
.a786		20 6f 9e	jsr $9e6f	                jsr xt_scr
.a789		20 18 a1	jsr $a118	                jsr xt_store
.a78c		20 43 85	jsr $8543	                jsr xt_buffer
.a78f						z_editor_screen_helper:
.a78f		60		rts		                rts
.a790						xt_editor_enter_screen:
.a790		20 83 a7	jsr $a783	                jsr xt_editor_screen_helper
.a793		20 ae 8c	jsr $8cae	                jsr xt_drop
.a796		64 35		stz $35		                stz ed_head
.a798						_prompt_loop:
.a798		ca		dex		                dex
.a799		ca		dex		                dex
.a79a		a5 35		lda $35		                lda ed_head
.a79c		95 00		sta $00,x	                sta 0,x
.a79e		74 01		stz $01,x	                stz 1,x
.a7a0		20 65 a8	jsr $a865	                jsr xt_editor_o
.a7a3		e6 35		inc $35		                inc ed_head
.a7a5		a9 10		lda #$10	                lda #16
.a7a7		c5 35		cmp $35		                cmp ed_head
.a7a9		d0 ed		bne $a798	                bne _prompt_loop
.a7ab						z_editor_enter_screen:
.a7ab		60		rts		                rts
.a7ac						xt_editor_erase_screen:
.a7ac		20 83 a7	jsr $a783	                jsr xt_editor_screen_helper
.a7af		ca		dex		                dex
.a7b0		ca		dex		                dex
.a7b1		74 00		stz $00,x	                stz 0,x
.a7b3		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a7b5		95 01		sta $01,x	                sta 1,x
.a7b7		20 9c 8e	jsr $8e9c	                jsr xt_blank
.a7ba		20 f2 a5	jsr $a5f2	                jsr xt_update
.a7bd						z_editor_erase_screen:
.a7bd		60		rts		                rts
.a7be						xt_editor_el:
.a7be		20 4c a8	jsr $a84c	                jsr xt_editor_line
.a7c1		ca		dex		                dex
.a7c2		ca		dex		                dex
.a7c3		a9 40		lda #$40	                lda #64
.a7c5		95 00		sta $00,x	                sta 0,x
.a7c7		74 01		stz $01,x	                stz 1,x
.a7c9		20 9c 8e	jsr $8e9c	                jsr xt_blank
.a7cc		20 f2 a5	jsr $a5f2	                jsr xt_update
.a7cf		60		rts		z_editor_el:    rts
.a7d0						xt_editor_l:
.a7d0		ca		dex		                dex             ; Put SCR on the stack.
.a7d1		ca		dex		                dex
.a7d2		a0 06		ldy #$06	                ldy #scr_offset
.a7d4		b1 08		lda ($08),y	                lda (up),y
.a7d6		95 00		sta $00,x	                sta 0,x
.a7d8		c8		iny		                iny
.a7d9		b1 08		lda ($08),y	                lda (up),y
.a7db		95 01		sta $01,x	                sta 1,x
.a7dd		20 70 83	jsr $8370	                jsr xt_block    ; Get the current screen.
.a7e0		20 fb 88	jsr $88fb	                jsr xt_cr
.a7e3		80 08		bra $a7ed	                bra _after_screen_msg
.a7e5						_screen_msg:
>a7e5		53 63 72 65 65 6e 20 23		                .text "Screen #"
.a7ed						_after_screen_msg:
.a7ed		20 34 a0	jsr $a034	                jsr sliteral_runtime
>a7f0		e5 a7 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a7f4		20 7e a4	jsr $a47e	                jsr xt_type
.a7f7		20 6f 9e	jsr $9e6f	                jsr xt_scr
.a7fa		20 32 8f	jsr $8f32	                jsr xt_fetch
.a7fd		ca		dex		                dex
.a7fe		ca		dex		                dex
.a7ff		a9 04		lda #$04	                lda #4          ; four spaces
.a801		95 00		sta $00,x	                sta 0,x
.a803		74 01		stz $01,x	                stz 1,x
.a805		20 b5 a4	jsr $a4b5	                jsr xt_u_dot_r
.a808		64 29		stz $29		                stz tmp3
.a80a						_line_loop:
.a80a		20 fb 88	jsr $88fb	                jsr xt_cr
.a80d		ca		dex		                dex
.a80e		ca		dex		                dex
.a80f		ca		dex		                dex
.a810		ca		dex		                dex
.a811		74 03		stz $03,x	                stz 3,x
.a813		a5 29		lda $29		                lda tmp3
.a815		95 02		sta $02,x	                sta 2,x
.a817		74 01		stz $01,x	                stz 1,x
.a819		a9 02		lda #$02	                lda #2
.a81b		95 00		sta $00,x	                sta 0,x
.a81d		20 b5 a4	jsr $a4b5	                jsr xt_u_dot_r
.a820		20 a9 a0	jsr $a0a9	                jsr xt_space
.a823		20 2f 8d	jsr $8d2f	                jsr xt_dup
.a826		ca		dex		                dex
.a827		ca		dex		                dex
.a828		a9 40		lda #$40	                lda #64
.a82a		95 00		sta $00,x	                sta 0,x
.a82c		74 01		stz $01,x	                stz 1,x
.a82e		20 7e a4	jsr $a47e	                jsr xt_type
.a831		18		clc		                clc
.a832		a9 40		lda #$40	                lda #64
.a834		75 00		adc $00,x	                adc 0,x
.a836		95 00		sta $00,x	                sta 0,x
.a838		b5 01		lda $01,x	                lda 1,x
.a83a		69 00		adc #$00	                adc #0      ; Add carry
.a83c		95 01		sta $01,x	                sta 1,x
.a83e		e6 29		inc $29		                inc tmp3
.a840		a5 29		lda $29		                lda tmp3
.a842		c9 10		cmp #$10	                cmp #16
.a844		d0 c4		bne $a80a	                bne _line_loop
.a846		20 fb 88	jsr $88fb	                jsr xt_cr
.a849		e8		inx		                inx
.a84a		e8		inx		                inx
.a84b		60		rts		z_editor_l:            rts
.a84c						xt_editor_line:
.a84c		20 73 d8	jsr $d873	                jsr underflow_1
.a84f		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a851						_shift_tos_left:
.a851		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a853		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a855		88		dey		                dey
.a856		d0 f9		bne $a851	                bne _shift_tos_left
.a858		20 6f 9e	jsr $9e6f	                jsr xt_scr
.a85b		20 32 8f	jsr $8f32	                jsr xt_fetch
.a85e		20 70 83	jsr $8370	                jsr xt_block
.a861		20 af 99	jsr $99af	                jsr xt_plus
.a864		60		rts		z_editor_line:  rts
.a865						xt_editor_o:
.a865		20 fb 88	jsr $88fb	                jsr xt_cr
.a868		20 2f 8d	jsr $8d2f	                jsr xt_dup
.a86b		20 22 a3	jsr $a322	                jsr xt_two
.a86e		20 b5 a4	jsr $a4b5	                jsr xt_u_dot_r
.a871		20 a9 a0	jsr $a0a9	                jsr xt_space
.a874		a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a876		20 a8 8d	jsr $8da8	                jsr emit_a
.a879		20 a9 a0	jsr $a0a9	                jsr xt_space
.a87c		20 4c a8	jsr $a84c	                jsr xt_editor_line
.a87f		20 2f 8d	jsr $8d2f	                jsr xt_dup      ; Save a copy of the line address for later.
.a882		ca		dex		                dex
.a883		ca		dex		                dex
.a884		a9 40		lda #$40	                lda #64         ; chars/line
.a886		95 00		sta $00,x	                sta 0,x
.a888		74 01		stz $01,x	                stz 1,x
.a88a		20 e6 80	jsr $80e6	                jsr xt_accept
.a88d		20 2f 8d	jsr $8d2f	                jsr xt_dup
.a890		20 3d 96	jsr $963d	                jsr xt_not_rote ; -rot
.a893		20 af 99	jsr $99af	                jsr xt_plus
.a896		ca		dex		                dex
.a897		ca		dex		                dex
.a898		a9 40		lda #$40	                lda #64         ; chars/line
.a89a		95 00		sta $00,x	                sta 0,x
.a89c		74 01		stz $01,x	                stz 1,x
.a89e		20 1c 9b	jsr $9b1c	                jsr xt_rot
.a8a1		20 25 95	jsr $9525	                jsr xt_minus
.a8a4		20 9c 8e	jsr $8e9c	                jsr xt_blank
.a8a7		20 f2 a5	jsr $a5f2	                jsr xt_update
.a8aa		60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.a8ab						cold_zp_table:
>a8ab	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>a8ad	0002	75 bc				dp:         .word dictionary_start  ; Dictionary Pointer
>a8af	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>a8b1	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>a8b3	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>a8b5	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>a8b7	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>a8b9	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>a8bb	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>a8bd	0012	27 f0				output:     .word kernel_putc       ; vector for EMIT
>a8bf	0014	21 f0				input:      .word kernel_getc       ; vector for KEY
>a8c1	0016	00 00				havekey:    .word 0                 ; vector for KEY?
>a8c3	0018	0a 00				base:       .word 10                ; number radix, default decimal
>a8c5	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>a8c7	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>a8c9	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>a8ca	001f					loopctrl:   .byte ?         ; Offset and flags for DO/LOOP/+LOOP control.
>a8cb	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$100						lcbstack = $100
=256						loopindex = lcbstack+0      ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack+2      ; loop control block offset for limit fudge factor
>a8cc	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>a8ce	0023					tmptos:     .word ?         ; temporary TOS storage
>a8d0	0025					tmp1:       .word ?         ; temporary storage
>a8d2	0027					tmp2:       .word ?         ; temporary storage
>a8d4	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>a8d6	002b					tohold:     .word ?         ; pointer for formatted output
>a8d8	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>a8e0	0035					tmped:      .word ?,?,?     ; temporary for editors
.a8c9						cold_zp_table_end:
.a8c9						cold_user_table:
>a8c9	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>a8cb	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>a8cd	0004	00 00				blk_offset:             .word 0         ; BLK
>a8cf	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
>a8d1	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>a8d2	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.a8d3	000a					wordlists_offset:
>a8d3	000a	75 bc				    .word dictionary_start              ; FORTH-WORDLIST
>a8d5	000c	bd ca				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>a8d7	000e	0d cb				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>a8d9	0010	7c ca				    .word root_dictionary_start         ; ROOT-WORDLIST
>a8db	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>a8e3	001a	00 00 00 00 00 00 00 00
>a8eb	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.a8ec	0023					search_order_offset:
>a8ec	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>a8f4	002b	00
>a8f5	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>a8f7	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>a8f9	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>a8fb	0032	ff 84				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>a8fd	0034	ff 84				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.a8ff						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0a  ; line feed
=$0d						AscCR   = $0d  ; carriage return
=$1b						AscESC  = $1b  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7f  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a8ff						assembler:
.a8ff						xt_asm_adc_h:
.a8ff		a9 69		lda #$69	                lda #$69
.a901		4c 5a ac	jmp $ac5a	                jmp asm_common
.a904						z_asm_adc_h:
.a904						xt_asm_adc_x:
.a904		a9 7d		lda #$7d	                lda #$7D
.a906		4c 5a ac	jmp $ac5a	                jmp asm_common
.a909						z_asm_adc_x:
.a909						xt_asm_adc_y:
.a909		a9 79		lda #$79	                lda #$79
.a90b		4c 5a ac	jmp $ac5a	                jmp asm_common
.a90e						z_asm_adc_y:
.a90e						xt_asm_adc_z:
.a90e		a9 65		lda #$65	                lda #$65
.a910		4c 5a ac	jmp $ac5a	                jmp asm_common
.a913						z_asm_adc_z:
.a913						xt_asm_adc_zi:
.a913		a9 72		lda #$72	                lda #$72
.a915		4c 5a ac	jmp $ac5a	                jmp asm_common
.a918						z_asm_adc_zi:
.a918						xt_asm_adc_ziy:
.a918		a9 71		lda #$71	                lda #$71
.a91a		4c 5a ac	jmp $ac5a	                jmp asm_common
.a91d						z_asm_adc_ziy:
.a91d						xt_asm_adc_zx:
.a91d		a9 75		lda #$75	                lda #$75
.a91f		4c 5a ac	jmp $ac5a	                jmp asm_common
.a922						z_asm_adc_zx:
.a922						xt_asm_adc_zxi:
.a922		a9 61		lda #$61	                lda #$61
.a924		4c 5a ac	jmp $ac5a	                jmp asm_common
.a927						z_asm_adc_zxi:
.a927						xt_asm_and:
.a927		a9 2d		lda #$2d	                lda #$2D
.a929		4c 5a ac	jmp $ac5a	                jmp asm_common
.a92c						z_asm_and:
.a92c						xt_asm_and_h:
.a92c		a9 29		lda #$29	                lda #$29
.a92e		4c 5a ac	jmp $ac5a	                jmp asm_common
.a931						z_asm_and_h:
.a931						xt_asm_and_x:
.a931		a9 3d		lda #$3d	                lda #$3D
.a933		4c 5a ac	jmp $ac5a	                jmp asm_common
.a936						z_asm_and_x:
.a936						xt_asm_and_y:
.a936		a9 39		lda #$39	                lda #$39
.a938		4c 5a ac	jmp $ac5a	                jmp asm_common
.a93b						z_asm_and_y:
.a93b						xt_asm_and_z:
.a93b		a9 25		lda #$25	                lda #$25
.a93d		4c 5a ac	jmp $ac5a	                jmp asm_common
.a940						z_asm_and_z:
.a940						xt_asm_and_zi:
.a940		a9 32		lda #$32	                lda #$32
.a942		4c 5a ac	jmp $ac5a	                jmp asm_common
.a945						z_asm_and_zi:
.a945						xt_asm_and_ziy:
.a945		a9 31		lda #$31	                lda #$31
.a947		4c 5a ac	jmp $ac5a	                jmp asm_common
.a94a						z_asm_and_ziy:
.a94a						xt_asm_and_zx:
.a94a		a9 35		lda #$35	                lda #$35
.a94c		4c 5a ac	jmp $ac5a	                jmp asm_common
.a94f						z_asm_and_zx:
.a94f						xt_asm_and_zxi:
.a94f		a9 21		lda #$21	                lda #$21
.a951		4c 5a ac	jmp $ac5a	                jmp asm_common
.a954						z_asm_and_zxi:
.a954						xt_asm_asl:
.a954		a9 0e		lda #$0e	                lda #$0E
.a956		4c 5a ac	jmp $ac5a	                jmp asm_common
.a959						z_asm_asl:
.a959						xt_asm_asl_a:
.a959		a9 0a		lda #$0a	                lda #$0A
.a95b		4c 5a ac	jmp $ac5a	                jmp asm_common
.a95e						z_asm_asl_a:
.a95e						xt_asm_asl_x:
.a95e		a9 1e		lda #$1e	                lda #$1E
.a960		4c 5a ac	jmp $ac5a	                jmp asm_common
.a963						z_asm_asl_x:
.a963						xt_asm_asl_z:
.a963		a9 06		lda #$06	                lda #$06
.a965		4c 5a ac	jmp $ac5a	                jmp asm_common
.a968						z_asm_asl_z:
.a968						xt_asm_asl_zx:
.a968		a9 16		lda #$16	                lda #$16
.a96a		4c 5a ac	jmp $ac5a	                jmp asm_common
.a96d						z_asm_asl_zx:
.a96d						xt_asm_bcc:
.a96d		a9 90		lda #$90	                lda #$90
.a96f		4c 5a ac	jmp $ac5a	                jmp asm_common
.a972						z_asm_bcc:
.a972						xt_asm_bcs:
.a972		a9 b0		lda #$b0	                lda #$B0
.a974		a0 02		ldy #$02	                ldy #2
.a976		4c 5a ac	jmp $ac5a	                jmp asm_common
.a979						z_asm_bcs:
.a979						xt_asm_beq:
.a979		a9 f0		lda #$f0	                lda #$F0
.a97b		4c 5a ac	jmp $ac5a	                jmp asm_common
.a97e						z_asm_beq:
.a97e						xt_asm_bit:
.a97e		a9 2c		lda #$2c	                lda #$2C
.a980		4c 5a ac	jmp $ac5a	                jmp asm_common
.a983						z_asm_bit:
.a983						xt_asm_bit_h:
.a983		a9 89		lda #$89	                lda #$89
.a985		4c 5a ac	jmp $ac5a	                jmp asm_common
.a988						z_asm_bit_h:
.a988						xt_asm_bit_x:
.a988		a9 3c		lda #$3c	                lda #$3C
.a98a		4c 5a ac	jmp $ac5a	                jmp asm_common
.a98d						z_asm_bit_x:
.a98d						xt_asm_bit_z:
.a98d		a9 24		lda #$24	                lda #$24
.a98f		4c 5a ac	jmp $ac5a	                jmp asm_common
.a992						z_asm_bit_z:
.a992						xt_asm_bit_zx:
.a992		a9 34		lda #$34	                lda #$34
.a994		4c 5a ac	jmp $ac5a	                jmp asm_common
.a997						z_asm_bit_zx:
.a997						xt_asm_bmi:
.a997		a9 30		lda #$30	                lda #$30
.a999		4c 5a ac	jmp $ac5a	                jmp asm_common
.a99c						z_asm_bmi:
.a99c						xt_asm_bne:
.a99c		a9 d0		lda #$d0	                lda #$D0
.a99e		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9a1						z_asm_bne:
.a9a1						xt_asm_bpl:
.a9a1		a9 10		lda #$10	                lda #$10
.a9a3		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9a6						z_asm_bpl:
.a9a6						xt_asm_bra:
.a9a6		a9 80		lda #$80	                lda #$80
.a9a8		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9ab						z_asm_bra:
.a9ab						xt_asm_brk:
.a9ab		a9 00		lda #$00	                lda #$00
.a9ad		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9b0						z_asm_brk:
.a9b0						xt_asm_bvc:
.a9b0		a9 50		lda #$50	                lda #$50
.a9b2		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9b5						z_asm_bvc:
.a9b5						xt_asm_bvs:
.a9b5		a9 70		lda #$70	                lda #$70
.a9b7		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9ba						z_asm_bvs:
.a9ba						xt_asm_clc:
.a9ba		a9 18		lda #$18	                lda #$18
.a9bc		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9bf						z_asm_clc:
.a9bf						xt_asm_cld:
.a9bf		a9 d8		lda #$d8	                lda #$D8
.a9c1		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9c4						z_asm_cld:
.a9c4						xt_asm_cli:
.a9c4		a9 58		lda #$58	                lda #$58
.a9c6		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9c9						z_asm_cli:
.a9c9						xt_asm_clv:
.a9c9		a9 b8		lda #$b8	                lda #$B8
.a9cb		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9ce						z_asm_clv:
.a9ce						xt_asm_cmp:
.a9ce		a9 cd		lda #$cd	                lda #$CD
.a9d0		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9d3						z_asm_cmp:
.a9d3						xt_asm_cmp_h:
.a9d3		a9 c9		lda #$c9	                lda #$C9
.a9d5		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9d8						z_asm_cmp_h:
.a9d8						xt_asm_cmp_x:
.a9d8		a9 dd		lda #$dd	                lda #$DD
.a9da		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9dd						z_asm_cmp_x:
.a9dd						xt_asm_cmp_y:
.a9dd		a9 d9		lda #$d9	                lda #$D9
.a9df		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9e2						z_asm_cmp_y:
.a9e2						xt_asm_cmp_z:
.a9e2		a9 c5		lda #$c5	                lda #$C5
.a9e4		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9e7						z_asm_cmp_z:
.a9e7						xt_asm_cmp_zi:
.a9e7		a9 d2		lda #$d2	                lda #$D2
.a9e9		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9ec						z_asm_cmp_zi:
.a9ec						xt_asm_cmp_ziy:
.a9ec		a9 d1		lda #$d1	                lda #$D1
.a9ee		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9f1						z_asm_cmp_ziy:
.a9f1						xt_asm_cmp_zx:
.a9f1		a9 d5		lda #$d5	                lda #$D5
.a9f3		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9f6						z_asm_cmp_zx:
.a9f6						xt_asm_cmp_zxi:
.a9f6		a9 c1		lda #$c1	                lda #$C1
.a9f8		4c 5a ac	jmp $ac5a	                jmp asm_common
.a9fb						z_asm_cmp_zxi:
.a9fb						xt_asm_cpx:
.a9fb		a9 ec		lda #$ec	                lda #$EC
.a9fd		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa00						z_asm_cpx:
.aa00						xt_asm_cpx_h:
.aa00		a9 e0		lda #$e0	                lda #$E0
.aa02		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa05						z_asm_cpx_h:
.aa05						xt_asm_cpx_z:
.aa05		a9 e4		lda #$e4	                lda #$E4
.aa07		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa0a						z_asm_cpx_z:
.aa0a						xt_asm_cpy:
.aa0a		a9 cc		lda #$cc	                lda #$CC
.aa0c		a0 03		ldy #$03	                ldy #3
.aa0e		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa11						z_asm_cpy:
.aa11						xt_asm_cpy_h:
.aa11		a9 c0		lda #$c0	                lda #$C0
.aa13		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa16						z_asm_cpy_h:
.aa16						xt_asm_cpy_z:
.aa16		a9 c4		lda #$c4	                lda #$C4
.aa18		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa1b						z_asm_cpy_z:
.aa1b						xt_asm_dec:
.aa1b		a9 ce		lda #$ce	                lda #$CE
.aa1d		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa20						z_asm_dec:
.aa20						xt_asm_dec_a:
.aa20		a9 3a		lda #$3a	                lda #$3A
.aa22		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa25						z_asm_dec_a:
.aa25						xt_asm_dec_x:
.aa25		a9 de		lda #$de	                lda #$DE
.aa27		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa2a						z_asm_dec_x:
.aa2a						xt_asm_dec_z:
.aa2a		a9 c6		lda #$c6	                lda #$C6
.aa2c		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa2f						z_asm_dec_z:
.aa2f						xt_asm_dec_zx:
.aa2f		a9 d6		lda #$d6	                lda #$D6
.aa31		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa34						z_asm_dec_zx:
.aa34						xt_asm_dex:
.aa34		a9 ca		lda #$ca	                lda #$CA
.aa36		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa39						z_asm_dex:
.aa39						xt_asm_dey:
.aa39		a9 88		lda #$88	                lda #$88
.aa3b		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa3e						z_asm_dey:
.aa3e						xt_asm_eor:
.aa3e		a9 4d		lda #$4d	                lda #$4D
.aa40		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa43						z_asm_eor:
.aa43						xt_asm_eor_h:
.aa43		a9 49		lda #$49	                lda #$49
.aa45		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa48						z_asm_eor_h:
.aa48						xt_asm_eor_x:
.aa48		a9 5d		lda #$5d	                lda #$5D
.aa4a		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa4d						z_asm_eor_x:
.aa4d						xt_asm_eor_y:
.aa4d		a9 59		lda #$59	                lda #$59
.aa4f		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa52						z_asm_eor_y:
.aa52						xt_asm_eor_z:
.aa52		a9 45		lda #$45	                lda #$45
.aa54		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa57						z_asm_eor_z:
.aa57						xt_asm_eor_zi:
.aa57		a9 52		lda #$52	                lda #$52
.aa59		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa5c						z_asm_eor_zi:
.aa5c						xt_asm_eor_ziy:
.aa5c		a9 51		lda #$51	                lda #$51
.aa5e		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa61						z_asm_eor_ziy:
.aa61						xt_asm_eor_zx:
.aa61		a9 55		lda #$55	                lda #$55
.aa63		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa66						z_asm_eor_zx:
.aa66						xt_asm_eor_zxi:
.aa66		a9 41		lda #$41	                lda #$41
.aa68		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa6b						z_asm_eor_zxi:
.aa6b						xt_asm_inc:
.aa6b		a9 ee		lda #$ee	                lda #$EE
.aa6d		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa70						z_asm_inc:
.aa70						xt_asm_inc_a:
.aa70		a9 1a		lda #$1a	                lda #$1A
.aa72		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa75						z_asm_inc_a:
.aa75						xt_asm_inc_x:
.aa75		a9 fe		lda #$fe	                lda #$FE
.aa77		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa7a						z_asm_inc_x:
.aa7a						xt_asm_inc_z:
.aa7a		a9 e6		lda #$e6	                lda #$E6
.aa7c		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa7f						z_asm_inc_z:
.aa7f						xt_asm_inc_zx:
.aa7f		a9 f6		lda #$f6	                lda #$F6
.aa81		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa84						z_asm_inc_zx:
.aa84						xt_asm_inx:
.aa84		a9 e8		lda #$e8	                lda #$E8
.aa86		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa89						z_asm_inx:
.aa89						xt_asm_iny:
.aa89		a9 c8		lda #$c8	                lda #$C8
.aa8b		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa8e						z_asm_iny:
.aa8e						xt_asm_jmp:
.aa8e		a9 4c		lda #$4c	                lda #$4C
.aa90		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa93						z_asm_jmp:
.aa93						xt_asm_jmp_i:
.aa93		a9 6c		lda #$6c	                lda #$6C
.aa95		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa98						z_asm_jmp_i:
.aa98						xt_asm_jmp_xi:
.aa98		a9 7c		lda #$7c	                lda #$7C
.aa9a		4c 5a ac	jmp $ac5a	                jmp asm_common
.aa9d						z_asm_jmp_xi:
.aa9d						xt_asm_jsr:
.aa9d		a9 20		lda #$20	                lda #$20
.aa9f		4c 5a ac	jmp $ac5a	                jmp asm_common
.aaa2						z_asm_jsr:
.aaa2						xt_asm_lda:
.aaa2		a9 ad		lda #$ad	                lda #$AD
.aaa4		4c 5a ac	jmp $ac5a	                jmp asm_common
.aaa7						z_asm_lda:
.aaa7						xt_asm_lda_h:
.aaa7		a9 a9		lda #$a9	                lda #$A9
.aaa9		4c 5a ac	jmp $ac5a	                jmp asm_common
.aaac						z_asm_lda_h:
.aaac						xt_asm_lda_x:
.aaac		a9 bd		lda #$bd	                lda #$BD
.aaae		4c 5a ac	jmp $ac5a	                jmp asm_common
.aab1						z_asm_lda_x:
.aab1						xt_asm_lda_y:
.aab1		a9 b9		lda #$b9	                lda #$B9
.aab3		4c 5a ac	jmp $ac5a	                jmp asm_common
.aab6						z_asm_lda_y:
.aab6						xt_asm_lda_z:
.aab6		a9 a5		lda #$a5	                lda #$A5
.aab8		4c 5a ac	jmp $ac5a	                jmp asm_common
.aabb						z_asm_lda_z:
.aabb						xt_asm_lda_zi:
.aabb		a9 b2		lda #$b2	                lda #$B2
.aabd		4c 5a ac	jmp $ac5a	                jmp asm_common
.aac0						z_asm_lda_zi:
.aac0						xt_asm_lda_ziy:
.aac0		a9 b1		lda #$b1	                lda #$B1
.aac2		4c 5a ac	jmp $ac5a	                jmp asm_common
.aac5						z_asm_lda_ziy:
.aac5						xt_asm_lda_zx:
.aac5		a9 b5		lda #$b5	                lda #$B5
.aac7		4c 5a ac	jmp $ac5a	                jmp asm_common
.aaca						z_asm_lda_zx:
.aaca						xt_asm_lda_zxi:
.aaca		a9 a1		lda #$a1	                lda #$A1
.aacc		4c 5a ac	jmp $ac5a	                jmp asm_common
.aacf						z_asm_lda_zxi:
.aacf						xt_asm_ldx:
.aacf		a9 ae		lda #$ae	                lda #$AE
.aad1		4c 5a ac	jmp $ac5a	                jmp asm_common
.aad4						z_asm_ldx:
.aad4						xt_asm_ldx_h:
.aad4		a9 a2		lda #$a2	                lda #$A2
.aad6		4c 5a ac	jmp $ac5a	                jmp asm_common
.aad9						z_asm_ldx_h:
.aad9						xt_asm_ldx_y:
.aad9		a9 be		lda #$be	                lda #$BE
.aadb		4c 5a ac	jmp $ac5a	                jmp asm_common
.aade						z_asm_ldx_y:
.aade						xt_asm_ldx_z:
.aade		a9 a6		lda #$a6	                lda #$A6
.aae0		4c 5a ac	jmp $ac5a	                jmp asm_common
.aae3						z_asm_ldx_z:
.aae3						xt_asm_ldx_zy:
.aae3		a9 b6		lda #$b6	                lda #$B6
.aae5		4c 5a ac	jmp $ac5a	                jmp asm_common
.aae8						z_asm_ldx_zy:
.aae8						xt_asm_ldy:
.aae8		a9 ac		lda #$ac	                lda #$AC
.aaea		4c 5a ac	jmp $ac5a	                jmp asm_common
.aaed						z_asm_ldy:
.aaed						xt_asm_ldy_h:
.aaed		a9 a0		lda #$a0	                lda #$A0
.aaef		4c 5a ac	jmp $ac5a	                jmp asm_common
.aaf2						z_asm_ldy_h:
.aaf2						xt_asm_ldy_x:
.aaf2		a9 bc		lda #$bc	                lda #$BC
.aaf4		4c 5a ac	jmp $ac5a	                jmp asm_common
.aaf7						z_asm_ldy_x:
.aaf7						xt_asm_ldy_z:
.aaf7		a9 a4		lda #$a4	                lda #$A4
.aaf9		4c 5a ac	jmp $ac5a	                jmp asm_common
.aafc						z_asm_ldy_z:
.aafc						xt_asm_ldy_zx:
.aafc		a9 b4		lda #$b4	                lda #$B4
.aafe		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab01						z_asm_ldy_zx:
.ab01						xt_asm_lsr:
.ab01		a9 4e		lda #$4e	                lda #$4E
.ab03		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab06						z_asm_lsr:
.ab06						xt_asm_lsr_a:
.ab06		a9 4a		lda #$4a	                lda #$4A
.ab08		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab0b						z_asm_lsr_a:
.ab0b						xt_asm_lsr_x:
.ab0b		a9 5e		lda #$5e	                lda #$5E
.ab0d		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab10						z_asm_lsr_x:
.ab10						xt_asm_lsr_z:
.ab10		a9 46		lda #$46	                lda #$46
.ab12		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab15						z_asm_lsr_z:
.ab15						xt_asm_lsr_zx:
.ab15		a9 56		lda #$56	                lda #$56
.ab17		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab1a						z_asm_lsr_zx:
.ab1a						xt_asm_nop:
.ab1a		a9 ea		lda #$ea	                lda #$EA
.ab1c		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab1f						z_asm_nop:
.ab1f						xt_asm_ora:
.ab1f		a9 0d		lda #$0d	                lda #$0D
.ab21		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab24						z_asm_ora:
.ab24						xt_asm_ora_h:
.ab24		a9 09		lda #$09	                lda #$09
.ab26		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab29						z_asm_ora_h:
.ab29						xt_asm_ora_x:
.ab29		a9 1d		lda #$1d	                lda #$1D
.ab2b		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab2e						z_asm_ora_x:
.ab2e						xt_asm_ora_y:
.ab2e		a9 19		lda #$19	                lda #$19
.ab30		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab33						z_asm_ora_y:
.ab33						xt_asm_ora_z:
.ab33		a9 05		lda #$05	                lda #$05
.ab35		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab38						z_asm_ora_z:
.ab38						xt_asm_ora_zi:
.ab38		a9 12		lda #$12	                lda #$12
.ab3a		a0 02		ldy #$02	                ldy #2
.ab3c		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab3f						z_asm_ora_zi:
.ab3f						xt_asm_ora_ziy:
.ab3f		a9 11		lda #$11	                lda #$11
.ab41		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab44						z_asm_ora_ziy:
.ab44						xt_asm_ora_zx:
.ab44		a9 15		lda #$15	                lda #$15
.ab46		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab49						z_asm_ora_zx:
.ab49						xt_asm_ora_zxi:
.ab49		a9 01		lda #$01	                lda #$01
.ab4b		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab4e						z_asm_ora_zxi:
.ab4e						xt_asm_pha:
.ab4e		a9 48		lda #$48	                lda #$48
.ab50		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab53						z_asm_pha:
.ab53						xt_asm_php:
.ab53		a9 08		lda #$08	                lda #$08
.ab55		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab58						z_asm_php:
.ab58						xt_asm_phx:
.ab58		a9 da		lda #$da	                lda #$DA
.ab5a		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab5d						z_asm_phx:
.ab5d						xt_asm_phy:
.ab5d		a9 5a		lda #$5a	                lda #$5A
.ab5f		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab62						z_asm_phy:
.ab62						xt_asm_pla:
.ab62		a9 68		lda #$68	                lda #$68
.ab64		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab67						z_asm_pla:
.ab67						xt_asm_plp:
.ab67		a9 28		lda #$28	                lda #$28
.ab69		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab6c						z_asm_plp:
.ab6c						xt_asm_plx:
.ab6c		a9 fa		lda #$fa	                lda #$FA
.ab6e		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab71						z_asm_plx:
.ab71						xt_asm_ply:
.ab71		a9 7a		lda #$7a	                lda #$7A
.ab73		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab76						z_asm_ply:
.ab76						xt_asm_rol:
.ab76		a9 2e		lda #$2e	                lda #$2E
.ab78		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab7b						z_asm_rol:
.ab7b						xt_asm_rol_a:
.ab7b		a9 2a		lda #$2a	                lda #$2A
.ab7d		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab80						z_asm_rol_a:
.ab80						xt_asm_rol_x:
.ab80		a9 3e		lda #$3e	                lda #$3E
.ab82		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab85						z_asm_rol_x:
.ab85						xt_asm_rol_z:
.ab85		a9 26		lda #$26	                lda #$26
.ab87		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab8a						z_asm_rol_z:
.ab8a						xt_asm_rol_zx:
.ab8a		a9 36		lda #$36	                lda #$36
.ab8c		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab8f						z_asm_rol_zx:
.ab8f						xt_asm_ror:
.ab8f		a9 6e		lda #$6e	                lda #$6E
.ab91		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab94						z_asm_ror:
.ab94						xt_asm_ror_a:
.ab94		a9 6a		lda #$6a	                lda #$6A
.ab96		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab99						z_asm_ror_a:
.ab99						xt_asm_ror_x:
.ab99		a9 7e		lda #$7e	                lda #$7E
.ab9b		4c 5a ac	jmp $ac5a	                jmp asm_common
.ab9e						z_asm_ror_x:
.ab9e						xt_asm_ror_z:
.ab9e		a9 66		lda #$66	                lda #$66
.aba0		4c 5a ac	jmp $ac5a	                jmp asm_common
.aba3						z_asm_ror_z:
.aba3						xt_asm_ror_zx:
.aba3		a9 76		lda #$76	                lda #$76
.aba5		4c 5a ac	jmp $ac5a	                jmp asm_common
.aba8						z_asm_ror_zx:
.aba8						xt_asm_rti:
.aba8		a9 40		lda #$40	                lda #$40
.abaa		4c 5a ac	jmp $ac5a	                jmp asm_common
.abad						z_asm_rti:
.abad						xt_asm_rts:
.abad		a9 60		lda #$60	                lda #$60
.abaf		4c 5a ac	jmp $ac5a	                jmp asm_common
.abb2						z_asm_rts:
.abb2						xt_asm_sbc:
.abb2		a9 ed		lda #$ed	                lda #$ED
.abb4		4c 5a ac	jmp $ac5a	                jmp asm_common
.abb7						z_asm_sbc:
.abb7						xt_asm_sbc_h:
.abb7		a9 e9		lda #$e9	                lda #$E9
.abb9		4c 5a ac	jmp $ac5a	                jmp asm_common
.abbc						z_asm_sbc_h:
.abbc						xt_asm_sbc_x:
.abbc		a9 fd		lda #$fd	                lda #$FD
.abbe		4c 5a ac	jmp $ac5a	                jmp asm_common
.abc1						z_asm_sbc_x:
.abc1						xt_asm_sbc_y:
.abc1		a9 f9		lda #$f9	                lda #$F9
.abc3		4c 5a ac	jmp $ac5a	                jmp asm_common
.abc6						z_asm_sbc_y:
.abc6						xt_asm_sbc_z:
.abc6		a9 e5		lda #$e5	                lda #$E5
.abc8		4c 5a ac	jmp $ac5a	                jmp asm_common
.abcb						z_asm_sbc_z:
.abcb						xt_asm_sbc_zi:
.abcb		a9 f2		lda #$f2	                lda #$F2
.abcd		4c 5a ac	jmp $ac5a	                jmp asm_common
.abd0						z_asm_sbc_zi:
.abd0						xt_asm_sbc_ziy:
.abd0		a9 f1		lda #$f1	                lda #$F1
.abd2		4c 5a ac	jmp $ac5a	                jmp asm_common
.abd5						z_asm_sbc_ziy:
.abd5						xt_asm_sbc_zx:
.abd5		a9 f5		lda #$f5	                lda #$F5
.abd7		4c 5a ac	jmp $ac5a	                jmp asm_common
.abda						z_asm_sbc_zx:
.abda						xt_asm_sbc_zxi:
.abda		a9 e1		lda #$e1	                lda #$E1
.abdc		80 7c		bra $ac5a	                bra asm_common  ; <-- limit for BRA instead of JMP
.abde						z_asm_sbc_zxi:
.abde						xt_asm_sec:
.abde		a9 38		lda #$38	                lda #$38
.abe0		80 78		bra $ac5a	                bra asm_common
.abe2						z_asm_sec:
.abe2						xt_asm_sed:
.abe2		a9 f8		lda #$f8	                lda #$F8
.abe4		80 74		bra $ac5a	                bra asm_common
.abe6						z_asm_sed:
.abe6						xt_asm_sei:
.abe6		a9 78		lda #$78	                lda #$78
.abe8		80 70		bra $ac5a	                bra asm_common
.abea						z_asm_sei:
.abea						xt_asm_sta:
.abea		a9 8d		lda #$8d	                lda #$8D
.abec		80 6c		bra $ac5a	                bra asm_common
.abee						z_asm_sta:
.abee						xt_asm_sta_x:
.abee		a9 9d		lda #$9d	                lda #$9D
.abf0		80 68		bra $ac5a	                bra asm_common
.abf2						z_asm_sta_x:
.abf2						xt_asm_sta_y:
.abf2		a9 99		lda #$99	                lda #$99
.abf4		80 64		bra $ac5a	                bra asm_common
.abf6						z_asm_sta_y:
.abf6						xt_asm_sta_z:
.abf6		a9 85		lda #$85	                lda #$85
.abf8		80 60		bra $ac5a	                bra asm_common
.abfa						z_asm_sta_z:
.abfa						xt_asm_sta_zi:
.abfa		a9 92		lda #$92	                lda #$92
.abfc		80 5c		bra $ac5a	                bra asm_common
.abfe						z_asm_sta_zi:
.abfe						xt_asm_sta_ziy:
.abfe		a9 91		lda #$91	                lda #$91
.ac00		80 58		bra $ac5a	                bra asm_common
.ac02						z_asm_sta_ziy:
.ac02						xt_asm_sta_zx:
.ac02		a9 95		lda #$95	                lda #$95
.ac04		80 54		bra $ac5a	                bra asm_common
.ac06						z_asm_sta_zx:
.ac06						xt_asm_sta_zxi:
.ac06		a9 81		lda #$81	                lda #$81
.ac08		80 50		bra $ac5a	                bra asm_common
.ac0a						z_asm_sta_zxi:
.ac0a						xt_asm_stx:
.ac0a		a9 8e		lda #$8e	                lda #$8E
.ac0c		80 4c		bra $ac5a	                bra asm_common
.ac0e						z_asm_stx:
.ac0e						xt_asm_stx_z:
.ac0e		a9 86		lda #$86	                lda #$86
.ac10		80 48		bra $ac5a	                bra asm_common
.ac12						z_asm_stx_z:
.ac12						xt_asm_stx_zy:
.ac12		a9 96		lda #$96	                lda #$96
.ac14		80 44		bra $ac5a	                bra asm_common
.ac16						z_asm_stx_zy:
.ac16						xt_asm_sty:
.ac16		a9 8c		lda #$8c	                lda #$8C
.ac18		80 40		bra $ac5a	                bra asm_common
.ac1a						z_asm_sty:
.ac1a						xt_asm_sty_z:
.ac1a		a9 84		lda #$84	                lda #$84
.ac1c		80 3c		bra $ac5a	                bra asm_common
.ac1e						z_asm_sty_z:
.ac1e						xt_asm_sty_zx:
.ac1e		a9 94		lda #$94	                lda #$94
.ac20		80 38		bra $ac5a	                bra asm_common
.ac22						z_asm_sty_zx:
.ac22						xt_asm_stz:
.ac22		a9 9c		lda #$9c	                lda #$9C
.ac24		80 34		bra $ac5a	                bra asm_common
.ac26						z_asm_stz:
.ac26						xt_asm_stz_x:
.ac26		a9 9e		lda #$9e	                lda #$9E
.ac28		80 30		bra $ac5a	                bra asm_common
.ac2a						z_asm_stz_x:
.ac2a						xt_asm_stz_z:
.ac2a		a9 64		lda #$64	                lda #$64
.ac2c		80 2c		bra $ac5a	                bra asm_common
.ac2e						z_asm_stz_z:
.ac2e						xt_asm_stz_zx:
.ac2e		a9 74		lda #$74	                lda #$74
.ac30		80 28		bra $ac5a	                bra asm_common
.ac32						z_asm_stz_zx:
.ac32						xt_asm_tax:
.ac32		a9 aa		lda #$aa	                lda #$AA
.ac34		80 24		bra $ac5a	                bra asm_common
.ac36						z_asm_tax:
.ac36						xt_asm_tay:
.ac36		a9 a8		lda #$a8	                lda #$A8
.ac38		80 20		bra $ac5a	                bra asm_common
.ac3a						z_asm_tay:
.ac3a						xt_asm_trb:
.ac3a		a9 1c		lda #$1c	                lda #$1C
.ac3c		80 1c		bra $ac5a	                bra asm_common
.ac3e						z_asm_trb:
.ac3e						xt_asm_trb_z:
.ac3e		a9 14		lda #$14	                lda #$14
.ac40		80 18		bra $ac5a	                bra asm_common
.ac42						z_asm_trb_z:
.ac42						xt_asm_tsb:
.ac42		a9 0c		lda #$0c	                lda #$0C
.ac44		80 14		bra $ac5a	                bra asm_common
.ac46						z_asm_tsb:
.ac46						xt_asm_tsb_z:
.ac46		a9 04		lda #$04	                lda #$04
.ac48		80 10		bra $ac5a	                bra asm_common
.ac4a						z_asm_tsb_z:
.ac4a						xt_asm_tsx:
.ac4a		a9 ba		lda #$ba	                lda #$BA
.ac4c		80 0c		bra $ac5a	                bra asm_common
.ac4e						z_asm_tsx:
.ac4e						xt_asm_txa:
.ac4e		a9 8a		lda #$8a	                lda #$8A
.ac50		80 08		bra $ac5a	                bra asm_common
.ac52						z_asm_txa:
.ac52						xt_asm_txs:
.ac52		a9 9a		lda #$9a	                lda #$9A
.ac54		80 04		bra $ac5a	                bra asm_common
.ac56						z_asm_txs:
.ac56						xt_asm_tya:
.ac56		a9 98		lda #$98	                lda #$98
.ac58		80 00		bra $ac5a	                bra asm_common
.ac5a						z_asm_tya:
.ac5a						asm_common:
.ac5a		a8		tay		                tay
.ac5b		20 1c d7	jsr $d71c	                jsr cmpl_a
.ac5e		a9 0a		lda #$0a	                lda #<oc_index_table
.ac60		85 27		sta $27		                sta tmp2
.ac62		a9 af		lda #$af	                lda #>oc_index_table
.ac64		85 28		sta $28		                sta tmp2+1
.ac66		98		tya		                tya             ; retrieve opcode
.ac67		0a		asl a		                asl             ; times two for offset
.ac68		90 02		bcc $ac6c	                bcc +
.ac6a		e6 28		inc $28		                inc tmp2+1
.ac6c						+
.ac6c		a8		tay		                tay             ; use Y as the index
.ac6d		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.ac6f		85 29		sta $29		                sta tmp3
.ac71		c8		iny		                iny
.ac72		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.ac74		85 2a		sta $2a		                sta tmp3+1
.ac76		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.ac78		2a		rol a		                rol
.ac79		2a		rol a		                rol
.ac7a		2a		rol a		                rol             ; Three times because we go through Carry
.ac7b		29 03		and #$03	                and #%00000011
.ac7d		a8		tay		                tay
.ac7e		88		dey		                dey
.ac7f		f0 12		beq $ac93	                beq _done
.ac81		20 73 d8	jsr $d873	                jsr underflow_1
.ac84		b5 00		lda $00,x	                lda 0,x
.ac86		20 1c d7	jsr $d71c	                jsr cmpl_a      ; does not use Y
.ac89		88		dey		                dey
.ac8a		f0 05		beq $ac91	                beq _done_drop
.ac8c		b5 01		lda $01,x	                lda 1,x
.ac8e		20 1c d7	jsr $d71c	                jsr cmpl_a      ; Fall through to _done_drop
.ac91						_done_drop:
.ac91		e8		inx		                inx
.ac92		e8		inx		                inx             ; Fall through to _done
.ac93						_done:
.ac93		60		rts		                rts             ; Returns to original caller
.ac94						xt_asm_push_a:
.ac94		a0 00		ldy #$00	                ldy #0
.ac96						_loop:
.ac96		b9 a4 ac	lda $aca4,y	                lda asm_push_a_data,y
.ac99		c9 ff		cmp #$ff	                cmp #$FF
.ac9b		f0 06		beq $aca3	                beq _done
.ac9d		20 1c d7	jsr $d71c	                jsr cmpl_a      ; does not change Y
.aca0		c8		iny		                iny
.aca1		80 f3		bra $ac96	                bra _loop
.aca3						_done:
.aca3						z_asm_push_a:
.aca3		60		rts		                rts
.aca4						asm_push_a_data:
>aca4		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acaa		ff				        .byte $FF               ; terminator
.acab						xt_asm_back_jump:
.acab						z_asm_back_jump:
.acab		60		rts		                rts
.acac						xt_asm_back_branch:
.acac		20 24 91	jsr $9124	                jsr xt_here             ; ( addr-l addr-h )
.acaf		20 25 95	jsr $9525	                jsr xt_minus            ; ( offset )
.acb2		3a		dec a		                dea
.acb3		3a		dec a		                dea
.acb4						z_asm_back_branch:
.acb4		60		rts		                rts
.acb5						assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acb5						disassembler:
.acb5		20 fb 88	jsr $88fb	                jsr xt_cr       ; ( addr u )
.acb8						_byte_loop:
.acb8		20 5f 98	jsr $985f	                jsr xt_over     ; ( addr u addr )
.acbb		20 a9 a4	jsr $a4a9	                jsr xt_u_dot    ; ( addr u )
.acbe		20 a9 a0	jsr $a0a9	                jsr xt_space
.acc1		a9 0a		lda #$0a	                lda #<oc_index_table
.acc3		85 27		sta $27		                sta tmp2
.acc5		a9 af		lda #$af	                lda #>oc_index_table
.acc7		85 28		sta $28		                sta tmp2+1
.acc9		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.accb		85 2d		sta $2d		                sta scratch     ; Save opcode
.accd		0a		asl a		                asl             ; multiply by two for offset
.acce		90 02		bcc $acd2	                bcc +
.acd0		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.acd2						+
.acd2		a8		tay		                tay             ; use Y as the index
.acd3		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.acd5		85 29		sta $29		                sta tmp3
.acd7		48		pha		                pha
.acd8		c8		iny		                iny
.acd9		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.acdb		85 2a		sta $2a		                sta tmp3+1
.acdd		48		pha		                pha
.acde		b2 29		lda ($29)	                lda (tmp3)
.ace0		a8		tay		                tay                     ; save copy of lengths byte
.ace1		10 3c		bpl $ad1f	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.ace3		20 36 a7	jsr $a736	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ace6		f6 04		inc $04,x	                inc 4,x
.ace8		d0 02		bne $acec	                bne +
.acea		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.acec						+
.acec		b5 02		lda $02,x	                lda 2,x
.acee		d0 02		bne $acf2	                bne +
.acf0		d6 03		dec $03,x	                dec 3,x
.acf2						+
.acf2		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.acf4		a1 04		lda ($04,x)	                lda (4,x)
.acf6		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.acf8		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.acfa		98		tya		                tya                     ; retrieve copy of lengths byte
.acfb		2a		rol a		                rol                     ; shift bit 6 to bit 7
.acfc		10 14		bpl $ad12	                bpl _print_operand
.acfe		f6 04		inc $04,x	                inc 4,x
.ad00		d0 02		bne $ad04	                bne +
.ad02		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad04						+
.ad04		b5 02		lda $02,x	                lda 2,x
.ad06		d0 02		bne $ad0a	                bne +
.ad08		d6 03		dec $03,x	                dec 3,x
.ad0a						+
.ad0a		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad0c		a1 04		lda ($04,x)	                lda (4,x)
.ad0e		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad10		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.ad12						_print_operand:
.ad12		ca		dex		                dex
.ad13		ca		dex		                dex
.ad14		a9 05		lda #$05	                lda #5
.ad16		95 00		sta $00,x	                sta 0,x
.ad18		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad1a		20 b5 a4	jsr $a4b5	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad1d		80 0b		bra $ad2a	                bra _print_mnemonic
.ad1f						_no_operand:
.ad1f		ca		dex		                dex
.ad20		ca		dex		                dex
.ad21		a9 05		lda #$05	                lda #5
.ad23		95 00		sta $00,x	                sta 0,x
.ad25		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad27		20 af a0	jsr $a0af	                jsr xt_spaces           ; ( addr u )
.ad2a						_print_mnemonic:
.ad2a		20 a9 a0	jsr $a0a9	                jsr xt_space
.ad2d		ca		dex		                dex
.ad2e		ca		dex		                dex                     ; ( addr u ? )
.ad2f		68		pla		                pla                     ; MSB
.ad30		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad32		68		pla		                pla                     ; LSB
.ad33		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad35		20 e7 88	jsr $88e7	                jsr xt_count            ; ( addr u addr-o u-o )
.ad38		74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad3a		b5 00		lda $00,x	                lda 0,x
.ad3c		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad3e		95 00		sta $00,x	                sta 0,x
.ad40		20 7e a4	jsr $a47e	                jsr xt_type             ; ( addr u )
.ad43		a5 2d		lda $2d		                lda scratch
.ad45		c9 20		cmp #$20	                cmp #$20
.ad47		d0 4e		bne $ad97	                bne _not_jsr
.ad49		ca		dex		                dex
.ad4a		ca		dex		                dex
.ad4b		a9 05		lda #$05	                lda #5
.ad4d		95 00		sta $00,x	                sta 0,x
.ad4f		74 01		stz $01,x	                stz 1,x
.ad51		20 af a0	jsr $a0af	                jsr xt_spaces
.ad54		a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.ad56		b9 83 ad	lda $ad83,y	_check_handler: lda _special_handlers,y
.ad59		c5 2e		cmp $2e		                cmp scratch+1
.ad5b		d0 07		bne $ad64	                bne _next_handler
.ad5d		b9 84 ad	lda $ad84,y	                lda _special_handlers+1,y
.ad60		c5 2f		cmp $2f		                cmp scratch+2
.ad62		f0 0c		beq $ad70	                beq _run_handler
.ad64		88		dey		_next_handler:  dey
.ad65		88		dey		                dey
.ad66		88		dey		                dey
.ad67		88		dey		                dey
.ad68		10 ec		bpl $ad56	                bpl _check_handler
.ad6a						_not_special:
.ad6a		20 ba ae	jsr $aeba	                jsr disasm_jsr
.ad6d		4c 01 ae	jmp $ae01	                jmp _printing_done
.ad70						_run_handler:
.ad70		b9 85 ad	lda $ad85,y	                lda _special_handlers+2,y
.ad73		85 30		sta $30		                sta scratch+3
.ad75		b9 86 ad	lda $ad86,y	                lda _special_handlers+3,y
.ad78		85 31		sta $31		                sta scratch+4
.ad7a		20 80 ad	jsr $ad80	                jsr _dispatch_handler
.ad7d		4c 01 ae	jmp $ae01	                jmp _printing_done
.ad80						_dispatch_handler:
.ad80		6c 30 00	jmp ($0030)	                jmp (scratch+3)
.ad83						_special_handlers:
>ad83		5c 93 9c ae			    .word literal_runtime,      disasm_literal
>ad87		34 a0 47 ae			    .word sliteral_runtime,     disasm_sliteral
>ad8b		cb 91 7e ae			    .word zero_branch_runtime,  disasm_0branch
>ad8f		c1 91 8a ae			    .word zero_test_runtime,    disasm_0test
>ad93		42 8b 92 ae			    .word do_runtime,           disasm_do
.ad97						_end_handlers:
.ad97						_not_jsr:
.ad97		c9 4c		cmp #$4c	                cmp #$4C
.ad99		d0 2c		bne $adc7	                bne _not_jmp
.ad9b		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.ad9d		85 30		sta $30		                sta scratch+3
.ad9f		a5 2f		lda $2f		                lda scratch+2
.ada1		85 31		sta $31		                sta scratch+4
.ada3		b2 30		lda ($30)	                lda (scratch+3)
.ada5		c9 20		cmp #$20	                cmp #$20 ; check for JSR
.ada7		d0 58		bne $ae01	                bne _printing_done
.ada9		e6 30		inc $30		                inc scratch+3
.adab		d0 02		bne $adaf	                bne +
.adad		e6 31		inc $31		                inc scratch+4
.adaf						+
.adaf		b2 30		lda ($30)	                lda (scratch+3)
.adb1		c9 34		cmp #$34	                cmp #<sliteral_runtime
.adb3		d0 4c		bne $ae01	                bne _printing_done
.adb5		e6 30		inc $30		                inc scratch+3
.adb7		d0 02		bne $adbb	                bne +
.adb9		e6 31		inc $31		                inc scratch+4
.adbb						+
.adbb		b2 30		lda ($30)	                lda (scratch+3)
.adbd		c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.adbf		d0 40		bne $ae01	                bne _printing_done
.adc1		20 1d ae	jsr $ae1d	                jsr disasm_sliteral_jump
.adc4		4c 01 ae	jmp $ae01	                jmp _printing_done
.adc7						_not_jmp:
.adc7		c9 80		cmp #$80	                cmp #$80            ; is it bra?
.adc9		f0 06		beq $add1	                beq _is_rel
.adcb		29 1f		and #$1f	                and #$1f
.adcd		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.adcf		d0 30		bne $ae01	                bne _printing_done
.add1						_is_rel:
.add1		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.add3		ca		dex		                dex
.add4		ca		dex		                dex
.add5		74 01		stz $01,x	                stz 1,x
.add7		a5 2e		lda $2e		                lda scratch+1
.add9		95 00		sta $00,x	                sta 0,x
.addb		10 04		bpl $ade1	                bpl +
.addd		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.addf		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.ade1		38		sec		+               sec                 ; start counting from address after opcode
.ade2		75 04		adc $04,x	                adc 4,x
.ade4		95 00		sta $00,x	                sta 0,x
.ade6		b5 01		lda $01,x	                lda 1,x
.ade8		75 05		adc $05,x	                adc 5,x
.adea		95 01		sta $01,x	                sta 1,x
.adec		5a		phy		                phy                 ; save the direction indicator
.aded		ca		dex		                dex
.adee		ca		dex		                dex
.adef		a9 09		lda #$09	                lda #9
.adf1		95 00		sta $00,x	                sta 0,x
.adf3		74 01		stz $01,x	                stz 1,x
.adf5		20 b5 a4	jsr $a4b5	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.adf8		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.adfa		20 a8 8d	jsr $8da8	                jsr emit_a
.adfd		68		pla		                pla
.adfe		20 a8 8d	jsr $8da8	                jsr emit_a
.ae01						_printing_done:
.ae01		20 fb 88	jsr $88fb	                jsr xt_cr
.ae04		f6 02		inc $02,x	                inc 2,x
.ae06		d0 02		bne $ae0a	                bne +
.ae08		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae0a						+
.ae0a		20 dd 97	jsr $97dd	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae0d		b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae0f		15 01		ora $01,x	                ora 1,x
.ae11		f0 07		beq $ae1a	                beq _done
.ae13		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae15		30 03		bmi $ae1a	                bmi _done
.ae17		4c b8 ac	jmp $acb8	                jmp _byte_loop          ; out of range for BRA
.ae1a						_done:
.ae1a		4c 2b a3	jmp $a32b	                jmp xt_two_drop         ; JSR/RTS
.ae1d						disasm_sliteral_jump:
.ae1d		20 33 a1	jsr $a133	                jsr xt_swap
.ae20		ca		dex		                dex
.ae21		ca		dex		                dex
.ae22		a5 2e		lda $2e		                lda scratch+1
.ae24		95 00		sta $00,x	                sta 0,x
.ae26		a5 2f		lda $2f		                lda scratch+2
.ae28		95 01		sta $01,x	                sta 1,x
.ae2a		20 33 a1	jsr $a133	                jsr xt_swap
.ae2d		20 25 95	jsr $9525	                jsr xt_minus
.ae30		20 dd 97	jsr $97dd	                jsr xt_one_minus
.ae33		20 25 95	jsr $9525	                jsr xt_minus
.ae36		ca		dex		                dex
.ae37		ca		dex		                dex
.ae38		a5 2e		lda $2e		                lda scratch+1
.ae3a		95 00		sta $00,x	                sta 0,x
.ae3c		a5 2f		lda $2f		                lda scratch+2
.ae3e		95 01		sta $01,x	                sta 1,x
.ae40		20 dd 97	jsr $97dd	                jsr xt_one_minus
.ae43		20 33 a1	jsr $a133	                jsr xt_swap ; ( new_addr new_n )
.ae46		60		rts		                rts
.ae47						disasm_sliteral:
.ae47		a9 53		lda #$53	                lda #'S'
.ae49		20 a8 8d	jsr $8da8	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae4c		a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.ae4e		20 af d8	jsr $d8af	                jsr print_string_no_lf
.ae51		20 33 a1	jsr $a133	                jsr xt_swap             ; switch to (u addr)
.ae54		20 e9 97	jsr $97e9	                jsr xt_one_plus
.ae57		20 2f 8d	jsr $8d2f	                jsr xt_dup
.ae5a		20 32 8f	jsr $8f32	                jsr xt_fetch
.ae5d		20 a9 a4	jsr $a4a9	                jsr xt_u_dot            ; Print the address of the string
.ae60		20 22 a3	jsr $a322	                jsr xt_two
.ae63		20 af 99	jsr $99af	                jsr xt_plus
.ae66		20 2f 8d	jsr $8d2f	                jsr xt_dup
.ae69		20 2e 9a	jsr $9a2e	                jsr xt_question         ; Print the length of the string
.ae6c		20 e9 97	jsr $97e9	                jsr xt_one_plus
.ae6f		20 33 a1	jsr $a133	                jsr xt_swap            ; ( addr+4 u )
.ae72		ca		dex		                dex
.ae73		ca		dex		                dex
.ae74		a9 04		lda #$04	                lda #4
.ae76		95 00		sta $00,x	                sta 0,x
.ae78		74 01		stz $01,x	                stz 1,x
.ae7a		20 25 95	jsr $9525	                jsr xt_minus            ; ( addr+4 u-4 )
.ae7d		60		rts		                rts
.ae7e						disasm_0branch:
.ae7e		a9 30		lda #$30	                lda #'0'
.ae80		20 a8 8d	jsr $8da8	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae83						disasm_branch:
.ae83		a9 0e		lda #$0e	                lda #str_disasm_bra
.ae85		20 af d8	jsr $d8af	                jsr print_string_no_lf ; "BRANCH "
.ae88		80 17		bra $aea1	                bra disasm_print_literal
.ae8a						disasm_0test:
.ae8a		a9 0f		lda #$0f	                lda #str_disasm_0test
.ae8c		20 af d8	jsr $d8af	                jsr print_string_no_lf
.ae8f		4c a8 8d	jmp $8da8	                jmp emit_a
.ae92						disasm_do:
.ae92		a9 44		lda #$44	                lda #'D'
.ae94		20 a8 8d	jsr $8da8	                jsr emit_a
.ae97		a9 4f		lda #$4f	                lda #'O'
.ae99		4c a8 8d	jmp $8da8	                jmp emit_a
.ae9c						disasm_literal:
.ae9c		a9 0c		lda #$0c	                lda #str_disasm_lit
.ae9e		20 af d8	jsr $d8af	                jsr print_string_no_lf ; "LITERAL "
.aea1						disasm_print_literal:
.aea1		20 33 a1	jsr $a133	                jsr xt_swap ; switch to (u addr)
.aea4		20 e9 97	jsr $97e9	                jsr xt_one_plus
.aea7		20 2f 8d	jsr $8d2f	                jsr xt_dup
.aeaa		20 2e 9a	jsr $9a2e	                jsr xt_question ; Print the value at the address
.aead		20 e9 97	jsr $97e9	                jsr xt_one_plus
.aeb0		20 33 a1	jsr $a133	                jsr xt_swap ; (addr+2 u)
.aeb3		20 dd 97	jsr $97dd	                jsr xt_one_minus
.aeb6		20 dd 97	jsr $97dd	                jsr xt_one_minus ; (addr+2 u-2)
.aeb9		60		rts		                rts
.aeba						disasm_jsr:
.aeba		ca		dex		                dex
.aebb		ca		dex		                dex
.aebc		a5 2e		lda $2e		                lda scratch+1
.aebe		95 00		sta $00,x	                sta 0,x
.aec0		a5 2f		lda $2f		                lda scratch+2
.aec2		95 01		sta $01,x	                sta 1,x
.aec4		20 23 92	jsr $9223	                jsr xt_int_to_name
.aec7		b5 00		lda $00,x	                lda 0,x
.aec9		15 01		ora $01,x	                ora 1,x
.aecb		f0 07		beq $aed4	                beq _disasm_no_nt
.aecd		20 d3 95	jsr $95d3	                jsr xt_name_to_string
.aed0		20 7e a4	jsr $a47e	                jsr xt_type
.aed3		60		rts		                rts
.aed4						_disasm_no_nt:
.aed4		20 ae 8c	jsr $8cae	                jsr xt_drop ; the 0 indicating no name token
.aed7		ca		dex		                dex
.aed8		ca		dex		                dex
.aed9		a5 2e		lda $2e		                lda scratch+1
.aedb		95 00		sta $00,x	                sta 0,x
.aedd		a5 2f		lda $2f		                lda scratch+2
.aedf		95 01		sta $01,x	                sta 1,x
.aee1		ca		dex		                dex
.aee2		ca		dex		                dex
.aee3		a9 73		lda #$73	                lda #<underflow_1
.aee5		95 00		sta $00,x	                sta 0,x
.aee7		a9 d8		lda #$d8	                lda #>underflow_1
.aee9		95 01		sta $01,x	                sta 1,x
.aeeb		20 9f d7	jsr $d79f	                jsr compare_16bit
.aeee		f0 02		beq $aef2	                beq _disasm_jsr_uflow_check_upper
.aef0		b0 14		bcs $af06	                bcs _disasm_jsr_unknown
.aef2						_disasm_jsr_uflow_check_upper:
.aef2		a9 82		lda #$82	                lda #<underflow_4
.aef4		95 00		sta $00,x	                sta 0,x
.aef6		a9 d8		lda #$d8	                lda #>underflow_4
.aef8		95 01		sta $01,x	                sta 1,x
.aefa		20 9f d7	jsr $d79f	                jsr compare_16bit
.aefd		f0 02		beq $af01	                beq _disasm_jsr_soc
.aeff		90 05		bcc $af06	                bcc _disasm_jsr_unknown
.af01						_disasm_jsr_soc:
.af01		a9 0d		lda #$0d	                lda #str_disasm_sdc
.af03		20 af d8	jsr $d8af	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.af06						_disasm_jsr_unknown:
.af06		20 2b a3	jsr $a32b	                jsr xt_two_drop
.af09		60		rts		                rts
.af0a						oc_index_table:
>af0a		0a b1 0e b1 a2 b5 a2 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>af12		16 b1 1c b1 22 b1 a2 b5
>af1a		28 b1 2c b1 32 b1 a2 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af22		38 b1 3c b1 40 b1 44 b1
>af2a		49 b1 4d b1 55 b1 a2 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af32		5c b1 62 b1 69 b1 70 b1
>af3a		77 b1 7b b1 81 b1 a2 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af42		87 b1 8b b1 a2 b5 91 b1
>af4a		97 b1 9b b1 a2 b5 a2 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af52		a3 b1 a9 b1 af b1 b5 b1
>af5a		bc b1 c0 b1 c6 b1 a2 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af62		cc b1 d0 b1 d5 b1 d9 b1
>af6a		de b1 e2 b1 ea b1 a2 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af72		f1 b1 f9 b1 00 b2 07 b2
>af7a		0e b2 12 b2 18 b2 a2 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af82		1e b2 24 b2 2a b2 44 b1
>af8a		35 b2 39 b2 a2 b5 a2 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af92		a2 b5 41 b2 47 b2 4d b2
>af9a		54 b2 58 b2 5e b2 a2 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>afa2		64 b2 68 b2 6c b2 70 b2
>afaa		75 b2 79 b2 81 b2 a2 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>afb2		a2 b5 88 b2 8f b2 96 b2
>afba		9d b2 a1 b2 a7 b2 a2 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>afc2		a2 b5 a2 b5 b1 b2 b7 b2
>afca		bc b2 c0 b2 a2 b5 a2 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>afd2		c8 b2 ce b2 d4 b2 da b2
>afda		e1 b2 e5 b2 eb b2 a2 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afe2		f1 b2 f7 b2 fb b2 ff b2
>afea		04 b3 08 b3 10 b3 a2 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>aff2		17 b3 1e b3 25 b3 2c b3
>affa		33 b3 37 b3 3d b3 a2 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>b002		41 b3 48 b3 4e b3 54 b3
>b00a		59 b3 5d b3 a2 b5 a2 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b012		65 b3 6b b3 71 b3 a2 b5
>b01a		77 b3 7b b3 81 b3 a2 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b022		85 b3 89 b3 8d b3 91 b3
>b02a		96 b3 9a b3 a2 b3 a2 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b032		a9 b3 b0 b3 b7 b3 be b3
>b03a		c5 b3 c9 b3 cf b3 a2 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b042		d3 b3 d7 b3 dd b3 e3 b3
>b04a		e8 b3 ee b3 f6 b3 a2 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b052		fc b3 02 b4 08 b4 0e b4
>b05a		15 b4 19 b4 1f b4 a2 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b062		23 b4 27 b4 2b b4 2f b4
>b06a		34 b4 38 b4 40 b4 a2 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b072		47 b4 4e b4 55 b4 5c b4
>b07a		63 b4 67 b4 6d b4 a2 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b082		71 b4 77 b4 7d b4 83 b4
>b08a		88 b4 8e b4 a2 b5 a2 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b092		96 b4 9c b4 a2 b4 a8 b4
>b09a		af b4 b3 b4 b9 b4 a2 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b0a2		bd b4 c1 b4 c5 b4 c9 b4
>b0aa		ce b4 d2 b4 da b4 a2 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b0b2		a2 b5 e1 b4 e8 b4 ef b4
>b0ba		f6 b4 fa b4 00 b5 a2 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0c2		a2 b5 04 b5 0a b5 10 b5
>b0ca		15 b5 1b b5 a2 b5 a2 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0d2		23 b5 29 b5 2f b5 35 b5
>b0da		3c b5 40 b5 46 b5 a2 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0e2		4a b5 4e b5 52 b5 56 b5
>b0ea		5b b5 5f b5 67 b5 a2 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b0f2		a2 b5 6e b5 75 b5 7c b5
>b0fa		83 b5 87 b5 8d b5 a2 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b102		a2 b5 91 b5 97 b5 9d b5
.b10a						oc_table:
>b10a		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b10e		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b116		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b11c		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b122		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b128		43 70 68 70				oc08:	.text 1*64+3, "php"
>b12c		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b132		45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b138		c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b13c		c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b140		c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b144		c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b149		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b14d		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b155		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b15c		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b162		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b169		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b170		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b177		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b17b		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b181		45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b187		c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b18b		c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b191		c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b197		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b19b		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b1a3		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b1a9		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b1af		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b1b5		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1bc		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1c0		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1c6		45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1cc		c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b1d0		c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1d5		c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1d9		c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1de		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1e2		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b1ea		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b1f1		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b1f9		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b200		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b207		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b20e		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b212		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b218		45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b21e		c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b224		c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b22a		c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b230		c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b235		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b239		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b241		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b247		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b24d		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b254		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b258		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b25e		45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b264		c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b268		c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b26c		c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b270		c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b275		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b279		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b281		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b288		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b28f		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b296		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b29d		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b2a1		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b2a7		43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b2ab		c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b2b1		c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2b7		c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2bc		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2c0		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2c8		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b2ce		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2d4		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2da		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2e1		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b2e5		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b2eb		45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b2f1		c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b2f7		c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b2fb		c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b2ff		c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b304		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b308		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b310		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b317		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b31e		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b325		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b32c		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b333		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b337		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b33d		43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b341		c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b348		c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b34e		c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b354		c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b359		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b35d		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b365		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b36b		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b371		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b377		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b37b		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b381		43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b385		c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b389		c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b38d		c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b391		c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b396		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b39a		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b3a2		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b3a9		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b3b0		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3b7		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3be		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3c5		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3c9		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b3cf		43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3d3		c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3d7		c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3dd		c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b3e3		c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b3e8		85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b3ee		87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b3f6		85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b3fc		85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b402		85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b408		85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b40e		86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b415		43 74 61 79				oca8:	.text 1*64+3, "tay"
>b419		85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b41f		43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b423		c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b427		c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b42b		c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b42f		c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b434		83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b438		87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b440		86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b447		86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b44e		86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b455		86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b45c		86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b463		43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b467		c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b46d		43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b471		c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b477		c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b47d		c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b483		c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b488		85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b48e		87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b496		85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b49c		85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b4a2		85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b4a8		86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b4af		43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b4b3		85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4b9		43 64 65 78				occa:	.text 1*64+3, "dex"
>b4bd		c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4c1		c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4c5		c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4c9		c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b4ce		83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4d2		87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4da		86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4e1		86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b4e8		86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b4ef		86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b4f6		43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b4fa		c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b500		43 70 68 78				ocda:	.text 1*64+3, "phx"
>b504		c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b50a		c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b510		c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b515		85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b51b		87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b523		85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b529		85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b52f		85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b535		86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b53c		43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b540		85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b546		43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b54a		c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b54e		c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b552		c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b556		c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b55b		83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b55f		87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b567		86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b56e		86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b575		86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b57c		86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b583		43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b587		c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b58d		43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b591		c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b597		c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b59d		c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b5a2		01 3f					oc__:	.text 1, "?"
.b5a4						disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.b5a4						ed6502:
.b5a4		a5 18		lda $18		                lda base
.b5a6		85 3a		sta $3a		                sta ed_base
.b5a8		a9 0a		lda #$0a	                lda #10
.b5aa		85 18		sta $18		                sta base
.b5ac		64 35		stz $35		                stz ed_head
.b5ae		64 36		stz $36		                stz ed_head+1
.b5b0		64 37		stz $37		                stz ed_cur
.b5b2		64 38		stz $38		                stz ed_cur+1
.b5b4		64 39		stz $39		                stz ed_flags
.b5b6		20 36 a7	jsr $a736	                jsr xt_zero
.b5b9		20 36 a7	jsr $a736	                jsr xt_zero             ; ( addr-t u-t )
.b5bc		20 fb 88	jsr $88fb	                jsr xt_cr
.b5bf						ed_input_loop:
.b5bf		a9 81		lda #$81	                lda #%10000001
.b5c1		14 39		trb $39		                trb ed_flags
.b5c3		20 9e ba	jsr $ba9e	                jsr ed_get_input
.b5c6		a5 0e		lda $0e		                lda ciblen
.b5c8		d0 1f		bne $b5e9	                bne _command_mode
.b5ca		ca		dex		                dex
.b5cb		ca		dex		                dex                     ; ( addr-t u-t ? )
.b5cc		a5 37		lda $37		                lda ed_cur
.b5ce		95 00		sta $00,x	                sta 0,x
.b5d0		a5 38		lda $38		                lda ed_cur+1
.b5d2		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5d4		a9 80		lda #$80	                lda #%10000000
.b5d6		04 39		tsb $39		                tsb ed_flags
.b5d8		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5db		20 ba ba	jsr $baba	                jsr ed_is_valid_line
.b5de		b0 03		bcs $b5e3	                bcs +
.b5e0		4c 8e ba	jmp $ba8e	                jmp ed_error_1drop
.b5e3						+
.b5e3		20 36 a7	jsr $a736	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b5e6		4c b4 b6	jmp $b6b4	                jmp _line_number_only_from_external
.b5e9						_command_mode:
.b5e9		20 36 a7	jsr $a736	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b5ec		20 36 a7	jsr $a736	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b5ef						_prefix_dot:
.b5ef		b2 0c		lda ($0c)	                lda (cib)
.b5f1		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b5f3		d0 3a		bne $b62f	                bne _prefix_dollar
.b5f5		20 af ba	jsr $baaf	                jsr ed_have_text
.b5f8		a5 37		lda $37		                lda ed_cur
.b5fa		95 02		sta $02,x	                sta 2,x
.b5fc		a5 38		lda $38		                lda ed_cur+1
.b5fe		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b600		a9 80		lda #$80	                lda #%10000000
.b602		04 39		tsb $39		                tsb ed_flags
.b604		a5 0e		lda $0e		                lda ciblen
.b606		3a		dec a		                dea                     ; sets Z if A was 1
.b607		d0 03		bne $b60c	                bne +
.b609		4c b4 b6	jmp $b6b4	                jmp _line_number_only_from_external
.b60c						+
.b60c		ca		dex		                dex
.b60d		ca		dex		                dex
.b60e		ca		dex		                dex
.b60f		ca		dex		                dex
.b610		a5 0c		lda $0c		                lda cib
.b612		95 02		sta $02,x	                sta 2,x
.b614		a5 0d		lda $0d		                lda cib+1
.b616		95 03		sta $03,x	                sta 3,x
.b618		a5 0e		lda $0e		                lda ciblen
.b61a		95 00		sta $00,x	                sta 0,x
.b61c		a5 0f		lda $0f		                lda ciblen+1
.b61e		95 01		sta $01,x	                sta 1,x
.b620		20 dd 97	jsr $97dd	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b623		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b626		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b629		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b62c		4c 0c b7	jmp $b70c	                jmp _check_for_para2
.b62f						_prefix_dollar:
.b62f		b2 0c		lda ($0c)	                lda (cib)
.b631		c9 24		cmp #$24	                cmp #'$'
.b633		d0 1c		bne $b651	                bne _prefix_percent
.b635		20 af ba	jsr $baaf	                jsr ed_have_text
.b638		e8		inx		                inx
.b639		e8		inx		                inx                     ; ( addr-t u-t 0 )
.b63a		20 dc ba	jsr $badc	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b63d		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b640		a9 80		lda #$80	                lda #%10000000
.b642		04 39		tsb $39		                tsb ed_flags
.b644		a5 0e		lda $0e		                lda ciblen
.b646		3a		dec a		                dea                     ; sets Z if A was 1
.b647		d0 03		bne $b64c	                bne +
.b649		4c b4 b6	jmp $b6b4	                jmp _line_number_only_from_external
.b64c						+
.b64c		a0 01		ldy #$01	                ldy #01
.b64e		4c 88 b7	jmp $b788	                jmp _check_command
.b651						_prefix_percent:
.b651		b2 0c		lda ($0c)	                lda (cib)
.b653		c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b655		f0 04		beq $b65b	                beq _whole_text
.b657		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b659		d0 17		bne $b672	                bne _prefix_semicolon
.b65b						_whole_text:
.b65b		20 af ba	jsr $baaf	                jsr ed_have_text
.b65e		a9 01		lda #$01	                lda #01
.b660		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b662		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b664						_semicolon_entry:
.b664		e8		inx		                inx
.b665		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b666		20 dc ba	jsr $badc	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b669		a9 80		lda #$80	                lda #%10000000
.b66b		04 39		tsb $39		                tsb ed_flags
.b66d		a0 01		ldy #$01	                ldy #01
.b66f		4c 88 b7	jmp $b788	                jmp _check_command
.b672						_prefix_semicolon:
.b672		b2 0c		lda ($0c)	                lda (cib)
.b674		c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b676		d0 0d		bne $b685	                bne _prefix_number
.b678		20 af ba	jsr $baaf	                jsr ed_have_text
.b67b		a5 37		lda $37		                lda ed_cur
.b67d		95 02		sta $02,x	                sta 2,x
.b67f		a5 38		lda $38		                lda ed_cur+1
.b681		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b683		80 df		bra $b664	                bra _semicolon_entry
.b685						_prefix_number:
.b685		20 36 a7	jsr $a736	                jsr xt_zero
.b688		20 36 a7	jsr $a736	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b68b		ca		dex		                dex
.b68c		ca		dex		                dex
.b68d		ca		dex		                dex
.b68e		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b68f		a5 0c		lda $0c		                lda cib
.b691		95 02		sta $02,x	                sta 2,x
.b693		a5 0d		lda $0d		                lda cib+1
.b695		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b697		a5 0e		lda $0e		                lda ciblen
.b699		95 00		sta $00,x	                sta 0,x
.b69b		a5 0f		lda $0f		                lda ciblen+1
.b69d		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b69f		20 38 a2	jsr $a238	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b6a2		b5 00		lda $00,x	                lda 0,x
.b6a4		15 01		ora $01,x	                ora 1,x
.b6a6		d0 24		bne $b6cc	                bne _have_unconverted_chars
.b6a8		e8		inx		                inx
.b6a9		e8		inx		                inx
.b6aa		e8		inx		                inx
.b6ab		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b6ac		20 18 8a	jsr $8a18	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b6af		20 3d 96	jsr $963d	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b6b2		e8		inx		                inx
.b6b3		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b6b4						_line_number_only_from_external:
.b6b4		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6b7		20 ba ba	jsr $baba	                jsr ed_is_valid_line
.b6ba		b0 03		bcs $b6bf	                bcs +
.b6bc		4c 8c ba	jmp $ba8c	                jmp ed_error_2drop
.b6bf						+
.b6bf		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6c2		20 49 bb	jsr $bb49	                jsr ed_para1_to_cur
.b6c5		a9 80		lda #$80	                lda #%10000000
.b6c7		04 39		tsb $39		                tsb ed_flags
.b6c9		4c 67 b9	jmp $b967	                jmp ed_cmd_p_from_external
.b6cc						_have_unconverted_chars:
.b6cc		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b6cf		ca		dex		                dex
.b6d0		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6d1		a5 0e		lda $0e		                lda ciblen
.b6d3		95 00		sta $00,x	                sta 0,x
.b6d5		a5 0f		lda $0f		                lda ciblen+1
.b6d7		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6d9		20 80 8e	jsr $8e80	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6dc		b5 00		lda $00,x	                lda 0,x
.b6de		15 01		ora $01,x	                ora 1,x
.b6e0		f0 0e		beq $b6f0	                beq _no_command_yet
.b6e2		8a		txa		                txa
.b6e3		18		clc		                clc
.b6e4		69 0a		adc #$0a	                adc #10
.b6e6		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b6e7		a9 80		lda #$80	                lda #%10000000
.b6e9		14 39		trb $39		                trb ed_flags
.b6eb		a0 00		ldy #$00	                ldy #00
.b6ed		4c 88 b7	jmp $b788	                jmp _check_command
.b6f0						_no_command_yet:
.b6f0		e8		inx		                inx
.b6f1		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b6f2		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b6f5		20 3d 96	jsr $963d	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b6f8		20 18 8a	jsr $8a18	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b6fb		b5 00		lda $00,x	                lda 0,x                 ; LSB
.b6fd		95 06		sta $06,x	                sta 6,x
.b6ff		b5 01		lda $01,x	                lda 1,x                 ; MSB
.b701		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b703		e8		inx		                inx
.b704		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b705		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b708		a9 80		lda #$80	                lda #%10000000
.b70a		04 39		tsb $39		                tsb ed_flags
.b70c						_check_for_para2:
.b70c		a1 02		lda ($02,x)	                lda (2,x)
.b70e		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b710		f0 0d		beq $b71f	                beq _got_comma
.b712		38		sec		                sec
.b713		a5 0e		lda $0e		                lda ciblen
.b715		f5 00		sbc $00,x	                sbc 0,x
.b717		a8		tay		                tay
.b718		e8		inx		                inx
.b719		e8		inx		                inx
.b71a		e8		inx		                inx
.b71b		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b71c		4c 88 b7	jmp $b788	                jmp _check_command
.b71f						_got_comma:
.b71f		f6 02		inc $02,x	                inc 2,x
.b721		d0 02		bne $b725	                bne +
.b723		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b725						+
.b725		b5 01		lda $01,x	                lda 1,x
.b727		f0 02		beq $b72b	                beq +
.b729		d6 01		dec $01,x	                dec 1,x
.b72b						+
.b72b		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b72d		a1 02		lda ($02,x)	                lda (2,x)
.b72f		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b731		d0 14		bne $b747	                bne _para2_not_dollar
.b733		38		sec		                sec
.b734		a5 0e		lda $0e		                lda ciblen
.b736		f5 02		sbc $02,x	                sbc 2,x
.b738		a8		tay		                tay
.b739		c8		iny		                iny
.b73a		5a		phy		                phy
.b73b		8a		txa		                txa
.b73c		18		clc		                clc
.b73d		69 06		adc #$06	                adc #06
.b73f		aa		tax		                tax                     ; ( addr-t u-t para1 )
.b740		20 dc ba	jsr $badc	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b743		7a		ply		                ply
.b744		4c 88 b7	jmp $b788	                jmp _check_command
.b747						_para2_not_dollar:
.b747		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b74a		20 36 a7	jsr $a736	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b74d		20 36 a7	jsr $a736	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b750		20 1c 9b	jsr $9b1c	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b753		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b756		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b759		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b75c		20 38 a2	jsr $a238	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b75f		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b762		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b765		20 80 8e	jsr $8e80	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b768		b5 00		lda $00,x	                lda 0,x
.b76a		15 01		ora $01,x	                ora 1,x
.b76c		f0 08		beq $b776	                beq _second_number
.b76e		8a		txa		                txa
.b76f		18		clc		                clc
.b770		69 0c		adc #$0c	                adc #12
.b772		aa		tax		                tax                     ; back to ( addr-t u-t )
.b773		4c 90 ba	jmp $ba90	                jmp ed_error
.b776						_second_number:
.b776		e8		inx		                inx
.b777		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b778		38		sec		                sec
.b779		a5 0e		lda $0e		                lda ciblen
.b77b		f5 00		sbc $00,x	                sbc 0,x
.b77d		48		pha		                pha
.b77e		20 2b a3	jsr $a32b	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b781		20 18 8a	jsr $8a18	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b784		20 11 96	jsr $9611	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b787		7a		ply		                ply
.b788						_check_command:
.b788		24 39		bit $39		                bit ed_flags
.b78a		30 08		bmi $b794	                bmi _check_command_have_arg
.b78c		a5 37		lda $37		                lda ed_cur
.b78e		95 02		sta $02,x	                sta 2,x
.b790		a5 38		lda $38		                lda ed_cur+1
.b792		95 03		sta $03,x	                sta 3,x
.b794						_check_command_have_arg:
.b794		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.b796		85 25		sta $25		                sta tmp1
.b798		da		phx		                phx
.b799		a2 00		ldx #$00	                ldx #00
.b79b						_cmd_loop:
.b79b		bd 74 bb	lda $bb74,x	                lda ed_cmd_list,x
.b79e		f0 07		beq $b7a7	                beq _illegal_command    ; zero marks end of list
.b7a0		c5 25		cmp $25		                cmp tmp1
.b7a2		f0 07		beq $b7ab	                beq _found_cmd
.b7a4		e8		inx		                inx
.b7a5		80 f4		bra $b79b	                bra _cmd_loop
.b7a7						_illegal_command:
.b7a7		fa		plx		                plx
.b7a8		4c 8c ba	jmp $ba8c	                jmp ed_error_2drop
.b7ab						_found_cmd:
.b7ab		8a		txa		                txa
.b7ac		0a		asl a		                asl
.b7ad		aa		tax		                tax                     ; X * 2 for table
.b7ae		7c 7f bb	jmp ($bb7f,x)	                jmp (ed_cmd_table,x)
.b7b1						ed_next_command:
.b7b1		e8		inx		                inx
.b7b2		e8		inx		                inx
.b7b3		e8		inx		                inx
.b7b4		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b7b5						_next_command_empty:
.b7b5		4c bf b5	jmp $b5bf	                jmp ed_input_loop
.b7b8						ed_all_done:
.b7b8		64 0e		stz $0e		                stz ciblen
.b7ba		64 0f		stz $0f		                stz ciblen+1
.b7bc		20 2b a3	jsr $a32b	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7bf		a5 3a		lda $3a		                lda ed_base
.b7c1		85 18		sta $18		                sta base
.b7c3		60		rts		                rts
.b7c4						ed_cmd_a:
.b7c4		fa		plx		                plx
.b7c5		e8		inx		                inx
.b7c6		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7c7						ed_entry_cmd_i:
.b7c7						ed_cmd_a_have_para:
.b7c7		20 12 bb	jsr $bb12	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7ca		20 fb 88	jsr $88fb	                jsr xt_cr
.b7cd						_next_string_loop:
.b7cd		20 9e ba	jsr $ba9e	                jsr ed_get_input
.b7d0		b2 0c		lda ($0c)	                lda (cib)
.b7d2		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7d4		d0 16		bne $b7ec	                bne _add_line
.b7d6		a4 0e		ldy $0e		                ldy ciblen
.b7d8		c0 01		cpy #$01	                cpy #01
.b7da		d0 10		bne $b7ec	                bne _add_line
.b7dc		a4 0f		ldy $0f		                ldy ciblen+1
.b7de		d0 0c		bne $b7ec	                bne _add_line
.b7e0		e8		inx		                inx
.b7e1		e8		inx		                inx
.b7e2		a9 40		lda #$40	                lda #%01000000
.b7e4		04 39		tsb $39		                tsb ed_flags
.b7e6		20 fb 88	jsr $88fb	                jsr xt_cr
.b7e9		4c bf b5	jmp $b5bf	                jmp ed_input_loop
.b7ec						_add_line:
.b7ec		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b7ef		20 24 91	jsr $9124	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b7f2		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b7f5		20 32 8f	jsr $8f32	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b7f8		20 f1 86	jsr $86f1	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b7fb		20 08 a3	jsr $a308	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b7fe		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b801		20 18 a1	jsr $a118	                jsr xt_store            ; ! ( addr-t u-t here )
.b804		20 24 91	jsr $9124	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b807		a5 00		lda $00		                lda cp
.b809		18		clc		                clc
.b80a		69 04		adc #$04	                adc #04
.b80c		85 00		sta $00		                sta cp
.b80e		90 02		bcc $b812	                bcc +
.b810		e6 01		inc $01		                inc cp+1
.b812						+
.b812		e6 37		inc $37		                inc ed_cur
.b814		d0 02		bne $b818	                bne +
.b816		e6 38		inc $38		                inc ed_cur+1
.b818						+
.b818		20 24 91	jsr $9124	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b81b		20 2f 8d	jsr $8d2f	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b81e		ca		dex		                dex
.b81f		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b820		a5 0c		lda $0c		                lda cib
.b822		95 00		sta $00,x	                sta 0,x
.b824		a5 0d		lda $0d		                lda cib+1
.b826		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b828		20 33 a1	jsr $a133	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b82b		ca		dex		                dex
.b82c		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b82d		a5 0e		lda $0e		                lda ciblen
.b82f		95 00		sta $00,x	                sta 0,x
.b831		a5 0f		lda $0f		                lda ciblen+1
.b833		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b835		20 97 95	jsr $9597	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b838		18		clc		                clc
.b839		a5 00		lda $00		                lda cp
.b83b		65 0e		adc $0e		                adc ciblen
.b83d		85 00		sta $00		                sta cp
.b83f		90 06		bcc $b847	                bcc +
.b841		a5 01		lda $01		                lda cp+1
.b843		65 0f		adc $0f		                adc ciblen+1
.b845		85 01		sta $01		                sta cp+1
.b847						+
.b847		20 5f 98	jsr $985f	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b84a		20 18 a1	jsr $a118	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b84d		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+
.b850		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b853		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b856		a5 0e		lda $0e		                lda ciblen
.b858		95 02		sta $02,x	                sta 2,x
.b85a		a5 0f		lda $0f		                lda ciblen+1
.b85c		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b85e		20 18 a1	jsr $a118	                jsr xt_store            ; ! ( addr-t u-t here )
.b861		20 fb 88	jsr $88fb	                jsr xt_cr
.b864		4c cd b7	jmp $b7cd	                jmp _next_string_loop
.b867						ed_cmd_d:
.b867		fa		plx		                plx
.b868		20 af ba	jsr $baaf	                jsr ed_have_text
.b86b		20 04 bb	jsr $bb04	                jsr ed_no_line_zero
.b86e		b5 00		lda $00,x	                lda 0,x
.b870		15 01		ora $01,x	                ora 1,x
.b872		d0 08		bne $b87c	                bne +
.b874		20 5f 98	jsr $985f	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b877		20 b9 b8	jsr $b8b9	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b87a		80 33		bra $b8af	                bra _cmd_d_done
.b87c						+
.b87c		20 ba ba	jsr $baba	                jsr ed_is_valid_line      ; result is in C flag
.b87f		b0 03		bcs $b884	                bcs _cmd_d_loop
.b881		4c 8c ba	jmp $ba8c	                jmp ed_error_2drop
.b884						_cmd_d_loop:
.b884		20 33 a3	jsr $a333	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b887		20 0f 91	jsr $910f	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b88a		b5 00		lda $00,x	                lda 0,x
.b88c		15 01		ora $01,x	                ora 1,x
.b88e		d0 0d		bne $b89d	                bne _cmd_d_done_with_flag
.b890		e8		inx		                inx
.b891		e8		inx		                inx                     ; Get rid of the flag from >
.b892		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b895		20 b9 b8	jsr $b8b9	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b898		20 dd 97	jsr $97dd	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b89b		80 e7		bra $b884	                bra _cmd_d_loop
.b89d						_cmd_d_done_with_flag:
.b89d		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b89e		e8		inx		                inx
.b89f		b5 02		lda $02,x	                lda 2,x
.b8a1		d0 02		bne $b8a5	                bne +
.b8a3		d6 03		dec $03,x	                dec 3,x
.b8a5						+
.b8a5		d6 02		dec $02,x	                dec 2,x
.b8a7		b5 02		lda $02,x	                lda 2,x
.b8a9		85 37		sta $37		                sta ed_cur
.b8ab		b5 03		lda $03,x	                lda 3,x
.b8ad		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.b8af						_cmd_d_done:
.b8af		a9 40		lda #$40	                lda #%01000000
.b8b1		04 39		tsb $39		                tsb ed_flags
.b8b3		20 fb 88	jsr $88fb	                jsr xt_cr
.b8b6		4c b1 b7	jmp $b7b1	                jmp ed_next_command
.b8b9						_cmd_d_common:
.b8b9		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8bc		20 12 bb	jsr $bb12	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8bf		20 32 8f	jsr $8f32	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8c2		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8c5		20 dd 97	jsr $97dd	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8c8		20 12 bb	jsr $bb12	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8cb		20 18 a1	jsr $a118	                jsr xt_store            ; ! ( addr-t u-t )
.b8ce		60		rts		                rts
.b8cf						ed_cmd_equ:
.b8cf		fa		plx		                plx
.b8d0		a5 35		lda $35		                lda ed_head
.b8d2		05 36		ora $36		                ora ed_head+1
.b8d4		d0 08		bne $b8de	                bne _cmd_equ_have_text
.b8d6		ca		dex		                dex
.b8d7		ca		dex		                dex
.b8d8		74 00		stz $00,x	                stz 0,x
.b8da		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8dc		80 21		bra $b8ff	                bra _cmd_equ_done
.b8de						_cmd_equ_have_text:
.b8de		20 04 bb	jsr $bb04	                jsr ed_no_line_zero
.b8e1		24 39		bit $39		                bit ed_flags
.b8e3		30 0c		bmi $b8f1	                bmi _cmd_equ_have_para
.b8e5		ca		dex		                dex
.b8e6		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b8e7		a5 37		lda $37		                lda ed_cur
.b8e9		95 00		sta $00,x	                sta 0,x
.b8eb		a5 38		lda $38		                lda ed_cur+1
.b8ed		95 01		sta $01,x	                sta 1,x
.b8ef		80 0e		bra $b8ff	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b8f1						_cmd_equ_have_para:
.b8f1		b5 00		lda $00,x	                lda 0,x
.b8f3		15 01		ora $01,x	                ora 1,x
.b8f5		d0 05		bne $b8fc	                bne _cmd_equ_two_paras
.b8f7		20 5f 98	jsr $985f	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b8fa		80 03		bra $b8ff	                bra _cmd_equ_done
.b8fc						_cmd_equ_two_paras:
.b8fc		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b8ff						_cmd_equ_done:
.b8ff		20 fb 88	jsr $88fb	                jsr xt_cr               ; number goes on new line
.b902		20 a9 a4	jsr $a4a9	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b905		20 fb 88	jsr $88fb	                jsr xt_cr
.b908		4c b1 b7	jmp $b7b1	                jmp ed_next_command
.b90b						ed_cmd_f:
.b90b		fa		plx		                plx
.b90c		24 39		bit $39		                bit ed_flags
.b90e		30 17		bmi $b927	                bmi _cmd_f_have_para
.b910		20 fb 88	jsr $88fb	                jsr xt_cr
.b913		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b916		20 1c 9b	jsr $9b1c	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b919		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b91c		20 a9 a4	jsr $a4a9	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b91f		20 3d 96	jsr $963d	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b922		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b925		80 11		bra $b938	                bra _cmd_f_done
.b927						_cmd_f_have_para:
.b927		20 5f 98	jsr $985f	                jsr xt_over
.b92a		20 fb 88	jsr $88fb	                jsr xt_cr
.b92d		20 a9 a4	jsr $a4a9	                jsr xt_u_dot
.b930		b5 02		lda $02,x	                lda 2,x
.b932		95 06		sta $06,x	                sta 6,x
.b934		b5 03		lda $03,x	                lda 3,x
.b936		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b938						_cmd_f_done:
.b938		20 fb 88	jsr $88fb	                jsr xt_cr
.b93b		4c b1 b7	jmp $b7b1	                jmp ed_next_command
.b93e						ed_cmd_i:
.b93e		fa		plx		                plx
.b93f		e8		inx		                inx
.b940		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b941		24 39		bit $39		                bit ed_flags
.b943		30 08		bmi $b94d	                bmi _cmd_i_have_para
.b945		a5 37		lda $37		                lda ed_cur
.b947		95 00		sta $00,x	                sta 0,x
.b949		a5 38		lda $38		                lda ed_cur+1
.b94b		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b94d						_cmd_i_have_para:
.b94d		b5 00		lda $00,x	                lda 0,x
.b94f		15 01		ora $01,x	                ora 1,x
.b951		f0 09		beq $b95c	                beq _cmd_i_done
.b953		20 dd 97	jsr $97dd	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b956		20 36 a7	jsr $a736	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b959		20 ed 94	jsr $94ed	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b95c						_cmd_i_done:
.b95c		4c c7 b7	jmp $b7c7	                jmp ed_entry_cmd_i
.b95f						ed_cmd_n:
.b95f		fa		plx		                plx
.b960		a9 01		lda #$01	                lda #%00000001
.b962		04 39		tsb $39		                tsb ed_flags
.b964		80 05		bra $b96b	                bra ed_cmd_p_entry_for_cmd_n
.b966						ed_cmd_p:
.b966		fa		plx		                plx
.b967						ed_cmd_p_from_external:
.b967		a9 01		lda #$01	                lda #%00000001
.b969		14 39		trb $39		                trb ed_flags
.b96b						ed_cmd_p_entry_for_cmd_n:
.b96b		20 af ba	jsr $baaf	                jsr ed_have_text
.b96e		20 04 bb	jsr $bb04	                jsr ed_no_line_zero
.b971		20 fb 88	jsr $88fb	                jsr xt_cr
.b974		b5 00		lda $00,x	                lda 0,x
.b976		15 01		ora $01,x	                ora 1,x
.b978		d0 10		bne $b98a	                bne _cmd_p_loop
.b97a		b5 02		lda $02,x	                lda 2,x
.b97c		85 37		sta $37		                sta ed_cur
.b97e		b5 03		lda $03,x	                lda 3,x
.b980		85 38		sta $38		                sta ed_cur+1
.b982		20 5f 98	jsr $985f	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b985		20 b3 b9	jsr $b9b3	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b988		80 26		bra $b9b0	                bra _cmd_p_all_done
.b98a						_cmd_p_loop:
.b98a		20 33 a3	jsr $a333	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b98d		20 0f 91	jsr $910f	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b990		b5 00		lda $00,x	                lda 0,x
.b992		15 01		ora $01,x	                ora 1,x
.b994		d0 10		bne $b9a6	                bne _cmd_p_done
.b996		e8		inx		                inx
.b997		e8		inx		                inx                     ; Get rid of the flag from >
.b998		20 5f 98	jsr $985f	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b99b		20 b3 b9	jsr $b9b3	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b99e		f6 02		inc $02,x	                inc 2,x
.b9a0		d0 02		bne $b9a4	                bne +
.b9a2		f6 03		inc $03,x	                inc 3,x
.b9a4						+
.b9a4		80 e4		bra $b98a	                bra _cmd_p_loop
.b9a6						_cmd_p_done:
.b9a6		e8		inx		                inx
.b9a7		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b9a8		b5 00		lda $00,x	                lda 0,x
.b9aa		85 37		sta $37		                sta ed_cur
.b9ac		b5 01		lda $01,x	                lda 1,x
.b9ae		85 38		sta $38		                sta ed_cur+1
.b9b0						_cmd_p_all_done:
.b9b0		4c b1 b7	jmp $b7b1	                jmp ed_next_command
.b9b3						_cmd_p_common:
.b9b3		a5 39		lda $39		                lda ed_flags
.b9b5		4a		lsr a		                lsr                     ; bit 0 now in carry
.b9b6		90 0b		bcc $b9c3	                bcc _cmd_p_common_no_num
.b9b8		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9bb		20 a9 a4	jsr $a4a9	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9be		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9c0		20 a8 8d	jsr $8da8	                jsr emit_a
.b9c3						_cmd_p_common_no_num:
.b9c3		20 12 bb	jsr $bb12	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9c6		20 52 bb	jsr $bb52	                jsr ed_print_addr
.b9c9		60		rts		                rts
.b9ca						ed_cmd_q:
.b9ca		fa		plx		                plx
.b9cb		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.b9cd		50 03		bvc $b9d2	                bvc +
.b9cf		4c 8c ba	jmp $ba8c	                jmp ed_error_2drop
.b9d2						+
.b9d2		4c b8 b7	jmp $b7b8	                jmp ed_all_done            ; can't fall thru because of PLX
.b9d5						ed_cmd_qq:
.b9d5		fa		plx		                plx
.b9d6		4c b8 b7	jmp $b7b8	                jmp ed_all_done
.b9d9						ed_cmd_w:
.b9d9		fa		plx		                plx
.b9da		20 af ba	jsr $baaf	                jsr ed_have_text
.b9dd		24 39		bit $39		                bit ed_flags
.b9df		30 13		bmi $b9f4	                bmi _cmd_w_have_para
.b9e1		b5 06		lda $06,x	                lda 6,x
.b9e3		15 07		ora $07,x	                ora 7,x
.b9e5		d0 03		bne $b9ea	                bne +
.b9e7		4c 8c ba	jmp $ba8c	                jmp ed_error_2drop
.b9ea						+
.b9ea		b5 06		lda $06,x	                lda 6,x
.b9ec		95 02		sta $02,x	                sta 2,x
.b9ee		b5 07		lda $07,x	                lda 7,x
.b9f0		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b9f2		80 08		bra $b9fc	                bra _cmd_w_para_ready
.b9f4						_cmd_w_have_para:
.b9f4		b5 02		lda $02,x	                lda 2,x
.b9f6		95 06		sta $06,x	                sta 6,x
.b9f8		b5 03		lda $03,x	                lda 3,x
.b9fa		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b9fc						_cmd_w_para_ready:
.b9fc		a9 35		lda #$35	                lda #<ed_head
.b9fe		95 00		sta $00,x	                sta 0,x
.ba00		a9 00		lda #$00	                lda #>ed_head
.ba02		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ba04		20 5f 98	jsr $985f	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ba07		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ba0a						_cmd_w_loop:
.ba0a		20 32 8f	jsr $8f32	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ba0d		b5 00		lda $00,x	                lda 0,x
.ba0f		15 01		ora $01,x	                ora 1,x
.ba11		f0 55		beq $ba68	                beq _cmd_w_eol
.ba13		20 33 a3	jsr $a333	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba16		20 1d a4	jsr $a41d	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba19		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba1c		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba1f		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba22		20 32 8f	jsr $8f32	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba25		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba28		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba2b		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba2e		20 32 8f	jsr $8f32	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba31		20 3d 96	jsr $963d	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba34		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba37		20 1c 9b	jsr $9b1c	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba3a		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba3d		20 eb a2	jsr $a2eb	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba40		20 97 95	jsr $9597	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba43		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba46		20 a3 a3	jsr $a3a3	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba49		20 3d 96	jsr $963d	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba4c		20 af 99	jsr $99af	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba4f		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba52		ca		dex		                dex
.ba53		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba54		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba56		95 00		sta $00,x	                sta 0,x
.ba58		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba5a		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba5d		20 18 a1	jsr $a118	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba60		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba63		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba66		80 a2		bra $ba0a	                bra _cmd_w_loop
.ba68						_cmd_w_eol:
.ba68		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba6b		20 5e 9a	jsr $9a5e	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba6e		20 25 95	jsr $9525	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba71		b5 00		lda $00,x	                lda 0,x
.ba73		95 04		sta $04,x	                sta 4,x
.ba75		b5 01		lda $01,x	                lda 1,x
.ba77		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba79		20 fb 88	jsr $88fb	                jsr xt_cr
.ba7c		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba7f		20 a9 a4	jsr $a4a9	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba82		20 fb 88	jsr $88fb	                jsr xt_cr
.ba85		a9 40		lda #$40	                lda #%01000000
.ba87		14 39		trb $39		                trb ed_flags
.ba89		4c b1 b7	jmp $b7b1	                jmp ed_next_command
.ba8c						ed_error_2drop:
.ba8c		e8		inx		                inx
.ba8d		e8		inx		                inx                     ; drop through to _error_1drop
.ba8e						ed_error_1drop:
.ba8e		e8		inx		                inx
.ba8f		e8		inx		                inx                     ; drop through to _error
.ba90						ed_error:
.ba90		20 fb 88	jsr $88fb	                jsr xt_cr
.ba93		a9 3f		lda #$3f	                lda #'?'
.ba95		20 a8 8d	jsr $8da8	                jsr emit_a
.ba98		20 fb 88	jsr $88fb	                jsr xt_cr
.ba9b		4c bf b5	jmp $b5bf	                jmp ed_input_loop
.ba9e						ed_get_input:
.ba9e		20 c4 9a	jsr $9ac4	                jsr xt_refill           ;  ( addr-t u-t f )
.baa1		b5 00		lda $00,x	                lda 0,x
.baa3		15 01		ora $01,x	                ora 1,x
.baa5		d0 05		bne $baac	                bne +
.baa7		7a		ply		                ply
.baa8		7a		ply		                ply
.baa9		4c 8e ba	jmp $ba8e	                jmp ed_error_1drop
.baac						+
.baac		e8		inx		                inx
.baad		e8		inx		                inx
.baae		60		rts		                rts
.baaf						ed_have_text:
.baaf		a5 35		lda $35		                lda ed_head
.bab1		05 36		ora $36		                ora ed_head+1
.bab3		d0 04		bne $bab9	                bne +
.bab5		7a		ply		                ply
.bab6		7a		ply		                ply
.bab7		80 d7		bra $ba90	                bra ed_error
.bab9						+
.bab9		60		rts		                rts
.baba						ed_is_valid_line:
.baba		38		sec		                sec                             ; default is legal line number
.babb		b5 00		lda $00,x	                lda 0,x
.babd		15 01		ora $01,x	                ora 1,x
.babf		f0 19		beq $bada	                beq _is_valid_line_nope_zero    ; ( n )
.bac1		20 2f 8d	jsr $8d2f	                jsr xt_dup                      ; DUP ( n n )
.bac4		20 dc ba	jsr $badc	                jsr ed_last_line                  ; ( n n last )
.bac7		20 33 a1	jsr $a133	                jsr xt_swap                     ; SWAP ( n last n )
.baca		20 2c 93	jsr $932c	                jsr xt_less_than                ; < ( n f )
.bacd		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.bacf		15 01		ora $01,x	                ora 1,x
.bad1		d0 05		bne $bad8	                bne _is_valid_line_too_small
.bad3		e8		inx		                inx
.bad4		e8		inx		                inx                     ; DROP flag ( n )
.bad5		38		sec		                sec                     ; Who knows what's happened to C by now
.bad6		80 03		bra $badb	                bra _is_valid_line_done ; only one exit from this routine
.bad8						_is_valid_line_too_small:
.bad8		e8		inx		                inx
.bad9		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.bada						_is_valid_line_nope_zero:
.bada		18		clc		                clc                     ; drop through to _is_valid_line_done
.badb						_is_valid_line_done:
.badb		60		rts		                rts
.badc						ed_last_line:
.badc		64 25		stz $25		                stz tmp1
.bade		64 26		stz $26		                stz tmp1+1
.bae0		ca		dex		                dex
.bae1		ca		dex		                dex                     ; ( ? )
.bae2		a9 35		lda #$35	                lda #<ed_head
.bae4		95 00		sta $00,x	                sta 0,x
.bae6		a9 00		lda #$00	                lda #>ed_head
.bae8		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.baea						_last_line_loop:
.baea		20 32 8f	jsr $8f32	                jsr xt_fetch            ; ( addr | 0 )
.baed		b5 00		lda $00,x	                lda 0,x
.baef		15 01		ora $01,x	                ora 1,x
.baf1		f0 08		beq $bafb	                beq _last_line_done
.baf3		e6 25		inc $25		                inc tmp1
.baf5		d0 02		bne $baf9	                bne +
.baf7		e6 26		inc $26		                inc tmp1+1
.baf9						+
.baf9		80 ef		bra $baea	                bra _last_line_loop
.bafb						_last_line_done:
.bafb		a5 25		lda $25		                lda tmp1
.bafd		95 00		sta $00,x	                sta 0,x
.baff		a5 26		lda $26		                lda tmp1+1
.bb01		95 01		sta $01,x	                sta 1,x                 ; ( u )
.bb03		60		rts		                rts
.bb04						ed_no_line_zero:
.bb04		b5 02		lda $02,x	                lda 2,x
.bb06		15 03		ora $03,x	                ora 3,x
.bb08		d0 07		bne $bb11	                bne _no_line_zero_done
.bb0a		24 39		bit $39		                bit ed_flags
.bb0c		10 03		bpl $bb11	                bpl _no_line_zero_done
.bb0e		4c 8c ba	jmp $ba8c	                jmp ed_error_2drop
.bb11						_no_line_zero_done:
.bb11		60		rts		                rts
.bb12						ed_num_to_addr:
.bb12		ca		dex		                dex
.bb13		ca		dex		                dex                     ; ( u ? )
.bb14		a9 35		lda #$35	                lda #<ed_head
.bb16		95 00		sta $00,x	                sta 0,x
.bb18		a9 00		lda #$00	                lda #>ed_head
.bb1a		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb1c		b5 02		lda $02,x	                lda 2,x
.bb1e		15 03		ora $03,x	                ora 3,x
.bb20		d0 05		bne $bb27	                bne _num_to_addr_loop
.bb22		20 11 96	jsr $9611	                jsr xt_nip              ; ( addr-h )
.bb25		80 21		bra $bb48	                bra _num_to_addr_done
.bb27						_num_to_addr_loop:
.bb27		20 32 8f	jsr $8f32	                jsr xt_fetch            ; @ ( u addr1 )
.bb2a		b5 00		lda $00,x	                lda 0,x
.bb2c		15 01		ora $01,x	                ora 1,x
.bb2e		d0 05		bne $bb35	                bne +
.bb30		20 11 96	jsr $9611	                jsr xt_nip              ; NIP ( addr1 )
.bb33		80 13		bra $bb48	                bra _num_to_addr_done
.bb35						+
.bb35		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( addr1 u )
.bb38		20 dd 97	jsr $97dd	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb3b		b5 00		lda $00,x	                lda 0,x
.bb3d		15 01		ora $01,x	                ora 1,x
.bb3f		f0 05		beq $bb46	                beq _num_to_addr_finished
.bb41		20 33 a1	jsr $a133	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb44		80 e1		bra $bb27	                bra _num_to_addr_loop
.bb46						_num_to_addr_finished:
.bb46		e8		inx		                inx
.bb47		e8		inx		                inx                     ; ( addr )
.bb48						_num_to_addr_done:
.bb48		60		rts		                rts
.bb49						ed_para1_to_cur:
.bb49		b5 02		lda $02,x	                lda 2,x
.bb4b		85 37		sta $37		                sta ed_cur
.bb4d		b5 03		lda $03,x	                lda 3,x
.bb4f		85 38		sta $38		                sta ed_cur+1
.bb51		60		rts		                rts
.bb52						ed_print_addr:
.bb52		20 e9 97	jsr $97e9	                jsr xt_one_plus
.bb55		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; ( addr+2 )
.bb58		20 2f 8d	jsr $8d2f	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb5b		20 e9 97	jsr $97e9	                jsr xt_one_plus
.bb5e		20 e9 97	jsr $97e9	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb61		20 32 8f	jsr $8f32	                jsr xt_fetch            ; ( addr+2 u-s )
.bb64		20 33 a1	jsr $a133	                jsr xt_swap             ; ( u-s addr+2 )
.bb67		20 32 8f	jsr $8f32	                jsr xt_fetch            ; ( u-s addr-s )
.bb6a		20 33 a1	jsr $a133	                jsr xt_swap             ; ( addr-s u-s )
.bb6d		20 7e a4	jsr $a47e	                jsr xt_type
.bb70		20 fb 88	jsr $88fb	                jsr xt_cr
.bb73		60		rts		                rts
>bb74		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb7c		71 51 00
.bb7f						ed_cmd_table:
>bb7f		c4 b7 0b b9 3e b9 67 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb87		66 b9 5f b9
>bb8b		cf b8 d9 b9 ca b9 d5 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb93						ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb93						forth_words_start:
>bb93		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb9b		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bbab		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bbbb		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>bbcb		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>bbdb		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bbeb		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>bbfb		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bc0b		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bc1b		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bc2b		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bc3b		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bc4b		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bc5b		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bc6b		78 69 74 29 20 63 72 20
.bc73						forth_words_end:
.bc73						user_words_start:
>bc73		20 20				.binary "user_words.asc"
.bc75						user_words_end:

;******  Processing file: platform/../headers.asm

.bc75						dictionary_start:
.bc75						nt_drop:
>bc75		04 10				        .byte 4, UF
>bc77		81 bc ae 8c b3 8c		        .word nt_dup, xt_drop, z_drop
>bc7d		64 72 6f 70			        .text "drop"
.bc81						nt_dup:
>bc81		03 10				        .byte 3, UF
>bc83		8c bc 2f 8d 3c 8d		        .word nt_swap, xt_dup, z_dup
>bc89		64 75 70			        .text "dup"
.bc8c						nt_swap:
>bc8c		04 10				        .byte 4, UF
>bc8e		98 bc 33 a1 46 a1		        .word nt_store, xt_swap, z_swap
>bc94		73 77 61 70			        .text "swap"
.bc98						nt_store:
>bc98		01 10				        .byte 1, UF
>bc9a		a1 bc 18 a1 2d a1		        .word nt_fetch, xt_store, z_store
>bca0		21				        .text "!"
.bca1						nt_fetch:
>bca1		01 10				        .byte 1, UF
>bca3		aa bc 32 8f 44 8f		        .word nt_over, xt_fetch, z_fetch
>bca9		40				        .text "@"
.bcaa						nt_over:
>bcaa		04 10				        .byte 4, UF
>bcac		b6 bc 5f 98 6c 98		        .word nt_to_r, xt_over, z_over
>bcb2		6f 76 65 72			        .text "over"
.bcb6						nt_to_r:
>bcb6		02 11				        .byte 2, CO+UF ; native is special case
>bcb8		c0 bc eb a2 fe a2		        .word nt_r_from, xt_to_r, z_to_r
>bcbe		3e 72				        .text ">r"
.bcc0						nt_r_from:
>bcc0		02 01				        .byte 2, CO    ; native is special case
>bcc2		ca bc 5e 9a 6e 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bcc8		72 3e				        .text "r>"
.bcca						nt_r_fetch:
>bcca		02 01				        .byte 2, CO    ; native is special case
>bccc		d4 bc 49 9a 5d 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bcd2		72 40				        .text "r@"
.bcd4						nt_nip:
>bcd4		03 10				        .byte 3, UF
>bcd6		df bc 11 96 1e 96		        .word nt_rot, xt_nip, z_nip
>bcdc		6e 69 70			        .text "nip"
.bcdf						nt_rot:
>bcdf		03 10				        .byte 3, UF
>bce1		ea bc 1c 9b 37 9b		        .word nt_not_rote, xt_rot, z_rot
>bce7		72 6f 74			        .text "rot"
.bcea						nt_not_rote:
>bcea		04 10				        .byte 4, UF
>bcec		f6 bc 3d 96 58 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bcf2		2d 72 6f 74			        .text "-rot"
.bcf6						nt_tuck:
>bcf6		04 10				        .byte 4, UF
>bcf8		02 bd 08 a3 21 a3		        .word nt_comma, xt_tuck, z_tuck
>bcfe		74 75 63 6b			        .text "tuck"
.bd02						nt_comma:
>bd02		01 10				        .byte 1, UF
>bd04		0b bd f1 86 0a 87		        .word nt_c_fetch, xt_comma, z_comma
>bd0a		2c				        .text ","
.bd0b						nt_c_fetch:
>bd0b		02 10				        .byte 2, UF
>bd0d		15 bd 8e 85 97 85		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bd13		63 40				        .text "c@"
.bd15						nt_c_store:
>bd15		02 10				        .byte 2, UF
>bd17		1f bd 98 85 a3 85		        .word nt_plus_store, xt_c_store, z_c_store
>bd1d		63 21				        .text "c!"
.bd1f						nt_plus_store:
>bd1f		02 10				        .byte 2, UF
>bd21		29 bd c2 99 e1 99		        .word nt_execute, xt_plus_store, z_plus_store
>bd27		2b 21				        .text "+!"
.bd29						nt_execute:
>bd29		07 10				        .byte 7, UF
>bd2b		38 bd ef 8e f5 8e		        .word nt_emit, xt_execute, z_execute
>bd31		65 78 65 63 75 74 65		        .text "execute"
.bd38						nt_emit:
>bd38		04 18				        .byte 4, NN+UF
>bd3a		44 bd a1 8d ab 8d		        .word nt_type, xt_emit, z_emit
>bd40		65 6d 69 74			        .text "emit"
.bd44						nt_type:
>bd44		04 10				        .byte 4, UF
>bd46		50 bd 7e a4 a8 a4		        .word nt_dot, xt_type, z_type
>bd4c		74 79 70 65			        .text "type"
.bd50						nt_dot:
>bd50		01 10				        .byte 1, UF
>bd52		59 bd b6 8b d7 8b		        .word nt_u_dot, xt_dot, z_dot
>bd58		2e				        .text "."
.bd59						nt_u_dot:
>bd59		02 10				        .byte 2, UF
>bd5b		63 bd a9 a4 b4 a4		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd61		75 2e				        .text "u."
.bd63						nt_u_dot_r:
>bd63		03 10				        .byte 3, UF
>bd65		6e bd b5 a4 d6 a4		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd6b		75 2e 72			        .text "u.r"
.bd6e						nt_dot_r:
>bd6e		02 10				        .byte 2, UF
>bd70		78 bd f2 8b 1f 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd76		2e 72				        .text ".r"
.bd78						nt_d_dot:
>bd78		02 10				        .byte 2, UF
>bd7a		82 bd 64 8c 82 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd80		64 2e				        .text "d."
.bd82						nt_d_dot_r:
>bd82		03 10				        .byte 3, UF
>bd84		8d bd 83 8c ad 8c		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd8a		64 2e 72			        .text "d.r"
.bd8d						nt_ud_dot:
>bd8d		03 10				        .byte 3, UF
>bd8f		98 bd 03 a5 15 a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd95		75 64 2e			        .text "ud."
.bd98						nt_ud_dot_r:
>bd98		04 10				        .byte 4, UF
>bd9a		a4 bd 16 a5 34 a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bda0		75 64 2e 72			        .text "ud.r"
.bda4						nt_question:
>bda4		01 00				        .byte 1, 0
>bda6		ad bd 2e 9a 34 9a		        .word nt_false, xt_question, z_question
>bdac		3f				        .text "?"
.bdad						nt_false:
>bdad		05 00				        .byte 5, 0
>bdaf		ba bd 2b 8f 31 8f		        .word nt_true, xt_false, z_false
>bdb5		66 61 6c 73 65			        .text "false"
.bdba						nt_true:
>bdba		04 00				        .byte 4, 0
>bdbc		c6 bd ff a2 07 a3		        .word nt_space, xt_true, z_true
>bdc2		74 72 75 65			        .text "true"
.bdc6						nt_space:
>bdc6		05 00				        .byte 5, 0
>bdc8		d3 bd a9 a0 ae a0		        .word nt_zero, xt_space, z_space
>bdce		73 70 61 63 65			        .text "space"
.bdd3						nt_zero:
>bdd3		01 00				        .byte 1, 0
>bdd5		dc bd 36 a7 3c a7		        .word nt_one, xt_zero, z_zero
>bddb		30				        .text "0"
.bddc						nt_one:
>bddc		01 00				        .byte 1, 0
>bdde		e5 bd d4 97 dc 97		        .word nt_two, xt_one, z_one
>bde4		31				        .text "1"
.bde5						nt_two:
>bde5		01 00				        .byte 1, 0
>bde7		ee bd 22 a3 2a a3		        .word nt_two_dup, xt_two, z_two
>bded		32				        .text "2"
.bdee						nt_two_dup:
>bdee		04 10				        .byte 4, UF
>bdf0		fa bd 33 a3 4a a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bdf6		32 64 75 70			        .text "2dup"
.bdfa						nt_question_dup:
>bdfa		04 10				        .byte 4, UF
>bdfc		06 be 35 9a 48 9a		        .word nt_plus, xt_question_dup, z_question_dup
>be02		3f 64 75 70			        .text "?dup"
.be06						nt_plus:
>be06		01 10				        .byte 1, UF
>be08		0f be af 99 c1 99		        .word nt_minus, xt_plus, z_plus
>be0e		2b				        .text "+"
.be0f						nt_minus:
>be0f		01 10				        .byte 1, UF
>be11		18 be 25 95 37 95		        .word nt_one_minus, xt_minus, z_minus
>be17		2d				        .text "-"
.be18						nt_one_minus:
>be18		02 10				        .byte 2, UF
>be1a		22 be dd 97 e8 97		        .word nt_one_plus, xt_one_minus, z_one_minus
>be20		31 2d				        .text "1-"
.be22						nt_one_plus:
>be22		02 10				        .byte 2, UF
>be24		2c be e9 97 f2 97		        .word nt_two_star, xt_one_plus, z_one_plus
>be2a		31 2b				        .text "1+"
.be2c						nt_two_star:
>be2c		02 10				        .byte 2, UF
>be2e		36 be cb a3 d2 a3		        .word nt_two_slash, xt_two_star, z_two_star
>be34		32 2a				        .text "2*"
.be36						nt_two_slash:
>be36		02 10				        .byte 2, UF
>be38		40 be c0 a3 ca a3		        .word nt_abs, xt_two_slash, z_two_slash
>be3e		32 2f				        .text "2/"
.be40						nt_abs:
>be40		03 10				        .byte 3, UF
>be42		4b be d1 80 e5 80		        .word nt_dabs, xt_abs, z_abs
>be48		61 62 73			        .text "abs"
.be4b						nt_dabs:
>be4b		04 10				        .byte 4, UF
>be4d		57 be 1e 8a 3c 8a		        .word nt_and, xt_dabs, z_dabs
>be53		64 61 62 73			        .text "dabs"
.be57						nt_and:
>be57		03 10				        .byte 3, UF
>be59		62 be d6 82 e7 82		        .word nt_or, xt_and, z_and
>be5f		61 6e 64			        .text "and"
.be62						nt_or:
>be62		02 10				        .byte 2, UF
>be64		6c be ff 97 10 98		        .word nt_xor, xt_or, z_or
>be6a		6f 72				        .text "or"
.be6c						nt_xor:
>be6c		03 10				        .byte 3, UF
>be6e		77 be 24 a7 35 a7		        .word nt_rshift, xt_xor, z_xor
>be74		78 6f 72			        .text "xor"
.be77						nt_rshift:
>be77		06 10				        .byte 6, UF
>be79		85 be 38 9b 4b 9b		        .word nt_lshift, xt_rshift, z_rshift
>be7f		72 73 68 69 66 74		        .text "rshift"
.be85						nt_lshift:
>be85		06 10				        .byte 6, UF
>be87		93 be 4f 94 62 94		        .word nt_pick, xt_lshift, z_lshift
>be8d		6c 73 68 69 66 74		        .text "lshift"
.be93						nt_pick:
>be93		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be95		9f be 9e 99 ae 99		        .word nt_char, xt_pick, z_pick
>be9b		70 69 63 6b			        .text "pick"
.be9f						nt_char:
>be9f		04 00				        .byte 4, 0
>bea1		ab be b4 85 ca 85		        .word nt_bracket_char, xt_char, z_char
>bea7		63 68 61 72			        .text "char"
.beab						nt_bracket_char:
>beab		06 05				        .byte 6, CO+IM
>bead		b9 be 30 85 36 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>beb3		5b 63 68 61 72 5d		        .text "[char]"
.beb9						nt_char_plus:
>beb9		05 00				        .byte 5, 0
>bebb		c6 be e9 97 f2 97		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bec1		63 68 61 72 2b			        .text "char+"
.bec6						nt_chars:
>bec6		05 12				        .byte 5, AN+UF   ; deleted during compile
>bec8		d3 be cb 85 ce 85		        .word nt_cells, xt_chars, z_chars
>bece		63 68 61 72 73			        .text "chars"
.bed3						nt_cells:
>bed3		05 00				        .byte 5, 0
>bed5		e0 be cb a3 d2 a3		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bedb		63 65 6c 6c 73			        .text "cells"
.bee0						nt_cell_plus:
>bee0		05 10				        .byte 5, UF
>bee2		ed be a4 85 b3 85		        .word nt_here, xt_cell_plus, z_cell_plus
>bee8		63 65 6c 6c 2b			        .text "cell+"
.beed						nt_here:
>beed		04 00				        .byte 4, 0
>beef		f9 be 24 91 2e 91		        .word nt_equal, xt_here, z_here
>bef5		68 65 72 65			        .text "here"
.bef9						nt_equal:
>bef9		01 10				        .byte 1, UF
>befb		02 bf 80 8e 9b 8e		        .word nt_not_equals, xt_equal, z_equal
>bf01		3d				        .text "="
.bf02						nt_not_equals:
>bf02		02 10				        .byte 2, UF
>bf04		0c bf 1f 96 3c 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bf0a		3c 3e				        .text "<>"
.bf0c						nt_less_than:
>bf0c		01 10				        .byte 1, UF
>bf0e		15 bf 2c 93 40 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bf14		3c				        .text "<"
.bf15						nt_u_less_than:
>bf15		02 10				        .byte 2, UF
>bf17		1f bf ed a4 02 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bf1d		75 3c				        .text "u<"
.bf1f						nt_u_greater_than:
>bf1f		02 10				        .byte 2, UF
>bf21		29 bf d7 a4 ec a4		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bf27		75 3e				        .text "u>"
.bf29						nt_greater_than:
>bf29		01 10				        .byte 1, UF
>bf2b		32 bf 0f 91 23 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bf31		3e				        .text ">"
.bf32						nt_zero_equal:
>bf32		02 10				        .byte 2, UF
>bf34		3c bf 3d a7 4e a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bf3a		30 3d				        .text "0="
.bf3c						nt_zero_unequal:
>bf3c		03 10				        .byte 3, UF
>bf3e		47 bf 73 a7 82 a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bf44		30 3c 3e			        .text "0<>"
.bf47						nt_zero_greater:
>bf47		02 10				        .byte 2, UF
>bf49		51 bf 4f a7 62 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf4f		30 3e				        .text "0>"
.bf51						nt_zero_less:
>bf51		02 10				        .byte 2, UF
>bf53		5b bf 63 a7 72 a7		        .word nt_min, xt_zero_less, z_zero_less
>bf59		30 3c				        .text "0<"
.bf5b						nt_min:
>bf5b		03 10				        .byte 3, UF
>bf5d		66 bf 09 95 24 95		        .word nt_max, xt_min, z_min
>bf63		6d 69 6e			        .text "min"
.bf66						nt_max:
>bf66		03 10				        .byte 3, UF
>bf68		71 bf ed 94 08 95		        .word nt_two_drop, xt_max, z_max
>bf6e		6d 61 78			        .text "max"
.bf71						nt_two_drop:
>bf71		05 10				        .byte 5, UF
>bf73		7e bf 2b a3 32 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf79		32 64 72 6f 70			        .text "2drop"
.bf7e						nt_two_swap:
>bf7e		05 10				        .byte 5, UF
>bf80		8b bf f9 a3 1c a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf86		32 73 77 61 70			        .text "2swap"
.bf8b						nt_two_over:
>bf8b		05 10				        .byte 5, UF
>bf8d		98 bf 6d a3 84 a3		        .word nt_two_store, xt_two_over, z_two_over
>bf93		32 6f 76 65 72			        .text "2over"
.bf98						nt_two_store:
>bf98		02 10				        .byte 2, UF
>bf9a		a2 bf d3 a3 f8 a3		        .word nt_two_fetch, xt_two_store, z_two_store
>bfa0		32 21				        .text "2!"
.bfa2						nt_two_fetch:
>bfa2		02 10				        .byte 2, UF
>bfa4		ac bf 4b a3 6c a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bfaa		32 40				        .text "2@"
.bfac						nt_two_variable:
>bfac		09 00				        .byte 9, 0
>bfae		bd bf 6f a4 7d a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>bfb4		32 76 61 72 69 61 62 6c		        .text "2variable"
>bfbc		65
.bfbd						nt_two_constant:
>bfbd		09 10				        .byte 9, UF
>bfbf		ce bf 3d a4 61 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bfc5		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bfcd		74
.bfce						nt_two_literal:
>bfce		08 14				        .byte 8, UF+IM
>bfd0		de bf 62 a4 6e a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bfd6		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bfde						nt_two_r_fetch:
>bfde		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bfe0		e9 bf 85 a3 a2 a3		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bfe6		32 72 40			        .text "2r@"
.bfe9						nt_two_r_from:
>bfe9		03 01				        .byte 3, CO             ; native is special case
>bfeb		f4 bf a3 a3 bf a3		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bff1		32 72 3e			        .text "2r>"
.bff4						nt_two_to_r:
>bff4		03 11				        .byte 3, CO+UF          ; native is special case
>bff6		ff bf 1d a4 3c a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>bffc		32 3e 72			        .text "2>r"
.bfff						nt_invert:
>bfff		06 10				        .byte 6, UF
>c001		0d c0 96 92 a5 92		        .word nt_negate, xt_invert, z_invert
>c007		69 6e 76 65 72 74		        .text "invert"
.c00d						nt_negate:
>c00d		06 10				        .byte 6, UF
>c00f		1b c0 f2 95 02 96		        .word nt_dnegate, xt_negate, z_negate
>c015		6e 65 67 61 74 65		        .text "negate"
.c01b						nt_dnegate:
>c01b		07 10				        .byte 7, UF
>c01d		2a c0 d9 8a f3 8a		        .word nt_c_comma, xt_dnegate, z_dnegate
>c023		64 6e 65 67 61 74 65		        .text "dnegate"
.c02a						nt_c_comma:
>c02a		02 10				        .byte 2, UF
>c02c		34 c0 83 85 8d 85		        .word nt_bounds, xt_c_comma, z_c_comma
>c032		63 2c				        .text "c,"
.c034						nt_bounds:
>c034		06 10				        .byte 6, UF
>c036		42 c0 17 85 2f 85		        .word nt_spaces, xt_bounds, z_bounds
>c03c		62 6f 75 6e 64 73		        .text "bounds"
.c042						nt_spaces:
>c042		06 10				        .byte 6, UF
>c044		50 c0 af a0 ea a0		        .word nt_bl, xt_spaces, z_spaces
>c04a		73 70 61 63 65 73		        .text "spaces"
.c050						nt_bl:
>c050		02 00				        .byte 2, 0
>c052		5a c0 54 83 5c 83		        .word nt_minus_trailing, xt_bl, z_bl
>c058		62 6c				        .text "bl"
.c05a						nt_minus_trailing:
>c05a		09 10				        .byte 9, UF
>c05c		6b c0 51 95 8d 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c062		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c06a		67
.c06b						nt_minus_leading:
>c06b		08 10				        .byte 8, UF
>c06d		7b c0 38 95 50 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c073		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c07b						nt_slash_string:
>c07b		07 10				        .byte 7, UF
>c07d		8a c0 a4 9f c3 9f		        .word nt_refill, xt_slash_string, z_slash_string
>c083		2f 73 74 72 69 6e 67		        .text "/string"
.c08a						nt_refill:
>c08a		06 00				        .byte 6, 0
>c08c		98 c0 c4 9a 05 9b		        .word nt_accept, xt_refill, z_refill
>c092		72 65 66 69 6c 6c		        .text "refill"
.c098						nt_accept:
>c098		06 18				        .byte 6, UF+NN
>c09a		a6 c0 e6 80 de 81		        .word nt_input_to_r, xt_accept, z_accept
>c0a0		61 63 63 65 70 74		        .text "accept"
.c0a6						nt_input_to_r:
>c0a6		07 08				        .byte 7, NN
>c0a8		b5 c0 0d 92 22 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c0ae		69 6e 70 75 74 3e 72		        .text "input>r"
.c0b5						nt_r_to_input:
>c0b5		07 08				        .byte 7, NN
>c0b7		c4 c0 6f 9a 86 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c0bd		72 3e 69 6e 70 75 74		        .text "r>input"
.c0c4						nt_unused:
>c0c4		06 00				        .byte 6, 0
>c0c6		d2 c0 e2 a5 f1 a5		        .word nt_depth, xt_unused, z_unused
>c0cc		75 6e 75 73 65 64		        .text "unused"
.c0d2						nt_depth:
>c0d2		05 00				        .byte 5, 0
>c0d4		df c0 8e 8a 9c 8a		        .word nt_key, xt_depth, z_depth
>c0da		64 65 70 74 68			        .text "depth"
.c0df						nt_key:
>c0df		03 00				        .byte 3, 0
>c0e1		ea c0 d9 92 e2 92		        .word nt_allot, xt_key, z_key
>c0e7		6b 65 79			        .text "key"
.c0ea						nt_allot:
>c0ea		05 10				        .byte 5, UF
>c0ec		f7 c0 43 82 ab 82		        .word nt_create, xt_allot, z_allot
>c0f2		61 6c 6c 6f 74			        .text "allot"
.c0f7						nt_create:
>c0f7		06 00				        .byte 6, 0
>c0f9		05 c1 01 89 d5 89		        .word nt_does, xt_create, z_create
>c0ff		63 72 65 61 74 65		        .text "create"
.c105						nt_does:
>c105		05 05				        .byte 5, CO+IM
>c107		12 c1 75 8b 83 8b		        .word nt_variable, xt_does, z_does
>c10d		64 6f 65 73 3e			        .text "does>"
.c112						nt_variable:
>c112		08 00				        .byte 8, 0
>c114		22 c1 06 a6 1e a6		        .word nt_constant, xt_variable, z_variable
>c11a		76 61 72 69 61 62 6c 65		        .text "variable"
.c122						nt_constant:
>c122		08 10				        .byte 8, UF
>c124		32 c1 a9 88 e6 88		        .word nt_value, xt_constant, z_constant
>c12a		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c132						nt_value:
>c132		05 10				        .byte 5, UF
>c134		3f c1 a9 88 e6 88		        .word nt_to, xt_constant, z_constant
>c13a		76 61 6c 75 65			        .text "value"
.c13f						nt_to:
>c13f		02 0c				        .byte 2, NN+IM
>c141		49 c1 ac a1 07 a2		        .word nt_s_to_d, xt_to, z_to
>c147		74 6f				        .text "to"
.c149						nt_s_to_d:
>c149		03 10				        .byte 3, UF
>c14b		54 c1 42 9e 53 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c151		73 3e 64			        .text "s>d"
.c154						nt_d_to_s:
>c154		03 10				        .byte 3, UF
>c156		5f c1 18 8a 1d 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c15c		64 3e 73			        .text "d>s"
.c15f						nt_d_minus:
>c15f		02 10				        .byte 2, UF
>c161		69 c1 d6 89 f6 89		        .word nt_d_plus, xt_d_minus, z_d_minus
>c167		64 2d				        .text "d-"
.c169						nt_d_plus:
>c169		02 10				        .byte 2, UF
>c16b		73 c1 f7 89 17 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c171		64 2b				        .text "d+"
.c173						nt_erase:
>c173		05 00				        .byte 5, 0      ; underflow checked by FILL
>c175		80 c1 a6 8e ee 8e		        .word nt_blank, xt_erase, z_erase
>c17b		65 72 61 73 65			        .text "erase"
.c180						nt_blank:
>c180		05 00				        .byte 5, 0     ; underflow checked by FILL
>c182		8d c1 9c 8e ee 8e		        .word nt_fill, xt_blank, z_blank
>c188		62 6c 61 6e 6b			        .text "blank"
.c18d						nt_fill:
>c18d		04 10				        .byte 4, UF
>c18f		99 c1 ac 8e ee 8e		        .word nt_find_name, xt_fill, z_fill
>c195		66 69 6c 6c			        .text "fill"
.c199						nt_find_name:
>c199		09 10				        .byte 9, UF
>c19b		aa c1 8d 8f 38 90		        .word nt_tick, xt_find_name, z_find_name
>c1a1		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c1a9		65
.c1aa						nt_tick:
>c1aa		01 00				        .byte 1, 0
>c1ac		b3 c1 8c a1 ab a1		        .word nt_bracket_tick, xt_tick, z_tick
>c1b2		27				        .text "'"
.c1b3						nt_bracket_tick:
>c1b3		03 05				        .byte 3, CO+IM
>c1b5		be c1 37 85 3d 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c1bb		5b 27 5d			        .text "[']"
.c1be						nt_name_to_int:
>c1be		08 10				        .byte 8, UF
>c1c0		ce c1 b6 95 d2 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c1c6		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c1ce						nt_int_to_name:
>c1ce		08 10				        .byte 8, UF
>c1d0		de c1 23 92 95 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c1d6		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c1de						nt_name_to_string:
>c1de		0b 10				        .byte 11, UF
>c1e0		f1 c1 d3 95 ec 95		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c1e6		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1ee		69 6e 67
.c1f1						nt_to_body:
>c1f1		05 10				        .byte 5, UF
>c1f3		fe c1 08 a2 2c a2		        .word nt_defer, xt_to_body, z_to_body
>c1f9		3e 62 6f 64 79			        .text ">body"
.c1fe						nt_defer:
>c1fe		05 00				        .byte 5, 0
>c200		0b c2 44 8a 76 8a		        .word nt_latestxt, xt_defer, z_defer
>c206		64 65 66 65 72			        .text "defer"
.c20b						nt_latestxt:
>c20b		08 00				        .byte 8, 0
>c20d		1b c2 f4 92 fa 92		        .word nt_latestnt, xt_latestxt, z_latestxt
>c213		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c21b						nt_latestnt:
>c21b		08 00				        .byte 8, 0
>c21d		2b c2 e6 92 f3 92		        .word nt_parse_name, xt_latestnt, z_latestnt
>c223		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c22b						nt_parse_name:
>c22b		0a 08				        .byte 10, NN
>c22d		3d c2 ab 98 9d 99		        .word nt_parse, xt_parse_name, z_parse_name
>c233		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c23b		6d 65
.c23d						nt_parse:
>c23d		05 10				        .byte 5, UF
>c23f		4a c2 06 99 9d 99		        .word nt_execute_parsing, xt_parse, z_parse
>c245		70 61 72 73 65			        .text "parse"
.c24a						nt_execute_parsing:
>c24a		0f 10				        .byte 15, UF
>c24c		61 c2 03 8f 29 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c252		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c25a		70 61 72 73 69 6e 67
.c261						nt_source:
>c261		06 00				        .byte 6, 0
>c263		6f c2 89 a0 9d a0		        .word nt_source_id, xt_source, z_source
>c269		73 6f 75 72 63 65		        .text "source"
.c26f						nt_source_id:
>c26f		09 00				        .byte 9, 0
>c271		80 c2 9e a0 a8 a0		        .word nt_colon, xt_source_id, z_source_id
>c277		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c27f		64
.c280						nt_colon:
>c280		01 00				        .byte 1, 0
>c282		89 c2 92 86 d4 86		        .word nt_semicolon, xt_colon, z_colon
>c288		3a				        .text ":"
.c289						nt_semicolon:
>c289		01 05				        .byte 1, CO+IM
>c28b		92 c2 13 9f 71 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c291		3b				        .text ";"
.c292						nt_colon_noname:
>c292		07 00				        .byte 7, 0
>c294		a1 c2 d5 86 f0 86		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c29a		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c2a1						nt_compile_comma:
>c2a1		08 18				        .byte 8, UF+NN
>c2a3		b1 c2 70 87 9c 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c2a9		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c2b1						nt_left_bracket:
>c2b1		01 05				        .byte 1, IM+CO
>c2b3		ba c2 19 93 1d 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c2b9		5b				        .text "["
.c2ba						nt_right_bracket:
>c2ba		01 04				        .byte 1, IM
>c2bc		c3 c2 0c 9b 12 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c2c2		5d				        .text "]"
.c2c3						nt_literal:
>c2c3		07 15				        .byte 7, IM+CO+UF
>c2c5		d2 c2 4e 93 5b 93		        .word nt_sliteral, xt_literal, z_literal
>c2cb		6c 69 74 65 72 61 6c		        .text "literal"
.c2d2						nt_sliteral:
>c2d2		08 15				        .byte 8, CO+IM+UF
>c2d4		e2 c2 c4 9f 33 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c2da		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c2e2						nt_dot_quote:
>c2e2		02 05				        .byte 2, CO+IM
>c2e4		ec c2 e7 8b f1 8b		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2ea		2e 22				        .text ".", $22
.c2ec						nt_s_quote:
>c2ec		02 0c				        .byte 2, IM+NN
>c2ee		f6 c2 14 9d 41 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2f4		73 22				        .text "s", $22
.c2f6						nt_s_backslash_quote:
>c2f6		03 04				        .byte 3, IM
>c2f8		01 c3 4c 9b 55 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2fe		73 5c 22			        .text "s", $5C, $22
.c301						nt_postpone:
>c301		08 05				        .byte 8, IM+CO
>c303		11 c3 e2 99 20 9a		        .word nt_immediate, xt_postpone, z_postpone
>c309		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c311						nt_immediate:
>c311		09 00				        .byte 9, 0
>c313		22 c3 f6 91 01 92		        .word nt_compile_only, xt_immediate, z_immediate
>c319		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c321		65
.c322						nt_compile_only:
>c322		0c 00				        .byte 12, 0
>c324		36 c3 9d 88 a8 88		        .word nt_never_native, xt_compile_only, z_compile_only
>c32a		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c332		6f 6e 6c 79
.c336						nt_never_native:
>c336		0c 00				        .byte 12, 0
>c338		4a c3 03 96 10 96		        .word nt_always_native, xt_never_native, z_never_native
>c33e		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c346		74 69 76 65
.c34a						nt_always_native:
>c34a		0d 00				        .byte 13, 0
>c34c		5f c3 c8 82 d5 82		        .word nt_allow_native, xt_always_native, z_always_native
>c352		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c35a		61 74 69 76 65
.c35f						nt_allow_native:
>c35f		0c 00				        .byte 12, 0
>c361		73 c3 ac 82 b7 82		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c367		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c36f		74 69 76 65
.c373						nt_nc_limit:
>c373		08 08				        .byte 8, NN
>c375		83 c3 ed 95 f2 95		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c37b		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c383						nt_strip_underflow:
>c383		0f 08				        .byte 15, NN
>c385		9a c3 2e a1 33 a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c38b		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c393		64 65 72 66 6c 6f 77
.c39a						nt_abort:
>c39a		05 00				        .byte 5, 0
>c39c		a7 c3 60 80 b1 80		        .word nt_abort_quote, xt_abort, z_abort
>c3a2		61 62 6f 72 74			        .text "abort"
.c3a7						nt_abort_quote:
>c3a7		06 0d				        .byte 6, CO+IM+NN
>c3a9		b5 c3 b1 80 bb 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c3af		61 62 6f 72 74 22		        .text "abort", $22
.c3b5						nt_do:
>c3b5		02 0d				        .byte 2, CO+IM+NN
>c3b7		bf c3 f8 8a 32 8b		        .word nt_question_do, xt_do, z_do
>c3bd		64 6f				        .text "do"
.c3bf						nt_question_do:
>c3bf		03 0d				        .byte 3, CO+IM+NN
>c3c1		ca c3 f4 8a 32 8b		        .word nt_i, xt_question_do, z_question_do
>c3c7		3f 64 6f			        .text "?do"
.c3ca						nt_i:
>c3ca		01 01				        .byte 1, CO
>c3cc		d3 c3 9b 91 af 91		        .word nt_j, xt_i, z_i
>c3d2		69				        .text "i"
.c3d3						nt_j:
>c3d3		01 01				        .byte 1, CO
>c3d5		dc c3 bf 92 d8 92		        .word nt_loop, xt_j, z_j
>c3db		6a				        .text "j"
.c3dc						nt_loop:
>c3dc		04 05				        .byte 4, CO+IM
>c3de		e8 c3 bf 93 21 94		        .word nt_plus_loop, xt_loop, z_loop
>c3e4		6c 6f 6f 70			        .text "loop"
.c3e8						nt_plus_loop:
>c3e8		05 05				        .byte 5, CO+IM
>c3ea		f5 c3 d0 93 21 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3f0		2b 6c 6f 6f 70			        .text "+loop"
.c3f5						nt_exit:
>c3f5		04 03				        .byte 4, AN+CO
>c3f7		01 c4 2a 8f 2b 8f		        .word nt_unloop, xt_exit, z_exit
>c3fd		65 78 69 74			        .text "exit"
.c401						nt_unloop:
>c401		06 01				        .byte 6, CO
>c403		0f c4 bd a5 cc a5		        .word nt_leave, xt_unloop, z_unloop
>c409		75 6e 6c 6f 6f 70		        .text "unloop"
.c40f						nt_leave:
>c40f		05 05				        .byte 5, CO+IM
>c411		1c c4 fb 92 18 93		        .word nt_recurse, xt_leave, z_leave
>c417		6c 65 61 76 65			        .text "leave"
.c41c						nt_recurse:
>c41c		07 0d				        .byte 7, CO+IM+NN
>c41e		2b c4 87 9a c3 9a		        .word nt_quit, xt_recurse, z_recurse
>c424		72 65 63 75 72 73 65		        .text "recurse"
.c42b						nt_quit:
>c42b		04 00				        .byte 4, 0
>c42d		37 c4 62 80 b1 80		        .word nt_begin, xt_quit, z_quit
>c433		71 75 69 74			        .text "quit"
.c437						nt_begin:
>c437		05 07				        .byte 5, AN+CO+IM
>c439		44 c4 4a 83 4d 83		        .word nt_again, xt_begin, z_begin
>c43f		62 65 67 69 6e			        .text "begin"
.c444						nt_again:
>c444		05 17				        .byte 5, AN+CO+IM+UF
>c446		51 c4 21 82 41 82		        .word nt_state, xt_again, z_again
>c44c		61 67 61 69 6e			        .text "again"
.c451						nt_state:
>c451		05 00				        .byte 5, 0
>c453		5e c4 0d a1 17 a1		        .word nt_evaluate, xt_state, z_state
>c459		73 74 61 74 65			        .text "state"
.c45e						nt_evaluate:
>c45e		08 10				        .byte 8, UF
>c460		6e c4 87 90 da 90		        .word nt_base, xt_evaluate, z_evaluate
>c466		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c46e						nt_base:
>c46e		04 00				        .byte 4, 0
>c470		7a c4 41 83 49 83		        .word nt_digit_question, xt_base, z_base
>c476		62 61 73 65			        .text "base"
.c47a						nt_digit_question:
>c47a		06 10				        .byte 6, UF
>c47c		88 c4 9d 8a d1 8a		        .word nt_number, xt_digit_question, z_digit_question
>c482		64 69 67 69 74 3f		        .text "digit?"
.c488						nt_number:
>c488		06 10				        .byte 6, UF
>c48a		96 c4 59 96 52 97		        .word nt_to_number, xt_number, z_number
>c490		6e 75 6d 62 65 72		        .text "number"
.c496						nt_to_number:
>c496		07 10				        .byte 7, UF
>c498		a5 c4 38 a2 d7 a2		        .word nt_hex, xt_to_number, z_to_number
>c49e		3e 6e 75 6d 62 65 72		        .text ">number"
.c4a5						nt_hex:
>c4a5		03 00				        .byte 3, 0
>c4a7		b0 c4 2f 91 35 91		        .word nt_decimal, xt_hex, z_hex
>c4ad		68 65 78			        .text "hex"
.c4b0						nt_decimal:
>c4b0		07 00				        .byte 7, 0
>c4b2		bf c4 3d 8a 43 8a		        .word nt_count, xt_decimal, z_decimal
>c4b8		64 65 63 69 6d 61 6c		        .text "decimal"
.c4bf						nt_count:
>c4bf		05 10				        .byte 5, UF
>c4c1		cc c4 e7 88 fa 88		        .word nt_m_star, xt_count, z_count
>c4c7		63 6f 75 6e 74			        .text "count"
.c4cc						nt_m_star:
>c4cc		02 10				        .byte 2, UF
>c4ce		d6 c4 63 94 7d 94		        .word nt_um_star, xt_m_star, z_m_star
>c4d4		6d 2a				        .text "m*"
.c4d6						nt_um_star:
>c4d6		03 10				        .byte 3, UF
>c4d8		e1 c4 77 a5 bc a5		        .word nt_star, xt_um_star, z_um_star
>c4de		75 6d 2a			        .text "um*"
.c4e1						nt_star:
>c4e1		01 10				        .byte 1, UF
>c4e3		ea c4 eb a0 f3 a0		        .word nt_um_slash_mod, xt_star, z_star
>c4e9		2a				        .text "*"
.c4ea						nt_um_slash_mod:
>c4ea		06 10				        .byte 6, UF
>c4ec		f8 c4 35 a5 76 a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4f2		75 6d 2f 6d 6f 64		        .text "um/mod"
.c4f8						nt_sm_slash_rem:
>c4f8		06 10				        .byte 6, UF
>c4fa		06 c5 60 a0 88 a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c500		73 6d 2f 72 65 6d		        .text "sm/rem"
.c506						nt_fm_slash_mod:
>c506		06 10				        .byte 6, UF
>c508		14 c5 43 90 79 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c50e		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c514						nt_slash:
>c514		01 10				        .byte 1, UF
>c516		1d c5 87 9f a3 9f		        .word nt_slash_mod, xt_slash, z_slash
>c51c		2f				        .text "/"
.c51d						nt_slash_mod:
>c51d		04 10				        .byte 4, UF
>c51f		29 c5 8c 9f a3 9f		        .word nt_mod, xt_slash_mod, z_slash_mod
>c525		2f 6d 6f 64			        .text "/mod"
.c529						nt_mod:
>c529		03 10				        .byte 3, UF
>c52b		34 c5 8e 95 96 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c531		6d 6f 64			        .text "mod"
.c534						nt_star_slash_mod:
>c534		05 10				        .byte 5, UF
>c536		41 c5 fd a0 0c a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c53c		2a 2f 6d 6f 64			        .text "*/mod"
.c541						nt_star_slash:
>c541		02 10				        .byte 2, UF
>c543		4b c5 f4 a0 fc a0		        .word nt_backslash, xt_star_slash, z_star_slash
>c549		2a 2f				        .text "*/"
.c54b						nt_backslash:
>c54b		01 04				        .byte 1, IM
>c54d		54 c5 16 83 40 83		        .word nt_move, xt_backslash, z_backslash
>c553		5c				        .byte $5c
.c554						nt_move:
>c554		04 18				        .byte 4, NN+UF
>c556		60 c5 97 95 b5 95		        .word nt_cmove_up, xt_move, z_move
>c55c		6d 6f 76 65			        .text "move"
.c560						nt_cmove_up:
>c560		06 10				        .byte 6, UF
>c562		6e c5 57 86 91 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c568		63 6d 6f 76 65 3e		        .text "cmove>"
.c56e						nt_cmove:
>c56e		05 10				        .byte 5, UF
>c570		7b c5 1c 86 56 86		        .word nt_pad, xt_cmove, z_cmove
>c576		63 6d 6f 76 65			        .text "cmove"
.c57b						nt_pad:
>c57b		03 00				        .byte 3, 0
>c57d		86 c5 6d 98 7c 98		        .word nt_cleave, xt_pad, z_pad
>c583		70 61 64			        .text "pad"
.c586						nt_cleave:
>c586		06 10				        .byte 6, UF
>c588		94 c5 cf 85 1b 86		        .word nt_hexstore, xt_cleave, z_cleave
>c58e		63 6c 65 61 76 65		        .text "cleave"
.c594						nt_hexstore:
>c594		08 10				        .byte 8, UF
>c596		a4 c5 36 91 88 91		        .word nt_within, xt_hexstore, z_hexstore
>c59c		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c5a4						nt_within:
>c5a4		06 10				        .byte 6, UF
>c5a6		b2 c5 33 a6 48 a6		        .word nt_to_in, xt_within, z_within
>c5ac		77 69 74 68 69 6e		        .text "within"
.c5b2						nt_to_in:
>c5b2		03 00				        .byte 3, 0
>c5b4		bd c5 2d a2 37 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c5ba		3e 69 6e			        .text ">in"
.c5bd						nt_less_number_sign:
>c5bd		02 00				        .byte 2, 0
>c5bf		c7 c5 1e 93 2b 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c5c5		3c 23				        .text "<#"
.c5c7						nt_number_sign:
>c5c7		01 10				        .byte 1, UF
>c5c9		d0 c5 53 97 87 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c5cf		23				        .text "#"
.c5d0						nt_number_sign_s:
>c5d0		02 10				        .byte 2, UF
>c5d2		da c5 aa 97 ba 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c5d8		23 73				        .text "#s"
.c5da						nt_number_sign_greater:
>c5da		02 10				        .byte 2, UF
>c5dc		e4 c5 88 97 a9 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c5e2		23 3e				        .text "#>"
.c5e4						nt_hold:
>c5e4		04 10				        .byte 4, UF
>c5e6		f0 c5 89 91 9a 91		        .word nt_sign, xt_hold, z_hold
>c5ec		68 6f 6c 64			        .text "hold"
.c5f0						nt_sign:
>c5f0		04 10				        .byte 4, UF
>c5f2		fc c5 72 9f 86 9f		        .word nt_output, xt_sign, z_sign
>c5f8		73 69 67 6e			        .text "sign"
.c5fc						nt_output:
>c5fc		06 00				        .byte 6, 0
>c5fe		0a c6 54 98 5e 98		        .word nt_input, xt_output, z_output
>c604		6f 75 74 70 75 74		        .text "output"
.c60a						nt_input:
>c60a		05 00				        .byte 5, 0
>c60c		17 c6 02 92 0c 92		        .word nt_cr, xt_input, z_input
>c612		69 6e 70 75 74			        .text "input"
.c617						nt_cr:
>c617		02 00				        .byte 2, 0
>c619		21 c6 fb 88 00 89		        .word nt_page, xt_cr, z_cr
>c61f		63 72				        .text "cr"
.c621						nt_page:
>c621		04 00				        .byte 4, 0
>c623		2d c6 7d 98 9a 98		        .word nt_at_xy, xt_page, z_page
>c629		70 61 67 65			        .text "page"
.c62d						nt_at_xy:
>c62d		05 10				        .byte 5, UF
>c62f		3a c6 e8 82 15 83		        .word nt_marker, xt_at_xy, z_at_xy
>c635		61 74 2d 78 79			        .text "at-xy"
.c63a						nt_marker:
>c63a		06 04				        .byte 6, IM
>c63c		48 c6 7e 94 bb 94		        .word nt_words, xt_marker, z_marker
>c642		6d 61 72 6b 65 72		        .text "marker"
.c648						nt_words:
>c648		05 00				        .byte 5, 0
>c64a		55 c6 a6 a6 02 a7		        .word nt_wordsize, xt_words, z_words
>c650		77 6f 72 64 73			        .text "words"
.c655						nt_wordsize:
>c655		08 10				        .byte 8, UF
>c657		65 c6 03 a7 23 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c65d		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c665						nt_aligned:
>c665		07 00				        .byte 7, 0
>c667		74 c6 42 82 42 82		        .word nt_align, xt_align, z_align
>c66d		61 6c 69 67 6e 65 64		        .text "aligned"
.c674						nt_align:
>c674		05 00				        .byte 5, 0
>c676		81 c6 42 82 42 82		        .word nt_bell, xt_align, z_align
>c67c		61 6c 69 67 6e			        .text "align"
.c681						nt_bell:
>c681		04 00				        .byte 4, 0
>c683		8d c6 4e 83 53 83		        .word nt_dump, xt_bell, z_bell
>c689		62 65 6c 6c			        .text "bell"
.c68d						nt_dump:
>c68d		04 10				        .byte 4, UF
>c68f		99 c6 b4 8c 1a 8d		        .word nt_dot_s, xt_dump, z_dump
>c695		64 75 6d 70			        .text "dump"
.c699						nt_dot_s:
>c699		02 00				        .byte 2, 0
>c69b		a3 c6 20 8c 63 8c		        .word +, xt_dot_s, z_dot_s
>c6a1		2e 73				        .text ".s"
.c6a3						+
.c6a3						nt_disasm:
>c6a3		06 10				        .byte 6, UF
>c6a5		b1 c6 d2 8a d8 8a		        .word +, xt_disasm, z_disasm
>c6ab		64 69 73 61 73 6d		        .text "disasm"
.c6b1						+
.c6b1						nt_compare:
>c6b1		07 10				        .byte 7, UF
>c6b3		c0 c6 0b 87 6f 87		        .word nt_search, xt_compare, z_compare
>c6b9		63 6f 6d 70 61 72 65		        .text "compare"
.c6c0						nt_search:
>c6c0		06 18				        .byte 6, UF+NN
>c6c2		ce c6 74 9e 12 9f		        .word +, xt_search, z_search
>c6c8		73 65 61 72 63 68		        .text "search"
.c6ce						+
.c6ce						nt_environment_q:
>c6ce		0c 10				        .byte 12, UF
>c6d0		e2 c6 c7 8d 43 8e		        .word +, xt_environment_q, z_environment_q
>c6d6		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6de		65 6e 74 3f
.c6e2						+
.c6e2						nt_find:
>c6e2		04 10				        .byte 4, UF
>c6e4		ee c6 45 8f 8c 8f		        .word nt_word, xt_find, z_find
>c6ea		66 69 6e 64			        .text "find"
.c6ee						nt_word:
>c6ee		04 10				        .byte 4, UF
>c6f0		fa c6 49 a6 8e a6		        .word nt_paren, xt_word, z_word
>c6f6		77 6f 72 64			        .text "word"
.c6fa						nt_paren:
>c6fa		01 04				        .byte 1, IM
>c6fc		03 c7 9b 98 aa 98		        .word nt_dot_paren, xt_paren, z_paren
>c702		28				        .text "("
.c703						nt_dot_paren:
>c703		02 04				        .byte 2, IM
>c705		0d c7 d8 8b e6 8b		        .word nt_if, xt_dot_paren, z_dot_paren
>c70b		2e 28				        .text ".("
.c70d						nt_if:
>c70d		02 0d				        .byte 2, IM+CO+NN
>c70f		17 c7 b0 91 c0 91		        .word nt_then, xt_if, z_if
>c715		69 66				        .text "if"
.c717						nt_then:
>c717		04 0d				        .byte 4, IM+CO+NN
>c719		23 c7 52 8d 9b 8d		        .word nt_else, xt_then, z_then
>c71f		74 68 65 6e			        .text "then"
.c723						nt_else:
>c723		04 0d				        .byte 4, IM+CO+NN
>c725		2f c7 41 8d 9b 8d		        .word nt_repeat, xt_else, z_else
>c72b		65 6c 73 65			        .text "else"
.c72f						nt_repeat:
>c72f		06 0d				        .byte 6, IM+CO+NN
>c731		3d c7 06 9b 0c 9b		        .word nt_until, xt_repeat, z_repeat
>c737		72 65 70 65 61 74		        .text "repeat"
.c73d						nt_until:
>c73d		05 0d				        .byte 5, IM+CO+NN
>c73f		4a c7 cd a5 e1 a5		        .word nt_while, xt_until, z_until
>c745		75 6e 74 69 6c			        .text "until"
.c74a						nt_while:
>c74a		05 0d				        .byte 5, IM+CO+NN
>c74c		57 c7 1f a6 32 a6		        .word nt_case, xt_while, z_while
>c752		77 68 69 6c 65			        .text "while"
.c757						nt_case:
>c757		04 0d				        .byte 4, IM+CO+NN
>c759		63 c7 36 a7 3c a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c75f		63 61 73 65			        .text "case"
.c763						nt_of:
>c763		02 0d				        .byte 2, IM+CO+NN
>c765		6d c7 bb 97 d3 97		        .word nt_endof, xt_of, z_of
>c76b		6f 66				        .text "of"
.c76d						nt_endof:
>c76d		05 0d				        .byte 5, IM+CO+NN
>c76f		7a c7 41 8d 9b 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c775		65 6e 64 6f 66			        .text "endof"
.c77a						nt_endcase:
>c77a		07 0d				        .byte 7, IM+CO+NN
>c77c		89 c7 b2 8d c6 8d		        .word nt_defer_fetch, xt_endcase, z_endcase
>c782		65 6e 64 63 61 73 65		        .text "endcase"
.c789						nt_defer_fetch:
>c789		06 00				        .byte 6, 0
>c78b		97 c7 77 8a 7d 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c791		64 65 66 65 72 40		        .text "defer@"
.c797						nt_defer_store:
>c797		06 00				        .byte 6, 0
>c799		a5 c7 7e 8a 84 8a		        .word nt_is, xt_defer_store, z_defer_store
>c79f		64 65 66 65 72 21		        .text "defer!"
.c7a5						nt_is:
>c7a5		02 04				        .byte 2, IM
>c7a7		af c7 a6 92 be 92		        .word nt_action_of, xt_is, z_is
>c7ad		69 73				        .text "is"
.c7af						nt_action_of:
>c7af		09 04				        .byte 9, IM
>c7b1		c0 c7 08 82 20 82		        .word nt_useraddr, xt_action_of, z_action_of
>c7b7		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c7bf		66
.c7c0						nt_useraddr:
>c7c0		08 00				        .byte 8, 0
>c7c2		d0 c7 fb a5 05 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c7c8		75 73 65 72 61 64 64 72		        .text "useraddr"
.c7d0						nt_buffer_colon:
>c7d0		07 00				        .byte 7, 0
>c7d2		df c7 74 85 7a 85		        .word +, xt_buffer_colon, z_buffer_colon
>c7d8		62 75 66 66 65 72 3a		        .text "buffer:"
.c7df						+
.c7df						nt_buffstatus:
>c7df		0a 00				        .byte 10, 0
>c7e1		f1 c7 7b 85 80 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7e7		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7ef		75 73
.c7f1						nt_buffblocknum:
>c7f1		0c 00				        .byte 12, 0
>c7f3		05 c8 3e 85 43 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7f9		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c801		6b 6e 75 6d
.c805						nt_blkbuffer:
>c805		09 00				        .byte 9, 0
>c807		16 c8 62 83 6f 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c80d		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c815		72
.c816						nt_scr:
>c816		03 08				        .byte 3, NN
>c818		21 c8 6f 9e 74 9e		        .word nt_blk, xt_scr, z_scr
>c81e		73 63 72			        .text "scr"
.c821						nt_blk:
>c821		03 08				        .byte 3, NN
>c823		2c c8 5d 83 62 83		        .word nt_block_write, xt_blk, z_blk
>c829		62 6c 6b			        .text "blk"
.c82c						nt_block_write:
>c82c		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c82e		3f c8 04 85 12 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c834		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c83c		69 74 65
.c83f						nt_block_write_vector:
>c83f		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c841		59 c8 12 85 17 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c847		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c84f		69 74 65 2d 76 65 63 74 6f 72
.c859						nt_block_read:
>c859		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c85b		6b c8 ec 84 fa 84		        .word nt_block_read_vector, xt_block_read, z_block_read
>c861		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c869		61 64
.c86b						nt_block_read_vector:
>c86b		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c86d		84 c8 fa 84 ff 84		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c873		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c87b		61 64 2d 76 65 63 74 6f 72
.c884						nt_save_buffers:
>c884		0c 00				        .byte 12, 0
>c886		98 c8 54 9e 6e 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c88c		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c894		66 65 72 73
.c898						nt_block:
>c898		05 00				        .byte 5, 0
>c89a		a5 c8 70 83 c2 83		        .word nt_update, xt_block, z_block
>c8a0		62 6c 6f 63 6b			        .text "block"
.c8a5						nt_update:
>c8a5		06 00				        .byte 6, 0
>c8a7		b3 c8 f2 a5 fa a5		        .word nt_buffer, xt_update, z_update
>c8ad		75 70 64 61 74 65		        .text "update"
.c8b3						nt_buffer:
>c8b3		06 00				        .byte 6, 0
>c8b5		c1 c8 43 85 73 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c8bb		62 75 66 66 65 72		        .text "buffer"
.c8c1						nt_empty_buffers:
>c8c1		0d 00				        .byte 13, 0
>c8c3		d6 c8 ab 8d b1 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c8c9		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c8d1		66 66 65 72 73
.c8d6						nt_flush:
>c8d6		05 00				        .byte 5, 0
>c8d8		e3 c8 39 90 42 90		        .word nt_load, xt_flush, z_flush
>c8de		66 6c 75 73 68			        .text "flush"
.c8e3						nt_load:
>c8e3		04 10				        .byte 4, UF
>c8e5		ef c8 7b 93 be 93		        .word nt_thru, xt_load, z_load
>c8eb		6c 6f 61 64			        .text "load"
.c8ef						nt_thru:
>c8ef		04 10				        .byte 4, UF
>c8f1		fb c8 47 a1 8b a1		        .word nt_list, xt_thru, z_thru
>c8f7		74 68 72 75			        .text "thru"
.c8fb						nt_list:
>c8fb		04 10				        .byte 4, UF
>c8fd		07 c9 41 93 4d 93		        .word +, xt_list, z_list
>c903		6c 69 73 74			        .text "list"
.c907						+
.c907						nt_block_ramdrive_init:
>c907		13 10				        .byte 19, UF
>c909		22 c9 c3 83 eb 84		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c90f		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c917		6d 64 72 69 76 65 2d 69 6e 69 74
.c922						+
.c922						nt_definitions:
>c922		0b 00				        .byte 11, 0
>c924		35 c9 85 8a 8d 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c92a		64 65 66 69 6e 69 74 69		        .text "definitions"
>c932		6f 6e 73
.c935						nt_wordlist:
>c935		08 00				        .byte 8, 0
>c937		45 c9 8f a6 a5 a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c93d		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c945						nt_search_wordlist:
>c945		0f 10				        .byte 15, UF
>c947		5c c9 65 9b 45 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c94d		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c955		6f 72 64 6c 69 73 74
.c95c						nt_set_current:
>c95c		0b 10				        .byte 11, UF
>c95e		6f c9 d4 9c df 9c		        .word nt_get_current, xt_set_current, z_set_current
>c964		73 65 74 2d 63 75 72 72		        .text "set-current"
>c96c		65 6e 74
.c96f						nt_get_current:
>c96f		0b 00				        .byte 11, 0
>c971		82 c9 db 90 e5 90		        .word nt_set_order, xt_get_current, z_get_current
>c977		67 65 74 2d 63 75 72 72		        .text "get-current"
>c97f		65 6e 74
.c982						nt_set_order:
>c982		09 00				        .byte 9, 0
>c984		93 c9 e0 9c 13 9d		        .word nt_get_order, xt_set_order, z_set_order
>c98a		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c992		72
.c993						nt_get_order:
>c993		09 00				        .byte 9, 0
>c995		a4 c9 e6 90 0e 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c99b		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c9a3		72
.c9a4						nt_root_wordlist:
>c9a4		0d 00				        .byte 13, 0
>c9a6		b9 c9 13 9b 1b 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c9ac		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c9b4		64 6c 69 73 74
.c9b9						+
.c9b9						nt_assembler_wordlist:
>c9b9		12 00				        .byte 18, 0
>c9bb		d3 c9 22 a3 2a a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c9c1		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c9c9		72 2d 77 6f 72 64 6c 69 73 74
.c9d3						+
.c9d3						nt_editor_wordlist:
>c9d3		0f 00				        .byte 15, 0
>c9d5		ea c9 d4 97 dc 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9db		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9e3		6f 72 64 6c 69 73 74
.c9ea						+
.c9ea						nt_forth_wordlist:
>c9ea		0e 00				        .byte 14, 0
>c9ec		00 ca 36 a7 3c a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9f2		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9fa		72 64 6c 69 73 74
.ca00						nt_only:
>ca00		04 00				        .byte 4, 0
>ca02		0c ca f3 97 fe 97		        .word nt_also, xt_only, z_only
>ca08		6f 6e 6c 79			        .text "only"
.ca0c						nt_also:
>ca0c		04 00				        .byte 4, 0
>ca0e		18 ca b8 82 c7 82		        .word nt_previous, xt_also, z_also
>ca14		61 6c 73 6f			        .text "also"
.ca18						nt_previous:
>ca18		08 00				        .byte 8, 0
>ca1a		28 ca 21 9a 2d 9a		        .word nt_to_order, xt_previous, z_previous
>ca20		70 72 65 76 69 6f 75 73		        .text "previous"
.ca28						nt_to_order:
>ca28		06 00				        .byte 6, 0
>ca2a		36 ca d8 a2 ea a2		        .word nt_order, xt_to_order, z_to_order
>ca30		3e 6f 72 64 65 72		        .text ">order"
.ca36						nt_order:
>ca36		05 00				        .byte 5, 0
>ca38		43 ca 11 98 3b 98		        .word nt_forth, xt_order, z_order
>ca3e		6f 72 64 65 72			        .text "order"
.ca43						nt_forth:
>ca43		05 00				        .byte 5, 0
>ca45		50 ca 7a 90 80 90		        .word +, xt_forth, z_forth
>ca4b		66 6f 72 74 68			        .text "forth"
.ca50						+
>ca50		03 08				nt_see: .byte 3, NN
>ca52		5b ca 46 9c d3 9c		        .word +, xt_see, z_see
>ca58		73 65 65			        .text "see"
.ca5b						+
.ca5b						nt_ed:
>ca5b		02 08				        .byte 2, NN
>ca5d		65 ca 3d 8d 40 8d		        .word +, xt_ed, z_ed
>ca63		65 64				        .text "ed"
.ca65						+
.ca65						nt_cold:
>ca65		04 00				        .byte 4, 0
>ca67		71 ca 00 80 b1 80		        .word nt_bye, xt_cold, z_cold
>ca6d		63 6f 6c 64			        .text "cold"
.ca71						nt_bye:
>ca71		03				        .byte 3         ; length of word strings
>ca72		00				        .byte 0         ; status byte
>ca73		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca75		80 85				        .word xt_bye    ; start of code block (xt of this word)
>ca77		83 85				        .word z_bye     ; end of code (RTS)
>ca79		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca7c						root_dictionary_start:
.ca7c						nt_root_set_order:
>ca7c		09 00				        .byte 9, 0
>ca7e		8d ca e0 9c 13 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca84		73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca8c		72
.ca8d						nt_root_forth:
>ca8d		05 00				        .byte 5, 0
>ca8f		9a ca 7a 90 80 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca95		66 6f 72 74 68			        .text "forth"
.ca9a						nt_root_forth_wordlist:
>ca9a		0e 00				        .byte 14, 0
>ca9c		b0 ca 36 a7 3c a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>caa2		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>caaa		72 64 6c 69 73 74
.cab0						nt_root_words:
>cab0		05 00				        .byte 5, 0
>cab2		00 00 a6 a6 02 a7		        .word 0000, xt_words, z_words
>cab8		77 6f 72 64 73			        .text "words"
.cabd						editor_dictionary_start:
.cabd						nt_editor_o:
>cabd		01 00				        .byte 1, 0
>cabf		c6 ca 65 a8 aa a8		        .word nt_editor_line, xt_editor_o, z_editor_o
>cac5		6f				        .text "o"
.cac6						nt_editor_line:
>cac6		04 10				        .byte 4, UF
>cac8		d2 ca 4c a8 64 a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>cace		6c 69 6e 65			        .text "line"
.cad2						nt_editor_l:
>cad2		01 00				        .byte 1, 0
>cad4		db ca d0 a7 4b a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cada		6c				        .text "l"
.cadb						nt_editor_el:
>cadb		02 00				        .byte 2, 0
>cadd		e5 ca be a7 cf a7		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cae3		65 6c				        .text "el"
.cae5						nt_editor_erase_screen:
>cae5		0c 00				        .byte 12, 0
>cae7		f9 ca ac a7 bd a7		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>caed		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>caf5		72 65 65 6e
.caf9						nt_editor_enter_screen:
>caf9		0c 00				        .byte 12, 0
>cafb		00 00 90 a7 ab a7		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cb01		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cb09		72 65 65 6e
.cb0d						assembler_dictionary_start:
.cb0d						nt_asm_adc_h:
>cb0d		05 0c						.byte 5, IM+NN
>cb0f		1a cb				                .word nt_asm_adc_x
>cb11		ff a8 04 a9					.word xt_asm_adc_h, z_asm_adc_h
>cb15		61 64 63 2e 23					.text "adc.#"
.cb1a						nt_asm_adc_x:
>cb1a		05 0c						.byte 5, IM+NN
>cb1c		27 cb				                .word nt_asm_adc_y
>cb1e		04 a9 09 a9					.word xt_asm_adc_x, z_asm_adc_x
>cb22		61 64 63 2e 78					.text "adc.x"
.cb27						nt_asm_adc_y:
>cb27		05 0c						.byte 5, IM+NN
>cb29		34 cb				                .word nt_asm_adc_z
>cb2b		09 a9 0e a9					.word xt_asm_adc_y, z_asm_adc_y
>cb2f		61 64 63 2e 79					.text "adc.y"
.cb34						nt_asm_adc_z:
>cb34		05 0c						.byte 5, IM+NN
>cb36		41 cb				                .word nt_asm_adc_zi
>cb38		0e a9 13 a9					.word xt_asm_adc_z, z_asm_adc_z
>cb3c		61 64 63 2e 7a					.text "adc.z"
.cb41						nt_asm_adc_zi:
>cb41		06 0c						.byte 6, IM+NN
>cb43		4f cb				                .word nt_asm_adc_ziy
>cb45		13 a9 18 a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cb49		61 64 63 2e 7a 69				.text "adc.zi"
.cb4f						nt_asm_adc_ziy:
>cb4f		07 0c						.byte 7, IM+NN
>cb51		5e cb				                .word nt_asm_adc_zx
>cb53		18 a9 1d a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb57		61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb5e						nt_asm_adc_zx:
>cb5e		06 0c						.byte 6, IM+NN
>cb60		6c cb				                .word nt_asm_adc_zxi
>cb62		1d a9 22 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb66		61 64 63 2e 7a 78				.text "adc.zx"
.cb6c						nt_asm_adc_zxi:
>cb6c		07 0c						.byte 7, IM+NN
>cb6e		7b cb				                .word nt_asm_and
>cb70		22 a9 27 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb74		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb7b						nt_asm_and:
>cb7b		04 0c						.byte 4, IM+NN
>cb7d		87 cb				                .word nt_asm_and_h
>cb7f		27 a9 2c a9					.word xt_asm_and, z_asm_and
>cb83		61 6e 64 2e					.text "and."
.cb87						nt_asm_and_h:
>cb87		05 0c						.byte 5, IM+NN
>cb89		94 cb				                .word nt_asm_and_x
>cb8b		2c a9 31 a9					.word xt_asm_and_h, z_asm_and_h
>cb8f		61 6e 64 2e 23					.text "and.#"
.cb94						nt_asm_and_x:
>cb94		05 0c						.byte 5, IM+NN
>cb96		a1 cb				                .word nt_asm_and_y
>cb98		31 a9 36 a9					.word xt_asm_and_x, z_asm_and_x
>cb9c		61 6e 64 2e 78					.text "and.x"
.cba1						nt_asm_and_y:
>cba1		05 0c						.byte 5, IM+NN
>cba3		ae cb				                .word nt_asm_and_z
>cba5		36 a9 3b a9					.word xt_asm_and_y, z_asm_and_y
>cba9		61 6e 64 2e 79					.text "and.y"
.cbae						nt_asm_and_z:
>cbae		05 0c						.byte 5, IM+NN
>cbb0		bb cb				                .word nt_asm_and_zi
>cbb2		3b a9 40 a9					.word xt_asm_and_z, z_asm_and_z
>cbb6		61 6e 64 2e 7a					.text "and.z"
.cbbb						nt_asm_and_zi:
>cbbb		06 0c						.byte 6, IM+NN
>cbbd		c9 cb				                .word nt_asm_and_ziy
>cbbf		40 a9 45 a9					.word xt_asm_and_zi, z_asm_and_zi
>cbc3		61 6e 64 2e 7a 69				.text "and.zi"
.cbc9						nt_asm_and_ziy:
>cbc9		07 0c						.byte 7, IM+NN
>cbcb		d8 cb				                .word nt_asm_and_zx
>cbcd		45 a9 4a a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cbd1		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbd8						nt_asm_and_zx:
>cbd8		06 0c						.byte 6, IM+NN
>cbda		e6 cb				                .word nt_asm_and_zxi
>cbdc		4a a9 4f a9					.word xt_asm_and_zx, z_asm_and_zx
>cbe0		61 6e 64 2e 7a 78				.text "and.zx"
.cbe6						nt_asm_and_zxi:
>cbe6		07 0c						.byte 7, IM+NN
>cbe8		f5 cb				                .word nt_asm_asl
>cbea		4f a9 54 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cbee		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cbf5						nt_asm_asl:
>cbf5		03 0c						.byte 3, IM+NN
>cbf7		00 cc				                .word nt_asm_asl_a
>cbf9		54 a9 59 a9					.word xt_asm_asl, z_asm_asl
>cbfd		61 73 6c					.text "asl"
.cc00						nt_asm_asl_a:
>cc00		05 0c						.byte 5, IM+NN
>cc02		0d cc				                .word nt_asm_asl_x
>cc04		59 a9 5e a9					.word xt_asm_asl_a, z_asm_asl_a
>cc08		61 73 6c 2e 61					.text "asl.a"
.cc0d						nt_asm_asl_x:
>cc0d		05 0c						.byte 5, IM+NN
>cc0f		1a cc				                .word nt_asm_asl_z
>cc11		5e a9 63 a9					.word xt_asm_asl_x, z_asm_asl_x
>cc15		61 73 6c 2e 78					.text "asl.x"
.cc1a						nt_asm_asl_z:
>cc1a		05 0c						.byte 5, IM+NN
>cc1c		27 cc				                .word nt_asm_asl_zx
>cc1e		63 a9 68 a9					.word xt_asm_asl_z, z_asm_asl_z
>cc22		61 73 6c 2e 7a					.text "asl.z"
.cc27						nt_asm_asl_zx:
>cc27		06 0c						.byte 6, IM+NN
>cc29		35 cc				                .word nt_asm_bcc
>cc2b		68 a9 6d a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cc2f		61 73 6c 2e 7a 78				.text "asl.zx"
.cc35						nt_asm_bcc:
>cc35		03 0c						.byte 3, IM+NN
>cc37		40 cc				                .word nt_asm_bcs
>cc39		6d a9 72 a9					.word xt_asm_bcc, z_asm_bcc
>cc3d		62 63 63					.text "bcc"
.cc40						nt_asm_bcs:
>cc40		03 0c						.byte 3, IM+NN
>cc42		4b cc				                .word nt_asm_beq
>cc44		72 a9 79 a9					.word xt_asm_bcs, z_asm_bcs
>cc48		62 63 73					.text "bcs"
.cc4b						nt_asm_beq:
>cc4b		03 0c						.byte 3, IM+NN
>cc4d		56 cc				                .word nt_asm_bit
>cc4f		79 a9 7e a9					.word xt_asm_beq, z_asm_beq
>cc53		62 65 71					.text "beq"
.cc56						nt_asm_bit:
>cc56		03 0c						.byte 3, IM+NN
>cc58		61 cc				                .word nt_asm_bit_h
>cc5a		7e a9 83 a9					.word xt_asm_bit, z_asm_bit
>cc5e		62 69 74					.text "bit"
.cc61						nt_asm_bit_h:
>cc61		05 0c						.byte 5, IM+NN
>cc63		6e cc				                .word nt_asm_bit_x
>cc65		83 a9 88 a9					.word xt_asm_bit_h, z_asm_bit_h
>cc69		62 69 74 2e 23					.text "bit.#"
.cc6e						nt_asm_bit_x:
>cc6e		05 0c						.byte 5, IM+NN
>cc70		7b cc				                .word nt_asm_bit_z
>cc72		88 a9 8d a9					.word xt_asm_bit_x, z_asm_bit_x
>cc76		62 69 74 2e 78					.text "bit.x"
.cc7b						nt_asm_bit_z:
>cc7b		05 0c						.byte 5, IM+NN
>cc7d		88 cc				                .word nt_asm_bit_zx
>cc7f		8d a9 92 a9					.word xt_asm_bit_z, z_asm_bit_z
>cc83		62 69 74 2e 7a					.text "bit.z"
.cc88						nt_asm_bit_zx:
>cc88		06 0c						.byte 6, IM+NN
>cc8a		96 cc				                .word nt_asm_bmi
>cc8c		92 a9 97 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc90		62 69 74 2e 7a 78				.text "bit.zx"
.cc96						nt_asm_bmi:
>cc96		03 0c						.byte 3, IM+NN
>cc98		a1 cc				                .word nt_asm_bne
>cc9a		97 a9 9c a9					.word xt_asm_bmi, z_asm_bmi
>cc9e		62 6d 69					.text "bmi"
.cca1						nt_asm_bne:
>cca1		03 0c						.byte 3, IM+NN
>cca3		ac cc				                .word nt_asm_bpl
>cca5		9c a9 a1 a9					.word xt_asm_bne, z_asm_bne
>cca9		62 6e 65					.text "bne"
.ccac						nt_asm_bpl:
>ccac		03 0c						.byte 3, IM+NN
>ccae		b7 cc				                .word nt_asm_bra
>ccb0		a1 a9 a6 a9					.word xt_asm_bpl, z_asm_bpl
>ccb4		62 70 6c					.text "bpl"
.ccb7						nt_asm_bra:
>ccb7		03 0c						.byte 3, IM+NN
>ccb9		c2 cc				                .word nt_asm_brk
>ccbb		a6 a9 ab a9					.word xt_asm_bra, z_asm_bra
>ccbf		62 72 61					.text "bra"
.ccc2						nt_asm_brk:
>ccc2		03 0c						.byte 3, IM+NN
>ccc4		cd cc				                .word nt_asm_bvc
>ccc6		ab a9 b0 a9					.word xt_asm_brk, z_asm_brk
>ccca		62 72 6b					.text "brk"
.cccd						nt_asm_bvc:
>cccd		03 0c						.byte 3, IM+NN
>cccf		d8 cc				                .word nt_asm_bvs
>ccd1		b0 a9 b5 a9					.word xt_asm_bvc, z_asm_bvc
>ccd5		62 76 63					.text "bvc"
.ccd8						nt_asm_bvs:
>ccd8		03 0c						.byte 3, IM+NN
>ccda		e3 cc				                .word nt_asm_clc
>ccdc		b5 a9 ba a9					.word xt_asm_bvs, z_asm_bvs
>cce0		62 76 73					.text "bvs"
.cce3						nt_asm_clc:
>cce3		03 0c						.byte 3, IM+NN
>cce5		ee cc				                .word nt_asm_cld
>cce7		ba a9 bf a9					.word xt_asm_clc, z_asm_clc
>cceb		63 6c 63					.text "clc"
.ccee						nt_asm_cld:
>ccee		03 0c						.byte 3, IM+NN
>ccf0		f9 cc				                .word nt_asm_cli
>ccf2		bf a9 c4 a9					.word xt_asm_cld, z_asm_cld
>ccf6		63 6c 64					.text "cld"
.ccf9						nt_asm_cli:
>ccf9		03 0c						.byte 3, IM+NN
>ccfb		04 cd				                .word nt_asm_clv
>ccfd		c4 a9 c9 a9					.word xt_asm_cli, z_asm_cli
>cd01		63 6c 69					.text "cli"
.cd04						nt_asm_clv:
>cd04		03 0c						.byte 3, IM+NN
>cd06		0f cd				                .word nt_asm_cmp
>cd08		c9 a9 ce a9					.word xt_asm_clv, z_asm_clv
>cd0c		63 6c 76					.text "clv"
.cd0f						nt_asm_cmp:
>cd0f		03 0c						.byte 3, IM+NN
>cd11		1a cd				                .word nt_asm_cmp_h
>cd13		ce a9 d3 a9					.word xt_asm_cmp, z_asm_cmp
>cd17		63 6d 70					.text "cmp"
.cd1a						nt_asm_cmp_h:
>cd1a		05 0c						.byte 5, IM+NN
>cd1c		27 cd				                .word nt_asm_cmp_x
>cd1e		d3 a9 d8 a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cd22		63 6d 70 2e 23					.text "cmp.#"
.cd27						nt_asm_cmp_x:
>cd27		05 0c						.byte 5, IM+NN
>cd29		34 cd				                .word nt_asm_cmp_y
>cd2b		d8 a9 dd a9					.word xt_asm_cmp_x, z_asm_cmp_x
>cd2f		63 6d 70 2e 78					.text "cmp.x"
.cd34						nt_asm_cmp_y:
>cd34		05 0c						.byte 5, IM+NN
>cd36		41 cd				                .word nt_asm_cmp_z
>cd38		dd a9 e2 a9					.word xt_asm_cmp_y, z_asm_cmp_y
>cd3c		63 6d 70 2e 79					.text "cmp.y"
.cd41						nt_asm_cmp_z:
>cd41		05 0c						.byte 5, IM+NN
>cd43		4e cd				                .word nt_asm_cmp_zi
>cd45		e2 a9 e7 a9					.word xt_asm_cmp_z, z_asm_cmp_z
>cd49		63 6d 70 2e 7a					.text "cmp.z"
.cd4e						nt_asm_cmp_zi:
>cd4e		06 0c						.byte 6, IM+NN
>cd50		5c cd				                .word nt_asm_cmp_ziy
>cd52		e7 a9 ec a9					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd56		63 6d 70 2e 7a 69				.text "cmp.zi"
.cd5c						nt_asm_cmp_ziy:
>cd5c		07 0c						.byte 7, IM+NN
>cd5e		6b cd				                .word nt_asm_cmp_zx
>cd60		ec a9 f1 a9					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd64		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd6b						nt_asm_cmp_zx:
>cd6b		06 0c						.byte 6, IM+NN
>cd6d		79 cd				                .word nt_asm_cmp_zxi
>cd6f		f1 a9 f6 a9					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd73		63 6d 70 2e 7a 78				.text "cmp.zx"
.cd79						nt_asm_cmp_zxi:
>cd79		07 0c						.byte 7, IM+NN
>cd7b		88 cd				                .word nt_asm_cpx
>cd7d		f6 a9 fb a9					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd81		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd88						nt_asm_cpx:
>cd88		03 0c						.byte 3, IM+NN
>cd8a		93 cd				                .word nt_asm_cpx_h
>cd8c		fb a9 00 aa					.word xt_asm_cpx, z_asm_cpx
>cd90		63 70 78					.text "cpx"
.cd93						nt_asm_cpx_h:
>cd93		05 0c						.byte 5, IM+NN
>cd95		a0 cd				                .word nt_asm_cpx_z
>cd97		00 aa 05 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>cd9b		63 70 78 2e 23					.text "cpx.#"
.cda0						nt_asm_cpx_z:
>cda0		05 0c						.byte 5, IM+NN
>cda2		ad cd				                .word nt_asm_cpy
>cda4		05 aa 0a aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cda8		63 70 78 2e 7a					.text "cpx.z"
.cdad						nt_asm_cpy:
>cdad		03 0c						.byte 3, IM+NN
>cdaf		b8 cd				                .word nt_asm_cpy_h
>cdb1		0a aa 11 aa					.word xt_asm_cpy, z_asm_cpy
>cdb5		63 70 79					.text "cpy"
.cdb8						nt_asm_cpy_h:
>cdb8		05 0c						.byte 5, IM+NN
>cdba		c5 cd				                .word nt_asm_cpy_z
>cdbc		11 aa 16 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cdc0		63 70 79 2e 23					.text "cpy.#"
.cdc5						nt_asm_cpy_z:
>cdc5		05 0c						.byte 5, IM+NN
>cdc7		d2 cd				                .word nt_asm_dec
>cdc9		16 aa 1b aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cdcd		63 70 79 2e 7a					.text "cpy.z"
.cdd2						nt_asm_dec:
>cdd2		03 0c						.byte 3, IM+NN
>cdd4		dd cd				                .word nt_asm_dec_a
>cdd6		1b aa 20 aa					.word xt_asm_dec, z_asm_dec
>cdda		64 65 63					.text "dec"
.cddd						nt_asm_dec_a:
>cddd		05 0c						.byte 5, IM+NN
>cddf		ea cd				                .word nt_asm_dec_x
>cde1		20 aa 25 aa					.word xt_asm_dec_a, z_asm_dec_a
>cde5		64 65 63 2e 61					.text "dec.a"
.cdea						nt_asm_dec_x:
>cdea		05 0c						.byte 5, IM+NN
>cdec		f7 cd				                .word nt_asm_dec_z
>cdee		25 aa 2a aa					.word xt_asm_dec_x, z_asm_dec_x
>cdf2		64 65 63 2e 78					.text "dec.x"
.cdf7						nt_asm_dec_z:
>cdf7		05 0c						.byte 5, IM+NN
>cdf9		04 ce				                .word nt_asm_dec_zx
>cdfb		2a aa 2f aa					.word xt_asm_dec_z, z_asm_dec_z
>cdff		64 65 63 2e 7a					.text "dec.z"
.ce04						nt_asm_dec_zx:
>ce04		06 0c						.byte 6, IM+NN
>ce06		12 ce				                .word nt_asm_dex
>ce08		2f aa 34 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>ce0c		64 65 63 2e 7a 78				.text "dec.zx"
.ce12						nt_asm_dex:
>ce12		03 0c						.byte 3, IM+NN
>ce14		1d ce				                .word nt_asm_dey
>ce16		34 aa 39 aa					.word xt_asm_dex, z_asm_dex
>ce1a		64 65 78					.text "dex"
.ce1d						nt_asm_dey:
>ce1d		03 0c						.byte 3, IM+NN
>ce1f		28 ce				                .word nt_asm_eor
>ce21		39 aa 3e aa					.word xt_asm_dey, z_asm_dey
>ce25		64 65 79					.text "dey"
.ce28						nt_asm_eor:
>ce28		03 0c						.byte 3, IM+NN
>ce2a		33 ce				                .word nt_asm_eor_h
>ce2c		3e aa 43 aa					.word xt_asm_eor, z_asm_eor
>ce30		65 6f 72					.text "eor"
.ce33						nt_asm_eor_h:
>ce33		05 0c						.byte 5, IM+NN
>ce35		40 ce				                .word nt_asm_eor_x
>ce37		43 aa 48 aa					.word xt_asm_eor_h, z_asm_eor_h
>ce3b		65 6f 72 2e 23					.text "eor.#"
.ce40						nt_asm_eor_x:
>ce40		05 0c						.byte 5, IM+NN
>ce42		4d ce				                .word nt_asm_eor_y
>ce44		48 aa 4d aa					.word xt_asm_eor_x, z_asm_eor_x
>ce48		65 6f 72 2e 78					.text "eor.x"
.ce4d						nt_asm_eor_y:
>ce4d		05 0c						.byte 5, IM+NN
>ce4f		5a ce				                .word nt_asm_eor_z
>ce51		4d aa 52 aa					.word xt_asm_eor_y, z_asm_eor_y
>ce55		65 6f 72 2e 79					.text "eor.y"
.ce5a						nt_asm_eor_z:
>ce5a		05 0c						.byte 5, IM+NN
>ce5c		67 ce				                .word nt_asm_eor_zi
>ce5e		52 aa 57 aa					.word xt_asm_eor_z, z_asm_eor_z
>ce62		65 6f 72 2e 7a					.text "eor.z"
.ce67						nt_asm_eor_zi:
>ce67		06 0c						.byte 6, IM+NN
>ce69		75 ce				                .word nt_asm_eor_ziy
>ce6b		57 aa 5c aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce6f		65 6f 72 2e 7a 69				.text "eor.zi"
.ce75						nt_asm_eor_ziy:
>ce75		07 0c						.byte 7, IM+NN
>ce77		84 ce				                .word nt_asm_eor_zx
>ce79		5c aa 61 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce7d		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce84						nt_asm_eor_zx:
>ce84		06 0c						.byte 6, IM+NN
>ce86		92 ce				                .word nt_asm_eor_zxi
>ce88		61 aa 66 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce8c		65 6f 72 2e 7a 78				.text "eor.zx"
.ce92						nt_asm_eor_zxi:
>ce92		07 0c						.byte 7, IM+NN
>ce94		a1 ce				                .word nt_asm_inc
>ce96		66 aa 6b aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce9a		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cea1						nt_asm_inc:
>cea1		03 0c						.byte 3, IM+NN
>cea3		ac ce				                .word nt_asm_inc_a
>cea5		6b aa 70 aa					.word xt_asm_inc, z_asm_inc
>cea9		69 6e 63					.text "inc"
.ceac						nt_asm_inc_a:
>ceac		05 0c						.byte 5, IM+NN
>ceae		b9 ce				                .word nt_asm_inc_x
>ceb0		70 aa 75 aa					.word xt_asm_inc_a, z_asm_inc_a
>ceb4		69 6e 63 2e 61					.text "inc.a"
.ceb9						nt_asm_inc_x:
>ceb9		05 0c						.byte 5, IM+NN
>cebb		c6 ce				                .word nt_asm_inc_z
>cebd		75 aa 7a aa					.word xt_asm_inc_x, z_asm_inc_x
>cec1		69 6e 63 2e 78					.text "inc.x"
.cec6						nt_asm_inc_z:
>cec6		05 0c						.byte 5, IM+NN
>cec8		d3 ce				                .word nt_asm_inc_zx
>ceca		7a aa 7f aa					.word xt_asm_inc_z, z_asm_inc_z
>cece		69 6e 63 2e 7a					.text "inc.z"
.ced3						nt_asm_inc_zx:
>ced3		06 0c						.byte 6, IM+NN
>ced5		e1 ce				                .word nt_asm_inx
>ced7		7f aa 84 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>cedb		69 6e 63 2e 7a 78				.text "inc.zx"
.cee1						nt_asm_inx:
>cee1		03 0c						.byte 3, IM+NN
>cee3		ec ce				                .word nt_asm_iny
>cee5		84 aa 89 aa					.word xt_asm_inx, z_asm_inx
>cee9		69 6e 78					.text "inx"
.ceec						nt_asm_iny:
>ceec		03 0c						.byte 3, IM+NN
>ceee		f7 ce				                .word nt_asm_jmp
>cef0		89 aa 8e aa					.word xt_asm_iny, z_asm_iny
>cef4		69 6e 79					.text "iny"
.cef7						nt_asm_jmp:
>cef7		03 0c						.byte 3, IM+NN
>cef9		02 cf				                .word nt_asm_jmp_i
>cefb		8e aa 93 aa					.word xt_asm_jmp, z_asm_jmp
>ceff		6a 6d 70					.text "jmp"
.cf02						nt_asm_jmp_i:
>cf02		05 0c						.byte 5, IM+NN
>cf04		0f cf				                .word nt_asm_jmp_xi
>cf06		93 aa 98 aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cf0a		6a 6d 70 2e 69					.text "jmp.i"
.cf0f						nt_asm_jmp_xi:
>cf0f		06 0c						.byte 6, IM+NN
>cf11		1d cf				                .word nt_asm_jsr
>cf13		98 aa 9d aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cf17		6a 6d 70 2e 78 69				.text "jmp.xi"
.cf1d						nt_asm_jsr:
>cf1d		03 0c						.byte 3, IM+NN
>cf1f		28 cf				                .word nt_asm_lda
>cf21		9d aa a2 aa					.word xt_asm_jsr, z_asm_jsr
>cf25		6a 73 72					.text "jsr"
.cf28						nt_asm_lda:
>cf28		03 0c						.byte 3, IM+NN
>cf2a		33 cf				                .word nt_asm_lda_h
>cf2c		a2 aa a7 aa					.word xt_asm_lda, z_asm_lda
>cf30		6c 64 61					.text "lda"
.cf33						nt_asm_lda_h:
>cf33		05 0c						.byte 5, IM+NN
>cf35		40 cf				                .word nt_asm_lda_x
>cf37		a7 aa ac aa					.word xt_asm_lda_h, z_asm_lda_h
>cf3b		6c 64 61 2e 23					.text "lda.#"
.cf40						nt_asm_lda_x:
>cf40		05 0c						.byte 5, IM+NN
>cf42		4d cf				                .word nt_asm_lda_y
>cf44		ac aa b1 aa					.word xt_asm_lda_x, z_asm_lda_x
>cf48		6c 64 61 2e 78					.text "lda.x"
.cf4d						nt_asm_lda_y:
>cf4d		05 0c						.byte 5, IM+NN
>cf4f		5a cf				                .word nt_asm_lda_z
>cf51		b1 aa b6 aa					.word xt_asm_lda_y, z_asm_lda_y
>cf55		6c 64 61 2e 79					.text "lda.y"
.cf5a						nt_asm_lda_z:
>cf5a		05 0c						.byte 5, IM+NN
>cf5c		67 cf				                .word nt_asm_lda_zi
>cf5e		b6 aa bb aa					.word xt_asm_lda_z, z_asm_lda_z
>cf62		6c 64 61 2e 7a					.text "lda.z"
.cf67						nt_asm_lda_zi:
>cf67		06 0c						.byte 6, IM+NN
>cf69		75 cf				                .word nt_asm_lda_ziy
>cf6b		bb aa c0 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cf6f		6c 64 61 2e 7a 69				.text "lda.zi"
.cf75						nt_asm_lda_ziy:
>cf75		07 0c						.byte 7, IM+NN
>cf77		84 cf				                .word nt_asm_lda_zx
>cf79		c0 aa c5 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf7d		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf84						nt_asm_lda_zx:
>cf84		06 0c						.byte 6, IM+NN
>cf86		92 cf				                .word nt_asm_lda_zxi
>cf88		c5 aa ca aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf8c		6c 64 61 2e 7a 78				.text "lda.zx"
.cf92						nt_asm_lda_zxi:
>cf92		07 0c						.byte 7, IM+NN
>cf94		a1 cf				                .word nt_asm_ldx
>cf96		ca aa cf aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf9a		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cfa1						nt_asm_ldx:
>cfa1		03 0c						.byte 3, IM+NN
>cfa3		ac cf				                .word nt_asm_ldx_h
>cfa5		cf aa d4 aa					.word xt_asm_ldx, z_asm_ldx
>cfa9		6c 64 78					.text "ldx"
.cfac						nt_asm_ldx_h:
>cfac		05 0c						.byte 5, IM+NN
>cfae		b9 cf				                .word nt_asm_ldx_y
>cfb0		d4 aa d9 aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cfb4		6c 64 78 2e 23					.text "ldx.#"
.cfb9						nt_asm_ldx_y:
>cfb9		05 0c						.byte 5, IM+NN
>cfbb		c6 cf				                .word nt_asm_ldx_z
>cfbd		d9 aa de aa					.word xt_asm_ldx_y, z_asm_ldx_y
>cfc1		6c 64 78 2e 79					.text "ldx.y"
.cfc6						nt_asm_ldx_z:
>cfc6		05 0c						.byte 5, IM+NN
>cfc8		d3 cf				                .word nt_asm_ldx_zy
>cfca		de aa e3 aa					.word xt_asm_ldx_z, z_asm_ldx_z
>cfce		6c 64 78 2e 7a					.text "ldx.z"
.cfd3						nt_asm_ldx_zy:
>cfd3		06 0c						.byte 6, IM+NN
>cfd5		e1 cf				                .word nt_asm_ldy
>cfd7		e3 aa e8 aa					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfdb		6c 64 78 2e 7a 79				.text "ldx.zy"
.cfe1						nt_asm_ldy:
>cfe1		03 0c						.byte 3, IM+NN
>cfe3		ec cf				                .word nt_asm_ldy_h
>cfe5		e8 aa ed aa					.word xt_asm_ldy, z_asm_ldy
>cfe9		6c 64 79					.text "ldy"
.cfec						nt_asm_ldy_h:
>cfec		05 0c						.byte 5, IM+NN
>cfee		f9 cf				                .word nt_asm_ldy_x
>cff0		ed aa f2 aa					.word xt_asm_ldy_h, z_asm_ldy_h
>cff4		6c 64 79 2e 23					.text "ldy.#"
.cff9						nt_asm_ldy_x:
>cff9		05 0c						.byte 5, IM+NN
>cffb		06 d0				                .word nt_asm_ldy_z
>cffd		f2 aa f7 aa					.word xt_asm_ldy_x, z_asm_ldy_x
>d001		6c 64 79 2e 78					.text "ldy.x"
.d006						nt_asm_ldy_z:
>d006		05 0c						.byte 5, IM+NN
>d008		13 d0				                .word nt_asm_ldy_zx
>d00a		f7 aa fc aa					.word xt_asm_ldy_z, z_asm_ldy_z
>d00e		6c 64 79 2e 7a					.text "ldy.z"
.d013						nt_asm_ldy_zx:
>d013		06 0c						.byte 6, IM+NN
>d015		21 d0				                .word nt_asm_lsr
>d017		fc aa 01 ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>d01b		6c 64 79 2e 7a 78				.text "ldy.zx"
.d021						nt_asm_lsr:
>d021		03 0c						.byte 3, IM+NN
>d023		2c d0				                .word nt_asm_lsr_a
>d025		01 ab 06 ab					.word xt_asm_lsr, z_asm_lsr
>d029		6c 73 72					.text "lsr"
.d02c						nt_asm_lsr_a:
>d02c		05 0c						.byte 5, IM+NN
>d02e		39 d0				                .word nt_asm_lsr_x
>d030		06 ab 0b ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d034		6c 73 72 2e 61					.text "lsr.a"
.d039						nt_asm_lsr_x:
>d039		05 0c						.byte 5, IM+NN
>d03b		46 d0				                .word nt_asm_lsr_z
>d03d		0b ab 10 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d041		6c 73 72 2e 78					.text "lsr.x"
.d046						nt_asm_lsr_z:
>d046		05 0c						.byte 5, IM+NN
>d048		53 d0				                .word nt_asm_lsr_zx
>d04a		10 ab 15 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d04e		6c 73 72 2e 7a					.text "lsr.z"
.d053						nt_asm_lsr_zx:
>d053		06 0c						.byte 6, IM+NN
>d055		61 d0				                .word nt_asm_nop
>d057		15 ab 1a ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d05b		6c 73 72 2e 7a 78				.text "lsr.zx"
.d061						nt_asm_nop:
>d061		03 0c						.byte 3, IM+NN
>d063		6c d0				                .word nt_asm_ora
>d065		1a ab 1f ab					.word xt_asm_nop, z_asm_nop
>d069		6e 6f 70					.text "nop"
.d06c						nt_asm_ora:
>d06c		03 0c						.byte 3, IM+NN
>d06e		77 d0				                .word nt_asm_ora_h
>d070		1f ab 24 ab					.word xt_asm_ora, z_asm_ora
>d074		6f 72 61					.text "ora"
.d077						nt_asm_ora_h:
>d077		05 0c						.byte 5, IM+NN
>d079		84 d0				                .word nt_asm_ora_x
>d07b		24 ab 29 ab					.word xt_asm_ora_h, z_asm_ora_h
>d07f		6f 72 61 2e 23					.text "ora.#"
.d084						nt_asm_ora_x:
>d084		05 0c						.byte 5, IM+NN
>d086		91 d0				                .word nt_asm_ora_y
>d088		29 ab 2e ab					.word xt_asm_ora_x, z_asm_ora_x
>d08c		6f 72 61 2e 78					.text "ora.x"
.d091						nt_asm_ora_y:
>d091		05 0c						.byte 5, IM+NN
>d093		9e d0				                .word nt_asm_ora_z
>d095		2e ab 33 ab					.word xt_asm_ora_y, z_asm_ora_y
>d099		6f 72 61 2e 79					.text "ora.y"
.d09e						nt_asm_ora_z:
>d09e		05 0c						.byte 5, IM+NN
>d0a0		ab d0				                .word nt_asm_ora_zi
>d0a2		33 ab 38 ab					.word xt_asm_ora_z, z_asm_ora_z
>d0a6		6f 72 61 2e 7a					.text "ora.z"
.d0ab						nt_asm_ora_zi:
>d0ab		06 0c						.byte 6, IM+NN
>d0ad		b9 d0				                .word nt_asm_ora_ziy
>d0af		38 ab 3f ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d0b3		6f 72 61 2e 7a 69				.text "ora.zi"
.d0b9						nt_asm_ora_ziy:
>d0b9		07 0c						.byte 7, IM+NN
>d0bb		c8 d0				                .word nt_asm_ora_zx
>d0bd		3f ab 44 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d0c1		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d0c8						nt_asm_ora_zx:
>d0c8		06 0c						.byte 6, IM+NN
>d0ca		d6 d0				                .word nt_asm_ora_zxi
>d0cc		44 ab 49 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d0d0		6f 72 61 2e 7a 78				.text "ora.zx"
.d0d6						nt_asm_ora_zxi:
>d0d6		07 0c						.byte 7, IM+NN
>d0d8		e5 d0				                .word nt_asm_pha
>d0da		49 ab 4e ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0de		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0e5						nt_asm_pha:
>d0e5		03 0c						.byte 3, IM+NN
>d0e7		f0 d0				                .word nt_asm_php
>d0e9		4e ab 53 ab					.word xt_asm_pha, z_asm_pha
>d0ed		70 68 61					.text "pha"
.d0f0						nt_asm_php:
>d0f0		03 0c						.byte 3, IM+NN
>d0f2		fb d0				                .word nt_asm_phx
>d0f4		53 ab 58 ab					.word xt_asm_php, z_asm_php
>d0f8		70 68 70					.text "php"
.d0fb						nt_asm_phx:
>d0fb		03 0c						.byte 3, IM+NN
>d0fd		06 d1				                .word nt_asm_phy
>d0ff		58 ab 5d ab					.word xt_asm_phx, z_asm_phx
>d103		70 68 78					.text "phx"
.d106						nt_asm_phy:
>d106		03 0c						.byte 3, IM+NN
>d108		11 d1				                .word nt_asm_pla
>d10a		5d ab 62 ab					.word xt_asm_phy, z_asm_phy
>d10e		70 68 79					.text "phy"
.d111						nt_asm_pla:
>d111		03 0c						.byte 3, IM+NN
>d113		1c d1				                .word nt_asm_plp
>d115		62 ab 67 ab					.word xt_asm_pla, z_asm_pla
>d119		70 6c 61					.text "pla"
.d11c						nt_asm_plp:
>d11c		03 0c						.byte 3, IM+NN
>d11e		27 d1				                .word nt_asm_plx
>d120		67 ab 6c ab					.word xt_asm_plp, z_asm_plp
>d124		70 6c 70					.text "plp"
.d127						nt_asm_plx:
>d127		03 0c						.byte 3, IM+NN
>d129		32 d1				                .word nt_asm_ply
>d12b		6c ab 71 ab					.word xt_asm_plx, z_asm_plx
>d12f		70 6c 78					.text "plx"
.d132						nt_asm_ply:
>d132		03 0c						.byte 3, IM+NN
>d134		3d d1				                .word nt_asm_rol
>d136		71 ab 76 ab					.word xt_asm_ply, z_asm_ply
>d13a		70 6c 79					.text "ply"
.d13d						nt_asm_rol:
>d13d		03 0c						.byte 3, IM+NN
>d13f		48 d1				                .word nt_asm_rol_a
>d141		76 ab 7b ab					.word xt_asm_rol, z_asm_rol
>d145		72 6f 6c					.text "rol"
.d148						nt_asm_rol_a:
>d148		05 0c						.byte 5, IM+NN
>d14a		55 d1				                .word nt_asm_rol_x
>d14c		7b ab 80 ab					.word xt_asm_rol_a, z_asm_rol_a
>d150		72 6f 6c 2e 61					.text "rol.a"
.d155						nt_asm_rol_x:
>d155		05 0c						.byte 5, IM+NN
>d157		62 d1				                .word nt_asm_rol_z
>d159		80 ab 85 ab					.word xt_asm_rol_x, z_asm_rol_x
>d15d		72 6f 6c 2e 78					.text "rol.x"
.d162						nt_asm_rol_z:
>d162		05 0c						.byte 5, IM+NN
>d164		6f d1				                .word nt_asm_rol_zx
>d166		85 ab 8a ab					.word xt_asm_rol_z, z_asm_rol_z
>d16a		72 6f 6c 2e 7a					.text "rol.z"
.d16f						nt_asm_rol_zx:
>d16f		06 0c						.byte 6, IM+NN
>d171		7d d1				                .word nt_asm_ror
>d173		8a ab 8f ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d177		72 6f 6c 2e 7a 78				.text "rol.zx"
.d17d						nt_asm_ror:
>d17d		03 0c						.byte 3, IM+NN
>d17f		88 d1				                .word nt_asm_ror_a
>d181		8f ab 94 ab					.word xt_asm_ror, z_asm_ror
>d185		72 6f 72					.text "ror"
.d188						nt_asm_ror_a:
>d188		05 0c						.byte 5, IM+NN
>d18a		95 d1				                .word nt_asm_ror_x
>d18c		94 ab 99 ab					.word xt_asm_ror_a, z_asm_ror_a
>d190		72 6f 72 2e 61					.text "ror.a"
.d195						nt_asm_ror_x:
>d195		05 0c						.byte 5, IM+NN
>d197		a2 d1				                .word nt_asm_ror_z
>d199		99 ab 9e ab					.word xt_asm_ror_x, z_asm_ror_x
>d19d		72 6f 72 2e 78					.text "ror.x"
.d1a2						nt_asm_ror_z:
>d1a2		05 0c						.byte 5, IM+NN
>d1a4		af d1				                .word nt_asm_ror_zx
>d1a6		9e ab a3 ab					.word xt_asm_ror_z, z_asm_ror_z
>d1aa		72 6f 72 2e 7a					.text "ror.z"
.d1af						nt_asm_ror_zx:
>d1af		06 0c						.byte 6, IM+NN
>d1b1		bd d1				                .word nt_asm_rti
>d1b3		a3 ab a8 ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d1b7		72 6f 72 2e 7a 78				.text "ror.zx"
.d1bd						nt_asm_rti:
>d1bd		03 0c						.byte 3, IM+NN
>d1bf		c8 d1				                .word nt_asm_rts
>d1c1		a8 ab ad ab					.word xt_asm_rti, z_asm_rti
>d1c5		72 74 69					.text "rti"
.d1c8						nt_asm_rts:
>d1c8		03 0c						.byte 3, IM+NN
>d1ca		d3 d1				                .word nt_asm_sbc
>d1cc		ad ab b2 ab					.word xt_asm_rts, z_asm_rts
>d1d0		72 74 73					.text "rts"
.d1d3						nt_asm_sbc:
>d1d3		03 0c						.byte 3, IM+NN
>d1d5		de d1				                .word nt_asm_sbc_h
>d1d7		b2 ab b7 ab					.word xt_asm_sbc, z_asm_sbc
>d1db		73 62 63					.text "sbc"
.d1de						nt_asm_sbc_h:
>d1de		05 0c						.byte 5, IM+NN
>d1e0		eb d1				                .word nt_asm_sbc_x
>d1e2		b7 ab bc ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d1e6		73 62 63 2e 23					.text "sbc.#"
.d1eb						nt_asm_sbc_x:
>d1eb		05 0c						.byte 5, IM+NN
>d1ed		f8 d1				                .word nt_asm_sbc_y
>d1ef		bc ab c1 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d1f3		73 62 63 2e 78					.text "sbc.x"
.d1f8						nt_asm_sbc_y:
>d1f8		05 0c						.byte 5, IM+NN
>d1fa		05 d2				                .word nt_asm_sbc_z
>d1fc		c1 ab c6 ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d200		73 62 63 2e 79					.text "sbc.y"
.d205						nt_asm_sbc_z:
>d205		05 0c						.byte 5, IM+NN
>d207		12 d2				                .word nt_asm_sbc_zi
>d209		c6 ab cb ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d20d		73 62 63 2e 7a					.text "sbc.z"
.d212						nt_asm_sbc_zi:
>d212		06 0c						.byte 6, IM+NN
>d214		20 d2				                .word nt_asm_sbc_ziy
>d216		cb ab d0 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d21a		73 62 63 2e 7a 69				.text "sbc.zi"
.d220						nt_asm_sbc_ziy:
>d220		07 0c						.byte 7, IM+NN
>d222		2f d2				                .word nt_asm_sbc_zx
>d224		d0 ab d5 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d228		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d22f						nt_asm_sbc_zx:
>d22f		06 0c						.byte 6, IM+NN
>d231		3d d2				                .word nt_asm_sbc_zxi
>d233		d5 ab da ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d237		73 62 63 2e 7a 78				.text "sbc.zx"
.d23d						nt_asm_sbc_zxi:
>d23d		07 0c						.byte 7, IM+NN
>d23f		4c d2				                .word nt_asm_sec
>d241		da ab de ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d245		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d24c						nt_asm_sec:
>d24c		03 0c						.byte 3, IM+NN
>d24e		57 d2				                .word nt_asm_sed
>d250		de ab e2 ab					.word xt_asm_sec, z_asm_sec
>d254		73 65 63					.text "sec"
.d257						nt_asm_sed:
>d257		03 0c						.byte 3, IM+NN
>d259		62 d2				                .word nt_asm_sei
>d25b		e2 ab e6 ab					.word xt_asm_sed, z_asm_sed
>d25f		73 65 64					.text "sed"
.d262						nt_asm_sei:
>d262		03 0c						.byte 3, IM+NN
>d264		6d d2				                .word nt_asm_sta
>d266		e6 ab ea ab					.word xt_asm_sei, z_asm_sei
>d26a		73 65 69					.text "sei"
.d26d						nt_asm_sta:
>d26d		03 0c						.byte 3, IM+NN
>d26f		78 d2				                .word nt_asm_sta_x
>d271		ea ab ee ab					.word xt_asm_sta, z_asm_sta
>d275		73 74 61					.text "sta"
.d278						nt_asm_sta_x:
>d278		05 0c						.byte 5, IM+NN
>d27a		85 d2				                .word nt_asm_sta_y
>d27c		ee ab f2 ab					.word xt_asm_sta_x, z_asm_sta_x
>d280		73 74 61 2e 78					.text "sta.x"
.d285						nt_asm_sta_y:
>d285		05 0c						.byte 5, IM+NN
>d287		92 d2				                .word nt_asm_sta_z
>d289		f2 ab f6 ab					.word xt_asm_sta_y, z_asm_sta_y
>d28d		73 74 61 2e 79					.text "sta.y"
.d292						nt_asm_sta_z:
>d292		05 0c						.byte 5, IM+NN
>d294		9f d2				                .word nt_asm_sta_zi
>d296		f6 ab fa ab					.word xt_asm_sta_z, z_asm_sta_z
>d29a		73 74 61 2e 7a					.text "sta.z"
.d29f						nt_asm_sta_zi:
>d29f		06 0c						.byte 6, IM+NN
>d2a1		ad d2				                .word nt_asm_sta_ziy
>d2a3		fa ab fe ab					.word xt_asm_sta_zi, z_asm_sta_zi
>d2a7		73 74 61 2e 7a 69				.text "sta.zi"
.d2ad						nt_asm_sta_ziy:
>d2ad		07 0c						.byte 7, IM+NN
>d2af		bc d2				                .word nt_asm_sta_zx
>d2b1		fe ab 02 ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d2b5		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d2bc						nt_asm_sta_zx:
>d2bc		06 0c						.byte 6, IM+NN
>d2be		ca d2				                .word nt_asm_sta_zxi
>d2c0		02 ac 06 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d2c4		73 74 61 2e 7a 78				.text "sta.zx"
.d2ca						nt_asm_sta_zxi:
>d2ca		07 0c						.byte 7, IM+NN
>d2cc		d9 d2				                .word nt_asm_stx
>d2ce		06 ac 0a ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2d2		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2d9						nt_asm_stx:
>d2d9		03 0c						.byte 3, IM+NN
>d2db		e4 d2				                .word nt_asm_stx_z
>d2dd		0a ac 0e ac					.word xt_asm_stx, z_asm_stx
>d2e1		73 74 78					.text "stx"
.d2e4						nt_asm_stx_z:
>d2e4		05 0c						.byte 5, IM+NN
>d2e6		f1 d2				                .word nt_asm_stx_zy
>d2e8		0e ac 12 ac					.word xt_asm_stx_z, z_asm_stx_z
>d2ec		73 74 78 2e 7a					.text "stx.z"
.d2f1						nt_asm_stx_zy:
>d2f1		06 0c						.byte 6, IM+NN
>d2f3		ff d2				                .word nt_asm_sty
>d2f5		12 ac 16 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d2f9		73 74 78 2e 7a 79				.text "stx.zy"
.d2ff						nt_asm_sty:
>d2ff		03 0c						.byte 3, IM+NN
>d301		0a d3				                .word nt_asm_sty_z
>d303		16 ac 1a ac					.word xt_asm_sty, z_asm_sty
>d307		73 74 79					.text "sty"
.d30a						nt_asm_sty_z:
>d30a		05 0c						.byte 5, IM+NN
>d30c		17 d3				                .word nt_asm_sty_zx
>d30e		1a ac 1e ac					.word xt_asm_sty_z, z_asm_sty_z
>d312		73 74 79 2e 7a					.text "sty.z"
.d317						nt_asm_sty_zx:
>d317		06 0c						.byte 6, IM+NN
>d319		25 d3				                .word nt_asm_stz
>d31b		1e ac 22 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d31f		73 74 79 2e 7a 78				.text "sty.zx"
.d325						nt_asm_stz:
>d325		03 0c						.byte 3, IM+NN
>d327		30 d3				                .word nt_asm_stz_x
>d329		22 ac 26 ac					.word xt_asm_stz, z_asm_stz
>d32d		73 74 7a					.text "stz"
.d330						nt_asm_stz_x:
>d330		05 0c						.byte 5, IM+NN
>d332		3d d3				                .word nt_asm_stz_z
>d334		26 ac 2a ac					.word xt_asm_stz_x, z_asm_stz_x
>d338		73 74 7a 2e 78					.text "stz.x"
.d33d						nt_asm_stz_z:
>d33d		05 0c						.byte 5, IM+NN
>d33f		4a d3				                .word nt_asm_stz_zx
>d341		2a ac 2e ac					.word xt_asm_stz_z, z_asm_stz_z
>d345		73 74 7a 2e 7a					.text "stz.z"
.d34a						nt_asm_stz_zx:
>d34a		06 0c						.byte 6, IM+NN
>d34c		58 d3				                .word nt_asm_tax
>d34e		2e ac 32 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d352		73 74 7a 2e 7a 78				.text "stz.zx"
.d358						nt_asm_tax:
>d358		03 0c						.byte 3, IM+NN
>d35a		63 d3				                .word nt_asm_tay
>d35c		32 ac 36 ac					.word xt_asm_tax, z_asm_tax
>d360		74 61 78					.text "tax"
.d363						nt_asm_tay:
>d363		03 0c						.byte 3, IM+NN
>d365		6e d3				                .word nt_asm_trb
>d367		36 ac 3a ac					.word xt_asm_tay, z_asm_tay
>d36b		74 61 79					.text "tay"
.d36e						nt_asm_trb:
>d36e		03 0c						.byte 3, IM+NN
>d370		79 d3				                .word nt_asm_trb_z
>d372		3a ac 3e ac					.word xt_asm_trb, z_asm_trb
>d376		74 72 62					.text "trb"
.d379						nt_asm_trb_z:
>d379		05 0c						.byte 5, IM+NN
>d37b		86 d3				                .word nt_asm_tsb
>d37d		3e ac 42 ac					.word xt_asm_trb_z, z_asm_trb_z
>d381		74 72 62 2e 7a					.text "trb.z"
.d386						nt_asm_tsb:
>d386		03 0c						.byte 3, IM+NN
>d388		91 d3				                .word nt_asm_tsb_z
>d38a		42 ac 46 ac					.word xt_asm_tsb, z_asm_tsb
>d38e		74 73 62					.text "tsb"
.d391						nt_asm_tsb_z:
>d391		05 0c						.byte 5, IM+NN
>d393		9e d3				                .word nt_asm_tsx
>d395		46 ac 4a ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d399		74 73 62 2e 7a					.text "tsb.z"
.d39e						nt_asm_tsx:
>d39e		03 0c						.byte 3, IM+NN
>d3a0		a9 d3				                .word nt_asm_txa
>d3a2		4a ac 4e ac					.word xt_asm_tsx, z_asm_tsx
>d3a6		74 73 78					.text "tsx"
.d3a9						nt_asm_txa:
>d3a9		03 0c						.byte 3, IM+NN
>d3ab		b4 d3				                .word nt_asm_txs
>d3ad		4e ac 52 ac					.word xt_asm_txa, z_asm_txa
>d3b1		74 78 61					.text "txa"
.d3b4						nt_asm_txs:
>d3b4		03 0c						.byte 3, IM+NN
>d3b6		bf d3				                .word nt_asm_tya
>d3b8		52 ac 56 ac					.word xt_asm_txs, z_asm_txs
>d3bc		74 78 73					.text "txs"
.d3bf						nt_asm_tya:
>d3bf		03 0c						.byte 3, IM+NN
>d3c1		ca d3				                .word nt_asm_arrow
>d3c3		56 ac 5a ac					.word xt_asm_tya, z_asm_tya
>d3c7		74 79 61					.text "tya"
.d3ca						nt_asm_arrow:
>d3ca		03 04				                .byte 3, IM
>d3cc		d5 d3				                .word nt_asm_back_jump
>d3ce		24 91 2e 91			                .word xt_asm_arrow, z_asm_arrow
>d3d2		2d 2d 3e			                .text "-->"
.d3d5						nt_asm_back_jump:
>d3d5		02 04				                .byte 2, IM
>d3d7		df d3				                .word nt_asm_back_branch
>d3d9		ab ac ab ac			                .word xt_asm_back_jump, z_asm_back_jump
>d3dd		3c 6a				                .text "<j"
.d3df						nt_asm_back_branch:
>d3df		02 04				                .byte 2, IM
>d3e1		e9 d3				                .word nt_asm_push_a
>d3e3		ac ac b4 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d3e7		3c 62				                .text "<b"
.d3e9						nt_asm_push_a:
>d3e9		06 0c				                .byte 6, IM+NN
>d3eb		00 00				                .word 0000
>d3ed		94 ac a3 ac			                .word xt_asm_push_a, z_asm_push_a
>d3f1		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix
=1						ix += 1
=1						str_compile        = ix
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_sdc     = ix
=14						ix += 1
=14						str_disasm_bra     = ix
=15						ix += 1
=15						str_disasm_0test   = ix
=16						ix += 1
.d3f7						string_table:
>d3f7		17 d4 1b d4 25 d4 30 d4		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d3ff		67 d4 5f d4 54 d4 6e d4		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d407		74 d4 90 d4 95 d4 9a d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d40f		ab d4 b4 d4 c6 d4 ce d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra, s_disasm_0test ; 12-15
>d417		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d41b		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d423		64 00
>d425		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d42d		64 20 00
>d430		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d438		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d448		4f 50 51 52 53 54 55 56 57 58 59 5a
>d454		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d45c		72 20 00
>d45f		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d467		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d46e		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d474		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d47c		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d48c		29 3a 20 00
>d490		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d495		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d49a		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d4a2		63 69 6d 61 6c 29 3a 20 00
>d4ab		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d4b3		00
>d4b4		53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d4bc		50 54 48 20 43 48 45 43 4b 00
>d4c6		42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
>d4ce		30 54 45 53 54 00		s_disasm_0test: .text "0TEST",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d4d4						error_table:
>d4d4		f0 d4 11 d5 31 d5 52 d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4dc		6f d5 80 d5 90 d5 be d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4e4		d6 d5 f7 d5 0c d6 28 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4ec		3f d6 7e d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d4f0		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4f8		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d508		65 20 6d 65 6d 6f 72 79 00
>d511		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d519		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d529		20 52 45 46 49 4c 4c 00
>d531		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d539		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d549		6e 6c 79 20 77 6f 72 64 00
>d552		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d55a		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d56a		20 79 65 74 00
>d56f		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d577		20 62 79 20 7a 65 72 6f 00
>d580		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d588		66 61 69 6c 75 72 65 00
>d590		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d598		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d5a8		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d5b8		64 20 2d 31 29 00
>d5be		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5c6		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5d6		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d5de		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d5ee		64 20 6e 75 6d 62 65 72 00
>d5f7		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d5ff		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d60c		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d614		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d624		4c 4f 54 00
>d628		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d630		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d63f		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d647		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d657		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d667		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d677		56 45 43 54 4f 52 00
>d67e		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d686		74 61 63 6b 3a 00
>d68c		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d694		44 2d 53 54 52 49 4e 47
>d69c		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d6a2		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d6a7		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d6af		2d 55 4e 49 54 2d 42 49 54 53
>d6b9		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d6c1		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6c9		52
>d6ca		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6d0		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6d6		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6de		53 54 41 43 4b 2d 43 45 4c 4c 53
>d6e9		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6f1		45 4c 4c 53
>d6f5		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6fd		54 53
>d6ff		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d705		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d70c						cmpl_subroutine:
.d70c		48		pha		                pha             ; save LSB of address
.d70d		a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d70f		80 03		bra $d714	                bra cmpl_common
.d711						cmpl_jump:
.d711		48		pha		                pha             ; save LSB of address
.d712		a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d714						cmpl_common:
.d714		20 1c d7	jsr $d71c	                jsr cmpl_a      ; compile opcode
.d717		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d718						cmpl_word:
.d718		20 1c d7	jsr $d71c	                jsr cmpl_a      ; compile LSB of address
.d71b		98		tya		                tya             ; fall thru for MSB
.d71c						cmpl_a:
.d71c		92 00		sta ($00)	                sta (cp)
.d71e		e6 00		inc $00		                inc cp
.d720		d0 02		bne $d724	                bne _done
.d722		e6 01		inc $01		                inc cp+1
.d724						_done:
.d724		60		rts		                rts
.d725						doconst:
.d725		ca		dex		                dex             ; make room for constant
.d726		ca		dex		                dex
.d727		68		pla		                pla             ; LSB of return address
.d728		85 25		sta $25		                sta tmp1
.d72a		68		pla		                pla             ; MSB of return address
.d72b		85 26		sta $26		                sta tmp1+1
.d72d		a0 01		ldy #$01	                ldy #1
.d72f		b1 25		lda ($25),y	                lda (tmp1),y
.d731		95 00		sta $00,x	                sta 0,x
.d733		c8		iny		                iny
.d734		b1 25		lda ($25),y	                lda (tmp1),y
.d736		95 01		sta $01,x	                sta 1,x
.d738		60		rts		                rts
.d739						dodefer:
.d739		68		pla		                pla             ; LSB
.d73a		85 25		sta $25		                sta tmp1
.d73c		68		pla		                pla             ; MSB
.d73d		85 26		sta $26		                sta tmp1+1
.d73f		a0 01		ldy #$01	                ldy #1
.d741		b1 25		lda ($25),y	                lda (tmp1),y
.d743		85 27		sta $27		                sta tmp2
.d745		c8		iny		                iny
.d746		b1 25		lda ($25),y	                lda (tmp1),y
.d748		85 28		sta $28		                sta tmp2+1
.d74a		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d74d						defer_error:
.d74d		a9 03		lda #$03	                lda #err_defer
.d74f		4c 89 d8	jmp $d889	                jmp error
.d752						dodoes:
.d752		7a		ply		                ply             ; LSB
.d753		68		pla		                pla             ; MSB
.d754		c8		iny		                iny
.d755		d0 01		bne $d758	                bne +
.d757		1a		inc a		                ina
.d758						+
.d758		84 27		sty $27		                sty tmp2
.d75a		85 28		sta $28		                sta tmp2+1
.d75c		ca		dex		                dex
.d75d		ca		dex		                dex
.d75e		7a		ply		                ply
.d75f		68		pla		                pla
.d760		c8		iny		                iny
.d761		d0 01		bne $d764	                bne +
.d763		1a		inc a		                ina
.d764						+
.d764		94 00		sty $00,x	                sty 0,x         ; LSB
.d766		95 01		sta $01,x	                sta 1,x         ; MSB
.d768		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d76b						dovar:
.d76b		7a		ply		                ply             ; LSB
.d76c		68		pla		                pla             ; MSB
.d76d		c8		iny		                iny
.d76e		d0 01		bne $d771	                bne +
.d770		1a		inc a		                ina
.d771						+
.d771		ca		dex		                dex
.d772		ca		dex		                dex
.d773		95 01		sta $01,x	                sta 1,x
.d775		98		tya		                tya
.d776		95 00		sta $00,x	                sta 0,x
.d778		60		rts		                rts
.d779						push_upvar_tos:
.d779		ca		dex		                dex
.d77a		ca		dex		                dex
.d77b		18		clc		                clc
.d77c		65 08		adc $08		                adc up
.d77e		95 00		sta $00,x	                sta 0,x
.d780		a5 09		lda $09		                lda up+1
.d782		90 01		bcc $d785	                bcc +
.d784		1a		inc a		                ina
.d785						+
.d785		95 01		sta $01,x	                sta 1,x
.d787		60		rts		                rts
.d788						byte_to_ascii:
.d788		48		pha		                pha
.d789		4a		lsr a		                lsr             ; convert high nibble first
.d78a		4a		lsr a		                lsr
.d78b		4a		lsr a		                lsr
.d78c		4a		lsr a		                lsr
.d78d		20 91 d7	jsr $d791	                jsr _nibble_to_ascii
.d790		68		pla		                pla
.d791						_nibble_to_ascii:
.d791		29 0f		and #$0f	                and #$0F
.d793		09 30		ora #$30	                ora #'0'
.d795		c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d797		90 02		bcc $d79b	                bcc +
.d799		69 06		adc #$06	                adc #$06
.d79b		4c a8 8d	jmp $8da8	+               jmp emit_a
.d79e		60		rts		                rts
.d79f						compare_16bit:
.d79f		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d7a1		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d7a3		f0 0a		beq $d7af	                beq _equal
.d7a5		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7a7		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7a9		09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d7ab		70 08		bvs $d7b5	                bvs _overflow
.d7ad		80 08		bra $d7b7	                bra _not_equal
.d7af						_equal:
.d7af		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7b1		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7b3		50 04		bvc $d7b9	                bvc _done
.d7b5						_overflow:
.d7b5		49 80		eor #$80	                eor #$80                ; complement negative flag
.d7b7						_not_equal:
.d7b7		09 01		ora #$01	                ora #1                  ; if overflow, we can't be equal
.d7b9						_done:
.d7b9		60		rts		                rts
.d7ba						current_to_dp:
.d7ba		a0 08		ldy #$08	                ldy #current_offset
.d7bc		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d7be		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7bf		18		clc		                clc
.d7c0		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d7c2		a8		tay		                tay
.d7c3		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d7c5		85 02		sta $02		                sta dp
.d7c7		c8		iny		                iny
.d7c8		b1 08		lda ($08),y	                lda (up),y
.d7ca		85 03		sta $03		                sta dp+1
.d7cc		60		rts		                rts
.d7cd						dp_to_current:
.d7cd		a0 08		ldy #$08	                ldy #current_offset
.d7cf		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d7d1		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7d2		18		clc		                clc
.d7d3		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d7d5		a8		tay		                tay
.d7d6		a5 02		lda $02		                lda dp
.d7d8		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d7da		c8		iny		                iny
.d7db		a5 03		lda $03		                lda dp+1
.d7dd		91 08		sta ($08),y	                sta (up),y
.d7df		60		rts		                rts
.d7e0						interpret:
.d7e0						_loop:
.d7e0		20 ab 98	jsr $98ab	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7e3		b5 00		lda $00,x	                lda 0,x
.d7e5		15 01		ora $01,x	                ora 1,x
.d7e7		f0 6b		beq $d854	                beq _line_done
.d7e9		20 33 a3	jsr $a333	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7ec		20 8d 8f	jsr $8f8d	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7ef		b5 00		lda $00,x	                lda 0,x
.d7f1		15 01		ora $01,x	                ora 1,x
.d7f3		d0 28		bne $d81d	                bne _got_name_token
.d7f5		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7f6		e8		inx		                inx
.d7f7		20 59 96	jsr $9659	                jsr xt_number           ; ( addr u -- u|d )
.d7fa		a5 1a		lda $1a		                lda state
.d7fc		f0 e2		beq $d7e0	                beq _loop
.d7fe		a9 20		lda #$20	                lda #$20
.d800		24 1c		bit $1c		                bit status
.d802		f0 0d		beq $d811	                beq _single_number
.d804		20 33 a1	jsr $a133	                jsr xt_swap
.d807		a0 93		ldy #$93	                ldy #>literal_runtime
.d809		a9 5c		lda #$5c	                lda #<literal_runtime
.d80b		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.d80e		20 f1 86	jsr $86f1	                jsr xt_comma
.d811						_single_number:
.d811		a0 93		ldy #$93	                ldy #>literal_runtime
.d813		a9 5c		lda #$5c	                lda #<literal_runtime
.d815		20 0c d7	jsr $d70c	                jsr cmpl_subroutine
.d818		20 f1 86	jsr $86f1	                jsr xt_comma
.d81b		80 c3		bra $d7e0	                bra _loop
.d81d						_got_name_token:
.d81d		b5 00		lda $00,x	                lda 0,x
.d81f		95 04		sta $04,x	                sta 4,x
.d821		b5 01		lda $01,x	                lda 1,x
.d823		95 05		sta $05,x	                sta 5,x
.d825		e8		inx		                inx
.d826		e8		inx		                inx
.d827		e8		inx		                inx
.d828		e8		inx		                inx                     ; ( nt )
.d829		20 e9 97	jsr $97e9	                jsr xt_one_plus
.d82c		a1 00		lda ($00,x)	                lda (0,x)
.d82e		48		pha		                pha
.d82f		20 dd 97	jsr $97dd	                jsr xt_one_minus
.d832		20 b6 95	jsr $95b6	                jsr xt_name_to_int      ; ( nt - xt )
.d835		a5 1a		lda $1a		                lda state
.d837		d0 10		bne $d849	                bne _compile
.d839		68		pla		                pla
.d83a		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d83c		f0 05		beq $d843	                beq _interpret
.d83e		a9 02		lda #$02	                lda #err_compileonly
.d840		4c 89 d8	jmp $d889	                jmp error
.d843						_interpret:
.d843		20 ef 8e	jsr $8eef	                jsr xt_execute
.d846		4c e0 d7	jmp $d7e0	                jmp _loop
.d849						_compile:
.d849		68		pla		                pla
.d84a		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d84c		d0 f5		bne $d843	                bne _interpret          ; IMMEDIATE word, execute right now
.d84e		20 70 87	jsr $8770	                jsr xt_compile_comma
.d851		4c e0 d7	jmp $d7e0	                jmp _loop
.d854						_line_done:
.d854		e8		inx		                inx
.d855		e8		inx		                inx
.d856		e8		inx		                inx
.d857		e8		inx		                inx
.d858		60		rts		                rts
.d859						is_printable:
.d859		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d85b		90 08		bcc $d865	                bcc _done
.d85d		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d85f		b0 03		bcs $d864	                bcs _failed
.d861		38		sec		                sec
.d862		80 01		bra $d865	                bra _done
.d864						_failed:
.d864		18		clc		                clc
.d865						_done:
.d865		60		rts		                rts
.d866						is_whitespace:
.d866		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d868		90 08		bcc $d872	                bcc _done
.d86a		c9 21		cmp #$21	                cmp #AscSP+1
.d86c		b0 03		bcs $d871	                bcs _failed
.d86e		38		sec		                sec
.d86f		80 01		bra $d872	                bra _done
.d871						_failed:
.d871		18		clc		                clc
.d872						_done:
.d872		60		rts		                rts
.d873						underflow_1:
.d873		e0 77		cpx #$77	                cpx #dsp0-1
.d875		10 10		bpl $d887	                bpl underflow_error
.d877		60		rts		                rts
.d878						underflow_2:
.d878		e0 75		cpx #$75	                cpx #dsp0-3
.d87a		10 0b		bpl $d887	                bpl underflow_error
.d87c		60		rts		                rts
.d87d						underflow_3:
.d87d		e0 73		cpx #$73	                cpx #dsp0-5
.d87f		10 06		bpl $d887	                bpl underflow_error
.d881		60		rts		                rts
.d882						underflow_4:
.d882		e0 71		cpx #$71	                cpx #dsp0-7
.d884		10 01		bpl $d887	                bpl underflow_error
.d886		60		rts		                rts
.d887						underflow_error:
.d887		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d889						error:
.d889		48		pha		                pha                     ; save error
.d88a		20 c9 d8	jsr $d8c9	                jsr print_error
.d88d		20 fb 88	jsr $88fb	                jsr xt_cr
.d890		68		pla		                pla
.d891		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d893		d0 17		bne $d8ac	                bne _no_underflow
.d895		a9 0d		lda #$0d	                lda #err_returnstack
.d897		20 c9 d8	jsr $d8c9	                jsr print_error
.d89a		ba		tsx		                tsx
.d89b						-
.d89b		e8		inx		                inx
.d89c		f0 0b		beq $d8a9	                beq +
.d89e		20 a9 a0	jsr $a0a9	                jsr xt_space
.d8a1		bd 00 01	lda $0100,x	                lda $100,x
.d8a4		20 88 d7	jsr $d788	                jsr byte_to_ascii
.d8a7		80 f2		bra $d89b	                bra -
.d8a9						+
.d8a9		20 fb 88	jsr $88fb	                jsr xt_cr
.d8ac						_no_underflow:
.d8ac		4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d8af						print_string_no_lf:
.d8af		0a		asl a		                asl
.d8b0		a8		tay		                tay
.d8b1		b9 f7 d3	lda $d3f7,y	                lda string_table,y
.d8b4		85 29		sta $29		                sta tmp3                ; LSB
.d8b6		c8		iny		                iny
.d8b7		b9 f7 d3	lda $d3f7,y	                lda string_table,y
.d8ba		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d8bc						print_common:
.d8bc		a0 00		ldy #$00	                ldy #0
.d8be						_loop:
.d8be		b1 29		lda ($29),y	                lda (tmp3),y
.d8c0		f0 06		beq $d8c8	                beq _done               ; strings are zero-terminated
.d8c2		20 a8 8d	jsr $8da8	                jsr emit_a              ; allows vectoring via output
.d8c5		c8		iny		                iny
.d8c6		80 f6		bra $d8be	                bra _loop
.d8c8						_done:
.d8c8		60		rts		                rts
.d8c9						print_error:
.d8c9		0a		asl a		                asl
.d8ca		a8		tay		                tay
.d8cb		b9 d4 d4	lda $d4d4,y	                lda error_table,y
.d8ce		85 29		sta $29		                sta tmp3                ; LSB
.d8d0		c8		iny		                iny
.d8d1		b9 d4 d4	lda $d4d4,y	                lda error_table,y
.d8d4		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d8d6		20 bc d8	jsr $d8bc	                jsr print_common
.d8d9		60		rts		                rts
.d8da						print_string:
.d8da		20 af d8	jsr $d8af	                jsr print_string_no_lf
.d8dd		4c fb 88	jmp $88fb	                jmp xt_cr               ; JSR/RTS because never compiled
.d8e0						print_u:
.d8e0		20 36 a7	jsr $a736	                jsr xt_zero                     ; 0
.d8e3		20 1e 93	jsr $931e	                jsr xt_less_number_sign         ; <#
.d8e6		20 aa 97	jsr $97aa	                jsr xt_number_sign_s            ; #S
.d8e9		20 88 97	jsr $9788	                jsr xt_number_sign_greater      ; #>
.d8ec		4c 7e a4	jmp $a47e	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010						v_nmi:
.f010						v_reset:
.f010						v_irq:
.f010						kernel_init:
.f010		78		sei		                sei             ; Disable interrupts
.f011		a2 00		ldx #$00	                ldx #0
.f013		bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016		f0 06		beq $f01e	                beq _done
.f018		20 27 f0	jsr $f027	                jsr kernel_putc
.f01b		e8		inx		                inx
.f01c		80 f5		bra $f013	                bra -
.f01e						_done:
.f01e		4c 00 80	jmp $8000	                jmp forth
.f021						kernel_getc:
.f021						_loop:
.f021		ad 04 f0	lda $f004	                lda $f004
.f024		f0 fb		beq $f021	                beq _loop
.f026		60		rts		                rts
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta $f001
.f02a		60		rts		                rts
.f02b						platform_bye:
.f02b		00		brk #		                brk
.f02c						s_kernel_id:
>f02c		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		10 f0				.word v_nmi
>fffc		10 f0				.word v_reset
>fffe		10 f0				.word v_irq

;******  End of listing
