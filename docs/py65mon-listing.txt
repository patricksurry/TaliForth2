
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Sat Mar 23 14:44:30 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; TaliForth2 system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=					TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]					TALI_OPTION_CR_EOL := [ "lf" ]
=1					TALI_OPTION_HISTORY := 1
=0					TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=126					turnkey   = zpage_end-1    ; word to resume in pre-compiled image
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd bd 80	lda $80bd,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad bd 80	lda $80bd	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 33		ldy #$33	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 df 80	lda $80df,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad df 80	lda $80df	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 7f 89	jsr $897f	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 c5		lda #$c5	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 bb		lda #$bb	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 82		lda #$82	                lda #<(user_words_end-forth_words_start)
.803f	95 00		sta $00,x	                sta 0,x
.8041	a9 01		lda #$01	                lda #>(user_words_end-forth_words_start)
.8043	95 01		sta $01,x	                sta 1,x
.8045	20 f1 90	jsr $90f1	                jsr xt_evaluate
.8048	80 0e		bra $8058	                bra _skip_turnkey
.804a					_turnkey:
.804a	78		sei		                sei
.804b	a2 76		ldx #$76	                ldx #dsp0-2
.804d	a5 7e		lda $7e		                lda turnkey
.804f	95 00		sta $00,x	                sta 0,x
.8051	a5 7f		lda $7f		                lda turnkey+1
.8053	95 01		sta $01,x	                sta 1,x
.8055	20 59 8f	jsr $8f59	                jsr xt_execute
.8058					_skip_turnkey:
.8058	9c 00 7c	stz $7c00	                stz hist_buff
.805b	9c 80 7c	stz $7c80	                stz hist_buff+$80
.805e	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8061	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8064	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8067	9c 80 7e	stz $7e80	                stz hist_buff+$280
.806a	9c 00 7f	stz $7f00	                stz hist_buff+$300
.806d	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8070					xt_abort:
.8070	a2 78		ldx #$78	                ldx #dsp0
.8072					xt_quit:
.8072	8a		txa		                txa             ; Save the DSP that we just defined
.8073	a2 ff		ldx #$ff	                ldx #rsp0
.8075	9a		txs		                txs
.8076	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8077	64 0e		stz $0e		                stz ip
.8079	64 0f		stz $0f		                stz ip+1
.807b	64 06		stz $06		                stz insrc
.807d	64 07		stz $07		                stz insrc+1
.807f	a9 00		lda #$00	                lda #0
.8081	a0 00		ldy #$00	                ldy #blk_offset
.8083	91 1e		sta ($1e),y	                sta (up),y
.8085	c8		iny		                iny
.8086	91 1e		sta ($1e),y	                sta (up),y
.8088	64 16		stz $16		                stz state
.808a	64 17		stz $17		                stz state+1
.808c					_get_line:
.808c	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.808e	85 08		sta $08		                sta cib
.8090	a9 02		lda #$02	                lda #>buffer0
.8092	85 09		sta $09		                sta cib+1
.8094	64 0a		stz $0a		                stz ciblen
.8096	64 0b		stz $0b		                stz ciblen+1
.8098	20 29 9b	jsr $9b29	                jsr xt_refill           ; ( -- f )
.809b	b5 00		lda $00,x	                lda 0,x
.809d	d0 05		bne $80a4	                bne _success
.809f	a9 06		lda #$06	                lda #err_refill
.80a1	4c 44 d9	jmp $d944	                jmp error
.80a4					_success:
.80a4	e8		inx		                inx                     ; drop
.80a5	e8		inx		                inx
.80a6	20 89 d8	jsr $d889	                jsr interpret
.80a9	e0 78		cpx #$78	                cpx #dsp0
.80ab	f0 05		beq $80b2	                beq _stack_ok
.80ad	90 03		bcc $80b2	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80af	4c 42 d9	jmp $d942	                jmp underflow_error
.80b2					_stack_ok:
.80b2	a5 16		lda $16		                lda state
.80b4	f0 02		beq $80b8	                beq _print
.80b6	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80b8					_print:
.80b8	20 95 d9	jsr $d995	                jsr print_string
.80bb	80 cf		bra $808c	                bra _get_line
.80bd					z_cold:
.80bd					z_abort:
.80bd					z_quit:
.80bd					cold_zp_table:
>80bd	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80bf	47 bd				        .word dictionary_start  ; dp
>80c1	00 00				        .word 0                 ; workword
>80c3	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80c5	00 02				        .word buffer0           ; cib
>80c7	00 00				        .word 0                 ; ciblen
>80c9	00 00				        .word 0                 ; toin
>80cb	00 00				        .word 0                 ; ip
>80cd	27 f0				        .word kernel_putc       ; output
>80cf	21 f0				        .word kernel_getc       ; input
>80d1	00 00				        .word 0                 ; havekey
>80d3	00 00				        .word 0                 ; state (0 = interpret)
>80d5	0a 00				        .word 10                ; base
>80d7	14 00				        .word 20                ; nc-limit
>80d9	00 00				        .word 0                 ; uf_strip (off by default)
>80db	00 03				        .word cp0               ; up (user vars put right at beginning of
>80dd	00 00				        .word 0                 ; status
.80df					cold_zp_table_end:
.80df					cold_user_table:
>80df	00 00				        .word 0                         ;  0 BLK
>80e1	00 00				        .word 0                         ;  2 SCR
>80e3	00				        .byte 0                         ;  4 CURRENT = FORTH-WORDLIST
>80e4	04				        .byte 4                         ;  5 #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80e5	47 bd				        .word dictionary_start          ;  6 FORTH-WORDLIST
>80e7	8f cb				        .word editor_dictionary_start   ;  8 EDITOR-WORDLIST
>80e9	df cb				        .word assembler_dictionary_start ; a ASSEMBLER-WORDLIST
>80eb	4e cb				        .word root_dictionary_start     ;  c ROOT-WORDLIST
>80ed	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ;  e User wordlists
>80f5	00 00 00 00 00 00 00 00
>80fd	01				        .byte 1                         ; 1e #ORDER
>80fe	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; 1f search-order
>8106	00
>8107	00 04				        .word cp0+256                   ; 28 Address of buffer (right after USER vars)
>8109	00 00				        .word 0                         ; 2a block in buffer
>810b	00 00				        .word 0                         ; 2c buffer status (not in use)
>810d	77 85				        .word xt_block_word_error       ; 2e block-read vector
>810f	77 85				        .word xt_block_word_error       ; 30 block-write vector
>8111	00 00				        .word 0                         ; 32 'COLD
.8113					cold_user_table_end:
.8113					xt_abort_quote:
.8113	20 80 9d	jsr $9d80	                jsr xt_s_quote          ; S"
.8116	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.8118	a9 1e		lda #$1e	                lda #<abort_quote_runtime
.811a	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.811d	60		rts		z_abort_quote:  rts
.811e					abort_quote_runtime:
.811e	b5 04		lda $04,x	                lda 4,x
.8120	15 05		ora $05,x	                ora 5,x
.8122	f0 09		beq $812d	                beq _done       ; if FALSE, we're done
.8124	20 05 a5	jsr $a505	                jsr xt_type
.8127	20 7f 89	jsr $897f	                jsr xt_cr
.812a	4c 70 80	jmp $8070	                jmp xt_abort    ; not JSR, so never come back
.812d					_done:
.812d	8a		txa		                txa
.812e	18		clc		                clc
.812f	69 06		adc #$06	                adc #6
.8131	aa		tax		                tax
.8132	60		rts		                rts
.8133					xt_abs:
.8133	20 2e d9	jsr $d92e	                jsr underflow_1
.8136	b5 01		lda $01,x	                lda 1,x
.8138	10 0d		bpl $8147	                bpl _done       ; positive number, easy money!
.813a	38		sec		                sec
.813b	a9 00		lda #$00	                lda #0
.813d	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.813f	95 00		sta $00,x	                sta 0,x
.8141	a9 00		lda #$00	                lda #0          ; MSB
.8143	f5 01		sbc $01,x	                sbc 1,x
.8145	95 01		sta $01,x	                sta 1,x
.8147					_done:
.8147	60		rts		z_abs:          rts
.8148					xt_accept:
.8148	20 33 d9	jsr $d933	                jsr underflow_2
.814b	b5 00		lda $00,x	                lda 0,x
.814d	15 01		ora $01,x	                ora 1,x
.814f	d0 09		bne $815a	                bne _not_zero
.8151	e8		inx		                inx
.8152	e8		inx		                inx
.8153	74 00		stz $00,x	                stz 0,x
.8155	74 01		stz $01,x	                stz 1,x
.8157	4c 26 82	jmp $8226	                jmp accept_done
.815a					_not_zero:
.815a	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.815c	85 26		sta $26		                sta tmp2
.815e	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.8160	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8162	85 24		sta $24		                sta tmp1
.8164	b5 03		lda $03,x	                lda 3,x
.8166	85 25		sta $25		                sta tmp1+1
.8168	e8		inx		                inx
.8169	e8		inx		                inx
.816a	a0 00		ldy #$00	                ldy #0
.816c	a5 20		lda $20		                lda status
.816e	29 f7		and #$f7	                and #$f7
.8170	1a		inc a		               ina
.8171	09 08		ora #$08	                ora #$08
.8173	85 20		sta $20		                sta status
.8175					accept_loop:
.8175	20 54 93	jsr $9354	                jsr key_a
.8178	c9 0a		cmp #$0a	                cmp #AscLF
.817a	f0 20		beq $819c	                beq _eol
.817c	c9 0d		cmp #$0d	                cmp #AscCR
.817e	f0 1c		beq $819c	                beq _eol
.8180	c9 08		cmp #$08	                cmp #AscBS
.8182	f0 22		beq $81a6	                beq _backspace
.8184	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8186	f0 1e		beq $81a6	                beq _backspace
.8188	c9 10		cmp #$10	                cmp #AscCP
.818a	f0 36		beq $81c2	                beq _ctrl_p
.818c	c9 0e		cmp #$0e	                cmp #AscCN
.818e	f0 44		beq $81d4	                beq _ctrl_n
.8190	91 24		sta ($24),y	                sta (tmp1),y
.8192	c8		iny		                iny
.8193	20 12 8e	jsr $8e12	                jsr emit_a
.8196	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.8198	d0 db		bne $8175	                bne accept_loop       ; fall through if buffer limit reached
.819a	80 03		bra $819f	                bra _buffer_full
.819c					_eol:
.819c	20 20 a1	jsr $a120	                jsr xt_space    ; print final space
.819f					_buffer_full:
.819f	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.81a1	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.81a3	4c 26 82	jmp $8226	                jmp accept_done
.81a6					_backspace:
.81a6	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.81a8	d0 06		bne $81b0	                bne +
.81aa	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.81ac	20 12 8e	jsr $8e12	                jsr emit_a
.81af	c8		iny		                iny
.81b0					+
.81b0	88		dey		                dey
.81b1	a9 08		lda #$08	                lda #AscBS      ; move back one
.81b3	20 12 8e	jsr $8e12	                jsr emit_a
.81b6	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.81b8	20 12 8e	jsr $8e12	                jsr emit_a
.81bb	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81bd	20 12 8e	jsr $8e12	                jsr emit_a
.81c0	80 b3		bra $8175	                bra accept_loop
.81c2					_ctrl_p:
.81c2	a5 20		lda $20		                lda status
.81c4	29 07		and #$07	                and #7
.81c6	d0 08		bne $81d0	                bne _ctrl_p_dec
.81c8	a5 20		lda $20		                lda status
.81ca	09 07		ora #$07	                ora #7
.81cc	85 20		sta $20		                sta status
.81ce	80 11		bra $81e1	                bra _recall_history
.81d0					_ctrl_p_dec:
.81d0	c6 20		dec $20		                dec status
.81d2	80 0d		bra $81e1	                bra _recall_history
.81d4					_ctrl_n:
.81d4	a9 08		lda #$08	                lda #$8
.81d6	24 20		bit $20		                bit status
.81d8	d0 07		bne $81e1	                bne _recall_history
.81da	a5 20		lda $20		                lda status
.81dc	29 f7		and #$f7	                and #$f7
.81de	1a		inc a		               ina
.81df	85 20		sta $20		                sta status
.81e1					_recall_history:
.81e1	a9 08		lda #$08	                lda #%00001000
.81e3	14 20		trb $20		                trb status
.81e5	20 41 82	jsr $8241	                jsr accept_total_recall
.81e8	a9 0d		lda #$0d	                lda #AscCR
.81ea	20 12 8e	jsr $8e12	                jsr emit_a
.81ed					input_clear:
.81ed	c0 00		cpy #$00	                cpy #0
.81ef	f0 08		beq $81f9	                beq input_cleared
.81f1	a9 20		lda #$20	                lda #AscSP
.81f3	20 12 8e	jsr $8e12	                jsr emit_a
.81f6	88		dey		                dey
.81f7	80 f4		bra $81ed	                bra input_clear
.81f9					input_cleared:
.81f9	a9 0d		lda #$0d	                lda #AscCR
.81fb	20 12 8e	jsr $8e12	                jsr emit_a
.81fe	b1 28		lda ($28),y	                lda (tmp3),y
.8200	85 21		sta $21		                sta status+1
.8202	e6 28		inc $28		                inc tmp3
.8204	d0 02		bne $8208	                bne +           ; Increment the upper byte on carry.
.8206	e6 29		inc $29		                inc tmp3+1
.8208					+
.8208	a9 0d		lda #$0d	                lda #AscCR
.820a	20 12 8e	jsr $8e12	                jsr emit_a
.820d					_history_loop:
.820d	c4 21		cpy $21		                cpy status+1
.820f	d0 03		bne $8214	                bne +
.8211	4c 75 81	jmp $8175	                jmp accept_loop       ; Needs a long jump
.8214					+
.8214	c4 26		cpy $26		                cpy tmp2
.8216	f0 0a		beq $8222	                beq _hist_filled_buffer
.8218	b1 28		lda ($28),y	                lda (tmp3),y
.821a	91 24		sta ($24),y	                sta (tmp1),y
.821c	20 12 8e	jsr $8e12	                jsr emit_a
.821f	c8		iny		                iny
.8220	80 eb		bra $820d	                bra _history_loop
.8222					_hist_filled_buffer:
.8222	88		dey		                dey
.8223	4c 75 81	jmp $8175	                jmp accept_loop
.8226					accept_done:
.8226	20 41 82	jsr $8241	                jsr accept_total_recall
.8229	85 21		sta $21		                sta status+1
.822b	a0 00		ldy #$00	                ldy #0
.822d	91 28		sta ($28),y	                sta (tmp3),y
.822f	e6 28		inc $28		                inc tmp3
.8231	d0 02		bne $8235	                bne +           ; Increment the upper byte on carry.
.8233	e6 29		inc $29		                inc tmp3+1
.8235					+
.8235					_save_history_loop:
.8235	c4 21		cpy $21		                cpy status+1
.8237	f0 07		beq $8240	                beq _save_history_done
.8239	b1 24		lda ($24),y	                lda (tmp1),y
.823b	91 28		sta ($28),y	                sta (tmp3),y
.823d	c8		iny		                iny
.823e	80 f5		bra $8235	                bra _save_history_loop
.8240					_save_history_done:
.8240					z_accept:
.8240	60		rts		                rts
.8241					accept_total_recall:
.8241	a9 00		lda #$00	                lda #<hist_buff
.8243	85 28		sta $28		                sta tmp3
.8245	a9 7c		lda #$7c	                lda #>hist_buff
.8247	85 29		sta $29		                sta tmp3+1
.8249	a5 20		lda $20		                lda status
.824b	6a		ror a		                ror
.824c	29 03		and #$03	                and #3
.824e	18		clc		                clc
.824f	65 29		adc $29		                adc tmp3+1
.8251	85 29		sta $29		                sta tmp3+1
.8253	a5 20		lda $20		                lda status
.8255	6a		ror a		                ror             ; Rotate through carry into msb.
.8256	6a		ror a		                ror
.8257	29 80		and #$80	                and #$80
.8259	18		clc		                clc
.825a	65 28		adc $28		                adc tmp3
.825c	85 28		sta $28		                sta tmp3
.825e	90 02		bcc $8262	                bcc +           ; Increment the upper byte on carry.
.8260	e6 29		inc $29		                inc tmp3+1
.8262					+
.8262	98		tya		                tya
.8263	c9 80		cmp #$80	                cmp #$80
.8265	90 02		bcc $8269	                bcc +
.8267	a9 7f		lda #$7f	                lda #$7F
.8269					+
.8269	60		rts		                rts
.826a					xt_action_of:
.826a	a5 16		lda $16		                lda state
.826c	05 17		ora $17		                ora state+1
.826e	f0 0c		beq $827c	                beq _interpreting
.8270					_compiling:
.8270	20 ba 85	jsr $85ba	                jsr xt_bracket_tick
.8273	a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.8275	a9 fb		lda #$fb	                lda #<xt_defer_fetch
.8277	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.827a	80 06		bra $8282	                bra _done
.827c					_interpreting:
.827c	20 13 a2	jsr $a213	                jsr xt_tick
.827f	20 fb 8a	jsr $8afb	                jsr xt_defer_fetch
.8282					_done:
.8282	60		rts		z_action_of:           rts
.8283					xt_again:
.8283	20 2e d9	jsr $d92e	                jsr underflow_1
.8286	a0 00		ldy #$00	                ldy #0
.8288	a9 4c		lda #$4c	                lda #$4C        ; JMP
.828a	91 00		sta ($00),y	                sta (cp),y
.828c	c8		iny		                iny
.828d	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.828f	91 00		sta ($00),y	                sta (cp),y
.8291	c8		iny		                iny
.8292	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.8294	91 00		sta ($00),y	                sta (cp),y
.8296	c8		iny		                iny
.8297	98		tya		                tya
.8298	18		clc		                clc
.8299	65 00		adc $00		                adc cp
.829b	85 00		sta $00		                sta cp
.829d	90 02		bcc $82a1	                bcc _done
.829f	e6 01		inc $01		                inc cp+1
.82a1					_done:
.82a1	e8		inx		                inx
.82a2	e8		inx		                inx
.82a3	60		rts		z_again:        rts
.82a4					xt_align:
.82a4					xt_aligned:
.82a4					z_align:
.82a4	60		rts		z_aligned:      rts             ; stripped out during native compile
.82a5					xt_allot:
.82a5	20 2e d9	jsr $d92e	                jsr underflow_1
.82a8	b5 01		lda $01,x	                lda 1,x
.82aa	30 22		bmi $82ce	                bmi _release
.82ac	18		clc		                clc
.82ad	a5 00		lda $00		                lda cp
.82af	75 00		adc $00,x	                adc 0,x
.82b1	85 00		sta $00		                sta cp
.82b3	a5 01		lda $01		                lda cp+1
.82b5	75 01		adc $01,x	                adc 1,x
.82b7	85 01		sta $01		                sta cp+1
.82b9	a0 00		ldy #$00	                ldy #<cp_end
.82bb	c4 00		cpy $00		                cpy cp
.82bd	a9 7c		lda #$7c	                lda #>cp_end
.82bf	e5 01		sbc $01		                sbc cp+1
.82c1	b0 48		bcs $830b	                bcs _done               ; we're fine.
.82c3	84 00		sty $00		                sty cp                  ; still #<cp_end
.82c5	a9 7c		lda #$7c	                lda #>cp_end
.82c7	85 01		sta $01		                sta cp+1
.82c9	a9 00		lda #$00	                lda #err_allot
.82cb	4c 44 d9	jmp $d944	                jmp error
.82ce					_release:
.82ce	ca		dex		                dex
.82cf	ca		dex		                dex
.82d0	a5 00		lda $00		                lda cp
.82d2	95 00		sta $00,x	                sta 0,x
.82d4	a5 01		lda $01		                lda cp+1
.82d6	95 01		sta $01,x	                sta 1,x
.82d8	20 14 9a	jsr $9a14	                jsr xt_plus                     ; new CP is now TOS
.82db	ca		dex		                dex
.82dc	ca		dex		                dex                             ; new CP now NOS
.82dd	a9 00		lda #$00	                lda #<cp0
.82df	95 00		sta $00,x	                sta 0,x
.82e1	a9 03		lda #$03	                lda #>cp0
.82e3	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82e5	20 48 d8	jsr $d848	                jsr compare_16bit               ; still ( CP CP0 )
.82e8	f0 17		beq $8301	                beq _nega_done
.82ea	30 15		bmi $8301	                bmi _nega_done
.82ec	a9 00		lda #$00	                lda #<cp0
.82ee	85 00		sta $00		                sta cp
.82f0	a9 03		lda #$03	                lda #>cp0
.82f2	85 01		sta $01		                sta cp+1
.82f4	a9 47		lda #$47	                lda #<dictionary_start
.82f6	85 02		sta $02		                sta dp
.82f8	a9 bd		lda #$bd	                lda #>dictionary_start
.82fa	85 03		sta $03		                sta dp+1
.82fc	a9 0a		lda #$0a	                lda #err_negallot
.82fe	4c 44 d9	jmp $d944	                jmp error
.8301					_nega_done:
.8301	b5 02		lda $02,x	                lda 2,x
.8303	85 00		sta $00		                sta cp
.8305	b5 03		lda $03,x	                lda 3,x
.8307	85 01		sta $01		                sta cp+1
.8309	e8		inx		                inx
.830a	e8		inx		                inx                     ; drop through to _done
.830b					_done:
.830b	e8		inx		                inx
.830c	e8		inx		                inx
.830d					z_allot:
.830d	60		rts		                rts
.830e					xt_allow_native:
.830e	20 63 d8	jsr $d863	                jsr current_to_dp
.8311	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8313	b1 02		lda ($02),y	                lda (dp),y
.8315	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.8317	91 02		sta ($02),y	                sta (dp),y
.8319					z_allow_native:
.8319	60		rts		                rts
.831a					xt_also:
.831a	20 50 91	jsr $9150	                jsr xt_get_order
.831d	20 c4 98	jsr $98c4	                jsr xt_over
.8320	20 b0 a1	jsr $a1b0	                jsr xt_swap
.8323	20 4e 98	jsr $984e	                jsr xt_one_plus
.8326	20 4c 9d	jsr $9d4c	                jsr xt_set_order
.8329	60		rts		z_also:         rts
.832a					xt_always_native:
.832a	20 63 d8	jsr $d863	                jsr current_to_dp
.832d	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.832f	b1 02		lda ($02),y	                lda (dp),y
.8331	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.8333	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.8335	91 02		sta ($02),y	                sta (dp),y
.8337					z_always_native:
.8337	60		rts		                rts
.8338					xt_and:
.8338	20 33 d9	jsr $d933	                jsr underflow_2
.833b	b5 00		lda $00,x	                lda 0,x
.833d	35 02		and $02,x	                and 2,x
.833f	95 02		sta $02,x	                sta 2,x
.8341	b5 01		lda $01,x	                lda 1,x
.8343	35 03		and $03,x	                and 3,x
.8345	95 03		sta $03,x	                sta 3,x
.8347	e8		inx		                inx
.8348	e8		inx		                inx
.8349	60		rts		z_and:          rts
.834a					xt_at_xy:
.834a	20 33 d9	jsr $d933	                jsr underflow_2
.834d	a5 18		lda $18		                lda base
.834f	48		pha		                pha
.8350	a9 0a		lda #$0a	                lda #10
.8352	85 18		sta $18		                sta base
.8354	a9 1b		lda #$1b	                lda #AscESC
.8356	20 12 8e	jsr $8e12	                jsr emit_a
.8359	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.835b	20 12 8e	jsr $8e12	                jsr emit_a
.835e	20 4e 98	jsr $984e	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8361	20 9b d9	jsr $d99b	                jsr print_u
.8364	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8366	20 12 8e	jsr $8e12	                jsr emit_a
.8369	20 4e 98	jsr $984e	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.836c	20 9b d9	jsr $d99b	                jsr print_u
.836f	a9 48		lda #$48	                lda #'H'
.8371	20 12 8e	jsr $8e12	                jsr emit_a
.8374	68		pla		                pla
.8375	85 18		sta $18		                sta base
.8377	60		rts		z_at_xy:        rts
.8378					xt_backslash:
.8378	a0 00		ldy #$00	                ldy #blk_offset
.837a	b1 1e		lda ($1e),y	                lda (up),y
.837c	c8		iny		                iny
.837d	11 1e		ora ($1e),y	                ora (up),y
.837f	f0 19		beq $839a	                beq backslash_not_block
.8381	a5 0c		lda $0c		                lda toin
.8383	29 3f		and #$3f	                and #$3F
.8385	f0 1b		beq $83a2	                beq z_backslash
.8387	c9 01		cmp #$01	                cmp #$01
.8389	f0 17		beq $83a2	                beq z_backslash
.838b	a5 0c		lda $0c		                lda toin
.838d	29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.838f	18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.8390	69 40		adc #$40	                adc #$40
.8392	85 0c		sta $0c		                sta toin
.8394	90 0c		bcc $83a2	                bcc z_backslash
.8396	e6 0d		inc $0d		                inc toin+1
.8398	80 08		bra $83a2	                bra z_backslash
.839a					backslash_not_block:
.839a	a5 0a		lda $0a		                lda ciblen
.839c	85 0c		sta $0c		                sta toin
.839e	a5 0b		lda $0b		                lda ciblen+1
.83a0	85 0d		sta $0d		                sta toin+1
.83a2	60		rts		z_backslash:    rts
.83a3					xt_base:
.83a3	ca		dex		                dex
.83a4	ca		dex		                dex
.83a5	a9 18		lda #$18	                lda #<base
.83a7	95 00		sta $00,x	                sta 0,x         ; LSB
.83a9	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.83ab	60		rts		z_base:         rts
.83ac					xt_begin:
.83ac	20 8e 91	jsr $918e	                jsr xt_here
.83af	60		rts		z_begin:        rts
.83b0					xt_bell:
.83b0	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.83b2	20 12 8e	jsr $8e12	                jsr emit_a
.83b5	60		rts		z_bell:         rts
.83b6					xt_bl:
.83b6	ca		dex		                dex
.83b7	ca		dex		                dex
.83b8	a9 20		lda #$20	                lda #AscSP
.83ba	95 00		sta $00,x	                sta 0,x
.83bc	74 01		stz $01,x	                stz 1,x
.83be	60		rts		z_bl:           rts
.83bf					xt_blk:
.83bf	ca		dex		                dex
.83c0	ca		dex		                dex
.83c1	18		clc		                clc
.83c2	a5 1e		lda $1e		                lda up
.83c4	69 00		adc #$00	                adc #blk_offset ; Add offset
.83c6	95 00		sta $00,x	                sta 0,x
.83c8	a5 1f		lda $1f		                lda up+1
.83ca	69 00		adc #$00	                adc #0          ; Adding carry
.83cc	95 01		sta $01,x	                sta 1,x
.83ce	60		rts		z_blk:          rts
.83cf					xt_blkbuffer:
.83cf	ca		dex		                dex
.83d0	ca		dex		                dex
.83d1	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83d3	b1 1e		lda ($1e),y	                lda (up),y
.83d5	95 00		sta $00,x	                sta 0,x
.83d7	c8		iny		                iny             ; Move along to the next byte
.83d8	b1 1e		lda ($1e),y	                lda (up),y
.83da	95 01		sta $01,x	                sta 1,x
.83dc	60		rts		z_blkbuffer:    rts
.83dd					xt_block:
.83dd	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83df	b1 1e		lda ($1e),y	                lda (up),y
.83e1	d5 00		cmp $00,x	                cmp 0,x
.83e3	d0 0f		bne $83f4	                bne _not_in_buffer
.83e5	c8		iny		                iny
.83e6	b1 1e		lda ($1e),y	                lda (up),y
.83e8	d5 01		cmp $01,x	                cmp 1,x
.83ea	d0 08		bne $83f4	                bne _not_in_buffer
.83ec	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83ee	b1 1e		lda ($1e),y	                lda (up),y
.83f0	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.83f2	d0 30		bne $8424	                bne _done       ; It's already in the buffer and in use.
.83f4					_not_in_buffer:
.83f4	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83f6	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83f8	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83fa	d0 0c		bne $8408	                bne _buffer_available ; Unused or not dirty = available
.83fc	20 cf 83	jsr $83cf	                jsr xt_blkbuffer
.83ff	20 c1 85	jsr $85c1	                jsr xt_buffblocknum
.8402	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.8405	20 7c 85	jsr $857c	                jsr xt_block_write
.8408					_buffer_available:
.8408	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.840a	b5 00		lda $00,x	                lda 0,x
.840c	91 1e		sta ($1e),y	                sta (up),y
.840e	c8		iny		                iny
.840f	b5 01		lda $01,x	                lda 1,x
.8411	91 1e		sta ($1e),y	                sta (up),y
.8413	20 cf 83	jsr $83cf	                jsr xt_blkbuffer
.8416	20 b0 a1	jsr $a1b0	                jsr xt_swap
.8419	20 59 85	jsr $8559	                jsr xt_block_read
.841c	a9 01		lda #$01	                lda #1
.841e	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8420	91 1e		sta ($1e),y	                sta (up),y
.8422	ca		dex		                dex
.8423	ca		dex		                dex
.8424					_done:
.8424	a0 28		ldy #$28	                ldy #blkbuffer_offset
.8426	b1 1e		lda ($1e),y	                lda (up),y
.8428	95 00		sta $00,x	                sta 0,x
.842a	c8		iny		                iny
.842b	b1 1e		lda ($1e),y	                lda (up),y
.842d	95 01		sta $01,x	                sta 1,x
.842f	60		rts		z_block:        rts
.8430					xt_block_ramdrive_init:
.8430	20 2e d9	jsr $d92e	                jsr underflow_1
.8433	4c 4e 85	jmp $854e	                jmp _after_ramdrive_code
.8436					_ramdrive_code:
>8436	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>843e	77 61 70 20 64 65 63 69 6d 61 6c
>8449	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>8450	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8454	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>845c	20 72 61 6d 64 72 69 76 65
>8465	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>846d	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>847b	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8483	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8493	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>84a3	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>84ab	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>84ba	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>84c2	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84d2	31 30 32 34 20 6d 6f 76 65 20 3b
>84dd	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84e5	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>84f5	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>8505	20 21
>8507	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>850f	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>851f	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>852f	6f 72 20 21
>8533	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>853b	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>854b	65 20 21
.854e					_after_ramdrive_code:
.854e	20 ab a0	jsr $a0ab	                jsr sliteral_runtime
>8551	36 84 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.8555	20 f1 90	jsr $90f1	                jsr xt_evaluate
.8558					z_block_ramdrive_init:
.8558	60		rts		                rts
.8559					xt_block_read:
.8559	a0 2e		ldy #$2e	                ldy #blockread_offset
.855b	b1 1e		lda ($1e),y	                lda (up),y
.855d	85 24		sta $24		                sta tmp1
.855f	c8		iny		                iny
.8560	b1 1e		lda ($1e),y	                lda (up),y
.8562	85 25		sta $25		                sta tmp1+1
.8564	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8567					z_block_read:
.8567					xt_block_read_vector:
.8567	ca		dex		                dex
.8568	ca		dex		                dex
.8569	18		clc		                clc
.856a	a5 1e		lda $1e		                lda up
.856c	69 2e		adc #$2e	                adc #blockread_offset
.856e	95 00		sta $00,x	                sta 0,x
.8570	a5 1f		lda $1f		                lda up+1
.8572	69 00		adc #$00	                adc #0          ; Add carry
.8574	95 01		sta $01,x	                sta 1,x
.8576					z_block_read_vector:
.8576	60		rts		                rts
.8577					xt_block_word_error:
.8577	a9 0c		lda #$0c	                lda #err_blockwords
.8579	4c 44 d9	jmp $d944	                jmp error       ; no RTS needed
.857c					z_block_word_error:
.857c					xt_block_write:
.857c	a0 30		ldy #$30	                ldy #blockwrite_offset
.857e	b1 1e		lda ($1e),y	                lda (up),y
.8580	85 24		sta $24		                sta tmp1
.8582	c8		iny		                iny
.8583	b1 1e		lda ($1e),y	                lda (up),y
.8585	85 25		sta $25		                sta tmp1+1
.8587	6c 24 00	jmp ($0024)	                jmp (tmp1)
.858a					z_block_write:
.858a					xt_block_write_vector:
.858a	ca		dex		                dex
.858b	ca		dex		                dex
.858c	18		clc		                clc
.858d	a5 1e		lda $1e		                lda up
.858f	69 30		adc #$30	                adc #blockwrite_offset
.8591	95 00		sta $00,x	                sta 0,x
.8593	a5 1f		lda $1f		                lda up+1
.8595	69 00		adc #$00	                adc #0          ; Add carry
.8597	95 01		sta $01,x	                sta 1,x
.8599					z_block_write_vector:
.8599	60		rts		                rts
.859a					xt_bounds:
.859a	20 33 d9	jsr $d933	                jsr underflow_2
.859d	18		clc		                clc
.859e	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.85a0	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.85a2	75 02		adc $02,x	                adc 2,x
.85a4	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.85a6	94 00		sty $00,x	                sty 0,x
.85a8	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.85aa	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.85ac	75 03		adc $03,x	                adc 3,x
.85ae	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.85b0	94 01		sty $01,x	                sty 1,x
.85b2	60		rts		z_bounds:       rts
.85b3					xt_bracket_char:
.85b3	20 4d 86	jsr $864d	                jsr xt_char
.85b6	20 a6 93	jsr $93a6	                jsr xt_literal
.85b9	60		rts		z_bracket_char: rts
.85ba					xt_bracket_tick:
.85ba	20 13 a2	jsr $a213	                jsr xt_tick
.85bd	20 a6 93	jsr $93a6	                jsr xt_literal
.85c0	60		rts		z_bracket_tick: rts
.85c1					xt_buffblocknum:
.85c1	ca		dex		                dex
.85c2	ca		dex		                dex
.85c3	18		clc		                clc
.85c4	a5 1e		lda $1e		                lda up
.85c6	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.85c8	95 00		sta $00,x	                sta 0,x
.85ca	a5 1f		lda $1f		                lda up+1
.85cc	69 00		adc #$00	                adc #0                          ; Adding carry
.85ce	95 01		sta $01,x	                sta 1,x
.85d0	60		rts		z_buffblocknum: rts
.85d1					xt_buffer:
.85d1	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85d3	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.85d5	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.85d7	d0 0c		bne $85e5	                bne _buffer_available ; Unused or not dirty = available
.85d9	20 cf 83	jsr $83cf	                jsr xt_blkbuffer
.85dc	20 c1 85	jsr $85c1	                jsr xt_buffblocknum
.85df	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.85e2	20 7c 85	jsr $857c	                jsr xt_block_write
.85e5					_buffer_available:
.85e5	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85e7	b5 00		lda $00,x	                lda 0,x
.85e9	91 1e		sta ($1e),y	                sta (up),y
.85eb	c8		iny		                iny
.85ec	b5 01		lda $01,x	                lda 1,x
.85ee	91 1e		sta ($1e),y	                sta (up),y
.85f0	a9 01		lda #$01	                lda #1
.85f2	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85f4	91 1e		sta ($1e),y	                sta (up),y
.85f6					_done:
.85f6	a0 28		ldy #$28	                ldy #blkbuffer_offset
.85f8	b1 1e		lda ($1e),y	                lda (up),y
.85fa	95 00		sta $00,x	                sta 0,x
.85fc	c8		iny		                iny
.85fd	b1 1e		lda ($1e),y	                lda (up),y
.85ff	95 01		sta $01,x	                sta 1,x
.8601	60		rts		z_buffer:       rts
.8602					xt_buffer_colon:
.8602	20 85 89	jsr $8985	                jsr xt_create
.8605	20 a5 82	jsr $82a5	                jsr xt_allot
.8608	60		rts		z_buffer_colon: rts
.8609					xt_buffstatus:
.8609	ca		dex		                dex
.860a	ca		dex		                dex
.860b	18		clc		                clc
.860c	a5 1e		lda $1e		                lda up
.860e	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.8610	95 00		sta $00,x	                sta 0,x
.8612	a5 1f		lda $1f		                lda up+1
.8614	69 00		adc #$00	                adc #0                  ; Adding carry
.8616	95 01		sta $01,x	                sta 1,x
.8618	60		rts		z_buffstatus:   rts
.8619					xt_bye:
.8619	4c 2b f0	jmp $f02b	                jmp platform_bye
.861c					z_bye:
.861c					xt_c_comma:
.861c	20 2e d9	jsr $d92e	                jsr underflow_1
.861f	b5 00		lda $00,x	                lda 0,x
.8621	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.8624	e8		inx		                inx
.8625	e8		inx		                inx
.8626	60		rts		z_c_comma:      rts
.8627					xt_c_fetch:
.8627	20 2e d9	jsr $d92e	                jsr underflow_1
.862a	a1 00		lda ($00,x)	                lda (0,x)
.862c	95 00		sta $00,x	                sta 0,x
.862e	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8630	60		rts		z_c_fetch:      rts
.8631					xt_c_store:
.8631	20 33 d9	jsr $d933	                jsr underflow_2
.8634	b5 02		lda $02,x	                lda 2,x
.8636	81 00		sta ($00,x)	                sta (0,x)
.8638	e8		inx		                inx
.8639	e8		inx		                inx
.863a	e8		inx		                inx
.863b	e8		inx		                inx
.863c	60		rts		z_c_store:      rts
.863d					xt_cell_plus:
.863d	20 2e d9	jsr $d92e	                jsr underflow_1
.8640	f6 00		inc $00,x	                inc 0,x
.8642	d0 02		bne $8646	                bne +
.8644	f6 01		inc $01,x	                inc 1,x
.8646					+
.8646	f6 00		inc $00,x	                inc 0,x
.8648	d0 02		bne $864c	                bne _done
.864a	f6 01		inc $01,x	                inc 1,x
.864c					_done:
.864c	60		rts		z_cell_plus:    rts
.864d					xt_char:
.864d	20 10 99	jsr $9910	                jsr xt_parse_name
.8650	b5 00		lda $00,x	                lda 0,x
.8652	15 01		ora $01,x	                ora 1,x
.8654	d0 05		bne $865b	                bne _not_empty
.8656	a9 05		lda #$05	                lda #err_noname
.8658	4c 44 d9	jmp $d944	                jmp error
.865b					_not_empty:
.865b	e8		inx		                inx             ; drop number of characters, leave addr
.865c	e8		inx		                inx
.865d	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.865f	95 00		sta $00,x	                sta 0,x
.8661	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8663	60		rts		z_char:         rts
.8664					xt_chars:
.8664	20 2e d9	jsr $d92e	                jsr underflow_1
.8667	60		rts		z_chars:        rts
.8668					xt_cleave:
.8668	20 33 d9	jsr $d933	                jsr underflow_2
.866b	20 94 95	jsr $9594	                jsr xt_minus_leading    ; -LEADING ( addr u )
.866e	20 7e 92	jsr $927e	                jsr xt_input_to_r       ; save old imput state
.8671	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8673	85 0a		sta $0a		                sta ciblen
.8675	b5 01		lda $01,x	                lda 1,x
.8677	85 0b		sta $0b		                sta ciblen+1
.8679	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.867b	85 08		sta $08		                sta cib
.867d	b5 03		lda $03,x	                lda 3,x
.867f	85 09		sta $09		                sta cib+1
.8681	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8683	64 0d		stz $0d		                stz toin+1
.8685	20 10 99	jsr $9910	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8688	b5 00		lda $00,x	                lda 0,x
.868a	15 01		ora $01,x	                ora 1,x
.868c	f0 23		beq $86b1	                beq _done
.868e	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.8690	38		sec		                sec
.8691	f5 00		sbc $00,x	                sbc 0,x
.8693	95 04		sta $04,x	                sta 4,x
.8695	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.8697	f5 01		sbc $01,x	                sbc 1,x
.8699	95 05		sta $05,x	                sta 5,x
.869b	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.869d	18		clc		                clc
.869e	75 00		adc $00,x	                adc 0,x
.86a0	95 06		sta $06,x	                sta 6,x
.86a2	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.86a4	75 01		adc $01,x	                adc 1,x
.86a6	95 07		sta $07,x	                sta 7,x
.86a8	20 80 a4	jsr $a480	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.86ab	20 94 95	jsr $9594	                jsr xt_minus_leading
.86ae	20 80 a4	jsr $a480	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.86b1					_done:
.86b1	20 d4 9a	jsr $9ad4	                jsr xt_r_to_input
.86b4	60		rts		z_cleave:       rts
.86b5					xt_cmove:
.86b5	20 38 d9	jsr $d938	                jsr underflow_3
.86b8	b5 02		lda $02,x	                lda 2,x
.86ba	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86bc	b5 03		lda $03,x	                lda 3,x
.86be	85 27		sta $27		                sta tmp2+1
.86c0	b5 04		lda $04,x	                lda 4,x
.86c2	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86c4	b5 05		lda $05,x	                lda 5,x
.86c6	85 25		sta $25		                sta tmp1+1
.86c8	a0 00		ldy #$00	                ldy #0
.86ca	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.86cc	f0 0f		beq $86dd	                beq _dopartial
.86ce					_page:
.86ce	b1 24		lda ($24),y	                lda (tmp1),y
.86d0	91 26		sta ($26),y	                sta (tmp2),y
.86d2	c8		iny		                iny
.86d3	d0 f9		bne $86ce	                bne _page
.86d5	e6 25		inc $25		                inc tmp1+1
.86d7	e6 27		inc $27		                inc tmp2+1
.86d9	d6 01		dec $01,x	                dec 1,x
.86db	d0 f1		bne $86ce	                bne _page
.86dd					_dopartial:
.86dd	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86df	f0 09		beq $86ea	                beq _done
.86e1					_partial:
.86e1	b1 24		lda ($24),y	                lda (tmp1),y
.86e3	91 26		sta ($26),y	                sta (tmp2),y
.86e5	c8		iny		                iny
.86e6	d6 00		dec $00,x	                dec 0,x
.86e8	d0 f7		bne $86e1	                bne _partial
.86ea					_done:
.86ea	8a		txa		                txa
.86eb	18		clc		                clc
.86ec	69 06		adc #$06	                adc #6
.86ee	aa		tax		                tax
.86ef	60		rts		z_cmove:        rts
.86f0					xt_cmove_up:
.86f0	20 38 d9	jsr $d938	                jsr underflow_3
.86f3	b5 02		lda $02,x	                lda 2,x
.86f5	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86f7	b5 03		lda $03,x	                lda 3,x
.86f9	18		clc		                clc
.86fa	75 01		adc $01,x	                adc 1,x
.86fc	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86fe	b5 04		lda $04,x	                lda 4,x
.8700	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.8702	b5 05		lda $05,x	                lda 5,x
.8704	18		clc		                clc
.8705	75 01		adc $01,x	                adc 1,x
.8707	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.8709	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.870b	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.870d	f0 0e		beq $871d	                beq _nopartial
.870f					_outerloop:
.870f	88		dey		                dey
.8710	f0 07		beq $8719	                beq _finishpage
.8712					_innerloop:
.8712	b1 24		lda ($24),y	                lda (tmp1),y
.8714	91 26		sta ($26),y	                sta (tmp2),y
.8716	88		dey		                dey
.8717	d0 f9		bne $8712	                bne _innerloop
.8719					_finishpage:
.8719	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.871b	92 26		sta ($26)	                sta (tmp2)
.871d					_nopartial:
.871d	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.871f	c6 27		dec $27		                dec tmp2+1
.8721	d6 01		dec $01,x	                dec 1,x
.8723	d0 ea		bne $870f	                bne _outerloop
.8725					_done:
.8725	8a		txa		                txa
.8726	18		clc		                clc
.8727	69 06		adc #$06	                adc #6
.8729	aa		tax		                tax
.872a	60		rts		z_cmove_up:     rts
.872b					xt_colon:
.872b	a5 16		lda $16		                lda state
.872d	05 17		ora $17		                ora state+1
.872f	f0 05		beq $8736	                beq +
.8731	a9 07		lda #$07	                lda #err_state
.8733	4c 44 d9	jmp $d944	                jmp error
.8736					+
.8736	c6 16		dec $16		                dec state
.8738	c6 17		dec $17		                dec state+1
.873a	a9 40		lda #$40	                lda #%01000000
.873c	04 20		tsb $20		                tsb status
.873e	20 63 d8	jsr $d863	                jsr current_to_dp
.8741	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8743	48		pha		                pha
.8744	a5 02		lda $02		                lda dp
.8746	48		pha		                pha
.8747	a9 80		lda #$80	                lda #%10000000
.8749	04 20		tsb $20		                tsb status
.874b	20 85 89	jsr $8985	                jsr xt_create
.874e	20 63 d8	jsr $d863	                jsr current_to_dp   ; This might be able to be omitted
.8751	a5 02		lda $02		                lda dp
.8753	85 04		sta $04		                sta workword
.8755	a5 03		lda $03		                lda dp+1
.8757	85 05		sta $05		                sta workword+1
.8759	68		pla		                pla
.875a	85 02		sta $02		                sta dp
.875c	68		pla		                pla
.875d	85 03		sta $03		                sta dp+1
.875f	20 76 d8	jsr $d876	                jsr dp_to_current
.8762	a5 00		lda $00		                lda cp
.8764	38		sec		                sec
.8765	e9 03		sbc #$03	                sbc #3
.8767	85 00		sta $00		                sta cp
.8769	b0 02		bcs $876d	                bcs _done
.876b	c6 01		dec $01		                dec cp+1
.876d					_done:
.876d	60		rts		z_colon:        rts
.876e					xt_colon_noname:
.876e	a5 16		lda $16		                lda state
.8770	05 17		ora $17		                ora state+1
.8772	f0 05		beq $8779	                beq +
.8774	a9 07		lda #$07	                lda #err_state
.8776	4c 44 d9	jmp $d944	                jmp error
.8779					+
.8779	c6 16		dec $16		                dec state
.877b	c6 17		dec $17		                dec state+1
.877d	a9 40		lda #$40	                lda #%01000000
.877f	14 20		trb $20		                trb status
.8781	a5 00		lda $00		                lda cp
.8783	85 04		sta $04		                sta workword
.8785	a5 01		lda $01		                lda cp+1
.8787	85 05		sta $05		                sta workword+1
.8789					_done:
.8789	60		rts		z_colon_noname:        rts
.878a					xt_comma:
.878a	20 2e d9	jsr $d92e	                jsr underflow_1
.878d	b5 00		lda $00,x	                lda 0,x
.878f	92 00		sta ($00)	                sta (cp)
.8791	e6 00		inc $00		                inc cp
.8793	d0 02		bne $8797	                bne +
.8795	e6 01		inc $01		                inc cp+1
.8797					+
.8797	b5 01		lda $01,x	                lda 1,x
.8799	92 00		sta ($00)	                sta (cp)
.879b	e6 00		inc $00		                inc cp
.879d	d0 02		bne $87a1	                bne _done
.879f	e6 01		inc $01		                inc cp+1
.87a1					_done:
.87a1	e8		inx		                inx
.87a2	e8		inx		                inx
.87a3	60		rts		z_comma:        rts
.87a4					xt_compare:
.87a4	20 3d d9	jsr $d93d	                jsr underflow_4
.87a7	b5 02		lda $02,x	                lda 2,x
.87a9	85 26		sta $26		                sta tmp2
.87ab	b5 03		lda $03,x	                lda 3,x
.87ad	85 27		sta $27		                sta tmp2+1
.87af	b5 06		lda $06,x	                lda 6,x
.87b1	85 24		sta $24		                sta tmp1
.87b3	b5 07		lda $07,x	                lda 7,x
.87b5	85 25		sta $25		                sta tmp1+1
.87b7					_compare_loop:
.87b7	b5 04		lda $04,x	                lda 4,x
.87b9	15 05		ora $05,x	                ora 5,x
.87bb	f0 2c		beq $87e9	                beq _str1_done
.87bd	b5 00		lda $00,x	                lda 0,x
.87bf	15 01		ora $01,x	                ora 1,x
.87c1	f0 3a		beq $87fd	                beq _greater    ; Str2 empty first
.87c3					_check_letter:
.87c3	b2 24		lda ($24)	                lda (tmp1)
.87c5	d2 26		cmp ($26)	                cmp (tmp2)
.87c7	90 26		bcc $87ef	                bcc _less
.87c9	d0 32		bne $87fd	                bne _greater
.87cb					_next_letter:
.87cb	e6 24		inc $24		                inc tmp1
.87cd	d0 02		bne $87d1	                bne +
.87cf	e6 25		inc $25		                inc tmp1+1
.87d1					+
.87d1	e6 26		inc $26		                inc tmp2
.87d3	d0 02		bne $87d7	                bne +
.87d5	e6 27		inc $27		                inc tmp2+1
.87d7					+
.87d7	b5 04		lda $04,x	                lda 4,x
.87d9	d0 02		bne $87dd	                bne +
.87db	d6 05		dec $05,x	                dec 5,x
.87dd					+
.87dd	d6 04		dec $04,x	                dec 4,x
.87df	b5 00		lda $00,x	                lda 0,x
.87e1	d0 02		bne $87e5	                bne +
.87e3	d6 01		dec $01,x	                dec 1,x
.87e5					+
.87e5	d6 00		dec $00,x	                dec 0,x
.87e7	80 ce		bra $87b7	                bra _compare_loop
.87e9					_str1_done:
.87e9	b5 00		lda $00,x	                lda 0,x
.87eb	15 01		ora $01,x	                ora 1,x
.87ed	f0 08		beq $87f7	                beq _equal      ; Both out of letters
.87ef					_less:
.87ef	a9 ff		lda #$ff	                lda #$FF
.87f1	95 06		sta $06,x	                sta 6,x
.87f3	95 07		sta $07,x	                sta 7,x
.87f5	80 0c		bra $8803	                bra _done
.87f7					_equal:
.87f7	74 06		stz $06,x	                stz 6,x
.87f9	74 07		stz $07,x	                stz 7,x
.87fb	80 06		bra $8803	                bra _done
.87fd					_greater:
.87fd	a9 01		lda #$01	                lda #1
.87ff	95 06		sta $06,x	                sta 6,x
.8801	74 07		stz $07,x	                stz 7,x
.8803					_done:
.8803	8a		txa		                txa
.8804	18		clc		                clc
.8805	69 06		adc #$06	                adc #6
.8807	aa		tax		                tax
.8808	60		rts		z_compare:      rts
.8809					xt_compile_comma:
.8809	20 2e d9	jsr $d92e	                jsr underflow_1
.880c	b5 01		lda $01,x	                lda 1,x                 ; MSB
.880e	48		pha		                pha
.880f	b5 00		lda $00,x	                lda 0,x
.8811	48		pha		                pha                     ; LSB
.8812	20 94 92	jsr $9294	                jsr xt_int_to_name      ; ( xt -- nt )
.8815	b5 00		lda $00,x	                lda 0,x
.8817	15 01		ora $01,x	                ora 1,x
.8819	d0 03		bne $881e	                bne _check_nt
.881b	4c 06 89	jmp $8906	                jmp _compile_as_jump
.881e					_check_nt:
.881e	b5 00		lda $00,x	                lda 0,x
.8820	85 2c		sta $2c		                sta tmptos
.8822	b5 01		lda $01,x	                lda 1,x
.8824	85 2d		sta $2d		                sta tmptos+1
.8826	f6 00		inc $00,x	                inc 0,x
.8828	d0 02		bne $882c	                bne +
.882a	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.882c					+
.882c	a1 00		lda ($00,x)	                lda (0,x)
.882e	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.8830	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8832	f0 0d		beq $8841	                beq _compile_check
.8834	a5 2c		lda $2c		                lda tmptos
.8836	95 00		sta $00,x	                sta 0,x
.8838	a5 2d		lda $2d		                lda tmptos+1
.883a	95 01		sta $01,x	                sta 1,x
.883c	20 77 a7	jsr $a777	                jsr xt_wordsize         ; ( nt -- u )
.883f	80 27		bra $8868	                bra _compile_as_code
.8841					_compile_check:
.8841	a5 28		lda $28		                lda tmp3
.8843	29 08		and #$08	                and #NN
.8845	f0 03		beq $884a	                beq _check_size_limit
.8847	4c 06 89	jmp $8906	                jmp _compile_as_jump    ; too far for BRA
.884a					_check_size_limit:
.884a	a5 2c		lda $2c		                lda tmptos
.884c	95 00		sta $00,x	                sta 0,x
.884e	a5 2d		lda $2d		                lda tmptos+1
.8850	95 01		sta $01,x	                sta 1,x
.8852	20 77 a7	jsr $a777	                jsr xt_wordsize         ; ( nt -- u )
.8855	b5 01		lda $01,x	                lda 1,x
.8857	c5 1b		cmp $1b		                cmp nc_limit+1
.8859	90 0d		bcc $8868	                bcc _compile_as_code    ; user-defined limit MSB
.885b	d0 08		bne $8865	                bne _jumpto_compile_as_jump
.885d	b5 00		lda $00,x	                lda 0,x
.885f	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.8861	90 05		bcc $8868	                bcc _compile_as_code    ; Allow native compiling for less
.8863	f0 03		beq $8868	                beq _compile_as_code    ; than or equal to the limit.
.8865					_jumpto_compile_as_jump:
.8865	4c 06 89	jmp $8906	                jmp _compile_as_jump    ; too far for BRA
.8868					_compile_as_code:
.8868	ca		dex		                dex
.8869	ca		dex		                dex                     ; ( -- u ? )
.886a	ca		dex		                dex
.886b	ca		dex		                dex                     ; ( -- u ? ? )
.886c	b5 04		lda $04,x	                lda 4,x
.886e	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.8870	b5 05		lda $05,x	                lda 5,x
.8872	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8874	68		pla		                pla
.8875	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8877	68		pla		                pla
.8878	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.887a	a5 00		lda $00		                lda cp                  ; LSB of cp
.887c	95 02		sta $02,x	                sta 2,x
.887e	a5 01		lda $01		                lda cp+1
.8880	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8882	a0 00		ldy #$00	                ldy #0
.8884					_strip_loop:
.8884	b9 f4 88	lda $88f4,y	                lda _strip_table,y      ; LSB of first word
.8887	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8889	d0 07		bne $8892	                bne _next_entry
.888b	b9 f5 88	lda $88f5,y	                lda _strip_table+1,y
.888e	d5 05		cmp $05,x	                cmp 5,x
.8890	f0 0c		beq $889e	                beq _found_entry
.8892					_next_entry:
.8892	b9 f4 88	lda $88f4,y	                lda _strip_table,y      ; pointing to LSB
.8895	19 f5 88	ora $88f5,y	                ora _strip_table+1,y    ; get MSB
.8898	f0 22		beq $88bc	                beq _underflow_strip    ; table done, let's get out of here
.889a	c8		iny		                iny
.889b	c8		iny		                iny
.889c	80 e6		bra $8884	                bra _strip_loop
.889e					_found_entry:
.889e	98		tya		                tya
.889f	4a		lsr a		                lsr
.88a0	a8		tay		                tay
.88a1	b9 00 89	lda $8900,y	                lda _strip_size,y
.88a4	85 2c		sta $2c		                sta tmptos              ; save a copy
.88a6	18		clc		                clc
.88a7	75 04		adc $04,x	                adc 4,x
.88a9	95 04		sta $04,x	                sta 4,x
.88ab	90 02		bcc $88af	                bcc+
.88ad	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.88af					+
.88af	06 2c		asl $2c		                asl tmptos
.88b1	38		sec		                sec
.88b2	b5 00		lda $00,x	                lda 0,x
.88b4	e5 2c		sbc $2c		                sbc tmptos
.88b6	95 00		sta $00,x	                sta 0,x
.88b8	b0 02		bcs $88bc	                bcs +
.88ba	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.88bc					+
.88bc					_underflow_strip:
.88bc	a5 1c		lda $1c		                lda uf_strip
.88be	05 1d		ora $1d		                ora uf_strip+1
.88c0	f0 1c		beq $88de	                beq _specials_done
.88c2	a5 28		lda $28		                lda tmp3
.88c4	29 10		and #$10	                and #UF
.88c6	f0 16		beq $88de	                beq _specials_done
.88c8	18		clc		                clc
.88c9	b5 04		lda $04,x	                lda 4,x
.88cb	69 03		adc #$03	                adc #3
.88cd	95 04		sta $04,x	                sta 4,x
.88cf	90 02		bcc $88d3	                bcc +
.88d1	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.88d3					+
.88d3	38		sec		                sec
.88d4	b5 00		lda $00,x	                lda 0,x
.88d6	e9 03		sbc #$03	                sbc #3
.88d8	95 00		sta $00,x	                sta 0,x
.88da	b0 02		bcs $88de	                bcs +
.88dc	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88de					+
.88de					_specials_done:
.88de	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88e0	48		pha		                pha
.88e1	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88e3	48		pha		                pha
.88e4	20 f3 95	jsr $95f3	                jsr xt_move
.88e7	18		clc		                clc
.88e8	68		pla		                pla                     ; LSB
.88e9	65 00		adc $00		                adc cp
.88eb	85 00		sta $00		                sta cp
.88ed	68		pla		                pla                     ; MSB
.88ee	65 01		adc $01		                adc cp+1
.88f0	85 01		sta $01		                sta cp+1
.88f2	80 2c		bra $8920	                bra _done
.88f4					_strip_table:
>88f4	c3 9a ae 9a 72 a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88fa	a4 a4 2a a4 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.8900					_strip_size:
>8900	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.8906					_compile_as_jump:
.8906	a9 20		lda #$20	                lda #$20
.8908	92 00		sta ($00)	                sta (cp)
.890a	a0 01		ldy #$01	                ldy #1
.890c	68		pla		                pla             ; LSB
.890d	91 00		sta ($00),y	                sta (cp),y
.890f	c8		iny		                iny
.8910	68		pla		                pla             ; MSB
.8911	91 00		sta ($00),y	                sta (cp),y
.8913	a9 03		lda #$03	                lda #3
.8915	18		clc		                clc
.8916	65 00		adc $00		                adc cp
.8918	85 00		sta $00		                sta cp
.891a	90 02		bcc $891e	                bcc +
.891c	e6 01		inc $01		                inc cp+1
.891e					+
.891e	e8		inx		                inx             ; drop xt
.891f	e8		inx		                inx
.8920					_done:
.8920					z_compile_comma:
.8920	60		rts		                rts
.8921					xt_compile_only:
.8921	20 63 d8	jsr $d863	                jsr current_to_dp
.8924	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8926	b1 02		lda ($02),y	                lda (dp),y
.8928	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.892a	91 02		sta ($02),y	                sta (dp),y
.892c	60		rts		z_compile_only: rts
.892d					xt_value:
.892d					xt_constant:
.892d	20 2e d9	jsr $d92e	                jsr underflow_1
.8930	20 85 89	jsr $8985	                jsr xt_create
.8933	38		sec		                sec
.8934	a5 00		lda $00		                lda cp
.8936	e9 02		sbc #$02	                sbc #2
.8938	85 24		sta $24		                sta tmp1
.893a	a5 01		lda $01		                lda cp+1
.893c	e9 00		sbc #$00	                sbc #0
.893e	85 25		sta $25		                sta tmp1+1
.8940	a9 dd		lda #$dd	                lda #<doconst           ; LSB of DOCONST
.8942	92 24		sta ($24)	                sta (tmp1)
.8944	a0 01		ldy #$01	                ldy #1
.8946	a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.8948	91 24		sta ($24),y	                sta (tmp1),y
.894a	20 8a 87	jsr $878a	                jsr xt_comma            ; drop through to adjust_z
.894d					adjust_z:
.894d	20 57 93	jsr $9357	                jsr xt_latestnt         ; gives us ( -- nt )
.8950	b5 00		lda $00,x	                lda 0,x
.8952	85 24		sta $24		                sta tmp1
.8954	b5 01		lda $01,x	                lda 1,x
.8956	85 25		sta $25		                sta tmp1+1
.8958	a0 06		ldy #$06	                ldy #6
.895a	b1 24		lda ($24),y	                lda (tmp1),y
.895c	18		clc		                clc
.895d	69 02		adc #$02	                adc #2
.895f	91 24		sta ($24),y	                sta (tmp1),y
.8961	c8		iny		                iny
.8962	b1 24		lda ($24),y	                lda (tmp1),y
.8964	69 00		adc #$00	                adc #0                  ; only need carry
.8966	91 24		sta ($24),y	                sta (tmp1),y
.8968	e8		inx		                inx
.8969	e8		inx		                inx
.896a					z_value:
.896a	60		rts		z_constant:     rts
.896b					xt_count:
.896b	20 2e d9	jsr $d92e	                jsr underflow_1
.896e	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.8970	a8		tay		                tay
.8971	f6 00		inc $00,x	                inc 0,x         ; LSB
.8973	d0 02		bne $8977	                bne +
.8975	f6 01		inc $01,x	                inc 1,x         ; MSB
.8977	98		tya		+               tya
.8978	ca		dex		                dex
.8979	ca		dex		                dex
.897a	95 00		sta $00,x	                sta 0,x         ; LSB
.897c	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.897e	60		rts		z_count:        rts
.897f					xt_cr:
.897f	a9 0a		lda #$0a	                lda #AscLF
.8981	20 12 8e	jsr $8e12	                jsr emit_a
.8984	60		rts		z_cr:           rts
.8985					xt_create:
.8985	20 10 99	jsr $9910	                jsr xt_parse_name       ; ( addr u )
.8988	b5 00		lda $00,x	                lda 0,x
.898a	15 01		ora $01,x	                ora 1,x
.898c	d0 05		bne $8993	                bne _got_name
.898e	a9 05		lda #$05	                lda #err_noname
.8990	4c 44 d9	jmp $d944	                jmp error
.8993					_got_name:
.8993	74 01		stz $01,x	                stz 1,x
.8995	20 ba a3	jsr $a3ba	                jsr xt_two_dup          ; ( addr u addr u )
.8998	20 f7 8f	jsr $8ff7	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.899b	b5 00		lda $00,x	                lda 0,x
.899d	15 01		ora $01,x	                ora 1,x
.899f	f0 1e		beq $89bf	                beq _new_name           ; We haven't seen this one before.
.89a1	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.89a2	e8		inx		                inx
.89a3	24 20		bit $20		                bit status
.89a5	10 08		bpl $89af	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.89a7	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.89a9	05 20		ora $20		                ora status
.89ab	85 20		sta $20		                sta status
.89ad	80 18		bra $89c7	                bra _process_name
.89af					_redefined_name:
.89af	a9 02		lda #$02	                lda #str_redefined
.89b1	20 6a d9	jsr $d96a	                jsr print_string_no_lf
.89b4	20 ba a3	jsr $a3ba	                jsr xt_two_dup           ; ( addr u addr u )
.89b7	20 05 a5	jsr $a505	                jsr xt_type
.89ba	20 20 a1	jsr $a120	                jsr xt_space
.89bd	80 08		bra $89c7	                bra _process_name
.89bf					_new_name:
.89bf	e8		inx		                inx                     ; Drop flag (0) from find-name.
.89c0	e8		inx		                inx
.89c1	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.89c3	25 20		and $20		                and status
.89c5	85 20		sta $20		                sta status
.89c7					_process_name:
.89c7	b5 00		lda $00,x	                lda 0,x
.89c9	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.89cb	a5 00		lda $00		                lda cp
.89cd	85 24		sta $24		                sta tmp1
.89cf	a5 01		lda $01		                lda cp+1
.89d1	85 25		sta $25		                sta tmp1+1
.89d3	b5 00		lda $00,x	                lda 0,x
.89d5	18		clc		                clc
.89d6	69 08		adc #$08	                adc #8
.89d8	85 28		sta $28		                sta tmp3                ; total header length
.89da	18		clc		                clc
.89db	69 03		adc #$03	                adc #3
.89dd	95 00		sta $00,x	                sta 0,x
.89df	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89e1	20 a5 82	jsr $82a5	                jsr xt_allot    ; ( addr )
.89e4	20 63 d8	jsr $d863	                jsr current_to_dp
.89e7	a0 00		ldy #$00	                ldy #0
.89e9	a5 26		lda $26		                lda tmp2
.89eb	91 24		sta ($24),y	                sta (tmp1),y
.89ed	a9 08		lda #$08	                lda #NN
.89ef	09 20		ora #$20	                ora #HC
.89f1	c8		iny		                iny
.89f2	91 24		sta ($24),y	                sta (tmp1),y
.89f4	c8		iny		                iny
.89f5	a5 02		lda $02		                lda dp
.89f7	91 24		sta ($24),y	                sta (tmp1),y
.89f9	c8		iny		                iny
.89fa	a5 03		lda $03		                lda dp+1
.89fc	91 24		sta ($24),y	                sta (tmp1),y
.89fe	c8		iny		                iny
.89ff	a5 25		lda $25		                lda tmp1+1
.8a01	85 03		sta $03		                sta dp+1
.8a03	a5 24		lda $24		                lda tmp1
.8a05	85 02		sta $02		                sta dp
.8a07	18		clc		                clc
.8a08	65 28		adc $28		                adc tmp3        ; add total header length
.8a0a	91 24		sta ($24),y	                sta (tmp1),y
.8a0c	48		pha		                pha             ; we need this in the next step
.8a0d	c8		iny		                iny
.8a0e	a5 25		lda $25		                lda tmp1+1
.8a10	69 00		adc #$00	                adc #0          ; only need the carry
.8a12	91 24		sta ($24),y	                sta (tmp1),y
.8a14	c8		iny		                iny
.8a15	68		pla		                pla             ; LSB of "z_" address
.8a16	18		clc		                clc
.8a17	69 03		adc #$03	                adc #3
.8a19	91 24		sta ($24),y	                sta (tmp1),y
.8a1b	88		dey		                dey             ; get the MSB of xt back
.8a1c	b1 24		lda ($24),y	                lda (tmp1),y
.8a1e	69 00		adc #$00	                adc #0          ; only need the carry
.8a20	c8		iny		                iny
.8a21	c8		iny		                iny
.8a22	91 24		sta ($24),y	                sta (tmp1),y
.8a24	c8		iny		                iny
.8a25	b5 00		lda $00,x	                lda 0,x
.8a27	38		sec		                sec
.8a28	e9 08		sbc #$08	                sbc #8
.8a2a	85 2c		sta $2c		                sta tmptos
.8a2c	b5 01		lda $01,x	                lda 1,x
.8a2e	e9 00		sbc #$00	                sbc #0          ; only need carry
.8a30	85 2d		sta $2d		                sta tmptos+1
.8a32					_name_loop:
.8a32	b1 2c		lda ($2c),y	                lda (tmptos),y
.8a34	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8a36	b0 07		bcs $8a3f	                bcs _store_name
.8a38	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8a3a	90 03		bcc $8a3f	                bcc _store_name
.8a3c	18		clc		                clc
.8a3d	69 20		adc #$20	                adc #$20
.8a3f					_store_name:
.8a3f	91 24		sta ($24),y	                sta (tmp1),y
.8a41	c8		iny		                iny
.8a42	c6 26		dec $26		                dec tmp2
.8a44	d0 ec		bne $8a32	                bne _name_loop
.8a46	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a48	91 24		sta ($24),y	                sta (tmp1),y
.8a4a	c8		iny		                iny
.8a4b	a9 23		lda #$23	                lda #<dovar
.8a4d	91 24		sta ($24),y	                sta (tmp1),y
.8a4f	c8		iny		                iny
.8a50	a9 d8		lda #$d8	                lda #>dovar
.8a52	91 24		sta ($24),y	                sta (tmp1),y
.8a54	20 76 d8	jsr $d876	                jsr dp_to_current
.8a57	e8		inx		                inx
.8a58	e8		inx		                inx
.8a59	60		rts		z_create:       rts
.8a5a					xt_d_minus:
.8a5a	20 3d d9	jsr $d93d	                jsr underflow_4 ; two double numbers
.8a5d	38		sec		                sec
.8a5e	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a60	f5 02		sbc $02,x	                sbc 2,x
.8a62	95 06		sta $06,x	                sta 6,x
.8a64	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a66	f5 03		sbc $03,x	                sbc 3,x
.8a68	95 07		sta $07,x	                sta 7,x
.8a6a	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a6c	f5 00		sbc $00,x	                sbc 0,x
.8a6e	95 04		sta $04,x	                sta 4,x
.8a70	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a72	f5 01		sbc $01,x	                sbc 1,x
.8a74	95 05		sta $05,x	                sta 5,x
.8a76	e8		inx		                inx
.8a77	e8		inx		                inx
.8a78	e8		inx		                inx
.8a79	e8		inx		                inx
.8a7a	60		rts		z_d_minus:      rts
.8a7b					xt_d_plus:
.8a7b	20 3d d9	jsr $d93d	                jsr underflow_4 ; two double numbers
.8a7e	18		clc		                clc
.8a7f	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a81	75 06		adc $06,x	                adc 6,x
.8a83	95 06		sta $06,x	                sta 6,x
.8a85	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a87	75 07		adc $07,x	                adc 7,x
.8a89	95 07		sta $07,x	                sta 7,x
.8a8b	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a8d	75 04		adc $04,x	                adc 4,x
.8a8f	95 04		sta $04,x	                sta 4,x
.8a91	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a93	75 05		adc $05,x	                adc 5,x
.8a95	95 05		sta $05,x	                sta 5,x
.8a97	e8		inx		                inx
.8a98	e8		inx		                inx
.8a99	e8		inx		                inx
.8a9a	e8		inx		                inx
.8a9b	60		rts		z_d_plus:       rts
.8a9c					xt_d_to_s:
.8a9c	20 33 d9	jsr $d933	                jsr underflow_2
.8a9f	e8		inx		                inx
.8aa0	e8		inx		                inx
.8aa1	60		rts		z_d_to_s:       rts
.8aa2					xt_dabs:
.8aa2	20 33 d9	jsr $d933	                jsr underflow_2 ; double number
.8aa5	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8aa7	10 17		bpl $8ac0	                bpl _done       ; positive, we get off light
.8aa9	a0 00		ldy #$00	                ldy #0
.8aab	38		sec		                sec
.8aac	98		tya		                tya
.8aad	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8aaf	95 02		sta $02,x	                sta 2,x
.8ab1	98		tya		                tya
.8ab2	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8ab4	95 03		sta $03,x	                sta 3,x
.8ab6	98		tya		                tya
.8ab7	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8ab9	95 00		sta $00,x	                sta 0,x
.8abb	98		tya		                tya
.8abc	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8abe	95 01		sta $01,x	                sta 1,x
.8ac0					_done:
.8ac0	60		rts		z_dabs:         rts
.8ac1					xt_decimal:
.8ac1	a9 0a		lda #$0a	                lda #10
.8ac3	85 18		sta $18		                sta base
.8ac5	64 19		stz $19		                stz base+1              ; paranoid
.8ac7	60		rts		z_decimal:      rts
.8ac8					xt_defer:
.8ac8	20 85 89	jsr $8985	                jsr xt_create
.8acb	a5 00		lda $00		                lda cp          ; LSB
.8acd	38		sec		                sec
.8ace	e9 02		sbc #$02	                sbc #2
.8ad0	85 24		sta $24		                sta tmp1
.8ad2	a5 01		lda $01		                lda cp+1        ; MSB
.8ad4	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8ad6	85 25		sta $25		                sta tmp1+1
.8ad8	a0 00		ldy #$00	                ldy #0
.8ada	a9 f1		lda #$f1	                lda #<dodefer   ; LSB
.8adc	91 24		sta ($24),y	                sta (tmp1),y
.8ade	c8		iny		                iny
.8adf	a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8ae1	91 24		sta ($24),y	                sta (tmp1),y
.8ae3	a9 05		lda #$05	                lda #<defer_error
.8ae5	92 00		sta ($00)	                sta (cp)
.8ae7	e6 00		inc $00		                inc cp
.8ae9	d0 02		bne $8aed	                bne +
.8aeb	e6 01		inc $01		                inc cp+1
.8aed					+
.8aed	a9 d8		lda #$d8	                lda #>defer_error
.8aef	92 00		sta ($00)	                sta (cp)
.8af1	e6 00		inc $00		                inc cp
.8af3	d0 02		bne $8af7	                bne +
.8af5	e6 01		inc $01		                inc cp+1
.8af7					+
.8af7	20 4d 89	jsr $894d	                jsr adjust_z    ; adjust header to correct length
.8afa	60		rts		z_defer:        rts
.8afb					xt_defer_fetch:
.8afb	20 8f a2	jsr $a28f	                jsr xt_to_body
.8afe	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.8b01	60		rts		z_defer_fetch:  rts
.8b02					xt_defer_store:
.8b02	20 8f a2	jsr $a28f	                jsr xt_to_body
.8b05	20 8f a1	jsr $a18f	                jsr xt_store
.8b08	60		rts		z_defer_store:  rts
.8b09					xt_definitions:
.8b09	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8b0b	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8b0d	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8b0f	91 1e		sta ($1e),y	                sta (up),y
.8b11	60		rts		z_definitions:  rts
.8b12					xt_depth:
.8b12	a9 78		lda #$78	                lda #dsp0
.8b14	86 2a		stx $2a		                stx tmpdsp
.8b16	38		sec		                sec
.8b17	e5 2a		sbc $2a		                sbc tmpdsp
.8b19	4a		lsr a		                lsr
.8b1a	ca		dex		                dex
.8b1b	ca		dex		                dex
.8b1c	95 00		sta $00,x	                sta 0,x
.8b1e	74 01		stz $01,x	                stz 1,x
.8b20	60		rts		z_depth:        rts
.8b21					xt_digit_question:
.8b21	20 2e d9	jsr $d92e	                jsr underflow_1
.8b24	ca		dex		                dex
.8b25	ca		dex		                dex
.8b26	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8b28	74 01		stz $01,x	                stz 1,x
.8b2a	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8b2c	b5 02		lda $02,x	                lda 2,x
.8b2e	c9 30		cmp #$30	                cmp #'0'
.8b30	90 23		bcc $8b55	                bcc _done               ; failure flag already set
.8b32	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8b34	90 12		bcc $8b48	                bcc _checkbase
.8b36	c9 41		cmp #$41	                cmp #'A'
.8b38	90 1b		bcc $8b55	                bcc _done               ; failure flag is already set
.8b3a	c9 61		cmp #$61	                cmp #'a'
.8b3c	90 07		bcc $8b45	                bcc _case_done          ; not lower case, too low
.8b3e	c9 7b		cmp #$7b	                cmp #'z'+1
.8b40	b0 03		bcs $8b45	                bcs _case_done          ; not lower case, too high
.8b42	18		clc		                clc                     ; just right
.8b43	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b45					_case_done:
.8b45	38		sec		                sec
.8b46	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b48					_checkbase:
.8b48	38		sec		                sec
.8b49	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b4b	c5 18		cmp $18		                cmp base
.8b4d	b0 06		bcs $8b55	                bcs _done               ; already have false flag
.8b4f	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b51	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b53	d6 01		dec $01,x	                dec 1,x
.8b55					_done:
.8b55					z_digit_question:
.8b55	60		rts		                rts
.8b56					xt_disasm:
.8b56	20 33 d9	jsr $d933	                jsr underflow_2
.8b59	20 d9 ac	jsr $acd9	                jsr disassembler
.8b5c	60		rts		z_disasm:       rts
.8b5d					xt_dnegate:
.8b5d	20 33 d9	jsr $d933	                jsr underflow_2 ; double number
.8b60	a0 00		ldy #$00	     		ldy #0
.8b62	38		sec		                sec
.8b63	98		tya		                tya
.8b64	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b66	95 02		sta $02,x	                sta 2,x
.8b68	98		tya		                tya
.8b69	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b6b	95 03		sta $03,x	                sta 3,x
.8b6d	98		tya		                tya
.8b6e	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b70	95 00		sta $00,x	                sta 0,x
.8b72	98		tya		                tya
.8b73	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b75	95 01		sta $01,x	                sta 1,x
.8b77	60		rts		z_dnegate:      rts
.8b78					xt_question_do:
.8b78	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b7a	85 24		sta $24		                sta tmp1
.8b7c	80 02		bra $8b80	                bra do_common           ; skip flag for DO
.8b7e					xt_do:
.8b7e	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b80					do_common:
.8b80	ca		dex		                dex
.8b81	ca		dex		                dex
.8b82	a5 00		lda $00		                lda cp
.8b84	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b86	a5 01		lda $01		                lda cp+1
.8b88	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b8a	a9 05		lda #$05	                lda #5                  ; we don't really care about the value,
.8b8c	a8		tay		                tay                     ; so we use 5 to be tricky
.8b8d					_loop:
.8b8d	91 00		sta ($00),y	                sta (CP),y
.8b8f	88		dey		                dey
.8b90	10 fb		bpl $8b8d	                bpl _loop
.8b92	1a		inc a		                ina             ; we used 5 as a dummy value, this is why
.8b93	18		clc		                clc
.8b94	65 00		adc $00		                adc CP
.8b96	85 00		sta $00		                sta CP
.8b98	90 02		bcc $8b9c	                bcc +
.8b9a	e6 01		inc $01		                inc CP+1
.8b9c					+
.8b9c	a5 24		lda $24		                lda tmp1
.8b9e	f0 17		beq $8bb7	                beq _compile_do
.8ba0	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8ba2	5a		phy		                phy             ; save counter to calculate new CP
.8ba3					-
.8ba3	b9 fd 8b	lda $8bfd,y	                lda question_do_runtime,y
.8ba6	91 00		sta ($00),y	                sta (cp),y
.8ba8	88		dey		                dey
.8ba9	10 f8		bpl $8ba3	                bpl -
.8bab	68		pla		                pla             ; retrieve counter
.8bac	18		clc		                clc
.8bad	65 00		adc $00		                adc cp
.8baf	85 00		sta $00		                sta cp
.8bb1	a5 01		lda $01		                lda cp+1
.8bb3	69 00		adc #$00	                adc #0          ; only care about carry
.8bb5	85 01		sta $01		                sta cp+1        ; fall through to _compile_do
.8bb7					_compile_do:
.8bb7	a0 24		ldy #$24	                ldy #do_runtime_end-do_runtime  ; counter
.8bb9	5a		phy		                phy             ; save counter to calculate new CP
.8bba					-
.8bba	b9 d9 8b	lda $8bd9,y	                lda do_runtime,y
.8bbd	91 00		sta ($00),y	                sta (cp),y
.8bbf	88		dey		                dey
.8bc0	10 f8		bpl $8bba	                bpl -
.8bc2	68		pla		                pla             ; retrieve counter
.8bc3	18		clc		                clc
.8bc4	65 00		adc $00		                adc cp
.8bc6	85 00		sta $00		                sta cp
.8bc8	a5 01		lda $01		                lda cp+1
.8bca	69 00		adc #$00	                adc #0          ; only care about carry
.8bcc	85 01		sta $01		                sta cp+1
.8bce	ca		dex		                dex
.8bcf	ca		dex		                dex
.8bd0	a5 00		lda $00		                lda CP          ; LSB
.8bd2	95 00		sta $00,x	                sta 0,x
.8bd4	a5 01		lda $01		                lda CP+1        ; MSB
.8bd6	95 01		sta $01,x	                sta 1,x
.8bd8					z_question_do:
.8bd8	60		rts		z_do:           rts
.8bd9					do_runtime:
.8bd9	38		sec		                sec
.8bda	a9 00		lda #$00	                lda #0
.8bdc	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8bde	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8be0	a9 80		lda #$80	                lda #$80
.8be2	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8be4	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8be6	48		pha		                pha             ; FUFA replaces limit on R stack
.8be7	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8be9	48		pha		                pha
.8bea	18		clc		                clc
.8beb	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bed	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bef	95 00		sta $00,x	                sta 0,x
.8bf1	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8bf3	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8bf5	48		pha		                pha
.8bf6	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8bf8	48		pha		                pha
.8bf9	e8		inx		                inx
.8bfa	e8		inx		                inx
.8bfb	e8		inx		                inx
.8bfc	e8		inx		                inx             ; no RTS because this is copied into code
.8bfd					do_runtime_end:
.8bfd					question_do_runtime:
.8bfd	20 ba a3	jsr $a3ba	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8c00	20 ea 8e	jsr $8eea	                jsr xt_equal            ; ( -- n1 n2 f )
.8c03	b5 00		lda $00,x	                lda 0,x
.8c05	15 01		ora $01,x	                ora 1,x
.8c07	f0 06		beq $8c0f	                beq _do_do
.8c09	8a		txa		                txa
.8c0a	18		clc		                clc
.8c0b	69 06		adc #$06	                adc #6
.8c0d	aa		tax		                tax
.8c0e	60		rts		                rts
.8c0f					_do_do:
.8c0f	e8		inx		                inx             ; clear flag from EQUAL off stack
.8c10	e8		inx		                inx             ; no RTS because this is copied into code
.8c11					question_do_runtime_end:
.8c11					xt_does:
.8c11	a0 8c		ldy #$8c	                ldy #>does_runtime
.8c13	a9 20		lda #$20	                lda #<does_runtime
.8c15	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.8c18	a0 d8		ldy #$d8	                ldy #>dodoes
.8c1a	a9 0a		lda #$0a	                lda #<dodoes
.8c1c	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.8c1f	60		rts		z_does:         rts
.8c20					does_runtime:
.8c20	7a		ply		                ply             ; LSB
.8c21	68		pla		                pla             ; MSB
.8c22	c8		iny		                iny
.8c23	d0 01		bne $8c26	                bne +
.8c25	1a		inc a		                ina
.8c26					+
.8c26	84 24		sty $24		                sty tmp1
.8c28	85 25		sta $25		                sta tmp1+1
.8c2a	20 63 d8	jsr $d863	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8c2d	a5 02		lda $02		                lda dp
.8c2f	18		clc		                clc
.8c30	69 04		adc #$04	                adc #4
.8c32	85 26		sta $26		                sta tmp2
.8c34	a5 03		lda $03		                lda dp+1
.8c36	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c38	85 27		sta $27		                sta tmp2+1
.8c3a	b2 26		lda ($26)	                lda (tmp2)
.8c3c	18		clc		                clc
.8c3d	69 01		adc #$01	                adc #1
.8c3f	85 28		sta $28		                sta tmp3
.8c41	a0 01		ldy #$01	                ldy #1
.8c43	b1 26		lda ($26),y	                lda (tmp2),y
.8c45	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c47	85 29		sta $29		                sta tmp3+1
.8c49	a5 24		lda $24		                lda tmp1        ; LSB
.8c4b	92 28		sta ($28)	                sta (tmp3)
.8c4d	a5 25		lda $25		                lda tmp1+1
.8c4f	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c51	60		rts		                rts
.8c52					xt_dot:
.8c52	20 2e d9	jsr $d92e	                jsr underflow_1
.8c55	20 cb 8d	jsr $8dcb	                jsr xt_dup                      ; ( n n )
.8c58	20 33 81	jsr $8133	                jsr xt_abs                      ; ( n u )
.8c5b	20 aa a7	jsr $a7aa	                jsr xt_zero                     ; ( n u 0 )
.8c5e	20 76 93	jsr $9376	                jsr xt_less_number_sign         ; ( n u 0 )
.8c61	20 0f 98	jsr $980f	                jsr xt_number_sign_s            ; ( n ud )
.8c64	20 88 9b	jsr $9b88	                jsr xt_rot                      ; ( ud n )
.8c67	20 e9 9f	jsr $9fe9	                jsr xt_sign                     ; ( ud )
.8c6a	20 ed 97	jsr $97ed	                jsr xt_number_sign_greater      ; ( addr u )
.8c6d	20 05 a5	jsr $a505	                jsr xt_type
.8c70	20 20 a1	jsr $a120	                jsr xt_space
.8c73	60		rts		z_dot:          rts
.8c74					xt_dot_paren:
.8c74	ca		dex		                dex
.8c75	ca		dex		                dex
.8c76	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c78	95 00		sta $00,x	                sta 0,x
.8c7a	74 01		stz $01,x	                stz 1,x
.8c7c	20 6b 99	jsr $996b	                jsr xt_parse
.8c7f	20 05 a5	jsr $a505	                jsr xt_type
.8c82	60		rts		z_dot_paren:    rts
.8c83					xt_dot_quote:
.8c83	20 80 9d	jsr $9d80	                jsr xt_s_quote
.8c86	a0 a5		ldy #$a5	                ldy #>xt_type
.8c88	a9 05		lda #$05	                lda #<xt_type
.8c8a	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.8c8d	60		rts		z_dot_quote:    rts
.8c8e					xt_dot_r:
.8c8e	20 33 d9	jsr $d933	                jsr underflow_2
.8c91	20 72 a3	jsr $a372	                jsr xt_to_r
.8c94	20 cb 8d	jsr $8dcb	                jsr xt_dup
.8c97	20 33 81	jsr $8133	                jsr xt_abs
.8c9a	20 aa a7	jsr $a7aa	                jsr xt_zero
.8c9d	20 76 93	jsr $9376	                jsr xt_less_number_sign
.8ca0	20 0f 98	jsr $980f	                jsr xt_number_sign_s
.8ca3	20 88 9b	jsr $9b88	                jsr xt_rot
.8ca6	20 e9 9f	jsr $9fe9	                jsr xt_sign
.8ca9	20 ed 97	jsr $97ed	                jsr xt_number_sign_greater
.8cac	20 c3 9a	jsr $9ac3	                jsr xt_r_from
.8caf	20 c4 98	jsr $98c4	                jsr xt_over
.8cb2	20 81 95	jsr $9581	                jsr xt_minus
.8cb5	20 26 a1	jsr $a126	                jsr xt_spaces
.8cb8	20 05 a5	jsr $a505	                jsr xt_type
.8cbb	60		rts		z_dot_r:        rts
.8cbc					xt_dot_s:
.8cbc	20 12 8b	jsr $8b12	                jsr xt_depth    ; ( -- u )
.8cbf	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8cc1	20 12 8e	jsr $8e12	                jsr emit_a
.8cc4	b5 00		lda $00,x	                lda 0,x
.8cc6	48		pha		                pha
.8cc7	ca		dex		                dex             ; DUP
.8cc8	ca		dex		                dex
.8cc9	95 00		sta $00,x	                sta 0,x
.8ccb	74 01		stz $01,x	                stz 1,x
.8ccd	20 9b d9	jsr $d99b	                jsr print_u
.8cd0	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8cd2	20 12 8e	jsr $8e12	                jsr emit_a
.8cd5	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8cd7	20 12 8e	jsr $8e12	                jsr emit_a
.8cda	e8		inx		                inx
.8cdb	e8		inx		                inx
.8cdc	e0 78		cpx #$78	                cpx #dsp0
.8cde	f0 1e		beq $8cfe	                beq _done
.8ce0					_have_stack:
.8ce0	7a		ply		                ply
.8ce1	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8ce3	85 28		sta $28		                sta tmp3
.8ce5	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8ce7					_loop:
.8ce7	ca		dex		                dex
.8ce8	ca		dex		                dex
.8ce9	b2 28		lda ($28)	                lda (tmp3)
.8ceb	95 01		sta $01,x	                sta 1,x
.8ced	c6 28		dec $28		                dec tmp3
.8cef	b2 28		lda ($28)	                lda (tmp3)
.8cf1	95 00		sta $00,x	                sta 0,x
.8cf3	c6 28		dec $28		                dec tmp3
.8cf5	5a		phy		                phy
.8cf6	20 52 8c	jsr $8c52	                jsr xt_dot
.8cf9	7a		ply		                ply
.8cfa	88		dey		                dey
.8cfb	d0 ea		bne $8ce7	                bne _loop
.8cfd	48		pha		                pha             ; dummy to balance stack
.8cfe					_done:
.8cfe	68		pla		                pla
.8cff	60		rts		z_dot_s:        rts
.8d00					xt_d_dot:
.8d00	20 33 d9	jsr $d933	                jsr underflow_2
.8d03	20 8f a3	jsr $a38f	                jsr xt_tuck
.8d06	20 a2 8a	jsr $8aa2	                jsr xt_dabs
.8d09	20 76 93	jsr $9376	                jsr xt_less_number_sign
.8d0c	20 0f 98	jsr $980f	                jsr xt_number_sign_s
.8d0f	20 88 9b	jsr $9b88	                jsr xt_rot
.8d12	20 e9 9f	jsr $9fe9	                jsr xt_sign
.8d15	20 ed 97	jsr $97ed	                jsr xt_number_sign_greater
.8d18	20 05 a5	jsr $a505	                jsr xt_type
.8d1b	20 20 a1	jsr $a120	                jsr xt_space
.8d1e	60		rts		z_d_dot:        rts
.8d1f					xt_d_dot_r:
.8d1f	20 38 d9	jsr $d938	                jsr underflow_3
.8d22	20 72 a3	jsr $a372	                jsr xt_to_r
.8d25	20 8f a3	jsr $a38f	                jsr xt_tuck
.8d28	20 a2 8a	jsr $8aa2	                jsr xt_dabs
.8d2b	20 76 93	jsr $9376	                jsr xt_less_number_sign
.8d2e	20 0f 98	jsr $980f	                jsr xt_number_sign_s
.8d31	20 88 9b	jsr $9b88	                jsr xt_rot
.8d34	20 e9 9f	jsr $9fe9	                jsr xt_sign
.8d37	20 ed 97	jsr $97ed	                jsr xt_number_sign_greater
.8d3a	20 c3 9a	jsr $9ac3	                jsr xt_r_from
.8d3d	20 c4 98	jsr $98c4	                jsr xt_over
.8d40	20 81 95	jsr $9581	                jsr xt_minus
.8d43	20 26 a1	jsr $a126	                jsr xt_spaces
.8d46	20 05 a5	jsr $a505	                jsr xt_type
.8d49	60		rts		z_d_dot_r:      rts
.8d4a					xt_drop:
.8d4a	20 2e d9	jsr $d92e	                jsr underflow_1
.8d4d	e8		inx		                inx
.8d4e	e8		inx		                inx
.8d4f	60		rts		z_drop:         rts
.8d50					xt_dump:
.8d50	20 33 d9	jsr $d933	                jsr underflow_2
.8d53					_row:
.8d53	a0 10		ldy #$10	                ldy #16
.8d55	64 26		stz $26		                stz tmp2
.8d57	20 7f 89	jsr $897f	                jsr xt_cr
.8d5a	b5 03		lda $03,x	                lda 3,x
.8d5c	20 31 d8	jsr $d831	                jsr byte_to_ascii
.8d5f	b5 02		lda $02,x	                lda 2,x
.8d61	20 31 d8	jsr $d831	                jsr byte_to_ascii
.8d64	20 20 a1	jsr $a120	                jsr xt_space
.8d67	20 20 a1	jsr $a120	                jsr xt_space
.8d6a					_loop:
.8d6a	b5 00		lda $00,x	                lda 0,x
.8d6c	15 01		ora $01,x	                ora 1,x
.8d6e	f0 39		beq $8da9	                beq _all_printed
.8d70	a1 02		lda ($02,x)	                lda (2,x)
.8d72	48		pha		                pha                     ; byte_to_ascii destroys A
.8d73	20 31 d8	jsr $d831	                jsr byte_to_ascii
.8d76	20 20 a1	jsr $a120	                jsr xt_space
.8d79	68		pla		                pla
.8d7a	20 14 d9	jsr $d914	                jsr is_printable
.8d7d	b0 02		bcs $8d81	                bcs _printable
.8d7f	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d81					_printable:
.8d81	5a		phy		                phy                     ; save counter
.8d82	a4 26		ldy $26		                ldy tmp2
.8d84	91 00		sta ($00),y	                sta (cp),y
.8d86	e6 26		inc $26		                inc tmp2
.8d88	7a		ply		                ply
.8d89	c0 09		cpy #$09	                cpy #9
.8d8b	d0 03		bne $8d90	                bne _next_char
.8d8d	20 20 a1	jsr $a120	                jsr xt_space
.8d90					_next_char:
.8d90	f6 02		inc $02,x	                inc 2,x
.8d92	d0 02		bne $8d96	                bne _counter
.8d94	f6 03		inc $03,x	                inc 3,x
.8d96					_counter:
.8d96	b5 00		lda $00,x	                lda 0,x
.8d98	d0 02		bne $8d9c	                bne +
.8d9a	d6 01		dec $01,x	                dec 1,x
.8d9c					+
.8d9c	d6 00		dec $00,x	                dec 0,x
.8d9e	88		dey		                dey
.8d9f	d0 c9		bne $8d6a	                bne _loop               ; next byte
.8da1	20 20 a1	jsr $a120	                jsr xt_space
.8da4	20 b7 8d	jsr $8db7	                jsr dump_print_ascii
.8da7	80 aa		bra $8d53	                bra _row                ; new row
.8da9					_all_printed:
.8da9	a5 26		lda $26		                lda tmp2
.8dab	f0 06		beq $8db3	                beq _done
.8dad	20 20 a1	jsr $a120	                jsr xt_space
.8db0	20 b7 8d	jsr $8db7	                jsr dump_print_ascii
.8db3					_done:
.8db3	20 b2 a3	jsr $a3b2	                jsr xt_two_drop         ; one byte less than 4x INX
.8db6	60		rts		z_dump:         rts
.8db7					dump_print_ascii:
.8db7	a0 00		ldy #$00	                ldy #0
.8db9					_ascii_loop:
.8db9	b1 00		lda ($00),y	                lda (cp),y
.8dbb	20 12 8e	jsr $8e12	                jsr emit_a
.8dbe	c8		iny		                iny
.8dbf	c0 08		cpy #$08	                cpy #8
.8dc1	d0 03		bne $8dc6	                bne +
.8dc3	20 20 a1	jsr $a120	                jsr xt_space
.8dc6					+
.8dc6	c6 26		dec $26		                dec tmp2
.8dc8	d0 ef		bne $8db9	                bne _ascii_loop
.8dca	60		rts		                rts
.8dcb					xt_dup:
.8dcb	20 2e d9	jsr $d92e	                jsr underflow_1
.8dce	ca		dex		                dex
.8dcf	ca		dex		                dex
.8dd0	b5 02		lda $02,x	                lda 2,x         ; LSB
.8dd2	95 00		sta $00,x	                sta 0,x
.8dd4	b5 03		lda $03,x	                lda 3,x         ; MSB
.8dd6	95 01		sta $01,x	                sta 1,x
.8dd8	60		rts		z_dup:          rts
.8dd9					xt_ed:
.8dd9	20 d6 b5	jsr $b5d6	                jsr ed6502      ; kept in separate file
.8ddc	60		rts		z_ed:           rts
.8ddd					xt_else:
.8ddd					xt_endof:
.8ddd	a0 8d		ldy #$8d	                ldy #>branch_runtime
.8ddf	a9 f7		lda #$f7	                lda #<branch_runtime
.8de1	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.8de4	20 8e 91	jsr $918e	                jsr xt_here
.8de7	20 aa a7	jsr $a7aa	                jsr xt_zero
.8dea	20 8a 87	jsr $878a	                jsr xt_comma
.8ded	20 8e 91	jsr $918e	                jsr xt_here
.8df0	20 88 9b	jsr $9b88	                jsr xt_rot
.8df3	20 8f a1	jsr $a18f	                jsr xt_store
.8df6					z_else:
.8df6					z_endof:
.8df6	60		rts		                rts
.8df7					branch_runtime:
.8df7	68		pla		                pla
.8df8	85 22		sta $22		                sta tmpbranch
.8dfa	68		pla		                pla
.8dfb	85 23		sta $23		                sta tmpbranch+1
.8dfd	a0 01		ldy #$01	                ldy #1
.8dff	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8e01	85 24		sta $24		                sta tmp1
.8e03	c8		iny		                iny
.8e04	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8e06	85 25		sta $25		                sta tmp1+1
.8e08	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8e0b					xt_emit:
.8e0b	20 2e d9	jsr $d92e	                jsr underflow_1
.8e0e	b5 00		lda $00,x	                lda 0,x
.8e10	e8		inx		                inx
.8e11	e8		inx		                inx
.8e12					emit_a:
.8e12	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8e15					z_emit:
.8e15					xt_empty_buffers:
.8e15	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8e17	a9 00		lda #$00	                lda #0
.8e19	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8e1b					z_empty_buffers:
.8e1b	60		rts		                rts
.8e1c					xt_endcase:
.8e1c	a0 8d		ldy #$8d	                ldy #>xt_drop
.8e1e	a9 4a		lda #$4a	                lda #<xt_drop
.8e20	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.8e23					_endcase_loop:
.8e23	b5 00		lda $00,x	                lda 0,x
.8e25	15 01		ora $01,x	                ora 1,x
.8e27	f0 05		beq $8e2e	                beq _done
.8e29	20 c4 a1	jsr $a1c4	                jsr xt_then
.8e2c	80 f5		bra $8e23	                bra _endcase_loop
.8e2e					_done:
.8e2e	e8		inx		                inx
.8e2f	e8		inx		                inx
.8e30	60		rts		z_endcase:      rts
.8e31					xt_environment_q:
.8e31	20 2e d9	jsr $d92e	                jsr underflow_1
.8e34	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8e36	5a		phy		                phy
.8e37					_table_loop:
.8e37	20 ba a3	jsr $a3ba	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e3a	ca		dex		                dex
.8e3b	ca		dex		                dex                     ; ( addr u addr u ? )
.8e3c	b9 ae 8e	lda $8eae,y	                lda env_table_single,y
.8e3f	95 00		sta $00,x	                sta 0,x
.8e41	c8		iny		                iny
.8e42	b9 ae 8e	lda $8eae,y	                lda env_table_single,y
.8e45	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e47	c8		iny		                iny
.8e48	15 00		ora $00,x	                ora 0,x
.8e4a	f0 4d		beq $8e99	                beq _table_done
.8e4c	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e4d	20 6b 89	jsr $896b	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e50	20 a4 87	jsr $87a4	                jsr xt_compare          ; ( addr u f )
.8e53	7a		ply		                ply
.8e54	b5 00		lda $00,x	                lda 0,x
.8e56	15 01		ora $01,x	                ora 1,x
.8e58	f0 04		beq $8e5e	                beq _got_result
.8e5a	e8		inx		                inx                     ; DROP, now ( addr u )
.8e5b	e8		inx		                inx
.8e5c	80 d9		bra $8e37	                bra _table_loop
.8e5e					_got_result:
.8e5e	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e5f	e8		inx		                inx
.8e60	88		dey		                dey                     ; go back to index we had
.8e61	88		dey		                dey
.8e62	68		pla		                pla
.8e63	d0 0d		bne $8e72	                bne _double_result
.8e65	b9 cc 8e	lda $8ecc,y	                lda env_results_single,y
.8e68	95 02		sta $02,x	                sta 2,x
.8e6a	c8		iny		                iny
.8e6b	b9 cc 8e	lda $8ecc,y	                lda env_results_single,y
.8e6e	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e70	80 1f		bra $8e91	                bra _set_flag
.8e72					_double_result:
.8e72	ca		dex		                dex                     ; ( addr u ? )
.8e73	ca		dex		                dex
.8e74	98		tya		                tya
.8e75	38		sec		                sec
.8e76	e9 18		sbc #$18	                sbc #24
.8e78	0a		asl a		                asl
.8e79	a8		tay		                tay
.8e7a	b9 e2 8e	lda $8ee2,y	                lda env_results_double,y
.8e7d	95 02		sta $02,x	                sta 2,x
.8e7f	c8		iny		                iny
.8e80	b9 e2 8e	lda $8ee2,y	                lda env_results_double,y
.8e83	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e85	c8		iny		                iny
.8e86	b9 e2 8e	lda $8ee2,y	                lda env_results_double,y
.8e89	95 04		sta $04,x	                sta 4,x
.8e8b	c8		iny		                iny
.8e8c	b9 e2 8e	lda $8ee2,y	                lda env_results_double,y
.8e8f	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e91					_set_flag:
.8e91	a9 ff		lda #$ff	                lda #$ff
.8e93	95 00		sta $00,x	                sta 0,x
.8e95	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e97	80 14		bra $8ead	                bra _done
.8e99					_table_done:
.8e99	68		pla		                pla
.8e9a	d0 09		bne $8ea5	                bne _no_match
.8e9c	1a		inc a		                ina
.8e9d	48		pha		                pha
.8e9e	8a		txa		                txa
.8e9f	18		clc		                clc
.8ea0	69 06		adc #$06	                adc #6                  ; skip six bytes
.8ea2	aa		tax		                tax                     ; ( addr u )
.8ea3	80 92		bra $8e37	                bra _table_loop
.8ea5					_no_match:
.8ea5	8a		txa		                txa
.8ea6	18		clc		                clc
.8ea7	69 0a		adc #$0a	                adc #10
.8ea9	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8eaa	20 95 8f	jsr $8f95	                jsr xt_false
.8ead					_done:
.8ead					z_environment_q:
.8ead	60		rts		                rts
.8eae					env_table_single:
>8eae	44 d7 54 d7 5a d7 5f d7		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8eb6	71 d7
>8eb8	79 d7 82 d7 88 d7 8e d7		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8ec0	a1 d7 ad d7 00 00		        .word envs_sc, envs_wl, 0000
.8ec6					env_table_double:
>8ec6	b7 d7 bd d7 00 00		        .word envs_max_d, envs_max_ud, 0000
.8ecc					env_results_single:
>8ecc	ff 7f				        .word $7FFF     ; /COUNTED-STRING
>8ece	ff 00				        .word $00FF     ; /HOLD
>8ed0	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8ed2	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8ed4	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8ed6	ff 00				        .word $00FF     ; MAX-CHAR
>8ed8	ff 7f				        .word $7FFF     ; MAX-N
>8eda	ff ff				        .word $FFFF     ; MAX-U
>8edc	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8ede	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8ee0	09 00				        .word $0009     ; WORDLISTS
.8ee2					env_results_double:
>8ee2	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8ee6	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8eea					xt_equal:
.8eea	20 33 d9	jsr $d933	                jsr underflow_2
.8eed	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8eef	d5 02		cmp $02,x	                cmp 2,x
.8ef1	d0 0a		bne $8efd	                bne _false
.8ef3	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8ef5	d5 03		cmp $03,x	                cmp 3,x
.8ef7	d0 04		bne $8efd	                bne _false
.8ef9	a9 ff		lda #$ff	                lda #$ff
.8efb	80 02		bra $8eff	                bra _done
.8efd	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8eff	95 02		sta $02,x	_done:          sta 2,x
.8f01	95 03		sta $03,x	                sta 3,x
.8f03	e8		inx		                inx
.8f04	e8		inx		                inx
.8f05	60		rts		z_equal:        rts
.8f06					xt_blank:
.8f06	ca		dex		                dex
.8f07	ca		dex		                dex
.8f08	a9 20		lda #$20	                lda #AscSP
.8f0a	95 00		sta $00,x	                sta 0,x
.8f0c	74 01		stz $01,x	                stz 1,x
.8f0e	80 06		bra $8f16	                bra xt_fill     ; skip over code for ERASE
.8f10					xt_erase:
.8f10	ca		dex		                dex
.8f11	ca		dex		                dex
.8f12	74 00		stz $00,x	                stz 0,x
.8f14	74 01		stz $01,x	                stz 1,x
.8f16					xt_fill:
.8f16	20 38 d9	jsr $d938	                jsr underflow_3
.8f19	b5 04		lda $04,x	                lda 4,x         ; LSB
.8f1b	85 24		sta $24		                sta tmp1
.8f1d	b5 05		lda $05,x	                lda 5,x
.8f1f	85 25		sta $25		                sta tmp1+1
.8f21	b5 02		lda $02,x	                lda 2,x
.8f23	85 26		sta $26		                sta tmp2
.8f25	b5 03		lda $03,x	                lda 3,x
.8f27	85 27		sta $27		                sta tmp2+1
.8f29	b5 00		lda $00,x	                lda 0,x
.8f2b	a8		tay		                tay
.8f2c					_loop:
.8f2c	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8f2e	c5 25		cmp $25		                cmp tmp1+1
.8f30	90 21		bcc $8f53	                bcc _done               ; RAM_END < TMP1, so leave
.8f32	d0 06		bne $8f3a	                bne _check_counter      ; RAM_END is not smaller and not equal
.8f34	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8f36	c5 24		cmp $24		                cmp tmp1
.8f38	90 19		bcc $8f53	                bcc _done               ; RAM_END < TMP1, so leave
.8f3a					_check_counter:
.8f3a	a5 26		lda $26		                lda tmp2
.8f3c	05 27		ora $27		                ora tmp2+1
.8f3e	f0 13		beq $8f53	                beq _done
.8f40	98		tya		                tya
.8f41	92 24		sta ($24)	                sta (tmp1)
.8f43	a5 26		lda $26		                lda tmp2
.8f45	d0 02		bne $8f49	                bne +
.8f47	c6 27		dec $27		                dec tmp2+1
.8f49	c6 26		dec $26		+               dec tmp2
.8f4b	e6 24		inc $24		                inc tmp1
.8f4d	d0 dd		bne $8f2c	                bne _loop
.8f4f	e6 25		inc $25		                inc tmp1+1
.8f51	80 d9		bra $8f2c	                bra _loop
.8f53					_done:
.8f53	8a		txa		                txa
.8f54	18		clc		                clc
.8f55	69 06		adc #$06	                adc #6
.8f57	aa		tax		                tax
.8f58					z_blank:
.8f58					z_erase:
.8f58	60		rts		z_fill:         rts
.8f59					xt_execute:
.8f59	20 2e d9	jsr $d92e	                jsr underflow_1
.8f5c	20 60 8f	jsr $8f60	                jsr doexecute   ; do not combine to JMP (native coding)
.8f5f	60		rts		z_execute:      rts
.8f60					doexecute:
.8f60	b5 00		lda $00,x	                lda 0,x
.8f62	85 0e		sta $0e		                sta ip
.8f64	b5 01		lda $01,x	                lda 1,x
.8f66	85 0f		sta $0f		                sta ip+1
.8f68	e8		inx		                inx
.8f69	e8		inx		                inx
.8f6a	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f6d					xt_execute_parsing:
.8f6d	20 38 d9	jsr $d938	                jsr underflow_3
.8f70	20 7e 92	jsr $927e	                jsr xt_input_to_r       ; save normal input for later
.8f73	20 9f 96	jsr $969f	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f76	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f78	85 0a		sta $0a		                sta ciblen
.8f7a	b5 01		lda $01,x	                lda 1,x
.8f7c	85 0b		sta $0b		                sta ciblen+1
.8f7e	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f80	85 08		sta $08		                sta cib
.8f82	b5 03		lda $03,x	                lda 3,x
.8f84	85 09		sta $09		                sta cib+1
.8f86	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f88	64 0d		stz $0d		                stz toin+1
.8f8a	20 b2 a3	jsr $a3b2	                jsr xt_two_drop         ; 2DROP ( xt )
.8f8d	20 59 8f	jsr $8f59	                jsr xt_execute
.8f90	20 d4 9a	jsr $9ad4	                jsr xt_r_to_input
.8f93					z_execute_parsing:
.8f93	60		rts		                rts
.8f94					xt_exit:
.8f94	60		rts		                rts             ; keep before z_exit
.8f95					z_exit:
.8f95					xt_false:
.8f95	ca		dex		                dex
.8f96	ca		dex		                dex
.8f97	74 00		stz $00,x	                stz 0,x
.8f99	74 01		stz $01,x	                stz 1,x
.8f9b	60		rts		z_false:        rts
.8f9c					xt_fetch:
.8f9c	20 2e d9	jsr $d92e	                jsr underflow_1
.8f9f	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8fa1	a8		tay		                tay
.8fa2	f6 00		inc $00,x	                inc 0,x
.8fa4	d0 02		bne $8fa8	                bne +
.8fa6	f6 01		inc $01,x	                inc 1,x
.8fa8					+
.8fa8	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8faa	95 01		sta $01,x	                sta 1,x
.8fac	94 00		sty $00,x	                sty 0,x
.8fae	60		rts		z_fetch:        rts
.8faf					xt_find:
.8faf	20 2e d9	jsr $d92e	                jsr underflow_1
.8fb2	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8fb4	48		pha		                pha
.8fb5	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8fb7	48		pha		                pha
.8fb8	20 6b 89	jsr $896b	                jsr xt_count            ; ( caddr -- addr u )
.8fbb	20 f7 8f	jsr $8ff7	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8fbe	b5 00		lda $00,x	                lda 0,x
.8fc0	15 01		ora $01,x	                ora 1,x
.8fc2	d0 0b		bne $8fcf	                bne _found_word
.8fc4	20 95 8f	jsr $8f95	                jsr xt_false            ; ( 0 0 )
.8fc7	68		pla		                pla                     ; LSB of address
.8fc8	95 02		sta $02,x	                sta 2,x
.8fca	68		pla		                pla
.8fcb	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8fcd	80 27		bra $8ff6	                bra _done               ; ( addr 0 )
.8fcf					_found_word:
.8fcf	68		pla		                pla
.8fd0	68		pla		                pla
.8fd1	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( nt nt )
.8fd4	20 12 96	jsr $9612	                jsr xt_name_to_int      ; ( nt xt )
.8fd7	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( xt nt )
.8fda	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fdc	f6 00		inc $00,x	                inc 0,x
.8fde	d0 02		bne $8fe2	                bne +
.8fe0	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fe2					+
.8fe2	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fe4	29 04		and #$04	                and #IM
.8fe6	d0 08		bne $8ff0	                bne _immediate          ; bit set, we're immediate
.8fe8	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fea	95 00		sta $00,x	                sta 0,x
.8fec	95 01		sta $01,x	                sta 1,x
.8fee	80 06		bra $8ff6	                bra _done
.8ff0					_immediate:
.8ff0	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8ff2	95 00		sta $00,x	                sta 0,x
.8ff4	74 01		stz $01,x	                stz 1,x
.8ff6					_done:
.8ff6	60		rts		z_find:         rts
.8ff7					xt_find_name:
.8ff7	20 33 d9	jsr $d933	                jsr underflow_2
.8ffa	b5 00		lda $00,x	                lda 0,x
.8ffc	15 01		ora $01,x	                ora 1,x
.8ffe	d0 03		bne $9003	                bne _nonempty
.9000	4c 9c 90	jmp $909c	                jmp _fail_done
.9003					_nonempty:
.9003	64 28		stz $28		                stz tmp3                ; Start at the beginning
.9005					_wordlist_loop:
.9005	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9007	a5 28		lda $28		                lda tmp3
.9009	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.900b	d0 03		bne $9010	                bne _have_string
.900d	4c 9c 90	jmp $909c	                jmp _fail_done
.9010					_have_string:
.9010	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9011	69 1f		adc #$1f	                adc #search_order_offset
.9013	a8		tay		                tay
.9014	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.9016	0a		asl a		                asl                     ; Turn offset into cells offset.
.9017	18		clc		                clc
.9018	69 06		adc #$06	                adc #wordlists_offset
.901a	a8		tay		                tay
.901b	b1 1e		lda ($1e),y	                lda (up),y
.901d	85 24		sta $24		                sta tmp1
.901f	c8		iny		                iny
.9020	b1 1e		lda ($1e),y	                lda (up),y
.9022	85 25		sta $25		                sta tmp1+1
.9024	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9026	85 26		sta $26		                sta tmp2
.9028	b5 03		lda $03,x	                lda 3,x
.902a	85 27		sta $27		                sta tmp2+1
.902c					_loop:
.902c	b2 24		lda ($24)	                lda (tmp1)
.902e	d5 00		cmp $00,x	                cmp 0,x
.9030	d0 54		bne $9086	                bne _next_entry
.9032					_compare_string:
.9032	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9034	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9036	b0 07		bcs $903f	                bcs _compare_first
.9038	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.903a	90 03		bcc $903f	                bcc _compare_first
.903c	18		clc		                clc
.903d	69 20		adc #$20	                adc #$20
.903f					_compare_first:
.903f	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9041	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9043	d0 41		bne $9086	                bne _next_entry
.9045	b5 00		lda $00,x	                lda 0,x
.9047	3a		dec a		                dea
.9048	f0 2c		beq $9076	                beq _success
.904a	a5 24		lda $24		                lda tmp1
.904c	48		pha		                pha             ; Preserve tmp1 on the return stack.
.904d	18		clc		                clc
.904e	69 08		adc #$08	                adc #8
.9050	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9052	a5 25		lda $25		                lda tmp1+1
.9054	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9055	69 00		adc #$00	                adc #0          ; we only need the carry
.9057	85 25		sta $25		                sta tmp1+1
.9059	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.905b	88		dey		                dey
.905c					_string_loop:
.905c	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.905e	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9060	b0 07		bcs $9069	                bcs _check_char
.9062	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9064	90 03		bcc $9069	                bcc _check_char
.9066	18		clc		                clc
.9067	69 20		adc #$20	                adc #$20
.9069					_check_char:
.9069	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.906b	d0 13		bne $9080	                bne _next_entry_tmp1
.906d	88		dey		                dey
.906e	d0 ec		bne $905c	                bne _string_loop
.9070					_success_tmp1:
.9070	68		pla		                pla             ; Restore tmp1 from the return stack.
.9071	85 25		sta $25		                sta tmp1+1
.9073	68		pla		                pla
.9074	85 24		sta $24		                sta tmp1
.9076					_success:
.9076	a5 24		lda $24		                lda tmp1
.9078	95 02		sta $02,x	                sta 2,x
.907a	a5 25		lda $25		                lda tmp1+1
.907c	95 03		sta $03,x	                sta 3,x
.907e	80 20		bra $90a0	                bra _done
.9080					_next_entry_tmp1:
.9080	68		pla		                pla             ; Restore tmp1 from the return stack.
.9081	85 25		sta $25		                sta tmp1+1
.9083	68		pla		                pla
.9084	85 24		sta $24		                sta tmp1
.9086					_next_entry:
.9086	a0 02		ldy #$02	                ldy #2
.9088	b1 24		lda ($24),y	                lda (tmp1),y
.908a	48		pha		                pha
.908b	c8		iny		                iny
.908c	b1 24		lda ($24),y	                lda (tmp1),y
.908e	85 25		sta $25		                sta tmp1+1
.9090	68		pla		                pla
.9091	85 24		sta $24		                sta tmp1
.9093	05 25		ora $25		                ora tmp1+1
.9095	d0 95		bne $902c	                bne _loop
.9097	e6 28		inc $28		                inc tmp3
.9099	4c 05 90	jmp $9005	                jmp _wordlist_loop
.909c					_fail_done:
.909c	74 02		stz $02,x	                stz 2,x         ; failure flag
.909e	74 03		stz $03,x	                stz 3,x
.90a0					_done:
.90a0	e8		inx		                inx
.90a1	e8		inx		                inx
.90a2	60		rts		z_find_name:    rts
.90a3					xt_flush:
.90a3	20 c0 9e	jsr $9ec0	                jsr xt_save_buffers
.90a6	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.90a8	a9 00		lda #$00	                lda #0
.90aa	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.90ac					z_flush:
.90ac	60		rts		                rts
.90ad					xt_fm_slash_mod:
.90ad	20 38 d9	jsr $d938	                jsr underflow_3
.90b0	64 26		stz $26		                stz tmp2        ; default: n is positive
.90b2	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90b4	10 0e		bpl $90c4	                bpl _check_d
.90b6	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.90b8	20 54 96	jsr $9654	                jsr xt_negate   ; NEGATE
.90bb	20 72 a3	jsr $a372	                jsr xt_to_r     ; >R
.90be	20 5d 8b	jsr $8b5d	                jsr xt_dnegate  ; DNEGATE
.90c1	20 c3 9a	jsr $9ac3	                jsr xt_r_from   ; R>
.90c4					_check_d:
.90c4	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.90c6	10 0d		bpl $90d5	                bpl _multiply
.90c8	18		clc		                clc
.90c9	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.90cb	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.90cd	95 02		sta $02,x	                sta 2,x
.90cf	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90d1	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.90d3	95 03		sta $03,x	                sta 3,x
.90d5					_multiply:
.90d5	20 bc a5	jsr $a5bc	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90d8	a5 26		lda $26		                lda tmp2
.90da	f0 07		beq $90e3	                beq _done
.90dc	e8		inx		                inx             ; pretend that we SWAP
.90dd	e8		inx		                inx
.90de	20 54 96	jsr $9654	                jsr xt_negate
.90e1	ca		dex		                dex
.90e2	ca		dex		                dex
.90e3					_done:
.90e3	60		rts		z_fm_slash_mod: rts
.90e4					xt_forth:
.90e4	a0 1f		ldy #$1f	                ldy #search_order_offset
.90e6	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90e8	91 1e		sta ($1e),y	                sta (up),y
.90ea					z_forth:
.90ea	60		rts		                rts
.90eb					load_evaluate:
.90eb	a9 ff		lda #$ff	                lda #$FF
.90ed	85 24		sta $24		                sta tmp1
.90ef	80 11		bra $9102	                bra load_evaluate_start
.90f1					xt_evaluate:
.90f1	20 33 d9	jsr $d933	                jsr underflow_2
.90f4	64 24		stz $24		                stz tmp1
.90f6	b5 00		lda $00,x	                lda 0,x
.90f8	15 01		ora $01,x	                ora 1,x
.90fa	d0 06		bne $9102	                bne evaluate_got_work
.90fc	e8		inx		                inx
.90fd	e8		inx		                inx
.90fe	e8		inx		                inx
.90ff	e8		inx		                inx
.9100	80 42		bra $9144	                bra evaluate_done
.9102					load_evaluate_start:
.9102					evaluate_got_work:
.9102	a0 01		ldy #$01	                ldy #blk_offset+1
.9104	b1 1e		lda ($1e),y	                lda (up),y
.9106	48		pha		                pha
.9107	88		dey		                dey
.9108	b1 1e		lda ($1e),y	                lda (up),y
.910a	48		pha		                pha
.910b	a5 24		lda $24		                lda tmp1
.910d	d0 05		bne $9114	                bne _nozero
.910f	91 1e		sta ($1e),y	                sta (up),y
.9111	c8		iny		                iny
.9112	91 1e		sta ($1e),y	                sta (up),y
.9114					_nozero:
.9114	20 7e 92	jsr $927e	                jsr xt_input_to_r
.9117	a9 ff		lda #$ff	                lda #$ff
.9119	85 06		sta $06		                sta insrc
.911b	85 07		sta $07		                sta insrc+1
.911d	64 0c		stz $0c		                stz toin
.911f	64 0d		stz $0d		                stz toin+1
.9121	b5 00		lda $00,x	                lda 0,x
.9123	85 0a		sta $0a		                sta ciblen
.9125	b5 01		lda $01,x	                lda 1,x
.9127	85 0b		sta $0b		                sta ciblen+1
.9129	b5 02		lda $02,x	                lda 2,x
.912b	85 08		sta $08		                sta cib
.912d	b5 03		lda $03,x	                lda 3,x
.912f	85 09		sta $09		                sta cib+1
.9131	e8		inx		                inx             ; A clean stack is a clean mind
.9132	e8		inx		                inx
.9133	e8		inx		                inx
.9134	e8		inx		                inx
.9135	20 89 d8	jsr $d889	                jsr interpret   ; ( -- )
.9138	20 d4 9a	jsr $9ad4	                jsr xt_r_to_input
.913b	a0 00		ldy #$00	                ldy #blk_offset
.913d	68		pla		                pla
.913e	91 1e		sta ($1e),y	                sta (up),y
.9140	c8		iny		                iny
.9141	68		pla		                pla
.9142	91 1e		sta ($1e),y	                sta (up),y
.9144					evaluate_done:
.9144	60		rts		z_evaluate:     rts
.9145					xt_get_current:
.9145	ca		dex		                dex
.9146	ca		dex		                dex
.9147	a0 04		ldy #$04	                ldy #current_offset
.9149	b1 1e		lda ($1e),y	                lda (up),y
.914b	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.914d	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.914f	60		rts		z_get_current:  rts
.9150					xt_get_order:
.9150	a0 1e		ldy #$1e	                ldy #num_order_offset
.9152	b1 1e		lda ($1e),y	                lda (up),y
.9154	85 24		sta $24		                sta tmp1
.9156	f0 16		beq $916e	                beq _done       ; If zero, there are no wordlists.
.9158					_loop:
.9158	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.915a	a9 1f		lda #$1f	                lda #search_order_offset
.915c	18		clc		                clc
.915d	65 24		adc $24		                adc tmp1
.915f	a8		tay		                tay
.9160	ca		dex		                dex
.9161	ca		dex		                dex
.9162	b1 1e		lda ($1e),y	                lda (up),y
.9164	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.9166	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.9168	a9 00		lda #$00	                lda #0
.916a	c5 24		cmp $24		                cmp tmp1
.916c	d0 ea		bne $9158	                bne _loop
.916e					_done:
.916e	ca		dex		                dex
.916f	ca		dex		                dex
.9170	a0 1e		ldy #$1e	                ldy #num_order_offset
.9172	b1 1e		lda ($1e),y	                lda (up),y
.9174	95 00		sta $00,x	                sta 0,x
.9176	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.9178	60		rts		z_get_order:    rts
.9179					xt_greater_than:
.9179	20 33 d9	jsr $d933	                jsr underflow_2
.917c	a0 00		ldy #$00	                ldy #0          ; default false
.917e	20 48 d8	jsr $d848	                jsr compare_16bit
.9181	f0 03		beq $9186	                beq _false
.9183	10 01		bpl $9186	                bpl _false
.9185	88		dey		                dey
.9186					_false:
.9186	98		tya		                tya
.9187	e8		inx		                inx
.9188	e8		inx		                inx
.9189	95 00		sta $00,x	                sta 0,x
.918b	95 01		sta $01,x	                sta 1,x
.918d	60		rts		z_greater_than: rts
.918e					xt_here:
.918e					xt_asm_arrow:
.918e	ca		dex		                dex
.918f	ca		dex		                dex
.9190	a5 00		lda $00		                lda cp
.9192	95 00		sta $00,x	                sta 0,x
.9194	a5 01		lda $01		                lda cp+1
.9196	95 01		sta $01,x	                sta 1,x
.9198					z_asm_arrow:
.9198	60		rts		z_here:         rts
.9199					xt_hex:
.9199	a9 10		lda #$10	                lda #16
.919b	85 18		sta $18		                sta base
.919d	64 19		stz $19		                stz base+1              ; paranoid
.919f	60		rts		z_hex:          rts
.91a0					xt_hexstore:
.91a0	20 38 d9	jsr $d938	                jsr underflow_3
.91a3	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; Save copy of original address
.91a6	20 a4 a4	jsr $a4a4	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.91a9					_loop:
.91a9	b5 00		lda $00,x	                lda 0,x
.91ab	15 01		ora $01,x	                ora 1,x
.91ad	f0 36		beq $91e5	                beq _done
.91af	20 68 86	jsr $8668	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.91b2	20 a4 a4	jsr $a4a4	                jsr xt_two_to_r
.91b5	20 aa a7	jsr $a7aa	                jsr xt_zero
.91b8	20 aa a7	jsr $a7aa	                jsr xt_zero
.91bb	20 2a a4	jsr $a42a	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.91be	20 bf a2	jsr $a2bf	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.91c1	b5 00		lda $00,x	                lda 0,x
.91c3	15 01		ora $01,x	                ora 1,x
.91c5	d0 17		bne $91de	                bne _have_chars_left
.91c7	20 b2 a3	jsr $a3b2	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.91ca	20 9c 8a	jsr $8a9c	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.91cd	20 ae 9a	jsr $9aae	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.91d0	20 31 86	jsr $8631	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.91d3	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; R>
.91d6	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+
.91d9	20 72 a3	jsr $a372	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91dc	80 cb		bra $91a9	                bra _loop
.91de					_have_chars_left:
.91de	8a		txa		                txa
.91df	18		clc		                clc
.91e0	69 08		adc #$08	                adc #8
.91e2	aa		tax		                tax
.91e3	80 c4		bra $91a9	                bra _loop
.91e5					_done:
.91e5	e8		inx		                inx
.91e6	e8		inx		                inx
.91e7	e8		inx		                inx
.91e8	e8		inx		                inx                     ; 2DROP
.91e9	20 2a a4	jsr $a42a	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91ec	20 b0 a1	jsr $a1b0	                jsr xt_swap
.91ef	20 81 95	jsr $9581	                jsr xt_minus            ; ( n )
.91f2	60		rts		z_hexstore:     rts
.91f3					xt_hold:
.91f3	20 2e d9	jsr $d92e	                jsr underflow_1
.91f6	a5 34		lda $34		                lda tohold
.91f8	d0 02		bne $91fc	                bne +
.91fa	c6 35		dec $35		                dec tohold+1
.91fc					+
.91fc	c6 34		dec $34		                dec tohold
.91fe	b5 00		lda $00,x	                lda 0,x
.9200	92 34		sta ($34)	                sta (tohold)
.9202	e8		inx		                inx
.9203	e8		inx		                inx
.9204	60		rts		z_hold:         rts
.9205					xt_i:
.9205	ca		dex		                dex
.9206	ca		dex		                dex
.9207	86 2a		stx $2a		                stx tmpdsp
.9209	ba		tsx		                tsx
.920a	38		sec		                sec
.920b	bd 01 01	lda $0101,x	                lda $0101,x     ; LSB
.920e	fd 03 01	sbc $0103,x	                sbc $0103,x
.9211	a8		tay		                tay
.9212	bd 02 01	lda $0102,x	                lda $0102,x     ; MSB
.9215	fd 04 01	sbc $0104,x	                sbc $0104,x
.9218	a6 2a		ldx $2a		                ldx tmpdsp
.921a	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.921c	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.921e	60		rts		z_i:            rts
.921f					xt_if:
.921f	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.9221	a9 30		lda #$30	                lda #<zero_branch_runtime
.9223	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.9226	20 8e 91	jsr $918e	                jsr xt_here
.9229	20 aa a7	jsr $a7aa	                jsr xt_zero
.922c	20 8a 87	jsr $878a	                jsr xt_comma
.922f	60		rts		z_if:           rts
.9230					zero_branch_runtime:
.9230	68		pla		                pla
.9231	85 22		sta $22		                sta tmpbranch
.9233	68		pla		                pla
.9234	85 23		sta $23		                sta tmpbranch+1
.9236	b5 00		lda $00,x	                lda 0,x
.9238	15 01		ora $01,x	                ora 1,x
.923a	f0 0f		beq $924b	                beq _zero
.923c	a5 22		lda $22		                lda tmpbranch   ; LSB
.923e	18		clc		                clc
.923f	69 02		adc #$02	                adc #2
.9241	85 24		sta $24		                sta tmp1
.9243	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.9245	69 00		adc #$00	                adc #0          ; For carry
.9247	85 25		sta $25		                sta tmp1+1
.9249	80 13		bra $925e	                bra _done
.924b					_zero:
.924b	a0 01		ldy #$01	                ldy #1
.924d	b1 22		lda ($22),y	                lda (tmpbranch),y
.924f	85 24		sta $24		                sta tmp1
.9251	c8		iny		                iny
.9252	b1 22		lda ($22),y	                lda (tmpbranch),y
.9254	85 25		sta $25		                sta tmp1+1
.9256	a5 24		lda $24		                lda tmp1
.9258	d0 02		bne $925c	                bne +
.925a	c6 25		dec $25		                dec tmp1+1
.925c					+
.925c	c6 24		dec $24		                dec tmp1
.925e					_done:
.925e	a5 25		lda $25		                lda tmp1+1
.9260	48		pha		                pha             ; MSB first
.9261	a5 24		lda $24		                lda tmp1
.9263	48		pha		                pha
.9264	e8		inx		                inx
.9265	e8		inx		                inx
.9266	60		rts		                rts
.9267					xt_immediate:
.9267	20 63 d8	jsr $d863	                jsr current_to_dp
.926a	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.926c	b1 02		lda ($02),y	                lda (dp),y
.926e	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9270	91 02		sta ($02),y	                sta (dp),y
.9272	60		rts		z_immediate:    rts
.9273					xt_input:
.9273	ca		dex		                dex
.9274	ca		dex		                dex
.9275	a9 12		lda #$12	                lda #<input
.9277	95 00		sta $00,x	                sta 0,x
.9279	a9 00		lda #$00	                lda #>input
.927b	95 01		sta $01,x	                sta 1,x
.927d	60		rts		z_input:        rts
.927e					xt_input_to_r:
.927e	68		pla		                pla
.927f	85 24		sta $24		                sta tmp1
.9281	68		pla		                pla
.9282	85 25		sta $25		                sta tmp1+1
.9284	a0 07		ldy #$07	                ldy #7
.9286					_loop:
.9286	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.9289	48		pha		                pha
.928a	88		dey		                dey
.928b	10 f9		bpl $9286	                bpl _loop
.928d	a5 25		lda $25		                lda tmp1+1
.928f	48		pha		                pha
.9290	a5 24		lda $24		                lda tmp1
.9292	48		pha		                pha
.9293	60		rts		z_input_to_r: 	rts
.9294					xt_int_to_name:
.9294	20 2e d9	jsr $d92e	                jsr underflow_1
.9297	ca		dex		                dex
.9298	ca		dex		                dex
.9299	74 00		stz $00,x	                stz 0,x
.929b	74 01		stz $01,x	                stz 1,x
.929d					_wordlist_loop:
.929d	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.929f	0a		asl a		                asl                     ; Turn offset into cells offset.
.92a0	18		clc		                clc
.92a1	69 06		adc #$06	                adc #wordlists_offset
.92a3	a8		tay		                tay
.92a4	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.92a6	85 26		sta $26		                sta tmp2                ; into tmp2
.92a8	c8		iny		                iny
.92a9	b1 1e		lda ($1e),y	                lda (up),y
.92ab	85 27		sta $27		                sta tmp2+1
.92ad	a5 26		lda $26		                lda tmp2
.92af	05 27		ora $27		                ora tmp2+1
.92b1	f0 38		beq $92eb	                beq _next_wordlist
.92b3	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.92b5	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.92b7	b5 03		lda $03,x	                lda 3,x
.92b9	85 29		sta $29		                sta tmp3+1
.92bb					_loop:
.92bb	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.92bd	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.92bf	c5 28		cmp $28		                cmp tmp3
.92c1	d0 07		bne $92ca	                bne _no_match
.92c3	c8		iny		                iny
.92c4	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.92c6	c5 29		cmp $29		                cmp tmp3+1
.92c8	f0 32		beq $92fc	                beq _match
.92ca					_no_match:
.92ca	18		clc		                clc
.92cb	a5 26		lda $26		                lda tmp2
.92cd	69 02		adc #$02	                adc #2
.92cf	85 26		sta $26		                sta tmp2
.92d1	a5 27		lda $27		                lda tmp2+1
.92d3	69 00		adc #$00	                adc #0          ; only care about carry
.92d5	85 27		sta $27		                sta tmp2+1
.92d7	a0 00		ldy #$00	                ldy #0
.92d9	b1 26		lda ($26),y	                lda (tmp2),y
.92db	48		pha		                pha
.92dc	c8		iny		                iny
.92dd	11 26		ora ($26),y	                ora (tmp2),y
.92df	f0 09		beq $92ea	                beq _zero
.92e1	b1 26		lda ($26),y	                lda (tmp2),y
.92e3	85 27		sta $27		                sta tmp2+1
.92e5	68		pla		                pla
.92e6	85 26		sta $26		                sta tmp2
.92e8	80 d1		bra $92bb	                bra _loop
.92ea					_zero:
.92ea	68		pla		                pla             ; Leftover from above loop
.92eb					_next_wordlist:
.92eb	b5 00		lda $00,x	                lda 0,x
.92ed	1a		inc a		                ina
.92ee	95 00		sta $00,x	                sta 0,x
.92f0	c9 0c		cmp #$0c	                cmp #max_wordlists
.92f2	d0 a9		bne $929d	                bne _wordlist_loop
.92f4	e8		inx		                inx
.92f5	e8		inx		                inx
.92f6	74 00		stz $00,x	                stz 0,x
.92f8	74 01		stz $01,x	                stz 1,x
.92fa	80 0a		bra $9306	                bra z_int_to_name
.92fc					_match:
.92fc	e8		inx		                inx
.92fd	e8		inx		                inx
.92fe	a5 26		lda $26		                lda tmp2
.9300	95 00		sta $00,x	                sta 0,x
.9302	a5 27		lda $27		                lda tmp2+1
.9304	95 01		sta $01,x	                sta 1,x
.9306	60		rts		z_int_to_name:  rts
.9307					xt_invert:
.9307	20 2e d9	jsr $d92e	                jsr underflow_1
.930a	a9 ff		lda #$ff	                lda #$FF
.930c	55 00		eor $00,x	                eor 0,x         ; LSB
.930e	95 00		sta $00,x	                sta 0,x
.9310	a9 ff		lda #$ff	                lda #$FF
.9312	55 01		eor $01,x	                eor 1,x         ; MSB
.9314	95 01		sta $01,x	                sta 1,x
.9316	60		rts		z_invert:       rts
.9317					xt_is:
.9317	a5 16		lda $16		                lda state
.9319	05 17		ora $17		                ora state+1
.931b	f0 0c		beq $9329	                beq _interpreting
.931d					_compiling:
.931d	20 ba 85	jsr $85ba	                jsr xt_bracket_tick
.9320	a0 8b		ldy #$8b	                ldy #>xt_defer_store
.9322	a9 02		lda #$02	                lda #<xt_defer_store
.9324	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.9327	80 06		bra $932f	                bra _done
.9329					_interpreting:
.9329	20 13 a2	jsr $a213	                jsr xt_tick
.932c	20 02 8b	jsr $8b02	                jsr xt_defer_store
.932f					_done:
.932f	60		rts		z_is:           rts
.9330					xt_j:
.9330	ca		dex		                dex
.9331	ca		dex		                dex
.9332	86 2a		stx $2a		                stx tmpdsp
.9334	ba		tsx		                tsx
.9335	38		sec		                sec
.9336	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.9339	fd 09 01	sbc $0109,x	                sbc $0109,x
.933c	a8		tay		                tay
.933d	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.9340	fd 0a 01	sbc $010a,x	                sbc $010A,x
.9343	a6 2a		ldx $2a		                ldx tmpdsp
.9345	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.9347	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.9349	60		rts		z_j:            rts
.934a					xt_key:
.934a	20 54 93	jsr $9354	                jsr key_a               ; returns char in A
.934d	ca		dex		                dex
.934e	ca		dex		                dex
.934f	95 00		sta $00,x	                sta 0,x
.9351	74 01		stz $01,x	                stz 1,x
.9353	60		rts		z_key:          rts
.9354					key_a:
.9354	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.9357					xt_latestnt:
.9357	ca		dex		                dex
.9358	ca		dex		                dex
.9359	20 63 d8	jsr $d863	                jsr current_to_dp
.935c	a5 02		lda $02		                lda dp
.935e	95 00		sta $00,x	                sta 0,x
.9360	a5 03		lda $03		                lda dp+1
.9362	95 01		sta $01,x	                sta 1,x
.9364	60		rts		z_latestnt:     rts
.9365					xt_latestxt:
.9365	20 57 93	jsr $9357	                jsr xt_latestnt         ; ( nt )
.9368	20 12 96	jsr $9612	                jsr xt_name_to_int      ; ( xt )
.936b	60		rts		z_latestxt:     rts
.936c					xt_leave:
.936c	68		pla		                pla
.936d	68		pla		                pla
.936e	68		pla		                pla
.936f	68		pla		                pla
.9370	60		rts		                rts             ; this must be compiled, so keep before z_leave
.9371					z_leave:
.9371					xt_left_bracket:
.9371	64 16		stz $16		                stz state
.9373	64 17		stz $17		                stz state+1
.9375	60		rts		z_left_bracket: rts
.9376					xt_less_number_sign:
.9376	20 d2 98	jsr $98d2	                jsr xt_pad      ; ( addr )
.9379	b5 00		lda $00,x	                lda 0,x
.937b	85 34		sta $34		                sta tohold
.937d	b5 01		lda $01,x	                lda 1,x
.937f	85 35		sta $35		                sta tohold+1
.9381	e8		inx		                inx
.9382	e8		inx		                inx
.9383					z_less_number_sign:
.9383	60		rts		                rts
.9384					xt_less_than:
.9384	20 33 d9	jsr $d933	                jsr underflow_2
.9387	a0 00		ldy #$00	                ldy #0          ; default false
.9389	20 48 d8	jsr $d848	                jsr compare_16bit
.938c	f0 03		beq $9391	                beq _false
.938e	30 01		bmi $9391	                bmi _false
.9390	88		dey		                dey
.9391					_false:
.9391	98		tya		                tya
.9392	e8		inx		                inx
.9393	e8		inx		                inx
.9394	95 00		sta $00,x	                sta 0,x
.9396	95 01		sta $01,x	                sta 1,x
.9398	60		rts		z_less_than:    rts
.9399					xt_list:
.9399	20 2e d9	jsr $d92e	                jsr underflow_1
.939c	20 db 9e	jsr $9edb	                jsr xt_scr
.939f	20 8f a1	jsr $a18f	                jsr xt_store
.93a2	20 48 a8	jsr $a848	                jsr xt_editor_l
.93a5	60		rts		z_list:         rts
.93a6					xt_literal:
.93a6	20 2e d9	jsr $d92e	                jsr underflow_1
.93a9	a0 93		ldy #$93	                ldy #>literal_runtime
.93ab	a9 b4		lda #$b4	                lda #<literal_runtime
.93ad	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.93b0	20 8a 87	jsr $878a	                jsr xt_comma
.93b3	60		rts		z_literal:      rts
.93b4					literal_runtime:
.93b4	ca		dex		                dex
.93b5	ca		dex		                dex
.93b6	68		pla		                pla             ; LSB
.93b7	85 24		sta $24		                sta tmp1
.93b9	68		pla		                pla             ; MSB
.93ba	85 25		sta $25		                sta tmp1+1
.93bc	a0 01		ldy #$01	                ldy #1
.93be	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.93c0	95 00		sta $00,x	                sta 0,x
.93c2	c8		iny		                iny
.93c3	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.93c5	95 01		sta $01,x	                sta 1,x
.93c7	98		tya		                tya
.93c8	18		clc		                clc
.93c9	65 24		adc $24		                adc tmp1
.93cb	a8		tay		                tay
.93cc	a5 25		lda $25		                lda tmp1+1
.93ce	69 00		adc #$00	                adc #0
.93d0	48		pha		                pha
.93d1	5a		phy		                phy
.93d2	60		rts		                rts
.93d3					byte_runtime:
.93d3	ca		dex		                dex             ; make space on the stack
.93d4	ca		dex		                dex
.93d5	68		pla		                pla             ; LSB
.93d6	7a		ply		                ply             ; MSB
.93d7	1a		inc a		                ina             ; inc return addr and store in tmp1
.93d8	d0 01		bne $93db	                bne +
.93da	c8		iny		                iny
.93db	5a		phy		+               phy
.93dc	48		pha		                pha
.93dd	85 24		sta $24		                sta tmp1
.93df	84 25		sty $25		                sty tmp1+1
.93e1	b2 24		lda ($24)	                lda (tmp1)      ; LSB
.93e3	95 00		sta $00,x	                sta 0,x
.93e5	74 01		stz $01,x	                stz 1,x         ; MSB is zero
.93e7	60		rts		                rts
.93e8					xt_load:
.93e8	20 2e d9	jsr $d92e	                jsr underflow_1
.93eb	a0 01		ldy #$01	                ldy #blk_offset+1
.93ed	b1 1e		lda ($1e),y	                lda (up),y
.93ef	48		pha		                pha
.93f0	88		dey		                dey
.93f1	b1 1e		lda ($1e),y	                lda (up),y
.93f3	48		pha		                pha
.93f4	b5 00		lda $00,x	                lda 0,x
.93f6	91 1e		sta ($1e),y	                sta (up),y
.93f8	c8		iny		                iny
.93f9	b5 01		lda $01,x	                lda 1,x
.93fb	91 1e		sta ($1e),y	                sta (up),y
.93fd	20 dd 83	jsr $83dd	                jsr xt_block
.9400	ca		dex		                dex
.9401	ca		dex		                dex
.9402	a9 04		lda #$04	                lda #4
.9404	95 01		sta $01,x	                sta 1,x
.9406	74 00		stz $00,x	                stz 0,x
.9408	20 eb 90	jsr $90eb	                jsr load_evaluate
.940b	a0 00		ldy #$00	                ldy #blk_offset
.940d	68		pla		                pla
.940e	91 1e		sta ($1e),y	                sta (up),y
.9410	c8		iny		                iny
.9411	68		pla		                pla
.9412	91 1e		sta ($1e),y	                sta (up),y
.9414	88		dey		                dey
.9415	11 1e		ora ($1e),y	                ora (up),y
.9417	f0 12		beq $942b	                beq _done
.9419	ca		dex		                dex
.941a	ca		dex		                dex
.941b	a0 00		ldy #$00	                ldy #blk_offset
.941d	b1 1e		lda ($1e),y	                lda (up),y
.941f	95 00		sta $00,x	                sta 0,x
.9421	c8		iny		                iny
.9422	b1 1e		lda ($1e),y	                lda (up),y
.9424	95 01		sta $01,x	                sta 1,x
.9426	20 dd 83	jsr $83dd	                jsr xt_block
.9429	e8		inx		                inx
.942a	e8		inx		                inx
.942b					_done:
.942b	60		rts		z_load:         rts
.942c					xt_loop:
.942c	a0 98		ldy #$98	                ldy #>xt_one
.942e	a9 39		lda #$39	                lda #<xt_one
.9430	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine     ; drop through to +LOOP
.9433					xt_plus_loop:
.9433	a0 11		ldy #$11	                ldy #plus_loop_runtime_end-plus_loop_runtime
.9435	5a		phy		                phy             ; save counter to adjust CP
.9436					-
.9436	b9 9a 94	lda $949a,y	                lda plus_loop_runtime,y
.9439	91 00		sta ($00),y	                sta (cp),y
.943b	88		dey		                dey
.943c	10 f8		bpl $9436	                bpl -
.943e	68		pla		                pla
.943f	18		clc		                clc
.9440	65 00		adc $00		                adc cp
.9442	85 00		sta $00		                sta cp
.9444	a5 01		lda $01		                lda cp+1
.9446	69 00		adc #$00	                adc #0          ; only need carry
.9448	85 01		sta $01		                sta cp+1
.944a	20 8a 87	jsr $878a	                jsr xt_comma
.944d	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.944f	a0 06		ldy #$06	                ldy #6
.9451					-
.9451	91 00		sta ($00),y	                sta (cp),y
.9453	88		dey		                dey
.9454	10 fb		bpl $9451	                bpl -
.9456	a9 06		lda #$06	                lda #6
.9458	18		clc		                clc
.9459	65 00		adc $00		                adc cp
.945b	85 00		sta $00		                sta cp
.945d	a5 01		lda $01		                lda cp+1
.945f	69 00		adc #$00	                adc #0                  ; only need carry
.9461	85 01		sta $01		                sta cp+1
.9463	b5 00		lda $00,x	                lda 0,x
.9465	85 24		sta $24		                sta tmp1
.9467	b5 01		lda $01,x	                lda 1,x
.9469	85 25		sta $25		                sta tmp1+1
.946b	e8		inx		                inx
.946c	e8		inx		                inx
.946d	a5 00		lda $00		                lda cp
.946f	38		sec		                sec
.9470	e9 01		sbc #$01	                sbc #1
.9472	85 26		sta $26		                sta tmp2
.9474	a5 01		lda $01		                lda cp+1
.9476	e9 00		sbc #$00	                sbc #0
.9478	85 27		sta $27		                sta tmp2+1
.947a	a0 00		ldy #$00	                ldy #0
.947c	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.947e	91 24		sta ($24),y	                sta (tmp1),y
.9480	c8		iny		                iny
.9481	a5 27		lda $27		                lda tmp2+1      ; MSB
.9483	91 24		sta ($24),y	                sta (tmp1),y
.9485	c8		iny		                iny
.9486	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9488	91 24		sta ($24),y	                sta (tmp1),y
.948a	c8		iny		                iny
.948b	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.948d	91 24		sta ($24),y	                sta (tmp1),y
.948f	c8		iny		                iny
.9490	a5 26		lda $26		                lda tmp2        ; LSB
.9492	91 24		sta ($24),y	                sta (tmp1),y
.9494	c8		iny		                iny
.9495	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9497	91 24		sta ($24),y	                sta (tmp1),y
.9499					z_loop:
.9499	60		rts		z_plus_loop:    rts
.949a					plus_loop_runtime:
.949a	18		clc		                clc
.949b	68		pla		                pla             ; LSB of index
.949c	75 00		adc $00,x	                adc 0,x         ; LSB of step
.949e	a8		tay		                tay             ; temporary storage of LSB
.949f	b8		clv		                clv
.94a0	68		pla		                pla             ; MSB of index
.94a1	75 01		adc $01,x	                adc 1,x         ; MSB of step
.94a3	48		pha		                pha             ; put MSB of index back on stack
.94a4	98		tya		                tya             ; put LSB of index back on stack
.94a5	48		pha		                pha
.94a6	e8		inx		                inx             ; dump step from TOS
.94a7	e8		inx		                inx
.94a8	70 03		bvs $94ad	                bvs _hack+3     ; skip over JMP instruction
.94aa					_hack:
>94aa	4c				                .byte $4C
.94ab					plus_loop_runtime_end:
.94ab					xt_lshift:
.94ab	20 33 d9	jsr $d933	                jsr underflow_2
.94ae	b5 00		lda $00,x	                lda 0,x
.94b0	29 0f		and #$0f	                and #%00001111
.94b2	f0 08		beq $94bc	                beq _done
.94b4	a8		tay		                tay
.94b5					_loop:
.94b5	16 02		asl $02,x	                asl 2,x
.94b7	36 03		rol $03,x	                rol 3,x
.94b9	88		dey		                dey
.94ba	d0 f9		bne $94b5	                bne _loop
.94bc					_done:
.94bc	e8		inx		                inx
.94bd	e8		inx		                inx
.94be	60		rts		z_lshift:       rts
.94bf					xt_m_star:
.94bf	20 33 d9	jsr $d933	                jsr underflow_2
.94c2	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.94c4	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.94c6	48		pha		                pha
.94c7	20 33 81	jsr $8133	                jsr xt_abs
.94ca	20 b0 a1	jsr $a1b0	                jsr xt_swap
.94cd	20 33 81	jsr $8133	                jsr xt_abs
.94d0	20 fe a5	jsr $a5fe	                jsr xt_um_star          ; ( d )
.94d3	68		pla		                pla
.94d4	10 03		bpl $94d9	                bpl _done
.94d6	20 5d 8b	jsr $8b5d	                jsr xt_dnegate
.94d9					_done:
.94d9	60		rts		z_m_star:       rts
.94da					xt_marker:
.94da	20 63 d8	jsr $d863	                jsr current_to_dp
.94dd	a5 02		lda $02		                lda dp
.94df	48		pha		                pha
.94e0	a5 03		lda $03		                lda dp+1
.94e2	48		pha		                pha
.94e3	a5 00		lda $00		                lda cp
.94e5	48		pha		                pha
.94e6	a5 01		lda $01		                lda cp+1
.94e8	48		pha		                pha
.94e9	20 85 89	jsr $8985	                jsr xt_create
.94ec	a5 00		lda $00		                lda cp          ; LSB
.94ee	38		sec		                sec
.94ef	e9 02		sbc #$02	                sbc #2
.94f1	85 00		sta $00		                sta cp
.94f3	a5 01		lda $01		                lda cp+1        ; MSB
.94f5	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94f7	85 01		sta $01		                sta cp+1
.94f9	a0 95		ldy #$95	                ldy #>marker_runtime
.94fb	a9 18		lda #$18	                lda #<marker_runtime
.94fd	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.9500	7a		ply		                ply                     ; MSB
.9501	68		pla		                pla                     ; LSB
.9502	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.9505	7a		ply		                ply                     ; MSB
.9506	68		pla		                pla                     ; LSB
.9507	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.950a	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.950c					_marker_loop:
.950c	b1 1e		lda ($1e),y	                lda (up),y
.950e	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.9511	c8		iny		                iny
.9512	98		tya		                tya
.9513	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.9515	d0 f5		bne $950c	                bne _marker_loop
.9517	60		rts		z_marker:       rts
.9518					marker_runtime:
.9518	68		pla		                pla
.9519	85 24		sta $24		                sta tmp1        ; LSB of address
.951b	68		pla		                pla
.951c	85 25		sta $25		                sta tmp1+1      ; MSB of address
.951e	e6 24		inc $24		                inc tmp1
.9520	d0 02		bne $9524	                bne +
.9522	e6 25		inc $25		                inc tmp1+1
.9524					+
.9524	a0 00		ldy #$00	                ldy #0
.9526	b1 24		lda ($24),y	                lda (tmp1),y
.9528	85 00		sta $00		                sta cp
.952a	c8		iny		                iny
.952b	b1 24		lda ($24),y	                lda (tmp1),y
.952d	85 01		sta $01		                sta cp+1
.952f	c8		iny		                iny
.9530	b1 24		lda ($24),y	                lda (tmp1),y
.9532	85 02		sta $02		                sta dp
.9534	c8		iny		                iny
.9535	b1 24		lda ($24),y	                lda (tmp1),y
.9537	85 03		sta $03		                sta dp+1
.9539	a0 04		ldy #$04	                ldy #4
.953b					_marker_restore_loop:
.953b	b1 24		lda ($24),y	                lda (tmp1), y
.953d	91 1e		sta ($1e),y	                sta (up), y
.953f	c8		iny		                iny
.9540	98		tya		                tya
.9541	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.9543	d0 f6		bne $953b	                bne _marker_restore_loop
.9545	20 76 d8	jsr $d876	                jsr dp_to_current       ; Move the CURRENT DP back.
.9548	60		rts		                rts
.9549					xt_max:
.9549	20 33 d9	jsr $d933	                jsr underflow_2
.954c	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.954e	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.9550	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9552	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9554	50 02		bvc $9558	                bvc _no_overflow
.9556	49 80		eor #$80	                eor #$80        ; complement negative flag
.9558					_no_overflow:
.9558	30 08		bmi $9562	                bmi _keep_nos
.955a	b5 00		lda $00,x	                lda 0,x
.955c	95 02		sta $02,x	                sta 2,x
.955e	b5 01		lda $01,x	                lda 1,x
.9560	95 03		sta $03,x	                sta 3,x
.9562					_keep_nos:
.9562	e8		inx		                inx
.9563	e8		inx		                inx
.9564	60		rts		z_max:          rts
.9565					xt_min:
.9565	20 33 d9	jsr $d933	                jsr underflow_2
.9568	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.956a	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.956c	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.956e	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9570	50 02		bvc $9574	                bvc _no_overflow
.9572	49 80		eor #$80	                eor #$80
.9574					_no_overflow:
.9574	10 08		bpl $957e	                bpl _keep_nos
.9576	b5 00		lda $00,x	                lda 0,x
.9578	95 02		sta $02,x	                sta 2,x
.957a	b5 01		lda $01,x	                lda 1,x
.957c	95 03		sta $03,x	                sta 3,x
.957e					_keep_nos:
.957e	e8		inx		                inx
.957f	e8		inx		                inx
.9580	60		rts		z_min:          rts
.9581					xt_minus:
.9581	20 33 d9	jsr $d933	                jsr underflow_2
.9584	38		sec		                sec
.9585	b5 02		lda $02,x	                lda 2,x         ; LSB
.9587	f5 00		sbc $00,x	                sbc 0,x
.9589	95 02		sta $02,x	                sta 2,x
.958b	b5 03		lda $03,x	                lda 3,x         ; MSB
.958d	f5 01		sbc $01,x	                sbc 1,x
.958f	95 03		sta $03,x	                sta 3,x
.9591	e8		inx		                inx
.9592	e8		inx		                inx
.9593	60		rts		z_minus:        rts
.9594					xt_minus_leading:
.9594	20 33 d9	jsr $d933	                jsr underflow_2
.9597					_loop:
.9597	b5 00		lda $00,x	                lda 0,x
.9599	15 01		ora $01,x	                ora 1,x
.959b	f0 0f		beq $95ac	                beq _done
.959d	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.959f	20 21 d9	jsr $d921	                jsr is_whitespace
.95a2	90 08		bcc $95ac	                bcc _done
.95a4	20 39 98	jsr $9839	                jsr xt_one              ; ( addr u 1 )
.95a7	20 1b a0	jsr $a01b	                jsr xt_slash_string     ; ( addr+ u-1 )
.95aa	80 eb		bra $9597	                bra _loop
.95ac					_done:
.95ac					z_minus_leading:
.95ac	60		rts		                rts
.95ad					xt_minus_trailing:
.95ad	20 33 d9	jsr $d933	                jsr underflow_2
.95b0	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.95b2	15 01		ora $01,x	                ora 1,x         ; MSB of n
.95b4	f0 33		beq $95e9	                beq _done
.95b6	18		clc		                clc
.95b7	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.95b9	75 00		adc $00,x	                adc 0,x
.95bb	85 24		sta $24		                sta tmp1
.95bd	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.95bf	75 01		adc $01,x	                adc 1,x
.95c1	85 25		sta $25		                sta tmp1+1
.95c3	a5 24		lda $24		                lda tmp1
.95c5	d0 02		bne $95c9	                bne +
.95c7	c6 25		dec $25		                dec tmp1+1
.95c9					+
.95c9	c6 24		dec $24		                dec tmp1
.95cb					_loop:
.95cb	b2 24		lda ($24)	                lda (tmp1)
.95cd	c9 20		cmp #$20	                cmp #AscSP
.95cf	d0 18		bne $95e9	                bne _done
.95d1	a5 24		lda $24		                lda tmp1
.95d3	d0 02		bne $95d7	                bne +
.95d5	c6 25		dec $25		                dec tmp1+1
.95d7					+
.95d7	c6 24		dec $24		                dec tmp1
.95d9	b5 00		lda $00,x	                lda 0,x
.95db	d0 02		bne $95df	                bne +
.95dd	d6 01		dec $01,x	                dec 1,x
.95df					+
.95df	d6 00		dec $00,x	                dec 0,x
.95e1	b5 00		lda $00,x	                lda 0,x
.95e3	15 01		ora $01,x	                ora 1,x
.95e5	f0 02		beq $95e9	                beq _done       ; Count has reached zero - we're done!
.95e7	80 e2		bra $95cb	                bra _loop
.95e9					_done:
.95e9					z_minus_trailing:
.95e9	60		rts		                rts
.95ea					xt_mod:
.95ea	20 33 d9	jsr $d933	                jsr underflow_2
.95ed	20 03 a0	jsr $a003	                jsr xt_slash_mod
.95f0	e8		inx		                inx             ; DROP
.95f1	e8		inx		                inx
.95f2					z_mod:
.95f2	60		rts		                rts
.95f3					xt_move:
.95f3	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95f5	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95f7	f0 05		beq $95fe	                beq _lsb                ; wasn't helpful, move to LSB
.95f9	b0 0e		bcs $9609	                bcs _to_move_up         ; we want CMOVE>
.95fb	4c b5 86	jmp $86b5	                jmp xt_cmove            ; JSR/RTS
.95fe					_lsb:
.95fe	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.9600	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.9602	f0 08		beq $960c	                beq _equal              ; LSB is equal as well
.9604	b0 03		bcs $9609	                bcs _to_move_up         ; we want CMOVE>
.9606	4c b5 86	jmp $86b5	                jmp xt_cmove            ; JSR/RTS
.9609					_to_move_up:
.9609	4c f0 86	jmp $86f0	                jmp xt_cmove_up         ; JSR/RTS
.960c					_equal:
.960c	8a		txa		                txa
.960d	18		clc		                clc
.960e	69 06		adc #$06	                adc #6
.9610	aa		tax		                tax
.9611	60		rts		z_move:         rts
.9612					xt_name_to_int:
.9612	20 2e d9	jsr $d92e	                jsr underflow_1
.9615	b5 00		lda $00,x	                lda 0,x
.9617	18		clc		                clc
.9618	69 04		adc #$04	                adc #4
.961a	85 28		sta $28		                sta tmp3
.961c	b5 01		lda $01,x	                lda 1,x
.961e	90 01		bcc $9621	                bcc _done
.9620	1a		inc a		                ina
.9621					_done:
.9621	85 29		sta $29		                sta tmp3+1
.9623	a0 00		ldy #$00	                ldy #0
.9625	b1 28		lda ($28),y	                lda (tmp3),y
.9627	95 00		sta $00,x	                sta 0,x
.9629	c8		iny		                iny
.962a	b1 28		lda ($28),y	                lda (tmp3),y
.962c	95 01		sta $01,x	                sta 1,x
.962e	60		rts		z_name_to_int:  rts
.962f					xt_name_to_string:
.962f	20 2e d9	jsr $d92e	                jsr underflow_1
.9632	ca		dex		                dex
.9633	ca		dex		                dex
.9634	a1 02		lda ($02,x)	                lda (2,x)
.9636	95 00		sta $00,x	                sta 0,x
.9638	74 01		stz $01,x	                stz 1,x
.963a	b5 02		lda $02,x	                lda 2,x         ; LSB
.963c	18		clc		                clc
.963d	69 08		adc #$08	                adc #8
.963f	a8		tay		                tay
.9640	b5 03		lda $03,x	                lda 3,x         ; MSB
.9642	69 00		adc #$00	                adc #0          ; just need carry
.9644	95 03		sta $03,x	                sta 3,x
.9646	94 02		sty $02,x	                sty 2,x
.9648					z_name_to_string:
.9648	60		rts		                rts
.9649					xt_nc_limit:
.9649	ca		dex		                dex
.964a	ca		dex		                dex
.964b	a9 1a		lda #$1a	                lda #<nc_limit
.964d	95 00		sta $00,x	                sta 0,x
.964f	a9 00		lda #$00	                lda #>nc_limit
.9651	95 01		sta $01,x	                sta 1,x
.9653	60		rts		z_nc_limit:     rts
.9654					xt_negate:
.9654	20 2e d9	jsr $d92e	                jsr underflow_1
.9657	a9 00		lda #$00	        	lda #0
.9659	38		sec		                sec
.965a	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.965c	95 00		sta $00,x	                sta 0,x
.965e	a9 00		lda #$00	                lda #0
.9660	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9662	95 01		sta $01,x	                sta 1,x
.9664	60		rts		z_negate:       rts
.9665					xt_never_native:
.9665	20 63 d8	jsr $d863	                jsr current_to_dp
.9668	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.966a	b1 02		lda ($02),y	                lda (dp),y
.966c	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.966e	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.9670	91 02		sta ($02),y	                sta (dp),y
.9672					z_never_native:
.9672	60		rts		                rts
.9673					xt_nip:
.9673	20 33 d9	jsr $d933	                jsr underflow_2
.9676	b5 00		lda $00,x	                lda 0,x         ; LSB
.9678	95 02		sta $02,x	                sta 2,x
.967a	b5 01		lda $01,x	                lda 1,x         ; MSB
.967c	95 03		sta $03,x	                sta 3,x
.967e	e8		inx		                inx
.967f	e8		inx		                inx
.9680	60		rts		z_nip:          rts
.9681					xt_not_equals:
.9681	20 33 d9	jsr $d933	                jsr underflow_2
.9684	a0 00		ldy #$00	                ldy #0                  ; default is true
.9686	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9688	d5 02		cmp $02,x	                cmp 2,x
.968a	d0 0a		bne $9696	                bne _not_equal
.968c	b5 01		lda $01,x	                lda 1,x                 ; MSB
.968e	d5 03		cmp $03,x	                cmp 3,x
.9690	d0 04		bne $9696	                bne _not_equal
.9692	a9 ff		lda #$ff	                lda #$FF
.9694	80 01		bra $9697	                bra _done
.9696					_not_equal:
.9696	88		dey		                dey                     ; drop thru to done
.9697					_done:
.9697	98		tya		                tya
.9698	e8		inx		                inx
.9699	e8		inx		                inx
.969a	95 00		sta $00,x	                sta 0,x
.969c	95 01		sta $01,x	                sta 1,x
.969e	60		rts		z_not_equals:   rts
.969f					xt_not_rote:
.969f	20 38 d9	jsr $d938	                jsr underflow_3
.96a2	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.96a4	b5 03		lda $03,x	                lda 3,x
.96a6	95 01		sta $01,x	                sta 1,x
.96a8	b5 05		lda $05,x	                lda 5,x
.96aa	95 03		sta $03,x	                sta 3,x
.96ac	94 05		sty $05,x	                sty 5,x
.96ae	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.96b0	b5 02		lda $02,x	                lda 2,x
.96b2	95 00		sta $00,x	                sta 0,x
.96b4	b5 04		lda $04,x	                lda 4,x
.96b6	95 02		sta $02,x	                sta 2,x
.96b8	94 04		sty $04,x	                sty 4,x
.96ba	60		rts		z_not_rote:     rts
.96bb					xt_number:
.96bb	20 33 d9	jsr $d933	                jsr underflow_2
.96be	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.96c0	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.96c2	a5 18		lda $18		                lda base
.96c4	48		pha		                pha
.96c5	20 ba a3	jsr $a3ba	                jsr xt_two_dup
.96c8	a1 02		lda ($02,x)	                lda (2,x)
.96ca					_check_dec:
.96ca	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.96cc	d0 04		bne $96d2	                bne _check_hex
.96ce	a9 0a		lda #$0a	                lda #$0A
.96d0	80 42		bra $9714	                bra _base_changed
.96d2					_check_hex:
.96d2	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.96d4	d0 04		bne $96da	                bne _check_binary
.96d6	a9 10		lda #$10	                lda #$10
.96d8	80 3a		bra $9714	                bra _base_changed
.96da					_check_binary:
.96da	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.96dc	d0 04		bne $96e2	                bne _check_char
.96de	a9 02		lda #$02	                lda #$02
.96e0	80 32		bra $9714	                bra _base_changed
.96e2					_check_char:
.96e2	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96e4	d0 3a		bne $9720	                bne _check_minus
.96e6	b5 00		lda $00,x	                lda 0,x         ; Get the length
.96e8	c9 03		cmp #$03	                cmp #$03
.96ea	d0 26		bne $9712	                bne _not_a_char
.96ec	b5 01		lda $01,x	                lda 1,x
.96ee	d0 22		bne $9712	                bne _not_a_char ; No compare needed to check for non-zero.
.96f0	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96f2	18		clc		                clc
.96f3	69 02		adc #$02	                adc #2          ; length of string
.96f5	85 2c		sta $2c		                sta tmptos
.96f7	b5 03		lda $03,x	                lda 3,x
.96f9	69 00		adc #$00	                adc #0          ; only need carry
.96fb	85 2d		sta $2d		                sta tmptos+1
.96fd	b2 2c		lda ($2c)	                lda (tmptos)
.96ff	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.9701	d0 0f		bne $9712	                bne _not_a_char
.9703	f6 02		inc $02,x	                inc 2,x
.9705	d0 02		bne $9709	                bne +
.9707	f6 03		inc $03,x	                inc 3,x
.9709					+
.9709	a1 02		lda ($02,x)	                lda (2,x)
.970b	95 02		sta $02,x	                sta 2,x
.970d	74 03		stz $03,x	                stz 3,x
.970f	4c 90 97	jmp $9790	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9712					_not_a_char:
.9712	80 5a		bra $976e	                bra _number_error
.9714					_base_changed:
.9714	85 18		sta $18		                sta base        ; Switch to the new base
.9716	f6 02		inc $02,x	                inc 2,x         ; start one character later
.9718	d0 02		bne $971c	                bne +
.971a	f6 03		inc $03,x	                inc 3,x
.971c					+
.971c	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.971e	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9720					_check_minus:
.9720	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.9722	d0 0a		bne $972e	                bne _check_dot
.9724	c6 2b		dec $2b		                dec tmpdsp+1
.9726	f6 02		inc $02,x	                inc 2,x         ; start one character later
.9728	d0 02		bne $972c	                bne +
.972a	f6 03		inc $03,x	                inc 3,x
.972c					+
.972c	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.972e					_check_dot:
.972e	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9730	18		clc		                clc
.9731	75 00		adc $00,x	                adc 0,x         ; length of string
.9733	85 2c		sta $2c		                sta tmptos
.9735	b5 03		lda $03,x	                lda 3,x
.9737	69 00		adc #$00	                adc #0          ; only need carry
.9739	85 2d		sta $2d		                sta tmptos+1
.973b	a5 2c		lda $2c		                lda tmptos
.973d	d0 02		bne $9741	                bne +
.973f	c6 2d		dec $2d		                dec tmptos+1
.9741					+
.9741	c6 2c		dec $2c		                dec tmptos
.9743	b2 2c		lda ($2c)	                lda (tmptos)
.9745	c9 2e		cmp #$2e	                cmp #'.'
.9747	d0 04		bne $974d	                bne _main
.9749	c6 2a		dec $2a		                dec tmpdsp
.974b	d6 00		dec $00,x	                dec 0,x
.974d					_main:
.974d	ca		dex		                dex
.974e	ca		dex		                dex
.974f	ca		dex		                dex
.9750	ca		dex		                dex
.9751	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9753	95 00		sta $00,x	                sta 0,x
.9755	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9757	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9759	95 02		sta $02,x	                sta 2,x
.975b	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.975d	95 03		sta $03,x	                sta 3,x
.975f	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9761	74 05		stz $05,x	                stz 5,x
.9763	74 06		stz $06,x	                stz 6,x
.9765	74 07		stz $07,x	                stz 7,x
.9767	20 bf a2	jsr $a2bf	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.976a	b5 00		lda $00,x	                lda 0,x
.976c	f0 1e		beq $978c	                beq _all_converted
.976e					_number_error:
.976e	20 b2 a3	jsr $a3b2	                jsr xt_two_drop ; >NUMBER modified addr u
.9771	20 b2 a3	jsr $a3b2	                jsr xt_two_drop ; ud   (partially converted number)
.9774	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9776	20 12 8e	jsr $8e12	                jsr emit_a
.9779	20 05 a5	jsr $a505	                jsr xt_type
.977c	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.977e	20 12 8e	jsr $8e12	                jsr emit_a
.9781	20 20 a1	jsr $a120	                jsr xt_space
.9784	68		pla		                pla
.9785	85 18		sta $18		                sta base
.9787	a9 08		lda #$08	                lda #err_syntax
.9789	4c 44 d9	jmp $d944	                jmp error
.978c					_all_converted:
.978c	e8		inx		                inx ; Drop the current addr u
.978d	e8		inx		                inx
.978e	e8		inx		                inx
.978f	e8		inx		                inx
.9790					_drop_original_string:
.9790	20 80 a4	jsr $a480	                jsr xt_two_swap  ; Drop the original addr u
.9793	20 b2 a3	jsr $a3b2	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9796	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9798	f0 0d		beq $97a7	                beq _single
.979a	a9 20		lda #$20	                lda #%00100000
.979c	04 20		tsb $20		                tsb status
.979e	a5 2b		lda $2b		                lda tmpdsp+1
.97a0	f0 12		beq $97b4	                beq _done       ; no minus, all done
.97a2	20 5d 8b	jsr $8b5d	                jsr xt_dnegate
.97a5	80 0d		bra $97b4	                bra _done
.97a7					_single:
.97a7	e8		inx		                inx
.97a8	e8		inx		                inx
.97a9	a9 20		lda #$20	                lda #%00100000
.97ab	14 20		trb $20		                trb status
.97ad	a5 2b		lda $2b		                lda tmpdsp+1
.97af	f0 03		beq $97b4	                beq _done       ; no minus, all done
.97b1	20 54 96	jsr $9654	                jsr xt_negate
.97b4					_done:
.97b4	68		pla		                pla
.97b5	85 18		sta $18		                sta base
.97b7	60		rts		z_number:       rts
.97b8					xt_number_sign:
.97b8	20 33 d9	jsr $d933	                jsr underflow_2         ; double number
.97bb	20 a3 83	jsr $83a3	                jsr xt_base
.97be	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; ( ud1 base )
.97c1	20 72 a3	jsr $a372	                jsr xt_to_r             ; >r
.97c4	20 aa a7	jsr $a7aa	                jsr xt_zero             ; 0
.97c7	20 ae 9a	jsr $9aae	                jsr xt_r_fetch          ; r@
.97ca	20 bc a5	jsr $a5bc	                jsr xt_um_slash_mod     ; um/mod
.97cd	20 88 9b	jsr $9b88	                jsr xt_rot              ; rot
.97d0	20 88 9b	jsr $9b88	                jsr xt_rot              ; rot
.97d3	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; r>
.97d6	20 bc a5	jsr $a5bc	                jsr xt_um_slash_mod     ; um/mod
.97d9	20 88 9b	jsr $9b88	                jsr xt_rot              ; rot
.97dc	20 88 9b	jsr $9b88	                jsr xt_rot              ; ( ud rem )
.97df	b5 00		lda $00,x	                lda 0,x
.97e1	a8		tay		                tay
.97e2	b9 00 d5	lda $d500,y	                lda s_abc_upper,y
.97e5	95 00		sta $00,x	                sta 0,x
.97e7	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.97e9	20 f3 91	jsr $91f3	                jsr xt_hold
.97ec					z_number_sign:
.97ec	60		rts		                rts
.97ed					xt_number_sign_greater:
.97ed	20 33 d9	jsr $d933	                jsr underflow_2         ; double number
.97f0	a5 34		lda $34		                lda tohold
.97f2	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97f4	95 02		sta $02,x	                sta 2,x
.97f6	a5 35		lda $35		                lda tohold+1
.97f8	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97fa	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97fc	20 d2 98	jsr $98d2	                jsr xt_pad      ; ( addr addr pad )
.97ff	38		sec		                sec
.9800	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.9802	f5 02		sbc $02,x	                sbc 2,x
.9804	95 02		sta $02,x	                sta 2,x
.9806	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.9808	f5 03		sbc $03,x	                sbc 3,x
.980a	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.980c	e8		inx		                inx
.980d	e8		inx		                inx
.980e					z_number_sign_greater:
.980e	60		rts		                rts
.980f					xt_number_sign_s:
.980f	20 33 d9	jsr $d933	                jsr underflow_2
.9812					_loop:
.9812	20 b8 97	jsr $97b8	                jsr xt_number_sign
.9815	b5 00		lda $00,x	                lda 0,x
.9817	15 01		ora $01,x	                ora 1,x
.9819	15 02		ora $02,x	                ora 2,x
.981b	15 03		ora $03,x	                ora 3,x
.981d	d0 f3		bne $9812	                bne _loop
.981f					z_number_sign_s:
.981f	60		rts		                rts
.9820					xt_of:
.9820	a0 98		ldy #$98	                ldy #>xt_over
.9822	a9 c4		lda #$c4	                lda #<xt_over
.9824	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.9827	a0 8e		ldy #$8e	                ldy #>xt_equal
.9829	a9 ea		lda #$ea	                lda #<xt_equal
.982b	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.982e	20 1f 92	jsr $921f	                jsr xt_if
.9831	a0 8d		ldy #$8d	                ldy #>xt_drop
.9833	a9 4a		lda #$4a	                lda #<xt_drop
.9835	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.9838	60		rts		z_of:           rts
.9839					xt_editor_wordlist:
.9839					xt_one:
.9839	ca		dex		                dex
.983a	ca		dex		                dex
.983b	a9 01		lda #$01	                lda #1
.983d	95 00		sta $00,x	                sta 0,x
.983f	74 01		stz $01,x	                stz 1,x
.9841					z_editor_wordlist:
.9841					z_one:
.9841	60		rts		                rts
.9842					xt_one_minus:
.9842	20 2e d9	jsr $d92e	                jsr underflow_1
.9845	b5 00		lda $00,x	                lda 0,x
.9847	d0 02		bne $984b	                bne +
.9849	d6 01		dec $01,x	                dec 1,x
.984b					+
.984b	d6 00		dec $00,x	                dec 0,x
.984d	60		rts		z_one_minus:    rts
.984e					xt_char_plus:
.984e					xt_one_plus:
.984e	20 2e d9	jsr $d92e	                jsr underflow_1
.9851	f6 00		inc $00,x	                inc 0,x
.9853	d0 02		bne $9857	                bne _done
.9855	f6 01		inc $01,x	                inc 1,x
.9857					_done:
.9857					z_char_plus:
.9857	60		rts		z_one_plus:     rts
.9858					xt_only:
.9858	ca		dex		                dex
.9859	ca		dex		                dex
.985a	a9 ff		lda #$ff	                lda #$FF
.985c	95 00		sta $00,x	                sta 0,x
.985e	95 01		sta $01,x	                sta 1,x
.9860	20 4c 9d	jsr $9d4c	                jsr xt_set_order
.9863	60		rts		z_only:         rts
.9864					xt_or:
.9864	20 33 d9	jsr $d933	                jsr underflow_2
.9867	b5 00		lda $00,x	                lda 0,x
.9869	15 02		ora $02,x	                ora 2,x
.986b	95 02		sta $02,x	                sta 2,x
.986d	b5 01		lda $01,x	                lda 1,x
.986f	15 03		ora $03,x	                ora 3,x
.9871	95 03		sta $03,x	                sta 3,x
.9873	e8		inx		                inx
.9874	e8		inx		                inx
.9875	60		rts		z_or:           rts
.9876					xt_order:
.9876	20 7f 89	jsr $897f	                jsr xt_cr
.9879	20 50 91	jsr $9150	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.987c	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.987e	f0 1e		beq $989e	                beq _drop_done
.9880					_have_wordlists:
.9880	a8		tay		                tay
.9881					_loop:
.9881	e8		inx		                inx
.9882	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9883	b5 00		lda $00,x	                lda 0,x
.9885	5a		phy		                phy
.9886	20 a1 98	jsr $98a1	                jsr order_print_wid_string   ; internal helper function
.9889	7a		ply		                ply
.988a	88		dey		                dey
.988b	d0 f4		bne $9881	                bne _loop
.988d	20 20 a1	jsr $a120	                jsr xt_space
.9890	20 20 a1	jsr $a120	                jsr xt_space
.9893	20 45 91	jsr $9145	                jsr xt_get_current      ; ( wid )
.9896	b5 00		lda $00,x	                lda 0,x
.9898	20 a1 98	jsr $98a1	                jsr order_print_wid_string
.989b	20 7f 89	jsr $897f	                jsr xt_cr
.989e					_drop_done:
.989e	e8		inx		                inx
.989f	e8		inx		                inx
.98a0					z_order:
.98a0	60		rts		                rts
.98a1					order_print_wid_string:
.98a1	c9 04		cmp #$04	                cmp #4
.98a3	90 09		bcc $98ae	                bcc _output_string      ; less than 4, print a real string
.98a5	ca		dex		                dex
.98a6	ca		dex		                dex
.98a7	95 00		sta $00,x	                sta 0,x
.98a9	74 01		stz $01,x	                stz 1,x
.98ab	4c 30 a5	jmp $a530	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.98ae					_output_string:
.98ae	a8		tay		                tay
.98af	b9 b5 98	lda $98b5,y	                lda _wid_data,y
.98b2	4c 6a d9	jmp $d96a	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.98b5					_wid_data:
>98b5	04				        .byte str_wid_forth            ; WID 0: "Forth"
>98b6	05				        .byte str_wid_editor           ; WID 1: "Editor"
>98b7	06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>98b8	07				        .byte str_wid_root             ; WID 3: "Root"
.98b9					xt_output:
.98b9	ca		dex		                dex
.98ba	ca		dex		                dex
.98bb	a9 10		lda #$10	                lda #<output
.98bd	95 00		sta $00,x	                sta 0,x
.98bf	a9 00		lda #$00	                lda #>output
.98c1	95 01		sta $01,x	                sta 1,x
.98c3	60		rts		z_output:       rts
.98c4					xt_over:
.98c4	20 33 d9	jsr $d933	                jsr underflow_2
.98c7	ca		dex		                dex
.98c8	ca		dex		                dex
.98c9	b5 04		lda $04,x	                lda 4,x         ; LSB
.98cb	95 00		sta $00,x	                sta 0,x
.98cd	b5 05		lda $05,x	                lda 5,x         ; MSB
.98cf	95 01		sta $01,x	                sta 1,x
.98d1	60		rts		z_over:         rts
.98d2					xt_pad:
.98d2	ca		dex		                dex
.98d3	ca		dex		                dex
.98d4	a5 00		lda $00		                lda cp
.98d6	18		clc		                clc
.98d7	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.98d9	95 00		sta $00,x	                sta 0,x
.98db	a5 01		lda $01		                lda cp+1
.98dd	69 00		adc #$00	                adc #0          ; only need carry
.98df	95 01		sta $01,x	                sta 1,x
.98e1	60		rts		z_pad:          rts
.98e2					xt_page:
.98e2	a9 1b		lda #$1b	                lda #AscESC
.98e4	20 12 8e	jsr $8e12	                jsr emit_a
.98e7	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.98e9	20 12 8e	jsr $8e12	                jsr emit_a
.98ec	a9 32		lda #$32	                lda #'2'
.98ee	20 12 8e	jsr $8e12	                jsr emit_a
.98f1	a9 4a		lda #$4a	                lda #'J'
.98f3	20 12 8e	jsr $8e12	                jsr emit_a
.98f6	20 aa a7	jsr $a7aa	                jsr xt_zero
.98f9	20 aa a7	jsr $a7aa	                jsr xt_zero
.98fc	20 4a 83	jsr $834a	                jsr xt_at_xy
.98ff	60		rts		z_page:         rts
.9900					xt_paren:
.9900	ca		dex		                dex
.9901	ca		dex		                dex
.9902	a9 29		lda #$29	                lda #41     ; Right parenthesis
.9904	95 00		sta $00,x	                sta 0,x
.9906	74 01		stz $01,x	                stz 1,x
.9908	20 6b 99	jsr $996b	                jsr xt_parse
.990b	e8		inx		                inx
.990c	e8		inx		                inx
.990d	e8		inx		                inx
.990e	e8		inx		                inx
.990f	60		rts		z_paren:        rts
.9910					xt_parse_name:
.9910	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.9912	38		sec		                sec
.9913	e5 0c		sbc $0c		                sbc toin
.9915	85 24		sta $24		                sta tmp1
.9917	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.9919	e5 0d		sbc $0d		                sbc toin+1
.991b	85 25		sta $25		                sta tmp1+1
.991d	a5 24		lda $24		                lda tmp1
.991f	05 25		ora $25		                ora tmp1+1
.9921	f0 28		beq $994b	                beq _empty_line
.9923	a5 08		lda $08		                lda cib
.9925	18		clc		                clc
.9926	65 0c		adc $0c		                adc toin
.9928	85 26		sta $26		                sta tmp2                ; LSB of first character
.992a	a5 09		lda $09		                lda cib+1
.992c	65 0d		adc $0d		                adc toin+1
.992e	85 27		sta $27		                sta tmp2+1              ; MSB
.9930					_skip_loop:
.9930	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.9932	20 21 d9	jsr $d921	                jsr is_whitespace
.9935	90 1f		bcc $9956	                bcc _char_found
.9937	e6 26		inc $26		                inc tmp2
.9939	d0 02		bne $993d	                bne +
.993b	e6 27		inc $27		                inc tmp2+1
.993d					+
.993d	a5 24		lda $24		                lda tmp1
.993f	d0 02		bne $9943	                bne +
.9941	c6 25		dec $25		                dec tmp1+1
.9943	c6 24		dec $24		+               dec tmp1
.9945	a5 24		lda $24		                lda tmp1
.9947	05 25		ora $25		                ora tmp1+1
.9949	d0 e5		bne $9930	                bne _skip_loop          ; fall through if empty line
.994b					_empty_line:
.994b	ca		dex		                dex
.994c	ca		dex		                dex
.994d	ca		dex		                dex
.994e	ca		dex		                dex
.994f	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.9951	74 01		stz $01,x	                stz 1,x
.9953	4c 02 9a	jmp $9a02	                jmp z_parse_name        ; skip over PARSE
.9956					_char_found:
.9956	a5 26		lda $26		                lda tmp2
.9958	38		sec		                sec
.9959	e5 08		sbc $08		                sbc cib
.995b	85 0c		sta $0c		                sta toin
.995d	a5 27		lda $27		                lda tmp2+1
.995f	e5 09		sbc $09		                sbc cib+1
.9961	85 0d		sta $0d		                sta toin+1
.9963	ca		dex		                dex
.9964	ca		dex		                dex
.9965	a9 20		lda #$20	                lda #AscSP
.9967	95 00		sta $00,x	                sta 0,x
.9969	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.996b					xt_parse:
.996b	20 2e d9	jsr $d92e	                jsr underflow_1
.996e	a5 0a		lda $0a		                lda ciblen
.9970	05 0b		ora $0b		                ora ciblen+1
.9972	f0 0c		beq $9980	                beq _abort_parse
.9974	a5 0d		lda $0d		                lda toin+1              ; MSB
.9976	c5 0b		cmp $0b		                cmp ciblen+1
.9978	90 0e		bcc $9988	                bcc _go_parse           ; unsigned comparison
.997a	a5 0c		lda $0c		                lda toin                ; LSB
.997c	c5 0a		cmp $0a		                cmp ciblen
.997e	90 08		bcc $9988	                bcc _go_parse
.9980					_abort_parse:
.9980	ca		dex		                dex
.9981	ca		dex		                dex
.9982	74 00		stz $00,x	                stz 0,x
.9984	74 01		stz $01,x	                stz 1,x
.9986	80 7a		bra $9a02	                bra _done
.9988					_go_parse:
.9988	b5 00		lda $00,x	                lda 0,x
.998a	85 2c		sta $2c		                sta tmptos
.998c	ca		dex		                dex
.998d	ca		dex		                dex
.998e	a5 08		lda $08		                lda cib
.9990	18		clc		                clc
.9991	65 0c		adc $0c		                adc toin        ; LSB
.9993	85 24		sta $24		                sta tmp1
.9995	85 26		sta $26		                sta tmp2
.9997	95 02		sta $02,x	                sta 2,x
.9999	a5 09		lda $09		                lda cib+1
.999b	65 0d		adc $0d		                adc toin+1      ; MSB
.999d	85 25		sta $25		                sta tmp1+1
.999f	85 27		sta $27		                sta tmp2+1
.99a1	95 03		sta $03,x	                sta 3,x
.99a3	a5 08		lda $08		                lda cib
.99a5	18		clc		                clc
.99a6	65 0a		adc $0a		                adc ciblen
.99a8	85 28		sta $28		                sta tmp3
.99aa	a5 09		lda $09		                lda cib+1
.99ac	65 0b		adc $0b		                adc ciblen+1
.99ae	85 29		sta $29		                sta tmp3+1
.99b0	64 2d		stz $2d		                stz tmptos+1
.99b2					_loop:
.99b2	a5 26		lda $26		                lda tmp2
.99b4	c5 28		cmp $28		                cmp tmp3
.99b6	d0 06		bne $99be	                bne _not_empty
.99b8	a5 27		lda $27		                lda tmp2+1
.99ba	c5 29		cmp $29		                cmp tmp3+1
.99bc	f0 1d		beq $99db	                beq _eol
.99be					_not_empty:
.99be	b2 26		lda ($26)	                lda (tmp2)
.99c0	a4 2c		ldy $2c		                ldy tmptos
.99c2	c0 20		cpy #$20	                cpy #AscSP
.99c4	d0 07		bne $99cd	                bne _not_whitespace
.99c6	20 21 d9	jsr $d921	                jsr is_whitespace
.99c9	90 02		bcc $99cd	                bcc _not_whitespace
.99cb	80 0c		bra $99d9	                bra _found_delimiter
.99cd					_not_whitespace:
.99cd	c5 2c		cmp $2c		                cmp tmptos
.99cf	f0 08		beq $99d9	                beq _found_delimiter
.99d1	e6 26		inc $26		                inc tmp2
.99d3	d0 dd		bne $99b2	                bne _loop
.99d5	e6 27		inc $27		                inc tmp2+1
.99d7	80 d9		bra $99b2	                bra _loop
.99d9					_found_delimiter:
.99d9	e6 2d		inc $2d		                inc tmptos+1
.99db					_eol:
.99db	a5 26		lda $26		                lda tmp2
.99dd	38		sec		                sec
.99de	e5 24		sbc $24		                sbc tmp1
.99e0	95 00		sta $00,x	                sta 0,x
.99e2	a5 27		lda $27		                lda tmp2+1
.99e4	e5 25		sbc $25		                sbc tmp1+1
.99e6	95 01		sta $01,x	                sta 1,x
.99e8	a5 26		lda $26		                lda tmp2
.99ea	38		sec		                sec
.99eb	e5 08		sbc $08		                sbc cib
.99ed	85 0c		sta $0c		                sta toin
.99ef	a5 27		lda $27		                lda tmp2+1
.99f1	e5 09		sbc $09		                sbc cib+1
.99f3	85 0d		sta $0d		                sta toin+1
.99f5	a5 0c		lda $0c		                lda toin
.99f7	18		clc		                clc
.99f8	65 2d		adc $2d		                adc tmptos+1
.99fa	85 0c		sta $0c		                sta toin
.99fc	a5 0d		lda $0d		                lda toin+1
.99fe	69 00		adc #$00	                adc #0          ; we only need the carry
.9a00	85 0d		sta $0d		                sta toin+1
.9a02					_done:
.9a02					z_parse_name:
.9a02	60		rts		z_parse:        rts
.9a03					xt_pick:
.9a03	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.9a05	8a		txa		                txa
.9a06	75 00		adc $00,x	                adc 0,x
.9a08	a8		tay		                tay
.9a09	b9 02 00	lda $0002,y	                lda 0002,y
.9a0c	95 00		sta $00,x	                sta 0,x
.9a0e	b9 03 00	lda $0003,y	                lda 0003,y
.9a11	95 01		sta $01,x	                sta 1,x
.9a13	60		rts		z_pick:         rts
.9a14					xt_plus:
.9a14	20 33 d9	jsr $d933	                jsr underflow_2
.9a17	18		clc		                clc
.9a18	b5 00		lda $00,x	                lda 0,x         ; LSB
.9a1a	75 02		adc $02,x	                adc 2,x
.9a1c	95 02		sta $02,x	                sta 2,x
.9a1e	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.9a20	75 03		adc $03,x	                adc 3,x
.9a22	95 03		sta $03,x	                sta 3,x
.9a24	e8		inx		                inx
.9a25	e8		inx		                inx
.9a26	60		rts		z_plus:         rts
.9a27					xt_plus_store:
.9a27	20 33 d9	jsr $d933	                jsr underflow_2
.9a2a	b5 00		lda $00,x	                lda 0,x
.9a2c	85 24		sta $24		                sta tmp1
.9a2e	b5 01		lda $01,x	                lda 1,x
.9a30	85 25		sta $25		                sta tmp1+1
.9a32	a0 00		ldy #$00	                ldy #0          ; LSB
.9a34	b1 24		lda ($24),y	                lda (tmp1),y
.9a36	18		clc		                clc
.9a37	75 02		adc $02,x	                adc 2,x
.9a39	91 24		sta ($24),y	                sta (tmp1),y
.9a3b	c8		iny		                iny             ; MSB
.9a3c	b1 24		lda ($24),y	                lda (tmp1),y
.9a3e	75 03		adc $03,x	                adc 3,x
.9a40	91 24		sta ($24),y	                sta (tmp1),y
.9a42	e8		inx		                inx
.9a43	e8		inx		                inx
.9a44	e8		inx		                inx
.9a45	e8		inx		                inx
.9a46	60		rts		z_plus_store:   rts
.9a47					xt_postpone:
.9a47	20 10 99	jsr $9910	                jsr xt_parse_name               ; ( -- addr n )
.9a4a	b5 00		lda $00,x	                lda 0,x
.9a4c	15 01		ora $01,x	                ora 1,x
.9a4e	d0 05		bne $9a55	                bne +
.9a50	a9 05		lda #$05	                lda #err_noname
.9a52	4c 44 d9	jmp $d944	                jmp error
.9a55					+
.9a55	20 f7 8f	jsr $8ff7	                jsr xt_find_name                ; ( -- nt | 0 )
.9a58	d0 05		bne $9a5f	                bne +
.9a5a	a9 05		lda #$05	                lda #err_noname
.9a5c	4c 44 d9	jmp $d944	                jmp error
.9a5f					+
.9a5f	b5 00		lda $00,x	                lda 0,x
.9a61	85 24		sta $24		                sta tmp1
.9a63	b5 01		lda $01,x	                lda 1,x
.9a65	85 25		sta $25		                sta tmp1+1
.9a67	20 12 96	jsr $9612	                jsr xt_name_to_int              ; ( nt -- xt )
.9a6a	e6 24		inc $24		                inc tmp1
.9a6c	d0 02		bne $9a70	                bne +
.9a6e	e6 25		inc $25		                inc tmp1+1
.9a70					+
.9a70	b2 24		lda ($24)	                lda (tmp1)
.9a72	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a74	f0 05		beq $9a7b	                beq _not_immediate
.9a76	20 09 88	jsr $8809	                jsr xt_compile_comma
.9a79	80 0a		bra $9a85	                bra _done
.9a7b					_not_immediate:
.9a7b	20 a6 93	jsr $93a6	                jsr xt_literal
.9a7e	a0 88		ldy #$88	                ldy #>xt_compile_comma
.9a80	a9 09		lda #$09	                lda #<xt_compile_comma
.9a82	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.9a85					_done:
.9a85	60		rts		z_postpone:     rts
.9a86					xt_previous:
.9a86	20 50 91	jsr $9150	                jsr xt_get_order
.9a89	20 73 96	jsr $9673	                jsr xt_nip
.9a8c	20 42 98	jsr $9842	                jsr xt_one_minus
.9a8f	20 4c 9d	jsr $9d4c	                jsr xt_set_order
.9a92	60		rts		z_previous:     rts
.9a93					xt_question:
.9a93	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.9a96	20 52 8c	jsr $8c52	                jsr xt_dot
.9a99	60		rts		z_question:     rts
.9a9a					xt_question_dup:
.9a9a	20 2e d9	jsr $d92e	                jsr underflow_1
.9a9d	b5 00		lda $00,x	                lda 0,x
.9a9f	15 01		ora $01,x	                ora 1,x
.9aa1	f0 0a		beq $9aad	                beq _done
.9aa3	ca		dex		                dex
.9aa4	ca		dex		                dex
.9aa5	b5 02		lda $02,x	                lda 2,x
.9aa7	95 00		sta $00,x	                sta 0,x
.9aa9	b5 03		lda $03,x	                lda 3,x
.9aab	95 01		sta $01,x	                sta 1,x
.9aad					_done:
.9aad	60		rts		z_question_dup: rts
.9aae					xt_r_fetch:
.9aae	7a		ply		                ply             ; LSB
.9aaf	84 24		sty $24		                sty tmp1
.9ab1	7a		ply		                ply             ; MSB
.9ab2	ca		dex		                dex
.9ab3	ca		dex		                dex
.9ab4	68		pla		                pla             ; LSB
.9ab5	95 00		sta $00,x	                sta 0,x
.9ab7	68		pla		                pla             ; MSB
.9ab8	95 01		sta $01,x	                sta 1,x
.9aba	48		pha		                pha
.9abb	b5 00		lda $00,x	                lda 0,x
.9abd	48		pha		                pha
.9abe	5a		phy		                phy             ; MSB
.9abf	a4 24		ldy $24		                ldy tmp1
.9ac1	5a		phy		                phy             ; LSB
.9ac2	60		rts		z_r_fetch:      rts
.9ac3					xt_r_from:
.9ac3	68		pla		                pla             ; LSB
.9ac4	85 2c		sta $2c		                sta tmptos
.9ac6	7a		ply		                ply             ; MSB
.9ac7	ca		dex		                dex
.9ac8	ca		dex		                dex
.9ac9	68		pla		                pla             ; LSB
.9aca	95 00		sta $00,x	                sta 0,x
.9acc	68		pla		                pla             ; MSB
.9acd	95 01		sta $01,x	                sta 1,x
.9acf	5a		phy		                phy             ; MSB
.9ad0	a5 2c		lda $2c		                lda tmptos
.9ad2	48		pha		                pha             ; LSB
.9ad3	60		rts		z_r_from:       rts
.9ad4					xt_r_to_input:
.9ad4	68		pla		                pla
.9ad5	85 24		sta $24		                sta tmp1
.9ad7	68		pla		                pla
.9ad8	85 25		sta $25		                sta tmp1+1
.9ada	a0 00		ldy #$00	                ldy #0
.9adc					_loop:
.9adc	68		pla		                pla
.9add	99 06 00	sta $0006,y	                sta insrc,y
.9ae0	c8		iny		                iny
.9ae1	c0 08		cpy #$08	                cpy #8
.9ae3	d0 f7		bne $9adc	                bne _loop
.9ae5	a5 25		lda $25		                lda tmp1+1
.9ae7	48		pha		                pha
.9ae8	a5 24		lda $24		                lda tmp1
.9aea	48		pha		                pha
.9aeb	60		rts		z_r_to_input: 	rts
.9aec					xt_recurse:
.9aec	a0 00		ldy #$00	                ldy #0
.9aee	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9af0	91 00		sta ($00),y	                sta (cp),y
.9af2	c8		iny		                iny
.9af3	24 20		bit $20		                bit status
.9af5	70 0c		bvs $9b03	                bvs _nt_in_workword
.9af7	a5 04		lda $04		                lda workword
.9af9	91 00		sta ($00),y	                sta (cp),y
.9afb	c8		iny		                iny
.9afc	a5 05		lda $05		                lda workword+1
.9afe	91 00		sta ($00),y	                sta (cp),y
.9b00	c8		iny		                iny
.9b01	80 1b		bra $9b1e	                bra _update_cp
.9b03					_nt_in_workword:
.9b03	a5 04		lda $04		                lda workword            ; LSB
.9b05	18		clc		                clc
.9b06	69 04		adc #$04	                adc #4
.9b08	85 24		sta $24		                sta tmp1
.9b0a	a5 05		lda $05		                lda workword+1          ; MSB
.9b0c	69 00		adc #$00	                adc #0
.9b0e	85 25		sta $25		                sta tmp1+1
.9b10	b2 24		lda ($24)	                lda (tmp1)
.9b12	91 00		sta ($00),y	                sta (cp),y
.9b14	5a		phy		                phy
.9b15	a0 01		ldy #$01	                ldy #1
.9b17	b1 24		lda ($24),y	                lda (tmp1),y
.9b19	7a		ply		                ply
.9b1a	c8		iny		                iny
.9b1b	91 00		sta ($00),y	                sta (cp),y
.9b1d	c8		iny		                iny
.9b1e					_update_cp:
.9b1e	98		tya		                tya
.9b1f	18		clc		                clc
.9b20	65 00		adc $00		                adc cp
.9b22	85 00		sta $00		                sta cp
.9b24	90 02		bcc $9b28	                bcc _done
.9b26	e6 01		inc $01		                inc cp+1
.9b28					_done:
.9b28	60		rts		z_recurse:      rts
.9b29					xt_refill:
.9b29	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9b2b	d0 2d		bne $9b5a	                bne _src_not_kbd
.9b2d	ca		dex		                dex
.9b2e	ca		dex		                dex
.9b2f	ca		dex		                dex
.9b30	ca		dex		                dex
.9b31	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9b33	95 02		sta $02,x	                sta 2,x
.9b35	a5 09		lda $09		                lda cib+1
.9b37	95 03		sta $03,x	                sta 3,x
.9b39	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9b3b	64 0b		stz $0b		                stz ciblen+1
.9b3d	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9b3f	95 00		sta $00,x	                sta 0,x
.9b41	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9b43	20 48 81	jsr $8148	                jsr xt_accept           ; ( addr n1 -- n2)
.9b46	b5 00		lda $00,x	                lda 0,x
.9b48	85 0a		sta $0a		                sta ciblen
.9b4a	b5 01		lda $01,x	                lda 1,x
.9b4c	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b4e	64 0c		stz $0c		                stz toin
.9b50	64 0d		stz $0d		                stz toin+1
.9b52	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b54	95 00		sta $00,x	                sta 0,x
.9b56	95 01		sta $01,x	                sta 1,x
.9b58	80 10		bra $9b6a	                bra _done
.9b5a					_src_not_kbd:
.9b5a	1a		inc a		                ina
.9b5b	d0 08		bne $9b65	                bne _src_not_string
.9b5d	ca		dex		                dex
.9b5e	ca		dex		                dex
.9b5f	74 00		stz $00,x	                stz 0,x
.9b61	74 01		stz $01,x	                stz 1,x
.9b63	80 05		bra $9b6a	                bra z_refill
.9b65					_src_not_string:
.9b65	a9 01		lda #$01	                lda #err_badsource
.9b67	4c 44 d9	jmp $d944	                jmp error
.9b6a					_done:
.9b6a	60		rts		z_refill:       rts
.9b6b					xt_repeat:
.9b6b	20 83 82	jsr $8283	                jsr xt_again
.9b6e	20 8e 91	jsr $918e	                jsr xt_here
.9b71	20 b0 a1	jsr $a1b0	                jsr xt_swap
.9b74	20 8f a1	jsr $a18f	                jsr xt_store
.9b77	60		rts		z_repeat:       rts
.9b78					xt_right_bracket:
.9b78	a9 ff		lda #$ff	                lda #$FF
.9b7a	85 16		sta $16		                sta state
.9b7c	85 17		sta $17		                sta state+1
.9b7e					z_right_bracket:
.9b7e	60		rts		                rts
.9b7f					xt_root_wordlist:
.9b7f	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b80	ca		dex		                dex
.9b81	a9 03		lda #$03	                lda #3
.9b83	95 00		sta $00,x	                sta 0,x
.9b85	74 01		stz $01,x	                stz 1,x
.9b87					z_root_wordlist:
.9b87	60		rts		                rts
.9b88					xt_rot:
.9b88	20 38 d9	jsr $d938	                jsr underflow_3
.9b8b	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b8d	b5 03		lda $03,x	                lda 3,x
.9b8f	95 05		sta $05,x	                sta 5,x
.9b91	b5 01		lda $01,x	                lda 1,x
.9b93	95 03		sta $03,x	                sta 3,x
.9b95	94 01		sty $01,x	                sty 1,x
.9b97	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b99	b5 02		lda $02,x	                lda 2,x
.9b9b	95 04		sta $04,x	                sta 4,x
.9b9d	b5 00		lda $00,x	                lda 0,x
.9b9f	95 02		sta $02,x	                sta 2,x
.9ba1	94 00		sty $00,x	                sty 0,x
.9ba3	60		rts		z_rot:          rts
.9ba4					xt_rshift:
.9ba4	20 33 d9	jsr $d933	                jsr underflow_2
.9ba7	b5 00		lda $00,x	                lda 0,x
.9ba9	29 0f		and #$0f	                and #%00001111
.9bab	f0 08		beq $9bb5	                beq _done               ; if 0 shifts, quit
.9bad	a8		tay		                tay
.9bae					_loop:
.9bae	56 03		lsr $03,x	                lsr 3,x
.9bb0	76 02		ror $02,x	                ror 2,x
.9bb2	88		dey		                dey
.9bb3	d0 f9		bne $9bae	                bne _loop
.9bb5					_done:
.9bb5	e8		inx		                inx
.9bb6	e8		inx		                inx
.9bb7	60		rts		z_rshift:       rts
.9bb8					xt_s_backslash_quote:
.9bb8	a9 ff		lda #$ff	                lda #$FF
.9bba	85 26		sta $26		                sta tmp2
.9bbc	64 27		stz $27		                stz tmp2+1
.9bbe	20 84 9d	jsr $9d84	                jsr s_quote_start
.9bc1					_done:
.9bc1					z_s_backslash_quote:
.9bc1	60		rts		                rts
.9bc2					convert_hex_value:
.9bc2	c9 41		cmp #$41	        cmp #'A'
.9bc4	90 07		bcc $9bcd	        bcc _digit
.9bc6	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9bc8	38		sec		        sec
.9bc9	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9bcb	80 03		bra $9bd0	        bra _done
.9bcd					_digit:
.9bcd	38		sec		        sec
.9bce	e9 30		sbc #$30	        sbc #'0'
.9bd0					_done:
.9bd0	60		rts		        rts
.9bd1					xt_search_wordlist:
.9bd1	20 38 d9	jsr $d938	                jsr underflow_3
.9bd4	a5 1e		lda $1e		                lda up
.9bd6	18		clc		                clc
.9bd7	69 06		adc #$06	                adc #wordlists_offset
.9bd9	85 26		sta $26		                sta tmp2
.9bdb	a5 1f		lda $1f		                lda up+1
.9bdd	69 00		adc #$00	                adc #0          ; Adding carry
.9bdf	85 27		sta $27		                sta tmp2+1
.9be1	b5 00		lda $00,x	                lda 0,x
.9be3	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9be4	65 26		adc $26		                adc tmp2
.9be6	85 26		sta $26		                sta tmp2
.9be8	90 02		bcc $9bec	                bcc +
.9bea	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9bec					+
.9bec	e8		inx		                inx
.9bed	e8		inx		                inx
.9bee	b5 00		lda $00,x	                lda 0,x
.9bf0	15 01		ora $01,x	                ora 1,x
.9bf2	d0 03		bne $9bf7	                bne _check_wordlist
.9bf4	4c af 9c	jmp $9caf	                jmp _done
.9bf7					_check_wordlist:
.9bf7	a5 26		lda $26		                lda tmp2
.9bf9	05 27		ora $27		                ora tmp2+1
.9bfb	d0 03		bne $9c00	                bne _have_string
.9bfd	4c af 9c	jmp $9caf	                jmp _done
.9c00					_have_string:
.9c00	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9c02	85 24		sta $24		                sta tmp1
.9c04	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9c06	d0 02		bne $9c0a	                bne +
.9c08	e6 27		inc $27		                inc tmp2+1
.9c0a					+
.9c0a	b2 26		lda ($26)	                lda (tmp2)
.9c0c	85 25		sta $25		                sta tmp1+1
.9c0e	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9c10	85 26		sta $26		                sta tmp2
.9c12	b5 03		lda $03,x	                lda 3,x
.9c14	85 27		sta $27		                sta tmp2+1
.9c16					_loop:
.9c16	b2 24		lda ($24)	                lda (tmp1)
.9c18	d5 00		cmp $00,x	                cmp 0,x
.9c1a	d0 7b		bne $9c97	                bne _next_entry
.9c1c					_compare_string:
.9c1c	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9c1e	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9c20	b0 07		bcs $9c29	                bcs _compare_first
.9c22	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c24	90 03		bcc $9c29	                bcc _compare_first
.9c26	18		clc		                clc
.9c27	69 20		adc #$20	                adc #$20
.9c29					_compare_first:
.9c29	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9c2b	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9c2d	d0 68		bne $9c97	                bne _next_entry
.9c2f	b5 00		lda $00,x	                lda 0,x
.9c31	3a		dec a		                dea
.9c32	f0 2c		beq $9c60	                beq _success
.9c34	a5 24		lda $24		                lda tmp1
.9c36	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9c37	18		clc		                clc
.9c38	69 08		adc #$08	                adc #8
.9c3a	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9c3c	a5 25		lda $25		                lda tmp1+1
.9c3e	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9c3f	69 00		adc #$00	                adc #0          ; we only need the carry
.9c41	85 25		sta $25		                sta tmp1+1
.9c43	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9c45	88		dey		                dey
.9c46					_string_loop:
.9c46	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9c48	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9c4a	b0 07		bcs $9c53	                bcs _check_char
.9c4c	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c4e	90 03		bcc $9c53	                bcc _check_char
.9c50	18		clc		                clc
.9c51	69 20		adc #$20	                adc #$20
.9c53					_check_char:
.9c53	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c55	d0 3a		bne $9c91	                bne _next_entry_tmp1
.9c57	88		dey		                dey
.9c58	d0 ec		bne $9c46	                bne _string_loop
.9c5a					_success_tmp1:
.9c5a	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c5b	85 25		sta $25		                sta tmp1+1
.9c5d	68		pla		                pla
.9c5e	85 24		sta $24		                sta tmp1
.9c60					_success:
.9c60	e8		inx		                inx
.9c61	e8		inx		                inx
.9c62	a5 24		lda $24		                lda tmp1
.9c64	95 00		sta $00,x	                sta 0,x
.9c66	a5 25		lda $25		                lda tmp1+1
.9c68	95 01		sta $01,x	                sta 1,x
.9c6a	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( nt nt )
.9c6d	20 12 96	jsr $9612	                jsr xt_name_to_int      ; ( nt xt )
.9c70	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( xt nt )
.9c73	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c75	f6 00		inc $00,x	                inc 0,x
.9c77	d0 02		bne $9c7b	                bne +
.9c79	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c7b					+
.9c7b	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c7d	29 04		and #$04	                and #IM
.9c7f	d0 08		bne $9c89	                bne _immediate          ; bit set, we're immediate
.9c81	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c83	95 00		sta $00,x	                sta 0,x
.9c85	95 01		sta $01,x	                sta 1,x
.9c87	80 28		bra $9cb1	                bra _done_nodrop
.9c89					_immediate:
.9c89	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c8b	95 00		sta $00,x	                sta 0,x
.9c8d	74 01		stz $01,x	                stz 1,x
.9c8f	80 20		bra $9cb1	                bra _done_nodrop
.9c91					_next_entry_tmp1:
.9c91	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c92	85 25		sta $25		                sta tmp1+1
.9c94	68		pla		                pla
.9c95	85 24		sta $24		                sta tmp1
.9c97					_next_entry:
.9c97	a0 02		ldy #$02	                ldy #2
.9c99	b1 24		lda ($24),y	                lda (tmp1),y
.9c9b	48		pha		                pha
.9c9c	c8		iny		                iny
.9c9d	b1 24		lda ($24),y	                lda (tmp1),y
.9c9f	85 25		sta $25		                sta tmp1+1
.9ca1	68		pla		                pla
.9ca2	85 24		sta $24		                sta tmp1
.9ca4	05 25		ora $25		                ora tmp1+1
.9ca6	f0 03		beq $9cab	                beq _fail_done
.9ca8	4c 16 9c	jmp $9c16	                jmp _loop
.9cab					_fail_done:
.9cab	74 02		stz $02,x	                stz 2,x         ; failure flag
.9cad	74 03		stz $03,x	                stz 3,x
.9caf					_done:
.9caf	e8		inx		                inx
.9cb0	e8		inx		                inx
.9cb1					_done_nodrop:
.9cb1					z_search_wordlist:
.9cb1	60		rts		                rts
.9cb2					xt_see:
.9cb2	20 10 99	jsr $9910	                jsr xt_parse_name       ; ( addr u )
.9cb5	20 f7 8f	jsr $8ff7	                jsr xt_find_name        ; ( nt | 0 )
.9cb8	b5 00		lda $00,x	                lda 0,x
.9cba	15 01		ora $01,x	                ora 1,x
.9cbc	d0 05		bne $9cc3	                bne +
.9cbe	a9 05		lda #$05	                lda #err_noname
.9cc0	4c 44 d9	jmp $d944	                jmp error
.9cc3					+
.9cc3	20 7f 89	jsr $897f	                jsr xt_cr
.9cc6	a5 18		lda $18		                lda base
.9cc8	48		pha		                pha
.9cc9	20 99 91	jsr $9199	                jsr xt_hex
.9ccc	a9 09		lda #$09	                lda #str_see_nt
.9cce	20 6a d9	jsr $d96a	                jsr print_string_no_lf
.9cd1	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( nt nt )
.9cd4	20 30 a5	jsr $a530	                jsr xt_u_dot
.9cd7	20 20 a1	jsr $a120	                jsr xt_space            ; ( nt )
.9cda	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( nt nt )
.9cdd	20 12 96	jsr $9612	                jsr xt_name_to_int      ; ( nt xt )
.9ce0	a9 0a		lda #$0a	                lda #str_see_xt
.9ce2	20 6a d9	jsr $d96a	                jsr print_string_no_lf
.9ce5	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( nt xt xt )
.9ce8	20 30 a5	jsr $a530	                jsr xt_u_dot
.9ceb	20 7f 89	jsr $897f	                jsr xt_cr               ; ( nt xt )
.9cee	a9 08		lda #$08	                lda #str_see_flags
.9cf0	20 6a d9	jsr $d96a	                jsr print_string_no_lf
.9cf3	20 c4 98	jsr $98c4	                jsr xt_over             ; ( nt xt nt )
.9cf6	20 4e 98	jsr $984e	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9cf9	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; ( nt xt flags )
.9cfc	b5 00		lda $00,x	                lda 0,x
.9cfe	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9d00					_flag_loop:
.9d00	48		pha		                pha
.9d01	29 01		and #$01	                and #%00000001
.9d03	18		clc		                clc
.9d04	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9d06	20 12 8e	jsr $8e12	                jsr emit_a
.9d09	20 20 a1	jsr $a120	                jsr xt_space
.9d0c	68		pla		                pla
.9d0d	6a		ror a		                ror                     ; Next flag
.9d0e	88		dey		                dey
.9d0f	d0 ef		bne $9d00	                bne _flag_loop
.9d11	20 7f 89	jsr $897f	                jsr xt_cr
.9d14	e8		inx		                inx
.9d15	e8		inx		                inx                     ; ( nt xt )
.9d16	a9 0b		lda #$0b	                lda #str_see_size
.9d18	20 6a d9	jsr $d96a	                jsr print_string_no_lf
.9d1b	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( xt nt )
.9d1e	20 77 a7	jsr $a777	                jsr xt_wordsize         ; ( xt u )
.9d21	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9d24	20 c1 8a	jsr $8ac1	                jsr xt_decimal
.9d27	20 30 a5	jsr $a530	                jsr xt_u_dot            ; ( xt u )
.9d2a	20 99 91	jsr $9199	                jsr xt_hex
.9d2d	20 7f 89	jsr $897f	                jsr xt_cr
.9d30	20 ba a3	jsr $a3ba	                jsr xt_two_dup          ; ( xt u xt u )
.9d33	20 50 8d	jsr $8d50	                jsr xt_dump
.9d36	20 7f 89	jsr $897f	                jsr xt_cr
.9d39	20 56 8b	jsr $8b56	                jsr xt_disasm
.9d3c	68		pla		                pla
.9d3d	85 18		sta $18		                sta base
.9d3f	60		rts		z_see:          rts
.9d40					xt_set_current:
.9d40	20 2e d9	jsr $d92e	                jsr underflow_1
.9d43	a0 04		ldy #$04	                ldy #current_offset
.9d45	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9d47	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9d49	e8		inx		                inx
.9d4a	e8		inx		                inx
.9d4b	60		rts		z_set_current:  rts
.9d4c					xt_set_order:
.9d4c	a9 ff		lda #$ff	                lda #$FF
.9d4e	d5 01		cmp $01,x	                cmp 1,x
.9d50	d0 12		bne $9d64	                bne _start
.9d52	d5 00		cmp $00,x	                cmp 0,x
.9d54	d0 0e		bne $9d64	                bne _start
.9d56	ca		dex		                dex             ; Make room for the count.
.9d57	ca		dex		                dex
.9d58	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d5a	a9 03		lda #$03	                lda #3
.9d5c	95 02		sta $02,x	                sta 2,x
.9d5e	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d60	a9 01		lda #$01	                lda #1
.9d62	95 00		sta $00,x	                sta 0,x
.9d64					_start:
.9d64	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d66	b5 00		lda $00,x	                lda 0,x
.9d68	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d6a	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d6c	e8		inx		                inx             ; Drop the count off the data stack.
.9d6d	e8		inx		                inx
.9d6e	a5 24		lda $24		                lda tmp1
.9d70	f0 0d		beq $9d7f	                beq _done       ; If zero, there are no wordlists.
.9d72	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d74					_loop:
.9d74	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d76	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d78	c8		iny		                iny
.9d79	e8		inx		                inx
.9d7a	e8		inx		                inx
.9d7b	c6 24		dec $24		                dec tmp1
.9d7d	d0 f5		bne $9d74	                bne _loop
.9d7f					_done:
.9d7f	60		rts		z_set_order:    rts
.9d80					xt_s_quote:
.9d80	64 26		stz $26		                stz tmp2
.9d82	64 27		stz $27		                stz tmp2+1
.9d84					s_quote_start:
.9d84	ca		dex		                dex
.9d85	ca		dex		                dex
.9d86	ca		dex		                dex
.9d87	ca		dex		                dex
.9d88	a9 4c		lda #$4c	                lda #$4C
.9d8a	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.9d8d	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.9d90	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.9d93	a5 00		lda $00		                lda cp
.9d95	95 02		sta $02,x	                sta 2,x
.9d97	a5 01		lda $01		                lda cp+1
.9d99	95 03		sta $03,x	                sta 3,x
.9d9b					_savechars_loop:
.9d9b	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d9d	c5 0b		cmp $0b		                cmp ciblen+1
.9d9f	90 2a		bcc $9dcb	                bcc _input_fine         ; unsigned comparison
.9da1	a5 0c		lda $0c		                lda toin                ; LSB
.9da3	c5 0a		cmp $0a		                cmp ciblen
.9da5	90 24		bcc $9dcb	                bcc _input_fine
.9da7	a5 26		lda $26		                lda tmp2
.9da9	48		pha		                pha
.9daa	a5 27		lda $27		                lda tmp2+1
.9dac	48		pha		                pha
.9dad	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9daf	48		pha		                pha
.9db0	20 29 9b	jsr $9b29	                jsr xt_refill           ; ( -- f )
.9db3	68		pla		                pla
.9db4	85 28		sta $28		                sta tmp3
.9db6	68		pla		                pla
.9db7	85 27		sta $27		                sta tmp2+1
.9db9	68		pla		                pla
.9dba	85 26		sta $26		                sta tmp2
.9dbc	b5 00		lda $00,x	                lda 0,x
.9dbe	15 01		ora $01,x	                ora 1,x
.9dc0	d0 05		bne $9dc7	                bne _refill_ok
.9dc2	a9 06		lda #$06	                lda #err_refill
.9dc4	4c 44 d9	jmp $d944	                jmp error
.9dc7					_refill_ok:
.9dc7	e8		inx		                inx
.9dc8	e8		inx		                inx
.9dc9	80 d0		bra $9d9b	                bra _savechars_loop
.9dcb					_input_fine:
.9dcb	a5 08		lda $08		                lda cib
.9dcd	18		clc		                clc
.9dce	65 0c		adc $0c		                adc toin        ; LSB
.9dd0	85 24		sta $24		                sta tmp1
.9dd2	a5 09		lda $09		                lda cib+1
.9dd4	65 0d		adc $0d		                adc toin+1      ; MSB
.9dd6	85 25		sta $25		                sta tmp1+1
.9dd8	b2 24		lda ($24)	                lda (tmp1)
.9dda	24 26		bit $26		                bit tmp2
.9ddc	30 03		bmi $9de1	                bmi _handle_escapes    ; Only checking bit 7
.9dde	4c 6a 9e	jmp $9e6a	                jmp _regular_char
.9de1					_handle_escapes:
.9de1	24 27		bit $27		                bit tmp2+1
.9de3	30 03		bmi $9de8	                bmi _escaped
.9de5	4c 60 9e	jmp $9e60	                jmp _not_escaped
.9de8					_escaped:
.9de8	70 3c		bvs $9e26	                bvs _check_esc_chars
.9dea	a9 01		lda #$01	                lda #1
.9dec	24 27		bit $27		                bit tmp2+1
.9dee	d0 10		bne $9e00	                bne _esc_x_second_digit
.9df0	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9df2	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9df4	20 c2 9b	jsr $9bc2	                jsr convert_hex_value
.9df7	0a		asl a		                asl
.9df8	0a		asl a		                asl
.9df9	0a		asl a		                asl
.9dfa	0a		asl a		                asl
.9dfb	85 28		sta $28		                sta tmp3    ; Save it for later.
.9dfd	4c 71 9e	jmp $9e71	                jmp _next_character
.9e00					_esc_x_second_digit:
.9e00	64 27		stz $27		                stz tmp2+1
.9e02	b2 24		lda ($24)	                lda (tmp1)
.9e04	20 c2 9b	jsr $9bc2	                jsr convert_hex_value
.9e07	05 28		ora $28		                ora tmp3
.9e09	4c 6e 9e	jmp $9e6e	                jmp _save_character
.9e0c					_esc_tr_table:
>9e0c	07				    .byte   7               ; a -> BEL (ASCII value 7)
>9e0d	08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9e0e	00 00				    .byte   0,0             ; c, d no escape
>9e10	1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9e11	0c				    .byte   12              ; f -> FF (ASCII value 12)
>9e12	00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9e17	0a				    .byte   10              ; l -> LF (ASCII value 10)
>9e18	8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9e19	0a				    .byte   10              ; n behaves like l --> lf
>9e1a	00 00				    .byte   0,0             ; o,p
>9e1c	22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9e1d	0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9e1e	00				    .byte   0               ; s
>9e1f	09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9e20	00				    .byte   0               ; u
>9e21	0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9e22	00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9e25	80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9e26					_check_esc_chars:
.9e26	64 27		stz $27		                stz tmp2+1
.9e28	c9 61		cmp #$61	                cmp #'a'
.9e2a	30 1a		bmi $9e46	                bmi _check_esc_quote
.9e2c	c9 7b		cmp #$7b	                cmp #'z'+1
.9e2e	10 16		bpl $9e46	                bpl _check_esc_quote
.9e30	a8		tay		                tay
.9e31	b9 ab 9d	lda $9dab,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9e34	d0 03		bne $9e39	                bne _esc_replace
.9e36	98		tya		                tya                     ; revert if no translation
.9e37	80 0d		bra $9e46	                bra _check_esc_quote
.9e39	10 33		bpl $9e6e	_esc_replace:   bpl _save_character     ; simple replacement
.9e3b	29 7f		and #$7f	                and #$7f                ; clear hi bit
.9e3d	f0 2f		beq $9e6e	                beq _save_character     ; NUL we can just output
.9e3f	20 d4 d7	jsr $d7d4	                jsr cmpl_a              ; else output first char (CR)
.9e42	a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9e44	80 28		bra $9e6e	                bra _save_character
.9e46					_check_esc_quote:
.9e46	c9 22		cmp #$22	                cmp #$22
.9e48	d0 04		bne $9e4e	                bne _check_esc_x
.9e4a	a9 22		lda #$22	                lda #34
.9e4c	80 20		bra $9e6e	                bra _save_character
.9e4e					_check_esc_x:
.9e4e	c9 78		cmp #$78	                cmp #'x'
.9e50	d0 06		bne $9e58	                bne _check_esc_backslash
.9e52	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e54	85 27		sta $27		                sta tmp2+1
.9e56	80 19		bra $9e71	                bra _next_character
.9e58					_check_esc_backslash:
.9e58	c9 5c		cmp #$5c	                cmp #$5C
.9e5a	d0 04		bne $9e60	                bne _not_escaped
.9e5c	a9 5c		lda #$5c	                lda #92
.9e5e	80 0e		bra $9e6e	                bra _save_character
.9e60					_not_escaped:
.9e60	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e62	d0 06		bne $9e6a	                bne _regular_char
.9e64	a9 ff		lda #$ff	                lda #$FF
.9e66	85 27		sta $27		                sta tmp2+1
.9e68	80 07		bra $9e71	                bra _next_character
.9e6a					_regular_char:
.9e6a	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e6c	f0 0c		beq $9e7a	                beq _found_string_end
.9e6e					_save_character:
.9e6e	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.9e71					_next_character:
.9e71	e6 0c		inc $0c		                inc toin
.9e73	d0 02		bne $9e77	                bne _savechars_loop_longjump
.9e75	e6 0d		inc $0d		                inc toin+1
.9e77					_savechars_loop_longjump:
.9e77	4c 9b 9d	jmp $9d9b	                jmp _savechars_loop
.9e7a					_found_string_end:
.9e7a	e6 0c		inc $0c		                inc toin
.9e7c	d0 02		bne $9e80	                bne +
.9e7e	e6 0d		inc $0d		                inc toin+1
.9e80					+
.9e80	a5 00		lda $00		                lda cp
.9e82	38		sec		                sec
.9e83	f5 02		sbc $02,x	                sbc 2,x
.9e85	95 00		sta $00,x	                sta 0,x         ; LSB
.9e87	a5 01		lda $01		                lda cp+1
.9e89	f5 03		sbc $03,x	                sbc 3,x
.9e8b	95 01		sta $01,x	                sta 1,x         ; MSB
.9e8d	b5 02		lda $02,x	                lda 2,x
.9e8f	38		sec		                sec
.9e90	e9 02		sbc #$02	                sbc #2
.9e92	85 24		sta $24		                sta tmp1
.9e94	b5 03		lda $03,x	                lda 3,x
.9e96	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e98	85 25		sta $25		                sta tmp1+1
.9e9a	a5 00		lda $00		                lda cp
.9e9c	92 24		sta ($24)	                sta (tmp1)
.9e9e	a0 01		ldy #$01	                ldy #1
.9ea0	a5 01		lda $01		                lda cp+1
.9ea2	91 24		sta ($24),y	                sta (tmp1),y
.9ea4	a5 16		lda $16		                lda state
.9ea6	05 17		ora $17		                ora state+1             ; paranoid
.9ea8	f0 03		beq $9ead	                beq _done
.9eaa	20 91 a0	jsr $a091	                jsr sliteral_const_str         ; ( addr u -- )
.9ead					_done:
.9ead	60		rts		z_s_quote:      rts
.9eae					xt_s_to_d:
.9eae	20 2e d9	jsr $d92e	                jsr underflow_1
.9eb1	ca		dex		                dex
.9eb2	ca		dex		                dex
.9eb3	74 00		stz $00,x	                stz 0,x
.9eb5	74 01		stz $01,x	                stz 1,x
.9eb7	b5 03		lda $03,x	                lda 3,x
.9eb9	10 04		bpl $9ebf	                bpl _done
.9ebb	d6 00		dec $00,x	                dec 0,x
.9ebd	d6 01		dec $01,x	                dec 1,x
.9ebf					_done:
.9ebf	60		rts		z_s_to_d:       rts
.9ec0					xt_save_buffers:
.9ec0	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ec2	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9ec4	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9ec6	d0 12		bne $9eda	                bne _done       ; Either not used or not dirty = done!
.9ec8	20 cf 83	jsr $83cf	                jsr xt_blkbuffer
.9ecb	20 c1 85	jsr $85c1	                jsr xt_buffblocknum
.9ece	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.9ed1	20 7c 85	jsr $857c	                jsr xt_block_write
.9ed4	a9 01		lda #$01	                lda #1
.9ed6	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ed8	91 1e		sta ($1e),y	                sta (up),y
.9eda					_done:
.9eda	60		rts		z_save_buffers: rts
.9edb					xt_scr:
.9edb	ca		dex		                dex
.9edc	ca		dex		                dex
.9edd	18		clc		                clc
.9ede	a5 1e		lda $1e		                lda up
.9ee0	69 02		adc #$02	                adc #scr_offset ; Add offset
.9ee2	95 00		sta $00,x	                sta 0,x
.9ee4	a5 1f		lda $1f		                lda up+1
.9ee6	69 00		adc #$00	                adc #0          ; Adding carry
.9ee8	95 01		sta $01,x	                sta 1,x
.9eea	60		rts		z_scr:          rts
.9eeb					xt_search:
.9eeb	20 3d d9	jsr $d93d	                jsr underflow_4
.9eee	b5 00		lda $00,x	                lda 0,x
.9ef0	15 01		ora $01,x	                ora 1,x
.9ef2	d0 0b		bne $9eff	                bne _start_search
.9ef4	e8		inx		                inx             ; Remove u2
.9ef5	e8		inx		                inx
.9ef6	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ef8	95 00		sta $00,x	                sta 0,x
.9efa	95 01		sta $01,x	                sta 1,x
.9efc	4c 89 9f	jmp $9f89	                jmp z_search
.9eff					_start_search:
.9eff	20 aa a7	jsr $a7aa	                jsr xt_zero
.9f02					_search_loop:
.9f02	18		clc		                clc
.9f03	b5 00		lda $00,x	                lda 0,x
.9f05	75 02		adc $02,x	                adc 2,x
.9f07	85 24		sta $24		                sta tmp1
.9f09	b5 01		lda $01,x	                lda 1,x
.9f0b	75 03		adc $03,x	                adc 3,x
.9f0d	d5 07		cmp $07,x	                cmp 7,x
.9f0f	90 12		bcc $9f23	                bcc _init_comparison ; Obviously less
.9f11	d0 06		bne $9f19	                bne _not_found
.9f13	b5 06		lda $06,x	                lda 6,x
.9f15	c5 24		cmp $24		                cmp tmp1
.9f17	b0 0a		bcs $9f23	                bcs _init_comparison
.9f19					_not_found:
.9f19	e8		inx		                inx             ; Remove offset
.9f1a	e8		inx		                inx
.9f1b	e8		inx		                inx             ; Remove u2
.9f1c	e8		inx		                inx
.9f1d	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9f1f	74 01		stz $01,x	                stz 1,x
.9f21	80 66		bra $9f89	                bra z_search
.9f23					_init_comparison:
.9f23	18		clc		                clc
.9f24	b5 08		lda $08,x	                lda 8,x
.9f26	75 00		adc $00,x	                adc 0,x
.9f28	85 24		sta $24		                sta tmp1
.9f2a	b5 09		lda $09,x	                lda 9,x
.9f2c	75 01		adc $01,x	                adc 1,x
.9f2e	85 25		sta $25		                sta tmp1+1
.9f30	b5 04		lda $04,x	                lda 4,x
.9f32	85 26		sta $26		                sta tmp2
.9f34	b5 05		lda $05,x	                lda 5,x
.9f36	85 27		sta $27		                sta tmp2+1
.9f38	b5 02		lda $02,x	                lda 2,x
.9f3a	85 28		sta $28		                sta tmp3
.9f3c	b5 03		lda $03,x	                lda 3,x
.9f3e	85 29		sta $29		                sta tmp3+1
.9f40					_comparison_loop:
.9f40	b2 24		lda ($24)	                lda (tmp1)
.9f42	d2 26		cmp ($26)	                cmp (tmp2)
.9f44	f0 05		beq $9f4b	                beq _letters_match
.9f46	20 4e 98	jsr $984e	                jsr xt_one_plus
.9f49	80 b7		bra $9f02	                bra _search_loop
.9f4b					_letters_match:
.9f4b	e6 24		inc $24		                inc tmp1
.9f4d	d0 02		bne $9f51	                bne +
.9f4f	e6 25		inc $25		                inc tmp1+1
.9f51					+
.9f51	e6 26		inc $26		                inc tmp2
.9f53	d0 02		bne $9f57	                bne +
.9f55	e6 27		inc $27		                inc tmp2+1
.9f57					+
.9f57	a5 28		lda $28		                lda tmp3
.9f59	d0 02		bne $9f5d	                bne +
.9f5b	c6 29		dec $29		                dec tmp3+1
.9f5d					+
.9f5d	c6 28		dec $28		                dec tmp3
.9f5f	a5 28		lda $28		                lda tmp3
.9f61	05 29		ora $29		                ora tmp3+1
.9f63	d0 db		bne $9f40	                bne _comparison_loop ; Check the next letter
.9f65	18		clc		                clc
.9f66	b5 00		lda $00,x	                lda 0,x
.9f68	75 08		adc $08,x	                adc 8,x
.9f6a	95 08		sta $08,x	                sta 8,x
.9f6c	b5 01		lda $01,x	                lda 1,x
.9f6e	75 09		adc $09,x	                adc 9,x
.9f70	95 09		sta $09,x	                sta 9,x
.9f72	38		sec		                sec
.9f73	b5 06		lda $06,x	                lda 6,x
.9f75	f5 00		sbc $00,x	                sbc 0,x
.9f77	95 06		sta $06,x	                sta 6,x
.9f79	b5 07		lda $07,x	                lda 7,x
.9f7b	f5 01		sbc $01,x	                sbc 1,x
.9f7d	95 07		sta $07,x	                sta 7,x
.9f7f	e8		inx		                inx             ; drop offset
.9f80	e8		inx		                inx
.9f81	e8		inx		                inx             ; drop u2
.9f82	e8		inx		                inx
.9f83	a9 ff		lda #$ff	                lda #$FF
.9f85	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f87	95 01		sta $01,x	                sta 1,x
.9f89	60		rts		z_search:       rts
.9f8a					xt_semicolon:
.9f8a	24 20		bit $20		                bit status
.9f8c	70 11		bvs $9f9f	                bvs _colonword
.9f8e	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f90	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.9f93	ca		dex		                dex
.9f94	ca		dex		                dex
.9f95	a5 04		lda $04		                lda workword
.9f97	95 00		sta $00,x	                sta 0,x
.9f99	a5 05		lda $05		                lda workword+1
.9f9b	95 01		sta $01,x	                sta 1,x
.9f9d	80 45		bra $9fe4	                bra _semicolon_done
.9f9f					_colonword:
.9f9f	a0 06		ldy #$06	                ldy #6
.9fa1	a5 00		lda $00		                lda cp
.9fa3	91 04		sta ($04),y	                sta (workword),y
.9fa5	c8		iny		                iny
.9fa6	a5 01		lda $01		                lda cp+1
.9fa8	91 04		sta ($04),y	                sta (workword),y
.9faa	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9fac	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.9faf	24 20		bit $20		                bit status
.9fb1	10 26		bpl $9fd9	                bpl _new_word   ; Bit 7 is clear = new word
.9fb3	ca		dex		                dex
.9fb4	ca		dex		                dex
.9fb5	ca		dex		                dex
.9fb6	ca		dex		                dex
.9fb7	b2 04		lda ($04)	                lda (workword)
.9fb9	95 00		sta $00,x	                sta 0,x
.9fbb	74 01		stz $01,x	                stz 1,x
.9fbd	a5 04		lda $04		                lda workword
.9fbf	18		clc		                clc
.9fc0	69 08		adc #$08	                adc #8
.9fc2	95 02		sta $02,x	                sta 2,x
.9fc4	a5 05		lda $05		                lda workword+1
.9fc6	69 00		adc #$00	                adc #0                  ; only want carry
.9fc8	95 03		sta $03,x	                sta 3,x
.9fca	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9fcc	20 6a d9	jsr $d96a	                jsr print_string_no_lf
.9fcf	20 05 a5	jsr $a505	                jsr xt_type
.9fd2	20 20 a1	jsr $a120	                jsr xt_space
.9fd5	a9 80		lda #$80	                lda #%10000000
.9fd7	14 20		trb $20		                trb status
.9fd9					_new_word:
.9fd9	a5 04		lda $04		                lda workword
.9fdb	85 02		sta $02		                sta dp
.9fdd	a5 05		lda $05		                lda workword+1
.9fdf	85 03		sta $03		                sta dp+1
.9fe1	20 76 d8	jsr $d876	                jsr dp_to_current       ; Save the updated DP to the
.9fe4					_semicolon_done:
.9fe4	64 16		stz $16		                stz state
.9fe6	64 17		stz $17		                stz state+1
.9fe8	60		rts		z_semicolon:    rts
.9fe9					xt_sign:
.9fe9	20 2e d9	jsr $d92e	                jsr underflow_1
.9fec	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9fee	30 04		bmi $9ff4	                bmi _minus
.9ff0	e8		inx		                inx
.9ff1	e8		inx		                inx
.9ff2	80 09		bra $9ffd	                bra _done
.9ff4					_minus:
.9ff4	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9ff6	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9ff8	74 01		stz $01,x	                stz 1,x         ; paranoid
.9ffa	20 f3 91	jsr $91f3	                jsr xt_hold
.9ffd					_done:
.9ffd	60		rts		z_sign:         rts
.9ffe					xt_slash:
.9ffe	a9 00		lda #$00	                lda #0
.a000	48		pha		                pha
.a001	80 03		bra $a006	                bra slashmod_common
.a003					xt_slash_mod:
.a003	a9 ff		lda #$ff	                lda #$FF
.a005	48		pha		                pha             ; falls through to _common
.a006					slashmod_common:
.a006	20 72 a3	jsr $a372	                jsr xt_to_r             ; >R
.a009	20 ae 9e	jsr $9eae	                jsr xt_s_to_d           ; S>D
.a00c	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; R>
.a00f	20 d7 a0	jsr $a0d7	                jsr xt_sm_slash_rem     ; SM/REM
.a012	68		pla		                pla
.a013	d0 05		bne $a01a	                bne _done
.a015	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a018	e8		inx		                inx             ; DROP
.a019	e8		inx		                inx
.a01a					_done:
.a01a					z_slash_mod:
.a01a	60		rts		z_slash:        rts
.a01b					xt_slash_string:
.a01b	20 38 d9	jsr $d938	                jsr underflow_3
.a01e	18		clc		                clc             ; 3OS+TOS
.a01f	b5 00		lda $00,x	                lda 0,x
.a021	75 04		adc $04,x	                adc 4,x
.a023	95 04		sta $04,x	                sta 4,x
.a025	b5 01		lda $01,x	                lda 1,x
.a027	75 05		adc $05,x	                adc 5,x
.a029	95 05		sta $05,x	                sta 5,x
.a02b	38		sec		                sec             ; NOS-TOS
.a02c	b5 02		lda $02,x	                lda 2,x
.a02e	f5 00		sbc $00,x	                sbc 0,x
.a030	95 02		sta $02,x	                sta 2,x
.a032	b5 03		lda $03,x	                lda 3,x
.a034	f5 01		sbc $01,x	                sbc 1,x
.a036	95 03		sta $03,x	                sta 3,x
.a038	e8		inx		                inx
.a039	e8		inx		                inx
.a03a	60		rts		z_slash_string: rts
.a03b					xt_sliteral:
.a03b	20 33 d9	jsr $d933	                jsr underflow_2
.a03e	a9 4c		lda #$4c	                lda #$4C
.a040	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.a043	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.a046	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.a049	8a		txa		                txa
.a04a	38		sec		                sec
.a04b	e9 06		sbc #$06	                sbc #6
.a04d	aa		tax		                tax
.a04e	b5 08		lda $08,x	                lda 8,x
.a050	95 04		sta $04,x	                sta 4,x
.a052	b5 09		lda $09,x	                lda 9,x
.a054	95 05		sta $05,x	                sta 5,x
.a056	b5 06		lda $06,x	                lda 6,x
.a058	95 00		sta $00,x	                sta 0,x
.a05a	b5 07		lda $07,x	                lda 7,x
.a05c	95 01		sta $01,x	                sta 1,x
.a05e	a5 00		lda $00		                lda cp
.a060	95 08		sta $08,x	                sta 8,x
.a062	95 02		sta $02,x	                sta 2,x
.a064	a5 01		lda $01		                lda cp+1
.a066	95 09		sta $09,x	                sta 9,x
.a068	95 03		sta $03,x	                sta 3,x
.a06a	20 f3 95	jsr $95f3	                jsr xt_move
.a06d	18		clc		                clc
.a06e	a5 00		lda $00		                lda cp
.a070	75 00		adc $00,x	                adc 0,x
.a072	85 00		sta $00		                sta cp
.a074	a5 01		lda $01		                lda cp+1
.a076	75 01		adc $01,x	                adc 1,x
.a078	85 01		sta $01		                sta cp+1
.a07a	b5 02		lda $02,x	                lda 2,x
.a07c	38		sec		                sec
.a07d	e9 02		sbc #$02	                sbc #2
.a07f	85 24		sta $24		                sta tmp1
.a081	b5 03		lda $03,x	                lda 3,x
.a083	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a085	85 25		sta $25		                sta tmp1+1
.a087	a5 00		lda $00		                lda cp
.a089	92 24		sta ($24)	                sta (tmp1)
.a08b	a0 01		ldy #$01	                ldy #1
.a08d	a5 01		lda $01		                lda cp+1
.a08f	91 24		sta ($24),y	                sta (tmp1),y
.a091					sliteral_const_str:
.a091	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a093	a9 ab		lda #$ab	                lda #<sliteral_runtime
.a095	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.a098	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a09a	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a09c	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.a09f	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a0a1	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a0a3	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.a0a6	e8		inx		                inx
.a0a7	e8		inx		                inx
.a0a8	e8		inx		                inx
.a0a9	e8		inx		                inx
.a0aa	60		rts		z_sliteral:     rts
.a0ab					sliteral_runtime:
.a0ab	ca		dex		                dex
.a0ac	ca		dex		                dex
.a0ad	ca		dex		                dex
.a0ae	ca		dex		                dex
.a0af	68		pla		                pla
.a0b0	85 24		sta $24		                sta tmp1        ; LSB of address
.a0b2	68		pla		                pla
.a0b3	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a0b5	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a0b7	b1 24		lda ($24),y	                lda (tmp1),y
.a0b9	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a0bb	c8		iny		                iny
.a0bc	b1 24		lda ($24),y	                lda (tmp1),y
.a0be	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a0c0	c8		iny		                iny
.a0c1	b1 24		lda ($24),y	                lda (tmp1),y
.a0c3	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a0c5	c8		iny		                iny
.a0c6	b1 24		lda ($24),y	                lda (tmp1),y
.a0c8	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a0ca	18		clc		                clc
.a0cb	a5 24		lda $24		                lda tmp1
.a0cd	69 04		adc #$04	                adc #4
.a0cf	a8		tay		                tay             ; LSB
.a0d0	a5 25		lda $25		                lda tmp1+1
.a0d2	69 00		adc #$00	                adc #0          ; we only need carry
.a0d4	48		pha		                pha             ; MSB
.a0d5	5a		phy		                phy
.a0d6	60		rts		                rts
.a0d7					xt_sm_slash_rem:
.a0d7	20 38 d9	jsr $d938	                jsr underflow_3 ; contains double number
.a0da	b5 03		lda $03,x	                lda 3,x
.a0dc	48		pha		                pha
.a0dd	b5 01		lda $01,x	                lda 1,x
.a0df	55 03		eor $03,x	                eor 3,x
.a0e1	48		pha		                pha
.a0e2	20 33 81	jsr $8133	                jsr xt_abs
.a0e5	e8		inx		                inx             ; pretend we pushed n1 to R
.a0e6	e8		inx		                inx
.a0e7	20 a2 8a	jsr $8aa2	                jsr xt_dabs
.a0ea	ca		dex		                dex
.a0eb	ca		dex		                dex
.a0ec	20 bc a5	jsr $a5bc	                jsr xt_um_slash_mod     ; UM/MOD
.a0ef	68		pla		                pla
.a0f0	10 03		bpl $a0f5	                bpl +
.a0f2	20 54 96	jsr $9654	                jsr xt_negate
.a0f5					+
.a0f5	68		pla		                pla
.a0f6	10 07		bpl $a0ff	                bpl _done
.a0f8	e8		inx		                inx             ; pretend we pushed quotient to R
.a0f9	e8		inx		                inx
.a0fa	20 54 96	jsr $9654	                jsr xt_negate
.a0fd	ca		dex		                dex
.a0fe	ca		dex		                dex
.a0ff					_done:
.a0ff	60		rts		z_sm_slash_rem: rts
.a100					xt_source:
.a100	ca		dex		                dex
.a101	ca		dex		                dex
.a102	a5 08		lda $08		                lda cib
.a104	95 00		sta $00,x	                sta 0,x
.a106	a5 09		lda $09		                lda cib+1
.a108	95 01		sta $01,x	                sta 1,x
.a10a	ca		dex		                dex
.a10b	ca		dex		                dex
.a10c	a5 0a		lda $0a		                lda ciblen
.a10e	95 00		sta $00,x	                sta 0,x
.a110	a5 0b		lda $0b		                lda ciblen+1
.a112	95 01		sta $01,x	                sta 1,x
.a114	60		rts		z_source:       rts
.a115					xt_source_id:
.a115	ca		dex		                dex
.a116	ca		dex		                dex
.a117	a5 06		lda $06		                lda insrc
.a119	95 00		sta $00,x	                sta 0,x
.a11b	a5 07		lda $07		                lda insrc+1
.a11d	95 01		sta $01,x	                sta 1,x
.a11f	60		rts		z_source_id:    rts
.a120					xt_space:
.a120	a9 20		lda #$20	                lda #AscSP
.a122	20 12 8e	jsr $8e12	                jsr emit_a
.a125	60		rts		z_space:        rts
.a126					xt_spaces:
.a126	20 2e d9	jsr $d92e	                jsr underflow_1
.a129	20 aa a7	jsr $a7aa	                jsr xt_zero
.a12c	20 49 95	jsr $9549	                jsr xt_max
.a12f	b5 00		lda $00,x	                lda 0,x
.a131	15 01		ora $01,x	                ora 1,x
.a133	f0 2a		beq $a15f	                beq _done
.a135	b4 01		ldy $01,x	                ldy 1,x
.a137	d0 0c		bne $a145	                bne _lots_of_spaces
.a139	b4 00		ldy $00,x	                ldy 0,x
.a13b					_quick_loop:
.a13b	a9 20		lda #$20	                lda #AscSP
.a13d	20 12 8e	jsr $8e12	                jsr emit_a
.a140	88		dey		                dey
.a141	f0 1c		beq $a15f	                beq _done
.a143	80 f6		bra $a13b	                bra _quick_loop
.a145					_lots_of_spaces:
.a145	b4 00		ldy $00,x	                ldy 0,x
.a147					_first_slow_loop:
.a147	f0 08		beq $a151	                beq _slow_outer_loop
.a149	a9 20		lda #$20	                lda #AscSP
.a14b	20 12 8e	jsr $8e12	                jsr emit_a
.a14e	88		dey		                dey
.a14f	80 f6		bra $a147	                bra _first_slow_loop
.a151					_slow_outer_loop:
.a151	a0 00		ldy #$00	                ldy #00
.a153					_slow_inner_loop:
.a153	a9 20		lda #$20	                lda #AscSP
.a155	20 12 8e	jsr $8e12	                jsr emit_a
.a158	88		dey		                dey
.a159	d0 f8		bne $a153	                bne _slow_inner_loop
.a15b	d6 01		dec $01,x	                dec 1,x
.a15d	d0 f2		bne $a151	                bne _slow_outer_loop
.a15f					_done:
.a15f	e8		inx		                inx             ; drop
.a160	e8		inx		                inx
.a161	60		rts		z_spaces:       rts
.a162					xt_star:
.a162	20 33 d9	jsr $d933	                jsr underflow_2
.a165	20 fe a5	jsr $a5fe	                jsr xt_um_star
.a168	e8		inx		                inx
.a169	e8		inx		                inx
.a16a	60		rts		z_star:         rts
.a16b					xt_star_slash:
.a16b	20 74 a1	jsr $a174	                jsr xt_star_slash_mod
.a16e	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a171	e8		inx		                inx
.a172	e8		inx		                inx
.a173					z_star_slash:
.a173	60		rts		                rts
.a174					xt_star_slash_mod:
.a174	20 38 d9	jsr $d938	                jsr underflow_3
.a177	20 72 a3	jsr $a372	                jsr xt_to_r
.a17a	20 bf 94	jsr $94bf	                jsr xt_m_star
.a17d	20 c3 9a	jsr $9ac3	                jsr xt_r_from
.a180	20 d7 a0	jsr $a0d7	                jsr xt_sm_slash_rem
.a183					z_star_slash_mod:
.a183	60		rts		                rts
.a184					xt_state:
.a184	ca		dex		                dex
.a185	ca		dex		                dex
.a186	a9 16		lda #$16	                lda #<state
.a188	95 00		sta $00,x	                sta 0,x
.a18a	a9 00		lda #$00	                lda #>state
.a18c	95 01		sta $01,x	                sta 1,x
.a18e	60		rts		z_state:        rts
.a18f					xt_store:
.a18f	20 33 d9	jsr $d933	                jsr underflow_2
.a192	b5 02		lda $02,x	                lda 2,x         ; LSB
.a194	81 00		sta ($00,x)	                sta (0,x)
.a196	f6 00		inc $00,x	                inc 0,x
.a198	d0 02		bne $a19c	                bne +
.a19a	f6 01		inc $01,x	                inc 1,x
.a19c					+
.a19c	b5 03		lda $03,x	                lda 3,x         ; MSB
.a19e	81 00		sta ($00,x)	                sta (0,x)
.a1a0	e8		inx		                inx             ; 2DROP
.a1a1	e8		inx		                inx
.a1a2	e8		inx		                inx
.a1a3	e8		inx		                inx
.a1a4	60		rts		z_store:        rts
.a1a5					xt_strip_underflow:
.a1a5	ca		dex		                dex
.a1a6	ca		dex		                dex
.a1a7	a9 1c		lda #$1c	                lda #<uf_strip
.a1a9	95 00		sta $00,x	                sta 0,x
.a1ab	a9 00		lda #$00	                lda #>uf_strip
.a1ad	95 01		sta $01,x	                sta 1,x
.a1af					z_strip_underflow:
.a1af	60		rts		                rts
.a1b0					xt_swap:
.a1b0	20 33 d9	jsr $d933	                jsr underflow_2
.a1b3	b5 00		lda $00,x	                lda 0,x         ; LSB
.a1b5	b4 02		ldy $02,x	                ldy 2,x
.a1b7	95 02		sta $02,x	                sta 2,x
.a1b9	94 00		sty $00,x	                sty 0,x
.a1bb	b5 01		lda $01,x	                lda 1,x         ; MSB
.a1bd	b4 03		ldy $03,x	                ldy 3,x
.a1bf	95 03		sta $03,x	                sta 3,x
.a1c1	94 01		sty $01,x	                sty 1,x
.a1c3	60		rts		z_swap:         rts
.a1c4					xt_then:
.a1c4	20 8e 91	jsr $918e	                jsr xt_here
.a1c7	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a1ca	20 8f a1	jsr $a18f	                jsr xt_store
.a1cd	60		rts		z_then:         rts
.a1ce					xt_thru:
.a1ce	20 33 d9	jsr $d933	                jsr underflow_2
.a1d1	b5 01		lda $01,x	                lda 1,x
.a1d3	48		pha		                pha
.a1d4	b5 00		lda $00,x	                lda 0,x
.a1d6	48		pha		                pha
.a1d7	e8		inx		                inx
.a1d8	e8		inx		                inx
.a1d9					_thru_loop:
.a1d9	b5 01		lda $01,x	                lda 1,x
.a1db	48		pha		                pha
.a1dc	b5 00		lda $00,x	                lda 0,x
.a1de	48		pha		                pha
.a1df	20 e8 93	jsr $93e8	                jsr xt_load
.a1e2	68		pla		                pla
.a1e3	85 24		sta $24		                sta tmp1
.a1e5	68		pla		                pla
.a1e6	85 25		sta $25		                sta tmp1+1
.a1e8	68		pla		                pla
.a1e9	85 26		sta $26		                sta tmp2
.a1eb	68		pla		                pla
.a1ec	85 27		sta $27		                sta tmp2+1
.a1ee	c5 25		cmp $25		                cmp tmp1+1
.a1f0	d0 08		bne $a1fa	                bne _next_screen
.a1f2	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a1f4	c5 24		cmp $24		                cmp tmp1
.a1f6	d0 02		bne $a1fa	                bne _next_screen
.a1f8	80 18		bra $a212	                bra _done       ; We just did the last screen.
.a1fa					_next_screen:
.a1fa	a5 27		lda $27		                lda tmp2+1
.a1fc	48		pha		                pha
.a1fd	a5 26		lda $26		                lda tmp2
.a1ff	48		pha		                pha
.a200	e6 24		inc $24		                inc tmp1
.a202	d0 02		bne $a206	                bne +
.a204	e6 25		inc $25		                inc tmp1+1
.a206					+
.a206	ca		dex		                dex
.a207	ca		dex		                dex
.a208	a5 24		lda $24		                lda tmp1
.a20a	95 00		sta $00,x	                sta 0,x
.a20c	a5 25		lda $25		                lda tmp1+1
.a20e	95 01		sta $01,x	                sta 1,x
.a210	80 c7		bra $a1d9	                bra _thru_loop
.a212					_done:
.a212	60		rts		z_thru:         rts
.a213					xt_tick:
.a213	20 10 99	jsr $9910	                jsr xt_parse_name       ; ( -- addr u )
.a216	b5 00		lda $00,x	                lda 0,x
.a218	15 01		ora $01,x	                ora 1,x
.a21a	d0 05		bne $a221	                bne +
.a21c	a9 05		lda #$05	                lda #err_noname
.a21e	4c 44 d9	jmp $d944	                jmp error
.a221					+
.a221	20 f7 8f	jsr $8ff7	                jsr xt_find_name        ; ( addr u -- nt )
.a224	b5 00		lda $00,x	                lda 0,x
.a226	15 01		ora $01,x	                ora 1,x
.a228	d0 05		bne $a22f	                bne +
.a22a	a9 08		lda #$08	                lda #err_syntax
.a22c	4c 44 d9	jmp $d944	                jmp error
.a22f					+
.a22f	20 12 96	jsr $9612	                jsr xt_name_to_int      ; ( nt -- xt )
.a232	60		rts		z_tick:         rts
.a233					xt_to:
.a233	20 13 a2	jsr $a213	                jsr xt_tick             ; ( [n] xt )
.a236	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a238	18		clc		                clc
.a239	69 03		adc #$03	                adc #3
.a23b	85 24		sta $24		                sta tmp1
.a23d	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a23f	69 00		adc #$00	                adc #0                  ; we just want the carry
.a241	85 25		sta $25		                sta tmp1+1
.a243	e8		inx		                inx
.a244	e8		inx		                inx                     ; ( [n] )
.a245	a5 16		lda $16		                lda state
.a247	05 17		ora $17		                ora state+1
.a249	f0 34		beq $a27f	                beq _interpret
.a24b	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a24d	a9 b5		lda #$b5	                lda #$B5
.a24f	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.a252	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a254	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.a257	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a259	a5 24		lda $24		                lda tmp1
.a25b	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.a25e	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a260	a9 b5		lda #$b5	                lda #$B5
.a262	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.a265	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a267	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.a26a	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a26c	d0 02		bne $a270	                bne +
.a26e	e6 25		inc $25		                inc tmp1+1
.a270					+
.a270	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a272	a5 24		lda $24		                lda tmp1
.a274	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.a277	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a279	98		tya		                tya
.a27a	20 d0 d7	jsr $d7d0	                jsr cmpl_word
.a27d	80 0f		bra $a28e	                bra _done
.a27f					_interpret:
.a27f	20 2e d9	jsr $d92e	                jsr underflow_1
.a282	b5 00		lda $00,x	                lda 0,x
.a284	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a286	a0 01		ldy #$01	                ldy #1
.a288	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a28a	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a28c	e8		inx		                inx                     ; DROP
.a28d	e8		inx		                inx
.a28e					_done:
.a28e	60		rts		z_to:           rts
.a28f					xt_to_body:
.a28f	20 2e d9	jsr $d92e	                jsr underflow_1
.a292	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( xt xt )
.a295	20 94 92	jsr $9294	                jsr xt_int_to_name      ; ( xt nt )
.a298	f6 00		inc $00,x	                inc 0,x
.a29a	d0 02		bne $a29e	                bne +
.a29c	f6 01		inc $01,x	                inc 1,x
.a29e					+
.a29e	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a2a0	29 20		and #$20	                and #HC
.a2a2	f0 0d		beq $a2b1	                beq _no_cfa
.a2a4	18		clc		                clc
.a2a5	b5 02		lda $02,x	                lda 2,x         ; LSB
.a2a7	69 03		adc #$03	                adc #3
.a2a9	95 02		sta $02,x	                sta 2,x
.a2ab	b5 03		lda $03,x	                lda 3,x         ; MSB
.a2ad	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a2af	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a2b1					_no_cfa:
.a2b1	e8		inx		                inx             ; get rid of the nt
.a2b2	e8		inx		                inx
.a2b3					_done:
.a2b3	60		rts		z_to_body:      rts
.a2b4					xt_to_in:
.a2b4	ca		dex		                dex
.a2b5	ca		dex		                dex
.a2b6	a9 0c		lda #$0c	                lda #<toin
.a2b8	95 00		sta $00,x	                sta 0,x
.a2ba	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a2bc	95 01		sta $01,x	                sta 1,x
.a2be	60		rts		z_to_in:        rts
.a2bf					xt_to_number:
.a2bf	20 3d d9	jsr $d93d	                jsr underflow_4
.a2c2	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a2c4	85 36		sta $36		                sta scratch
.a2c6	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a2c8	85 37		sta $37		                sta scratch+1
.a2ca	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a2cc	85 38		sta $38		                sta scratch+2
.a2ce	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a2d0	85 39		sta $39		                sta scratch+3
.a2d2	ca		dex		                dex
.a2d3	ca		dex		                dex
.a2d4					_loop:
.a2d4	a1 04		lda ($04,x)	                lda (4,x)
.a2d6	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a2d8	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2da	20 21 8b	jsr $8b21	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a2dd	b5 00		lda $00,x	                lda 0,x
.a2df	d0 04		bne $a2e5	                bne _digit_ok
.a2e1	e8		inx		                inx
.a2e2	e8		inx		                inx
.a2e3	80 67		bra $a34c	                bra _done       ; ( ud-lo ud-hi addr u char )
.a2e5					_digit_ok:
.a2e5	b5 02		lda $02,x	                lda 2,x
.a2e7	85 3a		sta $3a		                sta scratch+4
.a2e9	b5 03		lda $03,x	                lda 3,x
.a2eb	85 3b		sta $3b		                sta scratch+5
.a2ed	a5 38		lda $38		                lda scratch+2
.a2ef	95 02		sta $02,x	                sta 2,x         ; NOS
.a2f1	a5 39		lda $39		                lda scratch+3
.a2f3	95 03		sta $03,x	                sta 3,x
.a2f5	a5 18		lda $18		                lda base
.a2f7	95 00		sta $00,x	                sta 0,x         ; TOS
.a2f9	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a2fb	20 fe a5	jsr $a5fe	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2fe	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a300	85 3c		sta $3c		                sta scratch+6
.a302	b5 03		lda $03,x	                lda 3,x
.a304	85 3d		sta $3d		                sta scratch+7
.a306	a5 36		lda $36		                lda scratch
.a308	95 02		sta $02,x	                sta 2,x
.a30a	a5 37		lda $37		                lda scratch+1
.a30c	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a30e	a5 18		lda $18		                lda base
.a310	95 00		sta $00,x	                sta 0,x
.a312	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a314	20 fe a5	jsr $a5fe	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a317	b5 00		lda $00,x	                lda 0,x
.a319	85 38		sta $38		                sta scratch+2
.a31b	b5 01		lda $01,x	                lda 1,x
.a31d	85 39		sta $39		                sta scratch+3
.a31f	b5 02		lda $02,x	                lda 2,x
.a321	85 36		sta $36		                sta scratch
.a323	b5 03		lda $03,x	                lda 3,x
.a325	85 37		sta $37		                sta scratch+1
.a327	18		clc		                clc
.a328	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a32a	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a32c	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a32e	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a330	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a332	85 37		sta $37		                sta scratch+1
.a334	a5 38		lda $38		                lda scratch+2   ; LSB
.a336	65 3c		adc $3c		                adc scratch+6
.a338	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a33a	a5 39		lda $39		                lda scratch+3   ; MSB
.a33c	65 3d		adc $3d		                adc scratch+7
.a33e	85 39		sta $39		                sta scratch+3
.a340	e8		inx		                inx
.a341	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a342	f6 04		inc $04,x	                inc 4,x
.a344	d0 02		bne $a348	                bne +
.a346	f6 05		inc $05,x	                inc 5,x
.a348					+
.a348	d6 02		dec $02,x	                dec 2,x
.a34a	d0 88		bne $a2d4	                bne _loop
.a34c					_done:
.a34c	e8		inx		                inx
.a34d	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a34e	a5 36		lda $36		                lda scratch     ; new ud-lo
.a350	95 06		sta $06,x	                sta 6,x
.a352	a5 37		lda $37		                lda scratch+1
.a354	95 07		sta $07,x	                sta 7,x
.a356	a5 38		lda $38		                lda scratch+2
.a358	95 04		sta $04,x	                sta 4,x
.a35a	a5 39		lda $39		                lda scratch+3
.a35c	95 05		sta $05,x	                sta 5,x
.a35e	60		rts		z_to_number:    rts
.a35f					xt_to_order:
.a35f	20 72 a3	jsr $a372	                jsr xt_to_r
.a362	20 50 91	jsr $9150	                jsr xt_get_order
.a365	20 c3 9a	jsr $9ac3	                jsr xt_r_from
.a368	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a36b	20 4e 98	jsr $984e	                jsr xt_one_plus
.a36e	20 4c 9d	jsr $9d4c	                jsr xt_set_order
.a371	60		rts		z_to_order:     rts
.a372					xt_to_r:
.a372	68		pla		                pla             ; LSB
.a373	85 2c		sta $2c		                sta tmptos
.a375	7a		ply		                ply             ; MSB
.a376	20 2e d9	jsr $d92e	                jsr underflow_1
.a379	b5 01		lda $01,x	                lda 1,x         ; MSB
.a37b	48		pha		                pha
.a37c	b5 00		lda $00,x	                lda 0,x         ; LSB
.a37e	48		pha		                pha
.a37f	e8		inx		                inx
.a380	e8		inx		                inx
.a381	5a		phy		                phy             ; MSB
.a382	a5 2c		lda $2c		                lda tmptos
.a384	48		pha		                pha             ; LSB
.a385	60		rts		z_to_r:         rts
.a386					xt_true:
.a386	ca		dex		                dex
.a387	ca		dex		                dex
.a388	a9 ff		lda #$ff	                lda #$FF
.a38a	95 00		sta $00,x	                sta 0,x
.a38c	95 01		sta $01,x	                sta 1,x
.a38e	60		rts		z_true:         rts
.a38f					xt_tuck:
.a38f	20 33 d9	jsr $d933	                jsr underflow_2
.a392	ca		dex		                dex
.a393	ca		dex		                dex
.a394	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a396	b5 02		lda $02,x	                lda 2,x
.a398	95 04		sta $04,x	                sta 4,x
.a39a	94 02		sty $02,x	                sty 2,x
.a39c	95 00		sta $00,x	                sta 0,x
.a39e	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a3a0	b5 03		lda $03,x	                lda 3,x
.a3a2	95 05		sta $05,x	                sta 5,x
.a3a4	94 03		sty $03,x	                sty 3,x         ; bba
.a3a6	95 01		sta $01,x	                sta 1,x         ; baa
.a3a8	60		rts		z_tuck:         rts
.a3a9					xt_assembler_wordlist:
.a3a9					xt_two:
.a3a9	ca		dex		                dex
.a3aa	ca		dex		                dex
.a3ab	a9 02		lda #$02	                lda #2
.a3ad	95 00		sta $00,x	                sta 0,x
.a3af	74 01		stz $01,x	                stz 1,x
.a3b1					z_assembler_wordlist:
.a3b1	60		rts		z_two:          rts
.a3b2					xt_two_drop:
.a3b2	20 33 d9	jsr $d933	                jsr underflow_2
.a3b5	e8		inx		                inx
.a3b6	e8		inx		                inx
.a3b7	e8		inx		                inx
.a3b8	e8		inx		                inx
.a3b9	60		rts		z_two_drop:     rts
.a3ba					xt_two_dup:
.a3ba	20 33 d9	jsr $d933	                jsr underflow_2
.a3bd	ca		dex		                dex
.a3be	ca		dex		                dex
.a3bf	ca		dex		                dex
.a3c0	ca		dex		                dex
.a3c1	b5 04		lda $04,x	                lda 4,x         ; TOS
.a3c3	95 00		sta $00,x	                sta 0,x
.a3c5	b5 05		lda $05,x	                lda 5,x
.a3c7	95 01		sta $01,x	                sta 1,x
.a3c9	b5 06		lda $06,x	                lda 6,x         ; NOS
.a3cb	95 02		sta $02,x	                sta 2,x
.a3cd	b5 07		lda $07,x	                lda 7,x
.a3cf	95 03		sta $03,x	                sta 3,x
.a3d1	60		rts		z_two_dup:      rts
.a3d2					xt_two_fetch:
.a3d2	20 2e d9	jsr $d92e	                jsr underflow_1
.a3d5	b5 00		lda $00,x	                lda 0,x
.a3d7	85 24		sta $24		                sta tmp1
.a3d9	b4 01		ldy $01,x	                ldy 1,x
.a3db	84 25		sty $25		                sty tmp1+1
.a3dd	ca		dex		                dex             ; reuse one stack element
.a3de	ca		dex		                dex
.a3df	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a3e1	95 00		sta $00,x	                sta 0,x
.a3e3	a0 01		ldy #$01	                ldy #1          ; copy next
.a3e5	b1 24		lda ($24),y	                lda (tmp1),y
.a3e7	95 01		sta $01,x	                sta 1,x
.a3e9	c8		iny		                iny             ; copy next
.a3ea	b1 24		lda ($24),y	                lda (tmp1),y
.a3ec	95 02		sta $02,x	                sta 2,x
.a3ee	c8		iny		                iny             ; copy next
.a3ef	b1 24		lda ($24),y	                lda (tmp1),y
.a3f1	95 03		sta $03,x	                sta 3,x
.a3f3	60		rts		z_two_fetch:    rts
.a3f4					xt_two_over:
.a3f4	20 3d d9	jsr $d93d	                jsr underflow_4
.a3f7	ca		dex		                dex
.a3f8	ca		dex		                dex
.a3f9	ca		dex		                dex
.a3fa	ca		dex		                dex
.a3fb	b5 08		lda $08,x	                lda 8,x
.a3fd	95 00		sta $00,x	                sta 0,x
.a3ff	b5 09		lda $09,x	                lda 9,x
.a401	95 01		sta $01,x	                sta 1,x
.a403	b5 0a		lda $0a,x	                lda 10,x
.a405	95 02		sta $02,x	                sta 2,x
.a407	b5 0b		lda $0b,x	                lda 11,x
.a409	95 03		sta $03,x	                sta 3,x
.a40b	60		rts		z_two_over:     rts
.a40c					xt_two_r_fetch:
.a40c	ca		dex		                dex
.a40d	ca		dex		                dex
.a40e	ca		dex		                dex
.a40f	ca		dex		                dex
.a410	8a		txa		                txa
.a411	ba		tsx		                tsx
.a412	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a413	7a		ply		                ply
.a414	aa		tax		                tax
.a415	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a418	95 00		sta $00,x	                sta 0,x
.a41a	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a41d	95 01		sta $01,x	                sta 1,x
.a41f	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a422	95 02		sta $02,x	                sta 2,x
.a424	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a427	95 03		sta $03,x	                sta 3,x
.a429	60		rts		z_two_r_fetch:  rts
.a42a					xt_two_r_from:
.a42a	68		pla		                pla                     ; LSB
.a42b	85 24		sta $24		                sta tmp1
.a42d	68		pla		                pla                     ; MSB
.a42e	85 25		sta $25		                sta tmp1+1
.a430	ca		dex		                dex
.a431	ca		dex		                dex
.a432	ca		dex		                dex
.a433	ca		dex		                dex
.a434	68		pla		                pla                     ; LSB
.a435	95 00		sta $00,x	                sta 0,x
.a437	68		pla		                pla                     ; MSB
.a438	95 01		sta $01,x	                sta 1,x
.a43a	68		pla		                pla                     ; LSB
.a43b	95 02		sta $02,x	                sta 2,x
.a43d	68		pla		                pla                     ; MSB
.a43e	95 03		sta $03,x	                sta 3,x
.a440	a5 25		lda $25		                lda tmp1+1              ; MSB
.a442	48		pha		                pha
.a443	a5 24		lda $24		                lda tmp1                ; LSB
.a445	48		pha		                pha
.a446	60		rts		z_two_r_from:   rts
.a447					xt_two_slash:
.a447	20 2e d9	jsr $d92e	                jsr underflow_1
.a44a	b5 01		lda $01,x	                lda 1,x
.a44c	0a		asl a		                asl                     ; save the sign
.a44d	76 01		ror $01,x	                ror 1,x
.a44f	76 00		ror $00,x	                ror 0,x
.a451	60		rts		z_two_slash:    rts
.a452					xt_two_star:
.a452					xt_cells:
.a452	20 2e d9	jsr $d92e	                jsr underflow_1
.a455	16 00		asl $00,x	                asl 0,x
.a457	36 01		rol $01,x	                rol 1,x
.a459					z_cells:
.a459	60		rts		z_two_star:     rts
.a45a					xt_two_store:
.a45a	20 38 d9	jsr $d938	                jsr underflow_3
.a45d	b5 00		lda $00,x	                lda 0,x
.a45f	85 24		sta $24		                sta tmp1
.a461	b4 01		ldy $01,x	                ldy 1,x
.a463	84 25		sty $25		                sty tmp1+1
.a465	e8		inx		                inx
.a466	e8		inx		                inx
.a467	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a469	92 24		sta ($24)	                sta (tmp1)
.a46b	b5 01		lda $01,x	                lda 1,x         ; copy next
.a46d	a0 01		ldy #$01	                ldy #1
.a46f	91 24		sta ($24),y	                sta (tmp1),y
.a471	b5 02		lda $02,x	                lda 2,x         ; copy next
.a473	c8		iny		                iny
.a474	91 24		sta ($24),y	                sta (tmp1),y
.a476	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a478	c8		iny		                iny
.a479	91 24		sta ($24),y	                sta (tmp1),y
.a47b	e8		inx		                inx             ; 2DROP
.a47c	e8		inx		                inx
.a47d	e8		inx		                inx
.a47e	e8		inx		                inx
.a47f	60		rts		z_two_store:    rts
.a480					xt_two_swap:
.a480	20 3d d9	jsr $d93d	                jsr underflow_4
.a483	b5 00		lda $00,x	                lda 0,x
.a485	b4 04		ldy $04,x	                ldy 4,x
.a487	95 04		sta $04,x	                sta 4,x
.a489	94 00		sty $00,x	                sty 0,x
.a48b	b5 01		lda $01,x	                lda 1,x
.a48d	b4 05		ldy $05,x	                ldy 5,x
.a48f	95 05		sta $05,x	                sta 5,x
.a491	94 01		sty $01,x	                sty 1,x
.a493	b5 02		lda $02,x	                lda 2,x
.a495	b4 06		ldy $06,x	                ldy 6,x
.a497	95 06		sta $06,x	                sta 6,x
.a499	94 02		sty $02,x	                sty 2,x
.a49b	b5 03		lda $03,x	                lda 3,x
.a49d	b4 07		ldy $07,x	                ldy 7,x
.a49f	95 07		sta $07,x	                sta 7,x
.a4a1	94 03		sty $03,x	                sty 3,x
.a4a3	60		rts		z_two_swap:     rts
.a4a4					xt_two_to_r:
.a4a4	68		pla		                pla             ; LSB
.a4a5	85 24		sta $24		                sta tmp1
.a4a7	68		pla		                pla             ; MSB
.a4a8	85 25		sta $25		                sta tmp1+1
.a4aa	20 33 d9	jsr $d933	                jsr underflow_2
.a4ad	b5 03		lda $03,x	                lda 3,x         ; MSB
.a4af	48		pha		                pha
.a4b0	b5 02		lda $02,x	                lda 2,x         ; LSB
.a4b2	48		pha		                pha
.a4b3	b5 01		lda $01,x	                lda 1,x         ; MSB
.a4b5	48		pha		                pha
.a4b6	b5 00		lda $00,x	                lda 0,x         ; LSB
.a4b8	48		pha		                pha
.a4b9	e8		inx		                inx
.a4ba	e8		inx		                inx
.a4bb	e8		inx		                inx
.a4bc	e8		inx		                inx
.a4bd	a5 25		lda $25		                lda tmp1+1      ; MSB
.a4bf	48		pha		                pha
.a4c0	a5 24		lda $24		                lda tmp1        ; LSB
.a4c2	48		pha		                pha
.a4c3	60		rts		z_two_to_r:     rts
.a4c4					xt_two_constant:
.a4c4	20 33 d9	jsr $d933	                jsr underflow_2
.a4c7	20 85 89	jsr $8985	                jsr xt_create
.a4ca	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a4cd	20 8a 87	jsr $878a	                jsr xt_comma
.a4d0	20 8a 87	jsr $878a	                jsr xt_comma
.a4d3	20 20 8c	jsr $8c20	                jsr does_runtime    ; does> turns into these two routines.
.a4d6	20 0a d8	jsr $d80a	                jsr dodoes
.a4d9	20 cb 8d	jsr $8dcb	                jsr xt_dup
.a4dc	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.a4df	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a4e2	20 3d 86	jsr $863d	                jsr xt_cell_plus
.a4e5	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.a4e8	60		rts		z_two_constant: rts
.a4e9					xt_two_literal:
.a4e9	20 33 d9	jsr $d933	                jsr underflow_2 ; double number
.a4ec	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a4ef	20 a6 93	jsr $93a6	                jsr xt_literal
.a4f2	20 a6 93	jsr $93a6	                jsr xt_literal
.a4f5	60		rts		z_two_literal:  rts
.a4f6					xt_two_variable:
.a4f6	20 85 89	jsr $8985	                jsr xt_create
.a4f9	ca		dex		                dex
.a4fa	ca		dex		                dex
.a4fb	a9 04		lda #$04	                lda #4
.a4fd	95 00		sta $00,x	                sta 0,x
.a4ff	74 01		stz $01,x	                stz 1,x
.a501	20 a5 82	jsr $82a5	                jsr xt_allot
.a504	60		rts		z_two_variable: rts
.a505					xt_type:
.a505	20 33 d9	jsr $d933	                jsr underflow_2
.a508	b5 02		lda $02,x	                lda 2,x
.a50a	85 24		sta $24		                sta tmp1
.a50c	b5 03		lda $03,x	                lda 3,x
.a50e	85 25		sta $25		                sta tmp1+1
.a510					_loop:
.a510	b5 00		lda $00,x	                lda 0,x
.a512	15 01		ora $01,x	                ora 1,x
.a514	f0 15		beq $a52b	                beq _done
.a516	b2 24		lda ($24)	                lda (tmp1)
.a518	20 12 8e	jsr $8e12	                jsr emit_a      ; avoids stack foolery
.a51b	e6 24		inc $24		                inc tmp1
.a51d	d0 02		bne $a521	                bne +
.a51f	e6 25		inc $25		                inc tmp1+1
.a521					+
.a521	b5 00		lda $00,x	                lda 0,x
.a523	d0 02		bne $a527	                bne +
.a525	d6 01		dec $01,x	                dec 1,x
.a527					+
.a527	d6 00		dec $00,x	                dec 0,x
.a529	80 e5		bra $a510	                bra _loop
.a52b					_done:
.a52b	e8		inx		                inx
.a52c	e8		inx		                inx
.a52d	e8		inx		                inx
.a52e	e8		inx		                inx
.a52f	60		rts		z_type:         rts
.a530					xt_u_dot:
.a530	20 2e d9	jsr $d92e	                jsr underflow_1
.a533	20 9b d9	jsr $d99b	                jsr print_u
.a536	a9 20		lda #$20	                lda #AscSP
.a538	20 12 8e	jsr $8e12	                jsr emit_a
.a53b	60		rts		z_u_dot:        rts
.a53c					xt_u_dot_r:
.a53c	20 33 d9	jsr $d933	                jsr underflow_2
.a53f	20 72 a3	jsr $a372	                jsr xt_to_r
.a542	20 aa a7	jsr $a7aa	                jsr xt_zero
.a545	20 76 93	jsr $9376	                jsr xt_less_number_sign
.a548	20 0f 98	jsr $980f	                jsr xt_number_sign_s
.a54b	20 ed 97	jsr $97ed	                jsr xt_number_sign_greater
.a54e	20 c3 9a	jsr $9ac3	                jsr xt_r_from
.a551	20 c4 98	jsr $98c4	                jsr xt_over
.a554	20 81 95	jsr $9581	                jsr xt_minus
.a557	20 26 a1	jsr $a126	                jsr xt_spaces
.a55a	20 05 a5	jsr $a505	                jsr xt_type
.a55d	60		rts		z_u_dot_r:      rts
.a55e					xt_u_greater_than:
.a55e	20 33 d9	jsr $d933	                jsr underflow_2
.a561	b5 00		lda $00,x	                lda 0,x
.a563	d5 02		cmp $02,x	                cmp 2,x
.a565	b5 01		lda $01,x	                lda 1,x
.a567	f5 03		sbc $03,x	                sbc 3,x
.a569	e8		inx		                inx
.a56a	e8		inx		                inx
.a56b	a9 00		lda #$00	                lda #0
.a56d	69 ff		adc #$ff	                adc #$ff
.a56f	95 00		sta $00,x	                sta 0,x         ; store flag
.a571	95 01		sta $01,x	                sta 1,x
.a573	60		rts		z_u_greater_than:    rts
.a574					xt_u_less_than:
.a574	20 33 d9	jsr $d933	                jsr underflow_2
.a577	b5 02		lda $02,x	                lda 2,x
.a579	d5 00		cmp $00,x	                cmp 0,x
.a57b	b5 03		lda $03,x	                lda 3,x
.a57d	f5 01		sbc $01,x	                sbc 1,x
.a57f	e8		inx		                inx
.a580	e8		inx		                inx
.a581	a9 00		lda #$00	                lda #0
.a583	69 ff		adc #$ff	                adc #$ff
.a585	95 00		sta $00,x	                sta 0,x         ; store flag
.a587	95 01		sta $01,x	                sta 1,x
.a589	60		rts		z_u_less_than:    rts
.a58a					xt_ud_dot:
.a58a	20 33 d9	jsr $d933	                jsr underflow_2 ; double number
.a58d	20 76 93	jsr $9376	                jsr xt_less_number_sign
.a590	20 0f 98	jsr $980f	                jsr xt_number_sign_s
.a593	20 ed 97	jsr $97ed	                jsr xt_number_sign_greater
.a596	20 05 a5	jsr $a505	                jsr xt_type
.a599	20 20 a1	jsr $a120	                jsr xt_space
.a59c	60		rts		z_ud_dot:        rts
.a59d					xt_ud_dot_r:
.a59d	20 38 d9	jsr $d938	                jsr underflow_3
.a5a0	20 72 a3	jsr $a372	                jsr xt_to_r
.a5a3	20 76 93	jsr $9376	                jsr xt_less_number_sign
.a5a6	20 0f 98	jsr $980f	                jsr xt_number_sign_s
.a5a9	20 ed 97	jsr $97ed	                jsr xt_number_sign_greater
.a5ac	20 c3 9a	jsr $9ac3	                jsr xt_r_from
.a5af	20 c4 98	jsr $98c4	                jsr xt_over
.a5b2	20 81 95	jsr $9581	                jsr xt_minus
.a5b5	20 26 a1	jsr $a126	                jsr xt_spaces
.a5b8	20 05 a5	jsr $a505	                jsr xt_type
.a5bb	60		rts		z_ud_dot_r:      rts
.a5bc					xt_um_slash_mod:
.a5bc	20 38 d9	jsr $d938	                jsr underflow_3
.a5bf	b5 00		lda $00,x	                lda 0,x
.a5c1	15 01		ora $01,x	                ora 1,x
.a5c3	d0 05		bne $a5ca	                bne _not_zero
.a5c5	a9 04		lda #$04	                lda #err_divzero
.a5c7	4c 44 d9	jmp $d944	                jmp error
.a5ca					_not_zero:
.a5ca	a9 11		lda #$11	                lda #17
.a5cc	85 2c		sta $2c		                sta tmptos
.a5ce					_loop:
.a5ce	36 04		rol $04,x	                rol 4,x
.a5d0	36 05		rol $05,x	                rol 5,x
.a5d2	c6 2c		dec $2c		                dec tmptos
.a5d4	f0 22		beq $a5f8	                beq _done
.a5d6	36 02		rol $02,x	                rol 2,x
.a5d8	36 03		rol $03,x	                rol 3,x
.a5da	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a5dc	26 24		rol $24		                rol tmp1
.a5de	38		sec		                sec
.a5df	b5 02		lda $02,x	                lda 2,x
.a5e1	f5 00		sbc $00,x	                sbc 0,x
.a5e3	85 25		sta $25		                sta tmp1+1
.a5e5	b5 03		lda $03,x	                lda 3,x
.a5e7	f5 01		sbc $01,x	                sbc 1,x
.a5e9	a8		tay		                tay
.a5ea	a5 24		lda $24		                lda tmp1
.a5ec	e9 00		sbc #$00	                sbc #0
.a5ee	90 de		bcc $a5ce	                bcc _loop
.a5f0	a5 25		lda $25		                lda tmp1+1
.a5f2	95 02		sta $02,x	                sta 2,x
.a5f4	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a5f6	80 d6		bra $a5ce	                bra _loop
.a5f8					_done:
.a5f8	e8		inx		                inx
.a5f9	e8		inx		                inx
.a5fa	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a5fd	60		rts		z_um_slash_mod: rts
.a5fe					xt_um_star:
.a5fe	20 33 d9	jsr $d933	                jsr underflow_2
.a601	18		clc		                clc
.a602	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a604	e9 00		sbc #$00	                sbc #0
.a606	85 26		sta $26		                sta tmp2
.a608	b5 01		lda $01,x	                lda 1,x
.a60a	e9 00		sbc #$00	                sbc #0
.a60c	90 31		bcc $a63f	                bcc _zero       ; is TOS zero?
.a60e	85 27		sta $27		                sta tmp2+1
.a610	a9 00		lda #$00	                lda #0
.a612	85 24		sta $24		                sta tmp1
.a614	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a616	ca		dex		                dex
.a617	ca		dex		                dex
.a618					_outer_loop:
.a618	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a61a	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a61c					_inner_loop:
.a61c	90 0c		bcc $a62a	                bcc _no_add
.a61e	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a620	a5 24		lda $24		                lda tmp1
.a622	65 26		adc $26		                adc tmp2
.a624	85 24		sta $24		                sta tmp1
.a626	a5 25		lda $25		                lda tmp1+1
.a628	65 27		adc $27		                adc tmp2+1
.a62a					_no_add:
.a62a	6a		ror a		                ror
.a62b	66 24		ror $24		                ror tmp1
.a62d	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a62f	88		dey		                dey
.a630	d0 ea		bne $a61c	                bne _inner_loop ; go back for one more shift?
.a632	e8		inx		                inx
.a633	e4 28		cpx $28		                cpx tmp3
.a635	d0 e1		bne $a618	                bne _outer_loop ; go back for eight more shifts?
.a637	95 01		sta $01,x	                sta 1,x
.a639	a5 24		lda $24		                lda tmp1
.a63b	95 00		sta $00,x	                sta 0,x
.a63d	80 04		bra $a643	                bra _done
.a63f					_zero:
.a63f	74 02		stz $02,x	                stz 2,x
.a641	74 03		stz $03,x	                stz 3,x
.a643					_done:
.a643	60		rts		z_um_star:      rts
.a644					xt_unloop:
.a644	68		pla		                pla
.a645	68		pla		                pla
.a646	68		pla		                pla
.a647	68		pla		                pla
.a648	68		pla		                pla
.a649	68		pla		                pla
.a64a	60		rts		z_unloop:       rts
.a64b					xt_until:
.a64b	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a64d	a9 30		lda #$30	                lda #<zero_branch_runtime
.a64f	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.a652	20 8a 87	jsr $878a	                jsr xt_comma
.a655	60		rts		z_until:        rts
.a656					xt_unused:
.a656	ca		dex		                dex
.a657	ca		dex		                dex
.a658	a9 00		lda #$00	                lda #<cp_end
.a65a	38		sec		                sec
.a65b	e5 00		sbc $00		                sbc cp
.a65d	95 00		sta $00,x	                sta 0,x
.a65f	a9 7c		lda #$7c	                lda #>cp_end
.a661	e5 01		sbc $01		                sbc cp+1
.a663	95 01		sta $01,x	                sta 1,x
.a665	60		rts		z_unused:       rts
.a666					xt_update:
.a666	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a668	b1 1e		lda ($1e),y	                lda (up),y
.a66a	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a66c	91 1e		sta ($1e),y	                sta (up),y
.a66e	60		rts		z_update:       rts
.a66f					xt_useraddr:
.a66f	ca		dex		                dex
.a670	ca		dex		                dex
.a671	a9 1e		lda #$1e	                lda #<up
.a673	95 00		sta $00,x	                sta 0,x
.a675	a9 00		lda #$00	                lda #>up
.a677	95 01		sta $01,x	                sta 1,x
.a679	60		rts		z_useraddr:     rts
.a67a					xt_variable:
.a67a	20 85 89	jsr $8985	                jsr xt_create
.a67d	a9 00		lda #$00	                lda #0
.a67f	92 00		sta ($00)	                sta (cp)
.a681	e6 00		inc $00		                inc cp
.a683	d0 02		bne $a687	                bne +
.a685	e6 01		inc $01		                inc cp+1
.a687					+
.a687	92 00		sta ($00)	                sta (cp)
.a689	e6 00		inc $00		                inc cp
.a68b	d0 02		bne $a68f	                bne +
.a68d	e6 01		inc $01		                inc cp+1
.a68f					+
.a68f	20 4d 89	jsr $894d	                jsr adjust_z
.a692	60		rts		z_variable:     rts
.a693					xt_while:
.a693	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a695	a9 30		lda #$30	                lda #<zero_branch_runtime
.a697	20 c4 d7	jsr $d7c4	                jsr cmpl_subroutine
.a69a	20 8e 91	jsr $918e	                jsr xt_here
.a69d	20 aa a7	jsr $a7aa	                jsr xt_zero
.a6a0	20 8a 87	jsr $878a	                jsr xt_comma
.a6a3	20 b0 a1	jsr $a1b0	                jsr xt_swap
.a6a6	60		rts		z_while:        rts
.a6a7					xt_within:
.a6a7	20 38 d9	jsr $d938	                jsr underflow_3
.a6aa	20 c4 98	jsr $98c4	                jsr xt_over
.a6ad	20 81 95	jsr $9581	                jsr xt_minus
.a6b0	20 72 a3	jsr $a372	                jsr xt_to_r
.a6b3	20 81 95	jsr $9581	                jsr xt_minus
.a6b6	20 c3 9a	jsr $9ac3	                jsr xt_r_from
.a6b9	20 74 a5	jsr $a574	                jsr xt_u_less_than
.a6bc	60		rts		z_within:       rts
.a6bd					xt_word:
.a6bd	20 2e d9	jsr $d92e	                jsr underflow_1
.a6c0	a4 0c		ldy $0c		                ldy toin                ; >IN
.a6c2					_loop:
.a6c2	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a6c4	f0 09		beq $a6cf	                beq _found_char
.a6c6	b1 08		lda ($08),y	                lda (cib),y
.a6c8	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a6ca	d0 03		bne $a6cf	                bne _found_char
.a6cc	c8		iny		                iny
.a6cd	80 f3		bra $a6c2	                bra _loop
.a6cf					_found_char:
.a6cf	84 0c		sty $0c		                sty toin
.a6d1	20 6b 99	jsr $996b	                jsr xt_parse            ; Returns ( addr u )
.a6d4	b5 00		lda $00,x	                lda 0,x
.a6d6	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a6d8	48		pha		                pha                     ; Keep copy of length for later
.a6d9	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( addr u u )
.a6dc	a5 00		lda $00		                lda cp
.a6de	18		clc		                clc
.a6df	69 01		adc #$01	                adc #1
.a6e1	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a6e3	a5 01		lda $01		                lda cp+1
.a6e5	69 00		adc #$00	                adc #0
.a6e7	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a6e9	20 f3 95	jsr $95f3	                jsr xt_move
.a6ec	ca		dex		                dex
.a6ed	ca		dex		                dex
.a6ee	a5 00		lda $00		                lda cp
.a6f0	95 00		sta $00,x	                sta 0,x
.a6f2	a5 01		lda $01		                lda cp+1
.a6f4	95 01		sta $01,x	                sta 1,x
.a6f6	68		pla		                pla                     ; length of string
.a6f7	18		clc		                clc
.a6f8	65 00		adc $00		                adc cp
.a6fa	85 00		sta $00		                sta cp
.a6fc	a5 01		lda $01		                lda cp+1
.a6fe	69 00		adc #$00	                adc #0                  ; we only need the carry
.a700	85 01		sta $01		                sta cp+1
.a702	60		rts		z_word:         rts
.a703					xt_wordlist:
.a703	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a705	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a707	c9 0c		cmp #$0c	                cmp #max_wordlists
.a709	d0 05		bne $a710	                bne _ok
.a70b	a9 0b		lda #$0b	                lda #err_wordlist
.a70d	4c 44 d9	jmp $d944	                jmp error
.a710					_ok:
.a710	1a		inc a		                ina             ; Increment the wordlist#
.a711	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a713	ca		dex		                dex             ; and put it on the stack.
.a714	ca		dex		                dex
.a715	95 00		sta $00,x	                sta 0,x
.a717	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a719	60		rts		z_wordlist:     rts
.a71a					xt_words:
.a71a	20 7f 89	jsr $897f	                jsr xt_cr
.a71d	a9 00		lda #$00	                lda #0
.a71f	48		pha		                pha
.a720	ca		dex		                dex                     ; Make room on the stack for
.a721	ca		dex		                dex                     ; a dictionary pointer.
.a722	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a724					_wordlist_loop:
.a724	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a726	a5 28		lda $28		                lda tmp3
.a728	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a72a	d0 02		bne $a72e	                bne _have_wordlist
.a72c	80 45		bra $a773	                bra _words_done
.a72e					_have_wordlist:
.a72e	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a72f	69 1f		adc #$1f	                adc #search_order_offset
.a731	a8		tay		                tay
.a732	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a734	0a		asl a		                asl                     ; Turn offset into cells offset.
.a735	18		clc		                clc
.a736	69 06		adc #$06	                adc #wordlists_offset
.a738	a8		tay		                tay
.a739	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a73b	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a73d	c8		iny		                iny
.a73e	b1 1e		lda ($1e),y	                lda (up),y
.a740	95 01		sta $01,x	                sta 1,x
.a742					_loop:
.a742	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( nt nt )
.a745	20 2f 96	jsr $962f	                jsr xt_name_to_string   ; ( nt addr u )
.a748	68		pla		                pla
.a749	18		clc		                clc
.a74a	75 00		adc $00,x	                adc 0,x
.a74c	1a		inc a		                ina                     ; don't forget the space between words
.a74d	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a74f	90 06		bcc $a757	                bcc +
.a751	20 7f 89	jsr $897f	                jsr xt_cr
.a754	b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a756	1a		inc a		                ina                     ; with length of this word.
.a757					+
.a757	48		pha		                pha
.a758	20 05 a5	jsr $a505	                jsr xt_type             ; ( nt )
.a75b	a9 20		lda #$20	                lda #AscSP
.a75d	20 12 8e	jsr $8e12	                jsr emit_a
.a760	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+
.a763	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+
.a766	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; @ ( nt+1 )
.a769	b5 00		lda $00,x	                lda 0,x
.a76b	15 01		ora $01,x	                ora 1,x
.a76d	d0 d3		bne $a742	                bne _loop
.a76f	e6 28		inc $28		                inc tmp3
.a771	80 b1		bra $a724	                bra _wordlist_loop
.a773					_words_done:
.a773	68		pla		                pla                     ; dump counter
.a774	e8		inx		                inx
.a775	e8		inx		                inx
.a776	60		rts		z_words:        rts
.a777					xt_wordsize:
.a777	20 2e d9	jsr $d92e	                jsr underflow_1
.a77a	b5 00		lda $00,x	                lda 0,x
.a77c	85 24		sta $24		                sta tmp1
.a77e	b5 01		lda $01,x	                lda 1,x
.a780	85 25		sta $25		                sta tmp1+1
.a782	a0 06		ldy #$06	                ldy #6
.a784	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a786	88		dey		                dey
.a787	88		dey		                dey
.a788	38		sec		                sec
.a789	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a78b	95 00		sta $00,x	                sta 0,x
.a78d	a0 07		ldy #$07	                ldy #7
.a78f	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a791	88		dey		                dey
.a792	88		dey		                dey
.a793	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a795	95 01		sta $01,x	                sta 1,x
.a797	60		rts		z_wordsize:     rts
.a798					xt_xor:
.a798	20 33 d9	jsr $d933	                jsr underflow_2
.a79b	b5 00		lda $00,x	                lda 0,x
.a79d	55 02		eor $02,x	                eor 2,x
.a79f	95 02		sta $02,x	                sta 2,x
.a7a1	b5 01		lda $01,x	                lda 1,x
.a7a3	55 03		eor $03,x	                eor 3,x
.a7a5	95 03		sta $03,x	                sta 3,x
.a7a7	e8		inx		                inx
.a7a8	e8		inx		                inx
.a7a9	60		rts		z_xor:          rts
.a7aa					xt_case:
.a7aa					xt_forth_wordlist:
.a7aa					xt_zero:
.a7aa	ca		dex		                dex             ; push
.a7ab	ca		dex		                dex
.a7ac	74 00		stz $00,x	                stz 0,x
.a7ae	74 01		stz $01,x	                stz 1,x
.a7b0					z_case:
.a7b0					z_forth_wordlist:
.a7b0					z_zero:
.a7b0	60		rts		                rts
.a7b1					xt_zero_equal:
.a7b1	20 2e d9	jsr $d92e	                jsr underflow_1
.a7b4	b5 00		lda $00,x	                lda 0,x
.a7b6	15 01		ora $01,x	                ora 1,x
.a7b8	f0 04		beq $a7be	                beq _zero
.a7ba	a9 00		lda #$00	                lda #0
.a7bc	80 02		bra $a7c0	                bra _store
.a7be					_zero:
.a7be	a9 ff		lda #$ff	                lda #$ff
.a7c0					_store:
.a7c0	95 00		sta $00,x	                sta 0,x
.a7c2	95 01		sta $01,x	                sta 1,x
.a7c4	60		rts		z_zero_equal:   rts
.a7c5					xt_zero_greater:
.a7c5	20 2e d9	jsr $d92e	                jsr underflow_1
.a7c8	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a7ca	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7cc	30 05		bmi $a7d3	                bmi _done       ; TOS is negative, keep FLASE
.a7ce	15 00		ora $00,x	                ora 0,x
.a7d0	f0 01		beq $a7d3	                beq _done       ; TOS is zero, keep FALSE
.a7d2	88		dey		                dey             ; TOS is postive, make true
.a7d3					_done:
.a7d3	98		tya		                tya
.a7d4	95 00		sta $00,x	                sta 0,x
.a7d6	95 01		sta $01,x	                sta 1,x
.a7d8	60		rts		z_zero_greater: rts
.a7d9					xt_zero_less:
.a7d9	20 2e d9	jsr $d92e	                jsr underflow_1
.a7dc	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a7de	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7e0	10 01		bpl $a7e3	                bpl _done       ; TOS is positive, so keep FALSE
.a7e2	88		dey		                dey             ; TOS is negative, make TRUE
.a7e3					_done:
.a7e3	98		tya		                tya
.a7e4	95 00		sta $00,x	                sta 0,x
.a7e6	95 01		sta $01,x	                sta 1,x
.a7e8	60		rts		z_zero_less:    rts
.a7e9					xt_zero_unequal:
.a7e9	20 2e d9	jsr $d92e	                jsr underflow_1
.a7ec	a0 00		ldy #$00	                ldy #0          ; default false
.a7ee	b5 00		lda $00,x	                lda 0,x
.a7f0	15 01		ora $01,x	                ora 1,x
.a7f2	f0 01		beq $a7f5	                beq _got_zero
.a7f4	88		dey		                dey
.a7f5					_got_zero:
.a7f5	98		tya		                tya
.a7f6	95 00		sta $00,x	                sta 0,x
.a7f8	95 01		sta $01,x	                sta 1,x
.a7fa	60		rts		z_zero_unequal: rts
.a7fb					xt_editor_screen_helper:
.a7fb	20 cb 8d	jsr $8dcb	                jsr xt_dup
.a7fe	20 db 9e	jsr $9edb	                jsr xt_scr
.a801	20 8f a1	jsr $a18f	                jsr xt_store
.a804	20 d1 85	jsr $85d1	                jsr xt_buffer
.a807					z_editor_screen_helper:
.a807	60		rts		                rts
.a808					xt_editor_enter_screen:
.a808	20 fb a7	jsr $a7fb	                jsr xt_editor_screen_helper
.a80b	20 4a 8d	jsr $8d4a	                jsr xt_drop
.a80e	64 2e		stz $2e		                stz editor1
.a810					_prompt_loop:
.a810	ca		dex		                dex
.a811	ca		dex		                dex
.a812	a5 2e		lda $2e		                lda editor1
.a814	95 00		sta $00,x	                sta 0,x
.a816	74 01		stz $01,x	                stz 1,x
.a818	20 dd a8	jsr $a8dd	                jsr xt_editor_o
.a81b	e6 2e		inc $2e		                inc editor1
.a81d	a9 10		lda #$10	                lda #16
.a81f	c5 2e		cmp $2e		                cmp editor1
.a821	d0 ed		bne $a810	                bne _prompt_loop
.a823					z_editor_enter_screen:
.a823	60		rts		                rts
.a824					xt_editor_erase_screen:
.a824	20 fb a7	jsr $a7fb	                jsr xt_editor_screen_helper
.a827	ca		dex		                dex
.a828	ca		dex		                dex
.a829	74 00		stz $00,x	                stz 0,x
.a82b	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a82d	95 01		sta $01,x	                sta 1,x
.a82f	20 06 8f	jsr $8f06	                jsr xt_blank
.a832	20 66 a6	jsr $a666	                jsr xt_update
.a835					z_editor_erase_screen:
.a835	60		rts		                rts
.a836					xt_editor_el:
.a836	20 c4 a8	jsr $a8c4	                jsr xt_editor_line
.a839	ca		dex		                dex
.a83a	ca		dex		                dex
.a83b	a9 40		lda #$40	                lda #64
.a83d	95 00		sta $00,x	                sta 0,x
.a83f	74 01		stz $01,x	                stz 1,x
.a841	20 06 8f	jsr $8f06	                jsr xt_blank
.a844	20 66 a6	jsr $a666	                jsr xt_update
.a847	60		rts		z_editor_el:    rts
.a848					xt_editor_l:
.a848	ca		dex		                dex             ; Put SCR on the stack.
.a849	ca		dex		                dex
.a84a	a0 02		ldy #$02	                ldy #scr_offset
.a84c	b1 1e		lda ($1e),y	                lda (up),y
.a84e	95 00		sta $00,x	                sta 0,x
.a850	c8		iny		                iny
.a851	b1 1e		lda ($1e),y	                lda (up),y
.a853	95 01		sta $01,x	                sta 1,x
.a855	20 dd 83	jsr $83dd	                jsr xt_block    ; Get the current screen.
.a858	20 7f 89	jsr $897f	                jsr xt_cr
.a85b	80 08		bra $a865	                bra _after_screen_msg
.a85d					_screen_msg:
>a85d	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a865					_after_screen_msg:
.a865	20 ab a0	jsr $a0ab	                jsr sliteral_runtime
>a868	5d a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a86c	20 05 a5	jsr $a505	                jsr xt_type
.a86f	20 db 9e	jsr $9edb	                jsr xt_scr
.a872	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.a875	ca		dex		                dex
.a876	ca		dex		                dex
.a877	a9 04		lda #$04	                lda #4          ; four spaces
.a879	95 00		sta $00,x	                sta 0,x
.a87b	74 01		stz $01,x	                stz 1,x
.a87d	20 3c a5	jsr $a53c	                jsr xt_u_dot_r
.a880	64 28		stz $28		                stz tmp3
.a882					_line_loop:
.a882	20 7f 89	jsr $897f	                jsr xt_cr
.a885	ca		dex		                dex
.a886	ca		dex		                dex
.a887	ca		dex		                dex
.a888	ca		dex		                dex
.a889	74 03		stz $03,x	                stz 3,x
.a88b	a5 28		lda $28		                lda tmp3
.a88d	95 02		sta $02,x	                sta 2,x
.a88f	74 01		stz $01,x	                stz 1,x
.a891	a9 02		lda #$02	                lda #2
.a893	95 00		sta $00,x	                sta 0,x
.a895	20 3c a5	jsr $a53c	                jsr xt_u_dot_r
.a898	20 20 a1	jsr $a120	                jsr xt_space
.a89b	20 cb 8d	jsr $8dcb	                jsr xt_dup
.a89e	ca		dex		                dex
.a89f	ca		dex		                dex
.a8a0	a9 40		lda #$40	                lda #64
.a8a2	95 00		sta $00,x	                sta 0,x
.a8a4	74 01		stz $01,x	                stz 1,x
.a8a6	20 05 a5	jsr $a505	                jsr xt_type
.a8a9	18		clc		                clc
.a8aa	a9 40		lda #$40	                lda #64
.a8ac	75 00		adc $00,x	                adc 0,x
.a8ae	95 00		sta $00,x	                sta 0,x
.a8b0	b5 01		lda $01,x	                lda 1,x
.a8b2	69 00		adc #$00	                adc #0      ; Add carry
.a8b4	95 01		sta $01,x	                sta 1,x
.a8b6	e6 28		inc $28		                inc tmp3
.a8b8	a5 28		lda $28		                lda tmp3
.a8ba	c9 10		cmp #$10	                cmp #16
.a8bc	d0 c4		bne $a882	                bne _line_loop
.a8be	20 7f 89	jsr $897f	                jsr xt_cr
.a8c1	e8		inx		                inx
.a8c2	e8		inx		                inx
.a8c3	60		rts		z_editor_l:            rts
.a8c4					xt_editor_line:
.a8c4	20 2e d9	jsr $d92e	                jsr underflow_1
.a8c7	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a8c9					_shift_tos_left:
.a8c9	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a8cb	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a8cd	88		dey		                dey
.a8ce	d0 f9		bne $a8c9	                bne _shift_tos_left
.a8d0	20 db 9e	jsr $9edb	                jsr xt_scr
.a8d3	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.a8d6	20 dd 83	jsr $83dd	                jsr xt_block
.a8d9	20 14 9a	jsr $9a14	                jsr xt_plus
.a8dc	60		rts		z_editor_line:  rts
.a8dd					xt_editor_o:
.a8dd	20 7f 89	jsr $897f	                jsr xt_cr
.a8e0	20 cb 8d	jsr $8dcb	                jsr xt_dup
.a8e3	20 a9 a3	jsr $a3a9	                jsr xt_two
.a8e6	20 3c a5	jsr $a53c	                jsr xt_u_dot_r
.a8e9	20 20 a1	jsr $a120	                jsr xt_space
.a8ec	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a8ee	20 12 8e	jsr $8e12	                jsr emit_a
.a8f1	20 20 a1	jsr $a120	                jsr xt_space
.a8f4	20 c4 a8	jsr $a8c4	                jsr xt_editor_line
.a8f7	20 cb 8d	jsr $8dcb	                jsr xt_dup      ; Save a copy of the line address for later.
.a8fa	ca		dex		                dex
.a8fb	ca		dex		                dex
.a8fc	a9 40		lda #$40	                lda #64         ; chars/line
.a8fe	95 00		sta $00,x	                sta 0,x
.a900	74 01		stz $01,x	                stz 1,x
.a902	20 48 81	jsr $8148	                jsr xt_accept
.a905	20 cb 8d	jsr $8dcb	                jsr xt_dup
.a908	20 9f 96	jsr $969f	                jsr xt_not_rote ; -rot
.a90b	20 14 9a	jsr $9a14	                jsr xt_plus
.a90e	ca		dex		                dex
.a90f	ca		dex		                dex
.a910	a9 40		lda #$40	                lda #64         ; chars/line
.a912	95 00		sta $00,x	                sta 0,x
.a914	74 01		stz $01,x	                stz 1,x
.a916	20 88 9b	jsr $9b88	                jsr xt_rot
.a919	20 81 95	jsr $9581	                jsr xt_minus
.a91c	20 06 8f	jsr $8f06	                jsr xt_blank
.a91f	20 66 a6	jsr $a666	                jsr xt_update
.a922	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a923					assembler:
.a923					xt_asm_adc_h:
.a923	a9 69		lda #$69	                lda #$69
.a925	4c 7e ac	jmp $ac7e	                jmp asm_common
.a928					z_asm_adc_h:
.a928					xt_asm_adc_x:
.a928	a9 7d		lda #$7d	                lda #$7D
.a92a	4c 7e ac	jmp $ac7e	                jmp asm_common
.a92d					z_asm_adc_x:
.a92d					xt_asm_adc_y:
.a92d	a9 79		lda #$79	                lda #$79
.a92f	4c 7e ac	jmp $ac7e	                jmp asm_common
.a932					z_asm_adc_y:
.a932					xt_asm_adc_z:
.a932	a9 65		lda #$65	                lda #$65
.a934	4c 7e ac	jmp $ac7e	                jmp asm_common
.a937					z_asm_adc_z:
.a937					xt_asm_adc_zi:
.a937	a9 72		lda #$72	                lda #$72
.a939	4c 7e ac	jmp $ac7e	                jmp asm_common
.a93c					z_asm_adc_zi:
.a93c					xt_asm_adc_ziy:
.a93c	a9 71		lda #$71	                lda #$71
.a93e	4c 7e ac	jmp $ac7e	                jmp asm_common
.a941					z_asm_adc_ziy:
.a941					xt_asm_adc_zx:
.a941	a9 75		lda #$75	                lda #$75
.a943	4c 7e ac	jmp $ac7e	                jmp asm_common
.a946					z_asm_adc_zx:
.a946					xt_asm_adc_zxi:
.a946	a9 61		lda #$61	                lda #$61
.a948	4c 7e ac	jmp $ac7e	                jmp asm_common
.a94b					z_asm_adc_zxi:
.a94b					xt_asm_and:
.a94b	a9 2d		lda #$2d	                lda #$2D
.a94d	4c 7e ac	jmp $ac7e	                jmp asm_common
.a950					z_asm_and:
.a950					xt_asm_and_h:
.a950	a9 29		lda #$29	                lda #$29
.a952	4c 7e ac	jmp $ac7e	                jmp asm_common
.a955					z_asm_and_h:
.a955					xt_asm_and_x:
.a955	a9 3d		lda #$3d	                lda #$3D
.a957	4c 7e ac	jmp $ac7e	                jmp asm_common
.a95a					z_asm_and_x:
.a95a					xt_asm_and_y:
.a95a	a9 39		lda #$39	                lda #$39
.a95c	4c 7e ac	jmp $ac7e	                jmp asm_common
.a95f					z_asm_and_y:
.a95f					xt_asm_and_z:
.a95f	a9 25		lda #$25	                lda #$25
.a961	4c 7e ac	jmp $ac7e	                jmp asm_common
.a964					z_asm_and_z:
.a964					xt_asm_and_zi:
.a964	a9 32		lda #$32	                lda #$32
.a966	4c 7e ac	jmp $ac7e	                jmp asm_common
.a969					z_asm_and_zi:
.a969					xt_asm_and_ziy:
.a969	a9 31		lda #$31	                lda #$31
.a96b	4c 7e ac	jmp $ac7e	                jmp asm_common
.a96e					z_asm_and_ziy:
.a96e					xt_asm_and_zx:
.a96e	a9 35		lda #$35	                lda #$35
.a970	4c 7e ac	jmp $ac7e	                jmp asm_common
.a973					z_asm_and_zx:
.a973					xt_asm_and_zxi:
.a973	a9 21		lda #$21	                lda #$21
.a975	4c 7e ac	jmp $ac7e	                jmp asm_common
.a978					z_asm_and_zxi:
.a978					xt_asm_asl:
.a978	a9 0e		lda #$0e	                lda #$0E
.a97a	4c 7e ac	jmp $ac7e	                jmp asm_common
.a97d					z_asm_asl:
.a97d					xt_asm_asl_a:
.a97d	a9 0a		lda #$0a	                lda #$0A
.a97f	4c 7e ac	jmp $ac7e	                jmp asm_common
.a982					z_asm_asl_a:
.a982					xt_asm_asl_x:
.a982	a9 1e		lda #$1e	                lda #$1E
.a984	4c 7e ac	jmp $ac7e	                jmp asm_common
.a987					z_asm_asl_x:
.a987					xt_asm_asl_z:
.a987	a9 06		lda #$06	                lda #$06
.a989	4c 7e ac	jmp $ac7e	                jmp asm_common
.a98c					z_asm_asl_z:
.a98c					xt_asm_asl_zx:
.a98c	a9 16		lda #$16	                lda #$16
.a98e	4c 7e ac	jmp $ac7e	                jmp asm_common
.a991					z_asm_asl_zx:
.a991					xt_asm_bcc:
.a991	a9 90		lda #$90	                lda #$90
.a993	4c 7e ac	jmp $ac7e	                jmp asm_common
.a996					z_asm_bcc:
.a996					xt_asm_bcs:
.a996	a9 b0		lda #$b0	                lda #$B0
.a998	a0 02		ldy #$02	                ldy #2
.a99a	4c 7e ac	jmp $ac7e	                jmp asm_common
.a99d					z_asm_bcs:
.a99d					xt_asm_beq:
.a99d	a9 f0		lda #$f0	                lda #$F0
.a99f	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9a2					z_asm_beq:
.a9a2					xt_asm_bit:
.a9a2	a9 2c		lda #$2c	                lda #$2C
.a9a4	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9a7					z_asm_bit:
.a9a7					xt_asm_bit_h:
.a9a7	a9 89		lda #$89	                lda #$89
.a9a9	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9ac					z_asm_bit_h:
.a9ac					xt_asm_bit_x:
.a9ac	a9 3c		lda #$3c	                lda #$3C
.a9ae	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9b1					z_asm_bit_x:
.a9b1					xt_asm_bit_z:
.a9b1	a9 24		lda #$24	                lda #$24
.a9b3	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9b6					z_asm_bit_z:
.a9b6					xt_asm_bit_zx:
.a9b6	a9 34		lda #$34	                lda #$34
.a9b8	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9bb					z_asm_bit_zx:
.a9bb					xt_asm_bmi:
.a9bb	a9 30		lda #$30	                lda #$30
.a9bd	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9c0					z_asm_bmi:
.a9c0					xt_asm_bne:
.a9c0	a9 d0		lda #$d0	                lda #$D0
.a9c2	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9c5					z_asm_bne:
.a9c5					xt_asm_bpl:
.a9c5	a9 10		lda #$10	                lda #$10
.a9c7	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9ca					z_asm_bpl:
.a9ca					xt_asm_bra:
.a9ca	a9 80		lda #$80	                lda #$80
.a9cc	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9cf					z_asm_bra:
.a9cf					xt_asm_brk:
.a9cf	a9 00		lda #$00	                lda #$00
.a9d1	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9d4					z_asm_brk:
.a9d4					xt_asm_bvc:
.a9d4	a9 50		lda #$50	                lda #$50
.a9d6	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9d9					z_asm_bvc:
.a9d9					xt_asm_bvs:
.a9d9	a9 70		lda #$70	                lda #$70
.a9db	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9de					z_asm_bvs:
.a9de					xt_asm_clc:
.a9de	a9 18		lda #$18	                lda #$18
.a9e0	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9e3					z_asm_clc:
.a9e3					xt_asm_cld:
.a9e3	a9 d8		lda #$d8	                lda #$D8
.a9e5	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9e8					z_asm_cld:
.a9e8					xt_asm_cli:
.a9e8	a9 58		lda #$58	                lda #$58
.a9ea	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9ed					z_asm_cli:
.a9ed					xt_asm_clv:
.a9ed	a9 b8		lda #$b8	                lda #$B8
.a9ef	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9f2					z_asm_clv:
.a9f2					xt_asm_cmp:
.a9f2	a9 cd		lda #$cd	                lda #$CD
.a9f4	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9f7					z_asm_cmp:
.a9f7					xt_asm_cmp_h:
.a9f7	a9 c9		lda #$c9	                lda #$C9
.a9f9	4c 7e ac	jmp $ac7e	                jmp asm_common
.a9fc					z_asm_cmp_h:
.a9fc					xt_asm_cmp_x:
.a9fc	a9 dd		lda #$dd	                lda #$DD
.a9fe	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa01					z_asm_cmp_x:
.aa01					xt_asm_cmp_y:
.aa01	a9 d9		lda #$d9	                lda #$D9
.aa03	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa06					z_asm_cmp_y:
.aa06					xt_asm_cmp_z:
.aa06	a9 c5		lda #$c5	                lda #$C5
.aa08	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa0b					z_asm_cmp_z:
.aa0b					xt_asm_cmp_zi:
.aa0b	a9 d2		lda #$d2	                lda #$D2
.aa0d	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa10					z_asm_cmp_zi:
.aa10					xt_asm_cmp_ziy:
.aa10	a9 d1		lda #$d1	                lda #$D1
.aa12	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa15					z_asm_cmp_ziy:
.aa15					xt_asm_cmp_zx:
.aa15	a9 d5		lda #$d5	                lda #$D5
.aa17	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa1a					z_asm_cmp_zx:
.aa1a					xt_asm_cmp_zxi:
.aa1a	a9 c1		lda #$c1	                lda #$C1
.aa1c	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa1f					z_asm_cmp_zxi:
.aa1f					xt_asm_cpx:
.aa1f	a9 ec		lda #$ec	                lda #$EC
.aa21	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa24					z_asm_cpx:
.aa24					xt_asm_cpx_h:
.aa24	a9 e0		lda #$e0	                lda #$E0
.aa26	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa29					z_asm_cpx_h:
.aa29					xt_asm_cpx_z:
.aa29	a9 e4		lda #$e4	                lda #$E4
.aa2b	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa2e					z_asm_cpx_z:
.aa2e					xt_asm_cpy:
.aa2e	a9 cc		lda #$cc	                lda #$CC
.aa30	a0 03		ldy #$03	                ldy #3
.aa32	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa35					z_asm_cpy:
.aa35					xt_asm_cpy_h:
.aa35	a9 c0		lda #$c0	                lda #$C0
.aa37	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa3a					z_asm_cpy_h:
.aa3a					xt_asm_cpy_z:
.aa3a	a9 c4		lda #$c4	                lda #$C4
.aa3c	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa3f					z_asm_cpy_z:
.aa3f					xt_asm_dec:
.aa3f	a9 ce		lda #$ce	                lda #$CE
.aa41	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa44					z_asm_dec:
.aa44					xt_asm_dec_a:
.aa44	a9 3a		lda #$3a	                lda #$3A
.aa46	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa49					z_asm_dec_a:
.aa49					xt_asm_dec_x:
.aa49	a9 de		lda #$de	                lda #$DE
.aa4b	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa4e					z_asm_dec_x:
.aa4e					xt_asm_dec_z:
.aa4e	a9 c6		lda #$c6	                lda #$C6
.aa50	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa53					z_asm_dec_z:
.aa53					xt_asm_dec_zx:
.aa53	a9 d6		lda #$d6	                lda #$D6
.aa55	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa58					z_asm_dec_zx:
.aa58					xt_asm_dex:
.aa58	a9 ca		lda #$ca	                lda #$CA
.aa5a	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa5d					z_asm_dex:
.aa5d					xt_asm_dey:
.aa5d	a9 88		lda #$88	                lda #$88
.aa5f	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa62					z_asm_dey:
.aa62					xt_asm_eor:
.aa62	a9 4d		lda #$4d	                lda #$4D
.aa64	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa67					z_asm_eor:
.aa67					xt_asm_eor_h:
.aa67	a9 49		lda #$49	                lda #$49
.aa69	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa6c					z_asm_eor_h:
.aa6c					xt_asm_eor_x:
.aa6c	a9 5d		lda #$5d	                lda #$5D
.aa6e	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa71					z_asm_eor_x:
.aa71					xt_asm_eor_y:
.aa71	a9 59		lda #$59	                lda #$59
.aa73	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa76					z_asm_eor_y:
.aa76					xt_asm_eor_z:
.aa76	a9 45		lda #$45	                lda #$45
.aa78	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa7b					z_asm_eor_z:
.aa7b					xt_asm_eor_zi:
.aa7b	a9 52		lda #$52	                lda #$52
.aa7d	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa80					z_asm_eor_zi:
.aa80					xt_asm_eor_ziy:
.aa80	a9 51		lda #$51	                lda #$51
.aa82	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa85					z_asm_eor_ziy:
.aa85					xt_asm_eor_zx:
.aa85	a9 55		lda #$55	                lda #$55
.aa87	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa8a					z_asm_eor_zx:
.aa8a					xt_asm_eor_zxi:
.aa8a	a9 41		lda #$41	                lda #$41
.aa8c	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa8f					z_asm_eor_zxi:
.aa8f					xt_asm_inc:
.aa8f	a9 ee		lda #$ee	                lda #$EE
.aa91	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa94					z_asm_inc:
.aa94					xt_asm_inc_a:
.aa94	a9 1a		lda #$1a	                lda #$1A
.aa96	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa99					z_asm_inc_a:
.aa99					xt_asm_inc_x:
.aa99	a9 fe		lda #$fe	                lda #$FE
.aa9b	4c 7e ac	jmp $ac7e	                jmp asm_common
.aa9e					z_asm_inc_x:
.aa9e					xt_asm_inc_z:
.aa9e	a9 e6		lda #$e6	                lda #$E6
.aaa0	4c 7e ac	jmp $ac7e	                jmp asm_common
.aaa3					z_asm_inc_z:
.aaa3					xt_asm_inc_zx:
.aaa3	a9 f6		lda #$f6	                lda #$F6
.aaa5	4c 7e ac	jmp $ac7e	                jmp asm_common
.aaa8					z_asm_inc_zx:
.aaa8					xt_asm_inx:
.aaa8	a9 e8		lda #$e8	                lda #$E8
.aaaa	4c 7e ac	jmp $ac7e	                jmp asm_common
.aaad					z_asm_inx:
.aaad					xt_asm_iny:
.aaad	a9 c8		lda #$c8	                lda #$C8
.aaaf	4c 7e ac	jmp $ac7e	                jmp asm_common
.aab2					z_asm_iny:
.aab2					xt_asm_jmp:
.aab2	a9 4c		lda #$4c	                lda #$4C
.aab4	4c 7e ac	jmp $ac7e	                jmp asm_common
.aab7					z_asm_jmp:
.aab7					xt_asm_jmp_i:
.aab7	a9 6c		lda #$6c	                lda #$6C
.aab9	4c 7e ac	jmp $ac7e	                jmp asm_common
.aabc					z_asm_jmp_i:
.aabc					xt_asm_jmp_xi:
.aabc	a9 7c		lda #$7c	                lda #$7C
.aabe	4c 7e ac	jmp $ac7e	                jmp asm_common
.aac1					z_asm_jmp_xi:
.aac1					xt_asm_jsr:
.aac1	a9 20		lda #$20	                lda #$20
.aac3	4c 7e ac	jmp $ac7e	                jmp asm_common
.aac6					z_asm_jsr:
.aac6					xt_asm_lda:
.aac6	a9 ad		lda #$ad	                lda #$AD
.aac8	4c 7e ac	jmp $ac7e	                jmp asm_common
.aacb					z_asm_lda:
.aacb					xt_asm_lda_h:
.aacb	a9 a9		lda #$a9	                lda #$A9
.aacd	4c 7e ac	jmp $ac7e	                jmp asm_common
.aad0					z_asm_lda_h:
.aad0					xt_asm_lda_x:
.aad0	a9 bd		lda #$bd	                lda #$BD
.aad2	4c 7e ac	jmp $ac7e	                jmp asm_common
.aad5					z_asm_lda_x:
.aad5					xt_asm_lda_y:
.aad5	a9 b9		lda #$b9	                lda #$B9
.aad7	4c 7e ac	jmp $ac7e	                jmp asm_common
.aada					z_asm_lda_y:
.aada					xt_asm_lda_z:
.aada	a9 a5		lda #$a5	                lda #$A5
.aadc	4c 7e ac	jmp $ac7e	                jmp asm_common
.aadf					z_asm_lda_z:
.aadf					xt_asm_lda_zi:
.aadf	a9 b2		lda #$b2	                lda #$B2
.aae1	4c 7e ac	jmp $ac7e	                jmp asm_common
.aae4					z_asm_lda_zi:
.aae4					xt_asm_lda_ziy:
.aae4	a9 b1		lda #$b1	                lda #$B1
.aae6	4c 7e ac	jmp $ac7e	                jmp asm_common
.aae9					z_asm_lda_ziy:
.aae9					xt_asm_lda_zx:
.aae9	a9 b5		lda #$b5	                lda #$B5
.aaeb	4c 7e ac	jmp $ac7e	                jmp asm_common
.aaee					z_asm_lda_zx:
.aaee					xt_asm_lda_zxi:
.aaee	a9 a1		lda #$a1	                lda #$A1
.aaf0	4c 7e ac	jmp $ac7e	                jmp asm_common
.aaf3					z_asm_lda_zxi:
.aaf3					xt_asm_ldx:
.aaf3	a9 ae		lda #$ae	                lda #$AE
.aaf5	4c 7e ac	jmp $ac7e	                jmp asm_common
.aaf8					z_asm_ldx:
.aaf8					xt_asm_ldx_h:
.aaf8	a9 a2		lda #$a2	                lda #$A2
.aafa	4c 7e ac	jmp $ac7e	                jmp asm_common
.aafd					z_asm_ldx_h:
.aafd					xt_asm_ldx_y:
.aafd	a9 be		lda #$be	                lda #$BE
.aaff	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab02					z_asm_ldx_y:
.ab02					xt_asm_ldx_z:
.ab02	a9 a6		lda #$a6	                lda #$A6
.ab04	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab07					z_asm_ldx_z:
.ab07					xt_asm_ldx_zy:
.ab07	a9 b6		lda #$b6	                lda #$B6
.ab09	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab0c					z_asm_ldx_zy:
.ab0c					xt_asm_ldy:
.ab0c	a9 ac		lda #$ac	                lda #$AC
.ab0e	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab11					z_asm_ldy:
.ab11					xt_asm_ldy_h:
.ab11	a9 a0		lda #$a0	                lda #$A0
.ab13	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab16					z_asm_ldy_h:
.ab16					xt_asm_ldy_x:
.ab16	a9 bc		lda #$bc	                lda #$BC
.ab18	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab1b					z_asm_ldy_x:
.ab1b					xt_asm_ldy_z:
.ab1b	a9 a4		lda #$a4	                lda #$A4
.ab1d	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab20					z_asm_ldy_z:
.ab20					xt_asm_ldy_zx:
.ab20	a9 b4		lda #$b4	                lda #$B4
.ab22	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab25					z_asm_ldy_zx:
.ab25					xt_asm_lsr:
.ab25	a9 4e		lda #$4e	                lda #$4E
.ab27	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab2a					z_asm_lsr:
.ab2a					xt_asm_lsr_a:
.ab2a	a9 4a		lda #$4a	                lda #$4A
.ab2c	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab2f					z_asm_lsr_a:
.ab2f					xt_asm_lsr_x:
.ab2f	a9 5e		lda #$5e	                lda #$5E
.ab31	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab34					z_asm_lsr_x:
.ab34					xt_asm_lsr_z:
.ab34	a9 46		lda #$46	                lda #$46
.ab36	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab39					z_asm_lsr_z:
.ab39					xt_asm_lsr_zx:
.ab39	a9 56		lda #$56	                lda #$56
.ab3b	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab3e					z_asm_lsr_zx:
.ab3e					xt_asm_nop:
.ab3e	a9 ea		lda #$ea	                lda #$EA
.ab40	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab43					z_asm_nop:
.ab43					xt_asm_ora:
.ab43	a9 0d		lda #$0d	                lda #$0D
.ab45	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab48					z_asm_ora:
.ab48					xt_asm_ora_h:
.ab48	a9 09		lda #$09	                lda #$09
.ab4a	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab4d					z_asm_ora_h:
.ab4d					xt_asm_ora_x:
.ab4d	a9 1d		lda #$1d	                lda #$1D
.ab4f	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab52					z_asm_ora_x:
.ab52					xt_asm_ora_y:
.ab52	a9 19		lda #$19	                lda #$19
.ab54	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab57					z_asm_ora_y:
.ab57					xt_asm_ora_z:
.ab57	a9 05		lda #$05	                lda #$05
.ab59	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab5c					z_asm_ora_z:
.ab5c					xt_asm_ora_zi:
.ab5c	a9 12		lda #$12	                lda #$12
.ab5e	a0 02		ldy #$02	                ldy #2
.ab60	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab63					z_asm_ora_zi:
.ab63					xt_asm_ora_ziy:
.ab63	a9 11		lda #$11	                lda #$11
.ab65	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab68					z_asm_ora_ziy:
.ab68					xt_asm_ora_zx:
.ab68	a9 15		lda #$15	                lda #$15
.ab6a	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab6d					z_asm_ora_zx:
.ab6d					xt_asm_ora_zxi:
.ab6d	a9 01		lda #$01	                lda #$01
.ab6f	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab72					z_asm_ora_zxi:
.ab72					xt_asm_pha:
.ab72	a9 48		lda #$48	                lda #$48
.ab74	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab77					z_asm_pha:
.ab77					xt_asm_php:
.ab77	a9 08		lda #$08	                lda #$08
.ab79	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab7c					z_asm_php:
.ab7c					xt_asm_phx:
.ab7c	a9 da		lda #$da	                lda #$DA
.ab7e	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab81					z_asm_phx:
.ab81					xt_asm_phy:
.ab81	a9 5a		lda #$5a	                lda #$5A
.ab83	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab86					z_asm_phy:
.ab86					xt_asm_pla:
.ab86	a9 68		lda #$68	                lda #$68
.ab88	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab8b					z_asm_pla:
.ab8b					xt_asm_plp:
.ab8b	a9 28		lda #$28	                lda #$28
.ab8d	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab90					z_asm_plp:
.ab90					xt_asm_plx:
.ab90	a9 fa		lda #$fa	                lda #$FA
.ab92	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab95					z_asm_plx:
.ab95					xt_asm_ply:
.ab95	a9 7a		lda #$7a	                lda #$7A
.ab97	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab9a					z_asm_ply:
.ab9a					xt_asm_rol:
.ab9a	a9 2e		lda #$2e	                lda #$2E
.ab9c	4c 7e ac	jmp $ac7e	                jmp asm_common
.ab9f					z_asm_rol:
.ab9f					xt_asm_rol_a:
.ab9f	a9 2a		lda #$2a	                lda #$2A
.aba1	4c 7e ac	jmp $ac7e	                jmp asm_common
.aba4					z_asm_rol_a:
.aba4					xt_asm_rol_x:
.aba4	a9 3e		lda #$3e	                lda #$3E
.aba6	4c 7e ac	jmp $ac7e	                jmp asm_common
.aba9					z_asm_rol_x:
.aba9					xt_asm_rol_z:
.aba9	a9 26		lda #$26	                lda #$26
.abab	4c 7e ac	jmp $ac7e	                jmp asm_common
.abae					z_asm_rol_z:
.abae					xt_asm_rol_zx:
.abae	a9 36		lda #$36	                lda #$36
.abb0	4c 7e ac	jmp $ac7e	                jmp asm_common
.abb3					z_asm_rol_zx:
.abb3					xt_asm_ror:
.abb3	a9 6e		lda #$6e	                lda #$6E
.abb5	4c 7e ac	jmp $ac7e	                jmp asm_common
.abb8					z_asm_ror:
.abb8					xt_asm_ror_a:
.abb8	a9 6a		lda #$6a	                lda #$6A
.abba	4c 7e ac	jmp $ac7e	                jmp asm_common
.abbd					z_asm_ror_a:
.abbd					xt_asm_ror_x:
.abbd	a9 7e		lda #$7e	                lda #$7E
.abbf	4c 7e ac	jmp $ac7e	                jmp asm_common
.abc2					z_asm_ror_x:
.abc2					xt_asm_ror_z:
.abc2	a9 66		lda #$66	                lda #$66
.abc4	4c 7e ac	jmp $ac7e	                jmp asm_common
.abc7					z_asm_ror_z:
.abc7					xt_asm_ror_zx:
.abc7	a9 76		lda #$76	                lda #$76
.abc9	4c 7e ac	jmp $ac7e	                jmp asm_common
.abcc					z_asm_ror_zx:
.abcc					xt_asm_rti:
.abcc	a9 40		lda #$40	                lda #$40
.abce	4c 7e ac	jmp $ac7e	                jmp asm_common
.abd1					z_asm_rti:
.abd1					xt_asm_rts:
.abd1	a9 60		lda #$60	                lda #$60
.abd3	4c 7e ac	jmp $ac7e	                jmp asm_common
.abd6					z_asm_rts:
.abd6					xt_asm_sbc:
.abd6	a9 ed		lda #$ed	                lda #$ED
.abd8	4c 7e ac	jmp $ac7e	                jmp asm_common
.abdb					z_asm_sbc:
.abdb					xt_asm_sbc_h:
.abdb	a9 e9		lda #$e9	                lda #$E9
.abdd	4c 7e ac	jmp $ac7e	                jmp asm_common
.abe0					z_asm_sbc_h:
.abe0					xt_asm_sbc_x:
.abe0	a9 fd		lda #$fd	                lda #$FD
.abe2	4c 7e ac	jmp $ac7e	                jmp asm_common
.abe5					z_asm_sbc_x:
.abe5					xt_asm_sbc_y:
.abe5	a9 f9		lda #$f9	                lda #$F9
.abe7	4c 7e ac	jmp $ac7e	                jmp asm_common
.abea					z_asm_sbc_y:
.abea					xt_asm_sbc_z:
.abea	a9 e5		lda #$e5	                lda #$E5
.abec	4c 7e ac	jmp $ac7e	                jmp asm_common
.abef					z_asm_sbc_z:
.abef					xt_asm_sbc_zi:
.abef	a9 f2		lda #$f2	                lda #$F2
.abf1	4c 7e ac	jmp $ac7e	                jmp asm_common
.abf4					z_asm_sbc_zi:
.abf4					xt_asm_sbc_ziy:
.abf4	a9 f1		lda #$f1	                lda #$F1
.abf6	4c 7e ac	jmp $ac7e	                jmp asm_common
.abf9					z_asm_sbc_ziy:
.abf9					xt_asm_sbc_zx:
.abf9	a9 f5		lda #$f5	                lda #$F5
.abfb	4c 7e ac	jmp $ac7e	                jmp asm_common
.abfe					z_asm_sbc_zx:
.abfe					xt_asm_sbc_zxi:
.abfe	a9 e1		lda #$e1	                lda #$E1
.ac00	80 7c		bra $ac7e	                bra asm_common  ; <-- limit for BRA instead of JMP
.ac02					z_asm_sbc_zxi:
.ac02					xt_asm_sec:
.ac02	a9 38		lda #$38	                lda #$38
.ac04	80 78		bra $ac7e	                bra asm_common
.ac06					z_asm_sec:
.ac06					xt_asm_sed:
.ac06	a9 f8		lda #$f8	                lda #$F8
.ac08	80 74		bra $ac7e	                bra asm_common
.ac0a					z_asm_sed:
.ac0a					xt_asm_sei:
.ac0a	a9 78		lda #$78	                lda #$78
.ac0c	80 70		bra $ac7e	                bra asm_common
.ac0e					z_asm_sei:
.ac0e					xt_asm_sta:
.ac0e	a9 8d		lda #$8d	                lda #$8D
.ac10	80 6c		bra $ac7e	                bra asm_common
.ac12					z_asm_sta:
.ac12					xt_asm_sta_x:
.ac12	a9 9d		lda #$9d	                lda #$9D
.ac14	80 68		bra $ac7e	                bra asm_common
.ac16					z_asm_sta_x:
.ac16					xt_asm_sta_y:
.ac16	a9 99		lda #$99	                lda #$99
.ac18	80 64		bra $ac7e	                bra asm_common
.ac1a					z_asm_sta_y:
.ac1a					xt_asm_sta_z:
.ac1a	a9 85		lda #$85	                lda #$85
.ac1c	80 60		bra $ac7e	                bra asm_common
.ac1e					z_asm_sta_z:
.ac1e					xt_asm_sta_zi:
.ac1e	a9 92		lda #$92	                lda #$92
.ac20	80 5c		bra $ac7e	                bra asm_common
.ac22					z_asm_sta_zi:
.ac22					xt_asm_sta_ziy:
.ac22	a9 91		lda #$91	                lda #$91
.ac24	80 58		bra $ac7e	                bra asm_common
.ac26					z_asm_sta_ziy:
.ac26					xt_asm_sta_zx:
.ac26	a9 95		lda #$95	                lda #$95
.ac28	80 54		bra $ac7e	                bra asm_common
.ac2a					z_asm_sta_zx:
.ac2a					xt_asm_sta_zxi:
.ac2a	a9 81		lda #$81	                lda #$81
.ac2c	80 50		bra $ac7e	                bra asm_common
.ac2e					z_asm_sta_zxi:
.ac2e					xt_asm_stx:
.ac2e	a9 8e		lda #$8e	                lda #$8E
.ac30	80 4c		bra $ac7e	                bra asm_common
.ac32					z_asm_stx:
.ac32					xt_asm_stx_z:
.ac32	a9 86		lda #$86	                lda #$86
.ac34	80 48		bra $ac7e	                bra asm_common
.ac36					z_asm_stx_z:
.ac36					xt_asm_stx_zy:
.ac36	a9 96		lda #$96	                lda #$96
.ac38	80 44		bra $ac7e	                bra asm_common
.ac3a					z_asm_stx_zy:
.ac3a					xt_asm_sty:
.ac3a	a9 8c		lda #$8c	                lda #$8C
.ac3c	80 40		bra $ac7e	                bra asm_common
.ac3e					z_asm_sty:
.ac3e					xt_asm_sty_z:
.ac3e	a9 84		lda #$84	                lda #$84
.ac40	80 3c		bra $ac7e	                bra asm_common
.ac42					z_asm_sty_z:
.ac42					xt_asm_sty_zx:
.ac42	a9 94		lda #$94	                lda #$94
.ac44	80 38		bra $ac7e	                bra asm_common
.ac46					z_asm_sty_zx:
.ac46					xt_asm_stz:
.ac46	a9 9c		lda #$9c	                lda #$9C
.ac48	80 34		bra $ac7e	                bra asm_common
.ac4a					z_asm_stz:
.ac4a					xt_asm_stz_x:
.ac4a	a9 9e		lda #$9e	                lda #$9E
.ac4c	80 30		bra $ac7e	                bra asm_common
.ac4e					z_asm_stz_x:
.ac4e					xt_asm_stz_z:
.ac4e	a9 64		lda #$64	                lda #$64
.ac50	80 2c		bra $ac7e	                bra asm_common
.ac52					z_asm_stz_z:
.ac52					xt_asm_stz_zx:
.ac52	a9 74		lda #$74	                lda #$74
.ac54	80 28		bra $ac7e	                bra asm_common
.ac56					z_asm_stz_zx:
.ac56					xt_asm_tax:
.ac56	a9 aa		lda #$aa	                lda #$AA
.ac58	80 24		bra $ac7e	                bra asm_common
.ac5a					z_asm_tax:
.ac5a					xt_asm_tay:
.ac5a	a9 a8		lda #$a8	                lda #$A8
.ac5c	80 20		bra $ac7e	                bra asm_common
.ac5e					z_asm_tay:
.ac5e					xt_asm_trb:
.ac5e	a9 1c		lda #$1c	                lda #$1C
.ac60	80 1c		bra $ac7e	                bra asm_common
.ac62					z_asm_trb:
.ac62					xt_asm_trb_z:
.ac62	a9 14		lda #$14	                lda #$14
.ac64	80 18		bra $ac7e	                bra asm_common
.ac66					z_asm_trb_z:
.ac66					xt_asm_tsb:
.ac66	a9 0c		lda #$0c	                lda #$0C
.ac68	80 14		bra $ac7e	                bra asm_common
.ac6a					z_asm_tsb:
.ac6a					xt_asm_tsb_z:
.ac6a	a9 04		lda #$04	                lda #$04
.ac6c	80 10		bra $ac7e	                bra asm_common
.ac6e					z_asm_tsb_z:
.ac6e					xt_asm_tsx:
.ac6e	a9 ba		lda #$ba	                lda #$BA
.ac70	80 0c		bra $ac7e	                bra asm_common
.ac72					z_asm_tsx:
.ac72					xt_asm_txa:
.ac72	a9 8a		lda #$8a	                lda #$8A
.ac74	80 08		bra $ac7e	                bra asm_common
.ac76					z_asm_txa:
.ac76					xt_asm_txs:
.ac76	a9 9a		lda #$9a	                lda #$9A
.ac78	80 04		bra $ac7e	                bra asm_common
.ac7a					z_asm_txs:
.ac7a					xt_asm_tya:
.ac7a	a9 98		lda #$98	                lda #$98
.ac7c	80 00		bra $ac7e	                bra asm_common
.ac7e					z_asm_tya:
.ac7e					asm_common:
.ac7e	a8		tay		                tay
.ac7f	20 d4 d7	jsr $d7d4	                jsr cmpl_a
.ac82	a9 3c		lda #$3c	                lda #<oc_index_table
.ac84	85 26		sta $26		                sta tmp2
.ac86	a9 af		lda #$af	                lda #>oc_index_table
.ac88	85 27		sta $27		                sta tmp2+1
.ac8a	98		tya		                tya             ; retrieve opcode
.ac8b	0a		asl a		                asl             ; times two for offset
.ac8c	90 02		bcc $ac90	                bcc +
.ac8e	e6 27		inc $27		                inc tmp2+1
.ac90					+
.ac90	a8		tay		                tay             ; use Y as the index
.ac91	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac93	85 28		sta $28		                sta tmp3
.ac95	c8		iny		                iny
.ac96	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac98	85 29		sta $29		                sta tmp3+1
.ac9a	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac9c	2a		rol a		                rol
.ac9d	2a		rol a		                rol
.ac9e	2a		rol a		                rol             ; Three times because we go through Carry
.ac9f	29 03		and #$03	                and #%00000011
.aca1	a8		tay		                tay
.aca2	88		dey		                dey
.aca3	f0 12		beq $acb7	                beq _done
.aca5	20 2e d9	jsr $d92e	                jsr underflow_1
.aca8	b5 00		lda $00,x	                lda 0,x
.acaa	20 d4 d7	jsr $d7d4	                jsr cmpl_a      ; does not use Y
.acad	88		dey		                dey
.acae	f0 05		beq $acb5	                beq _done_drop
.acb0	b5 01		lda $01,x	                lda 1,x
.acb2	20 d4 d7	jsr $d7d4	                jsr cmpl_a      ; Fall through to _done_drop
.acb5					_done_drop:
.acb5	e8		inx		                inx
.acb6	e8		inx		                inx             ; Fall through to _done
.acb7					_done:
.acb7	60		rts		                rts             ; Returns to original caller
.acb8					xt_asm_push_a:
.acb8	a0 00		ldy #$00	                ldy #0
.acba					_loop:
.acba	b9 c8 ac	lda $acc8,y	                lda asm_push_a_data,y
.acbd	c9 ff		cmp #$ff	                cmp #$FF
.acbf	f0 06		beq $acc7	                beq _done
.acc1	20 d4 d7	jsr $d7d4	                jsr cmpl_a      ; does not change Y
.acc4	c8		iny		                iny
.acc5	80 f3		bra $acba	                bra _loop
.acc7					_done:
.acc7					z_asm_push_a:
.acc7	60		rts		                rts
.acc8					asm_push_a_data:
>acc8	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acce	ff				        .byte $FF               ; terminator
.accf					xt_asm_back_jump:
.accf					z_asm_back_jump:
.accf	60		rts		                rts
.acd0					xt_asm_back_branch:
.acd0	20 8e 91	jsr $918e	                jsr xt_here             ; ( addr-l addr-h )
.acd3	20 81 95	jsr $9581	                jsr xt_minus            ; ( offset )
.acd6	3a		dec a		                dea
.acd7	3a		dec a		                dea
.acd8					z_asm_back_branch:
.acd8	60		rts		                rts
.acd9					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acd9					disassembler:
.acd9	20 7f 89	jsr $897f	                jsr xt_cr       ; ( addr u )
.acdc					_byte_loop:
.acdc	20 c4 98	jsr $98c4	                jsr xt_over     ; ( addr u addr )
.acdf	20 30 a5	jsr $a530	                jsr xt_u_dot    ; ( addr u )
.ace2	20 20 a1	jsr $a120	                jsr xt_space
.ace5	a9 3c		lda #$3c	                lda #<oc_index_table
.ace7	85 26		sta $26		                sta tmp2
.ace9	a9 af		lda #$af	                lda #>oc_index_table
.aceb	85 27		sta $27		                sta tmp2+1
.aced	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.acef	85 36		sta $36		                sta scratch     ; Save opcode
.acf1	0a		asl a		                asl             ; multiply by two for offset
.acf2	90 02		bcc $acf6	                bcc +
.acf4	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.acf6					+
.acf6	a8		tay		                tay             ; use Y as the index
.acf7	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.acf9	85 28		sta $28		                sta tmp3
.acfb	48		pha		                pha
.acfc	c8		iny		                iny
.acfd	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acff	85 29		sta $29		                sta tmp3+1
.ad01	48		pha		                pha
.ad02	b2 28		lda ($28)	                lda (tmp3)
.ad04	a8		tay		                tay                     ; save copy of lengths byte
.ad05	10 3c		bpl $ad43	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.ad07	20 aa a7	jsr $a7aa	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ad0a	f6 04		inc $04,x	                inc 4,x
.ad0c	d0 02		bne $ad10	                bne +
.ad0e	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ad10					+
.ad10	b5 02		lda $02,x	                lda 2,x
.ad12	d0 02		bne $ad16	                bne +
.ad14	d6 03		dec $03,x	                dec 3,x
.ad16					+
.ad16	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.ad18	a1 04		lda ($04,x)	                lda (4,x)
.ad1a	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.ad1c	85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.ad1e	98		tya		                tya                     ; retrieve copy of lengths byte
.ad1f	2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad20	10 14		bpl $ad36	                bpl _print_operand
.ad22	f6 04		inc $04,x	                inc 4,x
.ad24	d0 02		bne $ad28	                bne +
.ad26	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad28					+
.ad28	b5 02		lda $02,x	                lda 2,x
.ad2a	d0 02		bne $ad2e	                bne +
.ad2c	d6 03		dec $03,x	                dec 3,x
.ad2e					+
.ad2e	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad30	a1 04		lda ($04,x)	                lda (4,x)
.ad32	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad34	85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad36					_print_operand:
.ad36	ca		dex		                dex
.ad37	ca		dex		                dex
.ad38	a9 05		lda #$05	                lda #5
.ad3a	95 00		sta $00,x	                sta 0,x
.ad3c	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad3e	20 3c a5	jsr $a53c	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad41	80 0b		bra $ad4e	                bra _print_mnemonic
.ad43					_no_operand:
.ad43	ca		dex		                dex
.ad44	ca		dex		                dex
.ad45	a9 05		lda #$05	                lda #5
.ad47	95 00		sta $00,x	                sta 0,x
.ad49	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad4b	20 26 a1	jsr $a126	                jsr xt_spaces           ; ( addr u )
.ad4e					_print_mnemonic:
.ad4e	20 20 a1	jsr $a120	                jsr xt_space
.ad51	ca		dex		                dex
.ad52	ca		dex		                dex                     ; ( addr u ? )
.ad53	68		pla		                pla                     ; MSB
.ad54	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad56	68		pla		                pla                     ; LSB
.ad57	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad59	20 6b 89	jsr $896b	                jsr xt_count            ; ( addr u addr-o u-o )
.ad5c	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad5e	b5 00		lda $00,x	                lda 0,x
.ad60	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad62	95 00		sta $00,x	                sta 0,x
.ad64	20 05 a5	jsr $a505	                jsr xt_type             ; ( addr u )
.ad67	a5 36		lda $36		                lda scratch
.ad69	c9 20		cmp #$20	                cmp #$20
.ad6b	d0 4e		bne $adbb	                bne _not_jsr
.ad6d	ca		dex		                dex
.ad6e	ca		dex		                dex
.ad6f	a9 05		lda #$05	                lda #5
.ad71	95 00		sta $00,x	                sta 0,x
.ad73	74 01		stz $01,x	                stz 1,x
.ad75	20 26 a1	jsr $a126	                jsr xt_spaces
.ad78	a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.ad7a	b9 a7 ad	lda $ada7,y	_check_handler: lda _special_handlers,y
.ad7d	c5 37		cmp $37		                cmp scratch+1
.ad7f	d0 07		bne $ad88	                bne _next_handler
.ad81	b9 a8 ad	lda $ada8,y	                lda _special_handlers+1,y
.ad84	c5 38		cmp $38		                cmp scratch+2
.ad86	f0 0c		beq $ad94	                beq _run_handler
.ad88	88		dey		_next_handler:  dey
.ad89	88		dey		                dey
.ad8a	88		dey		                dey
.ad8b	88		dey		                dey
.ad8c	10 ec		bpl $ad7a	                bpl _check_handler
.ad8e					_not_special:
.ad8e	20 ec ae	jsr $aeec	                jsr disasm_jsr
.ad91	4c 25 ae	jmp $ae25	                jmp _printing_done
.ad94					_run_handler:
.ad94	b9 a9 ad	lda $ada9,y	                lda _special_handlers+2,y
.ad97	85 39		sta $39		                sta scratch+3
.ad99	b9 aa ad	lda $adaa,y	                lda _special_handlers+3,y
.ad9c	85 3a		sta $3a		                sta scratch+4
.ad9e	20 a4 ad	jsr $ada4	                jsr _dispatch_handler
.ada1	4c 25 ae	jmp $ae25	                jmp _printing_done
.ada4					_dispatch_handler:
.ada4	6c 39 00	jmp ($0039)	                jmp (scratch+3)
.ada7					_special_handlers:
>ada7	b4 93 ae ae			    .word literal_runtime,      disasm_literal
>adab	d3 93 cc ae			    .word byte_runtime,         disasm_byte_literal
>adaf	ab a0 6b ae			    .word sliteral_runtime,     disasm_sliteral
>adb3	30 92 a2 ae			    .word zero_branch_runtime,  disasm_0branch
>adb7	f7 8d a7 ae			    .word branch_runtime,       disasm_branch
.adbb					_end_handlers:
.adbb					_not_jsr:
.adbb	c9 4c		cmp #$4c	                cmp #$4C
.adbd	d0 2c		bne $adeb	                bne _not_jmp
.adbf	a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.adc1	85 39		sta $39		                sta scratch+3
.adc3	a5 38		lda $38		                lda scratch+2
.adc5	85 3a		sta $3a		                sta scratch+4
.adc7	b2 39		lda ($39)	                lda (scratch+3)
.adc9	c9 20		cmp #$20	                cmp #$20 ; check for JSR
.adcb	d0 58		bne $ae25	                bne _printing_done
.adcd	e6 39		inc $39		                inc scratch+3
.adcf	d0 02		bne $add3	                bne +
.add1	e6 3a		inc $3a		                inc scratch+4
.add3					+
.add3	b2 39		lda ($39)	                lda (scratch+3)
.add5	c9 ab		cmp #$ab	                cmp #<sliteral_runtime
.add7	d0 4c		bne $ae25	                bne _printing_done
.add9	e6 39		inc $39		                inc scratch+3
.addb	d0 02		bne $addf	                bne +
.addd	e6 3a		inc $3a		                inc scratch+4
.addf					+
.addf	b2 39		lda ($39)	                lda (scratch+3)
.ade1	c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.ade3	d0 40		bne $ae25	                bne _printing_done
.ade5	20 41 ae	jsr $ae41	                jsr disasm_sliteral_jump
.ade8	4c 25 ae	jmp $ae25	                jmp _printing_done
.adeb					_not_jmp:
.adeb	c9 80		cmp #$80	                cmp #$80            ; is it bra?
.aded	f0 06		beq $adf5	                beq _is_rel
.adef	29 1f		and #$1f	                and #$1f
.adf1	49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.adf3	d0 30		bne $ae25	                bne _printing_done
.adf5					_is_rel:
.adf5	a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.adf7	ca		dex		                dex
.adf8	ca		dex		                dex
.adf9	74 01		stz $01,x	                stz 1,x
.adfb	a5 37		lda $37		                lda scratch+1
.adfd	95 00		sta $00,x	                sta 0,x
.adff	10 04		bpl $ae05	                bpl +
.ae01	d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.ae03	a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.ae05	38		sec		+               sec                 ; start counting from address after opcode
.ae06	75 04		adc $04,x	                adc 4,x
.ae08	95 00		sta $00,x	                sta 0,x
.ae0a	b5 01		lda $01,x	                lda 1,x
.ae0c	75 05		adc $05,x	                adc 5,x
.ae0e	95 01		sta $01,x	                sta 1,x
.ae10	5a		phy		                phy                 ; save the direction indicator
.ae11	ca		dex		                dex
.ae12	ca		dex		                dex
.ae13	a9 09		lda #$09	                lda #9
.ae15	95 00		sta $00,x	                sta 0,x
.ae17	74 01		stz $01,x	                stz 1,x
.ae19	20 3c a5	jsr $a53c	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.ae1c	a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.ae1e	20 12 8e	jsr $8e12	                jsr emit_a
.ae21	68		pla		                pla
.ae22	20 12 8e	jsr $8e12	                jsr emit_a
.ae25					_printing_done:
.ae25	20 7f 89	jsr $897f	                jsr xt_cr
.ae28	f6 02		inc $02,x	                inc 2,x
.ae2a	d0 02		bne $ae2e	                bne +
.ae2c	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae2e					+
.ae2e	20 42 98	jsr $9842	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae31	b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae33	15 01		ora $01,x	                ora 1,x
.ae35	f0 07		beq $ae3e	                beq _done
.ae37	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae39	30 03		bmi $ae3e	                bmi _done
.ae3b	4c dc ac	jmp $acdc	                jmp _byte_loop          ; out of range for BRA
.ae3e					_done:
.ae3e	4c b2 a3	jmp $a3b2	                jmp xt_two_drop         ; JSR/RTS
.ae41					disasm_sliteral_jump:
.ae41	20 b0 a1	jsr $a1b0	                jsr xt_swap
.ae44	ca		dex		                dex
.ae45	ca		dex		                dex
.ae46	a5 37		lda $37		                lda scratch+1
.ae48	95 00		sta $00,x	                sta 0,x
.ae4a	a5 38		lda $38		                lda scratch+2
.ae4c	95 01		sta $01,x	                sta 1,x
.ae4e	20 b0 a1	jsr $a1b0	                jsr xt_swap
.ae51	20 81 95	jsr $9581	                jsr xt_minus
.ae54	20 42 98	jsr $9842	                jsr xt_one_minus
.ae57	20 81 95	jsr $9581	                jsr xt_minus
.ae5a	ca		dex		                dex
.ae5b	ca		dex		                dex
.ae5c	a5 37		lda $37		                lda scratch+1
.ae5e	95 00		sta $00,x	                sta 0,x
.ae60	a5 38		lda $38		                lda scratch+2
.ae62	95 01		sta $01,x	                sta 1,x
.ae64	20 42 98	jsr $9842	                jsr xt_one_minus
.ae67	20 b0 a1	jsr $a1b0	                jsr xt_swap ; ( new_addr new_n )
.ae6a	60		rts		                rts
.ae6b					disasm_sliteral:
.ae6b	a9 53		lda #$53	                lda #'S'
.ae6d	20 12 8e	jsr $8e12	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae70	a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.ae72	20 6a d9	jsr $d96a	                jsr print_string_no_lf
.ae75	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; switch to (u addr)
.ae78	20 4e 98	jsr $984e	                jsr xt_one_plus
.ae7b	20 cb 8d	jsr $8dcb	                jsr xt_dup
.ae7e	20 9c 8f	jsr $8f9c	                jsr xt_fetch
.ae81	20 30 a5	jsr $a530	                jsr xt_u_dot            ; Print the address of the string
.ae84	20 a9 a3	jsr $a3a9	                jsr xt_two
.ae87	20 14 9a	jsr $9a14	                jsr xt_plus
.ae8a	20 cb 8d	jsr $8dcb	                jsr xt_dup
.ae8d	20 93 9a	jsr $9a93	                jsr xt_question         ; Print the length of the string
.ae90	20 4e 98	jsr $984e	                jsr xt_one_plus
.ae93	20 b0 a1	jsr $a1b0	                jsr xt_swap            ; ( addr+4 u )
.ae96	ca		dex		                dex
.ae97	ca		dex		                dex
.ae98	a9 04		lda #$04	                lda #4
.ae9a	95 00		sta $00,x	                sta 0,x
.ae9c	74 01		stz $01,x	                stz 1,x
.ae9e	20 81 95	jsr $9581	                jsr xt_minus            ; ( addr+4 u-4 )
.aea1	60		rts		                rts
.aea2					disasm_0branch:
.aea2	a9 30		lda #$30	                lda #'0'
.aea4	20 12 8e	jsr $8e12	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.aea7					disasm_branch:
.aea7	a9 0e		lda #$0e	                lda #str_disasm_bra
.aea9	20 6a d9	jsr $d96a	                jsr print_string_no_lf ; "BRANCH "
.aeac	80 05		bra $aeb3	                bra disasm_print_literal
.aeae					disasm_literal:
.aeae	a9 0c		lda #$0c	                lda #str_disasm_lit
.aeb0	20 6a d9	jsr $d96a	                jsr print_string_no_lf ; "LITERAL "
.aeb3					disasm_print_literal:
.aeb3	20 b0 a1	jsr $a1b0	                jsr xt_swap ; switch to (u addr)
.aeb6	20 4e 98	jsr $984e	                jsr xt_one_plus
.aeb9	20 cb 8d	jsr $8dcb	                jsr xt_dup
.aebc	20 93 9a	jsr $9a93	                jsr xt_question ; Print the value at the address
.aebf	20 4e 98	jsr $984e	                jsr xt_one_plus
.aec2	20 b0 a1	jsr $a1b0	                jsr xt_swap ; (addr+2 u)
.aec5	20 42 98	jsr $9842	                jsr xt_one_minus
.aec8	20 42 98	jsr $9842	                jsr xt_one_minus ; (addr+2 u-2)
.aecb	60		rts		                rts
.aecc					disasm_byte_literal:
.aecc	a9 42		lda #$42	                lda #'B'
.aece	20 12 8e	jsr $8e12	                jsr emit_a ; Add leading B
.aed1	a9 0c		lda #$0c	                lda #str_disasm_lit
.aed3	20 6a d9	jsr $d96a	                jsr print_string_no_lf ; "LITERAL "
.aed6	20 b0 a1	jsr $a1b0	                jsr xt_swap ; switch to (u addr)
.aed9	20 4e 98	jsr $984e	                jsr xt_one_plus
.aedc	20 cb 8d	jsr $8dcb	                jsr xt_dup
.aedf	20 27 86	jsr $8627	                jsr xt_c_fetch  ; Print byte at the address
.aee2	20 52 8c	jsr $8c52	                jsr xt_dot
.aee5	20 b0 a1	jsr $a1b0	                jsr xt_swap ; (addr+1 u)
.aee8	20 42 98	jsr $9842	                jsr xt_one_minus ; (addr+1 u-1)
.aeeb	60		rts		                rts
.aeec					disasm_jsr:
.aeec	ca		dex		                dex
.aeed	ca		dex		                dex
.aeee	a5 37		lda $37		                lda scratch+1
.aef0	95 00		sta $00,x	                sta 0,x
.aef2	a5 38		lda $38		                lda scratch+2
.aef4	95 01		sta $01,x	                sta 1,x
.aef6	20 94 92	jsr $9294	                jsr xt_int_to_name
.aef9	b5 00		lda $00,x	                lda 0,x
.aefb	15 01		ora $01,x	                ora 1,x
.aefd	f0 07		beq $af06	                beq _disasm_no_nt
.aeff	20 2f 96	jsr $962f	                jsr xt_name_to_string
.af02	20 05 a5	jsr $a505	                jsr xt_type
.af05	60		rts		                rts
.af06					_disasm_no_nt:
.af06	20 4a 8d	jsr $8d4a	                jsr xt_drop ; the 0 indicating no name token
.af09	ca		dex		                dex
.af0a	ca		dex		                dex
.af0b	a5 37		lda $37		                lda scratch+1
.af0d	95 00		sta $00,x	                sta 0,x
.af0f	a5 38		lda $38		                lda scratch+2
.af11	95 01		sta $01,x	                sta 1,x
.af13	ca		dex		                dex
.af14	ca		dex		                dex
.af15	a9 2e		lda #$2e	                lda #<underflow_1
.af17	95 00		sta $00,x	                sta 0,x
.af19	a9 d9		lda #$d9	                lda #>underflow_1
.af1b	95 01		sta $01,x	                sta 1,x
.af1d	20 48 d8	jsr $d848	                jsr compare_16bit
.af20	f0 02		beq $af24	                beq _disasm_jsr_uflow_check_upper
.af22	b0 14		bcs $af38	                bcs _disasm_jsr_unknown
.af24					_disasm_jsr_uflow_check_upper:
.af24	a9 3d		lda #$3d	                lda #<underflow_4
.af26	95 00		sta $00,x	                sta 0,x
.af28	a9 d9		lda #$d9	                lda #>underflow_4
.af2a	95 01		sta $01,x	                sta 1,x
.af2c	20 48 d8	jsr $d848	                jsr compare_16bit
.af2f	f0 02		beq $af33	                beq _disasm_jsr_soc
.af31	90 05		bcc $af38	                bcc _disasm_jsr_unknown
.af33					_disasm_jsr_soc:
.af33	a9 0d		lda #$0d	                lda #str_disasm_sdc
.af35	20 6a d9	jsr $d96a	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.af38					_disasm_jsr_unknown:
.af38	20 b2 a3	jsr $a3b2	                jsr xt_two_drop
.af3b	60		rts		                rts
.af3c					oc_index_table:
>af3c	3c b1 40 b1 d4 b5 d4 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>af44	48 b1 4e b1 54 b1 d4 b5
>af4c	5a b1 5e b1 64 b1 d4 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af54	6a b1 6e b1 72 b1 76 b1
>af5c	7b b1 7f b1 87 b1 d4 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af64	8e b1 94 b1 9b b1 a2 b1
>af6c	a9 b1 ad b1 b3 b1 d4 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af74	b9 b1 bd b1 d4 b5 c3 b1
>af7c	c9 b1 cd b1 d4 b5 d4 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af84	d5 b1 db b1 e1 b1 e7 b1
>af8c	ee b1 f2 b1 f8 b1 d4 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af94	fe b1 02 b2 07 b2 0b b2
>af9c	10 b2 14 b2 1c b2 d4 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>afa4	23 b2 2b b2 32 b2 39 b2
>afac	40 b2 44 b2 4a b2 d4 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>afb4	50 b2 56 b2 5c b2 76 b1
>afbc	67 b2 6b b2 d4 b5 d4 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>afc4	d4 b5 73 b2 79 b2 7f b2
>afcc	86 b2 8a b2 90 b2 d4 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>afd4	96 b2 9a b2 9e b2 a2 b2
>afdc	a7 b2 ab b2 b3 b2 d4 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>afe4	d4 b5 ba b2 c1 b2 c8 b2
>afec	cf b2 d3 b2 d9 b2 d4 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>aff4	d4 b5 d4 b5 e3 b2 e9 b2
>affc	ee b2 f2 b2 d4 b5 d4 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b004	fa b2 00 b3 06 b3 0c b3
>b00c	13 b3 17 b3 1d b3 d4 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>b014	23 b3 29 b3 2d b3 31 b3
>b01c	36 b3 3a b3 42 b3 d4 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b024	49 b3 50 b3 57 b3 5e b3
>b02c	65 b3 69 b3 6f b3 d4 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>b034	73 b3 7a b3 80 b3 86 b3
>b03c	8b b3 8f b3 d4 b5 d4 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b044	97 b3 9d b3 a3 b3 d4 b5
>b04c	a9 b3 ad b3 b3 b3 d4 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b054	b7 b3 bb b3 bf b3 c3 b3
>b05c	c8 b3 cc b3 d4 b3 d4 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b064	db b3 e2 b3 e9 b3 f0 b3
>b06c	f7 b3 fb b3 01 b4 d4 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b074	05 b4 09 b4 0f b4 15 b4
>b07c	1a b4 20 b4 28 b4 d4 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b084	2e b4 34 b4 3a b4 40 b4
>b08c	47 b4 4b b4 51 b4 d4 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b094	55 b4 59 b4 5d b4 61 b4
>b09c	66 b4 6a b4 72 b4 d4 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b0a4	79 b4 80 b4 87 b4 8e b4
>b0ac	95 b4 99 b4 9f b4 d4 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b0b4	a3 b4 a9 b4 af b4 b5 b4
>b0bc	ba b4 c0 b4 d4 b5 d4 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b0c4	c8 b4 ce b4 d4 b4 da b4
>b0cc	e1 b4 e5 b4 eb b4 d4 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b0d4	ef b4 f3 b4 f7 b4 fb b4
>b0dc	00 b5 04 b5 0c b5 d4 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b0e4	d4 b5 13 b5 1a b5 21 b5
>b0ec	28 b5 2c b5 32 b5 d4 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0f4	d4 b5 36 b5 3c b5 42 b5
>b0fc	47 b5 4d b5 d4 b5 d4 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b104	55 b5 5b b5 61 b5 67 b5
>b10c	6e b5 72 b5 78 b5 d4 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b114	7c b5 80 b5 84 b5 88 b5
>b11c	8d b5 91 b5 99 b5 d4 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b124	d4 b5 a0 b5 a7 b5 ae b5
>b12c	b5 b5 b9 b5 bf b5 d4 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b134	d4 b5 c3 b5 c9 b5 cf b5
.b13c					oc_table:
>b13c	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b140	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b148	85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b14e	85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b154	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b15a	43 70 68 70				oc08:	.text 1*64+3, "php"
>b15e	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b164	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b16a	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b16e	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b172	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b176	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b17b	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b17f	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b187	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b18e	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b194	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b19b	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b1a2	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b1a9	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b1ad	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b1b3	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b1b9	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b1bd	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b1c3	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b1c9	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b1cd	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b1d5	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b1db	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b1e1	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b1e7	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1ee	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1f2	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1f8	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1fe	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b202	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b207	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b20b	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b210	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b214	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b21c	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b223	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b22b	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b232	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b239	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b240	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b244	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b24a	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b250	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b256	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b25c	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b262	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b267	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b26b	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b273	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b279	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b27f	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b286	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b28a	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b290	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b296	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b29a	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b29e	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b2a2	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b2a7	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b2ab	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b2b3	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b2ba	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b2c1	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b2c8	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b2cf	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b2d3	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b2d9	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b2dd	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b2e3	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2e9	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2ee	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2f2	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2fa	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b300	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b306	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b30c	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b313	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b317	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b31d	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b323	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b329	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b32d	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b331	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b336	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b33a	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b342	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b349	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b350	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b357	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b35e	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b365	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b369	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b36f	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b373	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b37a	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b380	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b386	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b38b	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b38f	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b397	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b39d	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b3a3	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b3a9	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b3ad	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b3b3	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b3b7	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b3bb	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b3bf	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b3c3	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b3c8	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b3cc	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b3d4	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b3db	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b3e2	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3e9	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3f0	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3f7	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3fb	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b401	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b405	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b409	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b40f	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b415	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b41a	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b420	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b428	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b42e	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b434	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b43a	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b440	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b447	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b44b	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b451	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b455	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b459	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b45d	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b461	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b466	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b46a	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b472	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b479	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b480	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b487	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b48e	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b495	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b499	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b49f	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b4a3	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b4a9	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b4af	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b4b5	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b4ba	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b4c0	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b4c8	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b4ce	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b4d4	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b4da	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b4e1	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b4e5	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4eb	43 64 65 78				occa:	.text 1*64+3, "dex"
>b4ef	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4f3	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4f7	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4fb	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b500	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b504	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b50c	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b513	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b51a	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b521	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b528	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b52c	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b532	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b536	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b53c	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b542	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b547	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b54d	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b555	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b55b	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b561	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b567	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b56e	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b572	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b578	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b57c	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b580	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b584	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b588	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b58d	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b591	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b599	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b5a0	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b5a7	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b5ae	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b5b5	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b5b9	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b5bf	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b5c3	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b5c9	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b5cf	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b5d4	01 3f					oc__:	.text 1, "?"
.b5d6					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b5d6					ed6502:
.b5d6	a5 18		lda $18		                lda base
.b5d8	85 33		sta $33		                sta editor3+1
.b5da	a9 0a		lda #$0a	                lda #10
.b5dc	85 18		sta $18		                sta base
.b5de	64 2e		stz $2e		                stz ed_head
.b5e0	64 2f		stz $2f		                stz ed_head+1
.b5e2	64 30		stz $30		                stz ed_cur
.b5e4	64 31		stz $31		                stz ed_cur+1
.b5e6	64 32		stz $32		                stz ed_flags
.b5e8	20 aa a7	jsr $a7aa	                jsr xt_zero
.b5eb	20 aa a7	jsr $a7aa	                jsr xt_zero             ; ( addr-t u-t )
.b5ee	20 7f 89	jsr $897f	                jsr xt_cr
.b5f1					ed_input_loop:
.b5f1	a9 81		lda #$81	                lda #%10000001
.b5f3	14 32		trb $32		                trb ed_flags
.b5f5	20 d0 ba	jsr $bad0	                jsr ed_get_input
.b5f8	a5 0a		lda $0a		                lda ciblen
.b5fa	d0 1f		bne $b61b	                bne _command_mode
.b5fc	ca		dex		                dex
.b5fd	ca		dex		                dex                     ; ( addr-t u-t ? )
.b5fe	a5 30		lda $30		                lda ed_cur
.b600	95 00		sta $00,x	                sta 0,x
.b602	a5 31		lda $31		                lda ed_cur+1
.b604	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b606	a9 80		lda #$80	                lda #%10000000
.b608	04 32		tsb $32		                tsb ed_flags
.b60a	20 4e 98	jsr $984e	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b60d	20 ec ba	jsr $baec	                jsr ed_is_valid_line
.b610	b0 03		bcs $b615	                bcs +
.b612	4c c0 ba	jmp $bac0	                jmp ed_error_1drop
.b615					+
.b615	20 aa a7	jsr $a7aa	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b618	4c e6 b6	jmp $b6e6	                jmp _line_number_only_from_external
.b61b					_command_mode:
.b61b	20 aa a7	jsr $a7aa	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b61e	20 aa a7	jsr $a7aa	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b621					_prefix_dot:
.b621	b2 08		lda ($08)	                lda (cib)
.b623	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b625	d0 3a		bne $b661	                bne _prefix_dollar
.b627	20 e1 ba	jsr $bae1	                jsr ed_have_text
.b62a	a5 30		lda $30		                lda ed_cur
.b62c	95 02		sta $02,x	                sta 2,x
.b62e	a5 31		lda $31		                lda ed_cur+1
.b630	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b632	a9 80		lda #$80	                lda #%10000000
.b634	04 32		tsb $32		                tsb ed_flags
.b636	a5 0a		lda $0a		                lda ciblen
.b638	3a		dec a		                dea                     ; sets Z if A was 1
.b639	d0 03		bne $b63e	                bne +
.b63b	4c e6 b6	jmp $b6e6	                jmp _line_number_only_from_external
.b63e					+
.b63e	ca		dex		                dex
.b63f	ca		dex		                dex
.b640	ca		dex		                dex
.b641	ca		dex		                dex
.b642	a5 08		lda $08		                lda cib
.b644	95 02		sta $02,x	                sta 2,x
.b646	a5 09		lda $09		                lda cib+1
.b648	95 03		sta $03,x	                sta 3,x
.b64a	a5 0a		lda $0a		                lda ciblen
.b64c	95 00		sta $00,x	                sta 0,x
.b64e	a5 0b		lda $0b		                lda ciblen+1
.b650	95 01		sta $01,x	                sta 1,x
.b652	20 42 98	jsr $9842	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b655	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b658	20 4e 98	jsr $984e	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b65b	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b65e	4c 3e b7	jmp $b73e	                jmp _check_for_para2
.b661					_prefix_dollar:
.b661	b2 08		lda ($08)	                lda (cib)
.b663	c9 24		cmp #$24	                cmp #'$'
.b665	d0 1c		bne $b683	                bne _prefix_percent
.b667	20 e1 ba	jsr $bae1	                jsr ed_have_text
.b66a	e8		inx		                inx
.b66b	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b66c	20 0e bb	jsr $bb0e	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b66f	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b672	a9 80		lda #$80	                lda #%10000000
.b674	04 32		tsb $32		                tsb ed_flags
.b676	a5 0a		lda $0a		                lda ciblen
.b678	3a		dec a		                dea                     ; sets Z if A was 1
.b679	d0 03		bne $b67e	                bne +
.b67b	4c e6 b6	jmp $b6e6	                jmp _line_number_only_from_external
.b67e					+
.b67e	a0 01		ldy #$01	                ldy #01
.b680	4c ba b7	jmp $b7ba	                jmp _check_command
.b683					_prefix_percent:
.b683	b2 08		lda ($08)	                lda (cib)
.b685	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b687	f0 04		beq $b68d	                beq _whole_text
.b689	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b68b	d0 17		bne $b6a4	                bne _prefix_semicolon
.b68d					_whole_text:
.b68d	20 e1 ba	jsr $bae1	                jsr ed_have_text
.b690	a9 01		lda #$01	                lda #01
.b692	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b694	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b696					_semicolon_entry:
.b696	e8		inx		                inx
.b697	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b698	20 0e bb	jsr $bb0e	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b69b	a9 80		lda #$80	                lda #%10000000
.b69d	04 32		tsb $32		                tsb ed_flags
.b69f	a0 01		ldy #$01	                ldy #01
.b6a1	4c ba b7	jmp $b7ba	                jmp _check_command
.b6a4					_prefix_semicolon:
.b6a4	b2 08		lda ($08)	                lda (cib)
.b6a6	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b6a8	d0 0d		bne $b6b7	                bne _prefix_number
.b6aa	20 e1 ba	jsr $bae1	                jsr ed_have_text
.b6ad	a5 30		lda $30		                lda ed_cur
.b6af	95 02		sta $02,x	                sta 2,x
.b6b1	a5 31		lda $31		                lda ed_cur+1
.b6b3	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b6b5	80 df		bra $b696	                bra _semicolon_entry
.b6b7					_prefix_number:
.b6b7	20 aa a7	jsr $a7aa	                jsr xt_zero
.b6ba	20 aa a7	jsr $a7aa	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b6bd	ca		dex		                dex
.b6be	ca		dex		                dex
.b6bf	ca		dex		                dex
.b6c0	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b6c1	a5 08		lda $08		                lda cib
.b6c3	95 02		sta $02,x	                sta 2,x
.b6c5	a5 09		lda $09		                lda cib+1
.b6c7	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b6c9	a5 0a		lda $0a		                lda ciblen
.b6cb	95 00		sta $00,x	                sta 0,x
.b6cd	a5 0b		lda $0b		                lda ciblen+1
.b6cf	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b6d1	20 bf a2	jsr $a2bf	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b6d4	b5 00		lda $00,x	                lda 0,x
.b6d6	15 01		ora $01,x	                ora 1,x
.b6d8	d0 24		bne $b6fe	                bne _have_unconverted_chars
.b6da	e8		inx		                inx
.b6db	e8		inx		                inx
.b6dc	e8		inx		                inx
.b6dd	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b6de	20 9c 8a	jsr $8a9c	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b6e1	20 9f 96	jsr $969f	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b6e4	e8		inx		                inx
.b6e5	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b6e6					_line_number_only_from_external:
.b6e6	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6e9	20 ec ba	jsr $baec	                jsr ed_is_valid_line
.b6ec	b0 03		bcs $b6f1	                bcs +
.b6ee	4c be ba	jmp $babe	                jmp ed_error_2drop
.b6f1					+
.b6f1	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6f4	20 7b bb	jsr $bb7b	                jsr ed_para1_to_cur
.b6f7	a9 80		lda #$80	                lda #%10000000
.b6f9	04 32		tsb $32		                tsb ed_flags
.b6fb	4c 99 b9	jmp $b999	                jmp ed_cmd_p_from_external
.b6fe					_have_unconverted_chars:
.b6fe	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b701	ca		dex		                dex
.b702	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b703	a5 0a		lda $0a		                lda ciblen
.b705	95 00		sta $00,x	                sta 0,x
.b707	a5 0b		lda $0b		                lda ciblen+1
.b709	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b70b	20 ea 8e	jsr $8eea	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b70e	b5 00		lda $00,x	                lda 0,x
.b710	15 01		ora $01,x	                ora 1,x
.b712	f0 0e		beq $b722	                beq _no_command_yet
.b714	8a		txa		                txa
.b715	18		clc		                clc
.b716	69 0a		adc #$0a	                adc #10
.b718	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b719	a9 80		lda #$80	                lda #%10000000
.b71b	14 32		trb $32		                trb ed_flags
.b71d	a0 00		ldy #$00	                ldy #00
.b71f	4c ba b7	jmp $b7ba	                jmp _check_command
.b722					_no_command_yet:
.b722	e8		inx		                inx
.b723	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b724	20 72 a3	jsr $a372	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b727	20 9f 96	jsr $969f	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b72a	20 9c 8a	jsr $8a9c	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b72d	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b72f	95 06		sta $06,x	                sta 6,x
.b731	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b733	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b735	e8		inx		                inx
.b736	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b737	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b73a	a9 80		lda #$80	                lda #%10000000
.b73c	04 32		tsb $32		                tsb ed_flags
.b73e					_check_for_para2:
.b73e	a1 02		lda ($02,x)	                lda (2,x)
.b740	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b742	f0 0d		beq $b751	                beq _got_comma
.b744	38		sec		                sec
.b745	a5 0a		lda $0a		                lda ciblen
.b747	f5 00		sbc $00,x	                sbc 0,x
.b749	a8		tay		                tay
.b74a	e8		inx		                inx
.b74b	e8		inx		                inx
.b74c	e8		inx		                inx
.b74d	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b74e	4c ba b7	jmp $b7ba	                jmp _check_command
.b751					_got_comma:
.b751	f6 02		inc $02,x	                inc 2,x
.b753	d0 02		bne $b757	                bne +
.b755	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b757					+
.b757	b5 01		lda $01,x	                lda 1,x
.b759	f0 02		beq $b75d	                beq +
.b75b	d6 01		dec $01,x	                dec 1,x
.b75d					+
.b75d	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b75f	a1 02		lda ($02,x)	                lda (2,x)
.b761	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b763	d0 14		bne $b779	                bne _para2_not_dollar
.b765	38		sec		                sec
.b766	a5 0a		lda $0a		                lda ciblen
.b768	f5 02		sbc $02,x	                sbc 2,x
.b76a	a8		tay		                tay
.b76b	c8		iny		                iny
.b76c	5a		phy		                phy
.b76d	8a		txa		                txa
.b76e	18		clc		                clc
.b76f	69 06		adc #$06	                adc #06
.b771	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b772	20 0e bb	jsr $bb0e	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b775	7a		ply		                ply
.b776	4c ba b7	jmp $b7ba	                jmp _check_command
.b779					_para2_not_dollar:
.b779	20 72 a3	jsr $a372	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b77c	20 aa a7	jsr $a7aa	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b77f	20 aa a7	jsr $a7aa	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b782	20 88 9b	jsr $9b88	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b785	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b788	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b78b	20 72 a3	jsr $a372	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b78e	20 bf a2	jsr $a2bf	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b791	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b794	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b797	20 ea 8e	jsr $8eea	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b79a	b5 00		lda $00,x	                lda 0,x
.b79c	15 01		ora $01,x	                ora 1,x
.b79e	f0 08		beq $b7a8	                beq _second_number
.b7a0	8a		txa		                txa
.b7a1	18		clc		                clc
.b7a2	69 0c		adc #$0c	                adc #12
.b7a4	aa		tax		                tax                     ; back to ( addr-t u-t )
.b7a5	4c c2 ba	jmp $bac2	                jmp ed_error
.b7a8					_second_number:
.b7a8	e8		inx		                inx
.b7a9	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b7aa	38		sec		                sec
.b7ab	a5 0a		lda $0a		                lda ciblen
.b7ad	f5 00		sbc $00,x	                sbc 0,x
.b7af	48		pha		                pha
.b7b0	20 b2 a3	jsr $a3b2	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b7b3	20 9c 8a	jsr $8a9c	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b7b6	20 73 96	jsr $9673	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b7b9	7a		ply		                ply
.b7ba					_check_command:
.b7ba	24 32		bit $32		                bit ed_flags
.b7bc	30 08		bmi $b7c6	                bmi _check_command_have_arg
.b7be	a5 30		lda $30		                lda ed_cur
.b7c0	95 02		sta $02,x	                sta 2,x
.b7c2	a5 31		lda $31		                lda ed_cur+1
.b7c4	95 03		sta $03,x	                sta 3,x
.b7c6					_check_command_have_arg:
.b7c6	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b7c8	85 24		sta $24		                sta tmp1
.b7ca	da		phx		                phx
.b7cb	a2 00		ldx #$00	                ldx #00
.b7cd					_cmd_loop:
.b7cd	bd a6 bb	lda $bba6,x	                lda ed_cmd_list,x
.b7d0	f0 07		beq $b7d9	                beq _illegal_command    ; zero marks end of list
.b7d2	c5 24		cmp $24		                cmp tmp1
.b7d4	f0 07		beq $b7dd	                beq _found_cmd
.b7d6	e8		inx		                inx
.b7d7	80 f4		bra $b7cd	                bra _cmd_loop
.b7d9					_illegal_command:
.b7d9	fa		plx		                plx
.b7da	4c be ba	jmp $babe	                jmp ed_error_2drop
.b7dd					_found_cmd:
.b7dd	8a		txa		                txa
.b7de	0a		asl a		                asl
.b7df	aa		tax		                tax                     ; X * 2 for table
.b7e0	7c b1 bb	jmp ($bbb1,x)	                jmp (ed_cmd_table,x)
.b7e3					ed_next_command:
.b7e3	e8		inx		                inx
.b7e4	e8		inx		                inx
.b7e5	e8		inx		                inx
.b7e6	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b7e7					_next_command_empty:
.b7e7	4c f1 b5	jmp $b5f1	                jmp ed_input_loop
.b7ea					ed_all_done:
.b7ea	64 0a		stz $0a		                stz ciblen
.b7ec	64 0b		stz $0b		                stz ciblen+1
.b7ee	20 b2 a3	jsr $a3b2	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7f1	a5 33		lda $33		                lda editor3+1
.b7f3	85 18		sta $18		                sta base
.b7f5	60		rts		                rts
.b7f6					ed_cmd_a:
.b7f6	fa		plx		                plx
.b7f7	e8		inx		                inx
.b7f8	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7f9					ed_entry_cmd_i:
.b7f9					ed_cmd_a_have_para:
.b7f9	20 44 bb	jsr $bb44	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7fc	20 7f 89	jsr $897f	                jsr xt_cr
.b7ff					_next_string_loop:
.b7ff	20 d0 ba	jsr $bad0	                jsr ed_get_input
.b802	b2 08		lda ($08)	                lda (cib)
.b804	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b806	d0 16		bne $b81e	                bne _add_line
.b808	a4 0a		ldy $0a		                ldy ciblen
.b80a	c0 01		cpy #$01	                cpy #01
.b80c	d0 10		bne $b81e	                bne _add_line
.b80e	a4 0b		ldy $0b		                ldy ciblen+1
.b810	d0 0c		bne $b81e	                bne _add_line
.b812	e8		inx		                inx
.b813	e8		inx		                inx
.b814	a9 40		lda #$40	                lda #%01000000
.b816	04 32		tsb $32		                tsb ed_flags
.b818	20 7f 89	jsr $897f	                jsr xt_cr
.b81b	4c f1 b5	jmp $b5f1	                jmp ed_input_loop
.b81e					_add_line:
.b81e	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b821	20 8e 91	jsr $918e	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b824	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b827	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b82a	20 8a 87	jsr $878a	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b82d	20 8f a3	jsr $a38f	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b830	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b833	20 8f a1	jsr $a18f	                jsr xt_store            ; ! ( addr-t u-t here )
.b836	20 8e 91	jsr $918e	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b839	a5 00		lda $00		                lda cp
.b83b	18		clc		                clc
.b83c	69 04		adc #$04	                adc #04
.b83e	85 00		sta $00		                sta cp
.b840	90 02		bcc $b844	                bcc +
.b842	e6 01		inc $01		                inc cp+1
.b844					+
.b844	e6 30		inc $30		                inc ed_cur
.b846	d0 02		bne $b84a	                bne +
.b848	e6 31		inc $31		                inc ed_cur+1
.b84a					+
.b84a	20 8e 91	jsr $918e	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b84d	20 cb 8d	jsr $8dcb	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b850	ca		dex		                dex
.b851	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b852	a5 08		lda $08		                lda cib
.b854	95 00		sta $00,x	                sta 0,x
.b856	a5 09		lda $09		                lda cib+1
.b858	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b85a	20 b0 a1	jsr $a1b0	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b85d	ca		dex		                dex
.b85e	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b85f	a5 0a		lda $0a		                lda ciblen
.b861	95 00		sta $00,x	                sta 0,x
.b863	a5 0b		lda $0b		                lda ciblen+1
.b865	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b867	20 f3 95	jsr $95f3	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b86a	18		clc		                clc
.b86b	a5 00		lda $00		                lda cp
.b86d	65 0a		adc $0a		                adc ciblen
.b86f	85 00		sta $00		                sta cp
.b871	90 06		bcc $b879	                bcc +
.b873	a5 01		lda $01		                lda cp+1
.b875	65 0b		adc $0b		                adc ciblen+1
.b877	85 01		sta $01		                sta cp+1
.b879					+
.b879	20 c4 98	jsr $98c4	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b87c	20 8f a1	jsr $a18f	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b87f	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+
.b882	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b885	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b888	a5 0a		lda $0a		                lda ciblen
.b88a	95 02		sta $02,x	                sta 2,x
.b88c	a5 0b		lda $0b		                lda ciblen+1
.b88e	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b890	20 8f a1	jsr $a18f	                jsr xt_store            ; ! ( addr-t u-t here )
.b893	20 7f 89	jsr $897f	                jsr xt_cr
.b896	4c ff b7	jmp $b7ff	                jmp _next_string_loop
.b899					ed_cmd_d:
.b899	fa		plx		                plx
.b89a	20 e1 ba	jsr $bae1	                jsr ed_have_text
.b89d	20 36 bb	jsr $bb36	                jsr ed_no_line_zero
.b8a0	b5 00		lda $00,x	                lda 0,x
.b8a2	15 01		ora $01,x	                ora 1,x
.b8a4	d0 08		bne $b8ae	                bne +
.b8a6	20 c4 98	jsr $98c4	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b8a9	20 eb b8	jsr $b8eb	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b8ac	80 33		bra $b8e1	                bra _cmd_d_done
.b8ae					+
.b8ae	20 ec ba	jsr $baec	                jsr ed_is_valid_line      ; result is in C flag
.b8b1	b0 03		bcs $b8b6	                bcs _cmd_d_loop
.b8b3	4c be ba	jmp $babe	                jmp ed_error_2drop
.b8b6					_cmd_d_loop:
.b8b6	20 ba a3	jsr $a3ba	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b8b9	20 79 91	jsr $9179	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b8bc	b5 00		lda $00,x	                lda 0,x
.b8be	15 01		ora $01,x	                ora 1,x
.b8c0	d0 0d		bne $b8cf	                bne _cmd_d_done_with_flag
.b8c2	e8		inx		                inx
.b8c3	e8		inx		                inx                     ; Get rid of the flag from >
.b8c4	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b8c7	20 eb b8	jsr $b8eb	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b8ca	20 42 98	jsr $9842	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b8cd	80 e7		bra $b8b6	                bra _cmd_d_loop
.b8cf					_cmd_d_done_with_flag:
.b8cf	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b8d0	e8		inx		                inx
.b8d1	b5 02		lda $02,x	                lda 2,x
.b8d3	d0 02		bne $b8d7	                bne +
.b8d5	d6 03		dec $03,x	                dec 3,x
.b8d7					+
.b8d7	d6 02		dec $02,x	                dec 2,x
.b8d9	b5 02		lda $02,x	                lda 2,x
.b8db	85 30		sta $30		                sta ed_cur
.b8dd	b5 03		lda $03,x	                lda 3,x
.b8df	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b8e1					_cmd_d_done:
.b8e1	a9 40		lda #$40	                lda #%01000000
.b8e3	04 32		tsb $32		                tsb ed_flags
.b8e5	20 7f 89	jsr $897f	                jsr xt_cr
.b8e8	4c e3 b7	jmp $b7e3	                jmp ed_next_command
.b8eb					_cmd_d_common:
.b8eb	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8ee	20 44 bb	jsr $bb44	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8f1	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8f4	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8f7	20 42 98	jsr $9842	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8fa	20 44 bb	jsr $bb44	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8fd	20 8f a1	jsr $a18f	                jsr xt_store            ; ! ( addr-t u-t )
.b900	60		rts		                rts
.b901					ed_cmd_equ:
.b901	fa		plx		                plx
.b902	a5 2e		lda $2e		                lda ed_head
.b904	05 2f		ora $2f		                ora ed_head+1
.b906	d0 08		bne $b910	                bne _cmd_equ_have_text
.b908	ca		dex		                dex
.b909	ca		dex		                dex
.b90a	74 00		stz $00,x	                stz 0,x
.b90c	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b90e	80 21		bra $b931	                bra _cmd_equ_done
.b910					_cmd_equ_have_text:
.b910	20 36 bb	jsr $bb36	                jsr ed_no_line_zero
.b913	24 32		bit $32		                bit ed_flags
.b915	30 0c		bmi $b923	                bmi _cmd_equ_have_para
.b917	ca		dex		                dex
.b918	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b919	a5 30		lda $30		                lda ed_cur
.b91b	95 00		sta $00,x	                sta 0,x
.b91d	a5 31		lda $31		                lda ed_cur+1
.b91f	95 01		sta $01,x	                sta 1,x
.b921	80 0e		bra $b931	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b923					_cmd_equ_have_para:
.b923	b5 00		lda $00,x	                lda 0,x
.b925	15 01		ora $01,x	                ora 1,x
.b927	d0 05		bne $b92e	                bne _cmd_equ_two_paras
.b929	20 c4 98	jsr $98c4	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b92c	80 03		bra $b931	                bra _cmd_equ_done
.b92e					_cmd_equ_two_paras:
.b92e	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b931					_cmd_equ_done:
.b931	20 7f 89	jsr $897f	                jsr xt_cr               ; number goes on new line
.b934	20 30 a5	jsr $a530	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b937	20 7f 89	jsr $897f	                jsr xt_cr
.b93a	4c e3 b7	jmp $b7e3	                jmp ed_next_command
.b93d					ed_cmd_f:
.b93d	fa		plx		                plx
.b93e	24 32		bit $32		                bit ed_flags
.b940	30 17		bmi $b959	                bmi _cmd_f_have_para
.b942	20 7f 89	jsr $897f	                jsr xt_cr
.b945	20 72 a3	jsr $a372	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b948	20 88 9b	jsr $9b88	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b94b	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b94e	20 30 a5	jsr $a530	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b951	20 9f 96	jsr $969f	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b954	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b957	80 11		bra $b96a	                bra _cmd_f_done
.b959					_cmd_f_have_para:
.b959	20 c4 98	jsr $98c4	                jsr xt_over
.b95c	20 7f 89	jsr $897f	                jsr xt_cr
.b95f	20 30 a5	jsr $a530	                jsr xt_u_dot
.b962	b5 02		lda $02,x	                lda 2,x
.b964	95 06		sta $06,x	                sta 6,x
.b966	b5 03		lda $03,x	                lda 3,x
.b968	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b96a					_cmd_f_done:
.b96a	20 7f 89	jsr $897f	                jsr xt_cr
.b96d	4c e3 b7	jmp $b7e3	                jmp ed_next_command
.b970					ed_cmd_i:
.b970	fa		plx		                plx
.b971	e8		inx		                inx
.b972	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b973	24 32		bit $32		                bit ed_flags
.b975	30 08		bmi $b97f	                bmi _cmd_i_have_para
.b977	a5 30		lda $30		                lda ed_cur
.b979	95 00		sta $00,x	                sta 0,x
.b97b	a5 31		lda $31		                lda ed_cur+1
.b97d	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b97f					_cmd_i_have_para:
.b97f	b5 00		lda $00,x	                lda 0,x
.b981	15 01		ora $01,x	                ora 1,x
.b983	f0 09		beq $b98e	                beq _cmd_i_done
.b985	20 42 98	jsr $9842	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b988	20 aa a7	jsr $a7aa	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b98b	20 49 95	jsr $9549	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b98e					_cmd_i_done:
.b98e	4c f9 b7	jmp $b7f9	                jmp ed_entry_cmd_i
.b991					ed_cmd_n:
.b991	fa		plx		                plx
.b992	a9 01		lda #$01	                lda #%00000001
.b994	04 32		tsb $32		                tsb ed_flags
.b996	80 05		bra $b99d	                bra ed_cmd_p_entry_for_cmd_n
.b998					ed_cmd_p:
.b998	fa		plx		                plx
.b999					ed_cmd_p_from_external:
.b999	a9 01		lda #$01	                lda #%00000001
.b99b	14 32		trb $32		                trb ed_flags
.b99d					ed_cmd_p_entry_for_cmd_n:
.b99d	20 e1 ba	jsr $bae1	                jsr ed_have_text
.b9a0	20 36 bb	jsr $bb36	                jsr ed_no_line_zero
.b9a3	20 7f 89	jsr $897f	                jsr xt_cr
.b9a6	b5 00		lda $00,x	                lda 0,x
.b9a8	15 01		ora $01,x	                ora 1,x
.b9aa	d0 10		bne $b9bc	                bne _cmd_p_loop
.b9ac	b5 02		lda $02,x	                lda 2,x
.b9ae	85 30		sta $30		                sta ed_cur
.b9b0	b5 03		lda $03,x	                lda 3,x
.b9b2	85 31		sta $31		                sta ed_cur+1
.b9b4	20 c4 98	jsr $98c4	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b9b7	20 e5 b9	jsr $b9e5	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9ba	80 26		bra $b9e2	                bra _cmd_p_all_done
.b9bc					_cmd_p_loop:
.b9bc	20 ba a3	jsr $a3ba	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b9bf	20 79 91	jsr $9179	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b9c2	b5 00		lda $00,x	                lda 0,x
.b9c4	15 01		ora $01,x	                ora 1,x
.b9c6	d0 10		bne $b9d8	                bne _cmd_p_done
.b9c8	e8		inx		                inx
.b9c9	e8		inx		                inx                     ; Get rid of the flag from >
.b9ca	20 c4 98	jsr $98c4	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b9cd	20 e5 b9	jsr $b9e5	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9d0	f6 02		inc $02,x	                inc 2,x
.b9d2	d0 02		bne $b9d6	                bne +
.b9d4	f6 03		inc $03,x	                inc 3,x
.b9d6					+
.b9d6	80 e4		bra $b9bc	                bra _cmd_p_loop
.b9d8					_cmd_p_done:
.b9d8	e8		inx		                inx
.b9d9	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b9da	b5 00		lda $00,x	                lda 0,x
.b9dc	85 30		sta $30		                sta ed_cur
.b9de	b5 01		lda $01,x	                lda 1,x
.b9e0	85 31		sta $31		                sta ed_cur+1
.b9e2					_cmd_p_all_done:
.b9e2	4c e3 b7	jmp $b7e3	                jmp ed_next_command
.b9e5					_cmd_p_common:
.b9e5	a5 32		lda $32		                lda ed_flags
.b9e7	4a		lsr a		                lsr                     ; bit 0 now in carry
.b9e8	90 0b		bcc $b9f5	                bcc _cmd_p_common_no_num
.b9ea	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9ed	20 30 a5	jsr $a530	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9f0	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9f2	20 12 8e	jsr $8e12	                jsr emit_a
.b9f5					_cmd_p_common_no_num:
.b9f5	20 44 bb	jsr $bb44	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9f8	20 84 bb	jsr $bb84	                jsr ed_print_addr
.b9fb	60		rts		                rts
.b9fc					ed_cmd_q:
.b9fc	fa		plx		                plx
.b9fd	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b9ff	50 03		bvc $ba04	                bvc +
.ba01	4c be ba	jmp $babe	                jmp ed_error_2drop
.ba04					+
.ba04	4c ea b7	jmp $b7ea	                jmp ed_all_done            ; can't fall thru because of PLX
.ba07					ed_cmd_qq:
.ba07	fa		plx		                plx
.ba08	4c ea b7	jmp $b7ea	                jmp ed_all_done
.ba0b					ed_cmd_w:
.ba0b	fa		plx		                plx
.ba0c	20 e1 ba	jsr $bae1	                jsr ed_have_text
.ba0f	24 32		bit $32		                bit ed_flags
.ba11	30 13		bmi $ba26	                bmi _cmd_w_have_para
.ba13	b5 06		lda $06,x	                lda 6,x
.ba15	15 07		ora $07,x	                ora 7,x
.ba17	d0 03		bne $ba1c	                bne +
.ba19	4c be ba	jmp $babe	                jmp ed_error_2drop
.ba1c					+
.ba1c	b5 06		lda $06,x	                lda 6,x
.ba1e	95 02		sta $02,x	                sta 2,x
.ba20	b5 07		lda $07,x	                lda 7,x
.ba22	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.ba24	80 08		bra $ba2e	                bra _cmd_w_para_ready
.ba26					_cmd_w_have_para:
.ba26	b5 02		lda $02,x	                lda 2,x
.ba28	95 06		sta $06,x	                sta 6,x
.ba2a	b5 03		lda $03,x	                lda 3,x
.ba2c	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ba2e					_cmd_w_para_ready:
.ba2e	a9 2e		lda #$2e	                lda #<ed_head
.ba30	95 00		sta $00,x	                sta 0,x
.ba32	a9 00		lda #$00	                lda #>ed_head
.ba34	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ba36	20 c4 98	jsr $98c4	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ba39	20 72 a3	jsr $a372	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ba3c					_cmd_w_loop:
.ba3c	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ba3f	b5 00		lda $00,x	                lda 0,x
.ba41	15 01		ora $01,x	                ora 1,x
.ba43	f0 55		beq $ba9a	                beq _cmd_w_eol
.ba45	20 ba a3	jsr $a3ba	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba48	20 a4 a4	jsr $a4a4	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba4b	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba4e	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba51	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba54	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba57	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba5a	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba5d	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba60	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba63	20 9f 96	jsr $969f	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba66	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba69	20 88 9b	jsr $9b88	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba6c	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba6f	20 72 a3	jsr $a372	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba72	20 f3 95	jsr $95f3	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba75	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba78	20 2a a4	jsr $a42a	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba7b	20 9f 96	jsr $969f	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba7e	20 14 9a	jsr $9a14	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba81	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba84	ca		dex		                dex
.ba85	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba86	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba88	95 00		sta $00,x	                sta 0,x
.ba8a	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba8c	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba8f	20 8f a1	jsr $a18f	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba92	20 4e 98	jsr $984e	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba95	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba98	80 a2		bra $ba3c	                bra _cmd_w_loop
.ba9a					_cmd_w_eol:
.ba9a	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba9d	20 c3 9a	jsr $9ac3	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.baa0	20 81 95	jsr $9581	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.baa3	b5 00		lda $00,x	                lda 0,x
.baa5	95 04		sta $04,x	                sta 4,x
.baa7	b5 01		lda $01,x	                lda 1,x
.baa9	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.baab	20 7f 89	jsr $897f	                jsr xt_cr
.baae	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.bab1	20 30 a5	jsr $a530	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.bab4	20 7f 89	jsr $897f	                jsr xt_cr
.bab7	a9 40		lda #$40	                lda #%01000000
.bab9	14 32		trb $32		                trb ed_flags
.babb	4c e3 b7	jmp $b7e3	                jmp ed_next_command
.babe					ed_error_2drop:
.babe	e8		inx		                inx
.babf	e8		inx		                inx                     ; drop through to _error_1drop
.bac0					ed_error_1drop:
.bac0	e8		inx		                inx
.bac1	e8		inx		                inx                     ; drop through to _error
.bac2					ed_error:
.bac2	20 7f 89	jsr $897f	                jsr xt_cr
.bac5	a9 3f		lda #$3f	                lda #'?'
.bac7	20 12 8e	jsr $8e12	                jsr emit_a
.baca	20 7f 89	jsr $897f	                jsr xt_cr
.bacd	4c f1 b5	jmp $b5f1	                jmp ed_input_loop
.bad0					ed_get_input:
.bad0	20 29 9b	jsr $9b29	                jsr xt_refill           ;  ( addr-t u-t f )
.bad3	b5 00		lda $00,x	                lda 0,x
.bad5	15 01		ora $01,x	                ora 1,x
.bad7	d0 05		bne $bade	                bne +
.bad9	7a		ply		                ply
.bada	7a		ply		                ply
.badb	4c c0 ba	jmp $bac0	                jmp ed_error_1drop
.bade					+
.bade	e8		inx		                inx
.badf	e8		inx		                inx
.bae0	60		rts		                rts
.bae1					ed_have_text:
.bae1	a5 2e		lda $2e		                lda ed_head
.bae3	05 2f		ora $2f		                ora ed_head+1
.bae5	d0 04		bne $baeb	                bne +
.bae7	7a		ply		                ply
.bae8	7a		ply		                ply
.bae9	80 d7		bra $bac2	                bra ed_error
.baeb					+
.baeb	60		rts		                rts
.baec					ed_is_valid_line:
.baec	38		sec		                sec                             ; default is legal line number
.baed	b5 00		lda $00,x	                lda 0,x
.baef	15 01		ora $01,x	                ora 1,x
.baf1	f0 19		beq $bb0c	                beq _is_valid_line_nope_zero    ; ( n )
.baf3	20 cb 8d	jsr $8dcb	                jsr xt_dup                      ; DUP ( n n )
.baf6	20 0e bb	jsr $bb0e	                jsr ed_last_line                  ; ( n n last )
.baf9	20 b0 a1	jsr $a1b0	                jsr xt_swap                     ; SWAP ( n last n )
.bafc	20 84 93	jsr $9384	                jsr xt_less_than                ; < ( n f )
.baff	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.bb01	15 01		ora $01,x	                ora 1,x
.bb03	d0 05		bne $bb0a	                bne _is_valid_line_too_small
.bb05	e8		inx		                inx
.bb06	e8		inx		                inx                     ; DROP flag ( n )
.bb07	38		sec		                sec                     ; Who knows what's happened to C by now
.bb08	80 03		bra $bb0d	                bra _is_valid_line_done ; only one exit from this routine
.bb0a					_is_valid_line_too_small:
.bb0a	e8		inx		                inx
.bb0b	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.bb0c					_is_valid_line_nope_zero:
.bb0c	18		clc		                clc                     ; drop through to _is_valid_line_done
.bb0d					_is_valid_line_done:
.bb0d	60		rts		                rts
.bb0e					ed_last_line:
.bb0e	64 24		stz $24		                stz tmp1
.bb10	64 25		stz $25		                stz tmp1+1
.bb12	ca		dex		                dex
.bb13	ca		dex		                dex                     ; ( ? )
.bb14	a9 2e		lda #$2e	                lda #<ed_head
.bb16	95 00		sta $00,x	                sta 0,x
.bb18	a9 00		lda #$00	                lda #>ed_head
.bb1a	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.bb1c					_last_line_loop:
.bb1c	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; ( addr | 0 )
.bb1f	b5 00		lda $00,x	                lda 0,x
.bb21	15 01		ora $01,x	                ora 1,x
.bb23	f0 08		beq $bb2d	                beq _last_line_done
.bb25	e6 24		inc $24		                inc tmp1
.bb27	d0 02		bne $bb2b	                bne +
.bb29	e6 25		inc $25		                inc tmp1+1
.bb2b					+
.bb2b	80 ef		bra $bb1c	                bra _last_line_loop
.bb2d					_last_line_done:
.bb2d	a5 24		lda $24		                lda tmp1
.bb2f	95 00		sta $00,x	                sta 0,x
.bb31	a5 25		lda $25		                lda tmp1+1
.bb33	95 01		sta $01,x	                sta 1,x                 ; ( u )
.bb35	60		rts		                rts
.bb36					ed_no_line_zero:
.bb36	b5 02		lda $02,x	                lda 2,x
.bb38	15 03		ora $03,x	                ora 3,x
.bb3a	d0 07		bne $bb43	                bne _no_line_zero_done
.bb3c	24 32		bit $32		                bit ed_flags
.bb3e	10 03		bpl $bb43	                bpl _no_line_zero_done
.bb40	4c be ba	jmp $babe	                jmp ed_error_2drop
.bb43					_no_line_zero_done:
.bb43	60		rts		                rts
.bb44					ed_num_to_addr:
.bb44	ca		dex		                dex
.bb45	ca		dex		                dex                     ; ( u ? )
.bb46	a9 2e		lda #$2e	                lda #<ed_head
.bb48	95 00		sta $00,x	                sta 0,x
.bb4a	a9 00		lda #$00	                lda #>ed_head
.bb4c	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb4e	b5 02		lda $02,x	                lda 2,x
.bb50	15 03		ora $03,x	                ora 3,x
.bb52	d0 05		bne $bb59	                bne _num_to_addr_loop
.bb54	20 73 96	jsr $9673	                jsr xt_nip              ; ( addr-h )
.bb57	80 21		bra $bb7a	                bra _num_to_addr_done
.bb59					_num_to_addr_loop:
.bb59	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; @ ( u addr1 )
.bb5c	b5 00		lda $00,x	                lda 0,x
.bb5e	15 01		ora $01,x	                ora 1,x
.bb60	d0 05		bne $bb67	                bne +
.bb62	20 73 96	jsr $9673	                jsr xt_nip              ; NIP ( addr1 )
.bb65	80 13		bra $bb7a	                bra _num_to_addr_done
.bb67					+
.bb67	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( addr1 u )
.bb6a	20 42 98	jsr $9842	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb6d	b5 00		lda $00,x	                lda 0,x
.bb6f	15 01		ora $01,x	                ora 1,x
.bb71	f0 05		beq $bb78	                beq _num_to_addr_finished
.bb73	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb76	80 e1		bra $bb59	                bra _num_to_addr_loop
.bb78					_num_to_addr_finished:
.bb78	e8		inx		                inx
.bb79	e8		inx		                inx                     ; ( addr )
.bb7a					_num_to_addr_done:
.bb7a	60		rts		                rts
.bb7b					ed_para1_to_cur:
.bb7b	b5 02		lda $02,x	                lda 2,x
.bb7d	85 30		sta $30		                sta ed_cur
.bb7f	b5 03		lda $03,x	                lda 3,x
.bb81	85 31		sta $31		                sta ed_cur+1
.bb83	60		rts		                rts
.bb84					ed_print_addr:
.bb84	20 4e 98	jsr $984e	                jsr xt_one_plus
.bb87	20 4e 98	jsr $984e	                jsr xt_one_plus         ; ( addr+2 )
.bb8a	20 cb 8d	jsr $8dcb	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb8d	20 4e 98	jsr $984e	                jsr xt_one_plus
.bb90	20 4e 98	jsr $984e	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb93	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; ( addr+2 u-s )
.bb96	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( u-s addr+2 )
.bb99	20 9c 8f	jsr $8f9c	                jsr xt_fetch            ; ( u-s addr-s )
.bb9c	20 b0 a1	jsr $a1b0	                jsr xt_swap             ; ( addr-s u-s )
.bb9f	20 05 a5	jsr $a505	                jsr xt_type
.bba2	20 7f 89	jsr $897f	                jsr xt_cr
.bba5	60		rts		                rts
>bba6	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bbae	71 51 00
.bbb1					ed_cmd_table:
>bbb1	f6 b7 3d b9 70 b9 99 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bbb9	98 b9 91 b9
>bbbd	01 b9 0b ba fc b9 07 ba		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bbc5					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bbc5					forth_words_start:
>bbc5	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bbcd	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bbdd	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bbed	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bbfd	20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bc0d	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bc1d	2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bc2d	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bc3d	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bc4d	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc5d	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc6d	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc7d	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc8d	65 78 69 74 29 20 63 72 20
.bc96					forth_words_end:
.bc96					user_words_start:
>bc96	20 3a 6e 6f 6e 61 6d 65		.binary "user_words.asc"
>bc9e	20 2d 31 20 24 63 30 31 31 20 63 21 20 30 20 24
>bcae	63 30 31 30 20 63 21 20 24 63 30 31 31 20 63 40
>bcbe	20 30 3d 20 69 66 20 30 20 24 34 30 30 20 62 6c
>bcce	6b 2d 72 65 61 64 20 24 34 30 30 20 40 20 24 34
>bcde	36 35 34 20 3d 20 69 66 20 24 34 30 34 20 24 34
>bcee	30 32 20 40 20 65 76 61 6c 75 61 74 65 20 65 6c
>bcfe	73 65 20 2e 22 20 62 61 64 20 62 6f 6f 74 20 62
>bd0e	6c 6f 63 6b 22 20 43 52 20 74 68 65 6e 20 65 6c
>bd1e	73 65 20 2e 22 20 6e 6f 20 62 6c 6f 63 6b 20 64
>bd2e	65 76 69 63 65 22 20 43 52 20 74 68 65 6e 20 3b
>bd3e	20 65 78 65 63 75 74 65 20
.bd47					user_words_end:

;******  Processing file: platform/../headers.asm

.bd47					dictionary_start:
.bd47					nt_drop:
>bd47	04 10				        .byte 4, UF
>bd49	53 bd 4a 8d 4f 8d		        .word nt_dup, xt_drop, z_drop
>bd4f	64 72 6f 70			        .text "drop"
.bd53					nt_dup:
>bd53	03 10				        .byte 3, UF
>bd55	5e bd cb 8d d8 8d		        .word nt_swap, xt_dup, z_dup
>bd5b	64 75 70			        .text "dup"
.bd5e					nt_swap:
>bd5e	04 10				        .byte 4, UF
>bd60	6a bd b0 a1 c3 a1		        .word nt_store, xt_swap, z_swap
>bd66	73 77 61 70			        .text "swap"
.bd6a					nt_store:
>bd6a	01 10				        .byte 1, UF
>bd6c	73 bd 8f a1 a4 a1		        .word nt_fetch, xt_store, z_store
>bd72	21				        .text "!"
.bd73					nt_fetch:
>bd73	01 10				        .byte 1, UF
>bd75	7c bd 9c 8f ae 8f		        .word nt_over, xt_fetch, z_fetch
>bd7b	40				        .text "@"
.bd7c					nt_over:
>bd7c	04 10				        .byte 4, UF
>bd7e	88 bd c4 98 d1 98		        .word nt_to_r, xt_over, z_over
>bd84	6f 76 65 72			        .text "over"
.bd88					nt_to_r:
>bd88	02 11				        .byte 2, CO+UF ; native is special case
>bd8a	92 bd 72 a3 85 a3		        .word nt_r_from, xt_to_r, z_to_r
>bd90	3e 72				        .text ">r"
.bd92					nt_r_from:
>bd92	02 01				        .byte 2, CO    ; native is special case
>bd94	9c bd c3 9a d3 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bd9a	72 3e				        .text "r>"
.bd9c					nt_r_fetch:
>bd9c	02 01				        .byte 2, CO    ; native is special case
>bd9e	a6 bd ae 9a c2 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bda4	72 40				        .text "r@"
.bda6					nt_nip:
>bda6	03 10				        .byte 3, UF
>bda8	b1 bd 73 96 80 96		        .word nt_rot, xt_nip, z_nip
>bdae	6e 69 70			        .text "nip"
.bdb1					nt_rot:
>bdb1	03 10				        .byte 3, UF
>bdb3	bc bd 88 9b a3 9b		        .word nt_not_rote, xt_rot, z_rot
>bdb9	72 6f 74			        .text "rot"
.bdbc					nt_not_rote:
>bdbc	04 10				        .byte 4, UF
>bdbe	c8 bd 9f 96 ba 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bdc4	2d 72 6f 74			        .text "-rot"
.bdc8					nt_tuck:
>bdc8	04 10				        .byte 4, UF
>bdca	d4 bd 8f a3 a8 a3		        .word nt_comma, xt_tuck, z_tuck
>bdd0	74 75 63 6b			        .text "tuck"
.bdd4					nt_comma:
>bdd4	01 10				        .byte 1, UF
>bdd6	dd bd 8a 87 a3 87		        .word nt_c_fetch, xt_comma, z_comma
>bddc	2c				        .text ","
.bddd					nt_c_fetch:
>bddd	02 10				        .byte 2, UF
>bddf	e7 bd 27 86 30 86		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bde5	63 40				        .text "c@"
.bde7					nt_c_store:
>bde7	02 10				        .byte 2, UF
>bde9	f1 bd 31 86 3c 86		        .word nt_plus_store, xt_c_store, z_c_store
>bdef	63 21				        .text "c!"
.bdf1					nt_plus_store:
>bdf1	02 10				        .byte 2, UF
>bdf3	fb bd 27 9a 46 9a		        .word nt_execute, xt_plus_store, z_plus_store
>bdf9	2b 21				        .text "+!"
.bdfb					nt_execute:
>bdfb	07 10				        .byte 7, UF
>bdfd	0a be 59 8f 5f 8f		        .word nt_emit, xt_execute, z_execute
>be03	65 78 65 63 75 74 65		        .text "execute"
.be0a					nt_emit:
>be0a	04 18				        .byte 4, NN+UF
>be0c	16 be 0b 8e 15 8e		        .word nt_type, xt_emit, z_emit
>be12	65 6d 69 74			        .text "emit"
.be16					nt_type:
>be16	04 10				        .byte 4, UF
>be18	22 be 05 a5 2f a5		        .word nt_dot, xt_type, z_type
>be1e	74 79 70 65			        .text "type"
.be22					nt_dot:
>be22	01 10				        .byte 1, UF
>be24	2b be 52 8c 73 8c		        .word nt_u_dot, xt_dot, z_dot
>be2a	2e				        .text "."
.be2b					nt_u_dot:
>be2b	02 10				        .byte 2, UF
>be2d	35 be 30 a5 3b a5		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>be33	75 2e				        .text "u."
.be35					nt_u_dot_r:
>be35	03 10				        .byte 3, UF
>be37	40 be 3c a5 5d a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>be3d	75 2e 72			        .text "u.r"
.be40					nt_dot_r:
>be40	02 10				        .byte 2, UF
>be42	4a be 8e 8c bb 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>be48	2e 72				        .text ".r"
.be4a					nt_d_dot:
>be4a	02 10				        .byte 2, UF
>be4c	54 be 00 8d 1e 8d		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>be52	64 2e				        .text "d."
.be54					nt_d_dot_r:
>be54	03 10				        .byte 3, UF
>be56	5f be 1f 8d 49 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>be5c	64 2e 72			        .text "d.r"
.be5f					nt_ud_dot:
>be5f	03 10				        .byte 3, UF
>be61	6a be 8a a5 9c a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>be67	75 64 2e			        .text "ud."
.be6a					nt_ud_dot_r:
>be6a	04 10				        .byte 4, UF
>be6c	76 be 9d a5 bb a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>be72	75 64 2e 72			        .text "ud.r"
.be76					nt_question:
>be76	01 00				        .byte 1, 0
>be78	7f be 93 9a 99 9a		        .word nt_false, xt_question, z_question
>be7e	3f				        .text "?"
.be7f					nt_false:
>be7f	05 00				        .byte 5, 0
>be81	8c be 95 8f 9b 8f		        .word nt_true, xt_false, z_false
>be87	66 61 6c 73 65			        .text "false"
.be8c					nt_true:
>be8c	04 00				        .byte 4, 0
>be8e	98 be 86 a3 8e a3		        .word nt_space, xt_true, z_true
>be94	74 72 75 65			        .text "true"
.be98					nt_space:
>be98	05 00				        .byte 5, 0
>be9a	a5 be 20 a1 25 a1		        .word nt_zero, xt_space, z_space
>bea0	73 70 61 63 65			        .text "space"
.bea5					nt_zero:
>bea5	01 00				        .byte 1, 0
>bea7	ae be aa a7 b0 a7		        .word nt_one, xt_zero, z_zero
>bead	30				        .text "0"
.beae					nt_one:
>beae	01 00				        .byte 1, 0
>beb0	b7 be 39 98 41 98		        .word nt_two, xt_one, z_one
>beb6	31				        .text "1"
.beb7					nt_two:
>beb7	01 00				        .byte 1, 0
>beb9	c0 be a9 a3 b1 a3		        .word nt_two_dup, xt_two, z_two
>bebf	32				        .text "2"
.bec0					nt_two_dup:
>bec0	04 10				        .byte 4, UF
>bec2	cc be ba a3 d1 a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bec8	32 64 75 70			        .text "2dup"
.becc					nt_question_dup:
>becc	04 10				        .byte 4, UF
>bece	d8 be 9a 9a ad 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bed4	3f 64 75 70			        .text "?dup"
.bed8					nt_plus:
>bed8	01 10				        .byte 1, UF
>beda	e1 be 14 9a 26 9a		        .word nt_minus, xt_plus, z_plus
>bee0	2b				        .text "+"
.bee1					nt_minus:
>bee1	01 10				        .byte 1, UF
>bee3	ea be 81 95 93 95		        .word nt_one_minus, xt_minus, z_minus
>bee9	2d				        .text "-"
.beea					nt_one_minus:
>beea	02 10				        .byte 2, UF
>beec	f4 be 42 98 4d 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>bef2	31 2d				        .text "1-"
.bef4					nt_one_plus:
>bef4	02 10				        .byte 2, UF
>bef6	fe be 4e 98 57 98		        .word nt_two_star, xt_one_plus, z_one_plus
>befc	31 2b				        .text "1+"
.befe					nt_two_star:
>befe	02 10				        .byte 2, UF
>bf00	08 bf 52 a4 59 a4		        .word nt_two_slash, xt_two_star, z_two_star
>bf06	32 2a				        .text "2*"
.bf08					nt_two_slash:
>bf08	02 10				        .byte 2, UF
>bf0a	12 bf 47 a4 51 a4		        .word nt_abs, xt_two_slash, z_two_slash
>bf10	32 2f				        .text "2/"
.bf12					nt_abs:
>bf12	03 10				        .byte 3, UF
>bf14	1d bf 33 81 47 81		        .word nt_dabs, xt_abs, z_abs
>bf1a	61 62 73			        .text "abs"
.bf1d					nt_dabs:
>bf1d	04 10				        .byte 4, UF
>bf1f	29 bf a2 8a c0 8a		        .word nt_and, xt_dabs, z_dabs
>bf25	64 61 62 73			        .text "dabs"
.bf29					nt_and:
>bf29	03 10				        .byte 3, UF
>bf2b	34 bf 38 83 49 83		        .word nt_or, xt_and, z_and
>bf31	61 6e 64			        .text "and"
.bf34					nt_or:
>bf34	02 10				        .byte 2, UF
>bf36	3e bf 64 98 75 98		        .word nt_xor, xt_or, z_or
>bf3c	6f 72				        .text "or"
.bf3e					nt_xor:
>bf3e	03 10				        .byte 3, UF
>bf40	49 bf 98 a7 a9 a7		        .word nt_rshift, xt_xor, z_xor
>bf46	78 6f 72			        .text "xor"
.bf49					nt_rshift:
>bf49	06 10				        .byte 6, UF
>bf4b	57 bf a4 9b b7 9b		        .word nt_lshift, xt_rshift, z_rshift
>bf51	72 73 68 69 66 74		        .text "rshift"
.bf57					nt_lshift:
>bf57	06 10				        .byte 6, UF
>bf59	65 bf ab 94 be 94		        .word nt_pick, xt_lshift, z_lshift
>bf5f	6c 73 68 69 66 74		        .text "lshift"
.bf65					nt_pick:
>bf65	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bf67	71 bf 03 9a 13 9a		        .word nt_char, xt_pick, z_pick
>bf6d	70 69 63 6b			        .text "pick"
.bf71					nt_char:
>bf71	04 00				        .byte 4, 0
>bf73	7d bf 4d 86 63 86		        .word nt_bracket_char, xt_char, z_char
>bf79	63 68 61 72			        .text "char"
.bf7d					nt_bracket_char:
>bf7d	06 05				        .byte 6, CO+IM
>bf7f	8b bf b3 85 b9 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bf85	5b 63 68 61 72 5d		        .text "[char]"
.bf8b					nt_char_plus:
>bf8b	05 00				        .byte 5, 0
>bf8d	98 bf 4e 98 57 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bf93	63 68 61 72 2b			        .text "char+"
.bf98					nt_chars:
>bf98	05 12				        .byte 5, AN+UF   ; deleted during compile
>bf9a	a5 bf 64 86 67 86		        .word nt_cells, xt_chars, z_chars
>bfa0	63 68 61 72 73			        .text "chars"
.bfa5					nt_cells:
>bfa5	05 00				        .byte 5, 0
>bfa7	b2 bf 52 a4 59 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bfad	63 65 6c 6c 73			        .text "cells"
.bfb2					nt_cell_plus:
>bfb2	05 10				        .byte 5, UF
>bfb4	bf bf 3d 86 4c 86		        .word nt_here, xt_cell_plus, z_cell_plus
>bfba	63 65 6c 6c 2b			        .text "cell+"
.bfbf					nt_here:
>bfbf	04 00				        .byte 4, 0
>bfc1	cb bf 8e 91 98 91		        .word nt_equal, xt_here, z_here
>bfc7	68 65 72 65			        .text "here"
.bfcb					nt_equal:
>bfcb	01 10				        .byte 1, UF
>bfcd	d4 bf ea 8e 05 8f		        .word nt_not_equals, xt_equal, z_equal
>bfd3	3d				        .text "="
.bfd4					nt_not_equals:
>bfd4	02 10				        .byte 2, UF
>bfd6	de bf 81 96 9e 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bfdc	3c 3e				        .text "<>"
.bfde					nt_less_than:
>bfde	01 10				        .byte 1, UF
>bfe0	e7 bf 84 93 98 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bfe6	3c				        .text "<"
.bfe7					nt_u_less_than:
>bfe7	02 10				        .byte 2, UF
>bfe9	f1 bf 74 a5 89 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bfef	75 3c				        .text "u<"
.bff1					nt_u_greater_than:
>bff1	02 10				        .byte 2, UF
>bff3	fb bf 5e a5 73 a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bff9	75 3e				        .text "u>"
.bffb					nt_greater_than:
>bffb	01 10				        .byte 1, UF
>bffd	04 c0 79 91 8d 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>c003	3e				        .text ">"
.c004					nt_zero_equal:
>c004	02 10				        .byte 2, UF
>c006	0e c0 b1 a7 c4 a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>c00c	30 3d				        .text "0="
.c00e					nt_zero_unequal:
>c00e	03 10				        .byte 3, UF
>c010	19 c0 e9 a7 fa a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>c016	30 3c 3e			        .text "0<>"
.c019					nt_zero_greater:
>c019	02 10				        .byte 2, UF
>c01b	23 c0 c5 a7 d8 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>c021	30 3e				        .text "0>"
.c023					nt_zero_less:
>c023	02 10				        .byte 2, UF
>c025	2d c0 d9 a7 e8 a7		        .word nt_min, xt_zero_less, z_zero_less
>c02b	30 3c				        .text "0<"
.c02d					nt_min:
>c02d	03 10				        .byte 3, UF
>c02f	38 c0 65 95 80 95		        .word nt_max, xt_min, z_min
>c035	6d 69 6e			        .text "min"
.c038					nt_max:
>c038	03 10				        .byte 3, UF
>c03a	43 c0 49 95 64 95		        .word nt_two_drop, xt_max, z_max
>c040	6d 61 78			        .text "max"
.c043					nt_two_drop:
>c043	05 10				        .byte 5, UF
>c045	50 c0 b2 a3 b9 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>c04b	32 64 72 6f 70			        .text "2drop"
.c050					nt_two_swap:
>c050	05 10				        .byte 5, UF
>c052	5d c0 80 a4 a3 a4		        .word nt_two_over, xt_two_swap, z_two_swap
>c058	32 73 77 61 70			        .text "2swap"
.c05d					nt_two_over:
>c05d	05 10				        .byte 5, UF
>c05f	6a c0 f4 a3 0b a4		        .word nt_two_store, xt_two_over, z_two_over
>c065	32 6f 76 65 72			        .text "2over"
.c06a					nt_two_store:
>c06a	02 10				        .byte 2, UF
>c06c	74 c0 5a a4 7f a4		        .word nt_two_fetch, xt_two_store, z_two_store
>c072	32 21				        .text "2!"
.c074					nt_two_fetch:
>c074	02 10				        .byte 2, UF
>c076	7e c0 d2 a3 f3 a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>c07c	32 40				        .text "2@"
.c07e					nt_two_variable:
>c07e	09 00				        .byte 9, 0
>c080	8f c0 f6 a4 04 a5		        .word nt_two_constant, xt_two_variable, z_two_variable
>c086	32 76 61 72 69 61 62 6c		        .text "2variable"
>c08e	65
.c08f					nt_two_constant:
>c08f	09 10				        .byte 9, UF
>c091	a0 c0 c4 a4 e8 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>c097	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>c09f	74
.c0a0					nt_two_literal:
>c0a0	08 14				        .byte 8, UF+IM
>c0a2	b0 c0 e9 a4 f5 a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>c0a8	32 6c 69 74 65 72 61 6c		        .text "2literal"
.c0b0					nt_two_r_fetch:
>c0b0	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>c0b2	bb c0 0c a4 29 a4		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>c0b8	32 72 40			        .text "2r@"
.c0bb					nt_two_r_from:
>c0bb	03 01				        .byte 3, CO             ; native is special case
>c0bd	c6 c0 2a a4 46 a4		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>c0c3	32 72 3e			        .text "2r>"
.c0c6					nt_two_to_r:
>c0c6	03 11				        .byte 3, CO+UF          ; native is special case
>c0c8	d1 c0 a4 a4 c3 a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>c0ce	32 3e 72			        .text "2>r"
.c0d1					nt_invert:
>c0d1	06 10				        .byte 6, UF
>c0d3	df c0 07 93 16 93		        .word nt_negate, xt_invert, z_invert
>c0d9	69 6e 76 65 72 74		        .text "invert"
.c0df					nt_negate:
>c0df	06 10				        .byte 6, UF
>c0e1	ed c0 54 96 64 96		        .word nt_dnegate, xt_negate, z_negate
>c0e7	6e 65 67 61 74 65		        .text "negate"
.c0ed					nt_dnegate:
>c0ed	07 10				        .byte 7, UF
>c0ef	fc c0 5d 8b 77 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>c0f5	64 6e 65 67 61 74 65		        .text "dnegate"
.c0fc					nt_c_comma:
>c0fc	02 10				        .byte 2, UF
>c0fe	06 c1 1c 86 26 86		        .word nt_bounds, xt_c_comma, z_c_comma
>c104	63 2c				        .text "c,"
.c106					nt_bounds:
>c106	06 10				        .byte 6, UF
>c108	14 c1 9a 85 b2 85		        .word nt_spaces, xt_bounds, z_bounds
>c10e	62 6f 75 6e 64 73		        .text "bounds"
.c114					nt_spaces:
>c114	06 10				        .byte 6, UF
>c116	22 c1 26 a1 61 a1		        .word nt_bl, xt_spaces, z_spaces
>c11c	73 70 61 63 65 73		        .text "spaces"
.c122					nt_bl:
>c122	02 00				        .byte 2, 0
>c124	2c c1 b6 83 be 83		        .word nt_minus_trailing, xt_bl, z_bl
>c12a	62 6c				        .text "bl"
.c12c					nt_minus_trailing:
>c12c	09 10				        .byte 9, UF
>c12e	3d c1 ad 95 e9 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c134	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c13c	67
.c13d					nt_minus_leading:
>c13d	08 10				        .byte 8, UF
>c13f	4d c1 94 95 ac 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c145	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c14d					nt_slash_string:
>c14d	07 10				        .byte 7, UF
>c14f	5c c1 1b a0 3a a0		        .word nt_refill, xt_slash_string, z_slash_string
>c155	2f 73 74 72 69 6e 67		        .text "/string"
.c15c					nt_refill:
>c15c	06 00				        .byte 6, 0
>c15e	6a c1 29 9b 6a 9b		        .word nt_accept, xt_refill, z_refill
>c164	72 65 66 69 6c 6c		        .text "refill"
.c16a					nt_accept:
>c16a	06 18				        .byte 6, UF+NN
>c16c	78 c1 48 81 40 82		        .word nt_input_to_r, xt_accept, z_accept
>c172	61 63 63 65 70 74		        .text "accept"
.c178					nt_input_to_r:
>c178	07 08				        .byte 7, NN
>c17a	87 c1 7e 92 93 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c180	69 6e 70 75 74 3e 72		        .text "input>r"
.c187					nt_r_to_input:
>c187	07 08				        .byte 7, NN
>c189	96 c1 d4 9a eb 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c18f	72 3e 69 6e 70 75 74		        .text "r>input"
.c196					nt_unused:
>c196	06 00				        .byte 6, 0
>c198	a4 c1 56 a6 65 a6		        .word nt_depth, xt_unused, z_unused
>c19e	75 6e 75 73 65 64		        .text "unused"
.c1a4					nt_depth:
>c1a4	05 00				        .byte 5, 0
>c1a6	b1 c1 12 8b 20 8b		        .word nt_key, xt_depth, z_depth
>c1ac	64 65 70 74 68			        .text "depth"
.c1b1					nt_key:
>c1b1	03 00				        .byte 3, 0
>c1b3	bc c1 4a 93 53 93		        .word nt_allot, xt_key, z_key
>c1b9	6b 65 79			        .text "key"
.c1bc					nt_allot:
>c1bc	05 10				        .byte 5, UF
>c1be	c9 c1 a5 82 0d 83		        .word nt_create, xt_allot, z_allot
>c1c4	61 6c 6c 6f 74			        .text "allot"
.c1c9					nt_create:
>c1c9	06 00				        .byte 6, 0
>c1cb	d7 c1 85 89 59 8a		        .word nt_does, xt_create, z_create
>c1d1	63 72 65 61 74 65		        .text "create"
.c1d7					nt_does:
>c1d7	05 05				        .byte 5, CO+IM
>c1d9	e4 c1 11 8c 1f 8c		        .word nt_variable, xt_does, z_does
>c1df	64 6f 65 73 3e			        .text "does>"
.c1e4					nt_variable:
>c1e4	08 00				        .byte 8, 0
>c1e6	f4 c1 7a a6 92 a6		        .word nt_constant, xt_variable, z_variable
>c1ec	76 61 72 69 61 62 6c 65		        .text "variable"
.c1f4					nt_constant:
>c1f4	08 10				        .byte 8, UF
>c1f6	04 c2 2d 89 6a 89		        .word nt_value, xt_constant, z_constant
>c1fc	63 6f 6e 73 74 61 6e 74		        .text "constant"
.c204					nt_value:
>c204	05 10				        .byte 5, UF
>c206	11 c2 2d 89 6a 89		        .word nt_to, xt_constant, z_constant
>c20c	76 61 6c 75 65			        .text "value"
.c211					nt_to:
>c211	02 0c				        .byte 2, NN+IM
>c213	1b c2 33 a2 8e a2		        .word nt_s_to_d, xt_to, z_to
>c219	74 6f				        .text "to"
.c21b					nt_s_to_d:
>c21b	03 10				        .byte 3, UF
>c21d	26 c2 ae 9e bf 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c223	73 3e 64			        .text "s>d"
.c226					nt_d_to_s:
>c226	03 10				        .byte 3, UF
>c228	31 c2 9c 8a a1 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c22e	64 3e 73			        .text "d>s"
.c231					nt_d_minus:
>c231	02 10				        .byte 2, UF
>c233	3b c2 5a 8a 7a 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c239	64 2d				        .text "d-"
.c23b					nt_d_plus:
>c23b	02 10				        .byte 2, UF
>c23d	45 c2 7b 8a 9b 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c243	64 2b				        .text "d+"
.c245					nt_erase:
>c245	05 00				        .byte 5, 0      ; underflow checked by FILL
>c247	52 c2 10 8f 58 8f		        .word nt_blank, xt_erase, z_erase
>c24d	65 72 61 73 65			        .text "erase"
.c252					nt_blank:
>c252	05 00				        .byte 5, 0     ; underflow checked by FILL
>c254	5f c2 06 8f 58 8f		        .word nt_fill, xt_blank, z_blank
>c25a	62 6c 61 6e 6b			        .text "blank"
.c25f					nt_fill:
>c25f	04 10				        .byte 4, UF
>c261	6b c2 16 8f 58 8f		        .word nt_find_name, xt_fill, z_fill
>c267	66 69 6c 6c			        .text "fill"
.c26b					nt_find_name:
>c26b	09 10				        .byte 9, UF
>c26d	7c c2 f7 8f a2 90		        .word nt_tick, xt_find_name, z_find_name
>c273	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c27b	65
.c27c					nt_tick:
>c27c	01 00				        .byte 1, 0
>c27e	85 c2 13 a2 32 a2		        .word nt_bracket_tick, xt_tick, z_tick
>c284	27				        .text "'"
.c285					nt_bracket_tick:
>c285	03 05				        .byte 3, CO+IM
>c287	90 c2 ba 85 c0 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c28d	5b 27 5d			        .text "[']"
.c290					nt_name_to_int:
>c290	08 10				        .byte 8, UF
>c292	a0 c2 12 96 2e 96		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c298	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c2a0					nt_int_to_name:
>c2a0	08 10				        .byte 8, UF
>c2a2	b0 c2 94 92 06 93		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c2a8	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c2b0					nt_name_to_string:
>c2b0	0b 10				        .byte 11, UF
>c2b2	c3 c2 2f 96 48 96		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c2b8	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c2c0	69 6e 67
.c2c3					nt_to_body:
>c2c3	05 10				        .byte 5, UF
>c2c5	d0 c2 8f a2 b3 a2		        .word nt_defer, xt_to_body, z_to_body
>c2cb	3e 62 6f 64 79			        .text ">body"
.c2d0					nt_defer:
>c2d0	05 00				        .byte 5, 0
>c2d2	dd c2 c8 8a fa 8a		        .word nt_latestxt, xt_defer, z_defer
>c2d8	64 65 66 65 72			        .text "defer"
.c2dd					nt_latestxt:
>c2dd	08 00				        .byte 8, 0
>c2df	ed c2 65 93 6b 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c2e5	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c2ed					nt_latestnt:
>c2ed	08 00				        .byte 8, 0
>c2ef	fd c2 57 93 64 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c2f5	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c2fd					nt_parse_name:
>c2fd	0a 08				        .byte 10, NN
>c2ff	0f c3 10 99 02 9a		        .word nt_parse, xt_parse_name, z_parse_name
>c305	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c30d	6d 65
.c30f					nt_parse:
>c30f	05 10				        .byte 5, UF
>c311	1c c3 6b 99 02 9a		        .word nt_execute_parsing, xt_parse, z_parse
>c317	70 61 72 73 65			        .text "parse"
.c31c					nt_execute_parsing:
>c31c	0f 10				        .byte 15, UF
>c31e	33 c3 6d 8f 93 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c324	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c32c	70 61 72 73 69 6e 67
.c333					nt_source:
>c333	06 00				        .byte 6, 0
>c335	41 c3 00 a1 14 a1		        .word nt_source_id, xt_source, z_source
>c33b	73 6f 75 72 63 65		        .text "source"
.c341					nt_source_id:
>c341	09 00				        .byte 9, 0
>c343	52 c3 15 a1 1f a1		        .word nt_colon, xt_source_id, z_source_id
>c349	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c351	64
.c352					nt_colon:
>c352	01 00				        .byte 1, 0
>c354	5b c3 2b 87 6d 87		        .word nt_semicolon, xt_colon, z_colon
>c35a	3a				        .text ":"
.c35b					nt_semicolon:
>c35b	01 05				        .byte 1, CO+IM
>c35d	64 c3 8a 9f e8 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c363	3b				        .text ";"
.c364					nt_colon_noname:
>c364	07 00				        .byte 7, 0
>c366	73 c3 6e 87 89 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c36c	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c373					nt_compile_comma:
>c373	08 18				        .byte 8, UF+NN
>c375	83 c3 09 88 20 89		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c37b	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c383					nt_left_bracket:
>c383	01 05				        .byte 1, IM+CO
>c385	8c c3 71 93 75 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c38b	5b				        .text "["
.c38c					nt_right_bracket:
>c38c	01 04				        .byte 1, IM
>c38e	95 c3 78 9b 7e 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c394	5d				        .text "]"
.c395					nt_literal:
>c395	07 15				        .byte 7, IM+CO+UF
>c397	a4 c3 a6 93 b3 93		        .word nt_sliteral, xt_literal, z_literal
>c39d	6c 69 74 65 72 61 6c		        .text "literal"
.c3a4					nt_sliteral:
>c3a4	08 15				        .byte 8, CO+IM+UF
>c3a6	b4 c3 3b a0 aa a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c3ac	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c3b4					nt_dot_quote:
>c3b4	02 05				        .byte 2, CO+IM
>c3b6	be c3 83 8c 8d 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c3bc	2e 22				        .text ".", $22
.c3be					nt_s_quote:
>c3be	02 0c				        .byte 2, IM+NN
>c3c0	c8 c3 80 9d ad 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c3c6	73 22				        .text "s", $22
.c3c8					nt_s_backslash_quote:
>c3c8	03 04				        .byte 3, IM
>c3ca	d3 c3 b8 9b c1 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c3d0	73 5c 22			        .text "s", $5C, $22
.c3d3					nt_postpone:
>c3d3	08 05				        .byte 8, IM+CO
>c3d5	e3 c3 47 9a 85 9a		        .word nt_immediate, xt_postpone, z_postpone
>c3db	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c3e3					nt_immediate:
>c3e3	09 00				        .byte 9, 0
>c3e5	f4 c3 67 92 72 92		        .word nt_compile_only, xt_immediate, z_immediate
>c3eb	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c3f3	65
.c3f4					nt_compile_only:
>c3f4	0c 00				        .byte 12, 0
>c3f6	08 c4 21 89 2c 89		        .word nt_never_native, xt_compile_only, z_compile_only
>c3fc	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c404	6f 6e 6c 79
.c408					nt_never_native:
>c408	0c 00				        .byte 12, 0
>c40a	1c c4 65 96 72 96		        .word nt_always_native, xt_never_native, z_never_native
>c410	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c418	74 69 76 65
.c41c					nt_always_native:
>c41c	0d 00				        .byte 13, 0
>c41e	31 c4 2a 83 37 83		        .word nt_allow_native, xt_always_native, z_always_native
>c424	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c42c	61 74 69 76 65
.c431					nt_allow_native:
>c431	0c 00				        .byte 12, 0
>c433	45 c4 0e 83 19 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c439	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c441	74 69 76 65
.c445					nt_nc_limit:
>c445	08 00				        .byte 8, 0
>c447	55 c4 49 96 53 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c44d	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c455					nt_strip_underflow:
>c455	0f 00				        .byte 15, 0
>c457	6c c4 a5 a1 af a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c45d	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c465	64 65 72 66 6c 6f 77
.c46c					nt_abort:
>c46c	05 00				        .byte 5, 0
>c46e	79 c4 70 80 bd 80		        .word nt_abort_quote, xt_abort, z_abort
>c474	61 62 6f 72 74			        .text "abort"
.c479					nt_abort_quote:
>c479	06 0d				        .byte 6, CO+IM+NN
>c47b	87 c4 13 81 1d 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c481	61 62 6f 72 74 22		        .text "abort", $22
.c487					nt_do:
>c487	02 0d				        .byte 2, CO+IM+NN
>c489	91 c4 7e 8b d8 8b		        .word nt_question_do, xt_do, z_do
>c48f	64 6f				        .text "do"
.c491					nt_question_do:
>c491	03 0d				        .byte 3, CO+IM+NN
>c493	9c c4 78 8b d8 8b		        .word nt_i, xt_question_do, z_question_do
>c499	3f 64 6f			        .text "?do"
.c49c					nt_i:
>c49c	01 03				        .byte 1, AN+CO
>c49e	a5 c4 05 92 1e 92		        .word nt_j, xt_i, z_i
>c4a4	69				        .text "i"
.c4a5					nt_j:
>c4a5	01 03				        .byte 1, AN+CO
>c4a7	ae c4 30 93 49 93		        .word nt_loop, xt_j, z_j
>c4ad	6a				        .text "j"
.c4ae					nt_loop:
>c4ae	04 05				        .byte 4, CO+IM
>c4b0	ba c4 2c 94 99 94		        .word nt_plus_loop, xt_loop, z_loop
>c4b6	6c 6f 6f 70			        .text "loop"
.c4ba					nt_plus_loop:
>c4ba	05 05				        .byte 5, CO+IM
>c4bc	c7 c4 33 94 99 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c4c2	2b 6c 6f 6f 70			        .text "+loop"
.c4c7					nt_exit:
>c4c7	04 03				        .byte 4, AN+CO
>c4c9	d3 c4 94 8f 95 8f		        .word nt_unloop, xt_exit, z_exit
>c4cf	65 78 69 74			        .text "exit"
.c4d3					nt_unloop:
>c4d3	06 03				        .byte 6, AN+CO
>c4d5	e1 c4 44 a6 4a a6		        .word nt_leave, xt_unloop, z_unloop
>c4db	75 6e 6c 6f 6f 70		        .text "unloop"
.c4e1					nt_leave:
>c4e1	05 03				        .byte 5, AN+CO
>c4e3	ee c4 6c 93 71 93		        .word nt_recurse, xt_leave, z_leave
>c4e9	6c 65 61 76 65			        .text "leave"
.c4ee					nt_recurse:
>c4ee	07 0d				        .byte 7, CO+IM+NN
>c4f0	fd c4 ec 9a 28 9b		        .word nt_quit, xt_recurse, z_recurse
>c4f6	72 65 63 75 72 73 65		        .text "recurse"
.c4fd					nt_quit:
>c4fd	04 00				        .byte 4, 0
>c4ff	09 c5 72 80 bd 80		        .word nt_begin, xt_quit, z_quit
>c505	71 75 69 74			        .text "quit"
.c509					nt_begin:
>c509	05 07				        .byte 5, AN+CO+IM
>c50b	16 c5 ac 83 af 83		        .word nt_again, xt_begin, z_begin
>c511	62 65 67 69 6e			        .text "begin"
.c516					nt_again:
>c516	05 17				        .byte 5, AN+CO+IM+UF
>c518	23 c5 83 82 a3 82		        .word nt_state, xt_again, z_again
>c51e	61 67 61 69 6e			        .text "again"
.c523					nt_state:
>c523	05 00				        .byte 5, 0
>c525	30 c5 84 a1 8e a1		        .word nt_evaluate, xt_state, z_state
>c52b	73 74 61 74 65			        .text "state"
.c530					nt_evaluate:
>c530	08 10				        .byte 8, UF
>c532	40 c5 f1 90 44 91		        .word nt_base, xt_evaluate, z_evaluate
>c538	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c540					nt_base:
>c540	04 00				        .byte 4, 0
>c542	4c c5 a3 83 ab 83		        .word nt_digit_question, xt_base, z_base
>c548	62 61 73 65			        .text "base"
.c54c					nt_digit_question:
>c54c	06 10				        .byte 6, UF
>c54e	5a c5 21 8b 55 8b		        .word nt_number, xt_digit_question, z_digit_question
>c554	64 69 67 69 74 3f		        .text "digit?"
.c55a					nt_number:
>c55a	06 10				        .byte 6, UF
>c55c	68 c5 bb 96 b7 97		        .word nt_to_number, xt_number, z_number
>c562	6e 75 6d 62 65 72		        .text "number"
.c568					nt_to_number:
>c568	07 10				        .byte 7, UF
>c56a	77 c5 bf a2 5e a3		        .word nt_hex, xt_to_number, z_to_number
>c570	3e 6e 75 6d 62 65 72		        .text ">number"
.c577					nt_hex:
>c577	03 00				        .byte 3, 0
>c579	82 c5 99 91 9f 91		        .word nt_decimal, xt_hex, z_hex
>c57f	68 65 78			        .text "hex"
.c582					nt_decimal:
>c582	07 00				        .byte 7, 0
>c584	91 c5 c1 8a c7 8a		        .word nt_count, xt_decimal, z_decimal
>c58a	64 65 63 69 6d 61 6c		        .text "decimal"
.c591					nt_count:
>c591	05 10				        .byte 5, UF
>c593	9e c5 6b 89 7e 89		        .word nt_m_star, xt_count, z_count
>c599	63 6f 75 6e 74			        .text "count"
.c59e					nt_m_star:
>c59e	02 10				        .byte 2, UF
>c5a0	a8 c5 bf 94 d9 94		        .word nt_um_star, xt_m_star, z_m_star
>c5a6	6d 2a				        .text "m*"
.c5a8					nt_um_star:
>c5a8	03 10				        .byte 3, UF
>c5aa	b3 c5 fe a5 43 a6		        .word nt_star, xt_um_star, z_um_star
>c5b0	75 6d 2a			        .text "um*"
.c5b3					nt_star:
>c5b3	01 10				        .byte 1, UF
>c5b5	bc c5 62 a1 6a a1		        .word nt_um_slash_mod, xt_star, z_star
>c5bb	2a				        .text "*"
.c5bc					nt_um_slash_mod:
>c5bc	06 10				        .byte 6, UF
>c5be	ca c5 bc a5 fd a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c5c4	75 6d 2f 6d 6f 64		        .text "um/mod"
.c5ca					nt_sm_slash_rem:
>c5ca	06 10				        .byte 6, UF
>c5cc	d8 c5 d7 a0 ff a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c5d2	73 6d 2f 72 65 6d		        .text "sm/rem"
.c5d8					nt_fm_slash_mod:
>c5d8	06 10				        .byte 6, UF
>c5da	e6 c5 ad 90 e3 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c5e0	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c5e6					nt_slash:
>c5e6	01 10				        .byte 1, UF
>c5e8	ef c5 fe 9f 1a a0		        .word nt_slash_mod, xt_slash, z_slash
>c5ee	2f				        .text "/"
.c5ef					nt_slash_mod:
>c5ef	04 10				        .byte 4, UF
>c5f1	fb c5 03 a0 1a a0		        .word nt_mod, xt_slash_mod, z_slash_mod
>c5f7	2f 6d 6f 64			        .text "/mod"
.c5fb					nt_mod:
>c5fb	03 10				        .byte 3, UF
>c5fd	06 c6 ea 95 f2 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c603	6d 6f 64			        .text "mod"
.c606					nt_star_slash_mod:
>c606	05 10				        .byte 5, UF
>c608	13 c6 74 a1 83 a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c60e	2a 2f 6d 6f 64			        .text "*/mod"
.c613					nt_star_slash:
>c613	02 10				        .byte 2, UF
>c615	1d c6 6b a1 73 a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c61b	2a 2f				        .text "*/"
.c61d					nt_backslash:
>c61d	01 04				        .byte 1, IM
>c61f	26 c6 78 83 a2 83		        .word nt_move, xt_backslash, z_backslash
>c625	5c				        .byte $5c
.c626					nt_move:
>c626	04 18				        .byte 4, NN+UF
>c628	32 c6 f3 95 11 96		        .word nt_cmove_up, xt_move, z_move
>c62e	6d 6f 76 65			        .text "move"
.c632					nt_cmove_up:
>c632	06 10				        .byte 6, UF
>c634	40 c6 f0 86 2a 87		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c63a	63 6d 6f 76 65 3e		        .text "cmove>"
.c640					nt_cmove:
>c640	05 10				        .byte 5, UF
>c642	4d c6 b5 86 ef 86		        .word nt_pad, xt_cmove, z_cmove
>c648	63 6d 6f 76 65			        .text "cmove"
.c64d					nt_pad:
>c64d	03 00				        .byte 3, 0
>c64f	58 c6 d2 98 e1 98		        .word nt_cleave, xt_pad, z_pad
>c655	70 61 64			        .text "pad"
.c658					nt_cleave:
>c658	06 10				        .byte 6, UF
>c65a	66 c6 68 86 b4 86		        .word nt_hexstore, xt_cleave, z_cleave
>c660	63 6c 65 61 76 65		        .text "cleave"
.c666					nt_hexstore:
>c666	08 10				        .byte 8, UF
>c668	76 c6 a0 91 f2 91		        .word nt_within, xt_hexstore, z_hexstore
>c66e	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c676					nt_within:
>c676	06 10				        .byte 6, UF
>c678	84 c6 a7 a6 bc a6		        .word nt_to_in, xt_within, z_within
>c67e	77 69 74 68 69 6e		        .text "within"
.c684					nt_to_in:
>c684	03 00				        .byte 3, 0
>c686	8f c6 b4 a2 be a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c68c	3e 69 6e			        .text ">in"
.c68f					nt_less_number_sign:
>c68f	02 00				        .byte 2, 0
>c691	99 c6 76 93 83 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c697	3c 23				        .text "<#"
.c699					nt_number_sign:
>c699	01 10				        .byte 1, UF
>c69b	a2 c6 b8 97 ec 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c6a1	23				        .text "#"
.c6a2					nt_number_sign_s:
>c6a2	02 10				        .byte 2, UF
>c6a4	ac c6 0f 98 1f 98		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c6aa	23 73				        .text "#s"
.c6ac					nt_number_sign_greater:
>c6ac	02 10				        .byte 2, UF
>c6ae	b6 c6 ed 97 0e 98		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c6b4	23 3e				        .text "#>"
.c6b6					nt_hold:
>c6b6	04 10				        .byte 4, UF
>c6b8	c2 c6 f3 91 04 92		        .word nt_sign, xt_hold, z_hold
>c6be	68 6f 6c 64			        .text "hold"
.c6c2					nt_sign:
>c6c2	04 10				        .byte 4, UF
>c6c4	ce c6 e9 9f fd 9f		        .word nt_output, xt_sign, z_sign
>c6ca	73 69 67 6e			        .text "sign"
.c6ce					nt_output:
>c6ce	06 00				        .byte 6, 0
>c6d0	dc c6 b9 98 c3 98		        .word nt_input, xt_output, z_output
>c6d6	6f 75 74 70 75 74		        .text "output"
.c6dc					nt_input:
>c6dc	05 00				        .byte 5, 0
>c6de	e9 c6 73 92 7d 92		        .word nt_cr, xt_input, z_input
>c6e4	69 6e 70 75 74			        .text "input"
.c6e9					nt_cr:
>c6e9	02 00				        .byte 2, 0
>c6eb	f3 c6 7f 89 84 89		        .word nt_page, xt_cr, z_cr
>c6f1	63 72				        .text "cr"
.c6f3					nt_page:
>c6f3	04 00				        .byte 4, 0
>c6f5	ff c6 e2 98 ff 98		        .word nt_at_xy, xt_page, z_page
>c6fb	70 61 67 65			        .text "page"
.c6ff					nt_at_xy:
>c6ff	05 10				        .byte 5, UF
>c701	0c c7 4a 83 77 83		        .word nt_marker, xt_at_xy, z_at_xy
>c707	61 74 2d 78 79			        .text "at-xy"
.c70c					nt_marker:
>c70c	06 04				        .byte 6, IM
>c70e	1a c7 da 94 17 95		        .word nt_words, xt_marker, z_marker
>c714	6d 61 72 6b 65 72		        .text "marker"
.c71a					nt_words:
>c71a	05 00				        .byte 5, 0
>c71c	27 c7 1a a7 76 a7		        .word nt_wordsize, xt_words, z_words
>c722	77 6f 72 64 73			        .text "words"
.c727					nt_wordsize:
>c727	08 10				        .byte 8, UF
>c729	37 c7 77 a7 97 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c72f	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c737					nt_aligned:
>c737	07 00				        .byte 7, 0
>c739	46 c7 a4 82 a4 82		        .word nt_align, xt_align, z_align
>c73f	61 6c 69 67 6e 65 64		        .text "aligned"
.c746					nt_align:
>c746	05 00				        .byte 5, 0
>c748	53 c7 a4 82 a4 82		        .word nt_bell, xt_align, z_align
>c74e	61 6c 69 67 6e			        .text "align"
.c753					nt_bell:
>c753	04 00				        .byte 4, 0
>c755	5f c7 b0 83 b5 83		        .word nt_dump, xt_bell, z_bell
>c75b	62 65 6c 6c			        .text "bell"
.c75f					nt_dump:
>c75f	04 10				        .byte 4, UF
>c761	6b c7 50 8d b6 8d		        .word nt_dot_s, xt_dump, z_dump
>c767	64 75 6d 70			        .text "dump"
.c76b					nt_dot_s:
>c76b	02 00				        .byte 2, 0
>c76d	75 c7 bc 8c ff 8c		        .word +, xt_dot_s, z_dot_s
>c773	2e 73				        .text ".s"
.c775					+
.c775					nt_disasm:
>c775	06 10				        .byte 6, UF
>c777	83 c7 56 8b 5c 8b		        .word +, xt_disasm, z_disasm
>c77d	64 69 73 61 73 6d		        .text "disasm"
.c783					+
.c783					nt_compare:
>c783	07 10				        .byte 7, UF
>c785	92 c7 a4 87 08 88		        .word nt_search, xt_compare, z_compare
>c78b	63 6f 6d 70 61 72 65		        .text "compare"
.c792					nt_search:
>c792	06 18				        .byte 6, UF+NN
>c794	a0 c7 eb 9e 89 9f		        .word +, xt_search, z_search
>c79a	73 65 61 72 63 68		        .text "search"
.c7a0					+
.c7a0					nt_environment_q:
>c7a0	0c 10				        .byte 12, UF
>c7a2	b4 c7 31 8e ad 8e		        .word +, xt_environment_q, z_environment_q
>c7a8	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c7b0	65 6e 74 3f
.c7b4					+
.c7b4					nt_find:
>c7b4	04 10				        .byte 4, UF
>c7b6	c0 c7 af 8f f6 8f		        .word nt_word, xt_find, z_find
>c7bc	66 69 6e 64			        .text "find"
.c7c0					nt_word:
>c7c0	04 10				        .byte 4, UF
>c7c2	cc c7 bd a6 02 a7		        .word nt_paren, xt_word, z_word
>c7c8	77 6f 72 64			        .text "word"
.c7cc					nt_paren:
>c7cc	01 04				        .byte 1, IM
>c7ce	d5 c7 00 99 0f 99		        .word nt_dot_paren, xt_paren, z_paren
>c7d4	28				        .text "("
.c7d5					nt_dot_paren:
>c7d5	02 04				        .byte 2, IM
>c7d7	df c7 74 8c 82 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c7dd	2e 28				        .text ".("
.c7df					nt_if:
>c7df	02 0d				        .byte 2, IM+CO+NN
>c7e1	e9 c7 1f 92 2f 92		        .word nt_then, xt_if, z_if
>c7e7	69 66				        .text "if"
.c7e9					nt_then:
>c7e9	04 0d				        .byte 4, IM+CO+NN
>c7eb	f5 c7 c4 a1 cd a1		        .word nt_else, xt_then, z_then
>c7f1	74 68 65 6e			        .text "then"
.c7f5					nt_else:
>c7f5	04 0d				        .byte 4, IM+CO+NN
>c7f7	01 c8 dd 8d f6 8d		        .word nt_repeat, xt_else, z_else
>c7fd	65 6c 73 65			        .text "else"
.c801					nt_repeat:
>c801	06 0d				        .byte 6, IM+CO+NN
>c803	0f c8 6b 9b 77 9b		        .word nt_until, xt_repeat, z_repeat
>c809	72 65 70 65 61 74		        .text "repeat"
.c80f					nt_until:
>c80f	05 0d				        .byte 5, IM+CO+NN
>c811	1c c8 4b a6 55 a6		        .word nt_while, xt_until, z_until
>c817	75 6e 74 69 6c			        .text "until"
.c81c					nt_while:
>c81c	05 0d				        .byte 5, IM+CO+NN
>c81e	29 c8 93 a6 a6 a6		        .word nt_case, xt_while, z_while
>c824	77 68 69 6c 65			        .text "while"
.c829					nt_case:
>c829	04 0d				        .byte 4, IM+CO+NN
>c82b	35 c8 aa a7 b0 a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c831	63 61 73 65			        .text "case"
.c835					nt_of:
>c835	02 0d				        .byte 2, IM+CO+NN
>c837	3f c8 20 98 38 98		        .word nt_endof, xt_of, z_of
>c83d	6f 66				        .text "of"
.c83f					nt_endof:
>c83f	05 0d				        .byte 5, IM+CO+NN
>c841	4c c8 dd 8d f6 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c847	65 6e 64 6f 66			        .text "endof"
.c84c					nt_endcase:
>c84c	07 0d				        .byte 7, IM+CO+NN
>c84e	5b c8 1c 8e 30 8e		        .word nt_defer_fetch, xt_endcase, z_endcase
>c854	65 6e 64 63 61 73 65		        .text "endcase"
.c85b					nt_defer_fetch:
>c85b	06 00				        .byte 6, 0
>c85d	69 c8 fb 8a 01 8b		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c863	64 65 66 65 72 40		        .text "defer@"
.c869					nt_defer_store:
>c869	06 00				        .byte 6, 0
>c86b	77 c8 02 8b 08 8b		        .word nt_is, xt_defer_store, z_defer_store
>c871	64 65 66 65 72 21		        .text "defer!"
.c877					nt_is:
>c877	02 04				        .byte 2, IM
>c879	81 c8 17 93 2f 93		        .word nt_action_of, xt_is, z_is
>c87f	69 73				        .text "is"
.c881					nt_action_of:
>c881	09 04				        .byte 9, IM
>c883	92 c8 6a 82 82 82		        .word nt_useraddr, xt_action_of, z_action_of
>c889	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c891	66
.c892					nt_useraddr:
>c892	08 00				        .byte 8, 0
>c894	a2 c8 6f a6 79 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c89a	75 73 65 72 61 64 64 72		        .text "useraddr"
.c8a2					nt_buffer_colon:
>c8a2	07 00				        .byte 7, 0
>c8a4	b1 c8 02 86 08 86		        .word +, xt_buffer_colon, z_buffer_colon
>c8aa	62 75 66 66 65 72 3a		        .text "buffer:"
.c8b1					+
.c8b1					nt_buffstatus:
>c8b1	0a 00				        .byte 10, 0
>c8b3	c3 c8 09 86 18 86		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c8b9	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c8c1	75 73
.c8c3					nt_buffblocknum:
>c8c3	0c 00				        .byte 12, 0
>c8c5	d7 c8 c1 85 d0 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c8cb	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c8d3	6b 6e 75 6d
.c8d7					nt_blkbuffer:
>c8d7	09 00				        .byte 9, 0
>c8d9	e8 c8 cf 83 dc 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c8df	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c8e7	72
.c8e8					nt_scr:
>c8e8	03 00				        .byte 3, 0
>c8ea	f3 c8 db 9e ea 9e		        .word nt_blk, xt_scr, z_scr
>c8f0	73 63 72			        .text "scr"
.c8f3					nt_blk:
>c8f3	03 00				        .byte 3, 0
>c8f5	fe c8 bf 83 ce 83		        .word nt_block_write, xt_blk, z_blk
>c8fb	62 6c 6b			        .text "blk"
.c8fe					nt_block_write:
>c8fe	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c900	11 c9 7c 85 8a 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c906	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c90e	69 74 65
.c911					nt_block_write_vector:
>c911	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c913	2b c9 8a 85 99 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c919	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c921	69 74 65 2d 76 65 63 74 6f 72
.c92b					nt_block_read:
>c92b	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c92d	3d c9 59 85 67 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c933	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c93b	61 64
.c93d					nt_block_read_vector:
>c93d	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c93f	56 c9 67 85 76 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c945	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c94d	61 64 2d 76 65 63 74 6f 72
.c956					nt_save_buffers:
>c956	0c 00				        .byte 12, 0
>c958	6a c9 c0 9e da 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c95e	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c966	66 65 72 73
.c96a					nt_block:
>c96a	05 00				        .byte 5, 0
>c96c	77 c9 dd 83 2f 84		        .word nt_update, xt_block, z_block
>c972	62 6c 6f 63 6b			        .text "block"
.c977					nt_update:
>c977	06 00				        .byte 6, 0
>c979	85 c9 66 a6 6e a6		        .word nt_buffer, xt_update, z_update
>c97f	75 70 64 61 74 65		        .text "update"
.c985					nt_buffer:
>c985	06 00				        .byte 6, 0
>c987	93 c9 d1 85 01 86		        .word nt_empty_buffers, xt_buffer, z_buffer
>c98d	62 75 66 66 65 72		        .text "buffer"
.c993					nt_empty_buffers:
>c993	0d 00				        .byte 13, 0
>c995	a8 c9 15 8e 1b 8e		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c99b	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c9a3	66 66 65 72 73
.c9a8					nt_flush:
>c9a8	05 00				        .byte 5, 0
>c9aa	b5 c9 a3 90 ac 90		        .word nt_load, xt_flush, z_flush
>c9b0	66 6c 75 73 68			        .text "flush"
.c9b5					nt_load:
>c9b5	04 10				        .byte 4, UF
>c9b7	c1 c9 e8 93 2b 94		        .word nt_thru, xt_load, z_load
>c9bd	6c 6f 61 64			        .text "load"
.c9c1					nt_thru:
>c9c1	04 10				        .byte 4, UF
>c9c3	cd c9 ce a1 12 a2		        .word nt_list, xt_thru, z_thru
>c9c9	74 68 72 75			        .text "thru"
.c9cd					nt_list:
>c9cd	04 10				        .byte 4, UF
>c9cf	d9 c9 99 93 a5 93		        .word +, xt_list, z_list
>c9d5	6c 69 73 74			        .text "list"
.c9d9					+
.c9d9					nt_block_ramdrive_init:
>c9d9	13 10				        .byte 19, UF
>c9db	f4 c9 30 84 58 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c9e1	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c9e9	6d 64 72 69 76 65 2d 69 6e 69 74
.c9f4					+
.c9f4					nt_definitions:
>c9f4	0b 00				        .byte 11, 0
>c9f6	07 ca 09 8b 11 8b		        .word nt_wordlist, xt_definitions, z_definitions
>c9fc	64 65 66 69 6e 69 74 69		        .text "definitions"
>ca04	6f 6e 73
.ca07					nt_wordlist:
>ca07	08 00				        .byte 8, 0
>ca09	17 ca 03 a7 19 a7		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>ca0f	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.ca17					nt_search_wordlist:
>ca17	0f 10				        .byte 15, UF
>ca19	2e ca d1 9b b1 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>ca1f	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>ca27	6f 72 64 6c 69 73 74
.ca2e					nt_set_current:
>ca2e	0b 10				        .byte 11, UF
>ca30	41 ca 40 9d 4b 9d		        .word nt_get_current, xt_set_current, z_set_current
>ca36	73 65 74 2d 63 75 72 72		        .text "set-current"
>ca3e	65 6e 74
.ca41					nt_get_current:
>ca41	0b 00				        .byte 11, 0
>ca43	54 ca 45 91 4f 91		        .word nt_set_order, xt_get_current, z_get_current
>ca49	67 65 74 2d 63 75 72 72		        .text "get-current"
>ca51	65 6e 74
.ca54					nt_set_order:
>ca54	09 00				        .byte 9, 0
>ca56	65 ca 4c 9d 7f 9d		        .word nt_get_order, xt_set_order, z_set_order
>ca5c	73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca64	72
.ca65					nt_get_order:
>ca65	09 00				        .byte 9, 0
>ca67	76 ca 50 91 78 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>ca6d	67 65 74 2d 6f 72 64 65		        .text "get-order"
>ca75	72
.ca76					nt_root_wordlist:
>ca76	0d 00				        .byte 13, 0
>ca78	8b ca 7f 9b 87 9b		        .word +, xt_root_wordlist, z_root_wordlist
>ca7e	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>ca86	64 6c 69 73 74
.ca8b					+
.ca8b					nt_assembler_wordlist:
>ca8b	12 00				        .byte 18, 0
>ca8d	a5 ca a9 a3 b1 a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>ca93	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>ca9b	72 2d 77 6f 72 64 6c 69 73 74
.caa5					+
.caa5					nt_editor_wordlist:
>caa5	0f 00				        .byte 15, 0
>caa7	bc ca 39 98 41 98		        .word +, xt_editor_wordlist, z_editor_wordlist
>caad	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>cab5	6f 72 64 6c 69 73 74
.cabc					+
.cabc					nt_forth_wordlist:
>cabc	0e 00				        .byte 14, 0
>cabe	d2 ca aa a7 b0 a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>cac4	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>cacc	72 64 6c 69 73 74
.cad2					nt_only:
>cad2	04 00				        .byte 4, 0
>cad4	de ca 58 98 63 98		        .word nt_also, xt_only, z_only
>cada	6f 6e 6c 79			        .text "only"
.cade					nt_also:
>cade	04 00				        .byte 4, 0
>cae0	ea ca 1a 83 29 83		        .word nt_previous, xt_also, z_also
>cae6	61 6c 73 6f			        .text "also"
.caea					nt_previous:
>caea	08 00				        .byte 8, 0
>caec	fa ca 86 9a 92 9a		        .word nt_to_order, xt_previous, z_previous
>caf2	70 72 65 76 69 6f 75 73		        .text "previous"
.cafa					nt_to_order:
>cafa	06 00				        .byte 6, 0
>cafc	08 cb 5f a3 71 a3		        .word nt_order, xt_to_order, z_to_order
>cb02	3e 6f 72 64 65 72		        .text ">order"
.cb08					nt_order:
>cb08	05 00				        .byte 5, 0
>cb0a	15 cb 76 98 a0 98		        .word nt_forth, xt_order, z_order
>cb10	6f 72 64 65 72			        .text "order"
.cb15					nt_forth:
>cb15	05 00				        .byte 5, 0
>cb17	22 cb e4 90 ea 90		        .word +, xt_forth, z_forth
>cb1d	66 6f 72 74 68			        .text "forth"
.cb22					+
>cb22	03 08				nt_see: .byte 3, NN
>cb24	2d cb b2 9c 3f 9d		        .word +, xt_see, z_see
>cb2a	73 65 65			        .text "see"
.cb2d					+
.cb2d					nt_ed:
>cb2d	02 08				        .byte 2, NN
>cb2f	37 cb d9 8d dc 8d		        .word +, xt_ed, z_ed
>cb35	65 64				        .text "ed"
.cb37					+
.cb37					nt_cold:
>cb37	04 00				        .byte 4, 0
>cb39	43 cb 00 80 bd 80		        .word nt_bye, xt_cold, z_cold
>cb3f	63 6f 6c 64			        .text "cold"
.cb43					nt_bye:
>cb43	03				        .byte 3         ; length of word strings
>cb44	00				        .byte 0         ; status byte
>cb45	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>cb47	19 86				        .word xt_bye    ; start of code block (xt of this word)
>cb49	1c 86				        .word z_bye     ; end of code (RTS)
>cb4b	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.cb4e					root_dictionary_start:
.cb4e					nt_root_set_order:
>cb4e	09 00				        .byte 9, 0
>cb50	5f cb 4c 9d 7f 9d		        .word nt_root_forth, xt_set_order, z_set_order
>cb56	73 65 74 2d 6f 72 64 65		        .text "set-order"
>cb5e	72
.cb5f					nt_root_forth:
>cb5f	05 00				        .byte 5, 0
>cb61	6c cb e4 90 ea 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>cb67	66 6f 72 74 68			        .text "forth"
.cb6c					nt_root_forth_wordlist:
>cb6c	0e 00				        .byte 14, 0
>cb6e	82 cb aa a7 b0 a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>cb74	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>cb7c	72 64 6c 69 73 74
.cb82					nt_root_words:
>cb82	05 00				        .byte 5, 0
>cb84	00 00 1a a7 76 a7		        .word 0000, xt_words, z_words
>cb8a	77 6f 72 64 73			        .text "words"
.cb8f					editor_dictionary_start:
.cb8f					nt_editor_o:
>cb8f	01 00				        .byte 1, 0
>cb91	98 cb dd a8 22 a9		        .word nt_editor_line, xt_editor_o, z_editor_o
>cb97	6f				        .text "o"
.cb98					nt_editor_line:
>cb98	04 10				        .byte 4, UF
>cb9a	a4 cb c4 a8 dc a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>cba0	6c 69 6e 65			        .text "line"
.cba4					nt_editor_l:
>cba4	01 00				        .byte 1, 0
>cba6	ad cb 48 a8 c3 a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cbac	6c				        .text "l"
.cbad					nt_editor_el:
>cbad	02 00				        .byte 2, 0
>cbaf	b7 cb 36 a8 47 a8		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cbb5	65 6c				        .text "el"
.cbb7					nt_editor_erase_screen:
>cbb7	0c 00				        .byte 12, 0
>cbb9	cb cb 24 a8 35 a8		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cbbf	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cbc7	72 65 65 6e
.cbcb					nt_editor_enter_screen:
>cbcb	0c 00				        .byte 12, 0
>cbcd	00 00 08 a8 23 a8		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cbd3	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cbdb	72 65 65 6e
.cbdf					assembler_dictionary_start:
.cbdf					nt_asm_adc_h:
>cbdf	05 0c						.byte 5, IM+NN
>cbe1	ec cb				                .word nt_asm_adc_x
>cbe3	23 a9 28 a9					.word xt_asm_adc_h, z_asm_adc_h
>cbe7	61 64 63 2e 23					.text "adc.#"
.cbec					nt_asm_adc_x:
>cbec	05 0c						.byte 5, IM+NN
>cbee	f9 cb				                .word nt_asm_adc_y
>cbf0	28 a9 2d a9					.word xt_asm_adc_x, z_asm_adc_x
>cbf4	61 64 63 2e 78					.text "adc.x"
.cbf9					nt_asm_adc_y:
>cbf9	05 0c						.byte 5, IM+NN
>cbfb	06 cc				                .word nt_asm_adc_z
>cbfd	2d a9 32 a9					.word xt_asm_adc_y, z_asm_adc_y
>cc01	61 64 63 2e 79					.text "adc.y"
.cc06					nt_asm_adc_z:
>cc06	05 0c						.byte 5, IM+NN
>cc08	13 cc				                .word nt_asm_adc_zi
>cc0a	32 a9 37 a9					.word xt_asm_adc_z, z_asm_adc_z
>cc0e	61 64 63 2e 7a					.text "adc.z"
.cc13					nt_asm_adc_zi:
>cc13	06 0c						.byte 6, IM+NN
>cc15	21 cc				                .word nt_asm_adc_ziy
>cc17	37 a9 3c a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cc1b	61 64 63 2e 7a 69				.text "adc.zi"
.cc21					nt_asm_adc_ziy:
>cc21	07 0c						.byte 7, IM+NN
>cc23	30 cc				                .word nt_asm_adc_zx
>cc25	3c a9 41 a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cc29	61 64 63 2e 7a 69 79				.text "adc.ziy"
.cc30					nt_asm_adc_zx:
>cc30	06 0c						.byte 6, IM+NN
>cc32	3e cc				                .word nt_asm_adc_zxi
>cc34	41 a9 46 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cc38	61 64 63 2e 7a 78				.text "adc.zx"
.cc3e					nt_asm_adc_zxi:
>cc3e	07 0c						.byte 7, IM+NN
>cc40	4d cc				                .word nt_asm_and
>cc42	46 a9 4b a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cc46	61 64 63 2e 7a 78 69				.text "adc.zxi"
.cc4d					nt_asm_and:
>cc4d	04 0c						.byte 4, IM+NN
>cc4f	59 cc				                .word nt_asm_and_h
>cc51	4b a9 50 a9					.word xt_asm_and, z_asm_and
>cc55	61 6e 64 2e					.text "and."
.cc59					nt_asm_and_h:
>cc59	05 0c						.byte 5, IM+NN
>cc5b	66 cc				                .word nt_asm_and_x
>cc5d	50 a9 55 a9					.word xt_asm_and_h, z_asm_and_h
>cc61	61 6e 64 2e 23					.text "and.#"
.cc66					nt_asm_and_x:
>cc66	05 0c						.byte 5, IM+NN
>cc68	73 cc				                .word nt_asm_and_y
>cc6a	55 a9 5a a9					.word xt_asm_and_x, z_asm_and_x
>cc6e	61 6e 64 2e 78					.text "and.x"
.cc73					nt_asm_and_y:
>cc73	05 0c						.byte 5, IM+NN
>cc75	80 cc				                .word nt_asm_and_z
>cc77	5a a9 5f a9					.word xt_asm_and_y, z_asm_and_y
>cc7b	61 6e 64 2e 79					.text "and.y"
.cc80					nt_asm_and_z:
>cc80	05 0c						.byte 5, IM+NN
>cc82	8d cc				                .word nt_asm_and_zi
>cc84	5f a9 64 a9					.word xt_asm_and_z, z_asm_and_z
>cc88	61 6e 64 2e 7a					.text "and.z"
.cc8d					nt_asm_and_zi:
>cc8d	06 0c						.byte 6, IM+NN
>cc8f	9b cc				                .word nt_asm_and_ziy
>cc91	64 a9 69 a9					.word xt_asm_and_zi, z_asm_and_zi
>cc95	61 6e 64 2e 7a 69				.text "and.zi"
.cc9b					nt_asm_and_ziy:
>cc9b	07 0c						.byte 7, IM+NN
>cc9d	aa cc				                .word nt_asm_and_zx
>cc9f	69 a9 6e a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cca3	61 6e 64 2e 7a 69 79				.text "and.ziy"
.ccaa					nt_asm_and_zx:
>ccaa	06 0c						.byte 6, IM+NN
>ccac	b8 cc				                .word nt_asm_and_zxi
>ccae	6e a9 73 a9					.word xt_asm_and_zx, z_asm_and_zx
>ccb2	61 6e 64 2e 7a 78				.text "and.zx"
.ccb8					nt_asm_and_zxi:
>ccb8	07 0c						.byte 7, IM+NN
>ccba	c7 cc				                .word nt_asm_asl
>ccbc	73 a9 78 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>ccc0	61 6e 64 2e 7a 78 69				.text "and.zxi"
.ccc7					nt_asm_asl:
>ccc7	03 0c						.byte 3, IM+NN
>ccc9	d2 cc				                .word nt_asm_asl_a
>cccb	78 a9 7d a9					.word xt_asm_asl, z_asm_asl
>cccf	61 73 6c					.text "asl"
.ccd2					nt_asm_asl_a:
>ccd2	05 0c						.byte 5, IM+NN
>ccd4	df cc				                .word nt_asm_asl_x
>ccd6	7d a9 82 a9					.word xt_asm_asl_a, z_asm_asl_a
>ccda	61 73 6c 2e 61					.text "asl.a"
.ccdf					nt_asm_asl_x:
>ccdf	05 0c						.byte 5, IM+NN
>cce1	ec cc				                .word nt_asm_asl_z
>cce3	82 a9 87 a9					.word xt_asm_asl_x, z_asm_asl_x
>cce7	61 73 6c 2e 78					.text "asl.x"
.ccec					nt_asm_asl_z:
>ccec	05 0c						.byte 5, IM+NN
>ccee	f9 cc				                .word nt_asm_asl_zx
>ccf0	87 a9 8c a9					.word xt_asm_asl_z, z_asm_asl_z
>ccf4	61 73 6c 2e 7a					.text "asl.z"
.ccf9					nt_asm_asl_zx:
>ccf9	06 0c						.byte 6, IM+NN
>ccfb	07 cd				                .word nt_asm_bcc
>ccfd	8c a9 91 a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cd01	61 73 6c 2e 7a 78				.text "asl.zx"
.cd07					nt_asm_bcc:
>cd07	03 0c						.byte 3, IM+NN
>cd09	12 cd				                .word nt_asm_bcs
>cd0b	91 a9 96 a9					.word xt_asm_bcc, z_asm_bcc
>cd0f	62 63 63					.text "bcc"
.cd12					nt_asm_bcs:
>cd12	03 0c						.byte 3, IM+NN
>cd14	1d cd				                .word nt_asm_beq
>cd16	96 a9 9d a9					.word xt_asm_bcs, z_asm_bcs
>cd1a	62 63 73					.text "bcs"
.cd1d					nt_asm_beq:
>cd1d	03 0c						.byte 3, IM+NN
>cd1f	28 cd				                .word nt_asm_bit
>cd21	9d a9 a2 a9					.word xt_asm_beq, z_asm_beq
>cd25	62 65 71					.text "beq"
.cd28					nt_asm_bit:
>cd28	03 0c						.byte 3, IM+NN
>cd2a	33 cd				                .word nt_asm_bit_h
>cd2c	a2 a9 a7 a9					.word xt_asm_bit, z_asm_bit
>cd30	62 69 74					.text "bit"
.cd33					nt_asm_bit_h:
>cd33	05 0c						.byte 5, IM+NN
>cd35	40 cd				                .word nt_asm_bit_x
>cd37	a7 a9 ac a9					.word xt_asm_bit_h, z_asm_bit_h
>cd3b	62 69 74 2e 23					.text "bit.#"
.cd40					nt_asm_bit_x:
>cd40	05 0c						.byte 5, IM+NN
>cd42	4d cd				                .word nt_asm_bit_z
>cd44	ac a9 b1 a9					.word xt_asm_bit_x, z_asm_bit_x
>cd48	62 69 74 2e 78					.text "bit.x"
.cd4d					nt_asm_bit_z:
>cd4d	05 0c						.byte 5, IM+NN
>cd4f	5a cd				                .word nt_asm_bit_zx
>cd51	b1 a9 b6 a9					.word xt_asm_bit_z, z_asm_bit_z
>cd55	62 69 74 2e 7a					.text "bit.z"
.cd5a					nt_asm_bit_zx:
>cd5a	06 0c						.byte 6, IM+NN
>cd5c	68 cd				                .word nt_asm_bmi
>cd5e	b6 a9 bb a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cd62	62 69 74 2e 7a 78				.text "bit.zx"
.cd68					nt_asm_bmi:
>cd68	03 0c						.byte 3, IM+NN
>cd6a	73 cd				                .word nt_asm_bne
>cd6c	bb a9 c0 a9					.word xt_asm_bmi, z_asm_bmi
>cd70	62 6d 69					.text "bmi"
.cd73					nt_asm_bne:
>cd73	03 0c						.byte 3, IM+NN
>cd75	7e cd				                .word nt_asm_bpl
>cd77	c0 a9 c5 a9					.word xt_asm_bne, z_asm_bne
>cd7b	62 6e 65					.text "bne"
.cd7e					nt_asm_bpl:
>cd7e	03 0c						.byte 3, IM+NN
>cd80	89 cd				                .word nt_asm_bra
>cd82	c5 a9 ca a9					.word xt_asm_bpl, z_asm_bpl
>cd86	62 70 6c					.text "bpl"
.cd89					nt_asm_bra:
>cd89	03 0c						.byte 3, IM+NN
>cd8b	94 cd				                .word nt_asm_brk
>cd8d	ca a9 cf a9					.word xt_asm_bra, z_asm_bra
>cd91	62 72 61					.text "bra"
.cd94					nt_asm_brk:
>cd94	03 0c						.byte 3, IM+NN
>cd96	9f cd				                .word nt_asm_bvc
>cd98	cf a9 d4 a9					.word xt_asm_brk, z_asm_brk
>cd9c	62 72 6b					.text "brk"
.cd9f					nt_asm_bvc:
>cd9f	03 0c						.byte 3, IM+NN
>cda1	aa cd				                .word nt_asm_bvs
>cda3	d4 a9 d9 a9					.word xt_asm_bvc, z_asm_bvc
>cda7	62 76 63					.text "bvc"
.cdaa					nt_asm_bvs:
>cdaa	03 0c						.byte 3, IM+NN
>cdac	b5 cd				                .word nt_asm_clc
>cdae	d9 a9 de a9					.word xt_asm_bvs, z_asm_bvs
>cdb2	62 76 73					.text "bvs"
.cdb5					nt_asm_clc:
>cdb5	03 0c						.byte 3, IM+NN
>cdb7	c0 cd				                .word nt_asm_cld
>cdb9	de a9 e3 a9					.word xt_asm_clc, z_asm_clc
>cdbd	63 6c 63					.text "clc"
.cdc0					nt_asm_cld:
>cdc0	03 0c						.byte 3, IM+NN
>cdc2	cb cd				                .word nt_asm_cli
>cdc4	e3 a9 e8 a9					.word xt_asm_cld, z_asm_cld
>cdc8	63 6c 64					.text "cld"
.cdcb					nt_asm_cli:
>cdcb	03 0c						.byte 3, IM+NN
>cdcd	d6 cd				                .word nt_asm_clv
>cdcf	e8 a9 ed a9					.word xt_asm_cli, z_asm_cli
>cdd3	63 6c 69					.text "cli"
.cdd6					nt_asm_clv:
>cdd6	03 0c						.byte 3, IM+NN
>cdd8	e1 cd				                .word nt_asm_cmp
>cdda	ed a9 f2 a9					.word xt_asm_clv, z_asm_clv
>cdde	63 6c 76					.text "clv"
.cde1					nt_asm_cmp:
>cde1	03 0c						.byte 3, IM+NN
>cde3	ec cd				                .word nt_asm_cmp_h
>cde5	f2 a9 f7 a9					.word xt_asm_cmp, z_asm_cmp
>cde9	63 6d 70					.text "cmp"
.cdec					nt_asm_cmp_h:
>cdec	05 0c						.byte 5, IM+NN
>cdee	f9 cd				                .word nt_asm_cmp_x
>cdf0	f7 a9 fc a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cdf4	63 6d 70 2e 23					.text "cmp.#"
.cdf9					nt_asm_cmp_x:
>cdf9	05 0c						.byte 5, IM+NN
>cdfb	06 ce				                .word nt_asm_cmp_y
>cdfd	fc a9 01 aa					.word xt_asm_cmp_x, z_asm_cmp_x
>ce01	63 6d 70 2e 78					.text "cmp.x"
.ce06					nt_asm_cmp_y:
>ce06	05 0c						.byte 5, IM+NN
>ce08	13 ce				                .word nt_asm_cmp_z
>ce0a	01 aa 06 aa					.word xt_asm_cmp_y, z_asm_cmp_y
>ce0e	63 6d 70 2e 79					.text "cmp.y"
.ce13					nt_asm_cmp_z:
>ce13	05 0c						.byte 5, IM+NN
>ce15	20 ce				                .word nt_asm_cmp_zi
>ce17	06 aa 0b aa					.word xt_asm_cmp_z, z_asm_cmp_z
>ce1b	63 6d 70 2e 7a					.text "cmp.z"
.ce20					nt_asm_cmp_zi:
>ce20	06 0c						.byte 6, IM+NN
>ce22	2e ce				                .word nt_asm_cmp_ziy
>ce24	0b aa 10 aa					.word xt_asm_cmp_zi, z_asm_cmp_zi
>ce28	63 6d 70 2e 7a 69				.text "cmp.zi"
.ce2e					nt_asm_cmp_ziy:
>ce2e	07 0c						.byte 7, IM+NN
>ce30	3d ce				                .word nt_asm_cmp_zx
>ce32	10 aa 15 aa					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>ce36	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.ce3d					nt_asm_cmp_zx:
>ce3d	06 0c						.byte 6, IM+NN
>ce3f	4b ce				                .word nt_asm_cmp_zxi
>ce41	15 aa 1a aa					.word xt_asm_cmp_zx, z_asm_cmp_zx
>ce45	63 6d 70 2e 7a 78				.text "cmp.zx"
.ce4b					nt_asm_cmp_zxi:
>ce4b	07 0c						.byte 7, IM+NN
>ce4d	5a ce				                .word nt_asm_cpx
>ce4f	1a aa 1f aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>ce53	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.ce5a					nt_asm_cpx:
>ce5a	03 0c						.byte 3, IM+NN
>ce5c	65 ce				                .word nt_asm_cpx_h
>ce5e	1f aa 24 aa					.word xt_asm_cpx, z_asm_cpx
>ce62	63 70 78					.text "cpx"
.ce65					nt_asm_cpx_h:
>ce65	05 0c						.byte 5, IM+NN
>ce67	72 ce				                .word nt_asm_cpx_z
>ce69	24 aa 29 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>ce6d	63 70 78 2e 23					.text "cpx.#"
.ce72					nt_asm_cpx_z:
>ce72	05 0c						.byte 5, IM+NN
>ce74	7f ce				                .word nt_asm_cpy
>ce76	29 aa 2e aa					.word xt_asm_cpx_z, z_asm_cpx_z
>ce7a	63 70 78 2e 7a					.text "cpx.z"
.ce7f					nt_asm_cpy:
>ce7f	03 0c						.byte 3, IM+NN
>ce81	8a ce				                .word nt_asm_cpy_h
>ce83	2e aa 35 aa					.word xt_asm_cpy, z_asm_cpy
>ce87	63 70 79					.text "cpy"
.ce8a					nt_asm_cpy_h:
>ce8a	05 0c						.byte 5, IM+NN
>ce8c	97 ce				                .word nt_asm_cpy_z
>ce8e	35 aa 3a aa					.word xt_asm_cpy_h, z_asm_cpy_h
>ce92	63 70 79 2e 23					.text "cpy.#"
.ce97					nt_asm_cpy_z:
>ce97	05 0c						.byte 5, IM+NN
>ce99	a4 ce				                .word nt_asm_dec
>ce9b	3a aa 3f aa					.word xt_asm_cpy_z, z_asm_cpy_z
>ce9f	63 70 79 2e 7a					.text "cpy.z"
.cea4					nt_asm_dec:
>cea4	03 0c						.byte 3, IM+NN
>cea6	af ce				                .word nt_asm_dec_a
>cea8	3f aa 44 aa					.word xt_asm_dec, z_asm_dec
>ceac	64 65 63					.text "dec"
.ceaf					nt_asm_dec_a:
>ceaf	05 0c						.byte 5, IM+NN
>ceb1	bc ce				                .word nt_asm_dec_x
>ceb3	44 aa 49 aa					.word xt_asm_dec_a, z_asm_dec_a
>ceb7	64 65 63 2e 61					.text "dec.a"
.cebc					nt_asm_dec_x:
>cebc	05 0c						.byte 5, IM+NN
>cebe	c9 ce				                .word nt_asm_dec_z
>cec0	49 aa 4e aa					.word xt_asm_dec_x, z_asm_dec_x
>cec4	64 65 63 2e 78					.text "dec.x"
.cec9					nt_asm_dec_z:
>cec9	05 0c						.byte 5, IM+NN
>cecb	d6 ce				                .word nt_asm_dec_zx
>cecd	4e aa 53 aa					.word xt_asm_dec_z, z_asm_dec_z
>ced1	64 65 63 2e 7a					.text "dec.z"
.ced6					nt_asm_dec_zx:
>ced6	06 0c						.byte 6, IM+NN
>ced8	e4 ce				                .word nt_asm_dex
>ceda	53 aa 58 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cede	64 65 63 2e 7a 78				.text "dec.zx"
.cee4					nt_asm_dex:
>cee4	03 0c						.byte 3, IM+NN
>cee6	ef ce				                .word nt_asm_dey
>cee8	58 aa 5d aa					.word xt_asm_dex, z_asm_dex
>ceec	64 65 78					.text "dex"
.ceef					nt_asm_dey:
>ceef	03 0c						.byte 3, IM+NN
>cef1	fa ce				                .word nt_asm_eor
>cef3	5d aa 62 aa					.word xt_asm_dey, z_asm_dey
>cef7	64 65 79					.text "dey"
.cefa					nt_asm_eor:
>cefa	03 0c						.byte 3, IM+NN
>cefc	05 cf				                .word nt_asm_eor_h
>cefe	62 aa 67 aa					.word xt_asm_eor, z_asm_eor
>cf02	65 6f 72					.text "eor"
.cf05					nt_asm_eor_h:
>cf05	05 0c						.byte 5, IM+NN
>cf07	12 cf				                .word nt_asm_eor_x
>cf09	67 aa 6c aa					.word xt_asm_eor_h, z_asm_eor_h
>cf0d	65 6f 72 2e 23					.text "eor.#"
.cf12					nt_asm_eor_x:
>cf12	05 0c						.byte 5, IM+NN
>cf14	1f cf				                .word nt_asm_eor_y
>cf16	6c aa 71 aa					.word xt_asm_eor_x, z_asm_eor_x
>cf1a	65 6f 72 2e 78					.text "eor.x"
.cf1f					nt_asm_eor_y:
>cf1f	05 0c						.byte 5, IM+NN
>cf21	2c cf				                .word nt_asm_eor_z
>cf23	71 aa 76 aa					.word xt_asm_eor_y, z_asm_eor_y
>cf27	65 6f 72 2e 79					.text "eor.y"
.cf2c					nt_asm_eor_z:
>cf2c	05 0c						.byte 5, IM+NN
>cf2e	39 cf				                .word nt_asm_eor_zi
>cf30	76 aa 7b aa					.word xt_asm_eor_z, z_asm_eor_z
>cf34	65 6f 72 2e 7a					.text "eor.z"
.cf39					nt_asm_eor_zi:
>cf39	06 0c						.byte 6, IM+NN
>cf3b	47 cf				                .word nt_asm_eor_ziy
>cf3d	7b aa 80 aa					.word xt_asm_eor_zi, z_asm_eor_zi
>cf41	65 6f 72 2e 7a 69				.text "eor.zi"
.cf47					nt_asm_eor_ziy:
>cf47	07 0c						.byte 7, IM+NN
>cf49	56 cf				                .word nt_asm_eor_zx
>cf4b	80 aa 85 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cf4f	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cf56					nt_asm_eor_zx:
>cf56	06 0c						.byte 6, IM+NN
>cf58	64 cf				                .word nt_asm_eor_zxi
>cf5a	85 aa 8a aa					.word xt_asm_eor_zx, z_asm_eor_zx
>cf5e	65 6f 72 2e 7a 78				.text "eor.zx"
.cf64					nt_asm_eor_zxi:
>cf64	07 0c						.byte 7, IM+NN
>cf66	73 cf				                .word nt_asm_inc
>cf68	8a aa 8f aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cf6c	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cf73					nt_asm_inc:
>cf73	03 0c						.byte 3, IM+NN
>cf75	7e cf				                .word nt_asm_inc_a
>cf77	8f aa 94 aa					.word xt_asm_inc, z_asm_inc
>cf7b	69 6e 63					.text "inc"
.cf7e					nt_asm_inc_a:
>cf7e	05 0c						.byte 5, IM+NN
>cf80	8b cf				                .word nt_asm_inc_x
>cf82	94 aa 99 aa					.word xt_asm_inc_a, z_asm_inc_a
>cf86	69 6e 63 2e 61					.text "inc.a"
.cf8b					nt_asm_inc_x:
>cf8b	05 0c						.byte 5, IM+NN
>cf8d	98 cf				                .word nt_asm_inc_z
>cf8f	99 aa 9e aa					.word xt_asm_inc_x, z_asm_inc_x
>cf93	69 6e 63 2e 78					.text "inc.x"
.cf98					nt_asm_inc_z:
>cf98	05 0c						.byte 5, IM+NN
>cf9a	a5 cf				                .word nt_asm_inc_zx
>cf9c	9e aa a3 aa					.word xt_asm_inc_z, z_asm_inc_z
>cfa0	69 6e 63 2e 7a					.text "inc.z"
.cfa5					nt_asm_inc_zx:
>cfa5	06 0c						.byte 6, IM+NN
>cfa7	b3 cf				                .word nt_asm_inx
>cfa9	a3 aa a8 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>cfad	69 6e 63 2e 7a 78				.text "inc.zx"
.cfb3					nt_asm_inx:
>cfb3	03 0c						.byte 3, IM+NN
>cfb5	be cf				                .word nt_asm_iny
>cfb7	a8 aa ad aa					.word xt_asm_inx, z_asm_inx
>cfbb	69 6e 78					.text "inx"
.cfbe					nt_asm_iny:
>cfbe	03 0c						.byte 3, IM+NN
>cfc0	c9 cf				                .word nt_asm_jmp
>cfc2	ad aa b2 aa					.word xt_asm_iny, z_asm_iny
>cfc6	69 6e 79					.text "iny"
.cfc9					nt_asm_jmp:
>cfc9	03 0c						.byte 3, IM+NN
>cfcb	d4 cf				                .word nt_asm_jmp_i
>cfcd	b2 aa b7 aa					.word xt_asm_jmp, z_asm_jmp
>cfd1	6a 6d 70					.text "jmp"
.cfd4					nt_asm_jmp_i:
>cfd4	05 0c						.byte 5, IM+NN
>cfd6	e1 cf				                .word nt_asm_jmp_xi
>cfd8	b7 aa bc aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cfdc	6a 6d 70 2e 69					.text "jmp.i"
.cfe1					nt_asm_jmp_xi:
>cfe1	06 0c						.byte 6, IM+NN
>cfe3	ef cf				                .word nt_asm_jsr
>cfe5	bc aa c1 aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cfe9	6a 6d 70 2e 78 69				.text "jmp.xi"
.cfef					nt_asm_jsr:
>cfef	03 0c						.byte 3, IM+NN
>cff1	fa cf				                .word nt_asm_lda
>cff3	c1 aa c6 aa					.word xt_asm_jsr, z_asm_jsr
>cff7	6a 73 72					.text "jsr"
.cffa					nt_asm_lda:
>cffa	03 0c						.byte 3, IM+NN
>cffc	05 d0				                .word nt_asm_lda_h
>cffe	c6 aa cb aa					.word xt_asm_lda, z_asm_lda
>d002	6c 64 61					.text "lda"
.d005					nt_asm_lda_h:
>d005	05 0c						.byte 5, IM+NN
>d007	12 d0				                .word nt_asm_lda_x
>d009	cb aa d0 aa					.word xt_asm_lda_h, z_asm_lda_h
>d00d	6c 64 61 2e 23					.text "lda.#"
.d012					nt_asm_lda_x:
>d012	05 0c						.byte 5, IM+NN
>d014	1f d0				                .word nt_asm_lda_y
>d016	d0 aa d5 aa					.word xt_asm_lda_x, z_asm_lda_x
>d01a	6c 64 61 2e 78					.text "lda.x"
.d01f					nt_asm_lda_y:
>d01f	05 0c						.byte 5, IM+NN
>d021	2c d0				                .word nt_asm_lda_z
>d023	d5 aa da aa					.word xt_asm_lda_y, z_asm_lda_y
>d027	6c 64 61 2e 79					.text "lda.y"
.d02c					nt_asm_lda_z:
>d02c	05 0c						.byte 5, IM+NN
>d02e	39 d0				                .word nt_asm_lda_zi
>d030	da aa df aa					.word xt_asm_lda_z, z_asm_lda_z
>d034	6c 64 61 2e 7a					.text "lda.z"
.d039					nt_asm_lda_zi:
>d039	06 0c						.byte 6, IM+NN
>d03b	47 d0				                .word nt_asm_lda_ziy
>d03d	df aa e4 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>d041	6c 64 61 2e 7a 69				.text "lda.zi"
.d047					nt_asm_lda_ziy:
>d047	07 0c						.byte 7, IM+NN
>d049	56 d0				                .word nt_asm_lda_zx
>d04b	e4 aa e9 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>d04f	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.d056					nt_asm_lda_zx:
>d056	06 0c						.byte 6, IM+NN
>d058	64 d0				                .word nt_asm_lda_zxi
>d05a	e9 aa ee aa					.word xt_asm_lda_zx, z_asm_lda_zx
>d05e	6c 64 61 2e 7a 78				.text "lda.zx"
.d064					nt_asm_lda_zxi:
>d064	07 0c						.byte 7, IM+NN
>d066	73 d0				                .word nt_asm_ldx
>d068	ee aa f3 aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>d06c	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.d073					nt_asm_ldx:
>d073	03 0c						.byte 3, IM+NN
>d075	7e d0				                .word nt_asm_ldx_h
>d077	f3 aa f8 aa					.word xt_asm_ldx, z_asm_ldx
>d07b	6c 64 78					.text "ldx"
.d07e					nt_asm_ldx_h:
>d07e	05 0c						.byte 5, IM+NN
>d080	8b d0				                .word nt_asm_ldx_y
>d082	f8 aa fd aa					.word xt_asm_ldx_h, z_asm_ldx_h
>d086	6c 64 78 2e 23					.text "ldx.#"
.d08b					nt_asm_ldx_y:
>d08b	05 0c						.byte 5, IM+NN
>d08d	98 d0				                .word nt_asm_ldx_z
>d08f	fd aa 02 ab					.word xt_asm_ldx_y, z_asm_ldx_y
>d093	6c 64 78 2e 79					.text "ldx.y"
.d098					nt_asm_ldx_z:
>d098	05 0c						.byte 5, IM+NN
>d09a	a5 d0				                .word nt_asm_ldx_zy
>d09c	02 ab 07 ab					.word xt_asm_ldx_z, z_asm_ldx_z
>d0a0	6c 64 78 2e 7a					.text "ldx.z"
.d0a5					nt_asm_ldx_zy:
>d0a5	06 0c						.byte 6, IM+NN
>d0a7	b3 d0				                .word nt_asm_ldy
>d0a9	07 ab 0c ab					.word xt_asm_ldx_zy, z_asm_ldx_zy
>d0ad	6c 64 78 2e 7a 79				.text "ldx.zy"
.d0b3					nt_asm_ldy:
>d0b3	03 0c						.byte 3, IM+NN
>d0b5	be d0				                .word nt_asm_ldy_h
>d0b7	0c ab 11 ab					.word xt_asm_ldy, z_asm_ldy
>d0bb	6c 64 79					.text "ldy"
.d0be					nt_asm_ldy_h:
>d0be	05 0c						.byte 5, IM+NN
>d0c0	cb d0				                .word nt_asm_ldy_x
>d0c2	11 ab 16 ab					.word xt_asm_ldy_h, z_asm_ldy_h
>d0c6	6c 64 79 2e 23					.text "ldy.#"
.d0cb					nt_asm_ldy_x:
>d0cb	05 0c						.byte 5, IM+NN
>d0cd	d8 d0				                .word nt_asm_ldy_z
>d0cf	16 ab 1b ab					.word xt_asm_ldy_x, z_asm_ldy_x
>d0d3	6c 64 79 2e 78					.text "ldy.x"
.d0d8					nt_asm_ldy_z:
>d0d8	05 0c						.byte 5, IM+NN
>d0da	e5 d0				                .word nt_asm_ldy_zx
>d0dc	1b ab 20 ab					.word xt_asm_ldy_z, z_asm_ldy_z
>d0e0	6c 64 79 2e 7a					.text "ldy.z"
.d0e5					nt_asm_ldy_zx:
>d0e5	06 0c						.byte 6, IM+NN
>d0e7	f3 d0				                .word nt_asm_lsr
>d0e9	20 ab 25 ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>d0ed	6c 64 79 2e 7a 78				.text "ldy.zx"
.d0f3					nt_asm_lsr:
>d0f3	03 0c						.byte 3, IM+NN
>d0f5	fe d0				                .word nt_asm_lsr_a
>d0f7	25 ab 2a ab					.word xt_asm_lsr, z_asm_lsr
>d0fb	6c 73 72					.text "lsr"
.d0fe					nt_asm_lsr_a:
>d0fe	05 0c						.byte 5, IM+NN
>d100	0b d1				                .word nt_asm_lsr_x
>d102	2a ab 2f ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d106	6c 73 72 2e 61					.text "lsr.a"
.d10b					nt_asm_lsr_x:
>d10b	05 0c						.byte 5, IM+NN
>d10d	18 d1				                .word nt_asm_lsr_z
>d10f	2f ab 34 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d113	6c 73 72 2e 78					.text "lsr.x"
.d118					nt_asm_lsr_z:
>d118	05 0c						.byte 5, IM+NN
>d11a	25 d1				                .word nt_asm_lsr_zx
>d11c	34 ab 39 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d120	6c 73 72 2e 7a					.text "lsr.z"
.d125					nt_asm_lsr_zx:
>d125	06 0c						.byte 6, IM+NN
>d127	33 d1				                .word nt_asm_nop
>d129	39 ab 3e ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d12d	6c 73 72 2e 7a 78				.text "lsr.zx"
.d133					nt_asm_nop:
>d133	03 0c						.byte 3, IM+NN
>d135	3e d1				                .word nt_asm_ora
>d137	3e ab 43 ab					.word xt_asm_nop, z_asm_nop
>d13b	6e 6f 70					.text "nop"
.d13e					nt_asm_ora:
>d13e	03 0c						.byte 3, IM+NN
>d140	49 d1				                .word nt_asm_ora_h
>d142	43 ab 48 ab					.word xt_asm_ora, z_asm_ora
>d146	6f 72 61					.text "ora"
.d149					nt_asm_ora_h:
>d149	05 0c						.byte 5, IM+NN
>d14b	56 d1				                .word nt_asm_ora_x
>d14d	48 ab 4d ab					.word xt_asm_ora_h, z_asm_ora_h
>d151	6f 72 61 2e 23					.text "ora.#"
.d156					nt_asm_ora_x:
>d156	05 0c						.byte 5, IM+NN
>d158	63 d1				                .word nt_asm_ora_y
>d15a	4d ab 52 ab					.word xt_asm_ora_x, z_asm_ora_x
>d15e	6f 72 61 2e 78					.text "ora.x"
.d163					nt_asm_ora_y:
>d163	05 0c						.byte 5, IM+NN
>d165	70 d1				                .word nt_asm_ora_z
>d167	52 ab 57 ab					.word xt_asm_ora_y, z_asm_ora_y
>d16b	6f 72 61 2e 79					.text "ora.y"
.d170					nt_asm_ora_z:
>d170	05 0c						.byte 5, IM+NN
>d172	7d d1				                .word nt_asm_ora_zi
>d174	57 ab 5c ab					.word xt_asm_ora_z, z_asm_ora_z
>d178	6f 72 61 2e 7a					.text "ora.z"
.d17d					nt_asm_ora_zi:
>d17d	06 0c						.byte 6, IM+NN
>d17f	8b d1				                .word nt_asm_ora_ziy
>d181	5c ab 63 ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d185	6f 72 61 2e 7a 69				.text "ora.zi"
.d18b					nt_asm_ora_ziy:
>d18b	07 0c						.byte 7, IM+NN
>d18d	9a d1				                .word nt_asm_ora_zx
>d18f	63 ab 68 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d193	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d19a					nt_asm_ora_zx:
>d19a	06 0c						.byte 6, IM+NN
>d19c	a8 d1				                .word nt_asm_ora_zxi
>d19e	68 ab 6d ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d1a2	6f 72 61 2e 7a 78				.text "ora.zx"
.d1a8					nt_asm_ora_zxi:
>d1a8	07 0c						.byte 7, IM+NN
>d1aa	b7 d1				                .word nt_asm_pha
>d1ac	6d ab 72 ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d1b0	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d1b7					nt_asm_pha:
>d1b7	03 0c						.byte 3, IM+NN
>d1b9	c2 d1				                .word nt_asm_php
>d1bb	72 ab 77 ab					.word xt_asm_pha, z_asm_pha
>d1bf	70 68 61					.text "pha"
.d1c2					nt_asm_php:
>d1c2	03 0c						.byte 3, IM+NN
>d1c4	cd d1				                .word nt_asm_phx
>d1c6	77 ab 7c ab					.word xt_asm_php, z_asm_php
>d1ca	70 68 70					.text "php"
.d1cd					nt_asm_phx:
>d1cd	03 0c						.byte 3, IM+NN
>d1cf	d8 d1				                .word nt_asm_phy
>d1d1	7c ab 81 ab					.word xt_asm_phx, z_asm_phx
>d1d5	70 68 78					.text "phx"
.d1d8					nt_asm_phy:
>d1d8	03 0c						.byte 3, IM+NN
>d1da	e3 d1				                .word nt_asm_pla
>d1dc	81 ab 86 ab					.word xt_asm_phy, z_asm_phy
>d1e0	70 68 79					.text "phy"
.d1e3					nt_asm_pla:
>d1e3	03 0c						.byte 3, IM+NN
>d1e5	ee d1				                .word nt_asm_plp
>d1e7	86 ab 8b ab					.word xt_asm_pla, z_asm_pla
>d1eb	70 6c 61					.text "pla"
.d1ee					nt_asm_plp:
>d1ee	03 0c						.byte 3, IM+NN
>d1f0	f9 d1				                .word nt_asm_plx
>d1f2	8b ab 90 ab					.word xt_asm_plp, z_asm_plp
>d1f6	70 6c 70					.text "plp"
.d1f9					nt_asm_plx:
>d1f9	03 0c						.byte 3, IM+NN
>d1fb	04 d2				                .word nt_asm_ply
>d1fd	90 ab 95 ab					.word xt_asm_plx, z_asm_plx
>d201	70 6c 78					.text "plx"
.d204					nt_asm_ply:
>d204	03 0c						.byte 3, IM+NN
>d206	0f d2				                .word nt_asm_rol
>d208	95 ab 9a ab					.word xt_asm_ply, z_asm_ply
>d20c	70 6c 79					.text "ply"
.d20f					nt_asm_rol:
>d20f	03 0c						.byte 3, IM+NN
>d211	1a d2				                .word nt_asm_rol_a
>d213	9a ab 9f ab					.word xt_asm_rol, z_asm_rol
>d217	72 6f 6c					.text "rol"
.d21a					nt_asm_rol_a:
>d21a	05 0c						.byte 5, IM+NN
>d21c	27 d2				                .word nt_asm_rol_x
>d21e	9f ab a4 ab					.word xt_asm_rol_a, z_asm_rol_a
>d222	72 6f 6c 2e 61					.text "rol.a"
.d227					nt_asm_rol_x:
>d227	05 0c						.byte 5, IM+NN
>d229	34 d2				                .word nt_asm_rol_z
>d22b	a4 ab a9 ab					.word xt_asm_rol_x, z_asm_rol_x
>d22f	72 6f 6c 2e 78					.text "rol.x"
.d234					nt_asm_rol_z:
>d234	05 0c						.byte 5, IM+NN
>d236	41 d2				                .word nt_asm_rol_zx
>d238	a9 ab ae ab					.word xt_asm_rol_z, z_asm_rol_z
>d23c	72 6f 6c 2e 7a					.text "rol.z"
.d241					nt_asm_rol_zx:
>d241	06 0c						.byte 6, IM+NN
>d243	4f d2				                .word nt_asm_ror
>d245	ae ab b3 ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d249	72 6f 6c 2e 7a 78				.text "rol.zx"
.d24f					nt_asm_ror:
>d24f	03 0c						.byte 3, IM+NN
>d251	5a d2				                .word nt_asm_ror_a
>d253	b3 ab b8 ab					.word xt_asm_ror, z_asm_ror
>d257	72 6f 72					.text "ror"
.d25a					nt_asm_ror_a:
>d25a	05 0c						.byte 5, IM+NN
>d25c	67 d2				                .word nt_asm_ror_x
>d25e	b8 ab bd ab					.word xt_asm_ror_a, z_asm_ror_a
>d262	72 6f 72 2e 61					.text "ror.a"
.d267					nt_asm_ror_x:
>d267	05 0c						.byte 5, IM+NN
>d269	74 d2				                .word nt_asm_ror_z
>d26b	bd ab c2 ab					.word xt_asm_ror_x, z_asm_ror_x
>d26f	72 6f 72 2e 78					.text "ror.x"
.d274					nt_asm_ror_z:
>d274	05 0c						.byte 5, IM+NN
>d276	81 d2				                .word nt_asm_ror_zx
>d278	c2 ab c7 ab					.word xt_asm_ror_z, z_asm_ror_z
>d27c	72 6f 72 2e 7a					.text "ror.z"
.d281					nt_asm_ror_zx:
>d281	06 0c						.byte 6, IM+NN
>d283	8f d2				                .word nt_asm_rti
>d285	c7 ab cc ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d289	72 6f 72 2e 7a 78				.text "ror.zx"
.d28f					nt_asm_rti:
>d28f	03 0c						.byte 3, IM+NN
>d291	9a d2				                .word nt_asm_rts
>d293	cc ab d1 ab					.word xt_asm_rti, z_asm_rti
>d297	72 74 69					.text "rti"
.d29a					nt_asm_rts:
>d29a	03 0c						.byte 3, IM+NN
>d29c	a5 d2				                .word nt_asm_sbc
>d29e	d1 ab d6 ab					.word xt_asm_rts, z_asm_rts
>d2a2	72 74 73					.text "rts"
.d2a5					nt_asm_sbc:
>d2a5	03 0c						.byte 3, IM+NN
>d2a7	b0 d2				                .word nt_asm_sbc_h
>d2a9	d6 ab db ab					.word xt_asm_sbc, z_asm_sbc
>d2ad	73 62 63					.text "sbc"
.d2b0					nt_asm_sbc_h:
>d2b0	05 0c						.byte 5, IM+NN
>d2b2	bd d2				                .word nt_asm_sbc_x
>d2b4	db ab e0 ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d2b8	73 62 63 2e 23					.text "sbc.#"
.d2bd					nt_asm_sbc_x:
>d2bd	05 0c						.byte 5, IM+NN
>d2bf	ca d2				                .word nt_asm_sbc_y
>d2c1	e0 ab e5 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d2c5	73 62 63 2e 78					.text "sbc.x"
.d2ca					nt_asm_sbc_y:
>d2ca	05 0c						.byte 5, IM+NN
>d2cc	d7 d2				                .word nt_asm_sbc_z
>d2ce	e5 ab ea ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d2d2	73 62 63 2e 79					.text "sbc.y"
.d2d7					nt_asm_sbc_z:
>d2d7	05 0c						.byte 5, IM+NN
>d2d9	e4 d2				                .word nt_asm_sbc_zi
>d2db	ea ab ef ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d2df	73 62 63 2e 7a					.text "sbc.z"
.d2e4					nt_asm_sbc_zi:
>d2e4	06 0c						.byte 6, IM+NN
>d2e6	f2 d2				                .word nt_asm_sbc_ziy
>d2e8	ef ab f4 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d2ec	73 62 63 2e 7a 69				.text "sbc.zi"
.d2f2					nt_asm_sbc_ziy:
>d2f2	07 0c						.byte 7, IM+NN
>d2f4	01 d3				                .word nt_asm_sbc_zx
>d2f6	f4 ab f9 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d2fa	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d301					nt_asm_sbc_zx:
>d301	06 0c						.byte 6, IM+NN
>d303	0f d3				                .word nt_asm_sbc_zxi
>d305	f9 ab fe ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d309	73 62 63 2e 7a 78				.text "sbc.zx"
.d30f					nt_asm_sbc_zxi:
>d30f	07 0c						.byte 7, IM+NN
>d311	1e d3				                .word nt_asm_sec
>d313	fe ab 02 ac					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d317	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d31e					nt_asm_sec:
>d31e	03 0c						.byte 3, IM+NN
>d320	29 d3				                .word nt_asm_sed
>d322	02 ac 06 ac					.word xt_asm_sec, z_asm_sec
>d326	73 65 63					.text "sec"
.d329					nt_asm_sed:
>d329	03 0c						.byte 3, IM+NN
>d32b	34 d3				                .word nt_asm_sei
>d32d	06 ac 0a ac					.word xt_asm_sed, z_asm_sed
>d331	73 65 64					.text "sed"
.d334					nt_asm_sei:
>d334	03 0c						.byte 3, IM+NN
>d336	3f d3				                .word nt_asm_sta
>d338	0a ac 0e ac					.word xt_asm_sei, z_asm_sei
>d33c	73 65 69					.text "sei"
.d33f					nt_asm_sta:
>d33f	03 0c						.byte 3, IM+NN
>d341	4a d3				                .word nt_asm_sta_x
>d343	0e ac 12 ac					.word xt_asm_sta, z_asm_sta
>d347	73 74 61					.text "sta"
.d34a					nt_asm_sta_x:
>d34a	05 0c						.byte 5, IM+NN
>d34c	57 d3				                .word nt_asm_sta_y
>d34e	12 ac 16 ac					.word xt_asm_sta_x, z_asm_sta_x
>d352	73 74 61 2e 78					.text "sta.x"
.d357					nt_asm_sta_y:
>d357	05 0c						.byte 5, IM+NN
>d359	64 d3				                .word nt_asm_sta_z
>d35b	16 ac 1a ac					.word xt_asm_sta_y, z_asm_sta_y
>d35f	73 74 61 2e 79					.text "sta.y"
.d364					nt_asm_sta_z:
>d364	05 0c						.byte 5, IM+NN
>d366	71 d3				                .word nt_asm_sta_zi
>d368	1a ac 1e ac					.word xt_asm_sta_z, z_asm_sta_z
>d36c	73 74 61 2e 7a					.text "sta.z"
.d371					nt_asm_sta_zi:
>d371	06 0c						.byte 6, IM+NN
>d373	7f d3				                .word nt_asm_sta_ziy
>d375	1e ac 22 ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d379	73 74 61 2e 7a 69				.text "sta.zi"
.d37f					nt_asm_sta_ziy:
>d37f	07 0c						.byte 7, IM+NN
>d381	8e d3				                .word nt_asm_sta_zx
>d383	22 ac 26 ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d387	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d38e					nt_asm_sta_zx:
>d38e	06 0c						.byte 6, IM+NN
>d390	9c d3				                .word nt_asm_sta_zxi
>d392	26 ac 2a ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d396	73 74 61 2e 7a 78				.text "sta.zx"
.d39c					nt_asm_sta_zxi:
>d39c	07 0c						.byte 7, IM+NN
>d39e	ab d3				                .word nt_asm_stx
>d3a0	2a ac 2e ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d3a4	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d3ab					nt_asm_stx:
>d3ab	03 0c						.byte 3, IM+NN
>d3ad	b6 d3				                .word nt_asm_stx_z
>d3af	2e ac 32 ac					.word xt_asm_stx, z_asm_stx
>d3b3	73 74 78					.text "stx"
.d3b6					nt_asm_stx_z:
>d3b6	05 0c						.byte 5, IM+NN
>d3b8	c3 d3				                .word nt_asm_stx_zy
>d3ba	32 ac 36 ac					.word xt_asm_stx_z, z_asm_stx_z
>d3be	73 74 78 2e 7a					.text "stx.z"
.d3c3					nt_asm_stx_zy:
>d3c3	06 0c						.byte 6, IM+NN
>d3c5	d1 d3				                .word nt_asm_sty
>d3c7	36 ac 3a ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d3cb	73 74 78 2e 7a 79				.text "stx.zy"
.d3d1					nt_asm_sty:
>d3d1	03 0c						.byte 3, IM+NN
>d3d3	dc d3				                .word nt_asm_sty_z
>d3d5	3a ac 3e ac					.word xt_asm_sty, z_asm_sty
>d3d9	73 74 79					.text "sty"
.d3dc					nt_asm_sty_z:
>d3dc	05 0c						.byte 5, IM+NN
>d3de	e9 d3				                .word nt_asm_sty_zx
>d3e0	3e ac 42 ac					.word xt_asm_sty_z, z_asm_sty_z
>d3e4	73 74 79 2e 7a					.text "sty.z"
.d3e9					nt_asm_sty_zx:
>d3e9	06 0c						.byte 6, IM+NN
>d3eb	f7 d3				                .word nt_asm_stz
>d3ed	42 ac 46 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d3f1	73 74 79 2e 7a 78				.text "sty.zx"
.d3f7					nt_asm_stz:
>d3f7	03 0c						.byte 3, IM+NN
>d3f9	02 d4				                .word nt_asm_stz_x
>d3fb	46 ac 4a ac					.word xt_asm_stz, z_asm_stz
>d3ff	73 74 7a					.text "stz"
.d402					nt_asm_stz_x:
>d402	05 0c						.byte 5, IM+NN
>d404	0f d4				                .word nt_asm_stz_z
>d406	4a ac 4e ac					.word xt_asm_stz_x, z_asm_stz_x
>d40a	73 74 7a 2e 78					.text "stz.x"
.d40f					nt_asm_stz_z:
>d40f	05 0c						.byte 5, IM+NN
>d411	1c d4				                .word nt_asm_stz_zx
>d413	4e ac 52 ac					.word xt_asm_stz_z, z_asm_stz_z
>d417	73 74 7a 2e 7a					.text "stz.z"
.d41c					nt_asm_stz_zx:
>d41c	06 0c						.byte 6, IM+NN
>d41e	2a d4				                .word nt_asm_tax
>d420	52 ac 56 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d424	73 74 7a 2e 7a 78				.text "stz.zx"
.d42a					nt_asm_tax:
>d42a	03 0c						.byte 3, IM+NN
>d42c	35 d4				                .word nt_asm_tay
>d42e	56 ac 5a ac					.word xt_asm_tax, z_asm_tax
>d432	74 61 78					.text "tax"
.d435					nt_asm_tay:
>d435	03 0c						.byte 3, IM+NN
>d437	40 d4				                .word nt_asm_trb
>d439	5a ac 5e ac					.word xt_asm_tay, z_asm_tay
>d43d	74 61 79					.text "tay"
.d440					nt_asm_trb:
>d440	03 0c						.byte 3, IM+NN
>d442	4b d4				                .word nt_asm_trb_z
>d444	5e ac 62 ac					.word xt_asm_trb, z_asm_trb
>d448	74 72 62					.text "trb"
.d44b					nt_asm_trb_z:
>d44b	05 0c						.byte 5, IM+NN
>d44d	58 d4				                .word nt_asm_tsb
>d44f	62 ac 66 ac					.word xt_asm_trb_z, z_asm_trb_z
>d453	74 72 62 2e 7a					.text "trb.z"
.d458					nt_asm_tsb:
>d458	03 0c						.byte 3, IM+NN
>d45a	63 d4				                .word nt_asm_tsb_z
>d45c	66 ac 6a ac					.word xt_asm_tsb, z_asm_tsb
>d460	74 73 62					.text "tsb"
.d463					nt_asm_tsb_z:
>d463	05 0c						.byte 5, IM+NN
>d465	70 d4				                .word nt_asm_tsx
>d467	6a ac 6e ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d46b	74 73 62 2e 7a					.text "tsb.z"
.d470					nt_asm_tsx:
>d470	03 0c						.byte 3, IM+NN
>d472	7b d4				                .word nt_asm_txa
>d474	6e ac 72 ac					.word xt_asm_tsx, z_asm_tsx
>d478	74 73 78					.text "tsx"
.d47b					nt_asm_txa:
>d47b	03 0c						.byte 3, IM+NN
>d47d	86 d4				                .word nt_asm_txs
>d47f	72 ac 76 ac					.word xt_asm_txa, z_asm_txa
>d483	74 78 61					.text "txa"
.d486					nt_asm_txs:
>d486	03 0c						.byte 3, IM+NN
>d488	91 d4				                .word nt_asm_tya
>d48a	76 ac 7a ac					.word xt_asm_txs, z_asm_txs
>d48e	74 78 73					.text "txs"
.d491					nt_asm_tya:
>d491	03 0c						.byte 3, IM+NN
>d493	9c d4				                .word nt_asm_arrow
>d495	7a ac 7e ac					.word xt_asm_tya, z_asm_tya
>d499	74 79 61					.text "tya"
.d49c					nt_asm_arrow:
>d49c	03 04				                .byte 3, IM
>d49e	a7 d4				                .word nt_asm_back_jump
>d4a0	8e 91 98 91			                .word xt_asm_arrow, z_asm_arrow
>d4a4	2d 2d 3e			                .text "-->"
.d4a7					nt_asm_back_jump:
>d4a7	02 04				                .byte 2, IM
>d4a9	b1 d4				                .word nt_asm_back_branch
>d4ab	cf ac cf ac			                .word xt_asm_back_jump, z_asm_back_jump
>d4af	3c 6a				                .text "<j"
.d4b1					nt_asm_back_branch:
>d4b1	02 04				                .byte 2, IM
>d4b3	bb d4				                .word nt_asm_push_a
>d4b5	d0 ac d8 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d4b9	3c 62				                .text "<b"
.d4bb					nt_asm_push_a:
>d4bb	06 0c				                .byte 6, IM+NN
>d4bd	00 00				                .word 0000
>d4bf	b8 ac c7 ac			                .word xt_asm_push_a, z_asm_push_a
>d4c3	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					ix := 0
=0					str_ok             = ix
=1					ix += 1
=1					str_compile        = ix
=2					ix += 1
=2					str_redefined      = ix
=3					ix += 1
=3					str_abc_upper      = ix
=4					ix += 1
=4					str_wid_forth      = ix
=5					ix += 1
=5					str_wid_editor     = ix
=6					ix += 1
=6					str_wid_assembler  = ix
=7					ix += 1
=7					str_wid_root       = ix
=8					ix += 1
=8					str_see_flags      = ix
=9					ix += 1
=9					str_see_nt         = ix
=10					ix += 1
=10					str_see_xt         = ix
=11					ix += 1
=11					str_see_size       = ix
=12					ix += 1
=12					str_disasm_lit     = ix
=13					ix += 1
=13					str_disasm_sdc     = ix
=14					ix += 1
=14					str_disasm_bra     = ix
=15					ix += 1
.d4c9					string_table:
>d4c9	e7 d4 eb d4 f5 d4 00 d5		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d4d1	37 d5 2f d5 24 d5 3e d5		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d4d9	44 d5 60 d5 65 d5 6a d5		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d4e1	7b d5 84 d5 96 d5		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 12-14
>d4e7	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d4eb	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d4f3	64 00
>d4f5	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d4fd	64 20 00
>d500	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d508	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d518	4f 50 51 52 53 54 55 56 57 58 59 5a
>d524	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d52c	72 20 00
>d52f	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d537	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d53e	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d544	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d54c	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d55c	29 3a 20 00
>d560	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d565	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d56a	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d572	63 69 6d 61 6c 29 3a 20 00
>d57b	4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d583	00
>d584	53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d58c	50 54 48 20 43 48 45 43 4b 00
>d596	42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
=13					err_returnstack  = 13
.d59e					error_table:
>d59e	ba d5 db d5 fb d5 1c d6		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d5a6	39 d6 4a d6 5a d6 88 d6		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d5ae	a0 d6 af d6 c4 d6 e0 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d5b6	f7 d6 36 d7			        .word es_blockwords, es_returnstack                     ; 12-13
>d5ba	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d5c2	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d5d2	65 20 6d 65 6d 6f 72 79 00
>d5db	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d5e3	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d5f3	20 52 45 46 49 4c 4c 00
>d5fb	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d603	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d613	6e 6c 79 20 77 6f 72 64 00
>d61c	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d624	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d634	20 79 65 74 00
>d639	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d641	20 62 79 20 7a 65 72 6f 00
>d64a	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d652	66 61 69 6c 75 72 65 00
>d65a	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d662	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d672	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d682	64 20 2d 31 29 00
>d688	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d690	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d6a0	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word", 0
>d6a8	64 20 77 6f 72 64 00
>d6af	44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d6b7	63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d6c4	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d6cc	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d6dc	4c 4f 54 00
>d6e0	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d6e8	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d6f7	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d6ff	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d70f	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d71f	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d72f	56 45 43 54 4f 52 00
>d736	52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d73e	74 61 63 6b 3a 00
>d744	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d74c	44 2d 53 54 52 49 4e 47
>d754	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d75a	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d75f	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d767	2d 55 4e 49 54 2d 42 49 54 53
>d771	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d779	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d781	52
>d782	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d788	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d78e	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d796	53 54 41 43 4b 2d 43 45 4c 4c 53
>d7a1	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d7a9	45 4c 4c 53
>d7ad	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d7b5	54 53
>d7b7	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d7bd	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d7c4					cmpl_subroutine:
.d7c4	48		pha		                pha             ; save LSB of address
.d7c5	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d7c7	80 03		bra $d7cc	                bra cmpl_common
.d7c9					cmpl_jump:
.d7c9	48		pha		                pha             ; save LSB of address
.d7ca	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d7cc					cmpl_common:
.d7cc	20 d4 d7	jsr $d7d4	                jsr cmpl_a      ; compile opcode
.d7cf	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d7d0					cmpl_word:
.d7d0	20 d4 d7	jsr $d7d4	                jsr cmpl_a      ; compile LSB of address
.d7d3	98		tya		                tya             ; fall thru for MSB
.d7d4					cmpl_a:
.d7d4	92 00		sta ($00)	                sta (cp)
.d7d6	e6 00		inc $00		                inc cp
.d7d8	d0 02		bne $d7dc	                bne _done
.d7da	e6 01		inc $01		                inc cp+1
.d7dc					_done:
.d7dc	60		rts		                rts
.d7dd					doconst:
.d7dd	ca		dex		                dex             ; make room for constant
.d7de	ca		dex		                dex
.d7df	68		pla		                pla             ; LSB of return address
.d7e0	85 24		sta $24		                sta tmp1
.d7e2	68		pla		                pla             ; MSB of return address
.d7e3	85 25		sta $25		                sta tmp1+1
.d7e5	a0 01		ldy #$01	                ldy #1
.d7e7	b1 24		lda ($24),y	                lda (tmp1),y
.d7e9	95 00		sta $00,x	                sta 0,x
.d7eb	c8		iny		                iny
.d7ec	b1 24		lda ($24),y	                lda (tmp1),y
.d7ee	95 01		sta $01,x	                sta 1,x
.d7f0	60		rts		                rts
.d7f1					dodefer:
.d7f1	68		pla		                pla             ; LSB
.d7f2	85 24		sta $24		                sta tmp1
.d7f4	68		pla		                pla             ; MSB
.d7f5	85 25		sta $25		                sta tmp1+1
.d7f7	a0 01		ldy #$01	                ldy #1
.d7f9	b1 24		lda ($24),y	                lda (tmp1),y
.d7fb	85 26		sta $26		                sta tmp2
.d7fd	c8		iny		                iny
.d7fe	b1 24		lda ($24),y	                lda (tmp1),y
.d800	85 27		sta $27		                sta tmp2+1
.d802	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d805					defer_error:
.d805	a9 03		lda #$03	                lda #err_defer
.d807	4c 44 d9	jmp $d944	                jmp error
.d80a					dodoes:
.d80a	7a		ply		                ply             ; LSB
.d80b	68		pla		                pla             ; MSB
.d80c	c8		iny		                iny
.d80d	d0 01		bne $d810	                bne +
.d80f	1a		inc a		                ina
.d810					+
.d810	84 26		sty $26		                sty tmp2
.d812	85 27		sta $27		                sta tmp2+1
.d814	ca		dex		                dex
.d815	ca		dex		                dex
.d816	7a		ply		                ply
.d817	68		pla		                pla
.d818	c8		iny		                iny
.d819	d0 01		bne $d81c	                bne +
.d81b	1a		inc a		                ina
.d81c					+
.d81c	94 00		sty $00,x	                sty 0,x         ; LSB
.d81e	95 01		sta $01,x	                sta 1,x         ; MSB
.d820	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d823					dovar:
.d823	7a		ply		                ply             ; LSB
.d824	68		pla		                pla             ; MSB
.d825	c8		iny		                iny
.d826	d0 01		bne $d829	                bne +
.d828	1a		inc a		                ina
.d829					+
.d829	ca		dex		                dex
.d82a	ca		dex		                dex
.d82b	95 01		sta $01,x	                sta 1,x
.d82d	98		tya		                tya
.d82e	95 00		sta $00,x	                sta 0,x
.d830	60		rts		                rts
.d831					byte_to_ascii:
.d831	48		pha		                pha
.d832	4a		lsr a		                lsr             ; convert high nibble first
.d833	4a		lsr a		                lsr
.d834	4a		lsr a		                lsr
.d835	4a		lsr a		                lsr
.d836	20 3a d8	jsr $d83a	                jsr _nibble_to_ascii
.d839	68		pla		                pla
.d83a					_nibble_to_ascii:
.d83a	29 0f		and #$0f	                and #$0F
.d83c	09 30		ora #$30	                ora #'0'
.d83e	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d840	90 02		bcc $d844	                bcc +
.d842	69 06		adc #$06	                adc #$06
.d844	4c 12 8e	jmp $8e12	+               jmp emit_a
.d847	60		rts		                rts
.d848					compare_16bit:
.d848	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d84a	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d84c	f0 0a		beq $d858	                beq _equal
.d84e	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d850	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d852	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d854	70 08		bvs $d85e	                bvs _overflow
.d856	80 08		bra $d860	                bra _not_equal
.d858					_equal:
.d858	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d85a	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d85c	50 04		bvc $d862	                bvc _done
.d85e					_overflow:
.d85e	49 80		eor #$80	                eor #$80                ; complement negative flag
.d860					_not_equal:
.d860	09 01		ora #$01	                ora #1                  ; if overflow, we can't be eqal
.d862					_done:
.d862	60		rts		                rts
.d863					current_to_dp:
.d863	a0 04		ldy #$04	                ldy #current_offset
.d865	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d867	0a		asl a		                asl             ; turn it into an offset (in cells)
.d868	18		clc		                clc
.d869	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d86b	a8		tay		                tay
.d86c	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d86e	85 02		sta $02		                sta dp
.d870	c8		iny		                iny
.d871	b1 1e		lda ($1e),y	                lda (up),y
.d873	85 03		sta $03		                sta dp+1
.d875	60		rts		                rts
.d876					dp_to_current:
.d876	a0 04		ldy #$04	                ldy #current_offset
.d878	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d87a	0a		asl a		                asl             ; turn it into an offset (in cells)
.d87b	18		clc		                clc
.d87c	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d87e	a8		tay		                tay
.d87f	a5 02		lda $02		                lda dp
.d881	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d883	c8		iny		                iny
.d884	a5 03		lda $03		                lda dp+1
.d886	91 1e		sta ($1e),y	                sta (up),y
.d888	60		rts		                rts
.d889					interpret:
.d889					_loop:
.d889	20 10 99	jsr $9910	                jsr xt_parse_name       ; ( "string" -- addr u )
.d88c	b5 00		lda $00,x	                lda 0,x
.d88e	15 01		ora $01,x	                ora 1,x
.d890	f0 7d		beq $d90f	                beq _line_done
.d892	20 ba a3	jsr $a3ba	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d895	20 f7 8f	jsr $8ff7	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d898	b5 00		lda $00,x	                lda 0,x
.d89a	15 01		ora $01,x	                ora 1,x
.d89c	d0 35		bne $d8d3	                bne _got_name_token
.d89e	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d89f	e8		inx		                inx
.d8a0	20 bb 96	jsr $96bb	                jsr xt_number           ; ( addr u -- u|d )
.d8a3	a5 16		lda $16		                lda state
.d8a5	f0 e2		beq $d889	                beq _loop
.d8a7	a9 20		lda #$20	                lda #$20
.d8a9	24 20		bit $20		                bit status
.d8ab	f0 06		beq $d8b3	                beq _single_number
.d8ad	20 b0 a1	jsr $a1b0	                jsr xt_swap
.d8b0	20 b8 d8	jsr $d8b8	                jsr _add_lit
.d8b3					_single_number:
.d8b3	20 b8 d8	jsr $d8b8	                jsr _add_lit
.d8b6	80 d1		bra $d889	                bra _loop
.d8b8	b5 01		lda $01,x	_add_lit:       lda 1,x
.d8ba	f0 06		beq $d8c2	                beq _byte_rt
.d8bc	a0 93		ldy #$93	                ldy #>literal_runtime
.d8be	a9 b4		lda #$b4	                lda #<literal_runtime
.d8c0	80 04		bra $d8c6	                bra _cmpl_rt
.d8c2	a0 93		ldy #$93	_byte_rt:       ldy #>byte_runtime
.d8c4	a9 d3		lda #$d3	                lda #<byte_runtime
.d8c6	20 c4 d7	jsr $d7c4	_cmpl_rt:       jsr cmpl_subroutine
.d8c9	b5 01		lda $01,x	                lda 1,x
.d8cb	f0 03		beq $d8d0	                beq _c_comma
.d8cd	4c 8a 87	jmp $878a	                jmp xt_comma
.d8d0	4c 1c 86	jmp $861c	_c_comma:       jmp xt_c_comma
.d8d3					_got_name_token:
.d8d3	b5 00		lda $00,x	                lda 0,x
.d8d5	95 04		sta $04,x	                sta 4,x
.d8d7	b5 01		lda $01,x	                lda 1,x
.d8d9	95 05		sta $05,x	                sta 5,x
.d8db	e8		inx		                inx
.d8dc	e8		inx		                inx
.d8dd	e8		inx		                inx
.d8de	e8		inx		                inx                     ; ( nt )
.d8df	b5 00		lda $00,x	                lda 0,x
.d8e1	85 22		sta $22		                sta tmpbranch
.d8e3	b5 01		lda $01,x	                lda 1,x
.d8e5	85 23		sta $23		                sta tmpbranch+1
.d8e7	20 12 96	jsr $9612	                jsr xt_name_to_int      ; ( nt - xt )
.d8ea	a5 16		lda $16		                lda state
.d8ec	d0 13		bne $d901	                bne _compile
.d8ee	a0 01		ldy #$01	                ldy #1
.d8f0	b1 22		lda ($22),y	                lda (tmpbranch),y
.d8f2	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d8f4	f0 05		beq $d8fb	                beq _interpret
.d8f6	a9 02		lda #$02	                lda #err_compileonly
.d8f8	4c 44 d9	jmp $d944	                jmp error
.d8fb					_interpret:
.d8fb	20 59 8f	jsr $8f59	                jsr xt_execute
.d8fe	4c 89 d8	jmp $d889	                jmp _loop
.d901					_compile:
.d901	a0 01		ldy #$01	                ldy #1
.d903	b1 22		lda ($22),y	                lda (tmpbranch),y
.d905	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d907	d0 f2		bne $d8fb	                bne _interpret          ; IMMEDIATE word, execute right now
.d909	20 09 88	jsr $8809	                jsr xt_compile_comma
.d90c	4c 89 d8	jmp $d889	                jmp _loop
.d90f					_line_done:
.d90f	e8		inx		                inx
.d910	e8		inx		                inx
.d911	e8		inx		                inx
.d912	e8		inx		                inx
.d913	60		rts		                rts
.d914					is_printable:
.d914	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d916	90 08		bcc $d920	                bcc _done
.d918	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d91a	b0 03		bcs $d91f	                bcs _failed
.d91c	38		sec		                sec
.d91d	80 01		bra $d920	                bra _done
.d91f					_failed:
.d91f	18		clc		                clc
.d920					_done:
.d920	60		rts		                rts
.d921					is_whitespace:
.d921	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d923	90 08		bcc $d92d	                bcc _done
.d925	c9 21		cmp #$21	                cmp #AscSP+1
.d927	b0 03		bcs $d92c	                bcs _failed
.d929	38		sec		                sec
.d92a	80 01		bra $d92d	                bra _done
.d92c					_failed:
.d92c	18		clc		                clc
.d92d					_done:
.d92d	60		rts		                rts
.d92e					underflow_1:
.d92e	e0 77		cpx #$77	                cpx #dsp0-1
.d930	10 10		bpl $d942	                bpl underflow_error
.d932	60		rts		                rts
.d933					underflow_2:
.d933	e0 75		cpx #$75	                cpx #dsp0-3
.d935	10 0b		bpl $d942	                bpl underflow_error
.d937	60		rts		                rts
.d938					underflow_3:
.d938	e0 73		cpx #$73	                cpx #dsp0-5
.d93a	10 06		bpl $d942	                bpl underflow_error
.d93c	60		rts		                rts
.d93d					underflow_4:
.d93d	e0 71		cpx #$71	                cpx #dsp0-7
.d93f	10 01		bpl $d942	                bpl underflow_error
.d941	60		rts		                rts
.d942					underflow_error:
.d942	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d944					error:
.d944	48		pha		                pha                     ; save error
.d945	20 84 d9	jsr $d984	                jsr print_error
.d948	20 7f 89	jsr $897f	                jsr xt_cr
.d94b	68		pla		                pla
.d94c	c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d94e	d0 17		bne $d967	                bne _no_underflow
.d950	a9 0d		lda #$0d	                lda #err_returnstack
.d952	20 84 d9	jsr $d984	                jsr print_error
.d955	ba		tsx		                tsx
.d956					-
.d956	e8		inx		                inx
.d957	f0 0b		beq $d964	                beq +
.d959	20 20 a1	jsr $a120	                jsr xt_space
.d95c	bd 00 01	lda $0100,x	                lda $100,x
.d95f	20 31 d8	jsr $d831	                jsr byte_to_ascii
.d962	80 f2		bra $d956	                bra -
.d964					+
.d964	20 7f 89	jsr $897f	                jsr xt_cr
.d967					_no_underflow:
.d967	4c 70 80	jmp $8070	                jmp xt_abort            ; no jsr, as we clobber return stack
.d96a					print_string_no_lf:
.d96a	0a		asl a		                asl
.d96b	a8		tay		                tay
.d96c	b9 c9 d4	lda $d4c9,y	                lda string_table,y
.d96f	85 28		sta $28		                sta tmp3                ; LSB
.d971	c8		iny		                iny
.d972	b9 c9 d4	lda $d4c9,y	                lda string_table,y
.d975	85 29		sta $29		                sta tmp3+1              ; MSB
.d977					print_common:
.d977	a0 00		ldy #$00	                ldy #0
.d979					_loop:
.d979	b1 28		lda ($28),y	                lda (tmp3),y
.d97b	f0 06		beq $d983	                beq _done               ; strings are zero-terminated
.d97d	20 12 8e	jsr $8e12	                jsr emit_a              ; allows vectoring via output
.d980	c8		iny		                iny
.d981	80 f6		bra $d979	                bra _loop
.d983					_done:
.d983	60		rts		                rts
.d984					print_error:
.d984	0a		asl a		                asl
.d985	a8		tay		                tay
.d986	b9 9e d5	lda $d59e,y	                lda error_table,y
.d989	85 28		sta $28		                sta tmp3                ; LSB
.d98b	c8		iny		                iny
.d98c	b9 9e d5	lda $d59e,y	                lda error_table,y
.d98f	85 29		sta $29		                sta tmp3+1              ; MSB
.d991	20 77 d9	jsr $d977	                jsr print_common
.d994	60		rts		                rts
.d995					print_string:
.d995	20 6a d9	jsr $d96a	                jsr print_string_no_lf
.d998	4c 7f 89	jmp $897f	                jmp xt_cr               ; JSR/RTS because never compiled
.d99b					print_u:
.d99b	20 aa a7	jsr $a7aa	                jsr xt_zero                     ; 0
.d99e	20 76 93	jsr $9376	                jsr xt_less_number_sign         ; <#
.d9a1	20 0f 98	jsr $980f	                jsr xt_number_sign_s            ; #S
.d9a4	20 ed 97	jsr $97ed	                jsr xt_number_sign_greater      ; #>
.d9a7	4c 05 a5	jmp $a505	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
