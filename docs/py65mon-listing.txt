
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Sun Jun 23 11:42:01 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$7fff						ram_end = $7fff
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/simulator.asm


;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000						w_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 2b b4	lda $b42b,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 2b b4	lda $b42b	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f						_load_user_vars_loop:
.801f		b9 49 b4	lda $b449,y	                lda cold_user_table,y
.8022		91 08		sta ($08),y	                sta (up),y
.8024		88		dey		                dey
.8025		d0 f8		bne $801f	                bne _load_user_vars_loop
.8027		ad 49 b4	lda $b449	                lda cold_user_table
.802a		92 08		sta ($08)	                sta (up)
.802c		20 3a 84	jsr $843a	                jsr w_cr
.802f		ca		dex		                dex
.8030		ca		dex		                dex
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		a9 2c		lda #$2c	                lda #<forth_words_start
.8035		95 02		sta $02,x	                sta 2,x
.8037		a9 bb		lda #$bb	                lda #>forth_words_start
.8039		95 03		sta $03,x	                sta 3,x
.803b		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803d		95 00		sta $00,x	                sta 0,x
.803f		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8041		95 01		sta $01,x	                sta 1,x
.8043		20 ce 88	jsr $88ce	                jsr w_evaluate
.8046		9c 00 7c	stz $7c00	                stz hist_buff
.8049		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804c		9c 00 7d	stz $7d00	                stz hist_buff+$100
.804f		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8052		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8055		9c 80 7e	stz $7e80	                stz hist_buff+$280
.8058		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805b		9c 80 7f	stz $7f80	                stz hist_buff+$380
.805e						xt_abort:
.805e						w_abort:
.805e		a2 78		ldx #$78	                ldx #dsp0
.8060						xt_quit:
.8060						w_quit:
.8060		8a		txa		                txa             ; Save the DSP that we just defined
.8061		a2 ff		ldx #$ff	                ldx #rsp0
.8063		9a		txs		                txs
.8064		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8065		64 04		stz $04		                stz ip
.8067		64 05		stz $05		                stz ip+1
.8069		64 0a		stz $0a		                stz insrc
.806b		64 0b		stz $0b		                stz insrc+1
.806d		a9 00		lda #$00	                lda #0
.806f		a0 04		ldy #$04	                ldy #blk_offset
.8071		91 08		sta ($08),y	                sta (up),y
.8073		c8		iny		                iny
.8074		91 08		sta ($08),y	                sta (up),y
.8076		a9 fc		lda #$fc	                lda #(256-4)
.8078		85 1f		sta $1f		                sta loopctrl
.807a		64 1a		stz $1a		                stz state
.807c		64 1b		stz $1b		                stz state+1
.807e						_get_line:
.807e		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8080		85 0c		sta $0c		                sta cib
.8082		a9 02		lda #$02	                lda #>buffer0
.8084		85 0d		sta $0d		                sta cib+1
.8086		64 0e		stz $0e		                stz ciblen
.8088		64 0f		stz $0f		                stz ciblen+1
.808a		20 66 8f	jsr $8f66	                jsr w_refill           ; ( -- f )
.808d		b5 00		lda $00,x	                lda 0,x
.808f		d0 05		bne $8096	                bne _success
.8091		a9 06		lda #$06	                lda #err_refill
.8093		4c 98 d8	jmp $d898	                jmp error
.8096						_success:
.8096		e8		inx		                inx                     ; drop
.8097		e8		inx		                inx
.8098		20 ff d7	jsr $d7ff	                jsr interpret
.809b		e0 78		cpx #$78	                cpx #dsp0
.809d		f0 05		beq $80a4	                beq _stack_ok
.809f		90 03		bcc $80a4	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a1		4c 96 d8	jmp $d896	                jmp underflow_error
.80a4						_stack_ok:
.80a4		a5 1a		lda $1a		                lda state
.80a6		f0 02		beq $80aa	                beq _print
.80a8		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80aa						_print:
.80aa		20 e9 d8	jsr $d8e9	                jsr print_string
.80ad		80 cf		bra $807e	                bra _get_line
.80af						z_cold:
.80af						z_abort:
.80af						z_quit:

;******  Processing file: platform/../words/core.asm

.80af						xt_abort_quote:
.80af						w_abort_quote:
.80af		20 01 90	jsr $9001	                jsr w_s_quote          ; S"
.80b2		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b4		a9 ba		lda #$ba	                lda #<abort_quote_runtime
.80b6		20 b7 97	jsr $97b7	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b9		60		rts		z_abort_quote:  rts
.80ba						abort_quote_runtime:
.80ba		b5 04		lda $04,x	                lda 4,x
.80bc		15 05		ora $05,x	                ora 5,x
.80be		f0 09		beq $80c9	                beq _done       ; if FALSE, we're done
.80c0		20 e6 94	jsr $94e6	                jsr w_type
.80c3		20 3a 84	jsr $843a	                jsr w_cr
.80c6		4c 5e 80	jmp $805e	                jmp w_abort    ; not JSR, so never come back
.80c9						_done:
.80c9		8a		txa		                txa
.80ca		18		clc		                clc
.80cb		69 06		adc #$06	                adc #6
.80cd		aa		tax		                tax
.80ce		60		rts		                rts
.80cf						xt_abs:
.80cf		20 82 d8	jsr $d882	                jsr underflow_1
.80d2						w_abs:
.80d2		b5 01		lda $01,x	                lda 1,x
.80d4		10 0d		bpl $80e3	                bpl _done       ; positive number, easy money!
.80d6		38		sec		                sec
.80d7		a9 00		lda #$00	                lda #0
.80d9		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80db		95 00		sta $00,x	                sta 0,x
.80dd		a9 00		lda #$00	                lda #0          ; MSB
.80df		f5 01		sbc $01,x	                sbc 1,x
.80e1		95 01		sta $01,x	                sta 1,x
.80e3						_done:
.80e3		60		rts		z_abs:          rts
.80e4						xt_accept:
.80e4		20 87 d8	jsr $d887	                jsr underflow_2
.80e7						w_accept:
.80e7		b5 00		lda $00,x	                lda 0,x
.80e9		15 01		ora $01,x	                ora 1,x
.80eb		d0 09		bne $80f6	                bne _not_zero
.80ed		e8		inx		                inx
.80ee		e8		inx		                inx
.80ef		74 00		stz $00,x	                stz 0,x
.80f1		74 01		stz $01,x	                stz 1,x
.80f3		4c c2 81	jmp $81c2	                jmp accept_done
.80f6						_not_zero:
.80f6		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f8		85 27		sta $27		                sta tmp2
.80fa		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fc		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fe		85 25		sta $25		                sta tmp1
.8100		b5 03		lda $03,x	                lda 3,x
.8102		85 26		sta $26		                sta tmp1+1
.8104		e8		inx		                inx
.8105		e8		inx		                inx
.8106		a0 00		ldy #$00	                ldy #0
.8108		a5 1c		lda $1c		                lda status
.810a		29 f7		and #$f7	                and #$F7
.810c		1a		inc a		                ina
.810d		09 08		ora #$08	                ora #%00001000
.810f		85 1c		sta $1c		                sta status
.8111						accept_loop:
.8111		20 ca 89	jsr $89ca	                jsr key_a
.8114		c9 0a		cmp #$0a	                cmp #AscLF
.8116		f0 20		beq $8138	                beq _eol
.8118		c9 0d		cmp #$0d	                cmp #AscCR
.811a		f0 1c		beq $8138	                beq _eol
.811c		c9 08		cmp #$08	                cmp #AscBS
.811e		f0 22		beq $8142	                beq _backspace
.8120		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8122		f0 1e		beq $8142	                beq _backspace
.8124		c9 10		cmp #$10	                cmp #AscCP
.8126		f0 36		beq $815e	                beq _ctrl_p
.8128		c9 0e		cmp #$0e	                cmp #AscCN
.812a		f0 44		beq $8170	                beq _ctrl_n
.812c		91 25		sta ($25),y	                sta (tmp1),y
.812e		c8		iny		                iny
.812f		20 d3 86	jsr $86d3	                jsr emit_a
.8132		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8134		d0 db		bne $8111	                bne accept_loop       ; fall through if buffer limit reached
.8136		80 03		bra $813b	                bra _buffer_full
.8138						_eol:
.8138		20 f6 91	jsr $91f6	                jsr w_space    ; print final space
.813b						_buffer_full:
.813b		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813d		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813f		4c c2 81	jmp $81c2	                jmp accept_done
.8142						_backspace:
.8142		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8144		d0 06		bne $814c	                bne +
.8146		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8148		20 d3 86	jsr $86d3	                jsr emit_a
.814b		c8		iny		                iny
.814c						+
.814c		88		dey		                dey
.814d		a9 08		lda #$08	                lda #AscBS      ; move back one
.814f		20 d3 86	jsr $86d3	                jsr emit_a
.8152		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8154		20 d3 86	jsr $86d3	                jsr emit_a
.8157		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8159		20 d3 86	jsr $86d3	                jsr emit_a
.815c		80 b3		bra $8111	                bra accept_loop
.815e						_ctrl_p:
.815e		a5 1c		lda $1c		                lda status
.8160		29 07		and #$07	                and #7
.8162		d0 08		bne $816c	                bne _ctrl_p_dec
.8164		a5 1c		lda $1c		                lda status
.8166		09 07		ora #$07	                ora #7
.8168		85 1c		sta $1c		                sta status
.816a		80 11		bra $817d	                bra _recall_history
.816c						_ctrl_p_dec:
.816c		c6 1c		dec $1c		                dec status
.816e		80 0d		bra $817d	                bra _recall_history
.8170						_ctrl_n:
.8170		a9 08		lda #$08	                lda #$8
.8172		24 1c		bit $1c		                bit status
.8174		d0 07		bne $817d	                bne _recall_history
.8176		a5 1c		lda $1c		                lda status
.8178		29 f7		and #$f7	                and #$F7
.817a		1a		inc a		               ina
.817b		85 1c		sta $1c		                sta status
.817d						_recall_history:
.817d		a9 08		lda #$08	                lda #%00001000
.817f		14 1c		trb $1c		                trb status
.8181		20 dd 81	jsr $81dd	                jsr accept_total_recall
.8184		a9 0d		lda #$0d	                lda #AscCR
.8186		20 d3 86	jsr $86d3	                jsr emit_a
.8189						input_clear:
.8189		c0 00		cpy #$00	                cpy #0
.818b		f0 08		beq $8195	                beq input_cleared
.818d		a9 20		lda #$20	                lda #AscSP
.818f		20 d3 86	jsr $86d3	                jsr emit_a
.8192		88		dey		                dey
.8193		80 f4		bra $8189	                bra input_clear
.8195						input_cleared:
.8195		a9 0d		lda #$0d	                lda #AscCR
.8197		20 d3 86	jsr $86d3	                jsr emit_a
.819a		b1 29		lda ($29),y	                lda (tmp3),y
.819c		85 1d		sta $1d		                sta status+1
.819e		e6 29		inc $29		                inc tmp3
.81a0		d0 02		bne $81a4	                bne +           ; Increment the upper byte on carry.
.81a2		e6 2a		inc $2a		                inc tmp3+1
.81a4						+
.81a4		a9 0d		lda #$0d	                lda #AscCR
.81a6		20 d3 86	jsr $86d3	                jsr emit_a
.81a9						_history_loop:
.81a9		c4 1d		cpy $1d		                cpy status+1
.81ab		d0 03		bne $81b0	                bne +
.81ad		4c 11 81	jmp $8111	                jmp accept_loop       ; Needs a long jump
.81b0						+
.81b0		c4 27		cpy $27		                cpy tmp2
.81b2		f0 0a		beq $81be	                beq _hist_filled_buffer
.81b4		b1 29		lda ($29),y	                lda (tmp3),y
.81b6		91 25		sta ($25),y	                sta (tmp1),y
.81b8		20 d3 86	jsr $86d3	                jsr emit_a
.81bb		c8		iny		                iny
.81bc		80 eb		bra $81a9	                bra _history_loop
.81be						_hist_filled_buffer:
.81be		88		dey		                dey
.81bf		4c 11 81	jmp $8111	                jmp accept_loop
.81c2						accept_done:
.81c2		20 dd 81	jsr $81dd	                jsr accept_total_recall
.81c5		85 1d		sta $1d		                sta status+1
.81c7		a0 00		ldy #$00	                ldy #0
.81c9		91 29		sta ($29),y	                sta (tmp3),y
.81cb		e6 29		inc $29		                inc tmp3
.81cd		d0 02		bne $81d1	                bne +           ; Increment the upper byte on carry.
.81cf		e6 2a		inc $2a		                inc tmp3+1
.81d1						+
.81d1						_save_history_loop:
.81d1		c4 1d		cpy $1d		                cpy status+1
.81d3		f0 07		beq $81dc	                beq _save_history_done
.81d5		b1 25		lda ($25),y	                lda (tmp1),y
.81d7		91 29		sta ($29),y	                sta (tmp3),y
.81d9		c8		iny		                iny
.81da		80 f5		bra $81d1	                bra _save_history_loop
.81dc						_save_history_done:
.81dc						z_accept:
.81dc		60		rts		                rts
.81dd						accept_total_recall:
.81dd		a9 00		lda #$00	                lda #<hist_buff
.81df		85 29		sta $29		                sta tmp3
.81e1		a9 7c		lda #$7c	                lda #>hist_buff
.81e3		85 2a		sta $2a		                sta tmp3+1
.81e5		a5 1c		lda $1c		                lda status
.81e7		6a		ror a		                ror
.81e8		29 03		and #$03	                and #3
.81ea		18		clc		                clc
.81eb		65 2a		adc $2a		                adc tmp3+1
.81ed		85 2a		sta $2a		                sta tmp3+1
.81ef		a5 1c		lda $1c		                lda status
.81f1		6a		ror a		                ror             ; Rotate through carry into msb.
.81f2		6a		ror a		                ror
.81f3		29 80		and #$80	                and #$80
.81f5		18		clc		                clc
.81f6		65 29		adc $29		                adc tmp3
.81f8		85 29		sta $29		                sta tmp3
.81fa		90 02		bcc $81fe	                bcc +           ; Increment the upper byte on carry.
.81fc		e6 2a		inc $2a		                inc tmp3+1
.81fe						+
.81fe		98		tya		                tya
.81ff		c9 80		cmp #$80	                cmp #$80
.8201		90 02		bcc $8205	                bcc +
.8203		a9 7f		lda #$7f	                lda #$7F
.8205						+
.8205		60		rts		                rts
.8206						xt_action_of:
.8206						w_action_of:
.8206		a5 1a		lda $1a		                lda state
.8208		05 1b		ora $1b		                ora state+1
.820a		f0 0c		beq $8218	                beq _interpreting
.820c		20 14 83	jsr $8314	                jsr w_bracket_tick
.820f		a0 85		ldy #$85	                ldy #>w_defer_fetch
.8211		a9 47		lda #$47	                lda #<w_defer_fetch
.8213		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8216		80 06		bra $821e	                bra _done
.8218						_interpreting:
.8218		20 70 92	jsr $9270	                jsr w_tick
.821b		20 47 85	jsr $8547	                jsr w_defer_fetch
.821e						_done:
.821e		60		rts		z_action_of:           rts
.821f						xt_again:
.821f		20 82 d8	jsr $d882	                jsr underflow_1
.8222						w_again:
.8222		20 d0 97	jsr $97d0	                jsr cmpl_jump_tos
.8225		60		rts		z_again:        rts
.8226						xt_align:
.8226						xt_aligned:
.8226						w_align:
.8226						w_aligned:
.8226						z_align:
.8226						z_aligned:
.8226		60		rts		                rts             ; stripped out during native compile
.8227						xt_allot:
.8227		20 82 d8	jsr $d882	                jsr underflow_1
.822a						w_allot:
.822a		b5 01		lda $01,x	                lda 1,x
.822c		30 22		bmi $8250	                bmi _release
.822e		18		clc		                clc
.822f		a5 00		lda $00		                lda cp
.8231		75 00		adc $00,x	                adc 0,x
.8233		85 00		sta $00		                sta cp
.8235		a5 01		lda $01		                lda cp+1
.8237		75 01		adc $01,x	                adc 1,x
.8239		85 01		sta $01		                sta cp+1
.823b		a0 00		ldy #$00	                ldy #<cp_end
.823d		c4 00		cpy $00		                cpy cp
.823f		a9 7c		lda #$7c	                lda #>cp_end
.8241		e5 01		sbc $01		                sbc cp+1
.8243		b0 48		bcs $828d	                bcs _done               ; we're fine.
.8245		84 00		sty $00		                sty cp                  ; still #<cp_end
.8247		a9 7c		lda #$7c	                lda #>cp_end
.8249		85 01		sta $01		                sta cp+1
.824b		a9 00		lda #$00	                lda #err_allot
.824d		4c 98 d8	jmp $d898	                jmp error
.8250						_release:
.8250		ca		dex		                dex
.8251		ca		dex		                dex
.8252		a5 00		lda $00		                lda cp
.8254		95 00		sta $00,x	                sta 0,x
.8256		a5 01		lda $01		                lda cp+1
.8258		95 01		sta $01,x	                sta 1,x
.825a		20 80 8e	jsr $8e80	                jsr w_plus                     ; new CP is now TOS
.825d		ca		dex		                dex
.825e		ca		dex		                dex                             ; new CP now NOS
.825f		a9 00		lda #$00	                lda #<cp0
.8261		95 00		sta $00,x	                sta 0,x
.8263		a9 03		lda #$03	                lda #>cp0
.8265		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8267		20 c0 d7	jsr $d7c0	                jsr compare_16bit               ; still ( CP CP0 )
.826a		f0 17		beq $8283	                beq _nega_done
.826c		30 15		bmi $8283	                bmi _nega_done
.826e		a9 00		lda #$00	                lda #<cp0
.8270		85 00		sta $00		                sta cp
.8272		a9 03		lda #$03	                lda #>cp0
.8274		85 01		sta $01		                sta cp+1
.8276		a9 0e		lda #$0e	                lda #<dictionary_start
.8278		85 02		sta $02		                sta dp
.827a		a9 bc		lda #$bc	                lda #>dictionary_start
.827c		85 03		sta $03		                sta dp+1
.827e		a9 0a		lda #$0a	                lda #err_negallot
.8280		4c 98 d8	jmp $d898	                jmp error
.8283						_nega_done:
.8283		b5 02		lda $02,x	                lda 2,x
.8285		85 00		sta $00		                sta cp
.8287		b5 03		lda $03,x	                lda 3,x
.8289		85 01		sta $01		                sta cp+1
.828b		e8		inx		                inx
.828c		e8		inx		                inx                     ; drop through to _done
.828d						_done:
.828d		e8		inx		                inx
.828e		e8		inx		                inx
.828f						z_allot:
.828f		60		rts		                rts
.8290						xt_and:
.8290		20 87 d8	jsr $d887	                jsr underflow_2
.8293						w_and:
.8293		b5 00		lda $00,x	                lda 0,x
.8295		35 02		and $02,x	                and 2,x
.8297		95 02		sta $02,x	                sta 2,x
.8299		b5 01		lda $01,x	                lda 1,x
.829b		35 03		and $03,x	                and 3,x
.829d		95 03		sta $03,x	                sta 3,x
.829f		e8		inx		                inx
.82a0		e8		inx		                inx
.82a1		60		rts		z_and:          rts
.82a2						xt_at_xy:
.82a2		20 87 d8	jsr $d887	                jsr underflow_2
.82a5						w_at_xy:
.82a5		a5 18		lda $18		                lda base
.82a7		48		pha		                pha
.82a8		a9 0a		lda #$0a	                lda #10
.82aa		85 18		sta $18		                sta base
.82ac		a9 1b		lda #$1b	                lda #AscESC
.82ae		20 d3 86	jsr $86d3	                jsr emit_a
.82b1		a9 5b		lda #$5b	                lda #'['
.82b3		20 d3 86	jsr $86d3	                jsr emit_a
.82b6		20 16 8d	jsr $8d16	                jsr w_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82b9		20 ef d8	jsr $d8ef	                jsr print_u
.82bc		a9 3b		lda #$3b	                lda #';'
.82be		20 d3 86	jsr $86d3	                jsr emit_a
.82c1		20 16 8d	jsr $8d16	                jsr w_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c4		20 ef d8	jsr $d8ef	                jsr print_u
.82c7		a9 48		lda #$48	                lda #'H'
.82c9		20 d3 86	jsr $86d3	                jsr emit_a
.82cc		68		pla		                pla
.82cd		85 18		sta $18		                sta base
.82cf		60		rts		z_at_xy:        rts
.82d0						xt_backslash:
.82d0						w_backslash:
.82d0		a0 04		ldy #$04	                ldy #blk_offset
.82d2		b1 08		lda ($08),y	                lda (up),y
.82d4		c8		iny		                iny
.82d5		11 08		ora ($08),y	                ora (up),y
.82d7		f0 19		beq $82f2	                beq backslash_not_block
.82d9		a5 10		lda $10		                lda toin
.82db		29 3f		and #$3f	                and #$3F
.82dd		f0 1b		beq $82fa	                beq z_backslash
.82df		c9 01		cmp #$01	                cmp #$1
.82e1		f0 17		beq $82fa	                beq z_backslash
.82e3		a5 10		lda $10		                lda toin
.82e5		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e7		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82e8		69 40		adc #$40	                adc #$40
.82ea		85 10		sta $10		                sta toin
.82ec		90 0c		bcc $82fa	                bcc z_backslash
.82ee		e6 11		inc $11		                inc toin+1
.82f0		80 08		bra $82fa	                bra z_backslash
.82f2						backslash_not_block:
.82f2		a5 0e		lda $0e		                lda ciblen
.82f4		85 10		sta $10		                sta toin
.82f6		a5 0f		lda $0f		                lda ciblen+1
.82f8		85 11		sta $11		                sta toin+1
.82fa		60		rts		z_backslash:    rts
.82fb						xt_base:
.82fb						w_base:
.82fb		ca		dex		                dex
.82fc		ca		dex		                dex
.82fd		a9 18		lda #$18	                lda #<base
.82ff		95 00		sta $00,x	                sta 0,x         ; LSB
.8301		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8303		60		rts		z_base:         rts
.8304						xt_bl:
.8304						w_bl:
.8304		ca		dex		                dex
.8305		ca		dex		                dex
.8306		a9 20		lda #$20	                lda #AscSP
.8308		95 00		sta $00,x	                sta 0,x
.830a		74 01		stz $01,x	                stz 1,x
.830c		60		rts		z_bl:           rts
.830d						xt_bracket_char:
.830d						w_bracket_char:
.830d		20 53 83	jsr $8353	                jsr w_char
.8310		20 20 8a	jsr $8a20	                jsr w_literal
.8313		60		rts		z_bracket_char: rts
.8314						xt_bracket_tick:
.8314						w_bracket_tick:
.8314		20 70 92	jsr $9270	                jsr w_tick
.8317		20 20 8a	jsr $8a20	                jsr w_literal
.831a		60		rts		z_bracket_tick: rts
.831b						xt_buffer_colon:
.831b						w_buffer_colon:
.831b		20 40 84	jsr $8440	                jsr w_create
.831e		20 2a 82	jsr $822a	                jsr w_allot
.8321		60		rts		z_buffer_colon: rts
.8322						xt_c_comma:
.8322		20 82 d8	jsr $d882	                jsr underflow_1
.8325						w_c_comma:
.8325		b5 00		lda $00,x	                lda 0,x
.8327		20 c7 97	jsr $97c7	                jsr cmpl_a
.832a		e8		inx		                inx
.832b		e8		inx		                inx
.832c		60		rts		z_c_comma:      rts
.832d						xt_c_fetch:
.832d		20 82 d8	jsr $d882	                jsr underflow_1
.8330						w_c_fetch:
.8330		a1 00		lda ($00,x)	                lda (0,x)
.8332		95 00		sta $00,x	                sta 0,x
.8334		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8336		60		rts		z_c_fetch:      rts
.8337						xt_c_store:
.8337		20 87 d8	jsr $d887	                jsr underflow_2
.833a						w_c_store:
.833a		b5 02		lda $02,x	                lda 2,x
.833c		81 00		sta ($00,x)	                sta (0,x)
.833e		e8		inx		                inx
.833f		e8		inx		                inx
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		60		rts		z_c_store:      rts
.8343						xt_cell_plus:
.8343		20 82 d8	jsr $d882	                jsr underflow_1
.8346						w_cell_plus:
.8346		f6 00		inc $00,x	                inc 0,x
.8348		d0 02		bne $834c	                bne +
.834a		f6 01		inc $01,x	                inc 1,x
.834c						+
.834c		f6 00		inc $00,x	                inc 0,x
.834e		d0 02		bne $8352	                bne _done
.8350		f6 01		inc $01,x	                inc 1,x
.8352						_done:
.8352		60		rts		z_cell_plus:    rts
.8353						xt_char:
.8353						w_char:
.8353		20 7b 8d	jsr $8d7b	                jsr w_parse_name
.8356		b5 00		lda $00,x	                lda 0,x
.8358		15 01		ora $01,x	                ora 1,x
.835a		d0 05		bne $8361	                bne _not_empty
.835c		a9 05		lda #$05	                lda #err_noname
.835e		4c 98 d8	jmp $d898	                jmp error
.8361						_not_empty:
.8361		e8		inx		                inx             ; drop number of characters, leave addr
.8362		e8		inx		                inx
.8363		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8365		95 00		sta $00,x	                sta 0,x
.8367		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8369		60		rts		z_char:         rts
.836a						xt_chars:
.836a		20 82 d8	jsr $d882	                jsr underflow_1
.836d						w_chars:
.836d		60		rts		z_chars:        rts
.836e						xt_colon:
.836e						w_colon:
.836e		a5 1a		lda $1a		                lda state
.8370		05 1b		ora $1b		                ora state+1
.8372		f0 05		beq $8379	                beq +
.8374		a9 07		lda #$07	                lda #err_state
.8376		4c 98 d8	jmp $d898	                jmp error
.8379						+
.8379		c6 1a		dec $1a		                dec state
.837b		c6 1b		dec $1b		                dec state+1
.837d		a9 40		lda #$40	                lda #%01000000
.837f		04 1c		tsb $1c		                tsb status
.8381		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.8384		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8386		48		pha		                pha
.8387		a5 02		lda $02		                lda dp
.8389		48		pha		                pha
.838a		a9 80		lda #$80	                lda #%10000000
.838c		04 1c		tsb $1c		                tsb status
.838e		20 40 84	jsr $8440	                jsr w_create
.8391		20 d9 d7	jsr $d7d9	                jsr current_to_dp   ; This might be able to be omitted
.8394		a5 02		lda $02		                lda dp
.8396		85 06		sta $06		                sta workword
.8398		a5 03		lda $03		                lda dp+1
.839a		85 07		sta $07		                sta workword+1
.839c		68		pla		                pla
.839d		85 02		sta $02		                sta dp
.839f		68		pla		                pla
.83a0		85 03		sta $03		                sta dp+1
.83a2		20 ec d7	jsr $d7ec	                jsr dp_to_current
.83a5		a5 00		lda $00		                lda cp
.83a7		38		sec		                sec
.83a8		e9 03		sbc #$03	                sbc #3
.83aa		85 00		sta $00		                sta cp
.83ac		b0 02		bcs $83b0	                bcs _done
.83ae		c6 01		dec $01		                dec cp+1
.83b0						_done:
.83b0		60		rts		z_colon:        rts
.83b1						xt_colon_noname:
.83b1						w_colon_noname:
.83b1		a5 1a		lda $1a		                lda state
.83b3		05 1b		ora $1b		                ora state+1
.83b5		f0 05		beq $83bc	                beq +
.83b7		a9 07		lda #$07	                lda #err_state
.83b9		4c 98 d8	jmp $d898	                jmp error
.83bc						+
.83bc		c6 1a		dec $1a		                dec state
.83be		c6 1b		dec $1b		                dec state+1
.83c0		a9 40		lda #$40	                lda #%01000000
.83c2		14 1c		trb $1c		                trb status
.83c4		a5 00		lda $00		                lda cp
.83c6		85 06		sta $06		                sta workword
.83c8		a5 01		lda $01		                lda cp+1
.83ca		85 07		sta $07		                sta workword+1
.83cc		60		rts		z_colon_noname:        rts
.83cd						xt_comma:
.83cd		20 82 d8	jsr $d882	                jsr underflow_1
.83d0						w_comma:
.83d0		a0 02		ldy #$02	                ldy #2
.83d2		b5 00		lda $00,x	_twice:         lda 0,x
.83d4		20 c7 97	jsr $97c7	                jsr cmpl_a
.83d7		e8		inx		                inx
.83d8		88		dey		                dey
.83d9		d0 f7		bne $83d2	                bne _twice
.83db		60		rts		z_comma:        rts
.83dc						xt_compile_only:
.83dc						w_compile_only:
.83dc		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.83df		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83e1		b1 02		lda ($02),y	                lda (dp),y
.83e3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83e5		91 02		sta ($02),y	                sta (dp),y
.83e7		60		rts		z_compile_only: rts
.83e8						xt_value:
.83e8						xt_constant:
.83e8		20 82 d8	jsr $d882	                jsr underflow_1
.83eb						w_value:
.83eb						w_constant:
.83eb		20 40 84	jsr $8440	                jsr w_create
.83ee		38		sec		                sec
.83ef		a5 00		lda $00		                lda cp
.83f1		e9 02		sbc #$02	                sbc #2
.83f3		85 25		sta $25		                sta tmp1
.83f5		a5 01		lda $01		                lda cp+1
.83f7		e9 00		sbc #$00	                sbc #0
.83f9		85 26		sta $26		                sta tmp1+1
.83fb		a9 ea		lda #$ea	                lda #<doconst           ; LSB of DOCONST
.83fd		92 25		sta ($25)	                sta (tmp1)
.83ff		a0 01		ldy #$01	                ldy #1
.8401		a9 d6		lda #$d6	                lda #>doconst           ; MSB of DOCONST
.8403		91 25		sta ($25),y	                sta (tmp1),y
.8405		20 d0 83	jsr $83d0	                jsr w_comma            ; drop through to adjust_z
.8408						adjust_z:
.8408		20 61 9c	jsr $9c61	                jsr w_latestnt         ; gives us ( -- nt )
.840b		b5 00		lda $00,x	                lda 0,x
.840d		85 25		sta $25		                sta tmp1
.840f		b5 01		lda $01,x	                lda 1,x
.8411		85 26		sta $26		                sta tmp1+1
.8413		a0 06		ldy #$06	                ldy #6
.8415		b1 25		lda ($25),y	                lda (tmp1),y
.8417		18		clc		                clc
.8418		69 02		adc #$02	                adc #2
.841a		91 25		sta ($25),y	                sta (tmp1),y
.841c		c8		iny		                iny
.841d		b1 25		lda ($25),y	                lda (tmp1),y
.841f		69 00		adc #$00	                adc #0                  ; only need carry
.8421		91 25		sta ($25),y	                sta (tmp1),y
.8423		e8		inx		                inx
.8424		e8		inx		                inx
.8425						z_value:
.8425		60		rts		z_constant:     rts
.8426						xt_count:
.8426		20 82 d8	jsr $d882	                jsr underflow_1
.8429						w_count:
.8429		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.842b		a8		tay		                tay
.842c		f6 00		inc $00,x	                inc 0,x         ; LSB
.842e		d0 02		bne $8432	                bne +
.8430		f6 01		inc $01,x	                inc 1,x         ; MSB
.8432		98		tya		+               tya
.8433		ca		dex		                dex
.8434		ca		dex		                dex
.8435		95 00		sta $00,x	                sta 0,x         ; LSB
.8437		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8439		60		rts		z_count:        rts
.843a						xt_cr:
.843a						w_cr:
.843a		a9 0a		lda #$0a	                lda #AscLF
.843c		20 d3 86	jsr $86d3	                jsr emit_a
.843f		60		rts		z_cr:           rts
.8440						xt_create:
.8440						w_create:
.8440		20 7b 8d	jsr $8d7b	                jsr w_parse_name       ; ( addr u )
.8443		b5 00		lda $00,x	                lda 0,x
.8445		15 01		ora $01,x	                ora 1,x
.8447		d0 05		bne $844e	                bne _got_name
.8449		a9 05		lda #$05	                lda #err_noname
.844b		4c 98 d8	jmp $d898	                jmp error
.844e						_got_name:
.844e		74 01		stz $01,x	                stz 1,x
.8450		20 dc 93	jsr $93dc	                jsr w_two_dup          ; ( addr u addr u )
.8453		20 30 9b	jsr $9b30	                jsr w_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8456		b5 00		lda $00,x	                lda 0,x
.8458		15 01		ora $01,x	                ora 1,x
.845a		f0 1e		beq $847a	                beq _new_name           ; We haven't seen this one before.
.845c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.845d		e8		inx		                inx
.845e		24 1c		bit $1c		                bit status
.8460		10 08		bpl $846a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8462		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8464		05 1c		ora $1c		                ora status
.8466		85 1c		sta $1c		                sta status
.8468		80 18		bra $8482	                bra _process_name
.846a						_redefined_name:
.846a		a9 02		lda #$02	                lda #str_redefined
.846c		20 be d8	jsr $d8be	                jsr print_string_no_lf
.846f		20 dc 93	jsr $93dc	                jsr w_two_dup           ; ( addr u addr u )
.8472		20 e6 94	jsr $94e6	                jsr w_type
.8475		20 f6 91	jsr $91f6	                jsr w_space
.8478		80 08		bra $8482	                bra _process_name
.847a						_new_name:
.847a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.847b		e8		inx		                inx
.847c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.847e		25 1c		and $1c		                and status
.8480		85 1c		sta $1c		                sta status
.8482						_process_name:
.8482		b5 00		lda $00,x	                lda 0,x
.8484		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8486		a5 00		lda $00		                lda cp
.8488		85 25		sta $25		                sta tmp1
.848a		a5 01		lda $01		                lda cp+1
.848c		85 26		sta $26		                sta tmp1+1
.848e		b5 00		lda $00,x	                lda 0,x
.8490		18		clc		                clc
.8491		69 08		adc #$08	                adc #8
.8493		85 29		sta $29		                sta tmp3                ; total header length
.8495		95 00		sta $00,x	                sta 0,x
.8497		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.8499		20 2a 82	jsr $822a	                jsr w_allot    ; ( addr )
.849c		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.849f		a0 00		ldy #$00	                ldy #0
.84a1		a5 27		lda $27		                lda tmp2
.84a3		91 25		sta ($25),y	                sta (tmp1),y
.84a5		a9 08		lda #$08	                lda #NN
.84a7		09 20		ora #$20	                ora #HC
.84a9		c8		iny		                iny
.84aa		91 25		sta ($25),y	                sta (tmp1),y
.84ac		c8		iny		                iny
.84ad		a5 02		lda $02		                lda dp
.84af		91 25		sta ($25),y	                sta (tmp1),y
.84b1		c8		iny		                iny
.84b2		a5 03		lda $03		                lda dp+1
.84b4		91 25		sta ($25),y	                sta (tmp1),y
.84b6		c8		iny		                iny
.84b7		a5 26		lda $26		                lda tmp1+1
.84b9		85 03		sta $03		                sta dp+1
.84bb		a5 25		lda $25		                lda tmp1
.84bd		85 02		sta $02		                sta dp
.84bf		18		clc		                clc
.84c0		65 29		adc $29		                adc tmp3        ; add total header length
.84c2		91 25		sta ($25),y	                sta (tmp1),y
.84c4		48		pha		                pha             ; we need this in the next step
.84c5		c8		iny		                iny
.84c6		a5 26		lda $26		                lda tmp1+1
.84c8		69 00		adc #$00	                adc #0          ; only need the carry
.84ca		91 25		sta ($25),y	                sta (tmp1),y
.84cc		c8		iny		                iny
.84cd		68		pla		                pla             ; LSB of "z_" address
.84ce		18		clc		                clc
.84cf		69 03		adc #$03	                adc #3
.84d1		91 25		sta ($25),y	                sta (tmp1),y
.84d3		88		dey		                dey             ; get the MSB of xt back
.84d4		b1 25		lda ($25),y	                lda (tmp1),y
.84d6		69 00		adc #$00	                adc #0          ; only need the carry
.84d8		c8		iny		                iny
.84d9		c8		iny		                iny
.84da		91 25		sta ($25),y	                sta (tmp1),y
.84dc		c8		iny		                iny
.84dd		b5 00		lda $00,x	                lda 0,x
.84df		38		sec		                sec
.84e0		e9 08		sbc #$08	                sbc #8
.84e2		85 23		sta $23		                sta tmptos
.84e4		b5 01		lda $01,x	                lda 1,x
.84e6		e9 00		sbc #$00	                sbc #0          ; only need carry
.84e8		85 24		sta $24		                sta tmptos+1
.84ea						_name_loop:
.84ea		b1 23		lda ($23),y	                lda (tmptos),y
.84ec		c9 5b		cmp #$5b	                cmp #'Z'+1
.84ee		b0 06		bcs $84f6	                bcs _store_name
.84f0		c9 41		cmp #$41	                cmp #'A'
.84f2		90 02		bcc $84f6	                bcc _store_name
.84f4		09 20		ora #$20	                ora #$20
.84f6						_store_name:
.84f6		91 25		sta ($25),y	                sta (tmp1),y
.84f8		c8		iny		                iny
.84f9		c6 27		dec $27		                dec tmp2
.84fb		d0 ed		bne $84ea	                bne _name_loop
.84fd		a0 d7		ldy #$d7	                ldy #>dovar
.84ff		a9 30		lda #$30	                lda #<dovar
.8501		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8504		20 ec d7	jsr $d7ec	                jsr dp_to_current
.8507		e8		inx		                inx
.8508		e8		inx		                inx
.8509		60		rts		z_create:       rts
.850a						xt_decimal:
.850a						w_decimal:
.850a		a9 0a		lda #$0a	                lda #10
.850c		85 18		sta $18		                sta base
.850e		64 19		stz $19		                stz base+1              ; paranoid
.8510		60		rts		z_decimal:      rts
.8511						xt_defer:
.8511						w_defer:
.8511		20 40 84	jsr $8440	                jsr w_create
.8514		a5 00		lda $00		                lda cp          ; LSB
.8516		38		sec		                sec
.8517		e9 02		sbc #$02	                sbc #2
.8519		85 25		sta $25		                sta tmp1
.851b		a5 01		lda $01		                lda cp+1        ; MSB
.851d		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.851f		85 26		sta $26		                sta tmp1+1
.8521		a0 00		ldy #$00	                ldy #0
.8523		a9 fe		lda #$fe	                lda #<dodefer   ; LSB
.8525		91 25		sta ($25),y	                sta (tmp1),y
.8527		c8		iny		                iny
.8528		a9 d6		lda #$d6	                lda #>dodefer   ; MSB
.852a		91 25		sta ($25),y	                sta (tmp1),y
.852c		a9 12		lda #$12	                lda #<defer_error
.852e		92 00		sta ($00)	                sta (cp)
.8530		e6 00		inc $00		                inc cp
.8532		d0 02		bne $8536	                bne +
.8534		e6 01		inc $01		                inc cp+1
.8536						+
.8536		a9 d7		lda #$d7	                lda #>defer_error
.8538		92 00		sta ($00)	                sta (cp)
.853a		e6 00		inc $00		                inc cp
.853c		d0 02		bne $8540	                bne +
.853e		e6 01		inc $01		                inc cp+1
.8540						+
.8540		20 08 84	jsr $8408	                jsr adjust_z    ; adjust header to correct length
.8543		60		rts		z_defer:        rts
.8544						xt_defer_fetch:
.8544		20 82 d8	jsr $d882	                jsr underflow_1
.8547						w_defer_fetch:
.8547		20 cf 92	jsr $92cf	                jsr w_to_body
.854a		20 36 88	jsr $8836	                jsr w_fetch
.854d		60		rts		z_defer_fetch:  rts
.854e						xt_defer_store:
.854e		20 87 d8	jsr $d887	                jsr underflow_2
.8551						w_defer_store:
.8551		20 cf 92	jsr $92cf	                jsr w_to_body
.8554		20 49 92	jsr $9249	                jsr w_store
.8557		60		rts		z_defer_store:  rts
.8558						xt_depth:
.8558						w_depth:
.8558		a9 78		lda #$78	                lda #dsp0
.855a		86 1e		stx $1e		                stx tmpdsp
.855c		38		sec		                sec
.855d		e5 1e		sbc $1e		                sbc tmpdsp
.855f		4a		lsr a		                lsr
.8560		ca		dex		                dex
.8561		ca		dex		                dex
.8562		95 00		sta $00,x	                sta 0,x
.8564		74 01		stz $01,x	                stz 1,x
.8566		60		rts		z_depth:        rts
.8567						xt_question_do:
.8567						w_question_do:
.8567		ca		dex		                dex
.8568		ca		dex		                dex
.8569		a9 aa		lda #$aa	                lda #<question_do_runtime
.856b		95 00		sta $00,x	                sta 0,x
.856d		a9 85		lda #$85	                lda #>question_do_runtime
.856f		95 01		sta $01,x	                sta 1,x
.8571		20 a9 86	jsr $86a9	                jsr w_dup              ; xt and xt' are the same
.8574		ca		dex		                dex
.8575		ca		dex		                dex
.8576		a9 10		lda #$10	                lda #question_do_runtime_size
.8578		95 00		sta $00,x	                sta 0,x
.857a		74 01		stz $01,x	                stz 1,x
.857c		20 3f 97	jsr $973f	                jsr cmpl_by_limit
.857f		90 0b		bcc $858c	                bcc _native
.8581		20 34 89	jsr $8934	                jsr w_here
.8584		20 39 9e	jsr $9e39	                jsr w_zero
.8587		20 d0 83	jsr $83d0	                jsr w_comma
.858a		80 08		bra $8594	                bra do_common
.858c						_native:
.858c		20 d8 97	jsr $97d8	                jsr cmpl_jump_later
.858f		80 03		bra $8594	                bra do_common
.8591						xt_do:
.8591						w_do:
.8591		20 39 9e	jsr $9e39	                jsr w_zero             ; push 0 TOS
.8594						do_common:
.8594		ca		dex		                dex
.8595		ca		dex		                dex
.8596		a5 21		lda $21		                lda loopleave
.8598		95 00		sta $00,x	                sta 0,x
.859a		a5 22		lda $22		                lda loopleave+1
.859c		95 01		sta $01,x	                sta 1,x
.859e		64 22		stz $22		                stz loopleave+1
.85a0		a0 85		ldy #$85	                ldy #>do_runtime
.85a2		a9 c2		lda #$c2	                lda #<do_runtime
.85a4		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.85a7		4c 34 89	jmp $8934	                jmp w_here
.85aa						z_question_do:
.85aa						z_do:
.85aa						question_do_runtime:
.85aa		b5 00		lda $00,x	                lda 0,x
.85ac		d5 02		cmp $02,x	                cmp 2,x
.85ae		d0 0d		bne $85bd	                bne _begin
.85b0		b5 01		lda $01,x	                lda 1,x
.85b2		d5 03		cmp $03,x	                cmp 3,x
.85b4		d0 07		bne $85bd	                bne _begin
.85b6		e8		inx		                inx                     ; drop loop limits and skip
.85b7		e8		inx		                inx
.85b8		e8		inx		                inx
.85b9		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.85ba		a9 00		lda #$00	                lda #0
>85bc		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.85bd		a9 01		lda #$01	_begin:         lda #1
.85bf		4c 71 98	jmp $9871	                jmp zbranch_runtime
.85c2						do_runtime:
.85c2		a4 1f		ldy $1f		                ldy loopctrl
.85c4		30 05		bmi $85cb	                bmi +                   ; is this the first LCB?
.85c6		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.85c8		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.85cb						+
.85cb		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.85cc		c8		iny		                iny
.85cd		c8		iny		                iny
.85ce		c8		iny		                iny
.85cf		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.85d1		38		sec		                sec
.85d2		a9 00		lda #$00	                lda #0
.85d4		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.85d6		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.85d9		a9 80		lda #$80	                lda #$80
.85db		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.85dd		99 03 01	sta $0103,y	                sta loopfufa+1,y
.85e0		18		clc		                clc
.85e1		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.85e3		79 02 01	adc $0102,y	                adc loopfufa,y
.85e6		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.85e8		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.85ea		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85ed		99 01 01	sta $0101,y	                sta loopindex+1,y
.85f0		e8		inx		                inx                 ; clean up the stack
.85f1		e8		inx		                inx
.85f2		e8		inx		                inx
.85f3		e8		inx		                inx
.85f4		60		rts		                rts
.85f5						xt_does:
.85f5						w_does:
.85f5		a0 86		ldy #$86	                ldy #>does_runtime
.85f7		a9 04		lda #$04	                lda #<does_runtime
.85f9		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.85fc		a0 d7		ldy #$d7	                ldy #>dodoes
.85fe		a9 17		lda #$17	                lda #<dodoes
.8600		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8603		60		rts		z_does:         rts
.8604						does_runtime:
.8604		7a		ply		                ply             ; LSB
.8605		68		pla		                pla             ; MSB
.8606		c8		iny		                iny
.8607		d0 01		bne $860a	                bne +
.8609		1a		inc a		                ina
.860a						+
.860a		84 25		sty $25		                sty tmp1
.860c		85 26		sta $26		                sta tmp1+1
.860e		20 d9 d7	jsr $d7d9	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8611		a5 02		lda $02		                lda dp
.8613		18		clc		                clc
.8614		69 04		adc #$04	                adc #4
.8616		85 27		sta $27		                sta tmp2
.8618		a5 03		lda $03		                lda dp+1
.861a		69 00		adc #$00	                adc #0          ; we only care about the carry
.861c		85 28		sta $28		                sta tmp2+1
.861e		b2 27		lda ($27)	                lda (tmp2)
.8620		18		clc		                clc
.8621		69 01		adc #$01	                adc #1
.8623		85 29		sta $29		                sta tmp3
.8625		a0 01		ldy #$01	                ldy #1
.8627		b1 27		lda ($27),y	                lda (tmp2),y
.8629		69 00		adc #$00	                adc #0          ; we only care about the carry
.862b		85 2a		sta $2a		                sta tmp3+1
.862d		a5 25		lda $25		                lda tmp1        ; LSB
.862f		92 29		sta ($29)	                sta (tmp3)
.8631		a5 26		lda $26		                lda tmp1+1
.8633		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.8635		60		rts		                rts
.8636						xt_dot:
.8636		20 82 d8	jsr $d882	                jsr underflow_1
.8639						w_dot:
.8639		20 a9 86	jsr $86a9	                jsr w_dup                      ; ( n n )
.863c		20 d2 80	jsr $80d2	                jsr w_abs                      ; ( n u )
.863f		20 39 9e	jsr $9e39	                jsr w_zero                     ; ( n u 0 )
.8642		20 fa 89	jsr $89fa	                jsr w_less_number_sign         ; ( n u 0 )
.8645		20 e0 8c	jsr $8ce0	                jsr w_number_sign_s            ; ( n ud )
.8648		20 bb 8f	jsr $8fbb	                jsr w_rot                      ; ( ud n )
.864b		20 79 91	jsr $9179	                jsr w_sign                     ; ( ud )
.864e		20 be 8c	jsr $8cbe	                jsr w_number_sign_greater      ; ( addr u )
.8651		20 e6 94	jsr $94e6	                jsr w_type
.8654		20 f6 91	jsr $91f6	                jsr w_space
.8657		60		rts		z_dot:          rts
.8658						xt_dot_paren:
.8658						w_dot_paren:
.8658		ca		dex		                dex
.8659		ca		dex		                dex
.865a		a9 29		lda #$29	                lda #41     ; Right parenthesis
.865c		95 00		sta $00,x	                sta 0,x
.865e		74 01		stz $01,x	                stz 1,x
.8660		20 d9 8d	jsr $8dd9	                jsr w_parse
.8663		20 e6 94	jsr $94e6	                jsr w_type
.8666		60		rts		z_dot_paren:    rts
.8667						xt_dot_quote:
.8667						w_dot_quote:
.8667		20 01 90	jsr $9001	                jsr w_s_quote
.866a		a0 94		ldy #$94	                ldy #>w_type
.866c		a9 e6		lda #$e6	                lda #<w_type
.866e		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8671		60		rts		z_dot_quote:    rts
.8672						xt_dot_r:
.8672		20 87 d8	jsr $d887	                jsr underflow_2
.8675						w_dot_r:
.8675		20 9a 93	jsr $939a	                jsr w_to_r
.8678		20 a9 86	jsr $86a9	                jsr w_dup
.867b		20 d2 80	jsr $80d2	                jsr w_abs
.867e		20 39 9e	jsr $9e39	                jsr w_zero
.8681		20 fa 89	jsr $89fa	                jsr w_less_number_sign
.8684		20 e0 8c	jsr $8ce0	                jsr w_number_sign_s
.8687		20 bb 8f	jsr $8fbb	                jsr w_rot
.868a		20 79 91	jsr $9179	                jsr w_sign
.868d		20 be 8c	jsr $8cbe	                jsr w_number_sign_greater
.8690		20 18 8f	jsr $8f18	                jsr w_r_from
.8693		20 32 8d	jsr $8d32	                jsr w_over
.8696		20 12 8c	jsr $8c12	                jsr w_minus
.8699		20 ff 91	jsr $91ff	                jsr w_spaces
.869c		20 e6 94	jsr $94e6	                jsr w_type
.869f		60		rts		z_dot_r:        rts
.86a0						xt_drop:
.86a0		20 82 d8	jsr $d882	                jsr underflow_1
.86a3						w_drop:
.86a3		e8		inx		                inx
.86a4		e8		inx		                inx
.86a5		60		rts		z_drop:         rts
.86a6						xt_dup:
.86a6		20 82 d8	jsr $d882	                jsr underflow_1
.86a9						w_dup:
.86a9		ca		dex		                dex
.86aa		ca		dex		                dex
.86ab		b5 02		lda $02,x	                lda 2,x         ; LSB
.86ad		95 00		sta $00,x	                sta 0,x
.86af		b5 03		lda $03,x	                lda 3,x         ; MSB
.86b1		95 01		sta $01,x	                sta 1,x
.86b3		60		rts		z_dup:          rts
.86b4						xt_else:
.86b4						xt_endof:
.86b4		20 82 d8	jsr $d882	                jsr underflow_1
.86b7						w_else:
.86b7						w_endof:
.86b7		20 d8 97	jsr $97d8	                jsr cmpl_jump_later
.86ba		20 5f 92	jsr $925f	                jsr w_swap              ; ( target orig )
.86bd		80 03		bra $86c2	                bra w_then              ; fall through to then
.86bf						xt_then:
.86bf		20 82 d8	jsr $d882	                jsr underflow_1
.86c2						w_then:
.86c2		20 34 89	jsr $8934	                jsr w_here
.86c5		20 5f 92	jsr $925f	                jsr w_swap
.86c8		20 49 92	jsr $9249	                jsr w_store
.86cb						z_else:
.86cb						z_endof:
.86cb		60		rts		z_then:         rts
.86cc						xt_emit:
.86cc		20 82 d8	jsr $d882	                jsr underflow_1
.86cf						w_emit:
.86cf		b5 00		lda $00,x	                lda 0,x
.86d1		e8		inx		                inx
.86d2		e8		inx		                inx
.86d3						emit_a:
.86d3		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.86d6						z_emit:
.86d6						xt_endcase:
.86d6		20 82 d8	jsr $d882	                jsr underflow_1
.86d9						w_endcase:
.86d9		a0 86		ldy #$86	                ldy #>w_drop
.86db		a9 a3		lda #$a3	                lda #<w_drop
.86dd		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.86e0						_endcase_loop:
.86e0		b5 00		lda $00,x	                lda 0,x
.86e2		15 01		ora $01,x	                ora 1,x
.86e4		f0 05		beq $86eb	                beq _done
.86e6		20 c2 86	jsr $86c2	                jsr w_then
.86e9		80 f5		bra $86e0	                bra _endcase_loop
.86eb						_done:
.86eb		e8		inx		                inx
.86ec		e8		inx		                inx
.86ed		60		rts		z_endcase:      rts
.86ee						xt_environment_q:
.86ee		20 82 d8	jsr $d882	                jsr underflow_1
.86f1						w_environment_q:
.86f1		a0 00		ldy #$00	                ldy #00                 ; counter for table
.86f3		5a		phy		                phy
.86f4						_table_loop:
.86f4		20 dc 93	jsr $93dc	                jsr w_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86f7		ca		dex		                dex
.86f8		ca		dex		                dex                     ; ( addr u addr u ? )
.86f9		b9 6b 87	lda $876b,y	                lda env_table_single,y
.86fc		95 00		sta $00,x	                sta 0,x
.86fe		c8		iny		                iny
.86ff		b9 6b 87	lda $876b,y	                lda env_table_single,y
.8702		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8704		c8		iny		                iny
.8705		15 00		ora $00,x	                ora 0,x
.8707		f0 4d		beq $8756	                beq _table_done
.8709		5a		phy		                phy                     ; save Y, which is used by COUNT
.870a		20 29 84	jsr $8429	                jsr w_count            ; ( addr u addr u addr-s u-s )
.870d		20 6a a0	jsr $a06a	                jsr w_compare          ; ( addr u f )
.8710		7a		ply		                ply
.8711		b5 00		lda $00,x	                lda 0,x
.8713		15 01		ora $01,x	                ora 1,x
.8715		f0 04		beq $871b	                beq _got_result
.8717		e8		inx		                inx                     ; DROP, now ( addr u )
.8718		e8		inx		                inx
.8719		80 d9		bra $86f4	                bra _table_loop
.871b						_got_result:
.871b		e8		inx		                inx                     ; drop flag, now ( addr u )
.871c		e8		inx		                inx
.871d		88		dey		                dey                     ; go back to index we had
.871e		88		dey		                dey
.871f		68		pla		                pla
.8720		d0 0d		bne $872f	                bne _double_result
.8722		b9 89 87	lda $8789,y	                lda env_results_single,y
.8725		95 02		sta $02,x	                sta 2,x
.8727		c8		iny		                iny
.8728		b9 89 87	lda $8789,y	                lda env_results_single,y
.872b		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.872d		80 1f		bra $874e	                bra _set_flag
.872f						_double_result:
.872f		ca		dex		                dex                     ; ( addr u ? )
.8730		ca		dex		                dex
.8731		98		tya		                tya
.8732		38		sec		                sec
.8733		e9 18		sbc #$18	                sbc #24
.8735		0a		asl a		                asl
.8736		a8		tay		                tay
.8737		b9 9f 87	lda $879f,y	                lda env_results_double,y
.873a		95 02		sta $02,x	                sta 2,x
.873c		c8		iny		                iny
.873d		b9 9f 87	lda $879f,y	                lda env_results_double,y
.8740		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8742		c8		iny		                iny
.8743		b9 9f 87	lda $879f,y	                lda env_results_double,y
.8746		95 04		sta $04,x	                sta 4,x
.8748		c8		iny		                iny
.8749		b9 9f 87	lda $879f,y	                lda env_results_double,y
.874c		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.874e						_set_flag:
.874e		a9 ff		lda #$ff	                lda #$FF
.8750		95 00		sta $00,x	                sta 0,x
.8752		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8754		80 14		bra $876a	                bra _done
.8756						_table_done:
.8756		68		pla		                pla
.8757		d0 09		bne $8762	                bne _no_match
.8759		1a		inc a		                ina
.875a		48		pha		                pha
.875b		8a		txa		                txa
.875c		18		clc		                clc
.875d		69 06		adc #$06	                adc #6                  ; skip six bytes
.875f		aa		tax		                tax                     ; ( addr u )
.8760		80 92		bra $86f4	                bra _table_loop
.8762						_no_match:
.8762		8a		txa		                txa
.8763		18		clc		                clc
.8764		69 0a		adc #$0a	                adc #10
.8766		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8767		20 39 9e	jsr $9e39	                jsr w_false
.876a						_done:
.876a						z_environment_q:
.876a		60		rts		                rts
.876b						env_table_single:
>876b		6a d6 7a d6 80 d6 85 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8773		97 d6
>8775		9f d6 a8 d6 ae d6 b4 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>877d		c7 d6 d3 d6 00 00		        .word envs_sc, envs_wl, 0000
.8783						env_table_double:
>8783		dd d6 e3 d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8789						env_results_single:
>8789		ff 00				        .word $00FF     ; /COUNTED-STRING
>878b		ff 00				        .word $00FF     ; /HOLD
>878d		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>878f		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8791		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8793		ff 00				        .word $00FF     ; MAX-CHAR
>8795		ff 7f				        .word $7FFF     ; MAX-N
>8797		ff ff				        .word $FFFF     ; MAX-U
>8799		80 00				        .word $0080     ; RETURN-STACK-CELLS
>879b		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>879d		09 00				        .word $0009     ; WORDLISTS
.879f						env_results_double:
>879f		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>87a3		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.87a7						xt_equal:
.87a7		20 87 d8	jsr $d887	                jsr underflow_2
.87aa						w_equal:
.87aa		b5 00		lda $00,x	                lda 0,x                 ; LSB
.87ac		d5 02		cmp $02,x	                cmp 2,x
.87ae		d0 0a		bne $87ba	                bne _false
.87b0		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87b2		d5 03		cmp $03,x	                cmp 3,x
.87b4		d0 04		bne $87ba	                bne _false
.87b6		a9 ff		lda #$ff	                lda #$FF
.87b8		80 02		bra $87bc	                bra _done
.87ba		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.87bc		95 02		sta $02,x	_done:          sta 2,x
.87be		95 03		sta $03,x	                sta 3,x
.87c0		e8		inx		                inx
.87c1		e8		inx		                inx
.87c2		60		rts		z_equal:        rts
.87c3						xt_blank:
.87c3		20 87 d8	jsr $d887	                jsr underflow_2
.87c6						w_blank:
.87c6		ca		dex		                dex
.87c7		ca		dex		                dex
.87c8		a9 20		lda #$20	                lda #AscSP
.87ca		95 00		sta $00,x	                sta 0,x
.87cc		74 01		stz $01,x	                stz 1,x
.87ce		80 0e		bra $87de	                bra w_fill     ; skip over code for ERASE
.87d0						xt_erase:
.87d0		20 87 d8	jsr $d887	                jsr underflow_2
.87d3						w_erase:
.87d3		ca		dex		                dex
.87d4		ca		dex		                dex
.87d5		74 00		stz $00,x	                stz 0,x
.87d7		74 01		stz $01,x	                stz 1,x
.87d9		80 03		bra $87de	                bra w_fill
.87db						xt_fill:
.87db		20 8c d8	jsr $d88c	                jsr underflow_3
.87de						w_fill:
.87de		b5 04		lda $04,x	                lda 4,x         ; LSB
.87e0		85 25		sta $25		                sta tmp1
.87e2		b5 05		lda $05,x	                lda 5,x
.87e4		85 26		sta $26		                sta tmp1+1
.87e6		b5 02		lda $02,x	                lda 2,x
.87e8		85 27		sta $27		                sta tmp2
.87ea		b5 03		lda $03,x	                lda 3,x
.87ec		85 28		sta $28		                sta tmp2+1
.87ee		b5 00		lda $00,x	                lda 0,x
.87f0		a8		tay		                tay
.87f1						_loop:
.87f1		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87f3		c5 26		cmp $26		                cmp tmp1+1
.87f5		90 21		bcc $8818	                bcc _done               ; RAM_END < TMP1, so leave
.87f7		d0 06		bne $87ff	                bne _check_counter      ; RAM_END is not smaller and not equal
.87f9		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87fb		c5 25		cmp $25		                cmp tmp1
.87fd		90 19		bcc $8818	                bcc _done               ; RAM_END < TMP1, so leave
.87ff						_check_counter:
.87ff		a5 27		lda $27		                lda tmp2
.8801		05 28		ora $28		                ora tmp2+1
.8803		f0 13		beq $8818	                beq _done
.8805		98		tya		                tya
.8806		92 25		sta ($25)	                sta (tmp1)
.8808		a5 27		lda $27		                lda tmp2
.880a		d0 02		bne $880e	                bne +
.880c		c6 28		dec $28		                dec tmp2+1
.880e		c6 27		dec $27		+               dec tmp2
.8810		e6 25		inc $25		                inc tmp1
.8812		d0 dd		bne $87f1	                bne _loop
.8814		e6 26		inc $26		                inc tmp1+1
.8816		80 d9		bra $87f1	                bra _loop
.8818						_done:
.8818		8a		txa		                txa
.8819		18		clc		                clc
.881a		69 06		adc #$06	                adc #6
.881c		aa		tax		                tax
.881d						z_blank:
.881d						z_erase:
.881d		60		rts		z_fill:         rts
.881e						xt_execute:
.881e		20 82 d8	jsr $d882	                jsr underflow_1
.8821						w_execute:
.8821		20 25 88	jsr $8825	                jsr doexecute   ; do not combine to JMP (native coding)
.8824		60		rts		z_execute:      rts
.8825						doexecute:
.8825		b5 00		lda $00,x	                lda 0,x
.8827		85 04		sta $04		                sta ip
.8829		b5 01		lda $01,x	                lda 1,x
.882b		85 05		sta $05		                sta ip+1
.882d		e8		inx		                inx
.882e		e8		inx		                inx
.882f		6c 04 00	jmp ($0004)	                jmp (ip)
.8832						xt_exit:
.8832						w_exit:
.8832		60		rts		                rts             ; keep before z_exit
.8833						z_exit:
.8833						xt_fetch:
.8833		20 82 d8	jsr $d882	                jsr underflow_1
.8836						w_fetch:
.8836		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8838		a8		tay		                tay
.8839		f6 00		inc $00,x	                inc 0,x
.883b		d0 02		bne $883f	                bne +
.883d		f6 01		inc $01,x	                inc 1,x
.883f						+
.883f		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8841		95 01		sta $01,x	                sta 1,x
.8843		94 00		sty $00,x	                sty 0,x
.8845		60		rts		z_fetch:        rts
.8846						xt_find:
.8846		20 82 d8	jsr $d882	                jsr underflow_1
.8849						w_find:
.8849		b5 01		lda $01,x	                lda 1,x                 ; MSB
.884b		48		pha		                pha
.884c		b5 00		lda $00,x	                lda 0,x                 ; LSB
.884e		48		pha		                pha
.884f		20 29 84	jsr $8429	                jsr w_count            ; ( caddr -- addr u )
.8852		20 30 9b	jsr $9b30	                jsr w_find_name        ; ( addr u -- nt | 0 )
.8855		b5 00		lda $00,x	                lda 0,x
.8857		15 01		ora $01,x	                ora 1,x
.8859		d0 0b		bne $8866	                bne _found_word
.885b		20 39 9e	jsr $9e39	                jsr w_false            ; ( 0 0 )
.885e		68		pla		                pla                     ; LSB of address
.885f		95 02		sta $02,x	                sta 2,x
.8861		68		pla		                pla
.8862		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8864		80 27		bra $888d	                bra _done               ; ( addr 0 )
.8866						_found_word:
.8866		68		pla		                pla
.8867		68		pla		                pla
.8868		20 a9 86	jsr $86a9	                jsr w_dup              ; ( nt nt )
.886b		20 79 9c	jsr $9c79	                jsr w_name_to_int      ; ( nt xt )
.886e		20 5f 92	jsr $925f	                jsr w_swap             ; ( xt nt )
.8871		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8873		f6 00		inc $00,x	                inc 0,x
.8875		d0 02		bne $8879	                bne +
.8877		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8879						+
.8879		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.887b		29 04		and #$04	                and #IM
.887d		d0 08		bne $8887	                bne _immediate          ; bit set, we're immediate
.887f		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8881		95 00		sta $00,x	                sta 0,x
.8883		95 01		sta $01,x	                sta 1,x
.8885		80 06		bra $888d	                bra _done
.8887						_immediate:
.8887		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8889		95 00		sta $00,x	                sta 0,x
.888b		74 01		stz $01,x	                stz 1,x
.888d						_done:
.888d		60		rts		z_find:         rts
.888e						xt_fm_slash_mod:
.888e		20 8c d8	jsr $d88c	                jsr underflow_3
.8891						w_fm_slash_mod:
.8891		64 27		stz $27		                stz tmp2        ; default: n is positive
.8893		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8895		10 0e		bpl $88a5	                bpl _check_d
.8897		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.8899		20 50 8c	jsr $8c50	                jsr w_negate   ; NEGATE
.889c		20 9a 93	jsr $939a	                jsr w_to_r     ; >R
.889f		20 aa 9e	jsr $9eaa	                jsr w_dnegate  ; DNEGATE
.88a2		20 18 8f	jsr $8f18	                jsr w_r_from   ; R>
.88a5						_check_d:
.88a5		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.88a7		10 0d		bpl $88b6	                bpl _multiply
.88a9		18		clc		                clc
.88aa		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.88ac		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.88ae		95 02		sta $02,x	                sta 2,x
.88b0		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.88b2		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.88b4		95 03		sta $03,x	                sta 3,x
.88b6						_multiply:
.88b6		20 6b 95	jsr $956b	                jsr w_um_slash_mod     ; ( d n1 -- rem n2 )
.88b9		a5 27		lda $27		                lda tmp2
.88bb		f0 07		beq $88c4	                beq _done
.88bd		e8		inx		                inx             ; pretend that we SWAP
.88be		e8		inx		                inx
.88bf		20 50 8c	jsr $8c50	                jsr w_negate
.88c2		ca		dex		                dex
.88c3		ca		dex		                dex
.88c4						_done:
.88c4		60		rts		z_fm_slash_mod: rts
.88c5						load_evaluate:
.88c5		a9 ff		lda #$ff	                lda #$FF
.88c7		85 25		sta $25		                sta tmp1
.88c9		80 11		bra $88dc	                bra load_evaluate_start
.88cb						xt_evaluate:
.88cb		20 87 d8	jsr $d887	                jsr underflow_2
.88ce						w_evaluate:
.88ce		64 25		stz $25		                stz tmp1
.88d0		b5 00		lda $00,x	                lda 0,x
.88d2		15 01		ora $01,x	                ora 1,x
.88d4		d0 06		bne $88dc	                bne evaluate_got_work
.88d6		e8		inx		                inx
.88d7		e8		inx		                inx
.88d8		e8		inx		                inx
.88d9		e8		inx		                inx
.88da		80 42		bra $891e	                bra evaluate_done
.88dc						load_evaluate_start:
.88dc						evaluate_got_work:
.88dc		a0 05		ldy #$05	                ldy #blk_offset+1
.88de		b1 08		lda ($08),y	                lda (up),y
.88e0		48		pha		                pha
.88e1		88		dey		                dey
.88e2		b1 08		lda ($08),y	                lda (up),y
.88e4		48		pha		                pha
.88e5		a5 25		lda $25		                lda tmp1
.88e7		d0 05		bne $88ee	                bne _nozero
.88e9		91 08		sta ($08),y	                sta (up),y
.88eb		c8		iny		                iny
.88ec		91 08		sta ($08),y	                sta (up),y
.88ee						_nozero:
.88ee		20 da 9b	jsr $9bda	                jsr w_input_to_r
.88f1		a9 ff		lda #$ff	                lda #$FF
.88f3		85 0a		sta $0a		                sta insrc
.88f5		85 0b		sta $0b		                sta insrc+1
.88f7		64 10		stz $10		                stz toin
.88f9		64 11		stz $11		                stz toin+1
.88fb		b5 00		lda $00,x	                lda 0,x
.88fd		85 0e		sta $0e		                sta ciblen
.88ff		b5 01		lda $01,x	                lda 1,x
.8901		85 0f		sta $0f		                sta ciblen+1
.8903		b5 02		lda $02,x	                lda 2,x
.8905		85 0c		sta $0c		                sta cib
.8907		b5 03		lda $03,x	                lda 3,x
.8909		85 0d		sta $0d		                sta cib+1
.890b		e8		inx		                inx             ; A clean stack is a clean mind
.890c		e8		inx		                inx
.890d		e8		inx		                inx
.890e		e8		inx		                inx
.890f		20 ff d7	jsr $d7ff	                jsr interpret   ; ( -- )
.8912		20 e7 9d	jsr $9de7	                jsr w_r_to_input
.8915		a0 04		ldy #$04	                ldy #blk_offset
.8917		68		pla		                pla
.8918		91 08		sta ($08),y	                sta (up),y
.891a		c8		iny		                iny
.891b		68		pla		                pla
.891c		91 08		sta ($08),y	                sta (up),y
.891e						evaluate_done:
.891e		60		rts		z_evaluate:     rts
.891f						xt_greater_than:
.891f		20 87 d8	jsr $d887	                jsr underflow_2
.8922						w_greater_than:
.8922		a0 00		ldy #$00	                ldy #0          ; default false
.8924		20 c0 d7	jsr $d7c0	                jsr compare_16bit
.8927		f0 03		beq $892c	                beq _false
.8929		10 01		bpl $892c	                bpl _false
.892b		88		dey		                dey
.892c						_false:
.892c		98		tya		                tya
.892d		e8		inx		                inx
.892e		e8		inx		                inx
.892f		95 00		sta $00,x	                sta 0,x
.8931		95 01		sta $01,x	                sta 1,x
.8933		60		rts		z_greater_than: rts
.8934						xt_here:
.8934						xt_begin:
.8934						xt_asm_arrow:
.8934						w_here:
.8934						w_begin:
.8934						w_asm_arrow:
.8934		ca		dex		                dex
.8935		ca		dex		                dex
.8936		a5 00		lda $00		                lda cp
.8938		95 00		sta $00,x	                sta 0,x
.893a		a5 01		lda $01		                lda cp+1
.893c		95 01		sta $01,x	                sta 1,x
.893e						z_here:
.893e						z_begin:
.893e						z_asm_arrow:
.893e		60		rts		                rts
.893f						xt_hex:
.893f						w_hex:
.893f		a9 10		lda #$10	                lda #16
.8941		85 18		sta $18		                sta base
.8943		64 19		stz $19		                stz base+1              ; paranoid
.8945		60		rts		z_hex:          rts
.8946						xt_hold:
.8946		20 82 d8	jsr $d882	                jsr underflow_1
.8949						w_hold:
.8949		a5 2b		lda $2b		                lda tohold
.894b		d0 02		bne $894f	                bne +
.894d		c6 2c		dec $2c		                dec tohold+1
.894f						+
.894f		c6 2b		dec $2b		                dec tohold
.8951		b5 00		lda $00,x	                lda 0,x
.8953		92 2b		sta ($2b)	                sta (tohold)
.8955		e8		inx		                inx
.8956		e8		inx		                inx
.8957		60		rts		z_hold:         rts
.8958						xt_i:
.8958						w_i:
.8958		ca		dex		                dex
.8959		ca		dex		                dex
.895a		a4 1f		ldy $1f		                ldy loopctrl
.895c		38		sec		                sec
.895d		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.895f		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8962		95 00		sta $00,x	                sta 0,x
.8964		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8967		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.896a		95 01		sta $01,x	                sta 1,x
.896c		60		rts		z_i:            rts
.896d						xt_if:
.896d						w_if:
.896d		20 f4 97	jsr $97f4	                jsr cmpl_0branch_later
.8970		60		rts		z_if:           rts
.8971						xt_immediate:
.8971						w_immediate:
.8971		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.8974		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8976		b1 02		lda ($02),y	                lda (dp),y
.8978		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.897a		91 02		sta ($02),y	                sta (dp),y
.897c		60		rts		z_immediate:    rts
.897d						xt_invert:
.897d		20 82 d8	jsr $d882	                jsr underflow_1
.8980						w_invert:
.8980		a9 ff		lda #$ff	                lda #$FF
.8982		55 00		eor $00,x	                eor 0,x         ; LSB
.8984		95 00		sta $00,x	                sta 0,x
.8986		a9 ff		lda #$ff	                lda #$FF
.8988		55 01		eor $01,x	                eor 1,x         ; MSB
.898a		95 01		sta $01,x	                sta 1,x
.898c		60		rts		z_invert:       rts
.898d						xt_is:
.898d						w_is:
.898d		a5 1a		lda $1a		                lda state
.898f		05 1b		ora $1b		                ora state+1
.8991		f0 0c		beq $899f	                beq _interpreting
.8993		20 14 83	jsr $8314	                jsr w_bracket_tick
.8996		a0 85		ldy #$85	                ldy #>w_defer_store
.8998		a9 51		lda #$51	                lda #<w_defer_store
.899a		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.899d		80 06		bra $89a5	                bra _done
.899f						_interpreting:
.899f		20 70 92	jsr $9270	                jsr w_tick
.89a2		20 51 85	jsr $8551	                jsr w_defer_store
.89a5						_done:
.89a5		60		rts		z_is:           rts
.89a6						xt_j:
.89a6						w_j:
.89a6		ca		dex		                dex                 ; make space on the stack
.89a7		ca		dex		                dex
.89a8		a5 1f		lda $1f		                lda loopctrl
.89aa		38		sec		                sec
.89ab		e9 04		sbc #$04	                sbc #4
.89ad		a8		tay		                tay
.89ae		38		sec		                sec
.89af		b9 00 01	lda $0100,y	                lda loopindex,y
.89b2		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.89b5		95 00		sta $00,x	                sta 0,x
.89b7		b9 01 01	lda $0101,y	                lda loopindex+1,y
.89ba		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.89bd		95 01		sta $01,x	                sta 1,x
.89bf		60		rts		z_j:            rts
.89c0						xt_key:
.89c0						w_key:
.89c0		20 ca 89	jsr $89ca	                jsr key_a               ; returns char in A
.89c3		ca		dex		                dex
.89c4		ca		dex		                dex
.89c5		95 00		sta $00,x	                sta 0,x
.89c7		74 01		stz $01,x	                stz 1,x
.89c9		60		rts		z_key:          rts
.89ca						key_a:
.89ca		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.89cd						xt_keyq:
.89cd						w_keyq:
.89cd		a0 00		ldy #$00	                ldy #0
.89cf		20 dc 89	jsr $89dc	                jsr keyq_a
.89d2		f0 01		beq $89d5	                beq +           ; A=0 => Y=0
.89d4		88		dey		                dey             ; A<>0 => Y=#$ff
.89d5						+
.89d5		ca		dex		                dex
.89d6		ca		dex		                dex
.89d7		94 00		sty $00,x	                sty 0,x         ; store either $0000 or $ffff
.89d9		94 01		sty $01,x	                sty 1,x
.89db		60		rts		z_keyq:         rts
.89dc		6c 16 00	jmp ($0016)	keyq_a:         jmp (havekey)
.89df						xt_leave:
.89df						w_leave:
.89df		a5 21		lda $21		                lda loopleave
.89e1		a4 22		ldy $22		                ldy loopleave+1
.89e3		20 bc 97	jsr $97bc	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.89e6		38		sec		                sec
.89e7		a5 00		lda $00		                lda cp
.89e9		e9 02		sbc #$02	                sbc #2
.89eb		85 21		sta $21		                sta loopleave
.89ed		a5 01		lda $01		                lda cp+1
.89ef		b0 01		bcs $89f2	                bcs +
.89f1		3a		dec a		                dea
.89f2		85 22		sta $22		+               sta loopleave+1
.89f4						z_leave:
.89f4		60		rts		                rts
.89f5						xt_left_bracket:
.89f5						w_left_bracket:
.89f5		64 1a		stz $1a		                stz state
.89f7		64 1b		stz $1b		                stz state+1
.89f9		60		rts		z_left_bracket: rts
.89fa						xt_less_number_sign:
.89fa						w_less_number_sign:
.89fa		20 3d 8d	jsr $8d3d	                jsr w_pad      ; ( addr )
.89fd		b5 00		lda $00,x	                lda 0,x
.89ff		85 2b		sta $2b		                sta tohold
.8a01		b5 01		lda $01,x	                lda 1,x
.8a03		85 2c		sta $2c		                sta tohold+1
.8a05		e8		inx		                inx
.8a06		e8		inx		                inx
.8a07						z_less_number_sign:
.8a07		60		rts		                rts
.8a08						xt_less_than:
.8a08		20 87 d8	jsr $d887	                jsr underflow_2
.8a0b						w_less_than:
.8a0b		a0 00		ldy #$00	                ldy #0          ; default false
.8a0d		20 c0 d7	jsr $d7c0	                jsr compare_16bit
.8a10		f0 03		beq $8a15	                beq _false
.8a12		30 01		bmi $8a15	                bmi _false
.8a14		88		dey		                dey
.8a15						_false:
.8a15		98		tya		                tya
.8a16		e8		inx		                inx
.8a17		e8		inx		                inx
.8a18		95 00		sta $00,x	                sta 0,x
.8a1a		95 01		sta $01,x	                sta 1,x
.8a1c		60		rts		z_less_than:    rts
.8a1d						xt_literal:
.8a1d		20 82 d8	jsr $d882	                jsr underflow_1
.8a20						w_literal:
.8a20		a9 0a		lda #$0a	                lda #template_push_tos_size
.8a22		20 e2 97	jsr $97e2	                jsr check_nc_limit
.8a25		90 0c		bcc $8a33	                bcc _inline
.8a27		a0 8a		ldy #$8a	                ldy #>literal_runtime
.8a29		a9 65		lda #$65	                lda #<literal_runtime
.8a2b		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8a2e		20 d0 83	jsr $83d0	                jsr w_comma
.8a31		80 27		bra $8a5a	                bra z_literal
.8a33						_inline:
.8a33		a0 94		ldy #$94	                ldy #$94        ; STY opcode
.8a35		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a37		d0 02		bne $8a3b	                bne +
.8a39		a0 74		ldy #$74	                ldy #$74        ; STZ opcode
.8a3b		5a		phy		+               phy
.8a3c		b5 00		lda $00,x	                lda 0,x         ; LSB
.8a3e		48		pha		                pha
.8a3f		a0 02		ldy #$02	                ldy #2
.8a41		b5 01		lda $01,x	                lda 1,x         ; MSB
.8a43		f0 03		beq $8a48	                beq _copy
.8a45		a0 00		ldy #$00	                ldy #0
.8a47		48		pha		                pha
.8a48		b9 5b 8a	lda $8a5b,y	_copy:          lda template_push_tos,y
.8a4b		c9 ff		cmp #$ff	                cmp #$ff        ; is it a placeholder?
.8a4d		d0 01		bne $8a50	                bne +
.8a4f		68		pla		                pla
.8a50		20 c7 97	jsr $97c7	+               jsr cmpl_a
.8a53		c8		iny		                iny
.8a54		c0 0a		cpy #$0a	                cpy #template_push_tos_size
.8a56		d0 f0		bne $8a48	                bne _copy
.8a58		e8		inx		                inx             ; drop the literal
.8a59		e8		inx		                inx
.8a5a		60		rts		z_literal:      rts
.8a5b						template_push_tos:
.8a5b		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a5d		a9 ff		lda #$ff	                lda #$ff
.8a5f		ca		dex		                dex
.8a60		ca		dex		                dex
.8a61		95 00		sta $00,x	                sta 0,x
>8a63		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
=10						template_push_tos_size = * - template_push_tos
.8a65						literal_runtime:
.8a65		ca		dex		                dex
.8a66		ca		dex		                dex
.8a67		68		pla		                pla             ; LSB
.8a68		85 25		sta $25		                sta tmp1
.8a6a		68		pla		                pla             ; MSB
.8a6b		85 26		sta $26		                sta tmp1+1
.8a6d		a0 01		ldy #$01	                ldy #1
.8a6f		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a71		95 00		sta $00,x	                sta 0,x
.8a73		c8		iny		                iny
.8a74		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a76		95 01		sta $01,x	                sta 1,x
.8a78		98		tya		                tya
.8a79		18		clc		                clc
.8a7a		65 25		adc $25		                adc tmp1
.8a7c		a8		tay		                tay
.8a7d		a5 26		lda $26		                lda tmp1+1
.8a7f		69 00		adc #$00	                adc #0
.8a81		48		pha		                pha
.8a82		5a		phy		                phy
.8a83		60		rts		                rts
.8a84						xt_loop:
.8a84						w_loop:
.8a84		ca		dex		                dex
.8a85		ca		dex		                dex
.8a86		ca		dex		                dex
.8a87		ca		dex		                dex
.8a88		a9 fd		lda #$fd	                lda #<loop_runtime
.8a8a		95 02		sta $02,x	                sta 2,x
.8a8c		a9 8a		lda #$8a	                lda #>loop_runtime
.8a8e		95 03		sta $03,x	                sta 3,x
.8a90		a9 11		lda #$11	                lda #loop_runtime_size
.8a92		95 00		sta $00,x	                sta 0,x
.8a94		74 01		stz $01,x	                stz 1,x
.8a96		80 12		bra $8aaa	                bra loop_common
.8a98						xt_plus_loop:
.8a98						w_plus_loop:
.8a98		ca		dex		                dex
.8a99		ca		dex		                dex
.8a9a		ca		dex		                dex
.8a9b		ca		dex		                dex
.8a9c		a9 16		lda #$16	                lda #<plus_loop_runtime
.8a9e		95 02		sta $02,x	                sta 2,x
.8aa0		a9 8b		lda #$8b	                lda #>plus_loop_runtime
.8aa2		95 03		sta $03,x	                sta 3,x
.8aa4		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8aa6		95 00		sta $00,x	                sta 0,x
.8aa8		74 01		stz $01,x	                stz 1,x
.8aaa						loop_common:
.8aaa		20 32 8d	jsr $8d32	                jsr w_over
.8aad		20 5f 92	jsr $925f	                jsr w_swap             ; xt and xt' are the same
.8ab0		20 3f 97	jsr $973f	                jsr cmpl_by_limit
.8ab3		90 05		bcc $8aba	                bcc _native
.8ab5		20 d0 83	jsr $83d0	                jsr w_comma
.8ab8		80 03		bra $8abd	                bra +
.8aba						_native:
.8aba		20 d0 97	jsr $97d0	                jsr cmpl_jump_tos
.8abd						+
.8abd		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8abf		f0 19		beq $8ada	                beq _noleave
.8ac1						_next:
.8ac1		a0 01		ldy #$01	                ldy #1
.8ac3		b1 21		lda ($21),y	                lda (loopleave),y
.8ac5		48		pha		                pha
.8ac6		a5 01		lda $01		                lda cp+1
.8ac8		91 21		sta ($21),y	                sta (loopleave),y
.8aca		88		dey		                dey
.8acb		b1 21		lda ($21),y	                lda (loopleave),y
.8acd		48		pha		                pha
.8ace		a5 00		lda $00		                lda cp
.8ad0		91 21		sta ($21),y	                sta (loopleave),y
.8ad2		68		pla		                pla
.8ad3		85 21		sta $21		                sta loopleave
.8ad5		68		pla		                pla
.8ad6		85 22		sta $22		                sta loopleave+1
.8ad8		d0 e7		bne $8ac1	                bne _next
.8ada						_noleave:
.8ada		b5 00		lda $00,x	                lda 0,x
.8adc		85 21		sta $21		                sta loopleave
.8ade		b5 01		lda $01,x	                lda 1,x
.8ae0		85 22		sta $22		                sta loopleave+1
.8ae2		a9 f0		lda #$f0	                lda #<w_unloop
.8ae4		95 00		sta $00,x	                sta 0,x
.8ae6		a9 95		lda #$95	                lda #>w_unloop
.8ae8		95 01		sta $01,x	                sta 1,x
.8aea		20 ef 96	jsr $96ef	                jsr w_compile_comma
.8aed		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8aef		f0 09		beq $8afa	                beq +
.8af1		20 34 89	jsr $8934	                jsr w_here
.8af4		20 5f 92	jsr $925f	                jsr w_swap
.8af7		4c 49 92	jmp $9249	                jmp w_store            ; write here as ?DO jmp target and return
.8afa		e8		inx		+               inx                     ; drop the ignored word for DO
.8afb		e8		inx		                inx
.8afc						z_loop:
.8afc		60		rts		z_plus_loop:    rts
.8afd						loop_runtime:
.8afd		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8aff		d0 0d		bne $8b0e	                bne _repeat             ; avoid expensive test most of the time
.8b01		a4 1f		ldy $1f		                ldy loopctrl
.8b03		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8b06		1a		inc a		                ina
.8b07		c9 80		cmp #$80	                cmp #$80
.8b09		f0 06		beq $8b11	                beq _done
.8b0b		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8b0e						_repeat:
.8b0e		a9 00		lda #$00	                lda #0
>8b10		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8b11		a9 01		lda #$01	_done:          lda #1
.8b13		4c 71 98	jmp $9871	                jmp zbranch_runtime
.8b16						plus_loop_runtime:
.8b16		18		clc		                clc
.8b17		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8b19		65 20		adc $20		                adc loopidx0
.8b1b		85 20		sta $20		                sta loopidx0
.8b1d		e8		inx		                inx                     ; dump step from TOS before MSB test
.8b1e		e8		inx		                inx                     ; since we might skip it
.8b1f		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8b21		d0 02		bne $8b25	                bne _chkv               ; if it's non-zero we have to check
.8b23		90 0b		bcc $8b30	                bcc _repeat             ; but if 0 and no carry, we're good
.8b25		b8		clv		_chkv:          clv
.8b26		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8b28		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8b2b		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8b2e		70 03		bvs $8b33	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8b30						_repeat:
.8b30		a9 00		lda #$00	                lda #0
>8b32		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8b33		a9 01		lda #$01	_done:          lda #1
.8b35		4c 71 98	jmp $9871	                jmp zbranch_runtime
.8b38						xt_lshift:
.8b38		20 87 d8	jsr $d887	                jsr underflow_2
.8b3b						w_lshift:
.8b3b		b5 00		lda $00,x	                lda 0,x
.8b3d		29 0f		and #$0f	                and #%00001111
.8b3f		f0 08		beq $8b49	                beq _done
.8b41		a8		tay		                tay
.8b42						_loop:
.8b42		16 02		asl $02,x	                asl 2,x
.8b44		36 03		rol $03,x	                rol 3,x
.8b46		88		dey		                dey
.8b47		d0 f9		bne $8b42	                bne _loop
.8b49						_done:
.8b49		e8		inx		                inx
.8b4a		e8		inx		                inx
.8b4b		60		rts		z_lshift:       rts
.8b4c						xt_m_star:
.8b4c		20 87 d8	jsr $d887	                jsr underflow_2
.8b4f						w_m_star:
.8b4f		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b51		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b53		48		pha		                pha
.8b54		20 d2 80	jsr $80d2	                jsr w_abs
.8b57		20 5f 92	jsr $925f	                jsr w_swap
.8b5a		20 d2 80	jsr $80d2	                jsr w_abs
.8b5d		20 ad 95	jsr $95ad	                jsr w_um_star          ; ( d )
.8b60		68		pla		                pla
.8b61		10 03		bpl $8b66	                bpl _done
.8b63		20 aa 9e	jsr $9eaa	                jsr w_dnegate
.8b66						_done:
.8b66		60		rts		z_m_star:       rts
.8b67						xt_marker:
.8b67						w_marker:
.8b67		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.8b6a		a5 02		lda $02		                lda dp
.8b6c		48		pha		                pha
.8b6d		a5 03		lda $03		                lda dp+1
.8b6f		48		pha		                pha
.8b70		a5 00		lda $00		                lda cp
.8b72		48		pha		                pha
.8b73		a5 01		lda $01		                lda cp+1
.8b75		48		pha		                pha
.8b76		20 40 84	jsr $8440	                jsr w_create
.8b79		a5 00		lda $00		                lda cp          ; LSB
.8b7b		38		sec		                sec
.8b7c		e9 02		sbc #$02	                sbc #2
.8b7e		85 00		sta $00		                sta cp
.8b80		b0 02		bcs $8b84	                bcs +
.8b82		c6 01		dec $01		                dec cp+1        ; we only care about the borrow
.8b84						+
.8b84		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b86		a9 a2		lda #$a2	                lda #<marker_runtime
.8b88		20 c3 97	jsr $97c3	                jsr cmpl_word
.8b8b		7a		ply		                ply                     ; MSB
.8b8c		68		pla		                pla                     ; LSB
.8b8d		20 c3 97	jsr $97c3	                jsr cmpl_word
.8b90		7a		ply		                ply                     ; MSB
.8b91		68		pla		                pla                     ; LSB
.8b92		20 c3 97	jsr $97c3	                jsr cmpl_word
.8b95		a0 08		ldy #$08	                ldy #marker_start_offset
.8b97						-
.8b97		b1 08		lda ($08),y	                lda (up),y
.8b99		20 c7 97	jsr $97c7	                jsr cmpl_a
.8b9c		c8		iny		                iny
.8b9d		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b9f		d0 f6		bne $8b97	                bne -
.8ba1		60		rts		z_marker:       rts
.8ba2						marker_runtime:
.8ba2		68		pla		                pla
.8ba3		85 25		sta $25		                sta tmp1        ; LSB of address
.8ba5		68		pla		                pla
.8ba6		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8ba8		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8baa		b1 25		lda ($25),y	                lda (tmp1),y
.8bac		85 00		sta $00		                sta cp
.8bae		c8		iny		                iny
.8baf		b1 25		lda ($25),y	                lda (tmp1),y
.8bb1		85 01		sta $01		                sta cp+1
.8bb3		c8		iny		                iny
.8bb4		b1 25		lda ($25),y	                lda (tmp1),y
.8bb6		85 02		sta $02		                sta dp
.8bb8		c8		iny		                iny
.8bb9		b1 25		lda ($25),y	                lda (tmp1),y
.8bbb		85 03		sta $03		                sta dp+1
.8bbd		38		sec		                sec
.8bbe		a5 25		lda $25		                lda tmp1
.8bc0		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8bc2		85 25		sta $25		                sta tmp1
.8bc4		b0 02		bcs $8bc8	                bcs +
.8bc6		c6 26		dec $26		                dec tmp1+1
.8bc8						+
.8bc8		a0 08		ldy #$08	                ldy #marker_start_offset
.8bca						-
.8bca		b1 25		lda ($25),y	                lda (tmp1),y
.8bcc		91 08		sta ($08),y	                sta (up),y
.8bce		c8		iny		                iny
.8bcf		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8bd1		d0 f7		bne $8bca	                bne -
.8bd3		20 ec d7	jsr $d7ec	                jsr dp_to_current       ; Move the CURRENT DP back.
.8bd6		60		rts		                rts
.8bd7						xt_max:
.8bd7		20 87 d8	jsr $d887	                jsr underflow_2
.8bda						w_max:
.8bda		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bdc		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8bde		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8be0		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8be2		50 02		bvc $8be6	                bvc _no_overflow
.8be4		49 80		eor #$80	                eor #$80        ; complement negative flag
.8be6						_no_overflow:
.8be6		30 08		bmi $8bf0	                bmi _keep_nos
.8be8		b5 00		lda $00,x	                lda 0,x
.8bea		95 02		sta $02,x	                sta 2,x
.8bec		b5 01		lda $01,x	                lda 1,x
.8bee		95 03		sta $03,x	                sta 3,x
.8bf0						_keep_nos:
.8bf0		e8		inx		                inx
.8bf1		e8		inx		                inx
.8bf2		60		rts		z_max:          rts
.8bf3						xt_min:
.8bf3		20 87 d8	jsr $d887	                jsr underflow_2
.8bf6						w_min:
.8bf6		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8bf8		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8bfa		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8bfc		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8bfe		50 02		bvc $8c02	                bvc _no_overflow
.8c00		49 80		eor #$80	                eor #$80
.8c02						_no_overflow:
.8c02		10 08		bpl $8c0c	                bpl _keep_nos
.8c04		b5 00		lda $00,x	                lda 0,x
.8c06		95 02		sta $02,x	                sta 2,x
.8c08		b5 01		lda $01,x	                lda 1,x
.8c0a		95 03		sta $03,x	                sta 3,x
.8c0c						_keep_nos:
.8c0c		e8		inx		                inx
.8c0d		e8		inx		                inx
.8c0e		60		rts		z_min:          rts
.8c0f						xt_minus:
.8c0f		20 87 d8	jsr $d887	                jsr underflow_2
.8c12						w_minus:
.8c12		38		sec		                sec
.8c13		b5 02		lda $02,x	                lda 2,x         ; LSB
.8c15		f5 00		sbc $00,x	                sbc 0,x
.8c17		95 02		sta $02,x	                sta 2,x
.8c19		b5 03		lda $03,x	                lda 3,x         ; MSB
.8c1b		f5 01		sbc $01,x	                sbc 1,x
.8c1d		95 03		sta $03,x	                sta 3,x
.8c1f		e8		inx		                inx
.8c20		e8		inx		                inx
.8c21		60		rts		z_minus:        rts
.8c22						xt_mod:
.8c22		20 87 d8	jsr $d887	                jsr underflow_2
.8c25						w_mod:
.8c25		20 95 91	jsr $9195	                jsr w_slash_mod
.8c28		e8		inx		                inx             ; DROP
.8c29		e8		inx		                inx
.8c2a						z_mod:
.8c2a		60		rts		                rts
.8c2b						xt_move:
.8c2b		20 8c d8	jsr $d88c	                jsr underflow_3
.8c2e						w_move:
.8c2e		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8c30		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8c32		f0 05		beq $8c39	                beq _lsb                ; wasn't helpful, move to LSB
.8c34		b0 0e		bcs $8c44	                bcs _to_move_up         ; we want CMOVE>
.8c36		4c f4 9f	jmp $9ff4	                jmp w_cmove            ; JSR/RTS
.8c39						_lsb:
.8c39		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8c3b		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8c3d		f0 08		beq $8c47	                beq _equal              ; LSB is equal as well
.8c3f		b0 03		bcs $8c44	                bcs _to_move_up         ; we want CMOVE>
.8c41		4c f4 9f	jmp $9ff4	                jmp w_cmove            ; JSR/RTS
.8c44						_to_move_up:
.8c44		4c 2f a0	jmp $a02f	                jmp w_cmove_up         ; JSR/RTS
.8c47						_equal:
.8c47		8a		txa		                txa
.8c48		18		clc		                clc
.8c49		69 06		adc #$06	                adc #6
.8c4b		aa		tax		                tax
.8c4c		60		rts		z_move:         rts
.8c4d						xt_negate:
.8c4d		20 82 d8	jsr $d882	                jsr underflow_1
.8c50						w_negate:
.8c50		a9 00		lda #$00	        	lda #0
.8c52		38		sec		                sec
.8c53		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8c55		95 00		sta $00,x	                sta 0,x
.8c57		a9 00		lda #$00	                lda #0
.8c59		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c5b		95 01		sta $01,x	                sta 1,x
.8c5d		60		rts		z_negate:       rts
.8c5e						xt_nip:
.8c5e		20 87 d8	jsr $d887	                jsr underflow_2
.8c61						w_nip:
.8c61		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c63		95 02		sta $02,x	                sta 2,x
.8c65		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c67		95 03		sta $03,x	                sta 3,x
.8c69		e8		inx		                inx
.8c6a		e8		inx		                inx
.8c6b		60		rts		z_nip:          rts
.8c6c						xt_not_equals:
.8c6c		20 87 d8	jsr $d887	                jsr underflow_2
.8c6f						w_not_equals:
.8c6f		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c71		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c73		d5 02		cmp $02,x	                cmp 2,x
.8c75		d0 0a		bne $8c81	                bne _not_equal
.8c77		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c79		d5 03		cmp $03,x	                cmp 3,x
.8c7b		d0 04		bne $8c81	                bne _not_equal
.8c7d		a9 ff		lda #$ff	                lda #$FF
.8c7f		80 01		bra $8c82	                bra _done
.8c81						_not_equal:
.8c81		88		dey		                dey                     ; drop thru to done
.8c82						_done:
.8c82		98		tya		                tya
.8c83		e8		inx		                inx
.8c84		e8		inx		                inx
.8c85		95 00		sta $00,x	                sta 0,x
.8c87		95 01		sta $01,x	                sta 1,x
.8c89		60		rts		z_not_equals:   rts
.8c8a						xt_number_sign:
.8c8a		20 87 d8	jsr $d887	                jsr underflow_2         ; double number
.8c8d						w_number_sign:
.8c8d		ca		dex		                dex                     ; inline w_zero
.8c8e		ca		dex		                dex
.8c8f		74 00		stz $00,x	                stz 0,x
.8c91		74 01		stz $01,x	                stz 1,x
.8c93		e6 19		inc $19		                inc base+1
.8c95		b5 02		lda $02,x	                lda 2,x                 ; if msw is 0 we can skip the first pass
.8c97		15 03		ora $03,x	                ora 3,x
.8c99		f0 0b		beq $8ca6	                beq _skip               ; enter with ( v 0 0 -rot -- 0 v 0 )
.8c9b						_loop:
.8c9b		ca		dex		                dex                     ; inline `base @`
.8c9c		ca		dex		                dex
.8c9d		a5 18		lda $18		                lda base                ; base <= 36
.8c9f		95 00		sta $00,x	                sta 0,x
.8ca1		74 01		stz $01,x	                stz 1,x
.8ca3		20 6b 95	jsr $956b	                jsr w_um_slash_mod      ; ( v u 0 base -- v ru qu )
.8ca6		20 c0 9c	jsr $9cc0	_skip:          jsr w_not_rot           ; ( qu v ru )
.8ca9		46 19		lsr $19		                lsr base+1              ; 1 => 0 + C=1 => 0 + C=0
.8cab		b0 ee		bcs $8c9b	                bcs _loop               ; run two passes
.8cad		b5 00		lda $00,x	                lda 0,x
.8caf		a8		tay		                tay
.8cb0		b9 08 d4	lda $d408,y	                lda s_abc_upper,y       ; upper case 0-9A-Z
.8cb3		95 00		sta $00,x	                sta 0,x
.8cb5		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8cb7		20 49 89	jsr $8949	                jsr w_hold
.8cba						z_number_sign:
.8cba		60		rts		                rts
.8cbb						xt_number_sign_greater:
.8cbb		20 87 d8	jsr $d887	                jsr underflow_2         ; double number
.8cbe						w_number_sign_greater:
.8cbe		a5 2b		lda $2b		                lda tohold
.8cc0		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8cc2		95 02		sta $02,x	                sta 2,x
.8cc4		a5 2c		lda $2c		                lda tohold+1
.8cc6		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8cc8		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8cca		20 3d 8d	jsr $8d3d	                jsr w_pad      ; ( addr addr pad )
.8ccd		38		sec		                sec
.8cce		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8cd0		f5 02		sbc $02,x	                sbc 2,x
.8cd2		95 02		sta $02,x	                sta 2,x
.8cd4		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8cd6		f5 03		sbc $03,x	                sbc 3,x
.8cd8		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8cda		e8		inx		                inx
.8cdb		e8		inx		                inx
.8cdc						z_number_sign_greater:
.8cdc		60		rts		                rts
.8cdd						xt_number_sign_s:
.8cdd		20 87 d8	jsr $d887	                jsr underflow_2
.8ce0						w_number_sign_s:
.8ce0						_loop:
.8ce0		20 8d 8c	jsr $8c8d	                jsr w_number_sign
.8ce3		b5 00		lda $00,x	                lda 0,x
.8ce5		15 01		ora $01,x	                ora 1,x
.8ce7		15 02		ora $02,x	                ora 2,x
.8ce9		15 03		ora $03,x	                ora 3,x
.8ceb		d0 f3		bne $8ce0	                bne _loop
.8ced						z_number_sign_s:
.8ced		60		rts		                rts
.8cee						xt_of:
.8cee						w_of:
.8cee		a0 8d		ldy #$8d	                ldy #>w_over
.8cf0		a9 32		lda #$32	                lda #<w_over
.8cf2		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8cf5		a0 87		ldy #$87	                ldy #>w_equal
.8cf7		a9 aa		lda #$aa	                lda #<w_equal
.8cf9		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8cfc		20 6d 89	jsr $896d	                jsr w_if
.8cff		a0 86		ldy #$86	                ldy #>w_drop
.8d01		a9 a3		lda #$a3	                lda #<w_drop
.8d03		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8d06		60		rts		z_of:           rts
.8d07						xt_one_minus:
.8d07		20 82 d8	jsr $d882	                jsr underflow_1
.8d0a						w_one_minus:
.8d0a		b5 00		lda $00,x	                lda 0,x
.8d0c		d0 02		bne $8d10	                bne +
.8d0e		d6 01		dec $01,x	                dec 1,x
.8d10						+
.8d10		d6 00		dec $00,x	                dec 0,x
.8d12		60		rts		z_one_minus:    rts
.8d13						xt_char_plus:
.8d13						xt_one_plus:
.8d13		20 82 d8	jsr $d882	                jsr underflow_1
.8d16						w_char_plus:
.8d16						w_one_plus:
.8d16		f6 00		inc $00,x	                inc 0,x
.8d18		d0 02		bne $8d1c	                bne _done
.8d1a		f6 01		inc $01,x	                inc 1,x
.8d1c						_done:
.8d1c						z_char_plus:
.8d1c		60		rts		z_one_plus:     rts
.8d1d						xt_or:
.8d1d		20 87 d8	jsr $d887	                jsr underflow_2
.8d20						w_or:
.8d20		b5 00		lda $00,x	                lda 0,x
.8d22		15 02		ora $02,x	                ora 2,x
.8d24		95 02		sta $02,x	                sta 2,x
.8d26		b5 01		lda $01,x	                lda 1,x
.8d28		15 03		ora $03,x	                ora 3,x
.8d2a		95 03		sta $03,x	                sta 3,x
.8d2c		e8		inx		                inx
.8d2d		e8		inx		                inx
.8d2e		60		rts		z_or:           rts
.8d2f						xt_over:
.8d2f		20 87 d8	jsr $d887	                jsr underflow_2
.8d32						w_over:
.8d32		ca		dex		                dex
.8d33		ca		dex		                dex
.8d34		b5 04		lda $04,x	                lda 4,x         ; LSB
.8d36		95 00		sta $00,x	                sta 0,x
.8d38		b5 05		lda $05,x	                lda 5,x         ; MSB
.8d3a		95 01		sta $01,x	                sta 1,x
.8d3c		60		rts		z_over:         rts
.8d3d						xt_pad:
.8d3d						w_pad:
.8d3d		ca		dex		                dex
.8d3e		ca		dex		                dex
.8d3f		a5 00		lda $00		                lda cp
.8d41		18		clc		                clc
.8d42		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8d44		95 00		sta $00,x	                sta 0,x
.8d46		a5 01		lda $01		                lda cp+1
.8d48		69 00		adc #$00	                adc #0          ; only need carry
.8d4a		95 01		sta $01,x	                sta 1,x
.8d4c		60		rts		z_pad:          rts
.8d4d						xt_page:
.8d4d						w_page:
.8d4d		a9 1b		lda #$1b	                lda #AscESC
.8d4f		20 d3 86	jsr $86d3	                jsr emit_a
.8d52		a9 5b		lda #$5b	                lda #'['
.8d54		20 d3 86	jsr $86d3	                jsr emit_a
.8d57		a9 32		lda #$32	                lda #'2'
.8d59		20 d3 86	jsr $86d3	                jsr emit_a
.8d5c		a9 4a		lda #$4a	                lda #'J'
.8d5e		20 d3 86	jsr $86d3	                jsr emit_a
.8d61		20 39 9e	jsr $9e39	                jsr w_zero
.8d64		20 39 9e	jsr $9e39	                jsr w_zero
.8d67		20 a5 82	jsr $82a5	                jsr w_at_xy
.8d6a		60		rts		z_page:         rts
.8d6b						xt_paren:
.8d6b						w_paren:
.8d6b		ca		dex		                dex
.8d6c		ca		dex		                dex
.8d6d		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d6f		95 00		sta $00,x	                sta 0,x
.8d71		74 01		stz $01,x	                stz 1,x
.8d73		20 d9 8d	jsr $8dd9	                jsr w_parse
.8d76		e8		inx		                inx
.8d77		e8		inx		                inx
.8d78		e8		inx		                inx
.8d79		e8		inx		                inx
.8d7a		60		rts		z_paren:        rts
.8d7b						xt_parse_name:
.8d7b						w_parse_name:
.8d7b		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d7d		38		sec		                sec
.8d7e		e5 10		sbc $10		                sbc toin
.8d80		85 25		sta $25		                sta tmp1
.8d82		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d84		e5 11		sbc $11		                sbc toin+1
.8d86		85 26		sta $26		                sta tmp1+1
.8d88		a5 25		lda $25		                lda tmp1
.8d8a		05 26		ora $26		                ora tmp1+1
.8d8c		f0 28		beq $8db6	                beq _empty_line
.8d8e		a5 0c		lda $0c		                lda cib
.8d90		18		clc		                clc
.8d91		65 10		adc $10		                adc toin
.8d93		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d95		a5 0d		lda $0d		                lda cib+1
.8d97		65 11		adc $11		                adc toin+1
.8d99		85 28		sta $28		                sta tmp2+1              ; MSB
.8d9b						_skip_loop:
.8d9b		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d9d		20 75 d8	jsr $d875	                jsr is_whitespace
.8da0		90 1f		bcc $8dc1	                bcc _char_found
.8da2		e6 27		inc $27		                inc tmp2
.8da4		d0 02		bne $8da8	                bne +
.8da6		e6 28		inc $28		                inc tmp2+1
.8da8						+
.8da8		a5 25		lda $25		                lda tmp1
.8daa		d0 02		bne $8dae	                bne +
.8dac		c6 26		dec $26		                dec tmp1+1
.8dae		c6 25		dec $25		+               dec tmp1
.8db0		a5 25		lda $25		                lda tmp1
.8db2		05 26		ora $26		                ora tmp1+1
.8db4		d0 e5		bne $8d9b	                bne _skip_loop          ; fall through if empty line
.8db6						_empty_line:
.8db6		ca		dex		                dex
.8db7		ca		dex		                dex
.8db8		ca		dex		                dex
.8db9		ca		dex		                dex
.8dba		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8dbc		74 01		stz $01,x	                stz 1,x
.8dbe		4c 6b 8e	jmp $8e6b	                jmp z_parse_name        ; skip over PARSE
.8dc1						_char_found:
.8dc1		a5 27		lda $27		                lda tmp2
.8dc3		38		sec		                sec
.8dc4		e5 0c		sbc $0c		                sbc cib
.8dc6		85 10		sta $10		                sta toin
.8dc8		a5 28		lda $28		                lda tmp2+1
.8dca		e5 0d		sbc $0d		                sbc cib+1
.8dcc		85 11		sta $11		                sta toin+1
.8dce		ca		dex		                dex
.8dcf		ca		dex		                dex
.8dd0		a9 20		lda #$20	                lda #AscSP
.8dd2		95 00		sta $00,x	                sta 0,x
.8dd4		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8dd6						xt_parse:
.8dd6		20 82 d8	jsr $d882	                jsr underflow_1
.8dd9						w_parse:
.8dd9		a5 0e		lda $0e		                lda ciblen
.8ddb		05 0f		ora $0f		                ora ciblen+1
.8ddd		f0 0c		beq $8deb	                beq _abort_parse
.8ddf		a5 11		lda $11		                lda toin+1              ; MSB
.8de1		c5 0f		cmp $0f		                cmp ciblen+1
.8de3		90 0e		bcc $8df3	                bcc _go_parse           ; unsigned comparison
.8de5		a5 10		lda $10		                lda toin                ; LSB
.8de7		c5 0e		cmp $0e		                cmp ciblen
.8de9		90 08		bcc $8df3	                bcc _go_parse
.8deb						_abort_parse:
.8deb		ca		dex		                dex
.8dec		ca		dex		                dex
.8ded		74 00		stz $00,x	                stz 0,x
.8def		74 01		stz $01,x	                stz 1,x
.8df1		80 78		bra $8e6b	                bra _done
.8df3						_go_parse:
.8df3		b5 00		lda $00,x	                lda 0,x
.8df5		85 23		sta $23		                sta tmptos
.8df7		ca		dex		                dex
.8df8		ca		dex		                dex
.8df9		a5 0c		lda $0c		                lda cib
.8dfb		18		clc		                clc
.8dfc		65 10		adc $10		                adc toin        ; LSB
.8dfe		85 25		sta $25		                sta tmp1
.8e00		85 27		sta $27		                sta tmp2
.8e02		95 02		sta $02,x	                sta 2,x
.8e04		a5 0d		lda $0d		                lda cib+1
.8e06		65 11		adc $11		                adc toin+1      ; MSB
.8e08		85 26		sta $26		                sta tmp1+1
.8e0a		85 28		sta $28		                sta tmp2+1
.8e0c		95 03		sta $03,x	                sta 3,x
.8e0e		a5 0c		lda $0c		                lda cib
.8e10		18		clc		                clc
.8e11		65 0e		adc $0e		                adc ciblen
.8e13		85 29		sta $29		                sta tmp3
.8e15		a5 0d		lda $0d		                lda cib+1
.8e17		65 0f		adc $0f		                adc ciblen+1
.8e19		85 2a		sta $2a		                sta tmp3+1
.8e1b		64 24		stz $24		                stz tmptos+1
.8e1d						_loop:
.8e1d		a5 27		lda $27		                lda tmp2
.8e1f		c5 29		cmp $29		                cmp tmp3
.8e21		d0 06		bne $8e29	                bne _not_empty
.8e23		a5 28		lda $28		                lda tmp2+1
.8e25		c5 2a		cmp $2a		                cmp tmp3+1
.8e27		f0 1d		beq $8e46	                beq _eol
.8e29						_not_empty:
.8e29		b2 27		lda ($27)	                lda (tmp2)
.8e2b		a4 23		ldy $23		                ldy tmptos
.8e2d		c0 20		cpy #$20	                cpy #AscSP
.8e2f		d0 07		bne $8e38	                bne _not_whitespace
.8e31		20 75 d8	jsr $d875	                jsr is_whitespace
.8e34		90 02		bcc $8e38	                bcc _not_whitespace
.8e36		80 0c		bra $8e44	                bra _found_delimiter
.8e38						_not_whitespace:
.8e38		c5 23		cmp $23		                cmp tmptos
.8e3a		f0 08		beq $8e44	                beq _found_delimiter
.8e3c		e6 27		inc $27		                inc tmp2
.8e3e		d0 dd		bne $8e1d	                bne _loop
.8e40		e6 28		inc $28		                inc tmp2+1
.8e42		80 d9		bra $8e1d	                bra _loop
.8e44						_found_delimiter:
.8e44		e6 24		inc $24		                inc tmptos+1
.8e46						_eol:
.8e46		a5 27		lda $27		                lda tmp2
.8e48		38		sec		                sec
.8e49		e5 25		sbc $25		                sbc tmp1
.8e4b		95 00		sta $00,x	                sta 0,x
.8e4d		a5 28		lda $28		                lda tmp2+1
.8e4f		e5 26		sbc $26		                sbc tmp1+1
.8e51		95 01		sta $01,x	                sta 1,x
.8e53		a5 27		lda $27		                lda tmp2
.8e55		38		sec		                sec
.8e56		e5 0c		sbc $0c		                sbc cib
.8e58		85 10		sta $10		                sta toin
.8e5a		a5 28		lda $28		                lda tmp2+1
.8e5c		e5 0d		sbc $0d		                sbc cib+1
.8e5e		85 11		sta $11		                sta toin+1
.8e60		a5 10		lda $10		                lda toin
.8e62		18		clc		                clc
.8e63		65 24		adc $24		                adc tmptos+1
.8e65		85 10		sta $10		                sta toin
.8e67		90 02		bcc $8e6b	                bcc +
.8e69		e6 11		inc $11		                inc toin+1
.8e6b						+
.8e6b						_done:
.8e6b						z_parse_name:
.8e6b		60		rts		z_parse:        rts
.8e6c						xt_pick:
.8e6c						w_pick:
.8e6c		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e6e		8a		txa		                txa
.8e6f		75 00		adc $00,x	                adc 0,x
.8e71		a8		tay		                tay
.8e72		b9 02 00	lda $0002,y	                lda 0002,y
.8e75		95 00		sta $00,x	                sta 0,x
.8e77		b9 03 00	lda $0003,y	                lda 0003,y
.8e7a		95 01		sta $01,x	                sta 1,x
.8e7c		60		rts		z_pick:         rts
.8e7d						xt_plus:
.8e7d		20 87 d8	jsr $d887	                jsr underflow_2
.8e80						w_plus:
.8e80		18		clc		                clc
.8e81		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e83		75 02		adc $02,x	                adc 2,x
.8e85		95 02		sta $02,x	                sta 2,x
.8e87		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e89		75 03		adc $03,x	                adc 3,x
.8e8b		95 03		sta $03,x	                sta 3,x
.8e8d		e8		inx		                inx
.8e8e		e8		inx		                inx
.8e8f		60		rts		z_plus:         rts
.8e90						xt_plus_store:
.8e90		20 87 d8	jsr $d887	                jsr underflow_2
.8e93						w_plus_store:
.8e93		b5 00		lda $00,x	                lda 0,x
.8e95		85 25		sta $25		                sta tmp1
.8e97		b5 01		lda $01,x	                lda 1,x
.8e99		85 26		sta $26		                sta tmp1+1
.8e9b		a0 00		ldy #$00	                ldy #0          ; LSB
.8e9d		b1 25		lda ($25),y	                lda (tmp1),y
.8e9f		18		clc		                clc
.8ea0		75 02		adc $02,x	                adc 2,x
.8ea2		91 25		sta ($25),y	                sta (tmp1),y
.8ea4		c8		iny		                iny             ; MSB
.8ea5		b1 25		lda ($25),y	                lda (tmp1),y
.8ea7		75 03		adc $03,x	                adc 3,x
.8ea9		91 25		sta ($25),y	                sta (tmp1),y
.8eab		e8		inx		                inx
.8eac		e8		inx		                inx
.8ead		e8		inx		                inx
.8eae		e8		inx		                inx
.8eaf		60		rts		z_plus_store:   rts
.8eb0						xt_postpone:
.8eb0						w_postpone:
.8eb0		20 7b 8d	jsr $8d7b	                jsr w_parse_name               ; ( -- addr n )
.8eb3		b5 00		lda $00,x	                lda 0,x
.8eb5		15 01		ora $01,x	                ora 1,x
.8eb7		d0 05		bne $8ebe	                bne +
.8eb9		a9 05		lda #$05	                lda #err_noname
.8ebb		4c 98 d8	jmp $d898	                jmp error
.8ebe						+
.8ebe		20 30 9b	jsr $9b30	                jsr w_find_name                ; ( -- nt | 0 )
.8ec1		d0 05		bne $8ec8	                bne +
.8ec3		a9 05		lda #$05	                lda #err_noname
.8ec5		4c 98 d8	jmp $d898	                jmp error
.8ec8						+
.8ec8		b5 00		lda $00,x	                lda 0,x
.8eca		85 25		sta $25		                sta tmp1
.8ecc		b5 01		lda $01,x	                lda 1,x
.8ece		85 26		sta $26		                sta tmp1+1
.8ed0		20 79 9c	jsr $9c79	                jsr w_name_to_int              ; ( nt -- xt )
.8ed3		e6 25		inc $25		                inc tmp1
.8ed5		d0 02		bne $8ed9	                bne +
.8ed7		e6 26		inc $26		                inc tmp1+1
.8ed9						+
.8ed9		b2 25		lda ($25)	                lda (tmp1)
.8edb		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.8edd		f0 05		beq $8ee4	                beq _not_immediate
.8edf		20 ef 96	jsr $96ef	                jsr w_compile_comma
.8ee2		80 0a		bra $8eee	                bra _done
.8ee4						_not_immediate:
.8ee4		20 20 8a	jsr $8a20	                jsr w_literal
.8ee7		a0 96		ldy #$96	                ldy #>w_compile_comma
.8ee9		a9 ef		lda #$ef	                lda #<w_compile_comma
.8eeb		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.8eee						_done:
.8eee		60		rts		z_postpone:     rts
.8eef						xt_question_dup:
.8eef		20 82 d8	jsr $d882	                jsr underflow_1
.8ef2						w_question_dup:
.8ef2		b5 00		lda $00,x	                lda 0,x
.8ef4		15 01		ora $01,x	                ora 1,x
.8ef6		f0 0a		beq $8f02	                beq _done
.8ef8		ca		dex		                dex
.8ef9		ca		dex		                dex
.8efa		b5 02		lda $02,x	                lda 2,x
.8efc		95 00		sta $00,x	                sta 0,x
.8efe		b5 03		lda $03,x	                lda 3,x
.8f00		95 01		sta $01,x	                sta 1,x
.8f02						_done:
.8f02		60		rts		z_question_dup: rts
.8f03						xt_r_fetch:
.8f03						w_r_fetch:
.8f03		7a		ply		                ply             ; LSB
.8f04		84 25		sty $25		                sty tmp1
.8f06		7a		ply		                ply             ; MSB
.8f07		ca		dex		                dex
.8f08		ca		dex		                dex
.8f09		68		pla		                pla             ; LSB
.8f0a		95 00		sta $00,x	                sta 0,x
.8f0c		68		pla		                pla             ; MSB
.8f0d		95 01		sta $01,x	                sta 1,x
.8f0f		48		pha		                pha
.8f10		b5 00		lda $00,x	                lda 0,x
.8f12		48		pha		                pha
.8f13		5a		phy		                phy             ; MSB
.8f14		a4 25		ldy $25		                ldy tmp1
.8f16		5a		phy		                phy             ; LSB
.8f17		60		rts		z_r_fetch:      rts
.8f18						xt_r_from:
.8f18						w_r_from:
.8f18		68		pla		                pla             ; LSB
.8f19		85 23		sta $23		                sta tmptos
.8f1b		7a		ply		                ply             ; MSB
.8f1c		ca		dex		                dex
.8f1d		ca		dex		                dex
.8f1e		68		pla		                pla             ; LSB
.8f1f		95 00		sta $00,x	                sta 0,x
.8f21		68		pla		                pla             ; MSB
.8f22		95 01		sta $01,x	                sta 1,x
.8f24		5a		phy		                phy             ; MSB
.8f25		a5 23		lda $23		                lda tmptos
.8f27		48		pha		                pha             ; LSB
.8f28		60		rts		z_r_from:       rts
.8f29						xt_recurse:
.8f29						w_recurse:
.8f29		a0 00		ldy #$00	                ldy #0
.8f2b		a9 20		lda #$20	                lda #OpJSR
.8f2d		91 00		sta ($00),y	                sta (cp),y
.8f2f		c8		iny		                iny
.8f30		24 1c		bit $1c		                bit status
.8f32		70 0c		bvs $8f40	                bvs _nt_in_workword
.8f34		a5 06		lda $06		                lda workword
.8f36		91 00		sta ($00),y	                sta (cp),y
.8f38		c8		iny		                iny
.8f39		a5 07		lda $07		                lda workword+1
.8f3b		91 00		sta ($00),y	                sta (cp),y
.8f3d		c8		iny		                iny
.8f3e		80 1b		bra $8f5b	                bra _update_cp
.8f40						_nt_in_workword:
.8f40		a5 06		lda $06		                lda workword            ; LSB
.8f42		18		clc		                clc
.8f43		69 04		adc #$04	                adc #4
.8f45		85 25		sta $25		                sta tmp1
.8f47		a5 07		lda $07		                lda workword+1          ; MSB
.8f49		69 00		adc #$00	                adc #0
.8f4b		85 26		sta $26		                sta tmp1+1
.8f4d		b2 25		lda ($25)	                lda (tmp1)
.8f4f		91 00		sta ($00),y	                sta (cp),y
.8f51		5a		phy		                phy
.8f52		a0 01		ldy #$01	                ldy #1
.8f54		b1 25		lda ($25),y	                lda (tmp1),y
.8f56		7a		ply		                ply
.8f57		c8		iny		                iny
.8f58		91 00		sta ($00),y	                sta (cp),y
.8f5a		c8		iny		                iny
.8f5b						_update_cp:
.8f5b		98		tya		                tya
.8f5c		18		clc		                clc
.8f5d		65 00		adc $00		                adc cp
.8f5f		85 00		sta $00		                sta cp
.8f61		90 02		bcc $8f65	                bcc _done
.8f63		e6 01		inc $01		                inc cp+1
.8f65						_done:
.8f65		60		rts		z_recurse:      rts
.8f66						xt_refill:
.8f66						w_refill:
.8f66		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f68		d0 2d		bne $8f97	                bne _src_not_kbd
.8f6a		ca		dex		                dex
.8f6b		ca		dex		                dex
.8f6c		ca		dex		                dex
.8f6d		ca		dex		                dex
.8f6e		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f70		95 02		sta $02,x	                sta 2,x
.8f72		a5 0d		lda $0d		                lda cib+1
.8f74		95 03		sta $03,x	                sta 3,x
.8f76		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f78		64 0f		stz $0f		                stz ciblen+1
.8f7a		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f7c		95 00		sta $00,x	                sta 0,x
.8f7e		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f80		20 e7 80	jsr $80e7	                jsr w_accept           ; ( addr n1 -- n2)
.8f83		b5 00		lda $00,x	                lda 0,x
.8f85		85 0e		sta $0e		                sta ciblen
.8f87		b5 01		lda $01,x	                lda 1,x
.8f89		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f8b		64 10		stz $10		                stz toin
.8f8d		64 11		stz $11		                stz toin+1
.8f8f		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f91		95 00		sta $00,x	                sta 0,x
.8f93		95 01		sta $01,x	                sta 1,x
.8f95		80 10		bra $8fa7	                bra _done
.8f97						_src_not_kbd:
.8f97		1a		inc a		                ina
.8f98		d0 08		bne $8fa2	                bne _src_not_string
.8f9a		ca		dex		                dex
.8f9b		ca		dex		                dex
.8f9c		74 00		stz $00,x	                stz 0,x
.8f9e		74 01		stz $01,x	                stz 1,x
.8fa0		80 05		bra $8fa7	                bra z_refill
.8fa2						_src_not_string:
.8fa2		a9 01		lda #$01	                lda #err_badsource
.8fa4		4c 98 d8	jmp $d898	                jmp error
.8fa7						_done:
.8fa7		60		rts		z_refill:       rts
.8fa8						xt_repeat:
.8fa8		20 87 d8	jsr $d887	                jsr underflow_2
.8fab						w_repeat:
.8fab		20 22 82	jsr $8222	                jsr w_again
.8fae		4c c2 86	jmp $86c2	                jmp w_then
.8fb1						z_repeat:
.8fb1						xt_right_bracket:
.8fb1						w_right_bracket:
.8fb1		a9 ff		lda #$ff	                lda #$FF
.8fb3		85 1a		sta $1a		                sta state
.8fb5		85 1b		sta $1b		                sta state+1
.8fb7						z_right_bracket:
.8fb7		60		rts		                rts
.8fb8						xt_rot:
.8fb8		20 8c d8	jsr $d88c	                jsr underflow_3
.8fbb						w_rot:
.8fbb		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8fbd		b5 03		lda $03,x	                lda 3,x
.8fbf		95 05		sta $05,x	                sta 5,x
.8fc1		b5 01		lda $01,x	                lda 1,x
.8fc3		95 03		sta $03,x	                sta 3,x
.8fc5		94 01		sty $01,x	                sty 1,x
.8fc7		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8fc9		b5 02		lda $02,x	                lda 2,x
.8fcb		95 04		sta $04,x	                sta 4,x
.8fcd		b5 00		lda $00,x	                lda 0,x
.8fcf		95 02		sta $02,x	                sta 2,x
.8fd1		94 00		sty $00,x	                sty 0,x
.8fd3		60		rts		z_rot:          rts
.8fd4						xt_rshift:
.8fd4		20 87 d8	jsr $d887	                jsr underflow_2
.8fd7						w_rshift:
.8fd7		b5 00		lda $00,x	                lda 0,x
.8fd9		29 0f		and #$0f	                and #%00001111
.8fdb		f0 08		beq $8fe5	                beq _done               ; if 0 shifts, quit
.8fdd		a8		tay		                tay
.8fde						_loop:
.8fde		56 03		lsr $03,x	                lsr 3,x
.8fe0		76 02		ror $02,x	                ror 2,x
.8fe2		88		dey		                dey
.8fe3		d0 f9		bne $8fde	                bne _loop
.8fe5						_done:
.8fe5		e8		inx		                inx
.8fe6		e8		inx		                inx
.8fe7		60		rts		z_rshift:       rts
.8fe8						xt_s_backslash_quote:
.8fe8						w_s_backslash_quote:
.8fe8		a9 ff		lda #$ff	                lda #$FF
.8fea		85 27		sta $27		                sta tmp2
.8fec		64 28		stz $28		                stz tmp2+1
.8fee		20 05 90	jsr $9005	                jsr s_quote_start
.8ff1						z_s_backslash_quote:
.8ff1		60		rts		                rts
.8ff2						convert_hex_value:
.8ff2		c9 41		cmp #$41	        cmp #'A'
.8ff4		90 07		bcc $8ffd	        bcc _digit
.8ff6		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8ff8		38		sec		        sec
.8ff9		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8ffb		80 03		bra $9000	        bra _done
.8ffd						_digit:
.8ffd		38		sec		        sec
.8ffe		e9 30		sbc #$30	        sbc #'0'
.9000						_done:
.9000		60		rts		        rts
.9001						xt_s_quote:
.9001						w_s_quote:
.9001		64 27		stz $27		                stz tmp2
.9003		64 28		stz $28		                stz tmp2+1
.9005						s_quote_start:
.9005		20 d8 97	jsr $97d8	                jsr cmpl_jump_later
.9008		20 34 89	jsr $8934	                jsr w_here             ; the start of the string
.900b						_savechars_loop:
.900b		a5 11		lda $11		                lda toin+1              ; MSB
.900d		c5 0f		cmp $0f		                cmp ciblen+1
.900f		90 2a		bcc $903b	                bcc _input_fine         ; unsigned comparison
.9011		a5 10		lda $10		                lda toin                ; LSB
.9013		c5 0e		cmp $0e		                cmp ciblen
.9015		90 24		bcc $903b	                bcc _input_fine
.9017		a5 27		lda $27		                lda tmp2
.9019		48		pha		                pha
.901a		a5 28		lda $28		                lda tmp2+1
.901c		48		pha		                pha
.901d		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.901f		48		pha		                pha
.9020		20 66 8f	jsr $8f66	                jsr w_refill           ; ( -- f )
.9023		68		pla		                pla
.9024		85 29		sta $29		                sta tmp3
.9026		68		pla		                pla
.9027		85 28		sta $28		                sta tmp2+1
.9029		68		pla		                pla
.902a		85 27		sta $27		                sta tmp2
.902c		b5 00		lda $00,x	                lda 0,x
.902e		15 01		ora $01,x	                ora 1,x
.9030		d0 05		bne $9037	                bne _refill_ok
.9032		a9 06		lda #$06	                lda #err_refill
.9034		4c 98 d8	jmp $d898	                jmp error
.9037						_refill_ok:
.9037		e8		inx		                inx
.9038		e8		inx		                inx
.9039		80 d0		bra $900b	                bra _savechars_loop
.903b						_input_fine:
.903b		a5 0c		lda $0c		                lda cib
.903d		18		clc		                clc
.903e		65 10		adc $10		                adc toin        ; LSB
.9040		85 25		sta $25		                sta tmp1
.9042		a5 0d		lda $0d		                lda cib+1
.9044		65 11		adc $11		                adc toin+1      ; MSB
.9046		85 26		sta $26		                sta tmp1+1
.9048		b2 25		lda ($25)	                lda (tmp1)
.904a		24 27		bit $27		                bit tmp2
.904c		30 03		bmi $9051	                bmi _handle_escapes    ; Only checking bit 7
.904e		4c b9 90	jmp $90b9	                jmp _regular_char
.9051						_handle_escapes:
.9051		24 28		bit $28		                bit tmp2+1
.9053		30 03		bmi $9058	                bmi _escaped
.9055		4c af 90	jmp $90af	                jmp _not_escaped
.9058						_escaped:
.9058		70 21		bvs $907b	                bvs _check_esc_chars
.905a		a9 01		lda #$01	                lda #1
.905c		24 28		bit $28		                bit tmp2+1
.905e		d0 10		bne $9070	                bne _esc_x_second_digit
.9060		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.9062		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.9064		20 f2 8f	jsr $8ff2	                jsr convert_hex_value
.9067		0a		asl a		                asl
.9068		0a		asl a		                asl
.9069		0a		asl a		                asl
.906a		0a		asl a		                asl
.906b		85 29		sta $29		                sta tmp3    ; Save it for later.
.906d		4c c0 90	jmp $90c0	                jmp _next_character
.9070						_esc_x_second_digit:
.9070		64 28		stz $28		                stz tmp2+1
.9072		b2 25		lda ($25)	                lda (tmp1)
.9074		20 f2 8f	jsr $8ff2	                jsr convert_hex_value
.9077		05 29		ora $29		                ora tmp3
.9079		80 42		bra $90bd	                bra _save_character
.907b						_check_esc_chars:
.907b		64 28		stz $28		                stz tmp2+1
.907d		c9 61		cmp #$61	                cmp #'a'
.907f		30 1a		bmi $909b	                bmi _check_esc_quote
.9081		c9 7b		cmp #$7b	                cmp #'z'+1
.9083		10 16		bpl $909b	                bpl _check_esc_quote
.9085		a8		tay		                tay
.9086		b9 8a 90	lda $908a,y	                lda escape_tr_table - 'a',y   ; fake base address to index with a-z directly
.9089		d0 03		bne $908e	                bne _esc_replace
.908b		98		tya		                tya                     ; revert if no translation
.908c		80 0d		bra $909b	                bra _check_esc_quote
.908e		10 2d		bpl $90bd	_esc_replace:   bpl _save_character     ; simple replacement
.9090		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9092		f0 29		beq $90bd	                beq _save_character     ; NUL we can just output
.9094		20 c7 97	jsr $97c7	                jsr cmpl_a              ; else output first char (CR)
.9097		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9099		80 22		bra $90bd	                bra _save_character
.909b						_check_esc_quote:
.909b		c9 22		cmp #$22	                cmp #'"'
.909d		f0 1e		beq $90bd	                beq _save_character
.909f		c9 78		cmp #$78	                cmp #'x'
.90a1		d0 06		bne $90a9	                bne _check_esc_backslash
.90a3		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.90a5		85 28		sta $28		                sta tmp2+1
.90a7		80 17		bra $90c0	                bra _next_character
.90a9						_check_esc_backslash:
.90a9		c9 5c		cmp #$5c	                cmp #'\'
.90ab		d0 0c		bne $90b9	                bne _regular_char
.90ad		80 0e		bra $90bd	                bra _save_character
.90af						_not_escaped:
.90af		c9 5c		cmp #$5c	                cmp #'\'
.90b1		d0 06		bne $90b9	                bne _regular_char
.90b3		a9 ff		lda #$ff	                lda #$FF
.90b5		85 28		sta $28		                sta tmp2+1
.90b7		80 07		bra $90c0	                bra _next_character
.90b9						_regular_char:
.90b9		c9 22		cmp #$22	                cmp #'"'
.90bb		f0 0c		beq $90c9	                beq _found_string_end
.90bd						_save_character:
.90bd		20 c7 97	jsr $97c7	                jsr cmpl_a
.90c0						_next_character:
.90c0		e6 10		inc $10		                inc toin
.90c2		d0 02		bne $90c6	                bne _savechars_loop_longjump
.90c4		e6 11		inc $11		                inc toin+1
.90c6						_savechars_loop_longjump:
.90c6		4c 0b 90	jmp $900b	                jmp _savechars_loop
.90c9						_found_string_end:
.90c9		e6 10		inc $10		                inc toin
.90cb		d0 02		bne $90cf	                bne +
.90cd		e6 11		inc $11		                inc toin+1
.90cf						+
.90cf		20 34 89	jsr $8934	                jsr w_here
.90d2		20 bb 8f	jsr $8fbb	                jsr w_rot
.90d5		20 49 92	jsr $9249	                jsr w_store    ; Update the jmp target
.90d8		20 34 89	jsr $8934	                jsr w_here
.90db		20 32 8d	jsr $8d32	                jsr w_over
.90de		20 12 8c	jsr $8c12	                jsr w_minus    ; HERE - addr gives string length
.90e1		a5 1a		lda $1a		                lda state
.90e3		05 1b		ora $1b		                ora state+1             ; paranoid
.90e5		f0 03		beq $90ea	                beq _done
.90e7		20 0b a2	jsr $a20b	                jsr cmpl_sliteral         ; ( addr u -- )
.90ea						_done:
.90ea		60		rts		z_s_quote:      rts
.90eb						escape_tr_table:
>90eb		07				    .byte   7               ; a -> BEL (ASCII value 7)
>90ec		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>90ed		00 00				    .byte   0,0             ; c, d no escape
>90ef		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>90f0		0c				    .byte   12              ; f -> FF (ASCII value 12)
>90f1		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>90f6		0a				    .byte   10              ; l -> LF (ASCII value 10)
>90f7		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>90f8		0a				    .byte   10              ; n behaves like l --> lf
>90f9		00 00				    .byte   0,0             ; o,p
>90fb		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>90fc		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>90fd		00				    .byte   0               ; s
>90fe		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>90ff		00				    .byte   0               ; u
>9100		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9101		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9104		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9105						xt_s_to_d:
.9105		20 82 d8	jsr $d882	                jsr underflow_1
.9108						w_s_to_d:
.9108		ca		dex		                dex
.9109		ca		dex		                dex
.910a		74 00		stz $00,x	                stz 0,x
.910c		74 01		stz $01,x	                stz 1,x
.910e		b5 03		lda $03,x	                lda 3,x
.9110		10 04		bpl $9116	                bpl _done
.9112		d6 00		dec $00,x	                dec 0,x
.9114		d6 01		dec $01,x	                dec 1,x
.9116						_done:
.9116		60		rts		z_s_to_d:       rts
.9117						xt_semicolon:
.9117						w_semicolon:
.9117		24 1c		bit $1c		                bit status
.9119		70 11		bvs $912c	                bvs _colonword
.911b		a9 60		lda #$60	                lda #OpRTS
.911d		20 c7 97	jsr $97c7	                jsr cmpl_a
.9120		ca		dex		                dex
.9121		ca		dex		                dex
.9122		a5 06		lda $06		                lda workword
.9124		95 00		sta $00,x	                sta 0,x
.9126		a5 07		lda $07		                lda workword+1
.9128		95 01		sta $01,x	                sta 1,x
.912a		80 45		bra $9171	                bra _semicolon_done
.912c						_colonword:
.912c		a0 06		ldy #$06	                ldy #6
.912e		a5 00		lda $00		                lda cp
.9130		91 06		sta ($06),y	                sta (workword),y
.9132		c8		iny		                iny
.9133		a5 01		lda $01		                lda cp+1
.9135		91 06		sta ($06),y	                sta (workword),y
.9137		a9 60		lda #$60	                lda #OpRTS
.9139		20 c7 97	jsr $97c7	                jsr cmpl_a
.913c		24 1c		bit $1c		                bit status
.913e		10 26		bpl $9166	                bpl _new_word   ; Bit 7 is clear = new word
.9140		ca		dex		                dex
.9141		ca		dex		                dex
.9142		ca		dex		                dex
.9143		ca		dex		                dex
.9144		b2 06		lda ($06)	                lda (workword)
.9146		95 00		sta $00,x	                sta 0,x
.9148		74 01		stz $01,x	                stz 1,x
.914a		a5 06		lda $06		                lda workword
.914c		18		clc		                clc
.914d		69 08		adc #$08	                adc #8
.914f		95 02		sta $02,x	                sta 2,x
.9151		a5 07		lda $07		                lda workword+1
.9153		69 00		adc #$00	                adc #0                  ; only want carry
.9155		95 03		sta $03,x	                sta 3,x
.9157		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9159		20 be d8	jsr $d8be	                jsr print_string_no_lf
.915c		20 e6 94	jsr $94e6	                jsr w_type
.915f		20 f6 91	jsr $91f6	                jsr w_space
.9162		a9 80		lda #$80	                lda #%10000000
.9164		14 1c		trb $1c		                trb status
.9166						_new_word:
.9166		a5 06		lda $06		                lda workword
.9168		85 02		sta $02		                sta dp
.916a		a5 07		lda $07		                lda workword+1
.916c		85 03		sta $03		                sta dp+1
.916e		20 ec d7	jsr $d7ec	                jsr dp_to_current       ; Save the updated DP to the
.9171						_semicolon_done:
.9171		64 1a		stz $1a		                stz state
.9173		64 1b		stz $1b		                stz state+1
.9175		60		rts		z_semicolon:    rts
.9176						xt_sign:
.9176		20 82 d8	jsr $d882	                jsr underflow_1
.9179						w_sign:
.9179		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.917b		30 04		bmi $9181	                bmi _minus
.917d		e8		inx		                inx
.917e		e8		inx		                inx
.917f		80 09		bra $918a	                bra _done
.9181						_minus:
.9181		a9 2d		lda #$2d	                lda #'-'
.9183		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9185		74 01		stz $01,x	                stz 1,x         ; paranoid
.9187		20 49 89	jsr $8949	                jsr w_hold
.918a						_done:
.918a		60		rts		z_sign:         rts
.918b						xt_slash:
.918b		20 87 d8	jsr $d887	                jsr underflow_2
.918e						w_slash:
.918e		a9 00		lda #$00	                lda #0
.9190		80 05		bra $9197	                bra slashmod_common
.9192						xt_slash_mod:
.9192		20 87 d8	jsr $d887	                jsr underflow_2
.9195						w_slash_mod:
.9195		a9 ff		lda #$ff	                lda #$FF                ; falls through to _common
.9197						slashmod_common:
.9197		48		pha		                pha
.9198		20 9a 93	jsr $939a	                jsr w_to_r             ; >R
.919b		20 08 91	jsr $9108	                jsr w_s_to_d           ; S>D
.919e		20 18 8f	jsr $8f18	                jsr w_r_from           ; R>
.91a1		20 b0 91	jsr $91b0	                jsr w_sm_slash_rem     ; SM/REM
.91a4		68		pla		                pla
.91a5		d0 05		bne $91ac	                bne _done
.91a7		20 5f 92	jsr $925f	                jsr w_swap
.91aa		e8		inx		                inx             ; DROP
.91ab		e8		inx		                inx
.91ac						_done:
.91ac						z_slash_mod:
.91ac		60		rts		z_slash:        rts
.91ad						xt_sm_slash_rem:
.91ad		20 8c d8	jsr $d88c	                jsr underflow_3 ; contains double number
.91b0						w_sm_slash_rem:
.91b0		b5 03		lda $03,x	                lda 3,x
.91b2		48		pha		                pha
.91b3		b5 01		lda $01,x	                lda 1,x
.91b5		55 03		eor $03,x	                eor 3,x
.91b7		48		pha		                pha
.91b8		20 d2 80	jsr $80d2	                jsr w_abs
.91bb		e8		inx		                inx             ; pretend we pushed n1 to R
.91bc		e8		inx		                inx
.91bd		20 8b 9e	jsr $9e8b	                jsr w_dabs
.91c0		ca		dex		                dex
.91c1		ca		dex		                dex
.91c2		20 6b 95	jsr $956b	                jsr w_um_slash_mod     ; UM/MOD
.91c5		68		pla		                pla
.91c6		10 03		bpl $91cb	                bpl +
.91c8		20 50 8c	jsr $8c50	                jsr w_negate
.91cb						+
.91cb		68		pla		                pla
.91cc		10 07		bpl $91d5	                bpl _done
.91ce		e8		inx		                inx             ; pretend we pushed quotient to R
.91cf		e8		inx		                inx
.91d0		20 50 8c	jsr $8c50	                jsr w_negate
.91d3		ca		dex		                dex
.91d4		ca		dex		                dex
.91d5						_done:
.91d5		60		rts		z_sm_slash_rem: rts
.91d6						xt_source:
.91d6						w_source:
.91d6		ca		dex		                dex
.91d7		ca		dex		                dex
.91d8		a5 0c		lda $0c		                lda cib
.91da		95 00		sta $00,x	                sta 0,x
.91dc		a5 0d		lda $0d		                lda cib+1
.91de		95 01		sta $01,x	                sta 1,x
.91e0		ca		dex		                dex
.91e1		ca		dex		                dex
.91e2		a5 0e		lda $0e		                lda ciblen
.91e4		95 00		sta $00,x	                sta 0,x
.91e6		a5 0f		lda $0f		                lda ciblen+1
.91e8		95 01		sta $01,x	                sta 1,x
.91ea		60		rts		z_source:       rts
.91eb						xt_source_id:
.91eb						w_source_id:
.91eb		ca		dex		                dex
.91ec		ca		dex		                dex
.91ed		a5 0a		lda $0a		                lda insrc
.91ef		95 00		sta $00,x	                sta 0,x
.91f1		a5 0b		lda $0b		                lda insrc+1
.91f3		95 01		sta $01,x	                sta 1,x
.91f5		60		rts		z_source_id:    rts
.91f6						xt_space:
.91f6						w_space:
.91f6		a9 20		lda #$20	                lda #AscSP
.91f8		20 d3 86	jsr $86d3	                jsr emit_a
.91fb		60		rts		z_space:        rts
.91fc						xt_spaces:
.91fc		20 82 d8	jsr $d882	                jsr underflow_1
.91ff						w_spaces:
.91ff		b5 01		lda $01,x	                lda 1,x         ; ANS says this word takes a signed value
.9201		30 10		bmi $9213	                bmi _done       ; but prints no spaces for negative values.
.9203		b4 00		ldy $00,x	                ldy 0,x
.9205		f0 08		beq $920f	                beq _msb
.9207						_loop:
.9207		a9 20		lda #$20	                lda #AscSP
.9209		20 d3 86	jsr $86d3	                jsr emit_a      ; user routine preserves X and Y
.920c		88		dey		                dey
.920d		d0 f8		bne $9207	                bne _loop       ; Y is zero on exit so looping again emits 256 more spaces
.920f						_msb:
.920f		d6 01		dec $01,x	                dec 1,x         ; when decrementing MSB goes negative, it was zero so we're done
.9211		10 f4		bpl $9207	                bpl _loop       ; otherwise emit another 256 spaces
.9213		e8		inx		_done:          inx
.9214		e8		inx		                inx
.9215		60		rts		z_spaces:       rts
.9216						xt_star:
.9216		20 87 d8	jsr $d887	                jsr underflow_2
.9219						w_star:
.9219		20 ad 95	jsr $95ad	                jsr w_um_star
.921c		e8		inx		                inx
.921d		e8		inx		                inx
.921e		60		rts		z_star:         rts
.921f						xt_star_slash:
.921f		20 8c d8	jsr $d88c	                jsr underflow_3
.9222						w_star_slash:
.9222		20 2e 92	jsr $922e	                jsr w_star_slash_mod
.9225		20 5f 92	jsr $925f	                jsr w_swap
.9228		e8		inx		                inx
.9229		e8		inx		                inx
.922a						z_star_slash:
.922a		60		rts		                rts
.922b						xt_star_slash_mod:
.922b		20 8c d8	jsr $d88c	                jsr underflow_3
.922e						w_star_slash_mod:
.922e		20 9a 93	jsr $939a	                jsr w_to_r
.9231		20 4f 8b	jsr $8b4f	                jsr w_m_star
.9234		20 18 8f	jsr $8f18	                jsr w_r_from
.9237		20 b0 91	jsr $91b0	                jsr w_sm_slash_rem
.923a						z_star_slash_mod:
.923a		60		rts		                rts
.923b						xt_state:
.923b						w_state:
.923b		ca		dex		                dex
.923c		ca		dex		                dex
.923d		a9 1a		lda #$1a	                lda #<state
.923f		95 00		sta $00,x	                sta 0,x
.9241		a9 00		lda #$00	                lda #>state
.9243		95 01		sta $01,x	                sta 1,x
.9245		60		rts		z_state:        rts
.9246						xt_store:
.9246		20 87 d8	jsr $d887	                jsr underflow_2
.9249						w_store:
.9249		b5 02		lda $02,x	                lda 2,x         ; LSB
.924b		81 00		sta ($00,x)	                sta (0,x)
.924d		f6 00		inc $00,x	                inc 0,x
.924f		d0 02		bne $9253	                bne +
.9251		f6 01		inc $01,x	                inc 1,x
.9253						+
.9253		b5 03		lda $03,x	                lda 3,x         ; MSB
.9255		81 00		sta ($00,x)	                sta (0,x)
.9257		e8		inx		                inx             ; 2DROP
.9258		e8		inx		                inx
.9259		e8		inx		                inx
.925a		e8		inx		                inx
.925b		60		rts		z_store:        rts
.925c						xt_swap:
.925c		20 87 d8	jsr $d887	                jsr underflow_2
.925f						w_swap:
.925f		b5 00		lda $00,x	                lda 0,x         ; LSB
.9261		b4 02		ldy $02,x	                ldy 2,x
.9263		95 02		sta $02,x	                sta 2,x
.9265		94 00		sty $00,x	                sty 0,x
.9267		b5 01		lda $01,x	                lda 1,x         ; MSB
.9269		b4 03		ldy $03,x	                ldy 3,x
.926b		95 03		sta $03,x	                sta 3,x
.926d		94 01		sty $01,x	                sty 1,x
.926f		60		rts		z_swap:         rts
.9270						xt_tick:
.9270						w_tick:
.9270		20 7b 8d	jsr $8d7b	                jsr w_parse_name       ; ( -- addr u )
.9273		b5 00		lda $00,x	                lda 0,x
.9275		15 01		ora $01,x	                ora 1,x
.9277		d0 05		bne $927e	                bne +
.9279		a9 05		lda #$05	                lda #err_noname
.927b		4c 98 d8	jmp $d898	                jmp error
.927e						+
.927e		20 30 9b	jsr $9b30	                jsr w_find_name        ; ( addr u -- nt )
.9281		b5 00		lda $00,x	                lda 0,x
.9283		15 01		ora $01,x	                ora 1,x
.9285		d0 05		bne $928c	                bne +
.9287		a9 08		lda #$08	                lda #err_syntax
.9289		4c 98 d8	jmp $d898	                jmp error
.928c						+
.928c		20 79 9c	jsr $9c79	                jsr w_name_to_int      ; ( nt -- xt )
.928f		60		rts		z_tick:         rts
.9290						xt_to:
.9290						w_to:
.9290		20 70 92	jsr $9270	                jsr w_tick             ; ( [n] xt )
.9293		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9295		18		clc		                clc
.9296		69 03		adc #$03	                adc #3
.9298		85 25		sta $25		                sta tmp1
.929a		b5 01		lda $01,x	                lda 1,x                 ; MSB
.929c		69 00		adc #$00	                adc #0                  ; we just want the carry
.929e		85 26		sta $26		                sta tmp1+1
.92a0		a5 1a		lda $1a		                lda state
.92a2		05 1b		ora $1b		                ora state+1
.92a4		f0 14		beq $92ba	                beq _interpret
.92a6		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.92a8		95 00		sta $00,x	                sta 0,x
.92aa		a5 26		lda $26		                lda tmp1+1
.92ac		95 01		sta $01,x	                sta 1,x
.92ae		20 20 8a	jsr $8a20	                jsr w_literal      ; generate the runtime for LITERAL tmp1
.92b1		a0 92		ldy #$92	                ldy #>w_store      ; write the runtime for !
.92b3		a9 49		lda #$49	                lda #<w_store
.92b5		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.92b8		80 11		bra $92cb	                bra _done
.92ba						_interpret:
.92ba		20 87 d8	jsr $d887	                jsr underflow_2
.92bd		e8		inx		                inx
.92be		e8		inx		                inx                     ; leaving just ( n )
.92bf		b5 00		lda $00,x	                lda 0,x
.92c1		92 25		sta ($25)	                sta (tmp1)              ; LSB
.92c3		a0 01		ldy #$01	                ldy #1
.92c5		b5 01		lda $01,x	                lda 1,x                 ; MSB
.92c7		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.92c9		e8		inx		                inx                     ; DROP
.92ca		e8		inx		                inx
.92cb						_done:
.92cb		60		rts		z_to:           rts
.92cc						xt_to_body:
.92cc		20 82 d8	jsr $d882	                jsr underflow_1
.92cf						w_to_body:
.92cf		20 a9 86	jsr $86a9	                jsr w_dup              ; ( xt xt )
.92d2		20 f3 9b	jsr $9bf3	                jsr w_int_to_name      ; ( xt nt )
.92d5		f6 00		inc $00,x	                inc 0,x
.92d7		d0 02		bne $92db	                bne +
.92d9		f6 01		inc $01,x	                inc 1,x
.92db						+
.92db		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.92dd		29 20		and #$20	                and #HC
.92df		f0 0b		beq $92ec	                beq _no_cfa
.92e1		18		clc		                clc
.92e2		b5 02		lda $02,x	                lda 2,x         ; LSB
.92e4		69 03		adc #$03	                adc #3
.92e6		95 02		sta $02,x	                sta 2,x
.92e8		90 02		bcc $92ec	                bcc _no_cfa
.92ea		f6 03		inc $03,x	                inc 3,x         ; MSB
.92ec						_no_cfa:
.92ec		e8		inx		                inx             ; get rid of the nt
.92ed		e8		inx		                inx
.92ee		60		rts		z_to_body:      rts
.92ef						xt_to_in:
.92ef						w_to_in:
.92ef		ca		dex		                dex
.92f0		ca		dex		                dex
.92f1		a9 10		lda #$10	                lda #<toin
.92f3		95 00		sta $00,x	                sta 0,x
.92f5		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92f7		95 01		sta $01,x	                sta 1,x
.92f9		60		rts		z_to_in:        rts
.92fa						xt_to_number:
.92fa		20 91 d8	jsr $d891	                jsr underflow_4
.92fd						w_to_number:
.92fd		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92ff		85 2d		sta $2d		                sta scratch
.9301		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.9303		85 2e		sta $2e		                sta scratch+1
.9305		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.9307		85 2f		sta $2f		                sta scratch+2
.9309		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.930b		85 30		sta $30		                sta scratch+3
.930d		ca		dex		                dex
.930e		ca		dex		                dex
.930f						_loop:
.930f		a1 04		lda ($04,x)	                lda (4,x)
.9311		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.9313		74 01		stz $01,x	                stz 1,x                 ; paranoid
.9315		20 d4 9a	jsr $9ad4	                jsr w_digit_question   ; ( char -- n -1 | char 0 )
.9318		b5 00		lda $00,x	                lda 0,x
.931a		d0 04		bne $9320	                bne _digit_ok
.931c		e8		inx		                inx
.931d		e8		inx		                inx
.931e		80 67		bra $9387	                bra _done       ; ( ud-lo ud-hi addr u char )
.9320						_digit_ok:
.9320		b5 02		lda $02,x	                lda 2,x
.9322		85 31		sta $31		                sta scratch+4
.9324		b5 03		lda $03,x	                lda 3,x
.9326		85 32		sta $32		                sta scratch+5
.9328		a5 2f		lda $2f		                lda scratch+2
.932a		95 02		sta $02,x	                sta 2,x         ; NOS
.932c		a5 30		lda $30		                lda scratch+3
.932e		95 03		sta $03,x	                sta 3,x
.9330		a5 18		lda $18		                lda base
.9332		95 00		sta $00,x	                sta 0,x         ; TOS
.9334		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.9336		20 ad 95	jsr $95ad	                jsr w_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.9339		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.933b		85 33		sta $33		                sta scratch+6
.933d		b5 03		lda $03,x	                lda 3,x
.933f		85 34		sta $34		                sta scratch+7
.9341		a5 2d		lda $2d		                lda scratch
.9343		95 02		sta $02,x	                sta 2,x
.9345		a5 2e		lda $2e		                lda scratch+1
.9347		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.9349		a5 18		lda $18		                lda base
.934b		95 00		sta $00,x	                sta 0,x
.934d		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.934f		20 ad 95	jsr $95ad	                jsr w_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9352		b5 00		lda $00,x	                lda 0,x
.9354		85 2f		sta $2f		                sta scratch+2
.9356		b5 01		lda $01,x	                lda 1,x
.9358		85 30		sta $30		                sta scratch+3
.935a		b5 02		lda $02,x	                lda 2,x
.935c		85 2d		sta $2d		                sta scratch
.935e		b5 03		lda $03,x	                lda 3,x
.9360		85 2e		sta $2e		                sta scratch+1
.9362		18		clc		                clc
.9363		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.9365		65 31		adc $31		                adc scratch+4   ; n LSB
.9367		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.9369		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.936b		65 32		adc $32		                adc scratch+5   ; n MSB
.936d		85 2e		sta $2e		                sta scratch+1
.936f		a5 2f		lda $2f		                lda scratch+2   ; LSB
.9371		65 33		adc $33		                adc scratch+6
.9373		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.9375		a5 30		lda $30		                lda scratch+3   ; MSB
.9377		65 34		adc $34		                adc scratch+7
.9379		85 30		sta $30		                sta scratch+3
.937b		e8		inx		                inx
.937c		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.937d		f6 04		inc $04,x	                inc 4,x
.937f		d0 02		bne $9383	                bne +
.9381		f6 05		inc $05,x	                inc 5,x
.9383						+
.9383		d6 02		dec $02,x	                dec 2,x
.9385		d0 88		bne $930f	                bne _loop
.9387						_done:
.9387		e8		inx		                inx
.9388		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.9389		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.938b		95 06		sta $06,x	                sta 6,x
.938d		a5 2e		lda $2e		                lda scratch+1
.938f		95 07		sta $07,x	                sta 7,x
.9391		a5 2f		lda $2f		                lda scratch+2
.9393		95 04		sta $04,x	                sta 4,x
.9395		a5 30		lda $30		                lda scratch+3
.9397		95 05		sta $05,x	                sta 5,x
.9399		60		rts		z_to_number:    rts
.939a						xt_to_r:
.939a						w_to_r:
.939a		68		pla		                pla             ; LSB
.939b		85 23		sta $23		                sta tmptos
.939d		7a		ply		                ply             ; MSB
.939e		20 82 d8	jsr $d882	                jsr underflow_1
.93a1		b5 01		lda $01,x	                lda 1,x         ; MSB
.93a3		48		pha		                pha
.93a4		b5 00		lda $00,x	                lda 0,x         ; LSB
.93a6		48		pha		                pha
.93a7		e8		inx		                inx
.93a8		e8		inx		                inx
.93a9		5a		phy		                phy             ; MSB
.93aa		a5 23		lda $23		                lda tmptos
.93ac		48		pha		                pha             ; LSB
.93ad		60		rts		z_to_r:         rts
.93ae						xt_true:
.93ae						w_true:
.93ae		ca		dex		                dex
.93af		ca		dex		                dex
.93b0		a9 ff		lda #$ff	                lda #$FF
.93b2		95 00		sta $00,x	                sta 0,x
.93b4		95 01		sta $01,x	                sta 1,x
.93b6		60		rts		z_true:         rts
.93b7						xt_tuck:
.93b7		20 87 d8	jsr $d887	                jsr underflow_2
.93ba						w_tuck:
.93ba		ca		dex		                dex
.93bb		ca		dex		                dex
.93bc		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.93be		b5 02		lda $02,x	                lda 2,x
.93c0		95 04		sta $04,x	                sta 4,x
.93c2		94 02		sty $02,x	                sty 2,x
.93c4		95 00		sta $00,x	                sta 0,x
.93c6		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.93c8		b5 03		lda $03,x	                lda 3,x
.93ca		95 05		sta $05,x	                sta 5,x
.93cc		94 03		sty $03,x	                sty 3,x         ; bba
.93ce		95 01		sta $01,x	                sta 1,x         ; baa
.93d0		60		rts		z_tuck:         rts
.93d1						xt_two_drop:
.93d1		20 87 d8	jsr $d887	                jsr underflow_2
.93d4						w_two_drop:
.93d4		e8		inx		                inx
.93d5		e8		inx		                inx
.93d6		e8		inx		                inx
.93d7		e8		inx		                inx
.93d8		60		rts		z_two_drop:     rts
.93d9						xt_two_dup:
.93d9		20 87 d8	jsr $d887	                jsr underflow_2
.93dc						w_two_dup:
.93dc		ca		dex		                dex
.93dd		ca		dex		                dex
.93de		ca		dex		                dex
.93df		ca		dex		                dex
.93e0		b5 04		lda $04,x	                lda 4,x         ; TOS
.93e2		95 00		sta $00,x	                sta 0,x
.93e4		b5 05		lda $05,x	                lda 5,x
.93e6		95 01		sta $01,x	                sta 1,x
.93e8		b5 06		lda $06,x	                lda 6,x         ; NOS
.93ea		95 02		sta $02,x	                sta 2,x
.93ec		b5 07		lda $07,x	                lda 7,x
.93ee		95 03		sta $03,x	                sta 3,x
.93f0		60		rts		z_two_dup:      rts
.93f1						xt_two_fetch:
.93f1		20 82 d8	jsr $d882	                jsr underflow_1
.93f4						w_two_fetch:
.93f4		b5 00		lda $00,x	                lda 0,x
.93f6		85 25		sta $25		                sta tmp1
.93f8		b4 01		ldy $01,x	                ldy 1,x
.93fa		84 26		sty $26		                sty tmp1+1
.93fc		ca		dex		                dex             ; reuse one stack element
.93fd		ca		dex		                dex
.93fe		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.9400		95 00		sta $00,x	                sta 0,x
.9402		a0 01		ldy #$01	                ldy #1          ; copy next
.9404		b1 25		lda ($25),y	                lda (tmp1),y
.9406		95 01		sta $01,x	                sta 1,x
.9408		c8		iny		                iny             ; copy next
.9409		b1 25		lda ($25),y	                lda (tmp1),y
.940b		95 02		sta $02,x	                sta 2,x
.940d		c8		iny		                iny             ; copy next
.940e		b1 25		lda ($25),y	                lda (tmp1),y
.9410		95 03		sta $03,x	                sta 3,x
.9412		60		rts		z_two_fetch:    rts
.9413						xt_two_over:
.9413		20 91 d8	jsr $d891	                jsr underflow_4
.9416						w_two_over:
.9416		ca		dex		                dex
.9417		ca		dex		                dex
.9418		ca		dex		                dex
.9419		ca		dex		                dex
.941a		b5 08		lda $08,x	                lda 8,x
.941c		95 00		sta $00,x	                sta 0,x
.941e		b5 09		lda $09,x	                lda 9,x
.9420		95 01		sta $01,x	                sta 1,x
.9422		b5 0a		lda $0a,x	                lda 10,x
.9424		95 02		sta $02,x	                sta 2,x
.9426		b5 0b		lda $0b,x	                lda 11,x
.9428		95 03		sta $03,x	                sta 3,x
.942a		60		rts		z_two_over:     rts
.942b						xt_two_r_fetch:
.942b						w_two_r_fetch:
.942b		ca		dex		                dex
.942c		ca		dex		                dex
.942d		ca		dex		                dex
.942e		ca		dex		                dex
.942f		8a		txa		                txa
.9430		ba		tsx		                tsx
.9431		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.9432		7a		ply		                ply
.9433		aa		tax		                tax
.9434		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.9437		95 00		sta $00,x	                sta 0,x
.9439		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.943c		95 01		sta $01,x	                sta 1,x
.943e		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.9441		95 02		sta $02,x	                sta 2,x
.9443		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.9446		95 03		sta $03,x	                sta 3,x
.9448		60		rts		z_two_r_fetch:  rts
.9449						xt_two_r_from:
.9449						w_two_r_from:
.9449		68		pla		                pla                     ; LSB
.944a		85 25		sta $25		                sta tmp1
.944c		68		pla		                pla                     ; MSB
.944d		85 26		sta $26		                sta tmp1+1
.944f		ca		dex		                dex
.9450		ca		dex		                dex
.9451		ca		dex		                dex
.9452		ca		dex		                dex
.9453		68		pla		                pla                     ; LSB
.9454		95 00		sta $00,x	                sta 0,x
.9456		68		pla		                pla                     ; MSB
.9457		95 01		sta $01,x	                sta 1,x
.9459		68		pla		                pla                     ; LSB
.945a		95 02		sta $02,x	                sta 2,x
.945c		68		pla		                pla                     ; MSB
.945d		95 03		sta $03,x	                sta 3,x
.945f		a5 26		lda $26		                lda tmp1+1              ; MSB
.9461		48		pha		                pha
.9462		a5 25		lda $25		                lda tmp1                ; LSB
.9464		48		pha		                pha
.9465		60		rts		z_two_r_from:   rts
.9466						xt_two_slash:
.9466		20 82 d8	jsr $d882	                jsr underflow_1
.9469						w_two_slash:
.9469		b5 01		lda $01,x	                lda 1,x
.946b		0a		asl a		                asl                     ; save the sign
.946c		76 01		ror $01,x	                ror 1,x
.946e		76 00		ror $00,x	                ror 0,x
.9470		60		rts		z_two_slash:    rts
.9471						xt_two_star:
.9471						xt_cells:
.9471		20 82 d8	jsr $d882	                jsr underflow_1
.9474						w_two_star:
.9474						w_cells:
.9474		16 00		asl $00,x	                asl 0,x
.9476		36 01		rol $01,x	                rol 1,x
.9478						z_cells:
.9478		60		rts		z_two_star:     rts
.9479						xt_two_store:
.9479		20 8c d8	jsr $d88c	                jsr underflow_3
.947c						w_two_store:
.947c		b5 00		lda $00,x	                lda 0,x
.947e		85 25		sta $25		                sta tmp1
.9480		b4 01		ldy $01,x	                ldy 1,x
.9482		84 26		sty $26		                sty tmp1+1
.9484		e8		inx		                inx
.9485		e8		inx		                inx
.9486		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.9488		92 25		sta ($25)	                sta (tmp1)
.948a		b5 01		lda $01,x	                lda 1,x         ; copy next
.948c		a0 01		ldy #$01	                ldy #1
.948e		91 25		sta ($25),y	                sta (tmp1),y
.9490		b5 02		lda $02,x	                lda 2,x         ; copy next
.9492		c8		iny		                iny
.9493		91 25		sta ($25),y	                sta (tmp1),y
.9495		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.9497		c8		iny		                iny
.9498		91 25		sta ($25),y	                sta (tmp1),y
.949a		e8		inx		                inx             ; 2DROP
.949b		e8		inx		                inx
.949c		e8		inx		                inx
.949d		e8		inx		                inx
.949e		60		rts		z_two_store:    rts
.949f						xt_two_swap:
.949f		20 91 d8	jsr $d891	                jsr underflow_4
.94a2						w_two_swap:
.94a2		b5 00		lda $00,x	                lda 0,x
.94a4		b4 04		ldy $04,x	                ldy 4,x
.94a6		95 04		sta $04,x	                sta 4,x
.94a8		94 00		sty $00,x	                sty 0,x
.94aa		b5 01		lda $01,x	                lda 1,x
.94ac		b4 05		ldy $05,x	                ldy 5,x
.94ae		95 05		sta $05,x	                sta 5,x
.94b0		94 01		sty $01,x	                sty 1,x
.94b2		b5 02		lda $02,x	                lda 2,x
.94b4		b4 06		ldy $06,x	                ldy 6,x
.94b6		95 06		sta $06,x	                sta 6,x
.94b8		94 02		sty $02,x	                sty 2,x
.94ba		b5 03		lda $03,x	                lda 3,x
.94bc		b4 07		ldy $07,x	                ldy 7,x
.94be		95 07		sta $07,x	                sta 7,x
.94c0		94 03		sty $03,x	                sty 3,x
.94c2		60		rts		z_two_swap:     rts
.94c3						xt_two_to_r:
.94c3						w_two_to_r:
.94c3		68		pla		                pla             ; LSB
.94c4		85 25		sta $25		                sta tmp1
.94c6		68		pla		                pla             ; MSB
.94c7		85 26		sta $26		                sta tmp1+1
.94c9		20 87 d8	jsr $d887	                jsr underflow_2
.94cc		b5 03		lda $03,x	                lda 3,x         ; MSB
.94ce		48		pha		                pha
.94cf		b5 02		lda $02,x	                lda 2,x         ; LSB
.94d1		48		pha		                pha
.94d2		b5 01		lda $01,x	                lda 1,x         ; MSB
.94d4		48		pha		                pha
.94d5		b5 00		lda $00,x	                lda 0,x         ; LSB
.94d7		48		pha		                pha
.94d8		e8		inx		                inx
.94d9		e8		inx		                inx
.94da		e8		inx		                inx
.94db		e8		inx		                inx
.94dc		a5 26		lda $26		                lda tmp1+1      ; MSB
.94de		48		pha		                pha
.94df		a5 25		lda $25		                lda tmp1        ; LSB
.94e1		48		pha		                pha
.94e2		60		rts		z_two_to_r:     rts
.94e3						xt_type:
.94e3		20 87 d8	jsr $d887	                jsr underflow_2
.94e6						w_type:
.94e6		b5 02		lda $02,x	                lda 2,x
.94e8		85 25		sta $25		                sta tmp1
.94ea		b5 03		lda $03,x	                lda 3,x
.94ec		85 26		sta $26		                sta tmp1+1
.94ee						_loop:
.94ee		b5 00		lda $00,x	                lda 0,x
.94f0		15 01		ora $01,x	                ora 1,x
.94f2		f0 15		beq $9509	                beq _done
.94f4		b2 25		lda ($25)	                lda (tmp1)
.94f6		20 d3 86	jsr $86d3	                jsr emit_a      ; avoids stack foolery
.94f9		e6 25		inc $25		                inc tmp1
.94fb		d0 02		bne $94ff	                bne +
.94fd		e6 26		inc $26		                inc tmp1+1
.94ff						+
.94ff		b5 00		lda $00,x	                lda 0,x
.9501		d0 02		bne $9505	                bne +
.9503		d6 01		dec $01,x	                dec 1,x
.9505						+
.9505		d6 00		dec $00,x	                dec 0,x
.9507		80 e5		bra $94ee	                bra _loop
.9509						_done:
.9509		e8		inx		                inx
.950a		e8		inx		                inx
.950b		e8		inx		                inx
.950c		e8		inx		                inx
.950d		60		rts		z_type:         rts
.950e						xt_u_dot:
.950e		20 82 d8	jsr $d882	                jsr underflow_1
.9511						w_u_dot:
.9511		20 ef d8	jsr $d8ef	                jsr print_u
.9514		a9 20		lda #$20	                lda #AscSP
.9516		20 d3 86	jsr $86d3	                jsr emit_a
.9519		60		rts		z_u_dot:        rts
.951a						xt_u_dot_r:
.951a		20 87 d8	jsr $d887	                jsr underflow_2
.951d						w_u_dot_r:
.951d		20 9a 93	jsr $939a	                jsr w_to_r
.9520		20 39 9e	jsr $9e39	                jsr w_zero
.9523		20 fa 89	jsr $89fa	                jsr w_less_number_sign
.9526		20 e0 8c	jsr $8ce0	                jsr w_number_sign_s
.9529		20 be 8c	jsr $8cbe	                jsr w_number_sign_greater
.952c		20 18 8f	jsr $8f18	                jsr w_r_from
.952f		20 32 8d	jsr $8d32	                jsr w_over
.9532		20 12 8c	jsr $8c12	                jsr w_minus
.9535		20 ff 91	jsr $91ff	                jsr w_spaces
.9538		20 e6 94	jsr $94e6	                jsr w_type
.953b		60		rts		z_u_dot_r:      rts
.953c						xt_u_greater_than:
.953c		20 87 d8	jsr $d887	                jsr underflow_2
.953f						w_u_greater_than:
.953f		b5 00		lda $00,x	                lda 0,x
.9541		d5 02		cmp $02,x	                cmp 2,x
.9543		b5 01		lda $01,x	                lda 1,x
.9545		f5 03		sbc $03,x	                sbc 3,x
.9547		e8		inx		                inx
.9548		e8		inx		                inx
.9549		a9 00		lda #$00	                lda #0
.954b		69 ff		adc #$ff	                adc #$FF
.954d		95 00		sta $00,x	                sta 0,x         ; store flag
.954f		95 01		sta $01,x	                sta 1,x
.9551		60		rts		z_u_greater_than:    rts
.9552						xt_u_less_than:
.9552		20 87 d8	jsr $d887	                jsr underflow_2
.9555						w_u_less_than:
.9555		b5 02		lda $02,x	                lda 2,x
.9557		d5 00		cmp $00,x	                cmp 0,x
.9559		b5 03		lda $03,x	                lda 3,x
.955b		f5 01		sbc $01,x	                sbc 1,x
.955d		e8		inx		                inx
.955e		e8		inx		                inx
.955f		a9 00		lda #$00	                lda #0
.9561		69 ff		adc #$ff	                adc #$FF
.9563		95 00		sta $00,x	                sta 0,x         ; store flag
.9565		95 01		sta $01,x	                sta 1,x
.9567		60		rts		z_u_less_than:    rts
.9568						xt_um_slash_mod:
.9568		20 8c d8	jsr $d88c	                jsr underflow_3
.956b						w_um_slash_mod:
.956b		b5 00		lda $00,x	                lda 0,x
.956d		15 01		ora $01,x	                ora 1,x
.956f		d0 05		bne $9576	                bne _not_zero
.9571		a9 04		lda #$04	                lda #err_divzero
.9573		4c 98 d8	jmp $d898	                jmp error
.9576						_not_zero:
.9576		a9 11		lda #$11	                lda #17
.9578		85 23		sta $23		                sta tmptos
.957a						_loop:
.957a		36 04		rol $04,x	                rol 4,x
.957c		36 05		rol $05,x	                rol 5,x
.957e		c6 23		dec $23		                dec tmptos
.9580		f0 22		beq $95a4	                beq _done
.9582		36 02		rol $02,x	                rol 2,x
.9584		36 03		rol $03,x	                rol 3,x
.9586		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.9588		26 25		rol $25		                rol tmp1
.958a		38		sec		                sec
.958b		b5 02		lda $02,x	                lda 2,x
.958d		f5 00		sbc $00,x	                sbc 0,x
.958f		85 26		sta $26		                sta tmp1+1
.9591		b5 03		lda $03,x	                lda 3,x
.9593		f5 01		sbc $01,x	                sbc 1,x
.9595		a8		tay		                tay
.9596		a5 25		lda $25		                lda tmp1
.9598		e9 00		sbc #$00	                sbc #0
.959a		90 de		bcc $957a	                bcc _loop
.959c		a5 26		lda $26		                lda tmp1+1
.959e		95 02		sta $02,x	                sta 2,x
.95a0		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.95a2		80 d6		bra $957a	                bra _loop
.95a4						_done:
.95a4		e8		inx		                inx
.95a5		e8		inx		                inx
.95a6		20 5f 92	jsr $925f	                jsr w_swap
.95a9		60		rts		z_um_slash_mod: rts
.95aa						xt_um_star:
.95aa		20 87 d8	jsr $d887	                jsr underflow_2
.95ad						w_um_star:
.95ad		18		clc		                clc
.95ae		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.95b0		e9 00		sbc #$00	                sbc #0
.95b2		85 27		sta $27		                sta tmp2
.95b4		b5 01		lda $01,x	                lda 1,x
.95b6		e9 00		sbc #$00	                sbc #0
.95b8		90 31		bcc $95eb	                bcc _zero       ; is TOS zero?
.95ba		85 28		sta $28		                sta tmp2+1
.95bc		a9 00		lda #$00	                lda #0
.95be		85 25		sta $25		                sta tmp1
.95c0		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.95c2		ca		dex		                dex
.95c3		ca		dex		                dex
.95c4						_outer_loop:
.95c4		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.95c6		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.95c8						_inner_loop:
.95c8		90 0c		bcc $95d6	                bcc _no_add
.95ca		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.95cc		a5 25		lda $25		                lda tmp1
.95ce		65 27		adc $27		                adc tmp2
.95d0		85 25		sta $25		                sta tmp1
.95d2		a5 26		lda $26		                lda tmp1+1
.95d4		65 28		adc $28		                adc tmp2+1
.95d6						_no_add:
.95d6		6a		ror a		                ror
.95d7		66 25		ror $25		                ror tmp1
.95d9		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95db		88		dey		                dey
.95dc		d0 ea		bne $95c8	                bne _inner_loop ; go back for one more shift?
.95de		e8		inx		                inx
.95df		e4 29		cpx $29		                cpx tmp3
.95e1		d0 e1		bne $95c4	                bne _outer_loop ; go back for eight more shifts?
.95e3		95 01		sta $01,x	                sta 1,x
.95e5		a5 25		lda $25		                lda tmp1
.95e7		95 00		sta $00,x	                sta 0,x
.95e9		80 04		bra $95ef	                bra _done
.95eb						_zero:
.95eb		74 02		stz $02,x	                stz 2,x
.95ed		74 03		stz $03,x	                stz 3,x
.95ef						_done:
.95ef		60		rts		z_um_star:      rts
.95f0						xt_unloop:
.95f0						w_unloop:
.95f0		a4 1f		ldy $1f		                ldy loopctrl
.95f2		88		dey		                dey
.95f3		88		dey		                dey
.95f4		88		dey		                dey
.95f5		88		dey		                dey
.95f6		84 1f		sty $1f		                sty loopctrl
.95f8		30 05		bmi $95ff	                bmi z_unloop            ; no active loops?
.95fa		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95fd		85 20		sta $20		                sta loopidx0
.95ff		60		rts		z_unloop:       rts
.9600						xt_until:
.9600		20 82 d8	jsr $d882	                jsr underflow_1
.9603						w_until:
.9603		20 09 98	jsr $9809	                jsr cmpl_0branch_tos
.9606		60		rts		z_until:        rts
.9607						xt_unused:
.9607						w_unused:
.9607		ca		dex		                dex
.9608		ca		dex		                dex
.9609		a9 00		lda #$00	                lda #<cp_end
.960b		38		sec		                sec
.960c		e5 00		sbc $00		                sbc cp
.960e		95 00		sta $00,x	                sta 0,x
.9610		a9 7c		lda #$7c	                lda #>cp_end
.9612		e5 01		sbc $01		                sbc cp+1
.9614		95 01		sta $01,x	                sta 1,x
.9616		60		rts		z_unused:       rts
.9617						xt_variable:
.9617						w_variable:
.9617		20 40 84	jsr $8440	                jsr w_create
.961a		a9 00		lda #$00	                lda #0
.961c		92 00		sta ($00)	                sta (cp)
.961e		e6 00		inc $00		                inc cp
.9620		d0 02		bne $9624	                bne +
.9622		e6 01		inc $01		                inc cp+1
.9624						+
.9624		92 00		sta ($00)	                sta (cp)
.9626		e6 00		inc $00		                inc cp
.9628		d0 02		bne $962c	                bne +
.962a		e6 01		inc $01		                inc cp+1
.962c						+
.962c		20 08 84	jsr $8408	                jsr adjust_z
.962f		60		rts		z_variable:     rts
.9630						xt_while:
.9630		20 82 d8	jsr $d882	                jsr underflow_1
.9633						w_while:
.9633		20 f4 97	jsr $97f4	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.9636		20 5f 92	jsr $925f	                jsr w_swap
.9639		60		rts		z_while:        rts
.963a						xt_within:
.963a		20 8c d8	jsr $d88c	                jsr underflow_3
.963d						w_within:
.963d		20 32 8d	jsr $8d32	                jsr w_over
.9640		20 12 8c	jsr $8c12	                jsr w_minus
.9643		20 9a 93	jsr $939a	                jsr w_to_r
.9646		20 12 8c	jsr $8c12	                jsr w_minus
.9649		20 18 8f	jsr $8f18	                jsr w_r_from
.964c		20 55 95	jsr $9555	                jsr w_u_less_than
.964f		60		rts		z_within:       rts
.9650						xt_word:
.9650		20 82 d8	jsr $d882	                jsr underflow_1
.9653						w_word:
.9653		a4 10		ldy $10		                ldy toin                ; >IN
.9655						_loop:
.9655		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.9657		f0 09		beq $9662	                beq _found_char
.9659		b1 0c		lda ($0c),y	                lda (cib),y
.965b		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.965d		d0 03		bne $9662	                bne _found_char
.965f		c8		iny		                iny
.9660		80 f3		bra $9655	                bra _loop
.9662						_found_char:
.9662		84 10		sty $10		                sty toin
.9664		20 d9 8d	jsr $8dd9	                jsr w_parse            ; Returns ( addr u )
.9667		b5 00		lda $00,x	                lda 0,x
.9669		92 00		sta ($00)	                sta (cp)                ; Save length of string
.966b		48		pha		                pha                     ; Keep copy of length for later
.966c		20 a9 86	jsr $86a9	                jsr w_dup              ; ( addr u u )
.966f		a5 00		lda $00		                lda cp
.9671		18		clc		                clc
.9672		69 01		adc #$01	                adc #1
.9674		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.9676		a5 01		lda $01		                lda cp+1
.9678		69 00		adc #$00	                adc #0
.967a		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.967c		20 2e 8c	jsr $8c2e	                jsr w_move
.967f		ca		dex		                dex
.9680		ca		dex		                dex
.9681		a5 00		lda $00		                lda cp
.9683		95 00		sta $00,x	                sta 0,x
.9685		a5 01		lda $01		                lda cp+1
.9687		95 01		sta $01,x	                sta 1,x
.9689		68		pla		                pla                     ; length of string
.968a		18		clc		                clc
.968b		65 00		adc $00		                adc cp
.968d		85 00		sta $00		                sta cp
.968f		90 02		bcc $9693	                bcc z_word
.9691		e6 01		inc $01		                inc cp+1
.9693		60		rts		z_word:         rts
.9694						xt_xor:
.9694		20 87 d8	jsr $d887	                jsr underflow_2
.9697						w_xor:
.9697		b5 00		lda $00,x	                lda 0,x
.9699		55 02		eor $02,x	                eor 2,x
.969b		95 02		sta $02,x	                sta 2,x
.969d		b5 01		lda $01,x	                lda 1,x
.969f		55 03		eor $03,x	                eor 3,x
.96a1		95 03		sta $03,x	                sta 3,x
.96a3		e8		inx		                inx
.96a4		e8		inx		                inx
.96a5		60		rts		z_xor:          rts
.96a6						xt_zero_equal:
.96a6		20 82 d8	jsr $d882	                jsr underflow_1
.96a9						w_zero_equal:
.96a9		b5 00		lda $00,x	                lda 0,x
.96ab		15 01		ora $01,x	                ora 1,x
.96ad		f0 02		beq $96b1	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.96af		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.96b1						_zero:
.96b1		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.96b3		95 00		sta $00,x	                sta 0,x
.96b5		95 01		sta $01,x	                sta 1,x
.96b7		60		rts		z_zero_equal:   rts
.96b8						xt_zero_greater:
.96b8		20 82 d8	jsr $d882	                jsr underflow_1
.96bb						w_zero_greater:
.96bb		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.96bd		b5 01		lda $01,x	                lda 1,x         ; MSB
.96bf		30 05		bmi $96c6	                bmi _done       ; TOS is negative, keep FLASE
.96c1		15 00		ora $00,x	                ora 0,x
.96c3		f0 01		beq $96c6	                beq _done       ; TOS is zero, keep FALSE
.96c5		88		dey		                dey             ; TOS is postive, make true
.96c6						_done:
.96c6		98		tya		                tya
.96c7		95 00		sta $00,x	                sta 0,x
.96c9		95 01		sta $01,x	                sta 1,x
.96cb		60		rts		z_zero_greater: rts
.96cc						xt_zero_less:
.96cc		20 82 d8	jsr $d882	                jsr underflow_1
.96cf						w_zero_less:
.96cf		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.96d1		b5 01		lda $01,x	                lda 1,x         ; MSB
.96d3		10 01		bpl $96d6	                bpl _done       ; TOS is positive, so keep FALSE
.96d5		88		dey		                dey             ; TOS is negative, make TRUE
.96d6						_done:
.96d6		98		tya		                tya
.96d7		95 00		sta $00,x	                sta 0,x
.96d9		95 01		sta $01,x	                sta 1,x
.96db		60		rts		z_zero_less:    rts
.96dc						xt_zero_unequal:
.96dc		20 82 d8	jsr $d882	                jsr underflow_1
.96df						w_zero_unequal:
.96df		b5 00		lda $00,x	                lda 0,x
.96e1		15 01		ora $01,x	                ora 1,x
.96e3		f0 02		beq $96e7	                beq _zero
.96e5		a9 ff		lda #$ff	                lda #$FF
.96e7						_zero:
.96e7		95 00		sta $00,x	                sta 0,x
.96e9		95 01		sta $01,x	                sta 1,x
.96eb		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96ec						xt_compile_comma:
.96ec		20 82 d8	jsr $d882	                jsr underflow_1
.96ef						w_compile_comma:
.96ef		20 a9 86	jsr $86a9	                jsr w_dup              ; keep an unadjusted copy of xt
.96f2		20 a9 86	jsr $86a9	                jsr w_dup              ; plus one to convert to nt
.96f5		20 f3 9b	jsr $9bf3	                jsr w_int_to_name
.96f8		b5 00		lda $00,x	                lda 0,x
.96fa		15 01		ora $01,x	                ora 1,x
.96fc		f0 52		beq $9750	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96fe		20 a9 86	jsr $86a9	                jsr w_dup
.9701		20 16 8d	jsr $8d16	                jsr w_one_plus         ; status is at nt+1
.9704		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.9706		e8		inx		                inx                     ; drop pointer
.9707		e8		inx		                inx
.9708		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.970a		29 08		and #$08	                and #NN
.970c		d0 42		bne $9750	                bne cmpl_as_call        ; never native
.970e		20 1b 9e	jsr $9e1b	                jsr w_wordsize
.9711		20 74 97	jsr $9774	                jsr check_strip_table
.9714		a5 29		lda $29		                lda tmp3
.9716		29 10		and #$10	                and #UF
.9718		f0 1f		beq $9739	                beq _check_limit
.971a		a0 02		ldy #$02	                ldy #uf_strip_offset
.971c		b1 08		lda ($08),y	                lda (up),y
.971e		c8		iny		                iny
.971f		11 08		ora ($08),y	                ora (up),y
.9721		f0 16		beq $9739	                beq _check_limit
.9723		18		clc		                clc
.9724		b5 02		lda $02,x	                lda 2,x
.9726		69 03		adc #$03	                adc #3
.9728		95 02		sta $02,x	                sta 2,x
.972a		90 02		bcc $972e	                bcc +
.972c		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.972e						+
.972e		38		sec		                sec
.972f		b5 00		lda $00,x	                lda 0,x
.9731		e9 03		sbc #$03	                sbc #3
.9733		95 00		sta $00,x	                sta 0,x
.9735		b0 02		bcs $9739	                bcs +
.9737		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.9739						+
.9739						_check_limit:
.9739		a5 29		lda $29		                lda tmp3
.973b		29 02		and #$02	                and #AN                 ; check Always Native (AN) bit
.973d		d0 21		bne $9760	                bne cmpl_inline         ; always natively compile
.973f						cmpl_by_limit:
.973f		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9741		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.9743		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.9745		90 19		bcc $9760	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.9747		d0 07		bne $9750	                bne cmpl_as_call        ; else non-zero means size > limit
.9749		88		dey		                dey
.974a		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.974c		d5 00		cmp $00,x	                cmp 0,x
.974e		b0 10		bcs $9760	                bcs cmpl_inline         ; not bigger, so good to go
.9750						cmpl_as_call:
.9750		20 a3 86	jsr $86a3	                jsr w_drop
.9753		20 61 8c	jsr $8c61	                jsr w_nip
.9756		a9 20		lda #$20	                lda #OpJSR
.9758		20 c7 97	jsr $97c7	                jsr cmpl_a
.975b		20 d0 83	jsr $83d0	                jsr w_comma
.975e		38		sec		                sec
.975f		60		rts		                rts
.9760						cmpl_inline:
.9760		20 34 89	jsr $8934	                jsr w_here
.9763		20 5f 92	jsr $925f	                jsr w_swap
.9766		20 a9 86	jsr $86a9	                jsr w_dup
.9769		20 2a 82	jsr $822a	                jsr w_allot            ; allocate space for the word
.976c		20 2e 8c	jsr $8c2e	                jsr w_move
.976f		20 a3 86	jsr $86a3	                jsr w_drop             ; drop original xt
.9772		18		clc		                clc
.9773		60		rts		                rts
.9774						check_strip_table:
.9774		a0 00		ldy #$00	                ldy #0
.9776						_strip_loop:
.9776		b9 a8 97	lda $97a8,y	                lda _strip_table,y       ; LSB of first word
.9779		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of xt
.977b		d0 07		bne $9784	                bne _next_entry
.977d		b9 a9 97	lda $97a9,y	                lda _strip_table+1,y
.9780		d5 03		cmp $03,x	                cmp 3,x
.9782		f0 07		beq $978b	                beq _found_entry
.9784						_next_entry:
.9784		c8		iny		                iny
.9785		c8		iny		                iny
.9786		c0 0a		cpy #$0a	                cpy #_strip_table_size
.9788		d0 ec		bne $9776	                bne _strip_loop
.978a		60		rts		                rts
.978b						_found_entry:
.978b		98		tya		                tya
.978c		4a		lsr a		                lsr
.978d		a8		tay		                tay
.978e		b9 b2 97	lda $97b2,y	                lda _strip_size,y
.9791		48		pha		                pha                     ; save a copy
.9792		18		clc		                clc
.9793		75 02		adc $02,x	                adc 2,x
.9795		95 02		sta $02,x	                sta 2,x
.9797		90 02		bcc $979b	                bcc +
.9799		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.979b						+
.979b		68		pla		                pla
.979c		0a		asl a		                asl a                   ; Double to cut off both top and bottom.
.979d		f5 00		sbc $00,x	                sbc 0,x
.979f		49 ff		eor #$ff	                eor #$ff
.97a1		95 00		sta $00,x	                sta 0,x
.97a3		90 02		bcc $97a7	                bcc +                   ; note inverted carry check
.97a5		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.97a7						+
.97a7		60		rts		                rts
.97a8						_strip_table:
>97a8		18 8f 03 8f 9a 93		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>97ae		c3 94 49 94			                .word xt_two_to_r, xt_two_r_from        ; 2>R, 2R>
=10						_strip_table_size = * - _strip_table
.97b2						_strip_size:
>97b2		04 04 04			                .byte 4, 4, 4                           ; R>, R@, >R
>97b5		06 06				                .byte 6, 6                              ; 2>R, 2R>
.97b7						z_compile_comma:
.97b7						cmpl_subroutine:
.97b7		48		pha		                pha             ; save LSB of address
.97b8		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.97ba		80 03		bra $97bf	                bra +
.97bc						cmpl_jump:
.97bc		48		pha		                pha             ; save LSB of address
.97bd		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.97bf						+
.97bf		20 c7 97	jsr $97c7	                jsr cmpl_a      ; compile opcode
.97c2		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.97c3						cmpl_word:
.97c3		20 c7 97	jsr $97c7	                jsr cmpl_a      ; compile LSB of address
.97c6		98		tya		                tya             ; fall thru for MSB
.97c7						cmpl_a:
.97c7		92 00		sta ($00)	                sta (cp)
.97c9		e6 00		inc $00		                inc cp
.97cb		d0 02		bne $97cf	                bne _done
.97cd		e6 01		inc $01		                inc cp+1
.97cf						_done:
.97cf		60		rts		                rts
.97d0						cmpl_jump_tos:
.97d0		a9 4c		lda #$4c	                lda #OpJMP
.97d2		20 c7 97	jsr $97c7	                jsr cmpl_a
.97d5		4c d0 83	jmp $83d0	                jmp w_comma
.97d8						cmpl_jump_later:
.97d8		a9 4c		lda #$4c	                lda #OpJMP
.97da		20 c7 97	jsr $97c7	                jsr cmpl_a
.97dd		20 34 89	jsr $8934	                jsr w_here
.97e0		80 e1		bra $97c3	                bra cmpl_word
.97e2						check_nc_limit:
.97e2		48		pha		                pha
.97e3		38		sec		                sec
.97e4		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.97e6		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.97e8		f0 01		beq $97eb	                beq +
.97ea		18		clc		                clc
.97eb						+
.97eb		68		pla		                pla
.97ec		90 05		bcc $97f3	                bcc _done
.97ee		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.97ef		88		dey		                dey
.97f0		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.97f2		1a		inc a		                ina                     ; restore A, preserves carry
.97f3						_done:
.97f3		60		rts		                rts
.97f4						cmpl_0branch_later:
.97f4		20 39 9e	jsr $9e39	                jsr w_zero             ; dummy placeholder, which forces long jmp in native version
.97f7		20 09 98	jsr $9809	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.97fa		20 34 89	jsr $8934	                jsr w_here             ; either way the target address is two bytes before here
.97fd		38		sec		                sec
.97fe		b5 00		lda $00,x	                lda 0,x
.9800		e9 02		sbc #$02	                sbc #2
.9802		95 00		sta $00,x	                sta 0,x
.9804		b0 02		bcs $9808	                bcs +
.9806		d6 01		dec $01,x	                dec 1,x
.9808						+
.9808		60		rts		                rts
.9809						cmpl_0branch_tos:
.9809		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.980b		20 e2 97	jsr $97e2	                jsr check_nc_limit              ; returns C=0 if we should native compile
.980e		90 0a		bcc $981a	                bcc _inline
.9810		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.9812		a9 6b		lda #$6b	                lda #<zero_branch_runtime
.9814		20 b7 97	jsr $97b7	                jsr cmpl_subroutine             ; call the 0branch runtime
.9817		4c d0 83	jmp $83d0	                jmp w_comma                    ; add the payload and return
.981a						_inline:
.981a		a0 00		ldy #$00	                ldy #0
.981c						-
.981c		b9 6b 98	lda $986b,y	                lda ztest_runtime,y
.981f		20 c7 97	jsr $97c7	                jsr cmpl_a
.9822		c8		iny		                iny
.9823		c0 06		cpy #$06	                cpy #ztest_runtime_size
.9825		d0 f5		bne $981c	                bne -
.9827		b5 00		lda $00,x	                lda 0,x
.9829		15 01		ora $01,x	                ora 1,x
.982b		f0 31		beq $985e	                beq _long               ; always use the long form if target is 0
.982d		20 a9 86	jsr $86a9	                jsr w_dup
.9830		20 34 89	jsr $8934	                jsr w_here
.9833		18		clc		                clc
.9834		a9 02		lda #$02	                lda #2
.9836		75 00		adc $00,x	                adc 0,x
.9838		95 00		sta $00,x	                sta 0,x
.983a		90 02		bcc $983e	                bcc +
.983c		f6 01		inc $01,x	                inc 1,x
.983e						+
.983e		20 12 8c	jsr $8c12	                jsr w_minus
.9841		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.9842		e8		inx		                inx
.9843		b5 ff		lda $ff,x	                lda $ff,x
.9845		a8		tay		                tay             ; Y=MSB of offset
.9846		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.9848		30 04		bmi $984e	                bmi _minus
.984a		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.984c		80 02		bra $9850	                bra +
.984e		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.9850		d0 0c		bne $985e	+               bne _long
.9852		a9 f0		lda #$f0	                lda #OpBEQ
.9854		20 c7 97	jsr $97c7	                jsr cmpl_a
.9857		b5 fe		lda $fe,x	                lda $fe,x
.9859		e8		inx		                inx             ; drop the original address we used to calc offset
.985a		e8		inx		                inx
.985b		4c c7 97	jmp $97c7	                jmp cmpl_a
.985e						_long:
.985e		a9 d0		lda #$d0	                lda #OpBNE
.9860		20 c7 97	jsr $97c7	                jsr cmpl_a
.9863		a9 03		lda #$03	                lda #3
.9865		20 c7 97	jsr $97c7	                jsr cmpl_a
.9868		4c d0 97	jmp $97d0	                jmp cmpl_jump_tos
.986b						zero_branch_runtime:
.986b						ztest_runtime:
.986b		e8		inx		                inx
.986c		e8		inx		                inx
.986d		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.986f		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.9871						zbranch_runtime:
.9871		7a		ply		                ply
.9872		84 25		sty $25		                sty tmp1
.9874		7a		ply		                ply
.9875		84 26		sty $26		                sty tmp1+1
.9877		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.9878		f0 0d		beq $9887	                beq _branch
.987a		18		clc		                clc
.987b		a5 25		lda $25		                lda tmp1        ; LSB
.987d		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.987f		85 25		sta $25		                sta tmp1
.9881		90 11		bcc $9894	                bcc _jmp
.9883		e6 26		inc $26		                inc tmp1+1
.9885		80 0d		bra $9894	                bra _jmp
.9887						_branch:
.9887		a0 01		ldy #$01	                ldy #1
.9889		b1 25		lda ($25),y	                lda (tmp1),y
.988b		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.988c		c8		iny		                iny
.988d		b1 25		lda ($25),y	                lda (tmp1),y
.988f		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.9891		68		pla		                pla
.9892		85 25		sta $25		                sta tmp1
.9894						_jmp:
.9894		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.9897						xt_bye:
.9897						w_bye:
.9897		4c 26 f0	jmp $f026	                jmp kernel_bye
.989a						z_bye:
.989a						xt_dot_s:
.989a						w_dot_s:
.989a		20 58 85	jsr $8558	                jsr w_depth    ; ( -- u )
.989d		a9 3c		lda #$3c	                lda #'<'
.989f		20 d3 86	jsr $86d3	                jsr emit_a
.98a2		b5 00		lda $00,x	                lda 0,x
.98a4		48		pha		                pha
.98a5		ca		dex		                dex             ; DUP
.98a6		ca		dex		                dex
.98a7		95 00		sta $00,x	                sta 0,x
.98a9		74 01		stz $01,x	                stz 1,x
.98ab		20 ef d8	jsr $d8ef	                jsr print_u
.98ae		a9 3e		lda #$3e	                lda #'>'
.98b0		20 d3 86	jsr $86d3	                jsr emit_a
.98b3		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.98b5		20 d3 86	jsr $86d3	                jsr emit_a
.98b8		e8		inx		                inx
.98b9		e8		inx		                inx
.98ba		e0 78		cpx #$78	                cpx #dsp0
.98bc		f0 1e		beq $98dc	                beq _done
.98be		7a		ply		                ply
.98bf		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.98c1		85 29		sta $29		                sta tmp3
.98c3		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.98c5						_loop:
.98c5		ca		dex		                dex
.98c6		ca		dex		                dex
.98c7		b2 29		lda ($29)	                lda (tmp3)
.98c9		95 01		sta $01,x	                sta 1,x
.98cb		c6 29		dec $29		                dec tmp3
.98cd		b2 29		lda ($29)	                lda (tmp3)
.98cf		95 00		sta $00,x	                sta 0,x
.98d1		c6 29		dec $29		                dec tmp3
.98d3		5a		phy		                phy
.98d4		20 39 86	jsr $8639	                jsr w_dot
.98d7		7a		ply		                ply
.98d8		88		dey		                dey
.98d9		d0 ea		bne $98c5	                bne _loop
.98db		48		pha		                pha             ; dummy to balance stack
.98dc						_done:
.98dc		68		pla		                pla
.98dd		60		rts		z_dot_s:        rts
.98de						xt_dump:
.98de		20 87 d8	jsr $d887	                jsr underflow_2
.98e1						w_dump:
.98e1						_row:
.98e1		a0 10		ldy #$10	                ldy #16
.98e3		64 27		stz $27		                stz tmp2
.98e5		20 3a 84	jsr $843a	                jsr w_cr
.98e8		b5 03		lda $03,x	                lda 3,x
.98ea		20 4d d7	jsr $d74d	                jsr byte_to_ascii
.98ed		b5 02		lda $02,x	                lda 2,x
.98ef		20 4d d7	jsr $d74d	                jsr byte_to_ascii
.98f2		20 f6 91	jsr $91f6	                jsr w_space
.98f5		20 f6 91	jsr $91f6	                jsr w_space
.98f8						_loop:
.98f8		b5 00		lda $00,x	                lda 0,x
.98fa		15 01		ora $01,x	                ora 1,x
.98fc		f0 39		beq $9937	                beq _all_printed
.98fe		a1 02		lda ($02,x)	                lda (2,x)
.9900		48		pha		                pha                     ; byte_to_ascii destroys A
.9901		20 4d d7	jsr $d74d	                jsr byte_to_ascii
.9904		20 f6 91	jsr $91f6	                jsr w_space
.9907		68		pla		                pla
.9908		20 68 d8	jsr $d868	                jsr is_printable
.990b		b0 02		bcs $990f	                bcs _printable
.990d		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.990f						_printable:
.990f		5a		phy		                phy                     ; save counter
.9910		a4 27		ldy $27		                ldy tmp2
.9912		91 00		sta ($00),y	                sta (cp),y
.9914		e6 27		inc $27		                inc tmp2
.9916		7a		ply		                ply
.9917		c0 09		cpy #$09	                cpy #9
.9919		d0 03		bne $991e	                bne _next_char
.991b		20 f6 91	jsr $91f6	                jsr w_space
.991e						_next_char:
.991e		f6 02		inc $02,x	                inc 2,x
.9920		d0 02		bne $9924	                bne _counter
.9922		f6 03		inc $03,x	                inc 3,x
.9924						_counter:
.9924		b5 00		lda $00,x	                lda 0,x
.9926		d0 02		bne $992a	                bne +
.9928		d6 01		dec $01,x	                dec 1,x
.992a						+
.992a		d6 00		dec $00,x	                dec 0,x
.992c		88		dey		                dey
.992d		d0 c9		bne $98f8	                bne _loop               ; next byte
.992f		20 f6 91	jsr $91f6	                jsr w_space
.9932		20 45 99	jsr $9945	                jsr dump_print_ascii
.9935		80 aa		bra $98e1	                bra _row                ; new row
.9937						_all_printed:
.9937		a5 27		lda $27		                lda tmp2
.9939		f0 06		beq $9941	                beq _done
.993b		20 f6 91	jsr $91f6	                jsr w_space
.993e		20 45 99	jsr $9945	                jsr dump_print_ascii
.9941						_done:
.9941		20 d4 93	jsr $93d4	                jsr w_two_drop         ; one byte less than 4x INX
.9944		60		rts		z_dump:         rts
.9945						dump_print_ascii:
.9945		a0 00		ldy #$00	                ldy #0
.9947						_ascii_loop:
.9947		b1 00		lda ($00),y	                lda (cp),y
.9949		20 d3 86	jsr $86d3	                jsr emit_a
.994c		c8		iny		                iny
.994d		c0 08		cpy #$08	                cpy #8
.994f		d0 03		bne $9954	                bne +
.9951		20 f6 91	jsr $91f6	                jsr w_space
.9954						+
.9954		c6 27		dec $27		                dec tmp2
.9956		d0 ef		bne $9947	                bne _ascii_loop
.9958		60		rts		                rts
.9959						xt_question:
.9959						w_question:
.9959		20 36 88	jsr $8836	                jsr w_fetch
.995c		20 39 86	jsr $8639	                jsr w_dot
.995f		60		rts		z_question:     rts
.9960						xt_see:
.9960						w_see:
.9960		20 7b 8d	jsr $8d7b	                jsr w_parse_name       ; ( addr u )
.9963		20 30 9b	jsr $9b30	                jsr w_find_name        ; ( nt | 0 )
.9966		b5 00		lda $00,x	                lda 0,x
.9968		15 01		ora $01,x	                ora 1,x
.996a		d0 05		bne $9971	                bne +
.996c		a9 05		lda #$05	                lda #err_noname
.996e		4c 98 d8	jmp $d898	                jmp error
.9971						+
.9971		20 3a 84	jsr $843a	                jsr w_cr
.9974		a5 18		lda $18		                lda base
.9976		48		pha		                pha
.9977		20 3f 89	jsr $893f	                jsr w_hex
.997a		a9 09		lda #$09	                lda #str_see_nt
.997c		20 be d8	jsr $d8be	                jsr print_string_no_lf
.997f		20 a9 86	jsr $86a9	                jsr w_dup              ; ( nt nt )
.9982		20 11 95	jsr $9511	                jsr w_u_dot
.9985		20 f6 91	jsr $91f6	                jsr w_space            ; ( nt )
.9988		20 a9 86	jsr $86a9	                jsr w_dup              ; ( nt nt )
.998b		20 79 9c	jsr $9c79	                jsr w_name_to_int      ; ( nt xt )
.998e		a9 0a		lda #$0a	                lda #str_see_xt
.9990		20 be d8	jsr $d8be	                jsr print_string_no_lf
.9993		20 a9 86	jsr $86a9	                jsr w_dup              ; ( nt xt xt )
.9996		20 11 95	jsr $9511	                jsr w_u_dot
.9999		20 3a 84	jsr $843a	                jsr w_cr               ; ( nt xt )
.999c		a9 08		lda #$08	                lda #str_see_flags
.999e		20 be d8	jsr $d8be	                jsr print_string_no_lf
.99a1		20 32 8d	jsr $8d32	                jsr w_over             ; ( nt xt nt )
.99a4		20 16 8d	jsr $8d16	                jsr w_one_plus         ; ( nt xt nt+1 )
.99a7		20 36 88	jsr $8836	                jsr w_fetch            ; ( nt xt flags )
.99aa		b5 00		lda $00,x	                lda 0,x
.99ac		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.99ae						_flag_loop:
.99ae		48		pha		                pha
.99af		29 01		and #$01	                and #%00000001
.99b1		18		clc		                clc
.99b2		69 30		adc #$30	                adc #'0'
.99b4		20 d3 86	jsr $86d3	                jsr emit_a
.99b7		20 f6 91	jsr $91f6	                jsr w_space
.99ba		68		pla		                pla
.99bb		6a		ror a		                ror                     ; Next flag
.99bc		88		dey		                dey
.99bd		d0 ef		bne $99ae	                bne _flag_loop
.99bf		20 3a 84	jsr $843a	                jsr w_cr
.99c2		e8		inx		                inx
.99c3		e8		inx		                inx                     ; ( nt xt )
.99c4		a9 0b		lda #$0b	                lda #str_see_size
.99c6		20 be d8	jsr $d8be	                jsr print_string_no_lf
.99c9		20 5f 92	jsr $925f	                jsr w_swap             ; ( xt nt )
.99cc		20 1b 9e	jsr $9e1b	                jsr w_wordsize         ; ( xt u )
.99cf		20 a9 86	jsr $86a9	                jsr w_dup              ; ( xt u u ) for DUMP and DISASM
.99d2		20 0a 85	jsr $850a	                jsr w_decimal
.99d5		20 11 95	jsr $9511	                jsr w_u_dot            ; ( xt u )
.99d8		20 3f 89	jsr $893f	                jsr w_hex
.99db		20 3a 84	jsr $843a	                jsr w_cr
.99de		20 dc 93	jsr $93dc	                jsr w_two_dup          ; ( xt u xt u )
.99e1		20 e1 98	jsr $98e1	                jsr w_dump
.99e4		20 3a 84	jsr $843a	                jsr w_cr
.99e7		20 50 a2	jsr $a250	                jsr w_disasm
.99ea		68		pla		                pla
.99eb		85 18		sta $18		                sta base
.99ed		60		rts		z_see:          rts
.99ee						xt_words:
.99ee						w_words:
.99ee		20 3a 84	jsr $843a	                jsr w_cr
.99f1		a9 00		lda #$00	                lda #0
.99f3		48		pha		                pha
.99f4		ca		dex		                dex                     ; Make room on the stack for
.99f5		ca		dex		                dex                     ; a dictionary pointer.
.99f6		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.99f8						_wordlist_loop:
.99f8		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.99fa		a5 29		lda $29		                lda tmp3
.99fc		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.99fe		d0 02		bne $9a02	                bne _have_wordlist
.9a00		80 45		bra $9a47	                bra _words_done
.9a02						_have_wordlist:
.9a02		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.9a03		69 23		adc #$23	                adc #search_order_offset
.9a05		a8		tay		                tay
.9a06		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.9a08		0a		asl a		                asl                     ; Turn offset into cells offset.
.9a09		18		clc		                clc
.9a0a		69 0a		adc #$0a	                adc #wordlists_offset
.9a0c		a8		tay		                tay
.9a0d		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9a0f		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.9a11		c8		iny		                iny
.9a12		b1 08		lda ($08),y	                lda (up),y
.9a14		95 01		sta $01,x	                sta 1,x
.9a16						_loop:
.9a16		20 a9 86	jsr $86a9	                jsr w_dup              ; ( nt nt )
.9a19		20 96 9c	jsr $9c96	                jsr w_name_to_string   ; ( nt addr u )
.9a1c		68		pla		                pla
.9a1d		18		clc		                clc
.9a1e		75 00		adc $00,x	                adc 0,x
.9a20		1a		inc a		                ina                     ; don't forget the space between words
.9a21		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.9a23		90 06		bcc $9a2b	                bcc +
.9a25		20 3a 84	jsr $843a	                jsr w_cr
.9a28		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.9a2a		1a		inc a		                ina                     ; with length of this word.
.9a2b						+
.9a2b		48		pha		                pha
.9a2c		20 e6 94	jsr $94e6	                jsr w_type             ; ( nt )
.9a2f		a9 20		lda #$20	                lda #AscSP
.9a31		20 d3 86	jsr $86d3	                jsr emit_a
.9a34		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+
.9a37		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+
.9a3a		20 36 88	jsr $8836	                jsr w_fetch            ; @ ( nt+1 )
.9a3d		b5 00		lda $00,x	                lda 0,x
.9a3f		15 01		ora $01,x	                ora 1,x
.9a41		d0 d3		bne $9a16	                bne _loop
.9a43		e6 29		inc $29		                inc tmp3
.9a45		80 b1		bra $99f8	                bra _wordlist_loop
.9a47						_words_done:
.9a47		68		pla		                pla                     ; dump counter
.9a48		e8		inx		                inx
.9a49		e8		inx		                inx
.9a4a		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.9a4b						xt_allow_native:
.9a4b						w_allow_native:
.9a4b		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.9a4e		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a50		b1 02		lda ($02),y	                lda (dp),y
.9a52		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.9a54		91 02		sta ($02),y	                sta (dp),y
.9a56						z_allow_native:
.9a56		60		rts		                rts
.9a57						xt_always_native:
.9a57						w_always_native:
.9a57		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.9a5a		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a5c		b1 02		lda ($02),y	                lda (dp),y
.9a5e		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.9a60		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a62		91 02		sta ($02),y	                sta (dp),y
.9a64						z_always_native:
.9a64		60		rts		                rts
.9a65						xt_bell:
.9a65						w_bell:
.9a65		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.9a67		20 d3 86	jsr $86d3	                jsr emit_a
.9a6a		60		rts		z_bell:         rts
.9a6b						xt_bounds:
.9a6b		20 87 d8	jsr $d887	                jsr underflow_2
.9a6e						w_bounds:
.9a6e		18		clc		                clc
.9a6f		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a71		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9a73		75 02		adc $02,x	                adc 2,x
.9a75		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9a77		94 00		sty $00,x	                sty 0,x
.9a79		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9a7b		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9a7d		75 03		adc $03,x	                adc 3,x
.9a7f		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9a81		94 01		sty $01,x	                sty 1,x
.9a83		60		rts		z_bounds:       rts
.9a84						xt_cleave:
.9a84		20 87 d8	jsr $d887	                jsr underflow_2
.9a87						w_cleave:
.9a87		20 cf a0	jsr $a0cf	                jsr w_minus_leading    ; -LEADING ( addr u )
.9a8a		20 da 9b	jsr $9bda	                jsr w_input_to_r       ; save old imput state
.9a8d		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9a8f		85 0e		sta $0e		                sta ciblen
.9a91		b5 01		lda $01,x	                lda 1,x
.9a93		85 0f		sta $0f		                sta ciblen+1
.9a95		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9a97		85 0c		sta $0c		                sta cib
.9a99		b5 03		lda $03,x	                lda 3,x
.9a9b		85 0d		sta $0d		                sta cib+1
.9a9d		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9a9f		64 11		stz $11		                stz toin+1
.9aa1		20 7b 8d	jsr $8d7b	                jsr w_parse_name       ; ( addr u addr-s u-s )
.9aa4		b5 00		lda $00,x	                lda 0,x
.9aa6		15 01		ora $01,x	                ora 1,x
.9aa8		f0 23		beq $9acd	                beq _done
.9aaa		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9aac		38		sec		                sec
.9aad		f5 00		sbc $00,x	                sbc 0,x
.9aaf		95 04		sta $04,x	                sta 4,x
.9ab1		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9ab3		f5 01		sbc $01,x	                sbc 1,x
.9ab5		95 05		sta $05,x	                sta 5,x
.9ab7		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9ab9		18		clc		                clc
.9aba		75 00		adc $00,x	                adc 0,x
.9abc		95 06		sta $06,x	                sta 6,x
.9abe		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9ac0		75 01		adc $01,x	                adc 1,x
.9ac2		95 07		sta $07,x	                sta 7,x
.9ac4		20 a2 94	jsr $94a2	                jsr w_two_swap         ; ( addr-s u-s addr u )
.9ac7		20 cf a0	jsr $a0cf	                jsr w_minus_leading
.9aca		20 a2 94	jsr $94a2	                jsr w_two_swap         ; ( addr u addr-s u-s )
.9acd						_done:
.9acd		20 e7 9d	jsr $9de7	                jsr w_r_to_input
.9ad0		60		rts		z_cleave:       rts
.9ad1						xt_digit_question:
.9ad1		20 82 d8	jsr $d882	                jsr underflow_1
.9ad4						w_digit_question:
.9ad4		ca		dex		                dex
.9ad5		ca		dex		                dex
.9ad6		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9ad8		74 01		stz $01,x	                stz 1,x
.9ada		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9adc		b5 02		lda $02,x	                lda 2,x
.9ade		c9 30		cmp #$30	                cmp #'0'
.9ae0		90 23		bcc $9b05	                bcc _done               ; failure flag already set
.9ae2		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9ae4		90 12		bcc $9af8	                bcc _checkbase
.9ae6		c9 41		cmp #$41	                cmp #'A'
.9ae8		90 1b		bcc $9b05	                bcc _done               ; failure flag is already set
.9aea		c9 61		cmp #$61	                cmp #'a'
.9aec		90 07		bcc $9af5	                bcc _case_done          ; not lower case, too low
.9aee		c9 7b		cmp #$7b	                cmp #'z'+1
.9af0		b0 03		bcs $9af5	                bcs _case_done          ; not lower case, too high
.9af2		18		clc		                clc                     ; just right
.9af3		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9af5						_case_done:
.9af5		38		sec		                sec
.9af6		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9af8						_checkbase:
.9af8		38		sec		                sec
.9af9		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9afb		c5 18		cmp $18		                cmp base
.9afd		b0 06		bcs $9b05	                bcs _done               ; already have false flag
.9aff		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9b01		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9b03		d6 01		dec $01,x	                dec 1,x
.9b05						_done:
.9b05						z_digit_question:
.9b05		60		rts		                rts
.9b06						xt_execute_parsing:
.9b06		20 8c d8	jsr $d88c	                jsr underflow_3
.9b09						w_execute_parsing:
.9b09		20 da 9b	jsr $9bda	                jsr w_input_to_r       ; save normal input for later
.9b0c		20 c0 9c	jsr $9cc0	                jsr w_not_rot          ; -ROT ( xt addr u )
.9b0f		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9b11		85 0e		sta $0e		                sta ciblen
.9b13		b5 01		lda $01,x	                lda 1,x
.9b15		85 0f		sta $0f		                sta ciblen+1
.9b17		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9b19		85 0c		sta $0c		                sta cib
.9b1b		b5 03		lda $03,x	                lda 3,x
.9b1d		85 0d		sta $0d		                sta cib+1
.9b1f		64 10		stz $10		                stz toin                ; Set >IN to zero
.9b21		64 11		stz $11		                stz toin+1
.9b23		20 d4 93	jsr $93d4	                jsr w_two_drop         ; 2DROP ( xt )
.9b26		20 21 88	jsr $8821	                jsr w_execute
.9b29		20 e7 9d	jsr $9de7	                jsr w_r_to_input
.9b2c						z_execute_parsing:
.9b2c		60		rts		                rts
.9b2d						xt_find_name:
.9b2d		20 87 d8	jsr $d887	                jsr underflow_2
.9b30						w_find_name:
.9b30		b5 00		lda $00,x	                lda 0,x
.9b32		15 01		ora $01,x	                ora 1,x
.9b34		d0 03		bne $9b39	                bne _nonempty
.9b36		4c 6a 9b	jmp $9b6a	                jmp _fail_done
.9b39						_nonempty:
.9b39		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9b3b						_wordlist_loop:
.9b3b		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9b3d		a5 29		lda $29		                lda tmp3
.9b3f		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9b41		f0 27		beq $9b6a	                beq _fail_done
.9b43		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9b44		69 23		adc #$23	                adc #search_order_offset
.9b46		a8		tay		                tay
.9b47		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9b49		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b4a		18		clc		                clc
.9b4b		69 0a		adc #$0a	                adc #wordlists_offset
.9b4d		a8		tay		                tay
.9b4e		b1 08		lda ($08),y	                lda (up),y
.9b50		85 25		sta $25		                sta tmp1
.9b52		c8		iny		                iny
.9b53		b1 08		lda ($08),y	                lda (up),y
.9b55		85 26		sta $26		                sta tmp1+1
.9b57		20 64 d7	jsr $d764	                jsr find_header_name
.9b5a		d0 04		bne $9b60	                bne _success
.9b5c		e6 29		inc $29		                inc tmp3
.9b5e		80 db		bra $9b3b	                bra _wordlist_loop
.9b60						_success:
.9b60		a5 25		lda $25		                lda tmp1
.9b62		95 02		sta $02,x	                sta 2,x
.9b64		a5 26		lda $26		                lda tmp1+1
.9b66		95 03		sta $03,x	                sta 3,x
.9b68		80 04		bra $9b6e	                bra _done
.9b6a						_fail_done:
.9b6a		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b6c		74 03		stz $03,x	                stz 3,x
.9b6e						_done:
.9b6e		e8		inx		                inx
.9b6f		e8		inx		                inx
.9b70		60		rts		z_find_name:    rts
.9b71						xt_havekey:
.9b71						w_havekey:
.9b71		ca		dex		                dex
.9b72		ca		dex		                dex
.9b73		a9 16		lda #$16	                lda #<havekey
.9b75		95 00		sta $00,x	                sta 0,x
.9b77		a9 00		lda #$00	                lda #>havekey
.9b79		95 01		sta $01,x	                sta 1,x
.9b7b		60		rts		z_havekey:      rts
.9b7c						xt_hexstore:
.9b7c		20 8c d8	jsr $d88c	                jsr underflow_3
.9b7f						w_hexstore:
.9b7f		20 a9 86	jsr $86a9	                jsr w_dup              ; Save copy of original address
.9b82		20 c3 94	jsr $94c3	                jsr w_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b85						_loop:
.9b85		b5 00		lda $00,x	                lda 0,x
.9b87		15 01		ora $01,x	                ora 1,x
.9b89		f0 36		beq $9bc1	                beq _done
.9b8b		20 87 9a	jsr $9a87	                jsr w_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9b8e		20 c3 94	jsr $94c3	                jsr w_two_to_r
.9b91		20 39 9e	jsr $9e39	                jsr w_zero
.9b94		20 39 9e	jsr $9e39	                jsr w_zero
.9b97		20 49 94	jsr $9449	                jsr w_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9b9a		20 fd 92	jsr $92fd	                jsr w_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9b9d		b5 00		lda $00,x	                lda 0,x
.9b9f		15 01		ora $01,x	                ora 1,x
.9ba1		d0 17		bne $9bba	                bne _have_chars_left
.9ba3		20 d4 93	jsr $93d4	                jsr w_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9ba6		20 85 9e	jsr $9e85	                jsr w_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9ba9		20 03 8f	jsr $8f03	                jsr w_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9bac		20 3a 83	jsr $833a	                jsr w_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9baf		20 18 8f	jsr $8f18	                jsr w_r_from           ; R>
.9bb2		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+
.9bb5		20 9a 93	jsr $939a	                jsr w_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9bb8		80 cb		bra $9b85	                bra _loop
.9bba						_have_chars_left:
.9bba		8a		txa		                txa
.9bbb		18		clc		                clc
.9bbc		69 08		adc #$08	                adc #8
.9bbe		aa		tax		                tax
.9bbf		80 c4		bra $9b85	                bra _loop
.9bc1						_done:
.9bc1		e8		inx		                inx
.9bc2		e8		inx		                inx
.9bc3		e8		inx		                inx
.9bc4		e8		inx		                inx                     ; 2DROP
.9bc5		20 49 94	jsr $9449	                jsr w_two_r_from       ; ( addr2+n addr2 )
.9bc8		20 5f 92	jsr $925f	                jsr w_swap
.9bcb		20 12 8c	jsr $8c12	                jsr w_minus            ; ( n )
.9bce		60		rts		z_hexstore:     rts
.9bcf						xt_input:
.9bcf						w_input:
.9bcf		ca		dex		                dex
.9bd0		ca		dex		                dex
.9bd1		a9 14		lda #$14	                lda #<input
.9bd3		95 00		sta $00,x	                sta 0,x
.9bd5		a9 00		lda #$00	                lda #>input
.9bd7		95 01		sta $01,x	                sta 1,x
.9bd9		60		rts		z_input:        rts
.9bda						xt_input_to_r:
.9bda						w_input_to_r:
.9bda		68		pla		                pla
.9bdb		85 25		sta $25		                sta tmp1
.9bdd		68		pla		                pla
.9bde		85 26		sta $26		                sta tmp1+1
.9be0		a0 07		ldy #$07	                ldy #7
.9be2						_loop:
.9be2		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9be5		48		pha		                pha
.9be6		88		dey		                dey
.9be7		10 f9		bpl $9be2	                bpl _loop
.9be9		a5 26		lda $26		                lda tmp1+1
.9beb		48		pha		                pha
.9bec		a5 25		lda $25		                lda tmp1
.9bee		48		pha		                pha
.9bef		60		rts		z_input_to_r: 	rts
.9bf0						xt_int_to_name:
.9bf0		20 82 d8	jsr $d882	                jsr underflow_1
.9bf3						w_int_to_name:
.9bf3		ca		dex		                dex
.9bf4		ca		dex		                dex
.9bf5		74 00		stz $00,x	                stz 0,x
.9bf7		74 01		stz $01,x	                stz 1,x
.9bf9						_wordlist_loop:
.9bf9		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9bfb		0a		asl a		                asl                     ; Turn offset into cells offset.
.9bfc		18		clc		                clc
.9bfd		69 0a		adc #$0a	                adc #wordlists_offset
.9bff		a8		tay		                tay
.9c00		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9c02		85 27		sta $27		                sta tmp2                ; into tmp2
.9c04		c8		iny		                iny
.9c05		b1 08		lda ($08),y	                lda (up),y
.9c07		85 28		sta $28		                sta tmp2+1
.9c09		a5 27		lda $27		                lda tmp2
.9c0b		05 28		ora $28		                ora tmp2+1
.9c0d		f0 36		beq $9c45	                beq _next_wordlist
.9c0f		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9c11		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9c13		b5 03		lda $03,x	                lda 3,x
.9c15		85 2a		sta $2a		                sta tmp3+1
.9c17						_loop:
.9c17		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9c19		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9c1b		c5 29		cmp $29		                cmp tmp3
.9c1d		d0 07		bne $9c26	                bne _no_match
.9c1f		c8		iny		                iny
.9c20		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9c22		c5 2a		cmp $2a		                cmp tmp3+1
.9c24		f0 30		beq $9c56	                beq _match
.9c26						_no_match:
.9c26		18		clc		                clc
.9c27		a5 27		lda $27		                lda tmp2
.9c29		69 02		adc #$02	                adc #2
.9c2b		85 27		sta $27		                sta tmp2
.9c2d		90 02		bcc $9c31	                bcc +
.9c2f		e6 28		inc $28		                inc tmp2+1
.9c31						+
.9c31		a0 00		ldy #$00	                ldy #0
.9c33		b1 27		lda ($27),y	                lda (tmp2),y
.9c35		48		pha		                pha
.9c36		c8		iny		                iny
.9c37		11 27		ora ($27),y	                ora (tmp2),y
.9c39		f0 09		beq $9c44	                beq _zero
.9c3b		b1 27		lda ($27),y	                lda (tmp2),y
.9c3d		85 28		sta $28		                sta tmp2+1
.9c3f		68		pla		                pla
.9c40		85 27		sta $27		                sta tmp2
.9c42		80 d3		bra $9c17	                bra _loop
.9c44						_zero:
.9c44		68		pla		                pla             ; Leftover from above loop
.9c45						_next_wordlist:
.9c45		b5 00		lda $00,x	                lda 0,x
.9c47		1a		inc a		                ina
.9c48		95 00		sta $00,x	                sta 0,x
.9c4a		c9 0c		cmp #$0c	                cmp #max_wordlists
.9c4c		d0 ab		bne $9bf9	                bne _wordlist_loop
.9c4e		e8		inx		                inx
.9c4f		e8		inx		                inx
.9c50		74 00		stz $00,x	                stz 0,x
.9c52		74 01		stz $01,x	                stz 1,x
.9c54		80 0a		bra $9c60	                bra z_int_to_name
.9c56						_match:
.9c56		e8		inx		                inx
.9c57		e8		inx		                inx
.9c58		a5 27		lda $27		                lda tmp2
.9c5a		95 00		sta $00,x	                sta 0,x
.9c5c		a5 28		lda $28		                lda tmp2+1
.9c5e		95 01		sta $01,x	                sta 1,x
.9c60		60		rts		z_int_to_name:  rts
.9c61						xt_latestnt:
.9c61						w_latestnt:
.9c61		ca		dex		                dex
.9c62		ca		dex		                dex
.9c63		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.9c66		a5 02		lda $02		                lda dp
.9c68		95 00		sta $00,x	                sta 0,x
.9c6a		a5 03		lda $03		                lda dp+1
.9c6c		95 01		sta $01,x	                sta 1,x
.9c6e		60		rts		z_latestnt:     rts
.9c6f						xt_latestxt:
.9c6f						w_latestxt:
.9c6f		20 61 9c	jsr $9c61	                jsr w_latestnt         ; ( nt )
.9c72		20 79 9c	jsr $9c79	                jsr w_name_to_int      ; ( xt )
.9c75		60		rts		z_latestxt:     rts
.9c76						xt_name_to_int:
.9c76		20 82 d8	jsr $d882	                jsr underflow_1
.9c79						w_name_to_int:
.9c79		b5 00		lda $00,x	                lda 0,x
.9c7b		18		clc		                clc
.9c7c		69 04		adc #$04	                adc #4
.9c7e		85 29		sta $29		                sta tmp3
.9c80		b5 01		lda $01,x	                lda 1,x
.9c82		90 01		bcc $9c85	                bcc _done
.9c84		1a		inc a		                ina
.9c85						_done:
.9c85		85 2a		sta $2a		                sta tmp3+1
.9c87		a0 00		ldy #$00	                ldy #0
.9c89		b1 29		lda ($29),y	                lda (tmp3),y
.9c8b		95 00		sta $00,x	                sta 0,x
.9c8d		c8		iny		                iny
.9c8e		b1 29		lda ($29),y	                lda (tmp3),y
.9c90		95 01		sta $01,x	                sta 1,x
.9c92		60		rts		z_name_to_int:  rts
.9c93						xt_name_to_string:
.9c93		20 82 d8	jsr $d882	                jsr underflow_1
.9c96						w_name_to_string:
.9c96		ca		dex		                dex
.9c97		ca		dex		                dex
.9c98		a1 02		lda ($02,x)	                lda (2,x)
.9c9a		95 00		sta $00,x	                sta 0,x
.9c9c		74 01		stz $01,x	                stz 1,x
.9c9e		b5 02		lda $02,x	                lda 2,x         ; LSB
.9ca0		18		clc		                clc
.9ca1		69 08		adc #$08	                adc #8
.9ca3		95 02		sta $02,x	                sta 2,x
.9ca5		90 02		bcc $9ca9	                bcc z_name_to_string
.9ca7		f6 03		inc $03,x	                inc 3,x         ; MSB
.9ca9						z_name_to_string:
.9ca9		60		rts		                rts
.9caa						xt_nc_limit:
.9caa						w_nc_limit:
.9caa		a9 00		lda #$00	                lda #nc_limit_offset
.9cac		4c 3e d7	jmp $d73e	                jmp push_upvar_tos
.9caf						z_nc_limit:
.9caf						xt_never_native:
.9caf						w_never_native:
.9caf		20 d9 d7	jsr $d7d9	                jsr current_to_dp
.9cb2		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9cb4		b1 02		lda ($02),y	                lda (dp),y
.9cb6		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9cb8		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9cba		91 02		sta ($02),y	                sta (dp),y
.9cbc						z_never_native:
.9cbc		60		rts		                rts
.9cbd						xt_not_rot:
.9cbd		20 8c d8	jsr $d88c	                jsr underflow_3
.9cc0						w_not_rot:
.9cc0		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9cc2		b5 03		lda $03,x	                lda 3,x
.9cc4		95 01		sta $01,x	                sta 1,x
.9cc6		b5 05		lda $05,x	                lda 5,x
.9cc8		95 03		sta $03,x	                sta 3,x
.9cca		94 05		sty $05,x	                sty 5,x
.9ccc		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9cce		b5 02		lda $02,x	                lda 2,x
.9cd0		95 00		sta $00,x	                sta 0,x
.9cd2		b5 04		lda $04,x	                lda 4,x
.9cd4		95 02		sta $02,x	                sta 2,x
.9cd6		94 04		sty $04,x	                sty 4,x
.9cd8		60		rts		z_not_rot:      rts
.9cd9						xt_number:
.9cd9		20 87 d8	jsr $d887	                jsr underflow_2
.9cdc						w_number:
.9cdc		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9cde		a5 18		lda $18		                lda base
.9ce0		48		pha		                pha
.9ce1		20 dc 93	jsr $93dc	                jsr w_two_dup
.9ce4		a1 02		lda ($02,x)	                lda (2,x)
.9ce6		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9ce8		d0 04		bne $9cee	                bne _check_hex
.9cea		a9 0a		lda #$0a	                lda #10
.9cec		80 42		bra $9d30	                bra _base_changed
.9cee						_check_hex:
.9cee		c9 24		cmp #$24	                cmp #'$'
.9cf0		d0 04		bne $9cf6	                bne _check_binary
.9cf2		a9 10		lda #$10	                lda #16
.9cf4		80 3a		bra $9d30	                bra _base_changed
.9cf6						_check_binary:
.9cf6		c9 25		cmp #$25	                cmp #'%'
.9cf8		d0 04		bne $9cfe	                bne _check_char
.9cfa		a9 02		lda #$02	                lda #2
.9cfc		80 32		bra $9d30	                bra _base_changed
.9cfe						_check_char:
.9cfe		c9 27		cmp #$27	                cmp #"'"
.9d00		d0 3a		bne $9d3c	                bne _check_minus
.9d02		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9d04		c9 03		cmp #$03	                cmp #3
.9d06		d0 26		bne $9d2e	                bne _not_a_char
.9d08		b5 01		lda $01,x	                lda 1,x
.9d0a		d0 22		bne $9d2e	                bne _not_a_char ; No compare needed to check for non-zero.
.9d0c		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d0e		18		clc		                clc
.9d0f		69 02		adc #$02	                adc #2          ; length of string
.9d11		85 23		sta $23		                sta tmptos
.9d13		b5 03		lda $03,x	                lda 3,x
.9d15		69 00		adc #$00	                adc #0          ; only need carry
.9d17		85 24		sta $24		                sta tmptos+1
.9d19		b2 23		lda ($23)	                lda (tmptos)
.9d1b		c9 27		cmp #$27	                cmp #"'"
.9d1d		d0 0f		bne $9d2e	                bne _not_a_char
.9d1f		f6 02		inc $02,x	                inc 2,x
.9d21		d0 02		bne $9d25	                bne +
.9d23		f6 03		inc $03,x	                inc 3,x
.9d25						+
.9d25		a1 02		lda ($02,x)	                lda (2,x)
.9d27		95 02		sta $02,x	                sta 2,x
.9d29		74 03		stz $03,x	                stz 3,x
.9d2b		4c ae 9d	jmp $9dae	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9d2e						_not_a_char:
.9d2e		80 5c		bra $9d8c	                bra _number_error
.9d30						_base_changed:
.9d30		85 18		sta $18		                sta base        ; Switch to the new base
.9d32		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d34		d0 02		bne $9d38	                bne +
.9d36		f6 03		inc $03,x	                inc 3,x
.9d38						+
.9d38		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d3a		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9d3c						_check_minus:
.9d3c		c9 2d		cmp #$2d	                cmp #'-'
.9d3e		d0 0c		bne $9d4c	                bne _check_dot
.9d40		a9 80		lda #$80	                lda #$80
.9d42		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9d44		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d46		d0 02		bne $9d4a	                bne +
.9d48		f6 03		inc $03,x	                inc 3,x
.9d4a						+
.9d4a		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d4c						_check_dot:
.9d4c		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d4e		18		clc		                clc
.9d4f		75 00		adc $00,x	                adc 0,x         ; length of string
.9d51		85 23		sta $23		                sta tmptos
.9d53		b5 03		lda $03,x	                lda 3,x
.9d55		69 00		adc #$00	                adc #0          ; only need carry
.9d57		85 24		sta $24		                sta tmptos+1
.9d59		a5 23		lda $23		                lda tmptos
.9d5b		d0 02		bne $9d5f	                bne +
.9d5d		c6 24		dec $24		                dec tmptos+1
.9d5f						+
.9d5f		c6 23		dec $23		                dec tmptos
.9d61		b2 23		lda ($23)	                lda (tmptos)
.9d63		c9 2e		cmp #$2e	                cmp #'.'
.9d65		d0 04		bne $9d6b	                bne _main
.9d67		e6 1e		inc $1e		                inc tmpdsp
.9d69		d6 00		dec $00,x	                dec 0,x
.9d6b						_main:
.9d6b		ca		dex		                dex
.9d6c		ca		dex		                dex
.9d6d		ca		dex		                dex
.9d6e		ca		dex		                dex
.9d6f		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d71		95 00		sta $00,x	                sta 0,x
.9d73		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9d75		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9d77		95 02		sta $02,x	                sta 2,x
.9d79		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9d7b		95 03		sta $03,x	                sta 3,x
.9d7d		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9d7f		74 05		stz $05,x	                stz 5,x
.9d81		74 06		stz $06,x	                stz 6,x
.9d83		74 07		stz $07,x	                stz 7,x
.9d85		20 fd 92	jsr $92fd	                jsr w_to_number        ; (ud addr u -- ud addr u )
.9d88		b5 00		lda $00,x	                lda 0,x
.9d8a		f0 1e		beq $9daa	                beq _all_converted
.9d8c						_number_error:
.9d8c		20 d4 93	jsr $93d4	                jsr w_two_drop ; >NUMBER modified addr u
.9d8f		20 d4 93	jsr $93d4	                jsr w_two_drop ; ud   (partially converted number)
.9d92		a9 3e		lda #$3e	                lda #'>'
.9d94		20 d3 86	jsr $86d3	                jsr emit_a
.9d97		20 e6 94	jsr $94e6	                jsr w_type
.9d9a		a9 3c		lda #$3c	                lda #'<'
.9d9c		20 d3 86	jsr $86d3	                jsr emit_a
.9d9f		20 f6 91	jsr $91f6	                jsr w_space
.9da2		68		pla		                pla
.9da3		85 18		sta $18		                sta base
.9da5		a9 08		lda #$08	                lda #err_syntax
.9da7		4c 98 d8	jmp $d898	                jmp error
.9daa						_all_converted:
.9daa		e8		inx		                inx ; Drop the current addr u
.9dab		e8		inx		                inx
.9dac		e8		inx		                inx
.9dad		e8		inx		                inx
.9dae						_drop_original_string:
.9dae		20 a2 94	jsr $94a2	                jsr w_two_swap  ; Drop the original addr u
.9db1		20 d4 93	jsr $93d4	                jsr w_two_drop  ; (was saved for unknown word error message)
.9db4		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9db6		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9db8		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9db9		f0 0a		beq $9dc5	                beq _single
.9dbb		98		tya		                tya
.9dbc		04 1c		tsb $1c		                tsb status
.9dbe		90 0f		bcc $9dcf	                bcc _done       ; no minus, all done
.9dc0		20 aa 9e	jsr $9eaa	                jsr w_dnegate
.9dc3		80 0a		bra $9dcf	                bra _done
.9dc5						_single:
.9dc5		e8		inx		                inx
.9dc6		e8		inx		                inx
.9dc7		98		tya		                tya
.9dc8		14 1c		trb $1c		                trb status
.9dca		90 03		bcc $9dcf	                bcc _done       ; no minus, all done
.9dcc		20 50 8c	jsr $8c50	                jsr w_negate
.9dcf						_done:
.9dcf		68		pla		                pla
.9dd0		85 18		sta $18		                sta base
.9dd2		60		rts		z_number:       rts
.9dd3						xt_editor_wordlist:
.9dd3						xt_one:
.9dd3						w_editor_wordlist:
.9dd3						w_one:
.9dd3		ca		dex		                dex
.9dd4		ca		dex		                dex
.9dd5		a9 01		lda #$01	                lda #1
.9dd7		95 00		sta $00,x	                sta 0,x
.9dd9		74 01		stz $01,x	                stz 1,x
.9ddb						z_editor_wordlist:
.9ddb						z_one:
.9ddb		60		rts		                rts
.9ddc						xt_output:
.9ddc						w_output:
.9ddc		ca		dex		                dex
.9ddd		ca		dex		                dex
.9dde		a9 12		lda #$12	                lda #<output
.9de0		95 00		sta $00,x	                sta 0,x
.9de2		a9 00		lda #$00	                lda #>output
.9de4		95 01		sta $01,x	                sta 1,x
.9de6		60		rts		z_output:       rts
.9de7						xt_r_to_input:
.9de7						w_r_to_input:
.9de7		68		pla		                pla
.9de8		85 25		sta $25		                sta tmp1
.9dea		68		pla		                pla
.9deb		85 26		sta $26		                sta tmp1+1
.9ded		a0 00		ldy #$00	                ldy #0
.9def						_loop:
.9def		68		pla		                pla
.9df0		99 0a 00	sta $000a,y	                sta insrc,y
.9df3		c8		iny		                iny
.9df4		c0 08		cpy #$08	                cpy #8
.9df6		d0 f7		bne $9def	                bne _loop
.9df8		a5 26		lda $26		                lda tmp1+1
.9dfa		48		pha		                pha
.9dfb		a5 25		lda $25		                lda tmp1
.9dfd		48		pha		                pha
.9dfe		60		rts		z_r_to_input: 	rts
.9dff						xt_strip_underflow:
.9dff						w_strip_underflow:
.9dff		a9 02		lda #$02	                lda #uf_strip_offset
.9e01		4c 3e d7	jmp $d73e	                jmp push_upvar_tos
.9e04						z_strip_underflow:
.9e04						xt_assembler_wordlist:
.9e04						xt_two:
.9e04						w_assembler_wordlist:
.9e04						w_two:
.9e04		ca		dex		                dex
.9e05		ca		dex		                dex
.9e06		a9 02		lda #$02	                lda #2
.9e08		95 00		sta $00,x	                sta 0,x
.9e0a		74 01		stz $01,x	                stz 1,x
.9e0c						z_assembler_wordlist:
.9e0c		60		rts		z_two:          rts
.9e0d						xt_useraddr:
.9e0d						w_useraddr:
.9e0d		ca		dex		                dex
.9e0e		ca		dex		                dex
.9e0f		a9 08		lda #$08	                lda #<up
.9e11		95 00		sta $00,x	                sta 0,x
.9e13		a9 00		lda #$00	                lda #>up
.9e15		95 01		sta $01,x	                sta 1,x
.9e17		60		rts		z_useraddr:     rts
.9e18						xt_wordsize:
.9e18		20 82 d8	jsr $d882	                jsr underflow_1
.9e1b						w_wordsize:
.9e1b		b5 00		lda $00,x	                lda 0,x
.9e1d		85 25		sta $25		                sta tmp1
.9e1f		b5 01		lda $01,x	                lda 1,x
.9e21		85 26		sta $26		                sta tmp1+1
.9e23		a0 06		ldy #$06	                ldy #6
.9e25		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9e27		88		dey		                dey
.9e28		88		dey		                dey
.9e29		38		sec		                sec
.9e2a		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9e2c		95 00		sta $00,x	                sta 0,x
.9e2e		a0 07		ldy #$07	                ldy #7
.9e30		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9e32		88		dey		                dey
.9e33		88		dey		                dey
.9e34		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9e36		95 01		sta $01,x	                sta 1,x
.9e38		60		rts		z_wordsize:     rts
.9e39						xt_case:
.9e39						xt_false:
.9e39						xt_forth_wordlist:
.9e39						xt_zero:
.9e39						w_case:
.9e39						w_false:
.9e39						w_forth_wordlist:
.9e39						w_zero:
.9e39		ca		dex		                dex             ; push
.9e3a		ca		dex		                dex
.9e3b		74 00		stz $00,x	                stz 0,x
.9e3d		74 01		stz $01,x	                stz 1,x
.9e3f						z_case:
.9e3f						z_false:
.9e3f						z_forth_wordlist:
.9e3f						z_zero:
.9e3f		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9e40						xt_d_minus:
.9e40		20 91 d8	jsr $d891	                jsr underflow_4 ; two double numbers
.9e43						w_d_minus:
.9e43		38		sec		                sec
.9e44		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9e46		f5 02		sbc $02,x	                sbc 2,x
.9e48		95 06		sta $06,x	                sta 6,x
.9e4a		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9e4c		f5 03		sbc $03,x	                sbc 3,x
.9e4e		95 07		sta $07,x	                sta 7,x
.9e50		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9e52		f5 00		sbc $00,x	                sbc 0,x
.9e54		95 04		sta $04,x	                sta 4,x
.9e56		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9e58		f5 01		sbc $01,x	                sbc 1,x
.9e5a		95 05		sta $05,x	                sta 5,x
.9e5c		e8		inx		                inx
.9e5d		e8		inx		                inx
.9e5e		e8		inx		                inx
.9e5f		e8		inx		                inx
.9e60		60		rts		z_d_minus:      rts
.9e61						xt_d_plus:
.9e61		20 91 d8	jsr $d891	                jsr underflow_4 ; two double numbers
.9e64						w_d_plus:
.9e64		18		clc		                clc
.9e65		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9e67		75 06		adc $06,x	                adc 6,x
.9e69		95 06		sta $06,x	                sta 6,x
.9e6b		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e6d		75 07		adc $07,x	                adc 7,x
.9e6f		95 07		sta $07,x	                sta 7,x
.9e71		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9e73		75 04		adc $04,x	                adc 4,x
.9e75		95 04		sta $04,x	                sta 4,x
.9e77		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9e79		75 05		adc $05,x	                adc 5,x
.9e7b		95 05		sta $05,x	                sta 5,x
.9e7d		e8		inx		                inx
.9e7e		e8		inx		                inx
.9e7f		e8		inx		                inx
.9e80		e8		inx		                inx
.9e81		60		rts		z_d_plus:       rts
.9e82						xt_d_to_s:
.9e82		20 87 d8	jsr $d887	                jsr underflow_2
.9e85						w_d_to_s:
.9e85		e8		inx		                inx
.9e86		e8		inx		                inx
.9e87		60		rts		z_d_to_s:       rts
.9e88						xt_dabs:
.9e88		20 87 d8	jsr $d887	                jsr underflow_2 ; double number
.9e8b						w_dabs:
.9e8b		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9e8d		10 17		bpl $9ea6	                bpl _done       ; positive, we get off light
.9e8f		a0 00		ldy #$00	                ldy #0
.9e91		38		sec		                sec
.9e92		98		tya		                tya
.9e93		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e95		95 02		sta $02,x	                sta 2,x
.9e97		98		tya		                tya
.9e98		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e9a		95 03		sta $03,x	                sta 3,x
.9e9c		98		tya		                tya
.9e9d		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e9f		95 00		sta $00,x	                sta 0,x
.9ea1		98		tya		                tya
.9ea2		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9ea4		95 01		sta $01,x	                sta 1,x
.9ea6						_done:
.9ea6		60		rts		z_dabs:         rts
.9ea7						xt_dnegate:
.9ea7		20 87 d8	jsr $d887	                jsr underflow_2 ; double number
.9eaa						w_dnegate:
.9eaa		a0 00		ldy #$00	     		ldy #0
.9eac		38		sec		                sec
.9ead		98		tya		                tya
.9eae		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9eb0		95 02		sta $02,x	                sta 2,x
.9eb2		98		tya		                tya
.9eb3		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9eb5		95 03		sta $03,x	                sta 3,x
.9eb7		98		tya		                tya
.9eb8		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9eba		95 00		sta $00,x	                sta 0,x
.9ebc		98		tya		                tya
.9ebd		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9ebf		95 01		sta $01,x	                sta 1,x
.9ec1		60		rts		z_dnegate:      rts
.9ec2						xt_d_dot:
.9ec2		20 87 d8	jsr $d887	                jsr underflow_2
.9ec5						w_d_dot:
.9ec5		20 ba 93	jsr $93ba	                jsr w_tuck
.9ec8		20 8b 9e	jsr $9e8b	                jsr w_dabs
.9ecb		20 fa 89	jsr $89fa	                jsr w_less_number_sign
.9ece		20 e0 8c	jsr $8ce0	                jsr w_number_sign_s
.9ed1		20 bb 8f	jsr $8fbb	                jsr w_rot
.9ed4		20 79 91	jsr $9179	                jsr w_sign
.9ed7		20 be 8c	jsr $8cbe	                jsr w_number_sign_greater
.9eda		20 e6 94	jsr $94e6	                jsr w_type
.9edd		20 f6 91	jsr $91f6	                jsr w_space
.9ee0		60		rts		z_d_dot:        rts
.9ee1						xt_d_dot_r:
.9ee1		20 8c d8	jsr $d88c	                jsr underflow_3
.9ee4						w_d_dot_r:
.9ee4		20 9a 93	jsr $939a	                jsr w_to_r
.9ee7		20 ba 93	jsr $93ba	                jsr w_tuck
.9eea		20 8b 9e	jsr $9e8b	                jsr w_dabs
.9eed		20 fa 89	jsr $89fa	                jsr w_less_number_sign
.9ef0		20 e0 8c	jsr $8ce0	                jsr w_number_sign_s
.9ef3		20 bb 8f	jsr $8fbb	                jsr w_rot
.9ef6		20 79 91	jsr $9179	                jsr w_sign
.9ef9		20 be 8c	jsr $8cbe	                jsr w_number_sign_greater
.9efc		20 18 8f	jsr $8f18	                jsr w_r_from
.9eff		20 32 8d	jsr $8d32	                jsr w_over
.9f02		20 12 8c	jsr $8c12	                jsr w_minus
.9f05		20 ff 91	jsr $91ff	                jsr w_spaces
.9f08		20 e6 94	jsr $94e6	                jsr w_type
.9f0b		60		rts		z_d_dot_r:      rts
.9f0c						xt_m_star_slash:
.9f0c		20 91 d8	jsr $d891	                jsr underflow_4
.9f0f						w_m_star_slash:
.9f0f		20 dc 93	jsr $93dc	                jsr w_two_dup
.9f12		20 97 96	jsr $9697	                jsr w_xor
.9f15		20 5f 92	jsr $925f	                jsr w_swap
.9f18		20 d2 80	jsr $80d2	                jsr w_abs
.9f1b		20 9a 93	jsr $939a	                jsr w_to_r
.9f1e		20 5f 92	jsr $925f	                jsr w_swap
.9f21		20 d2 80	jsr $80d2	                jsr w_abs
.9f24		20 9a 93	jsr $939a	                jsr w_to_r
.9f27		20 32 8d	jsr $8d32	                jsr w_over
.9f2a		20 97 96	jsr $9697	                jsr w_xor
.9f2d		20 c0 9c	jsr $9cc0	                jsr w_not_rot          ; rot rot
.9f30		20 8b 9e	jsr $9e8b	                jsr w_dabs
.9f33		20 5f 92	jsr $925f	                jsr w_swap
.9f36		20 03 8f	jsr $8f03	                jsr w_r_fetch
.9f39		20 ad 95	jsr $95ad	                jsr w_um_star
.9f3c		20 bb 8f	jsr $8fbb	                jsr w_rot
.9f3f		20 18 8f	jsr $8f18	                jsr w_r_from
.9f42		20 ad 95	jsr $95ad	                jsr w_um_star
.9f45		20 bb 8f	jsr $8fbb	                jsr w_rot
.9f48		20 39 9e	jsr $9e39	                jsr w_zero
.9f4b		20 64 9e	jsr $9e64	                jsr w_d_plus
.9f4e		20 03 8f	jsr $8f03	                jsr w_r_fetch
.9f51		20 6b 95	jsr $956b	                jsr w_um_slash_mod
.9f54		20 c0 9c	jsr $9cc0	                jsr w_not_rot          ; rot rot
.9f57		20 18 8f	jsr $8f18	                jsr w_r_from
.9f5a		20 6b 95	jsr $956b	                jsr w_um_slash_mod
.9f5d		20 5f 92	jsr $925f	                jsr w_swap
.9f60		20 a3 86	jsr $86a3	                jsr w_drop
.9f63		20 5f 92	jsr $925f	                jsr w_swap
.9f66		20 bb 8f	jsr $8fbb	                jsr w_rot
.9f69		e8		inx		                inx                     ; drop TOS
.9f6a		e8		inx		                inx
.9f6b		b5 fe		lda $fe,x	                lda $fe,x               ; but keep MSB
.9f6d		10 03		bpl $9f72	                bpl z_m_star_slash      ; ... 0< if ...
.9f6f		20 aa 9e	jsr $9eaa	                jsr w_dnegate
.9f72		60		rts		z_m_star_slash: rts
.9f73						xt_two_constant:
.9f73		20 87 d8	jsr $d887	                jsr underflow_2
.9f76						w_two_constant:
.9f76		20 40 84	jsr $8440	                jsr w_create
.9f79		20 5f 92	jsr $925f	                jsr w_swap
.9f7c		20 d0 83	jsr $83d0	                jsr w_comma
.9f7f		20 d0 83	jsr $83d0	                jsr w_comma
.9f82		20 04 86	jsr $8604	                jsr does_runtime    ; does> turns into these two routines.
.9f85		20 17 d7	jsr $d717	                jsr dodoes
.9f88		20 a9 86	jsr $86a9	                jsr w_dup
.9f8b		20 36 88	jsr $8836	                jsr w_fetch
.9f8e		20 5f 92	jsr $925f	                jsr w_swap
.9f91		20 46 83	jsr $8346	                jsr w_cell_plus
.9f94		20 36 88	jsr $8836	                jsr w_fetch
.9f97		60		rts		z_two_constant: rts
.9f98						xt_two_literal:
.9f98		20 87 d8	jsr $d887	                jsr underflow_2 ; double number
.9f9b						w_two_literal:
.9f9b		a9 0a		lda #$0a	                lda #template_push_tos_size
.9f9d		0a		asl a		                asl
.9f9e		20 e2 97	jsr $97e2	                jsr check_nc_limit
.9fa1		b0 09		bcs $9fac	                bcs _no_inline
.9fa3		20 5f 92	jsr $925f	                jsr w_swap
.9fa6		20 20 8a	jsr $8a20	                jsr w_literal
.9fa9		4c 20 8a	jmp $8a20	                jmp w_literal
.9fac						_no_inline:
.9fac		20 0b a2	jsr $a20b	                jsr cmpl_two_literal
.9faf		60		rts		z_two_literal:  rts
.9fb0						xt_two_variable:
.9fb0						w_two_variable:
.9fb0		20 40 84	jsr $8440	                jsr w_create
.9fb3		ca		dex		                dex
.9fb4		ca		dex		                dex
.9fb5		a9 04		lda #$04	                lda #4
.9fb7		95 00		sta $00,x	                sta 0,x
.9fb9		74 01		stz $01,x	                stz 1,x
.9fbb		20 2a 82	jsr $822a	                jsr w_allot
.9fbe		60		rts		z_two_variable: rts
.9fbf						xt_ud_dot:
.9fbf		20 87 d8	jsr $d887	                jsr underflow_2 ; double number
.9fc2						w_ud_dot:
.9fc2		20 fa 89	jsr $89fa	                jsr w_less_number_sign
.9fc5		20 e0 8c	jsr $8ce0	                jsr w_number_sign_s
.9fc8		20 be 8c	jsr $8cbe	                jsr w_number_sign_greater
.9fcb		20 e6 94	jsr $94e6	                jsr w_type
.9fce		20 f6 91	jsr $91f6	                jsr w_space
.9fd1		60		rts		z_ud_dot:        rts
.9fd2						xt_ud_dot_r:
.9fd2		20 8c d8	jsr $d88c	                jsr underflow_3
.9fd5						w_ud_dot_r:
.9fd5		20 9a 93	jsr $939a	                jsr w_to_r
.9fd8		20 fa 89	jsr $89fa	                jsr w_less_number_sign
.9fdb		20 e0 8c	jsr $8ce0	                jsr w_number_sign_s
.9fde		20 be 8c	jsr $8cbe	                jsr w_number_sign_greater
.9fe1		20 18 8f	jsr $8f18	                jsr w_r_from
.9fe4		20 32 8d	jsr $8d32	                jsr w_over
.9fe7		20 12 8c	jsr $8c12	                jsr w_minus
.9fea		20 ff 91	jsr $91ff	                jsr w_spaces
.9fed		20 e6 94	jsr $94e6	                jsr w_type
.9ff0		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9ff1						xt_cmove:
.9ff1		20 8c d8	jsr $d88c	                jsr underflow_3
.9ff4						w_cmove:
.9ff4		b5 02		lda $02,x	                lda 2,x
.9ff6		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9ff8		b5 03		lda $03,x	                lda 3,x
.9ffa		85 28		sta $28		                sta tmp2+1
.9ffc		b5 04		lda $04,x	                lda 4,x
.9ffe		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.a000		b5 05		lda $05,x	                lda 5,x
.a002		85 26		sta $26		                sta tmp1+1
.a004		a0 00		ldy #$00	                ldy #0
.a006		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.a008		f0 0f		beq $a019	                beq _dopartial
.a00a						_page:
.a00a		b1 25		lda ($25),y	                lda (tmp1),y
.a00c		91 27		sta ($27),y	                sta (tmp2),y
.a00e		c8		iny		                iny
.a00f		d0 f9		bne $a00a	                bne _page
.a011		e6 26		inc $26		                inc tmp1+1
.a013		e6 28		inc $28		                inc tmp2+1
.a015		d6 01		dec $01,x	                dec 1,x
.a017		d0 f1		bne $a00a	                bne _page
.a019						_dopartial:
.a019		b5 00		lda $00,x	                lda 0,x         ; length of last page
.a01b		f0 09		beq $a026	                beq _done
.a01d						_partial:
.a01d		b1 25		lda ($25),y	                lda (tmp1),y
.a01f		91 27		sta ($27),y	                sta (tmp2),y
.a021		c8		iny		                iny
.a022		d6 00		dec $00,x	                dec 0,x
.a024		d0 f7		bne $a01d	                bne _partial
.a026						_done:
.a026		8a		txa		                txa
.a027		18		clc		                clc
.a028		69 06		adc #$06	                adc #6
.a02a		aa		tax		                tax
.a02b		60		rts		z_cmove:        rts
.a02c						xt_cmove_up:
.a02c		20 8c d8	jsr $d88c	                jsr underflow_3
.a02f						w_cmove_up:
.a02f		b5 02		lda $02,x	                lda 2,x
.a031		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.a033		b5 03		lda $03,x	                lda 3,x
.a035		18		clc		                clc
.a036		75 01		adc $01,x	                adc 1,x
.a038		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.a03a		b5 04		lda $04,x	                lda 4,x
.a03c		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.a03e		b5 05		lda $05,x	                lda 5,x
.a040		18		clc		                clc
.a041		75 01		adc $01,x	                adc 1,x
.a043		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.a045		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.a047		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.a049		f0 0e		beq $a059	                beq _nopartial
.a04b						_outerloop:
.a04b		88		dey		                dey
.a04c		f0 07		beq $a055	                beq _finishpage
.a04e						_innerloop:
.a04e		b1 25		lda ($25),y	                lda (tmp1),y
.a050		91 27		sta ($27),y	                sta (tmp2),y
.a052		88		dey		                dey
.a053		d0 f9		bne $a04e	                bne _innerloop
.a055						_finishpage:
.a055		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.a057		92 27		sta ($27)	                sta (tmp2)
.a059						_nopartial:
.a059		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.a05b		c6 28		dec $28		                dec tmp2+1
.a05d		d6 01		dec $01,x	                dec 1,x
.a05f		d0 ea		bne $a04b	                bne _outerloop
.a061		8a		txa		                txa
.a062		18		clc		                clc
.a063		69 06		adc #$06	                adc #6
.a065		aa		tax		                tax
.a066		60		rts		z_cmove_up:     rts
.a067						xt_compare:
.a067		20 91 d8	jsr $d891	                jsr underflow_4
.a06a						w_compare:
.a06a		b5 02		lda $02,x	                lda 2,x
.a06c		85 27		sta $27		                sta tmp2
.a06e		b5 03		lda $03,x	                lda 3,x
.a070		85 28		sta $28		                sta tmp2+1
.a072		b5 06		lda $06,x	                lda 6,x
.a074		85 25		sta $25		                sta tmp1
.a076		b5 07		lda $07,x	                lda 7,x
.a078		85 26		sta $26		                sta tmp1+1
.a07a						_compare_loop:
.a07a		b5 04		lda $04,x	                lda 4,x
.a07c		15 05		ora $05,x	                ora 5,x
.a07e		f0 2c		beq $a0ac	                beq _str1_done
.a080		b5 00		lda $00,x	                lda 0,x
.a082		15 01		ora $01,x	                ora 1,x
.a084		f0 3a		beq $a0c0	                beq _greater    ; Str2 empty first
.a086		b2 25		lda ($25)	                lda (tmp1)
.a088		d2 27		cmp ($27)	                cmp (tmp2)
.a08a		90 26		bcc $a0b2	                bcc _less
.a08c		d0 32		bne $a0c0	                bne _greater
.a08e		e6 25		inc $25		                inc tmp1
.a090		d0 02		bne $a094	                bne +
.a092		e6 26		inc $26		                inc tmp1+1
.a094						+
.a094		e6 27		inc $27		                inc tmp2
.a096		d0 02		bne $a09a	                bne +
.a098		e6 28		inc $28		                inc tmp2+1
.a09a						+
.a09a		b5 04		lda $04,x	                lda 4,x
.a09c		d0 02		bne $a0a0	                bne +
.a09e		d6 05		dec $05,x	                dec 5,x
.a0a0						+
.a0a0		d6 04		dec $04,x	                dec 4,x
.a0a2		b5 00		lda $00,x	                lda 0,x
.a0a4		d0 02		bne $a0a8	                bne +
.a0a6		d6 01		dec $01,x	                dec 1,x
.a0a8						+
.a0a8		d6 00		dec $00,x	                dec 0,x
.a0aa		80 ce		bra $a07a	                bra _compare_loop
.a0ac						_str1_done:
.a0ac		b5 00		lda $00,x	                lda 0,x
.a0ae		15 01		ora $01,x	                ora 1,x
.a0b0		f0 08		beq $a0ba	                beq _equal      ; Both out of letters
.a0b2						_less:
.a0b2		a9 ff		lda #$ff	                lda #$FF
.a0b4		95 06		sta $06,x	                sta 6,x
.a0b6		95 07		sta $07,x	                sta 7,x
.a0b8		80 0c		bra $a0c6	                bra _done
.a0ba						_equal:
.a0ba		74 06		stz $06,x	                stz 6,x
.a0bc		74 07		stz $07,x	                stz 7,x
.a0be		80 06		bra $a0c6	                bra _done
.a0c0						_greater:
.a0c0		a9 01		lda #$01	                lda #1
.a0c2		95 06		sta $06,x	                sta 6,x
.a0c4		74 07		stz $07,x	                stz 7,x
.a0c6						_done:
.a0c6		8a		txa		                txa
.a0c7		18		clc		                clc
.a0c8		69 06		adc #$06	                adc #6
.a0ca		aa		tax		                tax
.a0cb		60		rts		z_compare:      rts
.a0cc						xt_minus_leading:
.a0cc		20 87 d8	jsr $d887	                jsr underflow_2
.a0cf						w_minus_leading:
.a0cf						_loop:
.a0cf		b5 00		lda $00,x	                lda 0,x
.a0d1		15 01		ora $01,x	                ora 1,x
.a0d3		f0 0f		beq $a0e4	                beq _done
.a0d5		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a0d7		20 75 d8	jsr $d875	                jsr is_whitespace
.a0da		90 08		bcc $a0e4	                bcc _done
.a0dc		20 d3 9d	jsr $9dd3	                jsr w_one              ; ( addr u 1 )
.a0df		20 c4 a1	jsr $a1c4	                jsr w_slash_string     ; ( addr+ u-1 )
.a0e2		80 eb		bra $a0cf	                bra _loop
.a0e4						_done:
.a0e4						z_minus_leading:
.a0e4		60		rts		                rts
.a0e5						xt_minus_trailing:
.a0e5		20 87 d8	jsr $d887	                jsr underflow_2
.a0e8						w_minus_trailing:
.a0e8		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a0ea		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a0ec		f0 33		beq $a121	                beq _done
.a0ee		18		clc		                clc
.a0ef		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a0f1		75 00		adc $00,x	                adc 0,x
.a0f3		85 25		sta $25		                sta tmp1
.a0f5		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a0f7		75 01		adc $01,x	                adc 1,x
.a0f9		85 26		sta $26		                sta tmp1+1
.a0fb		a5 25		lda $25		                lda tmp1
.a0fd		d0 02		bne $a101	                bne +
.a0ff		c6 26		dec $26		                dec tmp1+1
.a101						+
.a101		c6 25		dec $25		                dec tmp1
.a103						_loop:
.a103		b2 25		lda ($25)	                lda (tmp1)
.a105		c9 20		cmp #$20	                cmp #AscSP
.a107		d0 18		bne $a121	                bne _done
.a109		a5 25		lda $25		                lda tmp1
.a10b		d0 02		bne $a10f	                bne +
.a10d		c6 26		dec $26		                dec tmp1+1
.a10f						+
.a10f		c6 25		dec $25		                dec tmp1
.a111		b5 00		lda $00,x	                lda 0,x
.a113		d0 02		bne $a117	                bne +
.a115		d6 01		dec $01,x	                dec 1,x
.a117						+
.a117		d6 00		dec $00,x	                dec 0,x
.a119		b5 00		lda $00,x	                lda 0,x
.a11b		15 01		ora $01,x	                ora 1,x
.a11d		f0 02		beq $a121	                beq _done       ; Count has reached zero - we're done!
.a11f		80 e2		bra $a103	                bra _loop
.a121						_done:
.a121						z_minus_trailing:
.a121		60		rts		                rts
.a122						xt_search:
.a122		20 91 d8	jsr $d891	                jsr underflow_4
.a125						w_search:
.a125		b5 00		lda $00,x	                lda 0,x
.a127		15 01		ora $01,x	                ora 1,x
.a129		d0 0b		bne $a136	                bne _start_search
.a12b		e8		inx		                inx             ; Remove u2
.a12c		e8		inx		                inx
.a12d		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a12f		95 00		sta $00,x	                sta 0,x
.a131		95 01		sta $01,x	                sta 1,x
.a133		4c c0 a1	jmp $a1c0	                jmp z_search
.a136						_start_search:
.a136		20 39 9e	jsr $9e39	                jsr w_zero
.a139						_search_loop:
.a139		18		clc		                clc
.a13a		b5 00		lda $00,x	                lda 0,x
.a13c		75 02		adc $02,x	                adc 2,x
.a13e		85 25		sta $25		                sta tmp1
.a140		b5 01		lda $01,x	                lda 1,x
.a142		75 03		adc $03,x	                adc 3,x
.a144		d5 07		cmp $07,x	                cmp 7,x
.a146		90 12		bcc $a15a	                bcc _init_comparison ; Obviously less
.a148		d0 06		bne $a150	                bne _not_found
.a14a		b5 06		lda $06,x	                lda 6,x
.a14c		c5 25		cmp $25		                cmp tmp1
.a14e		b0 0a		bcs $a15a	                bcs _init_comparison
.a150						_not_found:
.a150		e8		inx		                inx             ; Remove offset
.a151		e8		inx		                inx
.a152		e8		inx		                inx             ; Remove u2
.a153		e8		inx		                inx
.a154		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a156		74 01		stz $01,x	                stz 1,x
.a158		80 66		bra $a1c0	                bra z_search
.a15a						_init_comparison:
.a15a		18		clc		                clc
.a15b		b5 08		lda $08,x	                lda 8,x
.a15d		75 00		adc $00,x	                adc 0,x
.a15f		85 25		sta $25		                sta tmp1
.a161		b5 09		lda $09,x	                lda 9,x
.a163		75 01		adc $01,x	                adc 1,x
.a165		85 26		sta $26		                sta tmp1+1
.a167		b5 04		lda $04,x	                lda 4,x
.a169		85 27		sta $27		                sta tmp2
.a16b		b5 05		lda $05,x	                lda 5,x
.a16d		85 28		sta $28		                sta tmp2+1
.a16f		b5 02		lda $02,x	                lda 2,x
.a171		85 29		sta $29		                sta tmp3
.a173		b5 03		lda $03,x	                lda 3,x
.a175		85 2a		sta $2a		                sta tmp3+1
.a177						_comparison_loop:
.a177		b2 25		lda ($25)	                lda (tmp1)
.a179		d2 27		cmp ($27)	                cmp (tmp2)
.a17b		f0 05		beq $a182	                beq _letters_match
.a17d		20 16 8d	jsr $8d16	                jsr w_one_plus
.a180		80 b7		bra $a139	                bra _search_loop
.a182						_letters_match:
.a182		e6 25		inc $25		                inc tmp1
.a184		d0 02		bne $a188	                bne +
.a186		e6 26		inc $26		                inc tmp1+1
.a188						+
.a188		e6 27		inc $27		                inc tmp2
.a18a		d0 02		bne $a18e	                bne +
.a18c		e6 28		inc $28		                inc tmp2+1
.a18e						+
.a18e		a5 29		lda $29		                lda tmp3
.a190		d0 02		bne $a194	                bne +
.a192		c6 2a		dec $2a		                dec tmp3+1
.a194						+
.a194		c6 29		dec $29		                dec tmp3
.a196		a5 29		lda $29		                lda tmp3
.a198		05 2a		ora $2a		                ora tmp3+1
.a19a		d0 db		bne $a177	                bne _comparison_loop ; Check the next letter
.a19c		18		clc		                clc
.a19d		b5 00		lda $00,x	                lda 0,x
.a19f		75 08		adc $08,x	                adc 8,x
.a1a1		95 08		sta $08,x	                sta 8,x
.a1a3		b5 01		lda $01,x	                lda 1,x
.a1a5		75 09		adc $09,x	                adc 9,x
.a1a7		95 09		sta $09,x	                sta 9,x
.a1a9		38		sec		                sec
.a1aa		b5 06		lda $06,x	                lda 6,x
.a1ac		f5 00		sbc $00,x	                sbc 0,x
.a1ae		95 06		sta $06,x	                sta 6,x
.a1b0		b5 07		lda $07,x	                lda 7,x
.a1b2		f5 01		sbc $01,x	                sbc 1,x
.a1b4		95 07		sta $07,x	                sta 7,x
.a1b6		e8		inx		                inx             ; drop offset
.a1b7		e8		inx		                inx
.a1b8		e8		inx		                inx             ; drop u2
.a1b9		e8		inx		                inx
.a1ba		a9 ff		lda #$ff	                lda #$FF
.a1bc		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a1be		95 01		sta $01,x	                sta 1,x
.a1c0		60		rts		z_search:       rts
.a1c1						xt_slash_string:
.a1c1		20 8c d8	jsr $d88c	                jsr underflow_3
.a1c4						w_slash_string:
.a1c4		18		clc		                clc             ; 3OS+TOS
.a1c5		b5 00		lda $00,x	                lda 0,x
.a1c7		75 04		adc $04,x	                adc 4,x
.a1c9		95 04		sta $04,x	                sta 4,x
.a1cb		b5 01		lda $01,x	                lda 1,x
.a1cd		75 05		adc $05,x	                adc 5,x
.a1cf		95 05		sta $05,x	                sta 5,x
.a1d1		38		sec		                sec             ; NOS-TOS
.a1d2		b5 02		lda $02,x	                lda 2,x
.a1d4		f5 00		sbc $00,x	                sbc 0,x
.a1d6		95 02		sta $02,x	                sta 2,x
.a1d8		b5 03		lda $03,x	                lda 3,x
.a1da		f5 01		sbc $01,x	                sbc 1,x
.a1dc		95 03		sta $03,x	                sta 3,x
.a1de		e8		inx		                inx
.a1df		e8		inx		                inx
.a1e0		60		rts		z_slash_string: rts
.a1e1						xt_sliteral:
.a1e1		20 87 d8	jsr $d887	                jsr underflow_2
.a1e4						w_sliteral:
.a1e4		20 d8 97	jsr $97d8	                jsr cmpl_jump_later
.a1e7		20 9a 93	jsr $939a	                jsr w_to_r
.a1ea		20 34 89	jsr $8934	                jsr w_here
.a1ed		20 5f 92	jsr $925f	                jsr w_swap
.a1f0		20 a9 86	jsr $86a9	                jsr w_dup
.a1f3		20 2a 82	jsr $822a	                jsr w_allot            ; reserve u bytes for string
.a1f6		20 34 89	jsr $8934	                jsr w_here
.a1f9		20 18 8f	jsr $8f18	                jsr w_r_from
.a1fc		20 49 92	jsr $9249	                jsr w_store            ; point jmp past string
.a1ff		20 dc 93	jsr $93dc	                jsr w_two_dup
.a202		20 c3 94	jsr $94c3	                jsr w_two_to_r
.a205		20 2e 8c	jsr $8c2e	                jsr w_move             ; copy u bytes from addr -> addr'
.a208		20 49 94	jsr $9449	                jsr w_two_r_from
.a20b						cmpl_sliteral:
.a20b						cmpl_two_literal:
.a20b		a0 a2		ldy #$a2	                ldy #>sliteral_runtime
.a20d		a9 25		lda #$25	                lda #<sliteral_runtime
.a20f		20 b7 97	jsr $97b7	                jsr cmpl_subroutine
.a212		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a214		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a216		20 c3 97	jsr $97c3	                jsr cmpl_word
.a219		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a21b		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a21d		20 c3 97	jsr $97c3	                jsr cmpl_word
.a220		e8		inx		                inx
.a221		e8		inx		                inx
.a222		e8		inx		                inx
.a223		e8		inx		                inx
.a224		60		rts		z_sliteral:     rts
.a225						sliteral_runtime:
.a225		ca		dex		                dex
.a226		ca		dex		                dex
.a227		ca		dex		                dex
.a228		ca		dex		                dex
.a229		68		pla		                pla
.a22a		85 25		sta $25		                sta tmp1        ; LSB of address
.a22c		7a		ply		                ply
.a22d		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a22f		18		clc		                clc
.a230		69 04		adc #$04	                adc #4
.a232		90 01		bcc $a235	                bcc +
.a234		c8		iny		                iny
.a235						+
.a235		5a		phy		                phy
.a236		48		pha		                pha
.a237		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a239		b1 25		lda ($25),y	                lda (tmp1),y
.a23b		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a23d		c8		iny		                iny
.a23e		b1 25		lda ($25),y	                lda (tmp1),y
.a240		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a242		c8		iny		                iny
.a243		b1 25		lda ($25),y	                lda (tmp1),y
.a245		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a247		c8		iny		                iny
.a248		b1 25		lda ($25),y	                lda (tmp1),y
.a24a		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a24c		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a24d						xt_disasm:
.a24d		20 87 d8	jsr $d887	                jsr underflow_2
.a250						w_disasm:
.a250		20 54 a2	jsr $a254	                jsr disassembler
.a253		60		rts		z_disasm:       rts
.a254						disassembler:
.a254		64 32		stz $32		                stz scratch+5   ; flag indicating whether we're arriving at sliteral (vs 2literal)
.a256		20 3a 84	jsr $843a	                jsr w_cr       ; ( addr u )
.a259						_byte_loop:
.a259		20 32 8d	jsr $8d32	                jsr w_over     ; ( addr u addr )
.a25c		20 11 95	jsr $9511	                jsr w_u_dot    ; ( addr u )
.a25f		20 f6 91	jsr $91f6	                jsr w_space
.a262		a9 7f		lda #$7f	                lda #<oc_index_table
.a264		85 27		sta $27		                sta tmp2
.a266		a9 b4		lda #$b4	                lda #>oc_index_table
.a268		85 28		sta $28		                sta tmp2+1
.a26a		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a26c		85 2d		sta $2d		                sta scratch     ; Save opcode
.a26e		0a		asl a		                asl             ; multiply by two for offset
.a26f		90 02		bcc $a273	                bcc +
.a271		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a273						+
.a273		a8		tay		                tay             ; use Y as the index
.a274		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a276		85 29		sta $29		                sta tmp3
.a278		48		pha		                pha
.a279		c8		iny		                iny
.a27a		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a27c		85 2a		sta $2a		                sta tmp3+1
.a27e		48		pha		                pha
.a27f		b2 29		lda ($29)	                lda (tmp3)
.a281		a8		tay		                tay                     ; save copy of lengths byte
.a282		10 3c		bpl $a2c0	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a284		20 39 9e	jsr $9e39	                jsr w_zero             ; ( addr u 0 ) ZERO does not use Y
.a287		f6 04		inc $04,x	                inc 4,x
.a289		d0 02		bne $a28d	                bne +
.a28b		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a28d						+
.a28d		b5 02		lda $02,x	                lda 2,x
.a28f		d0 02		bne $a293	                bne +
.a291		d6 03		dec $03,x	                dec 3,x
.a293						+
.a293		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a295		a1 04		lda ($04,x)	                lda (4,x)
.a297		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a299		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a29b		98		tya		                tya                     ; retrieve copy of lengths byte
.a29c		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a29d		10 14		bpl $a2b3	                bpl _print_operand
.a29f		f6 04		inc $04,x	                inc 4,x
.a2a1		d0 02		bne $a2a5	                bne +
.a2a3		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a2a5						+
.a2a5		b5 02		lda $02,x	                lda 2,x
.a2a7		d0 02		bne $a2ab	                bne +
.a2a9		d6 03		dec $03,x	                dec 3,x
.a2ab						+
.a2ab		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a2ad		a1 04		lda ($04,x)	                lda (4,x)
.a2af		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a2b1		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a2b3						_print_operand:
.a2b3		ca		dex		                dex
.a2b4		ca		dex		                dex
.a2b5		a9 05		lda #$05	                lda #5
.a2b7		95 00		sta $00,x	                sta 0,x
.a2b9		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a2bb		20 1d 95	jsr $951d	                jsr w_u_dot_r          ; U.R ( addr+n u-n )
.a2be		80 0b		bra $a2cb	                bra _print_mnemonic
.a2c0						_no_operand:
.a2c0		ca		dex		                dex
.a2c1		ca		dex		                dex
.a2c2		a9 05		lda #$05	                lda #5
.a2c4		95 00		sta $00,x	                sta 0,x
.a2c6		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a2c8		20 ff 91	jsr $91ff	                jsr w_spaces           ; ( addr u )
.a2cb						_print_mnemonic:
.a2cb		20 f6 91	jsr $91f6	                jsr w_space
.a2ce		ca		dex		                dex
.a2cf		ca		dex		                dex                     ; ( addr u ? )
.a2d0		68		pla		                pla                     ; MSB
.a2d1		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a2d3		68		pla		                pla                     ; LSB
.a2d4		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a2d6		20 29 84	jsr $8429	                jsr w_count            ; ( addr u addr-o u-o )
.a2d9		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2db		b5 00		lda $00,x	                lda 0,x
.a2dd		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a2df		95 00		sta $00,x	                sta 0,x
.a2e1		20 e6 94	jsr $94e6	                jsr w_type             ; ( addr u )
.a2e4		a5 2d		lda $2d		                lda scratch
.a2e6		c9 20		cmp #$20	                cmp #OpJSR
.a2e8		d0 15		bne $a2ff	                bne _not_jsr
.a2ea		ca		dex		                dex
.a2eb		ca		dex		                dex
.a2ec		a9 05		lda #$05	                lda #5
.a2ee		95 00		sta $00,x	                sta 0,x
.a2f0		74 01		stz $01,x	                stz 1,x
.a2f2		20 ff 91	jsr $91ff	                jsr w_spaces
.a2f5		20 f3 a3	jsr $a3f3	                jsr disasm_special
.a2f8		b0 70		bcs $a36a	                bcs _printing_done
.a2fa		20 b0 a3	jsr $a3b0	                jsr disasm_jsr
.a2fd		b0 6b		bcs $a36a	                bcs _printing_done
.a2ff						_not_jsr:
.a2ff		c9 4c		cmp #$4c	                cmp #OpJMP
.a301		d0 2d		bne $a330	                bne _not_jmp
.a303		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a305		85 30		sta $30		                sta scratch+3
.a307		a5 2f		lda $2f		                lda scratch+2
.a309		85 31		sta $31		                sta scratch+4
.a30b		b2 30		lda ($30)	                lda (scratch+3)
.a30d		c9 20		cmp #$20	                cmp #OpJSR          ; check for JSR
.a30f		d0 59		bne $a36a	                bne _printing_done
.a311		e6 30		inc $30		                inc scratch+3
.a313		d0 02		bne $a317	                bne +
.a315		e6 31		inc $31		                inc scratch+4
.a317						+
.a317		b2 30		lda ($30)	                lda (scratch+3)
.a319		c9 25		cmp #$25	                cmp #<sliteral_runtime
.a31b		d0 4d		bne $a36a	                bne _printing_done
.a31d		e6 30		inc $30		                inc scratch+3
.a31f		d0 02		bne $a323	                bne +
.a321		e6 31		inc $31		                inc scratch+4
.a323						+
.a323		b2 30		lda ($30)	                lda (scratch+3)
.a325		c9 a2		cmp #$a2	                cmp #>sliteral_runtime
.a327		d0 41		bne $a36a	                bne _printing_done
.a329		c6 32		dec $32		                dec scratch+5                   ; flag for next go round
.a32b		20 86 a3	jsr $a386	                jsr disasm_sliteral_jump
.a32e		80 3a		bra $a36a	                bra _printing_done
.a330						_not_jmp:
.a330		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a332		f0 06		beq $a33a	                beq _is_rel
.a334		29 1f		and #$1f	                and #$1F
.a336		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a338		d0 30		bne $a36a	                bne _printing_done
.a33a						_is_rel:
.a33a		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a33c		ca		dex		                dex
.a33d		ca		dex		                dex
.a33e		74 01		stz $01,x	                stz 1,x
.a340		a5 2e		lda $2e		                lda scratch+1
.a342		95 00		sta $00,x	                sta 0,x
.a344		10 04		bpl $a34a	                bpl +
.a346		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a348		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a34a		38		sec		+               sec                 ; start counting from address after opcode
.a34b		75 04		adc $04,x	                adc 4,x
.a34d		95 00		sta $00,x	                sta 0,x
.a34f		b5 01		lda $01,x	                lda 1,x
.a351		75 05		adc $05,x	                adc 5,x
.a353		95 01		sta $01,x	                sta 1,x
.a355		5a		phy		                phy                 ; save the direction indicator
.a356		ca		dex		                dex
.a357		ca		dex		                dex
.a358		a9 09		lda #$09	                lda #9
.a35a		95 00		sta $00,x	                sta 0,x
.a35c		74 01		stz $01,x	                stz 1,x
.a35e		20 1d 95	jsr $951d	                jsr w_u_dot_r      ; print the destination with 5 leading spaces
.a361		a9 20		lda #$20	                lda #AscSP          ; print space and branch direction indicator
.a363		20 d3 86	jsr $86d3	                jsr emit_a
.a366		68		pla		                pla
.a367		20 d3 86	jsr $86d3	                jsr emit_a
.a36a						_printing_done:
.a36a		20 3a 84	jsr $843a	                jsr w_cr
.a36d		f6 02		inc $02,x	                inc 2,x
.a36f		d0 02		bne $a373	                bne +
.a371		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a373						+
.a373		20 0a 8d	jsr $8d0a	                jsr w_one_minus        ; ( addr+1 u-1 )
.a376		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a378		15 01		ora $01,x	                ora 1,x
.a37a		f0 07		beq $a383	                beq _done
.a37c		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a37e		30 03		bmi $a383	                bmi _done
.a380		4c 59 a2	jmp $a259	                jmp _byte_loop          ; out of range for BRA
.a383						_done:
.a383		4c d4 93	jmp $93d4	                jmp w_two_drop         ; JSR/RTS
.a386						disasm_sliteral_jump:
.a386		20 5f 92	jsr $925f	                jsr w_swap
.a389		ca		dex		                dex
.a38a		ca		dex		                dex
.a38b		a5 2e		lda $2e		                lda scratch+1
.a38d		95 00		sta $00,x	                sta 0,x
.a38f		a5 2f		lda $2f		                lda scratch+2
.a391		95 01		sta $01,x	                sta 1,x
.a393		20 5f 92	jsr $925f	                jsr w_swap
.a396		20 12 8c	jsr $8c12	                jsr w_minus
.a399		20 0a 8d	jsr $8d0a	                jsr w_one_minus
.a39c		20 12 8c	jsr $8c12	                jsr w_minus
.a39f		ca		dex		                dex
.a3a0		ca		dex		                dex
.a3a1		a5 2e		lda $2e		                lda scratch+1
.a3a3		95 00		sta $00,x	                sta 0,x
.a3a5		a5 2f		lda $2f		                lda scratch+2
.a3a7		95 01		sta $01,x	                sta 1,x
.a3a9		20 0a 8d	jsr $8d0a	                jsr w_one_minus
.a3ac		20 5f 92	jsr $925f	                jsr w_swap ; ( new_addr new_n )
.a3af		60		rts		                rts
.a3b0						disasm_jsr:
.a3b0		ca		dex		                dex
.a3b1		ca		dex		                dex
.a3b2		a5 2e		lda $2e		                lda scratch+1
.a3b4		95 00		sta $00,x	                sta 0,x
.a3b6		a5 2f		lda $2f		                lda scratch+2
.a3b8		95 01		sta $01,x	                sta 1,x
.a3ba		20 f3 9b	jsr $9bf3	                jsr w_int_to_name
.a3bd		b5 00		lda $00,x	                lda 0,x
.a3bf		15 01		ora $01,x	                ora 1,x
.a3c1		d0 24		bne $a3e7	                bne _found_nt
.a3c3		a5 2e		lda $2e		                lda scratch+1
.a3c5		38		sec		                sec
.a3c6		e9 03		sbc #$03	                sbc #3         ; Subtract 3 this time.
.a3c8		95 00		sta $00,x	                sta 0,x
.a3ca		a5 2f		lda $2f		                lda scratch+2
.a3cc		e9 00		sbc #$00	                sbc #0         ; Subtract the carry if needed.
.a3ce		95 01		sta $01,x	                sta 1,x
.a3d0		20 f3 9b	jsr $9bf3	                jsr w_int_to_name    ; Try looking again
.a3d3		b5 00		lda $00,x	                lda 0,x
.a3d5		15 01		ora $01,x	                ora 1,x
.a3d7		f0 16		beq $a3ef	                beq _no_nt
.a3d9		20 a9 86	jsr $86a9	                jsr w_dup
.a3dc		20 16 8d	jsr $8d16	                jsr w_one_plus
.a3df		a1 00		lda ($00,x)	                lda (0,x)
.a3e1		e8		inx		                inx
.a3e2		e8		inx		                inx
.a3e3		29 10		and #$10	                and #UF
.a3e5		f0 08		beq $a3ef	                beq _no_nt      ; The word doesn't have underflow checking
.a3e7						_found_nt:
.a3e7		20 96 9c	jsr $9c96	                jsr w_name_to_string
.a3ea		20 e6 94	jsr $94e6	                jsr w_type
.a3ed		38		sec		                sec
.a3ee		60		rts		                rts
.a3ef						_no_nt:
.a3ef		e8		inx		                inx
.a3f0		e8		inx		                inx
.a3f1		18		clc		                clc
.a3f2		60		rts		                rts
.a3f3						disasm_special:
.a3f3		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a3f5		b9 81 a4	lda $a481,y	_check:         lda _special_handlers,y
.a3f8		c5 2e		cmp $2e		                cmp scratch+1
.a3fa		d0 07		bne $a403	                bne _next
.a3fc		b9 82 a4	lda $a482,y	                lda _special_handlers+1,y
.a3ff		c5 2f		cmp $2f		                cmp scratch+2
.a401		f0 08		beq $a40b	                beq _found_handler
.a403		88		dey		_next:          dey
.a404		88		dey		                dey
.a405		88		dey		                dey
.a406		88		dey		                dey
.a407		10 ec		bpl $a3f5	                bpl _check
.a409		18		clc		                clc
.a40a		60		rts		                rts
.a40b						_found_handler:
.a40b		a5 32		lda $32		                lda scratch+5               ; are we expecting sliteral?
.a40d		f0 04		beq $a413	                beq +
.a40f		64 32		stz $32		                stz scratch+5               ; yes, skip 2literal and match again
.a411		80 f0		bra $a403	                bra _next
.a413						+
.a413		b9 84 a4	lda $a484,y	                lda _special_handlers+3,y   ; payload + prefix
.a416		48		pha		                pha                         ; stash a copy for payload later
.a417		4a		lsr a		                lsr
.a418		4a		lsr a		                lsr
.a419		f0 06		beq $a421	                beq _no_prefix
.a41b		18		clc		                clc
.a41c		69 20		adc #$20	                adc #32
.a41e		20 d3 86	jsr $86d3	                jsr emit_a
.a421						_no_prefix:
.a421		b9 83 a4	lda $a483,y	                lda _special_handlers+2,y   ; string index
.a424		20 be d8	jsr $d8be	                jsr print_string_no_lf
.a427		68		pla		                pla
.a428		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a42a		f0 0f		beq $a43b	                beq _done
.a42c		c9 03		cmp #$03	                cmp #3                      ; but 3 means a double-word
.a42e		d0 03		bne $a433	                bne _show_payload
.a430		4c 55 a4	jmp $a455	                jmp _print_2literal
.a433						_show_payload:
.a433		48		pha		                pha
.a434		20 3d a4	jsr $a43d	                jsr _print_literal
.a437		68		pla		                pla
.a438		3a		dec a		                dea
.a439		d0 f8		bne $a433	                bne _show_payload
.a43b		38		sec		_done:          sec
.a43c		60		rts		                rts
.a43d						_print_literal:
.a43d		20 5f 92	jsr $925f	                jsr w_swap ; switch to (u addr)
.a440		20 16 8d	jsr $8d16	                jsr w_one_plus
.a443		20 a9 86	jsr $86a9	                jsr w_dup
.a446		20 59 99	jsr $9959	                jsr w_question ; Print the value at the address
.a449		20 16 8d	jsr $8d16	                jsr w_one_plus
.a44c		20 5f 92	jsr $925f	                jsr w_swap ; (addr+2 u)
.a44f		20 0a 8d	jsr $8d0a	                jsr w_one_minus
.a452		4c 0a 8d	jmp $8d0a	                jmp w_one_minus ; (addr+2 u-2)
.a455						_print_2literal:
.a455		20 5f 92	jsr $925f	                jsr w_swap
.a458		20 16 8d	jsr $8d16	                jsr w_one_plus
.a45b		20 a9 86	jsr $86a9	                jsr w_dup
.a45e		20 f4 93	jsr $93f4	                jsr w_two_fetch
.a461		20 5f 92	jsr $925f	                jsr w_swap             ; 2! / 2@ put MSW first; but 2literal writes LSW first
.a464		20 c5 9e	jsr $9ec5	                jsr w_d_dot
.a467		18		clc		                clc
.a468		b5 00		lda $00,x	                lda 0,x
.a46a		69 03		adc #$03	                adc #3
.a46c		95 00		sta $00,x	                sta 0,x
.a46e		90 02		bcc $a472	                bcc +
.a470		f6 01		inc $01,x	                inc 1,x
.a472						+
.a472		20 5f 92	jsr $925f	                jsr w_swap ; ( addr+4 u )
.a475		38		sec		                sec
.a476		b5 00		lda $00,x	                lda 0,x
.a478		e9 04		sbc #$04	                sbc #4
.a47a		95 00		sta $00,x	                sta 0,x
.a47c		b0 02		bcs $a480	                bcs +
.a47e		d6 01		dec $01,x	                dec 1,x
.a480						+
.a480		60		rts		                rts
.a481						_special_handlers:
>a481		82 d8				    .word underflow_1
>a483		0c 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a485		87 d8				    .word underflow_2
>a487		0c 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a489		8c d8				    .word underflow_3
>a48b		0c 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a48d		91 d8				    .word underflow_4
>a48f		0c 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a491		65 8a				    .word literal_runtime
>a493		0d 01				        .byte str_disasm_lit, 1
>a495		25 a2				    .word sliteral_runtime
>a497		0d ce				        .byte str_disasm_lit, 2 + ('S'-32)*4
>a499		25 a2				    .word sliteral_runtime                      ; 2literal and sliteral use the same runtime
>a49b		0d 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4    ; list is searched in reverse, put 2literal first
>a49d		6b 98				    .word zero_branch_runtime
>a49f		0e 01				        .byte str_disasm_0bra, 1
>a4a1		fd 8a				    .word loop_runtime
>a4a3		0f 01				        .byte str_disasm_loop, 1
>a4a5		16 8b				    .word plus_loop_runtime
>a4a7		0f 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a4a9		c2 85				    .word do_runtime
>a4ab		10 00				        .byte str_disasm_do, 0
>a4ad		aa 85				    .word question_do_runtime
>a4af		10 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a4b1						_end_handlers:
.a4b1						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a4b1						assembler:
.a4b1						xt_asm_adc_h:
.a4b1		a9 69		lda #$69	                lda #$69
.a4b3		4c 0c a8	jmp $a80c	                jmp asm_common
.a4b6						z_asm_adc_h:
.a4b6						xt_asm_adc_x:
.a4b6		a9 7d		lda #$7d	                lda #$7D
.a4b8		4c 0c a8	jmp $a80c	                jmp asm_common
.a4bb						z_asm_adc_x:
.a4bb						xt_asm_adc_y:
.a4bb		a9 79		lda #$79	                lda #$79
.a4bd		4c 0c a8	jmp $a80c	                jmp asm_common
.a4c0						z_asm_adc_y:
.a4c0						xt_asm_adc_z:
.a4c0		a9 65		lda #$65	                lda #$65
.a4c2		4c 0c a8	jmp $a80c	                jmp asm_common
.a4c5						z_asm_adc_z:
.a4c5						xt_asm_adc_zi:
.a4c5		a9 72		lda #$72	                lda #$72
.a4c7		4c 0c a8	jmp $a80c	                jmp asm_common
.a4ca						z_asm_adc_zi:
.a4ca						xt_asm_adc_ziy:
.a4ca		a9 71		lda #$71	                lda #$71
.a4cc		4c 0c a8	jmp $a80c	                jmp asm_common
.a4cf						z_asm_adc_ziy:
.a4cf						xt_asm_adc_zx:
.a4cf		a9 75		lda #$75	                lda #$75
.a4d1		4c 0c a8	jmp $a80c	                jmp asm_common
.a4d4						z_asm_adc_zx:
.a4d4						xt_asm_adc_zxi:
.a4d4		a9 61		lda #$61	                lda #$61
.a4d6		4c 0c a8	jmp $a80c	                jmp asm_common
.a4d9						z_asm_adc_zxi:
.a4d9						xt_asm_and:
.a4d9		a9 2d		lda #$2d	                lda #$2D
.a4db		4c 0c a8	jmp $a80c	                jmp asm_common
.a4de						z_asm_and:
.a4de						xt_asm_and_h:
.a4de		a9 29		lda #$29	                lda #$29
.a4e0		4c 0c a8	jmp $a80c	                jmp asm_common
.a4e3						z_asm_and_h:
.a4e3						xt_asm_and_x:
.a4e3		a9 3d		lda #$3d	                lda #$3D
.a4e5		4c 0c a8	jmp $a80c	                jmp asm_common
.a4e8						z_asm_and_x:
.a4e8						xt_asm_and_y:
.a4e8		a9 39		lda #$39	                lda #$39
.a4ea		4c 0c a8	jmp $a80c	                jmp asm_common
.a4ed						z_asm_and_y:
.a4ed						xt_asm_and_z:
.a4ed		a9 25		lda #$25	                lda #$25
.a4ef		4c 0c a8	jmp $a80c	                jmp asm_common
.a4f2						z_asm_and_z:
.a4f2						xt_asm_and_zi:
.a4f2		a9 32		lda #$32	                lda #$32
.a4f4		4c 0c a8	jmp $a80c	                jmp asm_common
.a4f7						z_asm_and_zi:
.a4f7						xt_asm_and_ziy:
.a4f7		a9 31		lda #$31	                lda #$31
.a4f9		4c 0c a8	jmp $a80c	                jmp asm_common
.a4fc						z_asm_and_ziy:
.a4fc						xt_asm_and_zx:
.a4fc		a9 35		lda #$35	                lda #$35
.a4fe		4c 0c a8	jmp $a80c	                jmp asm_common
.a501						z_asm_and_zx:
.a501						xt_asm_and_zxi:
.a501		a9 21		lda #$21	                lda #$21
.a503		4c 0c a8	jmp $a80c	                jmp asm_common
.a506						z_asm_and_zxi:
.a506						xt_asm_asl:
.a506		a9 0e		lda #$0e	                lda #$0E
.a508		4c 0c a8	jmp $a80c	                jmp asm_common
.a50b						z_asm_asl:
.a50b						xt_asm_asl_a:
.a50b		a9 0a		lda #$0a	                lda #$0A
.a50d		4c 0c a8	jmp $a80c	                jmp asm_common
.a510						z_asm_asl_a:
.a510						xt_asm_asl_x:
.a510		a9 1e		lda #$1e	                lda #$1E
.a512		4c 0c a8	jmp $a80c	                jmp asm_common
.a515						z_asm_asl_x:
.a515						xt_asm_asl_z:
.a515		a9 06		lda #$06	                lda #$06
.a517		4c 0c a8	jmp $a80c	                jmp asm_common
.a51a						z_asm_asl_z:
.a51a						xt_asm_asl_zx:
.a51a		a9 16		lda #$16	                lda #$16
.a51c		4c 0c a8	jmp $a80c	                jmp asm_common
.a51f						z_asm_asl_zx:
.a51f						xt_asm_bcc:
.a51f		a9 90		lda #$90	                lda #$90
.a521		4c 0c a8	jmp $a80c	                jmp asm_common
.a524						z_asm_bcc:
.a524						xt_asm_bcs:
.a524		a9 b0		lda #$b0	                lda #$B0
.a526		a0 02		ldy #$02	                ldy #2
.a528		4c 0c a8	jmp $a80c	                jmp asm_common
.a52b						z_asm_bcs:
.a52b						xt_asm_beq:
.a52b		a9 f0		lda #$f0	                lda #$F0
.a52d		4c 0c a8	jmp $a80c	                jmp asm_common
.a530						z_asm_beq:
.a530						xt_asm_bit:
.a530		a9 2c		lda #$2c	                lda #$2C
.a532		4c 0c a8	jmp $a80c	                jmp asm_common
.a535						z_asm_bit:
.a535						xt_asm_bit_h:
.a535		a9 89		lda #$89	                lda #$89
.a537		4c 0c a8	jmp $a80c	                jmp asm_common
.a53a						z_asm_bit_h:
.a53a						xt_asm_bit_x:
.a53a		a9 3c		lda #$3c	                lda #$3C
.a53c		4c 0c a8	jmp $a80c	                jmp asm_common
.a53f						z_asm_bit_x:
.a53f						xt_asm_bit_z:
.a53f		a9 24		lda #$24	                lda #$24
.a541		4c 0c a8	jmp $a80c	                jmp asm_common
.a544						z_asm_bit_z:
.a544						xt_asm_bit_zx:
.a544		a9 34		lda #$34	                lda #$34
.a546		4c 0c a8	jmp $a80c	                jmp asm_common
.a549						z_asm_bit_zx:
.a549						xt_asm_bmi:
.a549		a9 30		lda #$30	                lda #$30
.a54b		4c 0c a8	jmp $a80c	                jmp asm_common
.a54e						z_asm_bmi:
.a54e						xt_asm_bne:
.a54e		a9 d0		lda #$d0	                lda #$D0
.a550		4c 0c a8	jmp $a80c	                jmp asm_common
.a553						z_asm_bne:
.a553						xt_asm_bpl:
.a553		a9 10		lda #$10	                lda #$10
.a555		4c 0c a8	jmp $a80c	                jmp asm_common
.a558						z_asm_bpl:
.a558						xt_asm_bra:
.a558		a9 80		lda #$80	                lda #$80
.a55a		4c 0c a8	jmp $a80c	                jmp asm_common
.a55d						z_asm_bra:
.a55d						xt_asm_brk:
.a55d		a9 00		lda #$00	                lda #$00
.a55f		4c 0c a8	jmp $a80c	                jmp asm_common
.a562						z_asm_brk:
.a562						xt_asm_bvc:
.a562		a9 50		lda #$50	                lda #$50
.a564		4c 0c a8	jmp $a80c	                jmp asm_common
.a567						z_asm_bvc:
.a567						xt_asm_bvs:
.a567		a9 70		lda #$70	                lda #$70
.a569		4c 0c a8	jmp $a80c	                jmp asm_common
.a56c						z_asm_bvs:
.a56c						xt_asm_clc:
.a56c		a9 18		lda #$18	                lda #$18
.a56e		4c 0c a8	jmp $a80c	                jmp asm_common
.a571						z_asm_clc:
.a571						xt_asm_cld:
.a571		a9 d8		lda #$d8	                lda #$D8
.a573		4c 0c a8	jmp $a80c	                jmp asm_common
.a576						z_asm_cld:
.a576						xt_asm_cli:
.a576		a9 58		lda #$58	                lda #$58
.a578		4c 0c a8	jmp $a80c	                jmp asm_common
.a57b						z_asm_cli:
.a57b						xt_asm_clv:
.a57b		a9 b8		lda #$b8	                lda #$B8
.a57d		4c 0c a8	jmp $a80c	                jmp asm_common
.a580						z_asm_clv:
.a580						xt_asm_cmp:
.a580		a9 cd		lda #$cd	                lda #$CD
.a582		4c 0c a8	jmp $a80c	                jmp asm_common
.a585						z_asm_cmp:
.a585						xt_asm_cmp_h:
.a585		a9 c9		lda #$c9	                lda #$C9
.a587		4c 0c a8	jmp $a80c	                jmp asm_common
.a58a						z_asm_cmp_h:
.a58a						xt_asm_cmp_x:
.a58a		a9 dd		lda #$dd	                lda #$DD
.a58c		4c 0c a8	jmp $a80c	                jmp asm_common
.a58f						z_asm_cmp_x:
.a58f						xt_asm_cmp_y:
.a58f		a9 d9		lda #$d9	                lda #$D9
.a591		4c 0c a8	jmp $a80c	                jmp asm_common
.a594						z_asm_cmp_y:
.a594						xt_asm_cmp_z:
.a594		a9 c5		lda #$c5	                lda #$C5
.a596		4c 0c a8	jmp $a80c	                jmp asm_common
.a599						z_asm_cmp_z:
.a599						xt_asm_cmp_zi:
.a599		a9 d2		lda #$d2	                lda #$D2
.a59b		4c 0c a8	jmp $a80c	                jmp asm_common
.a59e						z_asm_cmp_zi:
.a59e						xt_asm_cmp_ziy:
.a59e		a9 d1		lda #$d1	                lda #$D1
.a5a0		4c 0c a8	jmp $a80c	                jmp asm_common
.a5a3						z_asm_cmp_ziy:
.a5a3						xt_asm_cmp_zx:
.a5a3		a9 d5		lda #$d5	                lda #$D5
.a5a5		4c 0c a8	jmp $a80c	                jmp asm_common
.a5a8						z_asm_cmp_zx:
.a5a8						xt_asm_cmp_zxi:
.a5a8		a9 c1		lda #$c1	                lda #$C1
.a5aa		4c 0c a8	jmp $a80c	                jmp asm_common
.a5ad						z_asm_cmp_zxi:
.a5ad						xt_asm_cpx:
.a5ad		a9 ec		lda #$ec	                lda #$EC
.a5af		4c 0c a8	jmp $a80c	                jmp asm_common
.a5b2						z_asm_cpx:
.a5b2						xt_asm_cpx_h:
.a5b2		a9 e0		lda #$e0	                lda #$E0
.a5b4		4c 0c a8	jmp $a80c	                jmp asm_common
.a5b7						z_asm_cpx_h:
.a5b7						xt_asm_cpx_z:
.a5b7		a9 e4		lda #$e4	                lda #$E4
.a5b9		4c 0c a8	jmp $a80c	                jmp asm_common
.a5bc						z_asm_cpx_z:
.a5bc						xt_asm_cpy:
.a5bc		a9 cc		lda #$cc	                lda #$CC
.a5be		a0 03		ldy #$03	                ldy #3
.a5c0		4c 0c a8	jmp $a80c	                jmp asm_common
.a5c3						z_asm_cpy:
.a5c3						xt_asm_cpy_h:
.a5c3		a9 c0		lda #$c0	                lda #$C0
.a5c5		4c 0c a8	jmp $a80c	                jmp asm_common
.a5c8						z_asm_cpy_h:
.a5c8						xt_asm_cpy_z:
.a5c8		a9 c4		lda #$c4	                lda #$C4
.a5ca		4c 0c a8	jmp $a80c	                jmp asm_common
.a5cd						z_asm_cpy_z:
.a5cd						xt_asm_dec:
.a5cd		a9 ce		lda #$ce	                lda #$CE
.a5cf		4c 0c a8	jmp $a80c	                jmp asm_common
.a5d2						z_asm_dec:
.a5d2						xt_asm_dec_a:
.a5d2		a9 3a		lda #$3a	                lda #$3A
.a5d4		4c 0c a8	jmp $a80c	                jmp asm_common
.a5d7						z_asm_dec_a:
.a5d7						xt_asm_dec_x:
.a5d7		a9 de		lda #$de	                lda #$DE
.a5d9		4c 0c a8	jmp $a80c	                jmp asm_common
.a5dc						z_asm_dec_x:
.a5dc						xt_asm_dec_z:
.a5dc		a9 c6		lda #$c6	                lda #$C6
.a5de		4c 0c a8	jmp $a80c	                jmp asm_common
.a5e1						z_asm_dec_z:
.a5e1						xt_asm_dec_zx:
.a5e1		a9 d6		lda #$d6	                lda #$D6
.a5e3		4c 0c a8	jmp $a80c	                jmp asm_common
.a5e6						z_asm_dec_zx:
.a5e6						xt_asm_dex:
.a5e6		a9 ca		lda #$ca	                lda #$CA
.a5e8		4c 0c a8	jmp $a80c	                jmp asm_common
.a5eb						z_asm_dex:
.a5eb						xt_asm_dey:
.a5eb		a9 88		lda #$88	                lda #$88
.a5ed		4c 0c a8	jmp $a80c	                jmp asm_common
.a5f0						z_asm_dey:
.a5f0						xt_asm_eor:
.a5f0		a9 4d		lda #$4d	                lda #$4D
.a5f2		4c 0c a8	jmp $a80c	                jmp asm_common
.a5f5						z_asm_eor:
.a5f5						xt_asm_eor_h:
.a5f5		a9 49		lda #$49	                lda #$49
.a5f7		4c 0c a8	jmp $a80c	                jmp asm_common
.a5fa						z_asm_eor_h:
.a5fa						xt_asm_eor_x:
.a5fa		a9 5d		lda #$5d	                lda #$5D
.a5fc		4c 0c a8	jmp $a80c	                jmp asm_common
.a5ff						z_asm_eor_x:
.a5ff						xt_asm_eor_y:
.a5ff		a9 59		lda #$59	                lda #$59
.a601		4c 0c a8	jmp $a80c	                jmp asm_common
.a604						z_asm_eor_y:
.a604						xt_asm_eor_z:
.a604		a9 45		lda #$45	                lda #$45
.a606		4c 0c a8	jmp $a80c	                jmp asm_common
.a609						z_asm_eor_z:
.a609						xt_asm_eor_zi:
.a609		a9 52		lda #$52	                lda #$52
.a60b		4c 0c a8	jmp $a80c	                jmp asm_common
.a60e						z_asm_eor_zi:
.a60e						xt_asm_eor_ziy:
.a60e		a9 51		lda #$51	                lda #$51
.a610		4c 0c a8	jmp $a80c	                jmp asm_common
.a613						z_asm_eor_ziy:
.a613						xt_asm_eor_zx:
.a613		a9 55		lda #$55	                lda #$55
.a615		4c 0c a8	jmp $a80c	                jmp asm_common
.a618						z_asm_eor_zx:
.a618						xt_asm_eor_zxi:
.a618		a9 41		lda #$41	                lda #$41
.a61a		4c 0c a8	jmp $a80c	                jmp asm_common
.a61d						z_asm_eor_zxi:
.a61d						xt_asm_inc:
.a61d		a9 ee		lda #$ee	                lda #$EE
.a61f		4c 0c a8	jmp $a80c	                jmp asm_common
.a622						z_asm_inc:
.a622						xt_asm_inc_a:
.a622		a9 1a		lda #$1a	                lda #$1A
.a624		4c 0c a8	jmp $a80c	                jmp asm_common
.a627						z_asm_inc_a:
.a627						xt_asm_inc_x:
.a627		a9 fe		lda #$fe	                lda #$FE
.a629		4c 0c a8	jmp $a80c	                jmp asm_common
.a62c						z_asm_inc_x:
.a62c						xt_asm_inc_z:
.a62c		a9 e6		lda #$e6	                lda #$E6
.a62e		4c 0c a8	jmp $a80c	                jmp asm_common
.a631						z_asm_inc_z:
.a631						xt_asm_inc_zx:
.a631		a9 f6		lda #$f6	                lda #$F6
.a633		4c 0c a8	jmp $a80c	                jmp asm_common
.a636						z_asm_inc_zx:
.a636						xt_asm_inx:
.a636		a9 e8		lda #$e8	                lda #$E8
.a638		4c 0c a8	jmp $a80c	                jmp asm_common
.a63b						z_asm_inx:
.a63b						xt_asm_iny:
.a63b		a9 c8		lda #$c8	                lda #$C8
.a63d		4c 0c a8	jmp $a80c	                jmp asm_common
.a640						z_asm_iny:
.a640						xt_asm_jmp:
.a640		a9 4c		lda #$4c	                lda #$4C
.a642		4c 0c a8	jmp $a80c	                jmp asm_common
.a645						z_asm_jmp:
.a645						xt_asm_jmp_i:
.a645		a9 6c		lda #$6c	                lda #$6C
.a647		4c 0c a8	jmp $a80c	                jmp asm_common
.a64a						z_asm_jmp_i:
.a64a						xt_asm_jmp_xi:
.a64a		a9 7c		lda #$7c	                lda #$7C
.a64c		4c 0c a8	jmp $a80c	                jmp asm_common
.a64f						z_asm_jmp_xi:
.a64f						xt_asm_jsr:
.a64f		a9 20		lda #$20	                lda #$20
.a651		4c 0c a8	jmp $a80c	                jmp asm_common
.a654						z_asm_jsr:
.a654						xt_asm_lda:
.a654		a9 ad		lda #$ad	                lda #$AD
.a656		4c 0c a8	jmp $a80c	                jmp asm_common
.a659						z_asm_lda:
.a659						xt_asm_lda_h:
.a659		a9 a9		lda #$a9	                lda #$A9
.a65b		4c 0c a8	jmp $a80c	                jmp asm_common
.a65e						z_asm_lda_h:
.a65e						xt_asm_lda_x:
.a65e		a9 bd		lda #$bd	                lda #$BD
.a660		4c 0c a8	jmp $a80c	                jmp asm_common
.a663						z_asm_lda_x:
.a663						xt_asm_lda_y:
.a663		a9 b9		lda #$b9	                lda #$B9
.a665		4c 0c a8	jmp $a80c	                jmp asm_common
.a668						z_asm_lda_y:
.a668						xt_asm_lda_z:
.a668		a9 a5		lda #$a5	                lda #$A5
.a66a		4c 0c a8	jmp $a80c	                jmp asm_common
.a66d						z_asm_lda_z:
.a66d						xt_asm_lda_zi:
.a66d		a9 b2		lda #$b2	                lda #$B2
.a66f		4c 0c a8	jmp $a80c	                jmp asm_common
.a672						z_asm_lda_zi:
.a672						xt_asm_lda_ziy:
.a672		a9 b1		lda #$b1	                lda #$B1
.a674		4c 0c a8	jmp $a80c	                jmp asm_common
.a677						z_asm_lda_ziy:
.a677						xt_asm_lda_zx:
.a677		a9 b5		lda #$b5	                lda #$B5
.a679		4c 0c a8	jmp $a80c	                jmp asm_common
.a67c						z_asm_lda_zx:
.a67c						xt_asm_lda_zxi:
.a67c		a9 a1		lda #$a1	                lda #$A1
.a67e		4c 0c a8	jmp $a80c	                jmp asm_common
.a681						z_asm_lda_zxi:
.a681						xt_asm_ldx:
.a681		a9 ae		lda #$ae	                lda #$AE
.a683		4c 0c a8	jmp $a80c	                jmp asm_common
.a686						z_asm_ldx:
.a686						xt_asm_ldx_h:
.a686		a9 a2		lda #$a2	                lda #$A2
.a688		4c 0c a8	jmp $a80c	                jmp asm_common
.a68b						z_asm_ldx_h:
.a68b						xt_asm_ldx_y:
.a68b		a9 be		lda #$be	                lda #$BE
.a68d		4c 0c a8	jmp $a80c	                jmp asm_common
.a690						z_asm_ldx_y:
.a690						xt_asm_ldx_z:
.a690		a9 a6		lda #$a6	                lda #$A6
.a692		4c 0c a8	jmp $a80c	                jmp asm_common
.a695						z_asm_ldx_z:
.a695						xt_asm_ldx_zy:
.a695		a9 b6		lda #$b6	                lda #$B6
.a697		4c 0c a8	jmp $a80c	                jmp asm_common
.a69a						z_asm_ldx_zy:
.a69a						xt_asm_ldy:
.a69a		a9 ac		lda #$ac	                lda #$AC
.a69c		4c 0c a8	jmp $a80c	                jmp asm_common
.a69f						z_asm_ldy:
.a69f						xt_asm_ldy_h:
.a69f		a9 a0		lda #$a0	                lda #$A0
.a6a1		4c 0c a8	jmp $a80c	                jmp asm_common
.a6a4						z_asm_ldy_h:
.a6a4						xt_asm_ldy_x:
.a6a4		a9 bc		lda #$bc	                lda #$BC
.a6a6		4c 0c a8	jmp $a80c	                jmp asm_common
.a6a9						z_asm_ldy_x:
.a6a9						xt_asm_ldy_z:
.a6a9		a9 a4		lda #$a4	                lda #$A4
.a6ab		4c 0c a8	jmp $a80c	                jmp asm_common
.a6ae						z_asm_ldy_z:
.a6ae						xt_asm_ldy_zx:
.a6ae		a9 b4		lda #$b4	                lda #$B4
.a6b0		4c 0c a8	jmp $a80c	                jmp asm_common
.a6b3						z_asm_ldy_zx:
.a6b3						xt_asm_lsr:
.a6b3		a9 4e		lda #$4e	                lda #$4E
.a6b5		4c 0c a8	jmp $a80c	                jmp asm_common
.a6b8						z_asm_lsr:
.a6b8						xt_asm_lsr_a:
.a6b8		a9 4a		lda #$4a	                lda #$4A
.a6ba		4c 0c a8	jmp $a80c	                jmp asm_common
.a6bd						z_asm_lsr_a:
.a6bd						xt_asm_lsr_x:
.a6bd		a9 5e		lda #$5e	                lda #$5E
.a6bf		4c 0c a8	jmp $a80c	                jmp asm_common
.a6c2						z_asm_lsr_x:
.a6c2						xt_asm_lsr_z:
.a6c2		a9 46		lda #$46	                lda #$46
.a6c4		4c 0c a8	jmp $a80c	                jmp asm_common
.a6c7						z_asm_lsr_z:
.a6c7						xt_asm_lsr_zx:
.a6c7		a9 56		lda #$56	                lda #$56
.a6c9		4c 0c a8	jmp $a80c	                jmp asm_common
.a6cc						z_asm_lsr_zx:
.a6cc						xt_asm_nop:
.a6cc		a9 ea		lda #$ea	                lda #$EA
.a6ce		4c 0c a8	jmp $a80c	                jmp asm_common
.a6d1						z_asm_nop:
.a6d1						xt_asm_ora:
.a6d1		a9 0d		lda #$0d	                lda #$0D
.a6d3		4c 0c a8	jmp $a80c	                jmp asm_common
.a6d6						z_asm_ora:
.a6d6						xt_asm_ora_h:
.a6d6		a9 09		lda #$09	                lda #$09
.a6d8		4c 0c a8	jmp $a80c	                jmp asm_common
.a6db						z_asm_ora_h:
.a6db						xt_asm_ora_x:
.a6db		a9 1d		lda #$1d	                lda #$1D
.a6dd		4c 0c a8	jmp $a80c	                jmp asm_common
.a6e0						z_asm_ora_x:
.a6e0						xt_asm_ora_y:
.a6e0		a9 19		lda #$19	                lda #$19
.a6e2		4c 0c a8	jmp $a80c	                jmp asm_common
.a6e5						z_asm_ora_y:
.a6e5						xt_asm_ora_z:
.a6e5		a9 05		lda #$05	                lda #$05
.a6e7		4c 0c a8	jmp $a80c	                jmp asm_common
.a6ea						z_asm_ora_z:
.a6ea						xt_asm_ora_zi:
.a6ea		a9 12		lda #$12	                lda #$12
.a6ec		a0 02		ldy #$02	                ldy #2
.a6ee		4c 0c a8	jmp $a80c	                jmp asm_common
.a6f1						z_asm_ora_zi:
.a6f1						xt_asm_ora_ziy:
.a6f1		a9 11		lda #$11	                lda #$11
.a6f3		4c 0c a8	jmp $a80c	                jmp asm_common
.a6f6						z_asm_ora_ziy:
.a6f6						xt_asm_ora_zx:
.a6f6		a9 15		lda #$15	                lda #$15
.a6f8		4c 0c a8	jmp $a80c	                jmp asm_common
.a6fb						z_asm_ora_zx:
.a6fb						xt_asm_ora_zxi:
.a6fb		a9 01		lda #$01	                lda #$01
.a6fd		4c 0c a8	jmp $a80c	                jmp asm_common
.a700						z_asm_ora_zxi:
.a700						xt_asm_pha:
.a700		a9 48		lda #$48	                lda #$48
.a702		4c 0c a8	jmp $a80c	                jmp asm_common
.a705						z_asm_pha:
.a705						xt_asm_php:
.a705		a9 08		lda #$08	                lda #$08
.a707		4c 0c a8	jmp $a80c	                jmp asm_common
.a70a						z_asm_php:
.a70a						xt_asm_phx:
.a70a		a9 da		lda #$da	                lda #$DA
.a70c		4c 0c a8	jmp $a80c	                jmp asm_common
.a70f						z_asm_phx:
.a70f						xt_asm_phy:
.a70f		a9 5a		lda #$5a	                lda #$5A
.a711		4c 0c a8	jmp $a80c	                jmp asm_common
.a714						z_asm_phy:
.a714						xt_asm_pla:
.a714		a9 68		lda #$68	                lda #$68
.a716		4c 0c a8	jmp $a80c	                jmp asm_common
.a719						z_asm_pla:
.a719						xt_asm_plp:
.a719		a9 28		lda #$28	                lda #$28
.a71b		4c 0c a8	jmp $a80c	                jmp asm_common
.a71e						z_asm_plp:
.a71e						xt_asm_plx:
.a71e		a9 fa		lda #$fa	                lda #$FA
.a720		4c 0c a8	jmp $a80c	                jmp asm_common
.a723						z_asm_plx:
.a723						xt_asm_ply:
.a723		a9 7a		lda #$7a	                lda #$7A
.a725		4c 0c a8	jmp $a80c	                jmp asm_common
.a728						z_asm_ply:
.a728						xt_asm_rol:
.a728		a9 2e		lda #$2e	                lda #$2E
.a72a		4c 0c a8	jmp $a80c	                jmp asm_common
.a72d						z_asm_rol:
.a72d						xt_asm_rol_a:
.a72d		a9 2a		lda #$2a	                lda #$2A
.a72f		4c 0c a8	jmp $a80c	                jmp asm_common
.a732						z_asm_rol_a:
.a732						xt_asm_rol_x:
.a732		a9 3e		lda #$3e	                lda #$3E
.a734		4c 0c a8	jmp $a80c	                jmp asm_common
.a737						z_asm_rol_x:
.a737						xt_asm_rol_z:
.a737		a9 26		lda #$26	                lda #$26
.a739		4c 0c a8	jmp $a80c	                jmp asm_common
.a73c						z_asm_rol_z:
.a73c						xt_asm_rol_zx:
.a73c		a9 36		lda #$36	                lda #$36
.a73e		4c 0c a8	jmp $a80c	                jmp asm_common
.a741						z_asm_rol_zx:
.a741						xt_asm_ror:
.a741		a9 6e		lda #$6e	                lda #$6E
.a743		4c 0c a8	jmp $a80c	                jmp asm_common
.a746						z_asm_ror:
.a746						xt_asm_ror_a:
.a746		a9 6a		lda #$6a	                lda #$6A
.a748		4c 0c a8	jmp $a80c	                jmp asm_common
.a74b						z_asm_ror_a:
.a74b						xt_asm_ror_x:
.a74b		a9 7e		lda #$7e	                lda #$7E
.a74d		4c 0c a8	jmp $a80c	                jmp asm_common
.a750						z_asm_ror_x:
.a750						xt_asm_ror_z:
.a750		a9 66		lda #$66	                lda #$66
.a752		4c 0c a8	jmp $a80c	                jmp asm_common
.a755						z_asm_ror_z:
.a755						xt_asm_ror_zx:
.a755		a9 76		lda #$76	                lda #$76
.a757		4c 0c a8	jmp $a80c	                jmp asm_common
.a75a						z_asm_ror_zx:
.a75a						xt_asm_rti:
.a75a		a9 40		lda #$40	                lda #$40
.a75c		4c 0c a8	jmp $a80c	                jmp asm_common
.a75f						z_asm_rti:
.a75f						xt_asm_rts:
.a75f		a9 60		lda #$60	                lda #$60
.a761		4c 0c a8	jmp $a80c	                jmp asm_common
.a764						z_asm_rts:
.a764						xt_asm_sbc:
.a764		a9 ed		lda #$ed	                lda #$ED
.a766		4c 0c a8	jmp $a80c	                jmp asm_common
.a769						z_asm_sbc:
.a769						xt_asm_sbc_h:
.a769		a9 e9		lda #$e9	                lda #$E9
.a76b		4c 0c a8	jmp $a80c	                jmp asm_common
.a76e						z_asm_sbc_h:
.a76e						xt_asm_sbc_x:
.a76e		a9 fd		lda #$fd	                lda #$FD
.a770		4c 0c a8	jmp $a80c	                jmp asm_common
.a773						z_asm_sbc_x:
.a773						xt_asm_sbc_y:
.a773		a9 f9		lda #$f9	                lda #$F9
.a775		4c 0c a8	jmp $a80c	                jmp asm_common
.a778						z_asm_sbc_y:
.a778						xt_asm_sbc_z:
.a778		a9 e5		lda #$e5	                lda #$E5
.a77a		4c 0c a8	jmp $a80c	                jmp asm_common
.a77d						z_asm_sbc_z:
.a77d						xt_asm_sbc_zi:
.a77d		a9 f2		lda #$f2	                lda #$F2
.a77f		4c 0c a8	jmp $a80c	                jmp asm_common
.a782						z_asm_sbc_zi:
.a782						xt_asm_sbc_ziy:
.a782		a9 f1		lda #$f1	                lda #$F1
.a784		4c 0c a8	jmp $a80c	                jmp asm_common
.a787						z_asm_sbc_ziy:
.a787						xt_asm_sbc_zx:
.a787		a9 f5		lda #$f5	                lda #$F5
.a789		4c 0c a8	jmp $a80c	                jmp asm_common
.a78c						z_asm_sbc_zx:
.a78c						xt_asm_sbc_zxi:
.a78c		a9 e1		lda #$e1	                lda #$E1
.a78e		80 7c		bra $a80c	                bra asm_common  ; <-- limit for BRA instead of JMP
.a790						z_asm_sbc_zxi:
.a790						xt_asm_sec:
.a790		a9 38		lda #$38	                lda #$38
.a792		80 78		bra $a80c	                bra asm_common
.a794						z_asm_sec:
.a794						xt_asm_sed:
.a794		a9 f8		lda #$f8	                lda #$F8
.a796		80 74		bra $a80c	                bra asm_common
.a798						z_asm_sed:
.a798						xt_asm_sei:
.a798		a9 78		lda #$78	                lda #$78
.a79a		80 70		bra $a80c	                bra asm_common
.a79c						z_asm_sei:
.a79c						xt_asm_sta:
.a79c		a9 8d		lda #$8d	                lda #$8D
.a79e		80 6c		bra $a80c	                bra asm_common
.a7a0						z_asm_sta:
.a7a0						xt_asm_sta_x:
.a7a0		a9 9d		lda #$9d	                lda #$9D
.a7a2		80 68		bra $a80c	                bra asm_common
.a7a4						z_asm_sta_x:
.a7a4						xt_asm_sta_y:
.a7a4		a9 99		lda #$99	                lda #$99
.a7a6		80 64		bra $a80c	                bra asm_common
.a7a8						z_asm_sta_y:
.a7a8						xt_asm_sta_z:
.a7a8		a9 85		lda #$85	                lda #$85
.a7aa		80 60		bra $a80c	                bra asm_common
.a7ac						z_asm_sta_z:
.a7ac						xt_asm_sta_zi:
.a7ac		a9 92		lda #$92	                lda #$92
.a7ae		80 5c		bra $a80c	                bra asm_common
.a7b0						z_asm_sta_zi:
.a7b0						xt_asm_sta_ziy:
.a7b0		a9 91		lda #$91	                lda #$91
.a7b2		80 58		bra $a80c	                bra asm_common
.a7b4						z_asm_sta_ziy:
.a7b4						xt_asm_sta_zx:
.a7b4		a9 95		lda #$95	                lda #$95
.a7b6		80 54		bra $a80c	                bra asm_common
.a7b8						z_asm_sta_zx:
.a7b8						xt_asm_sta_zxi:
.a7b8		a9 81		lda #$81	                lda #$81
.a7ba		80 50		bra $a80c	                bra asm_common
.a7bc						z_asm_sta_zxi:
.a7bc						xt_asm_stx:
.a7bc		a9 8e		lda #$8e	                lda #$8E
.a7be		80 4c		bra $a80c	                bra asm_common
.a7c0						z_asm_stx:
.a7c0						xt_asm_stx_z:
.a7c0		a9 86		lda #$86	                lda #$86
.a7c2		80 48		bra $a80c	                bra asm_common
.a7c4						z_asm_stx_z:
.a7c4						xt_asm_stx_zy:
.a7c4		a9 96		lda #$96	                lda #$96
.a7c6		80 44		bra $a80c	                bra asm_common
.a7c8						z_asm_stx_zy:
.a7c8						xt_asm_sty:
.a7c8		a9 8c		lda #$8c	                lda #$8C
.a7ca		80 40		bra $a80c	                bra asm_common
.a7cc						z_asm_sty:
.a7cc						xt_asm_sty_z:
.a7cc		a9 84		lda #$84	                lda #$84
.a7ce		80 3c		bra $a80c	                bra asm_common
.a7d0						z_asm_sty_z:
.a7d0						xt_asm_sty_zx:
.a7d0		a9 94		lda #$94	                lda #$94
.a7d2		80 38		bra $a80c	                bra asm_common
.a7d4						z_asm_sty_zx:
.a7d4						xt_asm_stz:
.a7d4		a9 9c		lda #$9c	                lda #$9C
.a7d6		80 34		bra $a80c	                bra asm_common
.a7d8						z_asm_stz:
.a7d8						xt_asm_stz_x:
.a7d8		a9 9e		lda #$9e	                lda #$9E
.a7da		80 30		bra $a80c	                bra asm_common
.a7dc						z_asm_stz_x:
.a7dc						xt_asm_stz_z:
.a7dc		a9 64		lda #$64	                lda #$64
.a7de		80 2c		bra $a80c	                bra asm_common
.a7e0						z_asm_stz_z:
.a7e0						xt_asm_stz_zx:
.a7e0		a9 74		lda #$74	                lda #$74
.a7e2		80 28		bra $a80c	                bra asm_common
.a7e4						z_asm_stz_zx:
.a7e4						xt_asm_tax:
.a7e4		a9 aa		lda #$aa	                lda #$AA
.a7e6		80 24		bra $a80c	                bra asm_common
.a7e8						z_asm_tax:
.a7e8						xt_asm_tay:
.a7e8		a9 a8		lda #$a8	                lda #$A8
.a7ea		80 20		bra $a80c	                bra asm_common
.a7ec						z_asm_tay:
.a7ec						xt_asm_trb:
.a7ec		a9 1c		lda #$1c	                lda #$1C
.a7ee		80 1c		bra $a80c	                bra asm_common
.a7f0						z_asm_trb:
.a7f0						xt_asm_trb_z:
.a7f0		a9 14		lda #$14	                lda #$14
.a7f2		80 18		bra $a80c	                bra asm_common
.a7f4						z_asm_trb_z:
.a7f4						xt_asm_tsb:
.a7f4		a9 0c		lda #$0c	                lda #$0C
.a7f6		80 14		bra $a80c	                bra asm_common
.a7f8						z_asm_tsb:
.a7f8						xt_asm_tsb_z:
.a7f8		a9 04		lda #$04	                lda #$04
.a7fa		80 10		bra $a80c	                bra asm_common
.a7fc						z_asm_tsb_z:
.a7fc						xt_asm_tsx:
.a7fc		a9 ba		lda #$ba	                lda #$BA
.a7fe		80 0c		bra $a80c	                bra asm_common
.a800						z_asm_tsx:
.a800						xt_asm_txa:
.a800		a9 8a		lda #$8a	                lda #$8A
.a802		80 08		bra $a80c	                bra asm_common
.a804						z_asm_txa:
.a804						xt_asm_txs:
.a804		a9 9a		lda #$9a	                lda #$9A
.a806		80 04		bra $a80c	                bra asm_common
.a808						z_asm_txs:
.a808						xt_asm_tya:
.a808		a9 98		lda #$98	                lda #$98
.a80a		80 00		bra $a80c	                bra asm_common
.a80c						z_asm_tya:
.a80c						asm_common:
.a80c		a8		tay		                tay
.a80d		20 c7 97	jsr $97c7	                jsr cmpl_a
.a810		a9 7f		lda #$7f	                lda #<oc_index_table
.a812		85 27		sta $27		                sta tmp2
.a814		a9 b4		lda #$b4	                lda #>oc_index_table
.a816		85 28		sta $28		                sta tmp2+1
.a818		98		tya		                tya             ; retrieve opcode
.a819		0a		asl a		                asl             ; times two for offset
.a81a		90 02		bcc $a81e	                bcc +
.a81c		e6 28		inc $28		                inc tmp2+1
.a81e						+
.a81e		a8		tay		                tay             ; use Y as the index
.a81f		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a821		85 29		sta $29		                sta tmp3
.a823		c8		iny		                iny
.a824		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a826		85 2a		sta $2a		                sta tmp3+1
.a828		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a82a		2a		rol a		                rol
.a82b		2a		rol a		                rol
.a82c		2a		rol a		                rol             ; Three times because we go through Carry
.a82d		29 03		and #$03	                and #%00000011
.a82f		a8		tay		                tay
.a830		88		dey		                dey
.a831		f0 12		beq $a845	                beq _done
.a833		20 82 d8	jsr $d882	                jsr underflow_1
.a836		b5 00		lda $00,x	                lda 0,x
.a838		20 c7 97	jsr $97c7	                jsr cmpl_a      ; does not use Y
.a83b		88		dey		                dey
.a83c		f0 05		beq $a843	                beq _done_drop
.a83e		b5 01		lda $01,x	                lda 1,x
.a840		20 c7 97	jsr $97c7	                jsr cmpl_a      ; Fall through to _done_drop
.a843						_done_drop:
.a843		e8		inx		                inx
.a844		e8		inx		                inx             ; Fall through to _done
.a845						_done:
.a845		60		rts		                rts             ; Returns to original caller
.a846						xt_asm_push_a:
.a846		a0 00		ldy #$00	                ldy #0
.a848						_loop:
.a848		b9 56 a8	lda $a856,y	                lda asm_push_a_data,y
.a84b		c9 ff		cmp #$ff	                cmp #$FF
.a84d		f0 06		beq $a855	                beq _done
.a84f		20 c7 97	jsr $97c7	                jsr cmpl_a      ; does not change Y
.a852		c8		iny		                iny
.a853		80 f3		bra $a848	                bra _loop
.a855						_done:
.a855						z_asm_push_a:
.a855		60		rts		                rts
.a856						asm_push_a_data:
>a856		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a85c		ff				        .byte $FF               ; terminator
.a85d						xt_asm_back_jump:
.a85d						z_asm_back_jump:
.a85d		60		rts		                rts
.a85e						xt_asm_back_branch:
.a85e		20 34 89	jsr $8934	                jsr w_here             ; ( addr-l addr-h )
.a861		20 12 8c	jsr $8c12	                jsr w_minus            ; ( offset )
.a864		3a		dec a		                dea
.a865		3a		dec a		                dea
.a866						z_asm_back_branch:
.a866		60		rts		                rts
.a867						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a867						xt_ed:
.a867						w_ed:
.a867		20 6b a8	jsr $a86b	                jsr ed6502      ; kept in separate file
.a86a		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a86b						ed6502:
.a86b		a5 18		lda $18		                lda base
.a86d		85 3a		sta $3a		                sta ed_base
.a86f		a9 0a		lda #$0a	                lda #10
.a871		85 18		sta $18		                sta base
.a873		64 35		stz $35		                stz ed_head
.a875		64 36		stz $36		                stz ed_head+1
.a877		64 37		stz $37		                stz ed_cur
.a879		64 38		stz $38		                stz ed_cur+1
.a87b		64 39		stz $39		                stz ed_flags
.a87d		20 39 9e	jsr $9e39	                jsr w_zero
.a880		20 39 9e	jsr $9e39	                jsr w_zero             ; ( addr-t u-t )
.a883		20 3a 84	jsr $843a	                jsr w_cr
.a886						ed_input_loop:
.a886		a9 81		lda #$81	                lda #%10000001
.a888		14 39		trb $39		                trb ed_flags
.a88a		20 65 ad	jsr $ad65	                jsr ed_get_input
.a88d		a5 0e		lda $0e		                lda ciblen
.a88f		d0 1f		bne $a8b0	                bne _command_mode
.a891		ca		dex		                dex
.a892		ca		dex		                dex                     ; ( addr-t u-t ? )
.a893		a5 37		lda $37		                lda ed_cur
.a895		95 00		sta $00,x	                sta 0,x
.a897		a5 38		lda $38		                lda ed_cur+1
.a899		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a89b		a9 80		lda #$80	                lda #%10000000
.a89d		04 39		tsb $39		                tsb ed_flags
.a89f		20 16 8d	jsr $8d16	                jsr w_one_plus         ; ( addr-t u-t u+1 )
.a8a2		20 81 ad	jsr $ad81	                jsr ed_is_valid_line
.a8a5		b0 03		bcs $a8aa	                bcs +
.a8a7		4c 55 ad	jmp $ad55	                jmp ed_error_1drop
.a8aa						+
.a8aa		20 39 9e	jsr $9e39	                jsr w_zero             ; ( addr-t u-t u+1 0 )
.a8ad		4c 7b a9	jmp $a97b	                jmp _line_number_only_from_external
.a8b0						_command_mode:
.a8b0		20 39 9e	jsr $9e39	                jsr w_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a8b3		20 39 9e	jsr $9e39	                jsr w_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a8b6		b2 0c		lda ($0c)	                lda (cib)
.a8b8		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a8ba		d0 3a		bne $a8f6	                bne _prefix_dollar
.a8bc		20 76 ad	jsr $ad76	                jsr ed_have_text
.a8bf		a5 37		lda $37		                lda ed_cur
.a8c1		95 02		sta $02,x	                sta 2,x
.a8c3		a5 38		lda $38		                lda ed_cur+1
.a8c5		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a8c7		a9 80		lda #$80	                lda #%10000000
.a8c9		04 39		tsb $39		                tsb ed_flags
.a8cb		a5 0e		lda $0e		                lda ciblen
.a8cd		3a		dec a		                dea                     ; sets Z if A was 1
.a8ce		d0 03		bne $a8d3	                bne +
.a8d0		4c 7b a9	jmp $a97b	                jmp _line_number_only_from_external
.a8d3						+
.a8d3		ca		dex		                dex
.a8d4		ca		dex		                dex
.a8d5		ca		dex		                dex
.a8d6		ca		dex		                dex
.a8d7		a5 0c		lda $0c		                lda cib
.a8d9		95 02		sta $02,x	                sta 2,x
.a8db		a5 0d		lda $0d		                lda cib+1
.a8dd		95 03		sta $03,x	                sta 3,x
.a8df		a5 0e		lda $0e		                lda ciblen
.a8e1		95 00		sta $00,x	                sta 0,x
.a8e3		a5 0f		lda $0f		                lda ciblen+1
.a8e5		95 01		sta $01,x	                sta 1,x
.a8e7		20 0a 8d	jsr $8d0a	                jsr w_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a8ea		20 5f 92	jsr $925f	                jsr w_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a8ed		20 16 8d	jsr $8d16	                jsr w_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a8f0		20 5f 92	jsr $925f	                jsr w_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a8f3		4c d3 a9	jmp $a9d3	                jmp _check_for_para2
.a8f6						_prefix_dollar:
.a8f6		b2 0c		lda ($0c)	                lda (cib)
.a8f8		c9 24		cmp #$24	                cmp #'$'
.a8fa		d0 1c		bne $a918	                bne _prefix_percent
.a8fc		20 76 ad	jsr $ad76	                jsr ed_have_text
.a8ff		e8		inx		                inx
.a900		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a901		20 a3 ad	jsr $ada3	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a904		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr-t u-t para1 0 )
.a907		a9 80		lda #$80	                lda #%10000000
.a909		04 39		tsb $39		                tsb ed_flags
.a90b		a5 0e		lda $0e		                lda ciblen
.a90d		3a		dec a		                dea                     ; sets Z if A was 1
.a90e		d0 03		bne $a913	                bne +
.a910		4c 7b a9	jmp $a97b	                jmp _line_number_only_from_external
.a913						+
.a913		a0 01		ldy #$01	                ldy #01
.a915		4c 4f aa	jmp $aa4f	                jmp _check_command
.a918						_prefix_percent:
.a918		b2 0c		lda ($0c)	                lda (cib)
.a91a		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a91c		f0 04		beq $a922	                beq _whole_text
.a91e		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a920		d0 17		bne $a939	                bne _prefix_semicolon
.a922						_whole_text:
.a922		20 76 ad	jsr $ad76	                jsr ed_have_text
.a925		a9 01		lda #$01	                lda #01
.a927		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a929		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a92b						_semicolon_entry:
.a92b		e8		inx		                inx
.a92c		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a92d		20 a3 ad	jsr $ada3	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a930		a9 80		lda #$80	                lda #%10000000
.a932		04 39		tsb $39		                tsb ed_flags
.a934		a0 01		ldy #$01	                ldy #01
.a936		4c 4f aa	jmp $aa4f	                jmp _check_command
.a939						_prefix_semicolon:
.a939		b2 0c		lda ($0c)	                lda (cib)
.a93b		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a93d		d0 0d		bne $a94c	                bne _prefix_number
.a93f		20 76 ad	jsr $ad76	                jsr ed_have_text
.a942		a5 37		lda $37		                lda ed_cur
.a944		95 02		sta $02,x	                sta 2,x
.a946		a5 38		lda $38		                lda ed_cur+1
.a948		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a94a		80 df		bra $a92b	                bra _semicolon_entry
.a94c						_prefix_number:
.a94c		20 39 9e	jsr $9e39	                jsr w_zero
.a94f		20 39 9e	jsr $9e39	                jsr w_zero             ; ( addr-t u-t 0 0 0 0 )
.a952		ca		dex		                dex
.a953		ca		dex		                dex
.a954		ca		dex		                dex
.a955		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a956		a5 0c		lda $0c		                lda cib
.a958		95 02		sta $02,x	                sta 2,x
.a95a		a5 0d		lda $0d		                lda cib+1
.a95c		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a95e		a5 0e		lda $0e		                lda ciblen
.a960		95 00		sta $00,x	                sta 0,x
.a962		a5 0f		lda $0f		                lda ciblen+1
.a964		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a966		20 fd 92	jsr $92fd	                jsr w_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a969		b5 00		lda $00,x	                lda 0,x
.a96b		15 01		ora $01,x	                ora 1,x
.a96d		d0 24		bne $a993	                bne _have_unconverted_chars
.a96f		e8		inx		                inx
.a970		e8		inx		                inx
.a971		e8		inx		                inx
.a972		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a973		20 85 9e	jsr $9e85	                jsr w_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a976		20 c0 9c	jsr $9cc0	                jsr w_not_rot          ; -ROT ( addr-t u-t u 0 0 )
.a979		e8		inx		                inx
.a97a		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a97b						_line_number_only_from_external:
.a97b		20 5f 92	jsr $925f	                jsr w_swap             ; ( addr-t u-t 0 u )
.a97e		20 81 ad	jsr $ad81	                jsr ed_is_valid_line
.a981		b0 03		bcs $a986	                bcs +
.a983		4c 53 ad	jmp $ad53	                jmp ed_error_2drop
.a986						+
.a986		20 5f 92	jsr $925f	                jsr w_swap             ; ( addr-t u-t u 0 )
.a989		20 10 ae	jsr $ae10	                jsr ed_para1_to_cur
.a98c		a9 80		lda #$80	                lda #%10000000
.a98e		04 39		tsb $39		                tsb ed_flags
.a990		4c 2e ac	jmp $ac2e	                jmp ed_cmd_p_from_external
.a993						_have_unconverted_chars:
.a993		20 a9 86	jsr $86a9	                jsr w_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a996		ca		dex		                dex
.a997		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a998		a5 0e		lda $0e		                lda ciblen
.a99a		95 00		sta $00,x	                sta 0,x
.a99c		a5 0f		lda $0f		                lda ciblen+1
.a99e		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a9a0		20 aa 87	jsr $87aa	                jsr w_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a9a3		b5 00		lda $00,x	                lda 0,x
.a9a5		15 01		ora $01,x	                ora 1,x
.a9a7		f0 0e		beq $a9b7	                beq _no_command_yet
.a9a9		8a		txa		                txa
.a9aa		18		clc		                clc
.a9ab		69 0a		adc #$0a	                adc #10
.a9ad		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a9ae		a9 80		lda #$80	                lda #%10000000
.a9b0		14 39		trb $39		                trb ed_flags
.a9b2		a0 00		ldy #$00	                ldy #00
.a9b4		4c 4f aa	jmp $aa4f	                jmp _check_command
.a9b7						_no_command_yet:
.a9b7		e8		inx		                inx
.a9b8		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a9b9		20 9a 93	jsr $939a	                jsr w_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a9bc		20 c0 9c	jsr $9cc0	                jsr w_not_rot          ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a9bf		20 85 9e	jsr $9e85	                jsr w_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a9c2		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a9c4		95 06		sta $06,x	                sta 6,x
.a9c6		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a9c8		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a9ca		e8		inx		                inx
.a9cb		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a9cc		20 18 8f	jsr $8f18	                jsr w_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a9cf		a9 80		lda #$80	                lda #%10000000
.a9d1		04 39		tsb $39		                tsb ed_flags
.a9d3						_check_for_para2:
.a9d3		a1 02		lda ($02,x)	                lda (2,x)
.a9d5		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a9d7		f0 0d		beq $a9e6	                beq _got_comma
.a9d9		38		sec		                sec
.a9da		a5 0e		lda $0e		                lda ciblen
.a9dc		f5 00		sbc $00,x	                sbc 0,x
.a9de		a8		tay		                tay
.a9df		e8		inx		                inx
.a9e0		e8		inx		                inx
.a9e1		e8		inx		                inx
.a9e2		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a9e3		4c 4f aa	jmp $aa4f	                jmp _check_command
.a9e6						_got_comma:
.a9e6		f6 02		inc $02,x	                inc 2,x
.a9e8		d0 02		bne $a9ec	                bne +
.a9ea		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a9ec						+
.a9ec		b5 01		lda $01,x	                lda 1,x
.a9ee		f0 02		beq $a9f2	                beq +
.a9f0		d6 01		dec $01,x	                dec 1,x
.a9f2						+
.a9f2		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a9f4		a1 02		lda ($02,x)	                lda (2,x)
.a9f6		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a9f8		d0 14		bne $aa0e	                bne _para2_not_dollar
.a9fa		38		sec		                sec
.a9fb		a5 0e		lda $0e		                lda ciblen
.a9fd		f5 02		sbc $02,x	                sbc 2,x
.a9ff		a8		tay		                tay
.aa00		c8		iny		                iny
.aa01		5a		phy		                phy
.aa02		8a		txa		                txa
.aa03		18		clc		                clc
.aa04		69 06		adc #$06	                adc #06
.aa06		aa		tax		                tax                     ; ( addr-t u-t para1 )
.aa07		20 a3 ad	jsr $ada3	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.aa0a		7a		ply		                ply
.aa0b		4c 4f aa	jmp $aa4f	                jmp _check_command
.aa0e						_para2_not_dollar:
.aa0e		20 9a 93	jsr $939a	                jsr w_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.aa11		20 39 9e	jsr $9e39	                jsr w_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.aa14		20 39 9e	jsr $9e39	                jsr w_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.aa17		20 bb 8f	jsr $8fbb	                jsr w_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.aa1a		20 18 8f	jsr $8f18	                jsr w_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.aa1d		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.aa20		20 9a 93	jsr $939a	                jsr w_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.aa23		20 fd 92	jsr $92fd	                jsr w_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.aa26		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.aa29		20 18 8f	jsr $8f18	                jsr w_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.aa2c		20 aa 87	jsr $87aa	                jsr w_equal            ; = ( ... para1 0 ud addr3 u3 f )
.aa2f		b5 00		lda $00,x	                lda 0,x
.aa31		15 01		ora $01,x	                ora 1,x
.aa33		f0 08		beq $aa3d	                beq _second_number
.aa35		8a		txa		                txa
.aa36		18		clc		                clc
.aa37		69 0c		adc #$0c	                adc #12
.aa39		aa		tax		                tax                     ; back to ( addr-t u-t )
.aa3a		4c 57 ad	jmp $ad57	                jmp ed_error
.aa3d						_second_number:
.aa3d		e8		inx		                inx
.aa3e		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.aa3f		38		sec		                sec
.aa40		a5 0e		lda $0e		                lda ciblen
.aa42		f5 00		sbc $00,x	                sbc 0,x
.aa44		48		pha		                pha
.aa45		20 d4 93	jsr $93d4	                jsr w_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.aa48		20 85 9e	jsr $9e85	                jsr w_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.aa4b		20 61 8c	jsr $8c61	                jsr w_nip              ; NIP ( addr-t u-t para1 para2 )
.aa4e		7a		ply		                ply
.aa4f						_check_command:
.aa4f		24 39		bit $39		                bit ed_flags
.aa51		30 08		bmi $aa5b	                bmi _check_command_have_arg
.aa53		a5 37		lda $37		                lda ed_cur
.aa55		95 02		sta $02,x	                sta 2,x
.aa57		a5 38		lda $38		                lda ed_cur+1
.aa59		95 03		sta $03,x	                sta 3,x
.aa5b						_check_command_have_arg:
.aa5b		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.aa5d		85 25		sta $25		                sta tmp1
.aa5f		da		phx		                phx
.aa60		a2 00		ldx #$00	                ldx #00
.aa62						_cmd_loop:
.aa62		bd 3b ae	lda $ae3b,x	                lda ed_cmd_list,x
.aa65		f0 07		beq $aa6e	                beq _illegal_command    ; zero marks end of list
.aa67		c5 25		cmp $25		                cmp tmp1
.aa69		f0 07		beq $aa72	                beq _found_cmd
.aa6b		e8		inx		                inx
.aa6c		80 f4		bra $aa62	                bra _cmd_loop
.aa6e						_illegal_command:
.aa6e		fa		plx		                plx
.aa6f		4c 53 ad	jmp $ad53	                jmp ed_error_2drop
.aa72						_found_cmd:
.aa72		8a		txa		                txa
.aa73		0a		asl a		                asl
.aa74		aa		tax		                tax                     ; X * 2 for table
.aa75		7c 46 ae	jmp ($ae46,x)	                jmp (ed_cmd_table,x)
.aa78						ed_next_command:
.aa78		e8		inx		                inx
.aa79		e8		inx		                inx
.aa7a		e8		inx		                inx
.aa7b		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.aa7c		4c 86 a8	jmp $a886	                jmp ed_input_loop
.aa7f						ed_all_done:
.aa7f		64 0e		stz $0e		                stz ciblen
.aa81		64 0f		stz $0f		                stz ciblen+1
.aa83		20 d4 93	jsr $93d4	                jsr w_two_drop                 ; 2DROP ( addr-t u-t )
.aa86		a5 3a		lda $3a		                lda ed_base
.aa88		85 18		sta $18		                sta base
.aa8a		60		rts		                rts
.aa8b						ed_cmd_a:
.aa8b		fa		plx		                plx
.aa8c		e8		inx		                inx
.aa8d		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.aa8e						ed_entry_cmd_i:
.aa8e		20 d9 ad	jsr $add9	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.aa91		20 3a 84	jsr $843a	                jsr w_cr
.aa94						_next_string_loop:
.aa94		20 65 ad	jsr $ad65	                jsr ed_get_input
.aa97		b2 0c		lda ($0c)	                lda (cib)
.aa99		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.aa9b		d0 16		bne $aab3	                bne _add_line
.aa9d		a4 0e		ldy $0e		                ldy ciblen
.aa9f		c0 01		cpy #$01	                cpy #01
.aaa1		d0 10		bne $aab3	                bne _add_line
.aaa3		a4 0f		ldy $0f		                ldy ciblen+1
.aaa5		d0 0c		bne $aab3	                bne _add_line
.aaa7		e8		inx		                inx
.aaa8		e8		inx		                inx
.aaa9		a9 40		lda #$40	                lda #%01000000
.aaab		04 39		tsb $39		                tsb ed_flags
.aaad		20 3a 84	jsr $843a	                jsr w_cr
.aab0		4c 86 a8	jmp $a886	                jmp ed_input_loop
.aab3						_add_line:
.aab3		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( addr-t u-t addr1 addr1 )
.aab6		20 34 89	jsr $8934	                jsr w_here             ; HERE ( addr-t u-t addr1 addr1 here )
.aab9		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.aabc		20 36 88	jsr $8836	                jsr w_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.aabf		20 d0 83	jsr $83d0	                jsr w_comma            ; ,  ( addr-t u-t addr1 here )
.aac2		20 ba 93	jsr $93ba	                jsr w_tuck             ; TUCK ( addr-t u-t here addr1 here )
.aac5		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr-t u-t here here addr1 )
.aac8		20 49 92	jsr $9249	                jsr w_store            ; ! ( addr-t u-t here )
.aacb		20 34 89	jsr $8934	                jsr w_here             ; HERE ( addr-t u-t here here2)
.aace		a5 00		lda $00		                lda cp
.aad0		18		clc		                clc
.aad1		69 04		adc #$04	                adc #04
.aad3		85 00		sta $00		                sta cp
.aad5		90 02		bcc $aad9	                bcc +
.aad7		e6 01		inc $01		                inc cp+1
.aad9						+
.aad9		e6 37		inc $37		                inc ed_cur
.aadb		d0 02		bne $aadf	                bne +
.aadd		e6 38		inc $38		                inc ed_cur+1
.aadf						+
.aadf		20 34 89	jsr $8934	                jsr w_here     ; HERE ( addr-t u-t here here2 here3 )
.aae2		20 a9 86	jsr $86a9	                jsr w_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.aae5		ca		dex		                dex
.aae6		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.aae7		a5 0c		lda $0c		                lda cib
.aae9		95 00		sta $00,x	                sta 0,x
.aaeb		a5 0d		lda $0d		                lda cib+1
.aaed		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aaef		20 5f 92	jsr $925f	                jsr w_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aaf2		ca		dex		                dex
.aaf3		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aaf4		a5 0e		lda $0e		                lda ciblen
.aaf6		95 00		sta $00,x	                sta 0,x
.aaf8		a5 0f		lda $0f		                lda ciblen+1
.aafa		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aafc		20 2e 8c	jsr $8c2e	                jsr w_move     ; ( addr-t u-t here here2 here3 )
.aaff		18		clc		                clc
.ab00		a5 00		lda $00		                lda cp
.ab02		65 0e		adc $0e		                adc ciblen
.ab04		85 00		sta $00		                sta cp
.ab06		90 06		bcc $ab0e	                bcc +
.ab08		a5 01		lda $01		                lda cp+1
.ab0a		65 0f		adc $0f		                adc ciblen+1
.ab0c		85 01		sta $01		                sta cp+1
.ab0e						+
.ab0e		20 32 8d	jsr $8d32	                jsr w_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.ab11		20 49 92	jsr $9249	                jsr w_store            ; ! ( addr-t u-t here here2 )
.ab14		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+
.ab17		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.ab1a		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.ab1d		a5 0e		lda $0e		                lda ciblen
.ab1f		95 02		sta $02,x	                sta 2,x
.ab21		a5 0f		lda $0f		                lda ciblen+1
.ab23		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.ab25		20 49 92	jsr $9249	                jsr w_store            ; ! ( addr-t u-t here )
.ab28		20 3a 84	jsr $843a	                jsr w_cr
.ab2b		4c 94 aa	jmp $aa94	                jmp _next_string_loop
.ab2e						ed_cmd_d:
.ab2e		fa		plx		                plx
.ab2f		20 76 ad	jsr $ad76	                jsr ed_have_text
.ab32		20 cb ad	jsr $adcb	                jsr ed_no_line_zero
.ab35		b5 00		lda $00,x	                lda 0,x
.ab37		15 01		ora $01,x	                ora 1,x
.ab39		d0 08		bne $ab43	                bne +
.ab3b		20 32 8d	jsr $8d32	                jsr w_over             ; ( addr-t u-t para1 0 para1 )
.ab3e		20 80 ab	jsr $ab80	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.ab41		80 33		bra $ab76	                bra _cmd_d_done
.ab43						+
.ab43		20 81 ad	jsr $ad81	                jsr ed_is_valid_line      ; result is in C flag
.ab46		b0 03		bcs $ab4b	                bcs _cmd_d_loop
.ab48		4c 53 ad	jmp $ad53	                jmp ed_error_2drop
.ab4b						_cmd_d_loop:
.ab4b		20 dc 93	jsr $93dc	                jsr w_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab4e		20 22 89	jsr $8922	                jsr w_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab51		b5 00		lda $00,x	                lda 0,x
.ab53		15 01		ora $01,x	                ora 1,x
.ab55		d0 0d		bne $ab64	                bne _cmd_d_done_with_flag
.ab57		e8		inx		                inx
.ab58		e8		inx		                inx                     ; Get rid of the flag from >
.ab59		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.ab5c		20 80 ab	jsr $ab80	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.ab5f		20 0a 8d	jsr $8d0a	                jsr w_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.ab62		80 e7		bra $ab4b	                bra _cmd_d_loop
.ab64						_cmd_d_done_with_flag:
.ab64		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.ab65		e8		inx		                inx
.ab66		b5 02		lda $02,x	                lda 2,x
.ab68		d0 02		bne $ab6c	                bne +
.ab6a		d6 03		dec $03,x	                dec 3,x
.ab6c						+
.ab6c		d6 02		dec $02,x	                dec 2,x
.ab6e		b5 02		lda $02,x	                lda 2,x
.ab70		85 37		sta $37		                sta ed_cur
.ab72		b5 03		lda $03,x	                lda 3,x
.ab74		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.ab76						_cmd_d_done:
.ab76		a9 40		lda #$40	                lda #%01000000
.ab78		04 39		tsb $39		                tsb ed_flags
.ab7a		20 3a 84	jsr $843a	                jsr w_cr
.ab7d		4c 78 aa	jmp $aa78	                jmp ed_next_command
.ab80						_cmd_d_common:
.ab80		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( addr-t u-t u u )
.ab83		20 d9 ad	jsr $add9	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.ab86		20 36 88	jsr $8836	                jsr w_fetch            ; @ ( addr-t u-t u addr1 )
.ab89		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr-t u-t addr1 u )
.ab8c		20 0a 8d	jsr $8d0a	                jsr w_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.ab8f		20 d9 ad	jsr $add9	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.ab92		20 49 92	jsr $9249	                jsr w_store            ; ! ( addr-t u-t )
.ab95		60		rts		                rts
.ab96						ed_cmd_equ:
.ab96		fa		plx		                plx
.ab97		a5 35		lda $35		                lda ed_head
.ab99		05 36		ora $36		                ora ed_head+1
.ab9b		d0 08		bne $aba5	                bne _cmd_equ_have_text
.ab9d		ca		dex		                dex
.ab9e		ca		dex		                dex
.ab9f		74 00		stz $00,x	                stz 0,x
.aba1		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.aba3		80 21		bra $abc6	                bra _cmd_equ_done
.aba5						_cmd_equ_have_text:
.aba5		20 cb ad	jsr $adcb	                jsr ed_no_line_zero
.aba8		24 39		bit $39		                bit ed_flags
.abaa		30 0c		bmi $abb8	                bmi _cmd_equ_have_para
.abac		ca		dex		                dex
.abad		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.abae		a5 37		lda $37		                lda ed_cur
.abb0		95 00		sta $00,x	                sta 0,x
.abb2		a5 38		lda $38		                lda ed_cur+1
.abb4		95 01		sta $01,x	                sta 1,x
.abb6		80 0e		bra $abc6	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.abb8						_cmd_equ_have_para:
.abb8		b5 00		lda $00,x	                lda 0,x
.abba		15 01		ora $01,x	                ora 1,x
.abbc		d0 05		bne $abc3	                bne _cmd_equ_two_paras
.abbe		20 32 8d	jsr $8d32	                jsr w_over             ; ( addr-t u-t para1 para2 para1)
.abc1		80 03		bra $abc6	                bra _cmd_equ_done
.abc3						_cmd_equ_two_paras:
.abc3		20 a9 86	jsr $86a9	                jsr w_dup              ; ( addr-t u-t para1 para2 para2) drop through
.abc6						_cmd_equ_done:
.abc6		20 3a 84	jsr $843a	                jsr w_cr               ; number goes on new line
.abc9		20 11 95	jsr $9511	                jsr w_u_dot            ; ( addr-t u-t para1 para2 )
.abcc		20 3a 84	jsr $843a	                jsr w_cr
.abcf		4c 78 aa	jmp $aa78	                jmp ed_next_command
.abd2						ed_cmd_f:
.abd2		fa		plx		                plx
.abd3		24 39		bit $39		                bit ed_flags
.abd5		30 17		bmi $abee	                bmi _cmd_f_have_para
.abd7		20 3a 84	jsr $843a	                jsr w_cr
.abda		20 9a 93	jsr $939a	                jsr w_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.abdd		20 bb 8f	jsr $8fbb	                jsr w_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.abe0		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.abe3		20 11 95	jsr $9511	                jsr w_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.abe6		20 c0 9c	jsr $9cc0	                jsr w_not_rot          ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.abe9		20 18 8f	jsr $8f18	                jsr w_r_from           ; R>   ( addr-t u-t 0 0 )
.abec		80 11		bra $abff	                bra _cmd_f_done
.abee						_cmd_f_have_para:
.abee		20 32 8d	jsr $8d32	                jsr w_over
.abf1		20 3a 84	jsr $843a	                jsr w_cr
.abf4		20 11 95	jsr $9511	                jsr w_u_dot
.abf7		b5 02		lda $02,x	                lda 2,x
.abf9		95 06		sta $06,x	                sta 6,x
.abfb		b5 03		lda $03,x	                lda 3,x
.abfd		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.abff						_cmd_f_done:
.abff		20 3a 84	jsr $843a	                jsr w_cr
.ac02		4c 78 aa	jmp $aa78	                jmp ed_next_command
.ac05						ed_cmd_i:
.ac05		fa		plx		                plx
.ac06		e8		inx		                inx
.ac07		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.ac08		24 39		bit $39		                bit ed_flags
.ac0a		30 08		bmi $ac14	                bmi _cmd_i_have_para
.ac0c		a5 37		lda $37		                lda ed_cur
.ac0e		95 00		sta $00,x	                sta 0,x
.ac10		a5 38		lda $38		                lda ed_cur+1
.ac12		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.ac14						_cmd_i_have_para:
.ac14		b5 00		lda $00,x	                lda 0,x
.ac16		15 01		ora $01,x	                ora 1,x
.ac18		f0 09		beq $ac23	                beq _cmd_i_done
.ac1a		20 0a 8d	jsr $8d0a	                jsr w_one_minus        ; 1-  ( addr-t u-t para1-1 )
.ac1d		20 39 9e	jsr $9e39	                jsr w_zero             ; 0   ( addr-t u-t para1-1 0 )
.ac20		20 da 8b	jsr $8bda	                jsr w_max              ; MAX ( addr-t u-t para1-1 | 0 )
.ac23						_cmd_i_done:
.ac23		4c 8e aa	jmp $aa8e	                jmp ed_entry_cmd_i
.ac26						ed_cmd_n:
.ac26		fa		plx		                plx
.ac27		a9 01		lda #$01	                lda #%00000001
.ac29		04 39		tsb $39		                tsb ed_flags
.ac2b		80 05		bra $ac32	                bra ed_cmd_p_entry_for_cmd_n
.ac2d						ed_cmd_p:
.ac2d		fa		plx		                plx
.ac2e						ed_cmd_p_from_external:
.ac2e		a9 01		lda #$01	                lda #%00000001
.ac30		14 39		trb $39		                trb ed_flags
.ac32						ed_cmd_p_entry_for_cmd_n:
.ac32		20 76 ad	jsr $ad76	                jsr ed_have_text
.ac35		20 cb ad	jsr $adcb	                jsr ed_no_line_zero
.ac38		20 3a 84	jsr $843a	                jsr w_cr
.ac3b		b5 00		lda $00,x	                lda 0,x
.ac3d		15 01		ora $01,x	                ora 1,x
.ac3f		d0 10		bne $ac51	                bne _cmd_p_loop
.ac41		b5 02		lda $02,x	                lda 2,x
.ac43		85 37		sta $37		                sta ed_cur
.ac45		b5 03		lda $03,x	                lda 3,x
.ac47		85 38		sta $38		                sta ed_cur+1
.ac49		20 32 8d	jsr $8d32	                jsr w_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ac4c		20 7a ac	jsr $ac7a	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac4f		80 26		bra $ac77	                bra _cmd_p_all_done
.ac51						_cmd_p_loop:
.ac51		20 dc 93	jsr $93dc	                jsr w_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ac54		20 22 89	jsr $8922	                jsr w_greater_than     ; > ( addr-t u-t para1 para2 f )
.ac57		b5 00		lda $00,x	                lda 0,x
.ac59		15 01		ora $01,x	                ora 1,x
.ac5b		d0 10		bne $ac6d	                bne _cmd_p_done
.ac5d		e8		inx		                inx
.ac5e		e8		inx		                inx                     ; Get rid of the flag from >
.ac5f		20 32 8d	jsr $8d32	                jsr w_over             ; ( addr-t u-t para1 para2 para1 )
.ac62		20 7a ac	jsr $ac7a	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac65		f6 02		inc $02,x	                inc 2,x
.ac67		d0 02		bne $ac6b	                bne +
.ac69		f6 03		inc $03,x	                inc 3,x
.ac6b						+
.ac6b		80 e4		bra $ac51	                bra _cmd_p_loop
.ac6d						_cmd_p_done:
.ac6d		e8		inx		                inx
.ac6e		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ac6f		b5 00		lda $00,x	                lda 0,x
.ac71		85 37		sta $37		                sta ed_cur
.ac73		b5 01		lda $01,x	                lda 1,x
.ac75		85 38		sta $38		                sta ed_cur+1
.ac77						_cmd_p_all_done:
.ac77		4c 78 aa	jmp $aa78	                jmp ed_next_command
.ac7a						_cmd_p_common:
.ac7a		a5 39		lda $39		                lda ed_flags
.ac7c		4a		lsr a		                lsr                     ; bit 0 now in carry
.ac7d		90 0b		bcc $ac8a	                bcc _cmd_p_common_no_num
.ac7f		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( addr-t u-t para1 para1 )
.ac82		20 11 95	jsr $9511	                jsr w_u_dot            ; U. ( addr-t u-t para1 )
.ac85		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ac87		20 d3 86	jsr $86d3	                jsr emit_a
.ac8a						_cmd_p_common_no_num:
.ac8a		20 d9 ad	jsr $add9	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.ac8d		20 19 ae	jsr $ae19	                jsr ed_print_addr
.ac90		60		rts		                rts
.ac91						ed_cmd_q:
.ac91		fa		plx		                plx
.ac92		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.ac94		50 03		bvc $ac99	                bvc +
.ac96		4c 53 ad	jmp $ad53	                jmp ed_error_2drop
.ac99						+
.ac99		4c 7f aa	jmp $aa7f	                jmp ed_all_done            ; can't fall thru because of PLX
.ac9c						ed_cmd_qq:
.ac9c		fa		plx		                plx
.ac9d		4c 7f aa	jmp $aa7f	                jmp ed_all_done
.aca0						ed_cmd_w:
.aca0		fa		plx		                plx
.aca1		20 76 ad	jsr $ad76	                jsr ed_have_text
.aca4		24 39		bit $39		                bit ed_flags
.aca6		30 13		bmi $acbb	                bmi _cmd_w_have_para
.aca8		b5 06		lda $06,x	                lda 6,x
.acaa		15 07		ora $07,x	                ora 7,x
.acac		d0 03		bne $acb1	                bne +
.acae		4c 53 ad	jmp $ad53	                jmp ed_error_2drop
.acb1						+
.acb1		b5 06		lda $06,x	                lda 6,x
.acb3		95 02		sta $02,x	                sta 2,x
.acb5		b5 07		lda $07,x	                lda 7,x
.acb7		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.acb9		80 08		bra $acc3	                bra _cmd_w_para_ready
.acbb						_cmd_w_have_para:
.acbb		b5 02		lda $02,x	                lda 2,x
.acbd		95 06		sta $06,x	                sta 6,x
.acbf		b5 03		lda $03,x	                lda 3,x
.acc1		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.acc3						_cmd_w_para_ready:
.acc3		a9 35		lda #$35	                lda #<ed_head
.acc5		95 00		sta $00,x	                sta 0,x
.acc7		a9 00		lda #$00	                lda #>ed_head
.acc9		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.accb		20 32 8d	jsr $8d32	                jsr w_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.acce		20 9a 93	jsr $939a	                jsr w_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.acd1						_cmd_w_loop:
.acd1		20 36 88	jsr $8836	                jsr w_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.acd4		b5 00		lda $00,x	                lda 0,x
.acd6		15 01		ora $01,x	                ora 1,x
.acd8		f0 55		beq $ad2f	                beq _cmd_w_eol
.acda		20 dc 93	jsr $93dc	                jsr w_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.acdd		20 c3 94	jsr $94c3	                jsr w_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ace0		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ace3		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ace6		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ace9		20 36 88	jsr $8836	                jsr w_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.acec		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.acef		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.acf2		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.acf5		20 36 88	jsr $8836	                jsr w_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.acf8		20 c0 9c	jsr $9cc0	                jsr w_not_rot          ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.acfb		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.acfe		20 bb 8f	jsr $8fbb	                jsr w_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ad01		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ad04		20 9a 93	jsr $939a	                jsr w_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ad07		20 2e 8c	jsr $8c2e	                jsr w_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ad0a		20 18 8f	jsr $8f18	                jsr w_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ad0d		20 49 94	jsr $9449	                jsr w_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ad10		20 c0 9c	jsr $9cc0	                jsr w_not_rot          ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ad13		20 80 8e	jsr $8e80	                jsr w_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ad16		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ad19		ca		dex		                dex
.ad1a		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ad1b		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ad1d		95 00		sta $00,x	                sta 0,x
.ad1f		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ad21		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ad24		20 49 92	jsr $9249	                jsr w_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ad27		20 16 8d	jsr $8d16	                jsr w_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ad2a		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ad2d		80 a2		bra $acd1	                bra _cmd_w_loop
.ad2f						_cmd_w_eol:
.ad2f		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ad32		20 18 8f	jsr $8f18	                jsr w_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ad35		20 12 8c	jsr $8c12	                jsr w_minus            ; - ( addr-t u-t addr-n u )
.ad38		b5 00		lda $00,x	                lda 0,x
.ad3a		95 04		sta $04,x	                sta 4,x
.ad3c		b5 01		lda $01,x	                lda 1,x
.ad3e		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ad40		20 3a 84	jsr $843a	                jsr w_cr
.ad43		20 a9 86	jsr $86a9	                jsr w_dup              ; DUP ( addr-t u addr-n u u )
.ad46		20 11 95	jsr $9511	                jsr w_u_dot            ; U. ( addr-t u addr-n u )
.ad49		20 3a 84	jsr $843a	                jsr w_cr
.ad4c		a9 40		lda #$40	                lda #%01000000
.ad4e		14 39		trb $39		                trb ed_flags
.ad50		4c 78 aa	jmp $aa78	                jmp ed_next_command
.ad53						ed_error_2drop:
.ad53		e8		inx		                inx
.ad54		e8		inx		                inx                     ; drop through to _error_1drop
.ad55						ed_error_1drop:
.ad55		e8		inx		                inx
.ad56		e8		inx		                inx                     ; drop through to _error
.ad57						ed_error:
.ad57		20 3a 84	jsr $843a	                jsr w_cr
.ad5a		a9 3f		lda #$3f	                lda #'?'
.ad5c		20 d3 86	jsr $86d3	                jsr emit_a
.ad5f		20 3a 84	jsr $843a	                jsr w_cr
.ad62		4c 86 a8	jmp $a886	                jmp ed_input_loop
.ad65						ed_get_input:
.ad65		20 66 8f	jsr $8f66	                jsr w_refill           ;  ( addr-t u-t f )
.ad68		b5 00		lda $00,x	                lda 0,x
.ad6a		15 01		ora $01,x	                ora 1,x
.ad6c		d0 05		bne $ad73	                bne +
.ad6e		7a		ply		                ply
.ad6f		7a		ply		                ply
.ad70		4c 55 ad	jmp $ad55	                jmp ed_error_1drop
.ad73						+
.ad73		e8		inx		                inx
.ad74		e8		inx		                inx
.ad75		60		rts		                rts
.ad76						ed_have_text:
.ad76		a5 35		lda $35		                lda ed_head
.ad78		05 36		ora $36		                ora ed_head+1
.ad7a		d0 04		bne $ad80	                bne +
.ad7c		7a		ply		                ply
.ad7d		7a		ply		                ply
.ad7e		80 d7		bra $ad57	                bra ed_error
.ad80						+
.ad80		60		rts		                rts
.ad81						ed_is_valid_line:
.ad81		38		sec		                sec                             ; default is legal line number
.ad82		b5 00		lda $00,x	                lda 0,x
.ad84		15 01		ora $01,x	                ora 1,x
.ad86		f0 19		beq $ada1	                beq _is_valid_line_nope_zero    ; ( n )
.ad88		20 a9 86	jsr $86a9	                jsr w_dup                      ; DUP ( n n )
.ad8b		20 a3 ad	jsr $ada3	                jsr ed_last_line                  ; ( n n last )
.ad8e		20 5f 92	jsr $925f	                jsr w_swap                     ; SWAP ( n last n )
.ad91		20 0b 8a	jsr $8a0b	                jsr w_less_than                ; < ( n f )
.ad94		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ad96		15 01		ora $01,x	                ora 1,x
.ad98		d0 05		bne $ad9f	                bne _is_valid_line_too_small
.ad9a		e8		inx		                inx
.ad9b		e8		inx		                inx                     ; DROP flag ( n )
.ad9c		38		sec		                sec                     ; Who knows what's happened to C by now
.ad9d		80 03		bra $ada2	                bra _is_valid_line_done ; only one exit from this routine
.ad9f						_is_valid_line_too_small:
.ad9f		e8		inx		                inx
.ada0		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ada1						_is_valid_line_nope_zero:
.ada1		18		clc		                clc                     ; drop through to _is_valid_line_done
.ada2						_is_valid_line_done:
.ada2		60		rts		                rts
.ada3						ed_last_line:
.ada3		64 25		stz $25		                stz tmp1
.ada5		64 26		stz $26		                stz tmp1+1
.ada7		ca		dex		                dex
.ada8		ca		dex		                dex                     ; ( ? )
.ada9		a9 35		lda #$35	                lda #<ed_head
.adab		95 00		sta $00,x	                sta 0,x
.adad		a9 00		lda #$00	                lda #>ed_head
.adaf		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.adb1						_last_line_loop:
.adb1		20 36 88	jsr $8836	                jsr w_fetch            ; ( addr | 0 )
.adb4		b5 00		lda $00,x	                lda 0,x
.adb6		15 01		ora $01,x	                ora 1,x
.adb8		f0 08		beq $adc2	                beq _last_line_done
.adba		e6 25		inc $25		                inc tmp1
.adbc		d0 02		bne $adc0	                bne +
.adbe		e6 26		inc $26		                inc tmp1+1
.adc0						+
.adc0		80 ef		bra $adb1	                bra _last_line_loop
.adc2						_last_line_done:
.adc2		a5 25		lda $25		                lda tmp1
.adc4		95 00		sta $00,x	                sta 0,x
.adc6		a5 26		lda $26		                lda tmp1+1
.adc8		95 01		sta $01,x	                sta 1,x                 ; ( u )
.adca		60		rts		                rts
.adcb						ed_no_line_zero:
.adcb		b5 02		lda $02,x	                lda 2,x
.adcd		15 03		ora $03,x	                ora 3,x
.adcf		d0 07		bne $add8	                bne _no_line_zero_done
.add1		24 39		bit $39		                bit ed_flags
.add3		10 03		bpl $add8	                bpl _no_line_zero_done
.add5		4c 53 ad	jmp $ad53	                jmp ed_error_2drop
.add8						_no_line_zero_done:
.add8		60		rts		                rts
.add9						ed_num_to_addr:
.add9		ca		dex		                dex
.adda		ca		dex		                dex                     ; ( u ? )
.addb		a9 35		lda #$35	                lda #<ed_head
.addd		95 00		sta $00,x	                sta 0,x
.addf		a9 00		lda #$00	                lda #>ed_head
.ade1		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.ade3		b5 02		lda $02,x	                lda 2,x
.ade5		15 03		ora $03,x	                ora 3,x
.ade7		d0 05		bne $adee	                bne _num_to_addr_loop
.ade9		20 61 8c	jsr $8c61	                jsr w_nip              ; ( addr-h )
.adec		80 21		bra $ae0f	                bra _num_to_addr_done
.adee						_num_to_addr_loop:
.adee		20 36 88	jsr $8836	                jsr w_fetch            ; @ ( u addr1 )
.adf1		b5 00		lda $00,x	                lda 0,x
.adf3		15 01		ora $01,x	                ora 1,x
.adf5		d0 05		bne $adfc	                bne +
.adf7		20 61 8c	jsr $8c61	                jsr w_nip              ; NIP ( addr1 )
.adfa		80 13		bra $ae0f	                bra _num_to_addr_done
.adfc						+
.adfc		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( addr1 u )
.adff		20 0a 8d	jsr $8d0a	                jsr w_one_minus        ; 1- ( addr1 u-1 )
.ae02		b5 00		lda $00,x	                lda 0,x
.ae04		15 01		ora $01,x	                ora 1,x
.ae06		f0 05		beq $ae0d	                beq _num_to_addr_finished
.ae08		20 5f 92	jsr $925f	                jsr w_swap             ; SWAP ( u-1 addr1 )
.ae0b		80 e1		bra $adee	                bra _num_to_addr_loop
.ae0d						_num_to_addr_finished:
.ae0d		e8		inx		                inx
.ae0e		e8		inx		                inx                     ; ( addr )
.ae0f						_num_to_addr_done:
.ae0f		60		rts		                rts
.ae10						ed_para1_to_cur:
.ae10		b5 02		lda $02,x	                lda 2,x
.ae12		85 37		sta $37		                sta ed_cur
.ae14		b5 03		lda $03,x	                lda 3,x
.ae16		85 38		sta $38		                sta ed_cur+1
.ae18		60		rts		                rts
.ae19						ed_print_addr:
.ae19		20 16 8d	jsr $8d16	                jsr w_one_plus
.ae1c		20 16 8d	jsr $8d16	                jsr w_one_plus         ; ( addr+2 )
.ae1f		20 a9 86	jsr $86a9	                jsr w_dup              ; ( addr+2 addr+2 )
.ae22		20 16 8d	jsr $8d16	                jsr w_one_plus
.ae25		20 16 8d	jsr $8d16	                jsr w_one_plus         ; ( addr+2 addr+4 )
.ae28		20 36 88	jsr $8836	                jsr w_fetch            ; ( addr+2 u-s )
.ae2b		20 5f 92	jsr $925f	                jsr w_swap             ; ( u-s addr+2 )
.ae2e		20 36 88	jsr $8836	                jsr w_fetch            ; ( u-s addr-s )
.ae31		20 5f 92	jsr $925f	                jsr w_swap             ; ( addr-s u-s )
.ae34		20 e6 94	jsr $94e6	                jsr w_type
.ae37		20 3a 84	jsr $843a	                jsr w_cr
.ae3a		60		rts		                rts
>ae3b		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ae43		71 51 00
.ae46						ed_cmd_table:
>ae46		8b aa d2 ab 05 ac 2e ab		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ae4e		2d ac 26 ac
>ae52		96 ab a0 ac 91 ac 9c ac		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ae5a						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ae5a						xt_blk:
.ae5a						w_blk:
.ae5a		a9 04		lda #$04	                lda #blk_offset
.ae5c		4c 3e d7	jmp $d73e	                jmp push_upvar_tos
.ae5f						z_blk:
.ae5f						xt_blkbuffer:
.ae5f						w_blkbuffer:
.ae5f		ca		dex		                dex
.ae60		ca		dex		                dex
.ae61		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ae63		b1 08		lda ($08),y	                lda (up),y
.ae65		95 00		sta $00,x	                sta 0,x
.ae67		c8		iny		                iny             ; Move along to the next byte
.ae68		b1 08		lda ($08),y	                lda (up),y
.ae6a		95 01		sta $01,x	                sta 1,x
.ae6c		60		rts		z_blkbuffer:    rts
.ae6d						xt_block:
.ae6d						w_block:
.ae6d		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae6f		b1 08		lda ($08),y	                lda (up),y
.ae71		d5 00		cmp $00,x	                cmp 0,x
.ae73		d0 0f		bne $ae84	                bne _not_in_buffer
.ae75		c8		iny		                iny
.ae76		b1 08		lda ($08),y	                lda (up),y
.ae78		d5 01		cmp $01,x	                cmp 1,x
.ae7a		d0 08		bne $ae84	                bne _not_in_buffer
.ae7c		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae7e		b1 08		lda ($08),y	                lda (up),y
.ae80		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ae82		d0 30		bne $aeb4	                bne _done       ; It's already in the buffer and in use.
.ae84						_not_in_buffer:
.ae84		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae86		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ae88		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ae8a		d0 0c		bne $ae98	                bne _buffer_available ; Unused or not dirty = available
.ae8c		20 5f ae	jsr $ae5f	                jsr w_blkbuffer
.ae8f		20 69 b0	jsr $b069	                jsr w_buffblocknum
.ae92		20 36 88	jsr $8836	                jsr w_fetch
.ae95		20 56 b0	jsr $b056	                jsr w_block_write
.ae98						_buffer_available:
.ae98		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae9a		b5 00		lda $00,x	                lda 0,x
.ae9c		91 08		sta ($08),y	                sta (up),y
.ae9e		c8		iny		                iny
.ae9f		b5 01		lda $01,x	                lda 1,x
.aea1		91 08		sta ($08),y	                sta (up),y
.aea3		20 5f ae	jsr $ae5f	                jsr w_blkbuffer
.aea6		20 5f 92	jsr $925f	                jsr w_swap
.aea9		20 3e b0	jsr $b03e	                jsr w_block_read
.aeac		a9 01		lda #$01	                lda #1
.aeae		a0 30		ldy #$30	                ldy #buffstatus_offset
.aeb0		91 08		sta ($08),y	                sta (up),y
.aeb2		ca		dex		                dex
.aeb3		ca		dex		                dex
.aeb4						_done:
.aeb4		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.aeb6		b1 08		lda ($08),y	                lda (up),y
.aeb8		95 00		sta $00,x	                sta 0,x
.aeba		c8		iny		                iny
.aebb		b1 08		lda ($08),y	                lda (up),y
.aebd		95 01		sta $01,x	                sta 1,x
.aebf		60		rts		z_block:        rts
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.aec0						xt_block_c65_init:
.aec0						w_block_c65_init:
.aec0		a9 ff		lda #$ff	                lda #$ff
.aec2		8d 10 f0	sta $f010	                sta io_blk_status
.aec5		a9 00		lda #$00	                lda #$0
.aec7		8d 0f f0	sta $f00f	                sta io_blk_action
.aeca		ad 10 f0	lda $f010	                lda io_blk_status      ; $0 if OK, $ff otherwise
.aecd		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.aecf		ca		dex		                dex
.aed0		ca		dex		                dex
.aed1		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.aed3		95 01		sta $01,x	                sta 1,x
.aed5		ca		dex		                dex
.aed6		ca		dex		                dex
.aed7		a9 fa		lda #$fa	                lda #<c65_blk_read
.aed9		95 00		sta $00,x	                sta 0,x
.aedb		a9 ae		lda #$ae	                lda #>c65_blk_read
.aedd		95 01		sta $01,x	                sta 1,x
.aedf		20 4c b0	jsr $b04c	                jsr w_block_read_vector
.aee2		20 49 92	jsr $9249	                jsr w_store
.aee5		ca		dex		                dex
.aee6		ca		dex		                dex
.aee7		a9 f6		lda #$f6	                lda #<c65_blk_write
.aee9		95 00		sta $00,x	                sta 0,x
.aeeb		a9 ae		lda #$ae	                lda #>c65_blk_write
.aeed		95 01		sta $01,x	                sta 1,x
.aeef		20 64 b0	jsr $b064	                jsr w_block_write_vector
.aef2		20 49 92	jsr $9249	                jsr w_store
.aef5						z_block_c65_init:
.aef5		60		rts		                rts
.aef6		a0 02		ldy #$02	c65_blk_write:  ldy #2
.aef8		80 02		bra $aefc	                bra c65_blk_rw
.aefa		a0 01		ldy #$01	c65_blk_read:   ldy #1
.aefc		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.aefe		8d 11 f0	sta $f011	                sta io_blk_number
.af01		b5 01		lda $01,x	                lda 1,x
.af03		8d 12 f0	sta $f012	                sta io_blk_number+1
.af06		b5 02		lda $02,x	                lda 2,x
.af08		8d 13 f0	sta $f013	                sta io_blk_buffer
.af0b		b5 03		lda $03,x	                lda 3,x
.af0d		8d 14 f0	sta $f014	                sta io_blk_buffer+1
.af10		8c 0f f0	sty $f00f	                sty io_blk_action       ; trigger the r/w
.af13		e8		inx		                inx                     ; clean up stack
.af14		e8		inx		                inx
.af15		e8		inx		                inx
.af16		e8		inx		                inx
.af17		60		rts		                rts
.af18						xt_block_ramdrive_init:
.af18		20 82 d8	jsr $d882	                jsr underflow_1
.af1b						w_block_ramdrive_init:
.af1b		20 25 a2	jsr $a225	                jsr sliteral_runtime
>af1e		26 af 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.af22		20 ce 88	jsr $88ce	                jsr w_evaluate
.af25						z_block_ramdrive_init:
.af25		60		rts		                rts
.af26						ramdrive_code:
>af26		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>af2e		77 61 70 20 64 65 63 69 6d 61 6c
>af39		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>af40		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>af44		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>af4c		20 72 61 6d 64 72 69 76 65
>af55		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>af5d		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>af6b		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>af73		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af83		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>af93		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>af9b		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>afaa		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>afb2		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>afc2		31 30 32 34 20 6d 6f 76 65 20 3b
>afcd		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>afd5		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>afe5		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>aff5		20 21
>aff7		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>afff		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>b00f		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>b01f		6f 72 20 21
>b023		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>b02b		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>b03b		65 20 21
.b03e						ramdrive_code_end:
.b03e						xt_block_read:
.b03e						w_block_read:
.b03e		a0 32		ldy #$32	                ldy #blockread_offset
.b040		b1 08		lda ($08),y	                lda (up),y
.b042		85 25		sta $25		                sta tmp1
.b044		c8		iny		                iny
.b045		b1 08		lda ($08),y	                lda (up),y
.b047		85 26		sta $26		                sta tmp1+1
.b049		6c 25 00	jmp ($0025)	                jmp (tmp1)
.b04c						z_block_read:
.b04c						xt_block_read_vector:
.b04c						w_block_read_vector:
.b04c		a9 32		lda #$32	                lda #blockread_offset
.b04e		4c 3e d7	jmp $d73e	                jmp push_upvar_tos
.b051						z_block_read_vector:
.b051						xt_block_word_error:
.b051						w_block_word_error:
.b051		a9 0c		lda #$0c	                lda #err_blockwords
.b053		4c 98 d8	jmp $d898	                jmp error       ; no RTS needed
.b056						xt_block_write:
.b056						w_block_write:
.b056		a0 34		ldy #$34	                ldy #blockwrite_offset
.b058		b1 08		lda ($08),y	                lda (up),y
.b05a		85 25		sta $25		                sta tmp1
.b05c		c8		iny		                iny
.b05d		b1 08		lda ($08),y	                lda (up),y
.b05f		85 26		sta $26		                sta tmp1+1
.b061		6c 25 00	jmp ($0025)	                jmp (tmp1)
.b064						z_block_write:
.b064						xt_block_write_vector:
.b064						w_block_write_vector:
.b064		a9 34		lda #$34	                lda #blockwrite_offset
.b066		4c 3e d7	jmp $d73e	                jmp push_upvar_tos
.b069						z_block_write_vector:
.b069						xt_buffblocknum:
.b069						w_buffblocknum:
.b069		a9 2e		lda #$2e	                lda #buffblocknum_offset
.b06b		4c 3e d7	jmp $d73e	                jmp push_upvar_tos
.b06e						z_buffblocknum:
.b06e						xt_buffer:
.b06e						w_buffer:
.b06e		a0 30		ldy #$30	                ldy #buffstatus_offset
.b070		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b072		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b074		d0 0c		bne $b082	                bne _buffer_available ; Unused or not dirty = available
.b076		20 5f ae	jsr $ae5f	                jsr w_blkbuffer
.b079		20 69 b0	jsr $b069	                jsr w_buffblocknum
.b07c		20 36 88	jsr $8836	                jsr w_fetch
.b07f		20 56 b0	jsr $b056	                jsr w_block_write
.b082						_buffer_available:
.b082		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.b084		b5 00		lda $00,x	                lda 0,x
.b086		91 08		sta ($08),y	                sta (up),y
.b088		c8		iny		                iny
.b089		b5 01		lda $01,x	                lda 1,x
.b08b		91 08		sta ($08),y	                sta (up),y
.b08d		a9 01		lda #$01	                lda #1
.b08f		a0 30		ldy #$30	                ldy #buffstatus_offset
.b091		91 08		sta ($08),y	                sta (up),y
.b093		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.b095		b1 08		lda ($08),y	                lda (up),y
.b097		95 00		sta $00,x	                sta 0,x
.b099		c8		iny		                iny
.b09a		b1 08		lda ($08),y	                lda (up),y
.b09c		95 01		sta $01,x	                sta 1,x
.b09e		60		rts		z_buffer:       rts
.b09f						xt_buffstatus:
.b09f						w_buffstatus:
.b09f		a9 30		lda #$30	                lda #buffstatus_offset
.b0a1		4c 3e d7	jmp $d73e	                jmp push_upvar_tos
.b0a4						z_buffstatus:
.b0a4						xt_empty_buffers:
.b0a4						w_empty_buffers:
.b0a4		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0a6		a9 00		lda #$00	                lda #0
.b0a8		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b0aa						z_empty_buffers:
.b0aa		60		rts		                rts
.b0ab						xt_flush:
.b0ab						w_flush:
.b0ab		20 06 b1	jsr $b106	                jsr w_save_buffers
.b0ae		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0b0		a9 00		lda #$00	                lda #0
.b0b2		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b0b4						z_flush:
.b0b4		60		rts		                rts
.b0b5						xt_list:
.b0b5		20 82 d8	jsr $d882	                jsr underflow_1
.b0b8						w_list:
.b0b8		20 21 b1	jsr $b121	                jsr w_scr
.b0bb		20 49 92	jsr $9249	                jsr w_store
.b0be		20 c0 b1	jsr $b1c0	                jsr w_editor_l
.b0c1		60		rts		z_list:         rts
.b0c2						xt_load:
.b0c2		20 82 d8	jsr $d882	                jsr underflow_1
.b0c5						w_load:
.b0c5		a0 05		ldy #$05	                ldy #blk_offset+1
.b0c7		b1 08		lda ($08),y	                lda (up),y
.b0c9		48		pha		                pha
.b0ca		88		dey		                dey
.b0cb		b1 08		lda ($08),y	                lda (up),y
.b0cd		48		pha		                pha
.b0ce		b5 00		lda $00,x	                lda 0,x
.b0d0		91 08		sta ($08),y	                sta (up),y
.b0d2		c8		iny		                iny
.b0d3		b5 01		lda $01,x	                lda 1,x
.b0d5		91 08		sta ($08),y	                sta (up),y
.b0d7		20 6d ae	jsr $ae6d	                jsr w_block
.b0da		ca		dex		                dex
.b0db		ca		dex		                dex
.b0dc		a9 04		lda #$04	                lda #4
.b0de		95 01		sta $01,x	                sta 1,x
.b0e0		74 00		stz $00,x	                stz 0,x
.b0e2		20 c5 88	jsr $88c5	                jsr load_evaluate
.b0e5		a0 04		ldy #$04	                ldy #blk_offset
.b0e7		68		pla		                pla
.b0e8		91 08		sta ($08),y	                sta (up),y
.b0ea		c8		iny		                iny
.b0eb		68		pla		                pla
.b0ec		91 08		sta ($08),y	                sta (up),y
.b0ee		88		dey		                dey
.b0ef		11 08		ora ($08),y	                ora (up),y
.b0f1		f0 12		beq $b105	                beq _done
.b0f3		ca		dex		                dex
.b0f4		ca		dex		                dex
.b0f5		a0 04		ldy #$04	                ldy #blk_offset
.b0f7		b1 08		lda ($08),y	                lda (up),y
.b0f9		95 00		sta $00,x	                sta 0,x
.b0fb		c8		iny		                iny
.b0fc		b1 08		lda ($08),y	                lda (up),y
.b0fe		95 01		sta $01,x	                sta 1,x
.b100		20 6d ae	jsr $ae6d	                jsr w_block
.b103		e8		inx		                inx
.b104		e8		inx		                inx
.b105						_done:
.b105		60		rts		z_load:         rts
.b106						xt_save_buffers:
.b106						w_save_buffers:
.b106		a0 30		ldy #$30	                ldy #buffstatus_offset
.b108		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b10a		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b10c		d0 12		bne $b120	                bne _done       ; Either not used or not dirty = done!
.b10e		20 5f ae	jsr $ae5f	                jsr w_blkbuffer
.b111		20 69 b0	jsr $b069	                jsr w_buffblocknum
.b114		20 36 88	jsr $8836	                jsr w_fetch
.b117		20 56 b0	jsr $b056	                jsr w_block_write
.b11a		a9 01		lda #$01	                lda #1
.b11c		a0 30		ldy #$30	                ldy #buffstatus_offset
.b11e		91 08		sta ($08),y	                sta (up),y
.b120						_done:
.b120		60		rts		z_save_buffers: rts
.b121						xt_scr:
.b121						w_scr:
.b121		a9 06		lda #$06	                lda #scr_offset
.b123		4c 3e d7	jmp $d73e	                jmp push_upvar_tos
.b126						z_scr:
.b126						xt_thru:
.b126		20 87 d8	jsr $d887	                jsr underflow_2
.b129						w_thru:
.b129		b5 01		lda $01,x	                lda 1,x
.b12b		48		pha		                pha
.b12c		b5 00		lda $00,x	                lda 0,x
.b12e		48		pha		                pha
.b12f		e8		inx		                inx
.b130		e8		inx		                inx
.b131						_thru_loop:
.b131		b5 01		lda $01,x	                lda 1,x
.b133		48		pha		                pha
.b134		b5 00		lda $00,x	                lda 0,x
.b136		48		pha		                pha
.b137		20 c5 b0	jsr $b0c5	                jsr w_load
.b13a		68		pla		                pla
.b13b		85 25		sta $25		                sta tmp1
.b13d		68		pla		                pla
.b13e		85 26		sta $26		                sta tmp1+1
.b140		68		pla		                pla
.b141		85 27		sta $27		                sta tmp2
.b143		68		pla		                pla
.b144		85 28		sta $28		                sta tmp2+1
.b146		c5 26		cmp $26		                cmp tmp1+1
.b148		d0 08		bne $b152	                bne _next_screen
.b14a		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b14c		c5 25		cmp $25		                cmp tmp1
.b14e		d0 02		bne $b152	                bne _next_screen
.b150		80 18		bra $b16a	                bra _done       ; We just did the last screen.
.b152						_next_screen:
.b152		a5 28		lda $28		                lda tmp2+1
.b154		48		pha		                pha
.b155		a5 27		lda $27		                lda tmp2
.b157		48		pha		                pha
.b158		e6 25		inc $25		                inc tmp1
.b15a		d0 02		bne $b15e	                bne +
.b15c		e6 26		inc $26		                inc tmp1+1
.b15e						+
.b15e		ca		dex		                dex
.b15f		ca		dex		                dex
.b160		a5 25		lda $25		                lda tmp1
.b162		95 00		sta $00,x	                sta 0,x
.b164		a5 26		lda $26		                lda tmp1+1
.b166		95 01		sta $01,x	                sta 1,x
.b168		80 c7		bra $b131	                bra _thru_loop
.b16a						_done:
.b16a		60		rts		z_thru:         rts
.b16b						xt_update:
.b16b						w_update:
.b16b		a0 30		ldy #$30	                ldy #buffstatus_offset
.b16d		b1 08		lda ($08),y	                lda (up),y
.b16f		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b171		91 08		sta ($08),y	                sta (up),y
.b173		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b174						xt_editor_screen_helper:
.b174						w_editor_screen_helper:
.b174		20 a9 86	jsr $86a9	                jsr w_dup
.b177		20 21 b1	jsr $b121	                jsr w_scr
.b17a		20 49 92	jsr $9249	                jsr w_store
.b17d		4c 6e b0	jmp $b06e	                jmp w_buffer
.b180						xt_editor_enter_screen:
.b180						w_editor_enter_screen:
.b180		20 74 b1	jsr $b174	                jsr w_editor_screen_helper
.b183		20 a3 86	jsr $86a3	                jsr w_drop
.b186		64 35		stz $35		                stz ed_head
.b188						_prompt_loop:
.b188		ca		dex		                dex
.b189		ca		dex		                dex
.b18a		a5 35		lda $35		                lda ed_head
.b18c		95 00		sta $00,x	                sta 0,x
.b18e		74 01		stz $01,x	                stz 1,x
.b190		20 53 b2	jsr $b253	                jsr w_editor_o
.b193		e6 35		inc $35		                inc ed_head
.b195		a9 10		lda #$10	                lda #16
.b197		c5 35		cmp $35		                cmp ed_head
.b199		d0 ed		bne $b188	                bne _prompt_loop
.b19b						z_editor_enter_screen:
.b19b		60		rts		                rts
.b19c						xt_editor_erase_screen:
.b19c						w_editor_erase_screen:
.b19c		20 74 b1	jsr $b174	                jsr w_editor_screen_helper
.b19f		ca		dex		                dex
.b1a0		ca		dex		                dex
.b1a1		74 00		stz $00,x	                stz 0,x
.b1a3		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b1a5		95 01		sta $01,x	                sta 1,x
.b1a7		20 c6 87	jsr $87c6	                jsr w_blank
.b1aa		20 6b b1	jsr $b16b	                jsr w_update
.b1ad						z_editor_erase_screen:
.b1ad		60		rts		                rts
.b1ae						xt_editor_el:
.b1ae						w_editor_el:
.b1ae		20 3d b2	jsr $b23d	                jsr w_editor_line
.b1b1		ca		dex		                dex
.b1b2		ca		dex		                dex
.b1b3		a9 40		lda #$40	                lda #64
.b1b5		95 00		sta $00,x	                sta 0,x
.b1b7		74 01		stz $01,x	                stz 1,x
.b1b9		20 c6 87	jsr $87c6	                jsr w_blank
.b1bc		20 6b b1	jsr $b16b	                jsr w_update
.b1bf		60		rts		z_editor_el:    rts
.b1c0						xt_editor_l:
.b1c0						w_editor_l:
.b1c0		ca		dex		                dex             ; Put SCR on the stack.
.b1c1		ca		dex		                dex
.b1c2		a0 06		ldy #$06	                ldy #scr_offset
.b1c4		b1 08		lda ($08),y	                lda (up),y
.b1c6		95 00		sta $00,x	                sta 0,x
.b1c8		c8		iny		                iny
.b1c9		b1 08		lda ($08),y	                lda (up),y
.b1cb		95 01		sta $01,x	                sta 1,x
.b1cd		20 6d ae	jsr $ae6d	                jsr w_block    ; Get the current screen.
.b1d0		20 3a 84	jsr $843a	                jsr w_cr
.b1d3		80 08		bra $b1dd	                bra _after_screen_msg
.b1d5						_screen_msg:
>b1d5		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b1dd						_after_screen_msg:
.b1dd		20 25 a2	jsr $a225	                jsr sliteral_runtime
>b1e0		d5 b1 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b1e4		20 e6 94	jsr $94e6	                jsr w_type
.b1e7		20 21 b1	jsr $b121	                jsr w_scr
.b1ea		20 36 88	jsr $8836	                jsr w_fetch
.b1ed		ca		dex		                dex
.b1ee		ca		dex		                dex
.b1ef		a9 04		lda #$04	                lda #4          ; four spaces
.b1f1		95 00		sta $00,x	                sta 0,x
.b1f3		74 01		stz $01,x	                stz 1,x
.b1f5		20 1d 95	jsr $951d	                jsr w_u_dot_r
.b1f8		64 29		stz $29		                stz tmp3
.b1fa						_line_loop:
.b1fa		20 3a 84	jsr $843a	                jsr w_cr
.b1fd		ca		dex		                dex
.b1fe		ca		dex		                dex
.b1ff		ca		dex		                dex
.b200		ca		dex		                dex
.b201		74 03		stz $03,x	                stz 3,x
.b203		a5 29		lda $29		                lda tmp3
.b205		95 02		sta $02,x	                sta 2,x
.b207		74 01		stz $01,x	                stz 1,x
.b209		a9 02		lda #$02	                lda #2
.b20b		95 00		sta $00,x	                sta 0,x
.b20d		20 1d 95	jsr $951d	                jsr w_u_dot_r
.b210		20 f6 91	jsr $91f6	                jsr w_space
.b213		20 a9 86	jsr $86a9	                jsr w_dup
.b216		ca		dex		                dex
.b217		ca		dex		                dex
.b218		a9 40		lda #$40	                lda #64
.b21a		95 00		sta $00,x	                sta 0,x
.b21c		74 01		stz $01,x	                stz 1,x
.b21e		20 e6 94	jsr $94e6	                jsr w_type
.b221		18		clc		                clc
.b222		a9 40		lda #$40	                lda #64
.b224		75 00		adc $00,x	                adc 0,x
.b226		95 00		sta $00,x	                sta 0,x
.b228		90 02		bcc $b22c	                bcc +
.b22a		f6 01		inc $01,x	                inc 1,x
.b22c						+
.b22c		e6 29		inc $29		                inc tmp3
.b22e		a5 29		lda $29		                lda tmp3
.b230		c9 10		cmp #$10	                cmp #16
.b232		d0 c6		bne $b1fa	                bne _line_loop
.b234		20 3a 84	jsr $843a	                jsr w_cr
.b237		e8		inx		                inx
.b238		e8		inx		                inx
.b239		60		rts		z_editor_l:            rts
.b23a						xt_editor_line:
.b23a		20 82 d8	jsr $d882	                jsr underflow_1
.b23d						w_editor_line:
.b23d		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b23f						_shift_tos_left:
.b23f		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b241		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b243		88		dey		                dey
.b244		d0 f9		bne $b23f	                bne _shift_tos_left
.b246		20 21 b1	jsr $b121	                jsr w_scr
.b249		20 36 88	jsr $8836	                jsr w_fetch
.b24c		20 6d ae	jsr $ae6d	                jsr w_block
.b24f		20 80 8e	jsr $8e80	                jsr w_plus
.b252		60		rts		z_editor_line:  rts
.b253						xt_editor_o:
.b253						w_editor_o:
.b253		20 3a 84	jsr $843a	                jsr w_cr
.b256		20 a9 86	jsr $86a9	                jsr w_dup
.b259		20 04 9e	jsr $9e04	                jsr w_two
.b25c		20 1d 95	jsr $951d	                jsr w_u_dot_r
.b25f		20 f6 91	jsr $91f6	                jsr w_space
.b262		a9 2a		lda #$2a	                lda #'*'
.b264		20 d3 86	jsr $86d3	                jsr emit_a
.b267		20 f6 91	jsr $91f6	                jsr w_space
.b26a		20 3d b2	jsr $b23d	                jsr w_editor_line
.b26d		20 a9 86	jsr $86a9	                jsr w_dup      ; Save a copy of the line address for later.
.b270		ca		dex		                dex
.b271		ca		dex		                dex
.b272		a9 40		lda #$40	                lda #64         ; chars/line
.b274		95 00		sta $00,x	                sta 0,x
.b276		74 01		stz $01,x	                stz 1,x
.b278		20 e7 80	jsr $80e7	                jsr w_accept
.b27b		20 a9 86	jsr $86a9	                jsr w_dup
.b27e		20 c0 9c	jsr $9cc0	                jsr w_not_rot  ; -rot
.b281		20 80 8e	jsr $8e80	                jsr w_plus
.b284		ca		dex		                dex
.b285		ca		dex		                dex
.b286		a9 40		lda #$40	                lda #64         ; chars/line
.b288		95 00		sta $00,x	                sta 0,x
.b28a		74 01		stz $01,x	                stz 1,x
.b28c		20 bb 8f	jsr $8fbb	                jsr w_rot
.b28f		20 12 8c	jsr $8c12	                jsr w_minus
.b292		20 c6 87	jsr $87c6	                jsr w_blank
.b295		20 6b b1	jsr $b16b	                jsr w_update
.b298		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b299						xt_also:
.b299						w_also:
.b299		20 c4 b2	jsr $b2c4	                jsr w_get_order
.b29c		20 32 8d	jsr $8d32	                jsr w_over
.b29f		20 5f 92	jsr $925f	                jsr w_swap
.b2a2		20 16 8d	jsr $8d16	                jsr w_one_plus
.b2a5		20 cd b3	jsr $b3cd	                jsr w_set_order
.b2a8		60		rts		z_also:         rts
.b2a9						xt_definitions:
.b2a9						w_definitions:
.b2a9		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b2ab		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b2ad		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b2af		91 08		sta ($08),y	                sta (up),y
.b2b1		60		rts		z_definitions:  rts
.b2b2						xt_forth:
.b2b2						w_forth:
.b2b2		a0 23		ldy #$23	                ldy #search_order_offset
.b2b4		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b2b6		91 08		sta ($08),y	                sta (up),y
.b2b8						z_forth:
.b2b8		60		rts		                rts
.b2b9						xt_get_current:
.b2b9						w_get_current:
.b2b9		ca		dex		                dex
.b2ba		ca		dex		                dex
.b2bb		a0 08		ldy #$08	                ldy #current_offset
.b2bd		b1 08		lda ($08),y	                lda (up),y
.b2bf		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b2c1		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b2c3		60		rts		z_get_current:  rts
.b2c4						xt_get_order:
.b2c4						w_get_order:
.b2c4		a0 22		ldy #$22	                ldy #num_order_offset
.b2c6		b1 08		lda ($08),y	                lda (up),y
.b2c8		85 25		sta $25		                sta tmp1
.b2ca		f0 16		beq $b2e2	                beq _done       ; If zero, there are no wordlists.
.b2cc						_loop:
.b2cc		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b2ce		a9 23		lda #$23	                lda #search_order_offset
.b2d0		18		clc		                clc
.b2d1		65 25		adc $25		                adc tmp1
.b2d3		a8		tay		                tay
.b2d4		ca		dex		                dex
.b2d5		ca		dex		                dex
.b2d6		b1 08		lda ($08),y	                lda (up),y
.b2d8		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b2da		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b2dc		a9 00		lda #$00	                lda #0
.b2de		c5 25		cmp $25		                cmp tmp1
.b2e0		d0 ea		bne $b2cc	                bne _loop
.b2e2						_done:
.b2e2		ca		dex		                dex
.b2e3		ca		dex		                dex
.b2e4		a0 22		ldy #$22	                ldy #num_order_offset
.b2e6		b1 08		lda ($08),y	                lda (up),y
.b2e8		95 00		sta $00,x	                sta 0,x
.b2ea		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b2ec		60		rts		z_get_order:    rts
.b2ed						xt_only:
.b2ed						w_only:
.b2ed		20 ae 93	jsr $93ae	                jsr w_true
.b2f0		20 cd b3	jsr $b3cd	                jsr w_set_order
.b2f3		60		rts		z_only:         rts
.b2f4						xt_order:
.b2f4						w_order:
.b2f4		20 3a 84	jsr $843a	                jsr w_cr
.b2f7		20 c4 b2	jsr $b2c4	                jsr w_get_order        ; ( wid_n ... wid_1 n )
.b2fa		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b2fc		f0 1e		beq $b31c	                beq _drop_done
.b2fe		a8		tay		                tay
.b2ff						_loop:
.b2ff		e8		inx		                inx
.b300		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b301		b5 00		lda $00,x	                lda 0,x
.b303		5a		phy		                phy
.b304		20 1f b3	jsr $b31f	                jsr order_print_wid_string   ; internal helper function
.b307		7a		ply		                ply
.b308		88		dey		                dey
.b309		d0 f4		bne $b2ff	                bne _loop
.b30b		20 f6 91	jsr $91f6	                jsr w_space
.b30e		20 f6 91	jsr $91f6	                jsr w_space
.b311		20 b9 b2	jsr $b2b9	                jsr w_get_current      ; ( wid )
.b314		b5 00		lda $00,x	                lda 0,x
.b316		20 1f b3	jsr $b31f	                jsr order_print_wid_string
.b319		20 3a 84	jsr $843a	                jsr w_cr
.b31c						_drop_done:
.b31c		e8		inx		                inx
.b31d		e8		inx		                inx
.b31e						z_order:
.b31e		60		rts		                rts
.b31f						order_print_wid_string:
.b31f		c9 04		cmp #$04	                cmp #4
.b321		90 09		bcc $b32c	                bcc _output_string      ; less than 4, print a real string
.b323		ca		dex		                dex
.b324		ca		dex		                dex
.b325		95 00		sta $00,x	                sta 0,x
.b327		74 01		stz $01,x	                stz 1,x
.b329		4c 11 95	jmp $9511	                jmp w_u_dot            ; JSR/RTS as this routine is not compiled
.b32c						_output_string:
.b32c		a8		tay		                tay
.b32d		b9 33 b3	lda $b333,y	                lda _wid_data,y
.b330		4c be d8	jmp $d8be	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b333						_wid_data:
>b333		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b334		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b335		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b336		07				        .byte str_wid_root             ; WID 3: "Root"
.b337						xt_previous:
.b337						w_previous:
.b337		20 c4 b2	jsr $b2c4	                jsr w_get_order
.b33a		20 61 8c	jsr $8c61	                jsr w_nip
.b33d		20 0a 8d	jsr $8d0a	                jsr w_one_minus
.b340		20 cd b3	jsr $b3cd	                jsr w_set_order
.b343		60		rts		z_previous:     rts
.b344						xt_root_wordlist:
.b344						w_root_wordlist:
.b344		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b345		ca		dex		                dex
.b346		a9 03		lda #$03	                lda #3
.b348		95 00		sta $00,x	                sta 0,x
.b34a		74 01		stz $01,x	                stz 1,x
.b34c						z_root_wordlist:
.b34c		60		rts		                rts
.b34d						xt_search_wordlist:
.b34d		20 8c d8	jsr $d88c	                jsr underflow_3
.b350						w_search_wordlist:
.b350		a5 08		lda $08		                lda up
.b352		18		clc		                clc
.b353		69 0a		adc #$0a	                adc #wordlists_offset
.b355		85 27		sta $27		                sta tmp2
.b357		a5 09		lda $09		                lda up+1
.b359		69 00		adc #$00	                adc #0          ; Adding carry
.b35b		85 28		sta $28		                sta tmp2+1
.b35d		b5 00		lda $00,x	                lda 0,x
.b35f		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b360		65 27		adc $27		                adc tmp2
.b362		85 27		sta $27		                sta tmp2
.b364		90 02		bcc $b368	                bcc +
.b366		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b368						+
.b368		e8		inx		                inx
.b369		e8		inx		                inx
.b36a		b5 00		lda $00,x	                lda 0,x
.b36c		15 01		ora $01,x	                ora 1,x
.b36e		f0 4e		beq $b3be	                beq _done
.b370		a5 27		lda $27		                lda tmp2
.b372		05 28		ora $28		                ora tmp2+1
.b374		f0 48		beq $b3be	                beq _done
.b376		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b378		85 25		sta $25		                sta tmp1
.b37a		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b37c		d0 02		bne $b380	                bne +
.b37e		e6 28		inc $28		                inc tmp2+1
.b380						+
.b380		b2 27		lda ($27)	                lda (tmp2)
.b382		85 26		sta $26		                sta tmp1+1
.b384		20 64 d7	jsr $d764	                jsr find_header_name
.b387		f0 31		beq $b3ba	                beq _fail_done
.b389		e8		inx		                inx
.b38a		e8		inx		                inx
.b38b		a5 25		lda $25		                lda tmp1
.b38d		95 00		sta $00,x	                sta 0,x
.b38f		a5 26		lda $26		                lda tmp1+1
.b391		95 01		sta $01,x	                sta 1,x
.b393		20 a9 86	jsr $86a9	                jsr w_dup              ; ( nt nt )
.b396		20 79 9c	jsr $9c79	                jsr w_name_to_int      ; ( nt xt )
.b399		20 5f 92	jsr $925f	                jsr w_swap             ; ( xt nt )
.b39c		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b39e		f6 00		inc $00,x	                inc 0,x
.b3a0		d0 02		bne $b3a4	                bne +
.b3a2		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b3a4						+
.b3a4		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b3a6		29 04		and #$04	                and #IM
.b3a8		d0 08		bne $b3b2	                bne _immediate          ; bit set, we're immediate
.b3aa		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b3ac		95 00		sta $00,x	                sta 0,x
.b3ae		95 01		sta $01,x	                sta 1,x
.b3b0		80 0e		bra $b3c0	                bra _done_nodrop
.b3b2						_immediate:
.b3b2		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b3b4		95 00		sta $00,x	                sta 0,x
.b3b6		74 01		stz $01,x	                stz 1,x
.b3b8		80 06		bra $b3c0	                bra _done_nodrop
.b3ba						_fail_done:
.b3ba		74 02		stz $02,x	                stz 2,x         ; failure flag
.b3bc		74 03		stz $03,x	                stz 3,x
.b3be						_done:
.b3be		e8		inx		                inx
.b3bf		e8		inx		                inx
.b3c0						_done_nodrop:
.b3c0						z_search_wordlist:
.b3c0		60		rts		                rts
.b3c1						xt_set_current:
.b3c1		20 82 d8	jsr $d882	                jsr underflow_1
.b3c4						w_set_current:
.b3c4		a0 08		ldy #$08	                ldy #current_offset
.b3c6		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b3c8		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b3ca		e8		inx		                inx
.b3cb		e8		inx		                inx
.b3cc		60		rts		z_set_current:  rts
.b3cd						xt_set_order:
.b3cd						w_set_order:
.b3cd		a9 ff		lda #$ff	                lda #$FF
.b3cf		d5 01		cmp $01,x	                cmp 1,x
.b3d1		d0 12		bne $b3e5	                bne _start
.b3d3		d5 00		cmp $00,x	                cmp 0,x
.b3d5		d0 0e		bne $b3e5	                bne _start
.b3d7		ca		dex		                dex             ; Make room for the count.
.b3d8		ca		dex		                dex
.b3d9		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b3db		a9 03		lda #$03	                lda #3
.b3dd		95 02		sta $02,x	                sta 2,x
.b3df		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b3e1		a9 01		lda #$01	                lda #1
.b3e3		95 00		sta $00,x	                sta 0,x
.b3e5						_start:
.b3e5		a0 22		ldy #$22	                ldy #num_order_offset
.b3e7		b5 00		lda $00,x	                lda 0,x
.b3e9		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b3eb		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b3ed		e8		inx		                inx             ; Drop the count off the data stack.
.b3ee		e8		inx		                inx
.b3ef		a5 25		lda $25		                lda tmp1
.b3f1		f0 0d		beq $b400	                beq _done       ; If zero, there are no wordlists.
.b3f3		a0 23		ldy #$23	                ldy #search_order_offset
.b3f5						_loop:
.b3f5		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b3f7		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b3f9		c8		iny		                iny
.b3fa		e8		inx		                inx
.b3fb		e8		inx		                inx
.b3fc		c6 25		dec $25		                dec tmp1
.b3fe		d0 f5		bne $b3f5	                bne _loop
.b400						_done:
.b400		60		rts		z_set_order:    rts
.b401						xt_to_order:
.b401						w_to_order:
.b401		20 9a 93	jsr $939a	                jsr w_to_r
.b404		20 c4 b2	jsr $b2c4	                jsr w_get_order
.b407		20 18 8f	jsr $8f18	                jsr w_r_from
.b40a		20 5f 92	jsr $925f	                jsr w_swap
.b40d		20 16 8d	jsr $8d16	                jsr w_one_plus
.b410		20 cd b3	jsr $b3cd	                jsr w_set_order
.b413		60		rts		z_to_order:     rts
.b414						xt_wordlist:
.b414						w_wordlist:
.b414		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b416		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b418		c9 0c		cmp #$0c	                cmp #max_wordlists
.b41a		d0 05		bne $b421	                bne _ok
.b41c		a9 0b		lda #$0b	                lda #err_wordlist
.b41e		4c 98 d8	jmp $d898	                jmp error
.b421						_ok:
.b421		1a		inc a		                ina             ; Increment the wordlist#
.b422		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b424		ca		dex		                dex             ; and put it on the stack.
.b425		ca		dex		                dex
.b426		95 00		sta $00,x	                sta 0,x
.b428		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b42a		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=$0000						ram_start = $0000          ; start of installed RAM, must include zpage
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=32767						ram_end   = $8000-1        ; end of installed RAM
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=512						buffer0   = stack0+$100      ; input buffer ($0200-$02ff)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b42b						cold_zp_table:
>b42b	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b42d	0002	0e bc				dp:         .word dictionary_start  ; Dictionary Pointer
>b42f	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b431	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b433	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b435	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b437	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b439	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b43b	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b43d	0012	27 f0				output:     .word kernel_putc       ; vector for EMIT
>b43f	0014	2b f0				input:      .word kernel_getc       ; vector for KEY
>b441	0016	39 f0				havekey:    .word kernel_kbhit      ; vector for KEY?
>b443	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b445	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b447	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>b449	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b44a	001f					loopctrl:   .byte ?         ; Offset from lcbstack0 to current loop control block for DO/LOOP/+LOOP
>b44b	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$0100						lcbstack0 = stack0
=256						loopindex = lcbstack0+0     ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack0+2     ; loop control block offset for limit fudge factor
>b44c	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b44e	0023					tmptos:     .word ?         ; temporary TOS storage
>b450	0025					tmp1:       .word ?         ; temporary storage
>b452	0027					tmp2:       .word ?         ; temporary storage
>b454	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b456	002b					tohold:     .word ?         ; pointer for formatted output
>b458	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b460	0035					tmped:      .word ?,?,?     ; temporary for editors
.b449						cold_zp_table_end:
.b449						cold_user_table:
>b449	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b44b	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b44d	0004	00 00				blk_offset:             .word 0         ; BLK
>b44f	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b451	0008					marker_start_offset:
>b451	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b452	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b453	000a					wordlists_offset:
>b453	000a	0e bc				    .word dictionary_start              ; FORTH-WORDLIST
>b455	000c	93 ca				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b457	000e	e3 ca				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b459	0010	52 ca				    .word root_dictionary_start         ; ROOT-WORDLIST
>b45b	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b463	001a	00 00 00 00 00 00 00 00
>b46b	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b46c	0023					search_order_offset:
>b46c	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b474	002b	00
.b475	002c					marker_end_offset:
>b475	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b477	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b479	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b47b	0032	51 b0				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b47d	0034	51 b0				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b47f						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b47f						oc_index_table:
>b47f		7f b6 83 b6 2a bb 2a bb		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b487		8b b6 91 b6 97 b6 9d b6
>b48f		a4 b6 a8 b6 ae b6 2a bb		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b497		b4 b6 b8 b6 bc b6 c0 b6
>b49f		c5 b6 c9 b6 d1 b6 2a bb		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b4a7		d8 b6 de b6 e5 b6 ec b6
>b4af		f3 b6 f7 b6 fd b6 2a bb		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b4b7		03 b7 07 b7 0d b7 13 b7
>b4bf		18 b7 1c b7 2a bb 2a bb		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b4c7		24 b7 2a b7 30 b7 36 b7
>b4cf		3d b7 41 b7 47 b7 2a bb		        .word oc28, oc29, oc2A, oc__, oc2C, oc2D, oc2E, oc2F
>b4d7		4d b7 51 b7 56 b7 5a b7
>b4df		5f b7 63 b7 6b b7 2a bb		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b4e7		72 b7 7a b7 81 b7 88 b7
>b4ef		8f b7 93 b7 99 b7 2a bb		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b4f7		9f b7 a5 b7 ab b7 b1 b7
>b4ff		b6 b7 ba b7 2a bb 2a bb		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b507		2a bb c2 b7 c8 b7 ce b7
>b50f		d5 b7 d9 b7 df b7 2a bb		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b517		e5 b7 e9 b7 ed b7 f1 b7
>b51f		f6 b7 fa b7 02 b8 2a bb		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b527		2a bb 09 b8 10 b8 17 b8
>b52f		1e b8 22 b8 28 b8 2a bb		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b537		2a bb 2c b8 32 b8 38 b8
>b53f		3d b8 41 b8 2a bb 2a bb		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b547		49 b8 4f b8 55 b8 5b b8
>b54f		62 b8 66 b8 6c b8 2a bb		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b557		72 b8 78 b8 7c b8 80 b8
>b55f		85 b8 89 b8 91 b8 2a bb		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b567		98 b8 9f b8 a6 b8 ad b8
>b56f		b4 b8 b8 b8 be b8 2a bb		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b577		c2 b8 c9 b8 cf b8 d5 b8
>b57f		da b8 de b8 2a bb 2a bb		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b587		e6 b8 ec b8 f2 b8 f8 b8
>b58f		ff b8 03 b9 09 b9 2a bb		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b597		0d b9 11 b9 15 b9 19 b9
>b59f		1e b9 22 b9 2a b9 2a bb		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b5a7		31 b9 38 b9 3f b9 46 b9
>b5af		4d b9 51 b9 57 b9 2a bb		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b5b7		5b b9 5f b9 65 b9 6b b9
>b5bf		70 b9 76 b9 7e b9 2a bb		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b5c7		84 b9 8a b9 90 b9 96 b9
>b5cf		9d b9 a1 b9 a7 b9 2a bb		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b5d7		ab b9 af b9 b3 b9 b7 b9
>b5df		bc b9 c0 b9 c8 b9 2a bb		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b5e7		cf b9 d6 b9 dd b9 e4 b9
>b5ef		eb b9 ef b9 f5 b9 2a bb		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b5f7		f9 b9 ff b9 05 ba 0b ba
>b5ff		10 ba 16 ba 2a bb 2a bb		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b607		1e ba 24 ba 2a ba 30 ba
>b60f		37 ba 3b ba 41 ba 2a bb		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b617		45 ba 49 ba 4d ba 51 ba
>b61f		56 ba 5a ba 62 ba 2a bb		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b627		2a bb 69 ba 70 ba 77 ba
>b62f		7e ba 82 ba 88 ba 2a bb		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b637		2a bb 8c ba 92 ba 98 ba
>b63f		9d ba a3 ba 2a bb 2a bb		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b647		ab ba b1 ba b7 ba bd ba
>b64f		c4 ba c8 ba ce ba 2a bb		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b657		d2 ba d6 ba da ba de ba
>b65f		e3 ba e7 ba ef ba 2a bb		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b667		2a bb f6 ba fd ba 04 bb
>b66f		0b bb 0f bb 15 bb 2a bb		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b677		2a bb 19 bb 1f bb 25 bb
>b67f		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b683		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b68b		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b691		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b697		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b69d		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b6a4		43 70 68 70				oc08:	.text 1*64+3, "php"
>b6a8		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b6ae		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b6b4		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b6b8		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b6bc		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b6c0		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b6c5		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b6c9		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b6d1		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b6d8		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b6de		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b6e5		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b6ec		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b6f3		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b6f7		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b6fd		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b703		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b707		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b70d		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b713		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b718		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b71c		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b724		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b72a		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b730		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b736		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b73d		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b741		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b747		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b74d		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b751		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b756		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b75a		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b75f		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b763		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b76b		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b772		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b77a		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b781		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b788		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b78f		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b793		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b799		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b79f		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b7a5		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b7ab		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b7b1		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b7b6		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b7ba		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b7c2		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b7c8		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b7ce		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b7d5		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b7d9		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b7df		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b7e5		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b7e9		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b7ed		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b7f1		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b7f6		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b7fa		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b802		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b809		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b810		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b817		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b81e		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b822		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b828		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b82c		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b832		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b838		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b83d		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b841		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b849		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b84f		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b855		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b85b		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b862		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b866		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b86c		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b872		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b878		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b87c		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b880		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b885		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b889		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b891		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b898		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b89f		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b8a6		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b8ad		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b8b4		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b8b8		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b8be		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b8c2		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b8c9		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b8cf		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b8d5		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b8da		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b8de		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b8e6		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b8ec		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b8f2		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b8f8		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b8ff		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b903		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b909		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b90d		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b911		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b915		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b919		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b91e		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b922		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b92a		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b931		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b938		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b93f		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b946		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b94d		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b951		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b957		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b95b		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b95f		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b965		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b96b		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b970		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b976		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b97e		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b984		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b98a		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b990		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b996		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b99d		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b9a1		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b9a7		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b9ab		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b9af		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b9b3		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b9b7		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b9bc		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b9c0		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b9c8		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b9cf		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b9d6		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b9dd		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b9e4		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b9eb		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b9ef		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b9f5		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b9f9		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b9ff		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>ba05		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>ba0b		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>ba10		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>ba16		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>ba1e		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>ba24		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>ba2a		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>ba30		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>ba37		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>ba3b		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>ba41		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>ba45		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>ba49		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>ba4d		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>ba51		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>ba56		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>ba5a		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>ba62		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>ba69		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>ba70		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>ba77		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>ba7e		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>ba82		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>ba88		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>ba8c		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>ba92		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>ba98		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>ba9d		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>baa3		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>baab		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>bab1		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>bab7		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>babd		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>bac4		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>bac8		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>bace		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>bad2		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>bad6		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>bada		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>bade		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>bae3		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>bae7		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>baef		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>baf6		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>bafd		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>bb04		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>bb0b		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>bb0f		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>bb15		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>bb19		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>bb1f		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>bb25		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>bb2a		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.bb2c						forth_words_start:
>bb2c		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb34		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb44		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bb54		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>bb64		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>bb74		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bb84		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>bb94		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bba4		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bbb4		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bbc4		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bbd4		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bbe4		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bbf4		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bc04		78 69 74 29 20 63 72 20
.bc0c						forth_words_end:
.bc0c						user_words_start:
>bc0c		20 20				.binary "user_words.asc"
.bc0e						user_words_end:

;******  Processing file: platform/../words/headers.asm

.bc0e						dictionary_start:
.bc0e						nt_drop:
>bc0e		04 10				        .byte 4, UF
>bc10		1a bc a0 86 a5 86		        .word nt_dup, xt_drop, z_drop
>bc16		64 72 6f 70			        .text "drop"
.bc1a						nt_dup:
>bc1a		03 10				        .byte 3, UF
>bc1c		25 bc a6 86 b3 86		        .word nt_swap, xt_dup, z_dup
>bc22		64 75 70			        .text "dup"
.bc25						nt_swap:
>bc25		04 10				        .byte 4, UF
>bc27		31 bc 5c 92 6f 92		        .word nt_store, xt_swap, z_swap
>bc2d		73 77 61 70			        .text "swap"
.bc31						nt_store:
>bc31		01 10				        .byte 1, UF
>bc33		3a bc 46 92 5b 92		        .word nt_fetch, xt_store, z_store
>bc39		21				        .text "!"
.bc3a						nt_fetch:
>bc3a		01 10				        .byte 1, UF
>bc3c		43 bc 33 88 45 88		        .word nt_over, xt_fetch, z_fetch
>bc42		40				        .text "@"
.bc43						nt_over:
>bc43		04 10				        .byte 4, UF
>bc45		4f bc 2f 8d 3c 8d		        .word nt_to_r, xt_over, z_over
>bc4b		6f 76 65 72			        .text "over"
.bc4f						nt_to_r:
>bc4f		02 11				        .byte 2, CO+UF ; native is special case
>bc51		59 bc 9a 93 ad 93		        .word nt_r_from, xt_to_r, z_to_r
>bc57		3e 72				        .text ">r"
.bc59						nt_r_from:
>bc59		02 01				        .byte 2, CO    ; native is special case
>bc5b		63 bc 18 8f 28 8f		        .word nt_r_fetch, xt_r_from, z_r_from
>bc61		72 3e				        .text "r>"
.bc63						nt_r_fetch:
>bc63		02 01				        .byte 2, CO    ; native is special case
>bc65		6d bc 03 8f 17 8f		        .word nt_nip, xt_r_fetch, z_r_fetch
>bc6b		72 40				        .text "r@"
.bc6d						nt_nip:
>bc6d		03 10				        .byte 3, UF
>bc6f		78 bc 5e 8c 6b 8c		        .word nt_rot, xt_nip, z_nip
>bc75		6e 69 70			        .text "nip"
.bc78						nt_rot:
>bc78		03 10				        .byte 3, UF
>bc7a		83 bc b8 8f d3 8f		        .word nt_not_rot, xt_rot, z_rot
>bc80		72 6f 74			        .text "rot"
.bc83						nt_not_rot:
>bc83		04 10				        .byte 4, UF
>bc85		8f bc bd 9c d8 9c		        .word nt_tuck, xt_not_rot, z_not_rot
>bc8b		2d 72 6f 74			        .text "-rot"
.bc8f						nt_tuck:
>bc8f		04 10				        .byte 4, UF
>bc91		9b bc b7 93 d0 93		        .word nt_comma, xt_tuck, z_tuck
>bc97		74 75 63 6b			        .text "tuck"
.bc9b						nt_comma:
>bc9b		01 10				        .byte 1, UF
>bc9d		a4 bc cd 83 db 83		        .word nt_c_fetch, xt_comma, z_comma
>bca3		2c				        .text ","
.bca4						nt_c_fetch:
>bca4		02 10				        .byte 2, UF
>bca6		ae bc 2d 83 36 83		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bcac		63 40				        .text "c@"
.bcae						nt_c_store:
>bcae		02 10				        .byte 2, UF
>bcb0		b8 bc 37 83 42 83		        .word nt_plus_store, xt_c_store, z_c_store
>bcb6		63 21				        .text "c!"
.bcb8						nt_plus_store:
>bcb8		02 10				        .byte 2, UF
>bcba		c2 bc 90 8e af 8e		        .word nt_zero, xt_plus_store, z_plus_store
>bcc0		2b 21				        .text "+!"
.bcc2						nt_zero:
>bcc2		01 00				        .byte 1, 0
>bcc4		cb bc 39 9e 3f 9e		        .word nt_one, xt_zero, z_zero
>bcca		30				        .text "0"
.bccb						nt_one:
>bccb		01 00				        .byte 1, 0
>bccd		d4 bc d3 9d db 9d		        .word nt_two, xt_one, z_one
>bcd3		31				        .text "1"
.bcd4						nt_two:
>bcd4		01 00				        .byte 1, 0
>bcd6		dd bc 04 9e 0c 9e		        .word nt_execute, xt_two, z_two
>bcdc		32				        .text "2"
.bcdd						nt_execute:
>bcdd		07 10				        .byte 7, UF
>bcdf		ec bc 1e 88 24 88		        .word nt_emit, xt_execute, z_execute
>bce5		65 78 65 63 75 74 65		        .text "execute"
.bcec						nt_emit:
>bcec		04 18				        .byte 4, NN+UF
>bcee		f8 bc cc 86 d6 86		        .word nt_type, xt_emit, z_emit
>bcf4		65 6d 69 74			        .text "emit"
.bcf8						nt_type:
>bcf8		04 10				        .byte 4, UF
>bcfa		04 bd e3 94 0d 95		        .word nt_dot, xt_type, z_type
>bd00		74 79 70 65			        .text "type"
.bd04						nt_dot:
>bd04		01 10				        .byte 1, UF
>bd06		0d bd 36 86 57 86		        .word nt_u_dot, xt_dot, z_dot
>bd0c		2e				        .text "."
.bd0d						nt_u_dot:
>bd0d		02 10				        .byte 2, UF
>bd0f		17 bd 0e 95 19 95		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd15		75 2e				        .text "u."
.bd17						nt_u_dot_r:
>bd17		03 10				        .byte 3, UF
>bd19		22 bd 1a 95 3b 95		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd1f		75 2e 72			        .text "u.r"
.bd22						nt_dot_r:
>bd22		02 10				        .byte 2, UF
>bd24		2c bd 72 86 9f 86		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd2a		2e 72				        .text ".r"
.bd2c						nt_d_dot:
>bd2c		02 10				        .byte 2, UF
>bd2e		36 bd c2 9e e0 9e		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd34		64 2e				        .text "d."
.bd36						nt_d_dot_r:
>bd36		03 10				        .byte 3, UF
>bd38		41 bd e1 9e 0b 9f		        .word nt_m_star_slash, xt_d_dot_r, z_d_dot_r
>bd3e		64 2e 72			        .text "d.r"
.bd41						nt_m_star_slash:
>bd41		03 10				        .byte 3, UF
>bd43		4c bd 0c 9f 72 9f		        .word nt_ud_dot, xt_m_star_slash, z_m_star_slash
>bd49		6d 2a 2f			        .text "m*/"
.bd4c						nt_ud_dot:
>bd4c		03 10				        .byte 3, UF
>bd4e		57 bd bf 9f d1 9f		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd54		75 64 2e			        .text "ud."
.bd57						nt_ud_dot_r:
>bd57		04 10				        .byte 4, UF
>bd59		63 bd d2 9f f0 9f		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd5f		75 64 2e 72			        .text "ud.r"
.bd63						nt_question:
>bd63		01 00				        .byte 1, 0
>bd65		6c bd 59 99 5f 99		        .word nt_false, xt_question, z_question
>bd6b		3f				        .text "?"
.bd6c						nt_false:
>bd6c		05 00				        .byte 5, 0
>bd6e		79 bd 39 9e 3f 9e		        .word nt_true, xt_false, z_false
>bd74		66 61 6c 73 65			        .text "false"
.bd79						nt_true:
>bd79		04 00				        .byte 4, 0
>bd7b		85 bd ae 93 b6 93		        .word nt_space, xt_true, z_true
>bd81		74 72 75 65			        .text "true"
.bd85						nt_space:
>bd85		05 00				        .byte 5, 0
>bd87		92 bd f6 91 fb 91		        .word nt_two_dup, xt_space, z_space
>bd8d		73 70 61 63 65			        .text "space"
.bd92						nt_two_dup:
>bd92		04 10				        .byte 4, UF
>bd94		9e bd d9 93 f0 93		        .word nt_question_dup, xt_two_dup, z_two_dup
>bd9a		32 64 75 70			        .text "2dup"
.bd9e						nt_question_dup:
>bd9e		04 10				        .byte 4, UF
>bda0		aa bd ef 8e 02 8f		        .word nt_plus, xt_question_dup, z_question_dup
>bda6		3f 64 75 70			        .text "?dup"
.bdaa						nt_plus:
>bdaa		01 10				        .byte 1, UF
>bdac		b3 bd 7d 8e 8f 8e		        .word nt_minus, xt_plus, z_plus
>bdb2		2b				        .text "+"
.bdb3						nt_minus:
>bdb3		01 10				        .byte 1, UF
>bdb5		bc bd 0f 8c 21 8c		        .word nt_one_minus, xt_minus, z_minus
>bdbb		2d				        .text "-"
.bdbc						nt_one_minus:
>bdbc		02 10				        .byte 2, UF
>bdbe		c6 bd 07 8d 12 8d		        .word nt_one_plus, xt_one_minus, z_one_minus
>bdc4		31 2d				        .text "1-"
.bdc6						nt_one_plus:
>bdc6		02 10				        .byte 2, UF
>bdc8		d0 bd 13 8d 1c 8d		        .word nt_two_star, xt_one_plus, z_one_plus
>bdce		31 2b				        .text "1+"
.bdd0						nt_two_star:
>bdd0		02 10				        .byte 2, UF
>bdd2		da bd 71 94 78 94		        .word nt_two_slash, xt_two_star, z_two_star
>bdd8		32 2a				        .text "2*"
.bdda						nt_two_slash:
>bdda		02 10				        .byte 2, UF
>bddc		e4 bd 66 94 70 94		        .word nt_abs, xt_two_slash, z_two_slash
>bde2		32 2f				        .text "2/"
.bde4						nt_abs:
>bde4		03 10				        .byte 3, UF
>bde6		ef bd cf 80 e3 80		        .word nt_dabs, xt_abs, z_abs
>bdec		61 62 73			        .text "abs"
.bdef						nt_dabs:
>bdef		04 10				        .byte 4, UF
>bdf1		fb bd 88 9e a6 9e		        .word nt_and, xt_dabs, z_dabs
>bdf7		64 61 62 73			        .text "dabs"
.bdfb						nt_and:
>bdfb		03 10				        .byte 3, UF
>bdfd		06 be 90 82 a1 82		        .word nt_or, xt_and, z_and
>be03		61 6e 64			        .text "and"
.be06						nt_or:
>be06		02 10				        .byte 2, UF
>be08		10 be 1d 8d 2e 8d		        .word nt_xor, xt_or, z_or
>be0e		6f 72				        .text "or"
.be10						nt_xor:
>be10		03 10				        .byte 3, UF
>be12		1b be 94 96 a5 96		        .word nt_rshift, xt_xor, z_xor
>be18		78 6f 72			        .text "xor"
.be1b						nt_rshift:
>be1b		06 10				        .byte 6, UF
>be1d		29 be d4 8f e7 8f		        .word nt_lshift, xt_rshift, z_rshift
>be23		72 73 68 69 66 74		        .text "rshift"
.be29						nt_lshift:
>be29		06 10				        .byte 6, UF
>be2b		37 be 38 8b 4b 8b		        .word nt_pick, xt_lshift, z_lshift
>be31		6c 73 68 69 66 74		        .text "lshift"
.be37						nt_pick:
>be37		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be39		43 be 6c 8e 7c 8e		        .word nt_char, xt_pick, z_pick
>be3f		70 69 63 6b			        .text "pick"
.be43						nt_char:
>be43		04 00				        .byte 4, 0
>be45		4f be 53 83 69 83		        .word nt_bracket_char, xt_char, z_char
>be4b		63 68 61 72			        .text "char"
.be4f						nt_bracket_char:
>be4f		06 05				        .byte 6, CO+IM
>be51		5d be 0d 83 13 83		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be57		5b 63 68 61 72 5d		        .text "[char]"
.be5d						nt_char_plus:
>be5d		05 00				        .byte 5, 0
>be5f		6a be 13 8d 1c 8d		        .word nt_chars, xt_char_plus, z_char_plus ; same as 1+
>be65		63 68 61 72 2b			        .text "char+"
.be6a						nt_chars:
>be6a		05 10				        .byte 5, UF     ; deleted during compile
>be6c		77 be 6a 83 6d 83		        .word nt_cells, xt_chars, z_chars
>be72		63 68 61 72 73			        .text "chars"
.be77						nt_cells:
>be77		05 00				        .byte 5, 0
>be79		84 be 71 94 78 94		        .word nt_cell_plus, xt_cells, z_cells  ; same as 2*
>be7f		63 65 6c 6c 73			        .text "cells"
.be84						nt_cell_plus:
>be84		05 10				        .byte 5, UF
>be86		91 be 43 83 52 83		        .word nt_here, xt_cell_plus, z_cell_plus
>be8c		63 65 6c 6c 2b			        .text "cell+"
.be91						nt_here:
>be91		04 00				        .byte 4, 0
>be93		9d be 34 89 3e 89		        .word nt_equal, xt_here, z_here
>be99		68 65 72 65			        .text "here"
.be9d						nt_equal:
>be9d		01 10				        .byte 1, UF
>be9f		a6 be a7 87 c2 87		        .word nt_not_equals, xt_equal, z_equal
>bea5		3d				        .text "="
.bea6						nt_not_equals:
>bea6		02 10				        .byte 2, UF
>bea8		b0 be 6c 8c 89 8c		        .word nt_less_than, xt_not_equals, z_not_equals
>beae		3c 3e				        .text "<>"
.beb0						nt_less_than:
>beb0		01 10				        .byte 1, UF
>beb2		b9 be 08 8a 1c 8a		        .word nt_u_less_than, xt_less_than, z_less_than
>beb8		3c				        .text "<"
.beb9						nt_u_less_than:
>beb9		02 10				        .byte 2, UF
>bebb		c3 be 52 95 67 95		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bec1		75 3c				        .text "u<"
.bec3						nt_u_greater_than:
>bec3		02 10				        .byte 2, UF
>bec5		cd be 3c 95 51 95		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>becb		75 3e				        .text "u>"
.becd						nt_greater_than:
>becd		01 10				        .byte 1, UF
>becf		d6 be 1f 89 33 89		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bed5		3e				        .text ">"
.bed6						nt_zero_equal:
>bed6		02 10				        .byte 2, UF
>bed8		e0 be a6 96 b7 96		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bede		30 3d				        .text "0="
.bee0						nt_zero_unequal:
>bee0		03 10				        .byte 3, UF
>bee2		eb be dc 96 eb 96		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bee8		30 3c 3e			        .text "0<>"
.beeb						nt_zero_greater:
>beeb		02 10				        .byte 2, UF
>beed		f5 be b8 96 cb 96		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bef3		30 3e				        .text "0>"
.bef5						nt_zero_less:
>bef5		02 10				        .byte 2, UF
>bef7		ff be cc 96 db 96		        .word nt_min, xt_zero_less, z_zero_less
>befd		30 3c				        .text "0<"
.beff						nt_min:
>beff		03 10				        .byte 3, UF
>bf01		0a bf f3 8b 0e 8c		        .word nt_max, xt_min, z_min
>bf07		6d 69 6e			        .text "min"
.bf0a						nt_max:
>bf0a		03 10				        .byte 3, UF
>bf0c		15 bf d7 8b f2 8b		        .word nt_two_drop, xt_max, z_max
>bf12		6d 61 78			        .text "max"
.bf15						nt_two_drop:
>bf15		05 10				        .byte 5, UF
>bf17		22 bf d1 93 d8 93		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf1d		32 64 72 6f 70			        .text "2drop"
.bf22						nt_two_swap:
>bf22		05 10				        .byte 5, UF
>bf24		2f bf 9f 94 c2 94		        .word nt_two_over, xt_two_swap, z_two_swap
>bf2a		32 73 77 61 70			        .text "2swap"
.bf2f						nt_two_over:
>bf2f		05 10				        .byte 5, UF
>bf31		3c bf 13 94 2a 94		        .word nt_two_store, xt_two_over, z_two_over
>bf37		32 6f 76 65 72			        .text "2over"
.bf3c						nt_two_store:
>bf3c		02 10				        .byte 2, UF
>bf3e		46 bf 79 94 9e 94		        .word nt_two_fetch, xt_two_store, z_two_store
>bf44		32 21				        .text "2!"
.bf46						nt_two_fetch:
>bf46		02 10				        .byte 2, UF
>bf48		50 bf f1 93 12 94		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf4e		32 40				        .text "2@"
.bf50						nt_two_variable:
>bf50		09 00				        .byte 9, 0
>bf52		61 bf b0 9f be 9f		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf58		32 76 61 72 69 61 62 6c		        .text "2variable"
>bf60		65
.bf61						nt_two_constant:
>bf61		09 10				        .byte 9, UF
>bf63		72 bf 73 9f 97 9f		        .word nt_two_literal, xt_two_constant, z_two_constant
>bf69		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bf71		74
.bf72						nt_two_literal:
>bf72		08 14				        .byte 8, UF+IM
>bf74		82 bf 98 9f af 9f		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bf7a		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bf82						nt_two_r_fetch:
>bf82		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bf84		8d bf 2b 94 48 94		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bf8a		32 72 40			        .text "2r@"
.bf8d						nt_two_r_from:
>bf8d		03 01				        .byte 3, CO             ; native is special case
>bf8f		98 bf 49 94 65 94		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bf95		32 72 3e			        .text "2r>"
.bf98						nt_two_to_r:
>bf98		03 11				        .byte 3, CO+UF          ; native is special case
>bf9a		a3 bf c3 94 e2 94		        .word nt_invert, xt_two_to_r, z_two_to_r
>bfa0		32 3e 72			        .text "2>r"
.bfa3						nt_invert:
>bfa3		06 10				        .byte 6, UF
>bfa5		b1 bf 7d 89 8c 89		        .word nt_negate, xt_invert, z_invert
>bfab		69 6e 76 65 72 74		        .text "invert"
.bfb1						nt_negate:
>bfb1		06 10				        .byte 6, UF
>bfb3		bf bf 4d 8c 5d 8c		        .word nt_dnegate, xt_negate, z_negate
>bfb9		6e 65 67 61 74 65		        .text "negate"
.bfbf						nt_dnegate:
>bfbf		07 10				        .byte 7, UF
>bfc1		ce bf a7 9e c1 9e		        .word nt_c_comma, xt_dnegate, z_dnegate
>bfc7		64 6e 65 67 61 74 65		        .text "dnegate"
.bfce						nt_c_comma:
>bfce		02 10				        .byte 2, UF
>bfd0		d8 bf 22 83 2c 83		        .word nt_bounds, xt_c_comma, z_c_comma
>bfd6		63 2c				        .text "c,"
.bfd8						nt_bounds:
>bfd8		06 10				        .byte 6, UF
>bfda		e6 bf 6b 9a 83 9a		        .word nt_spaces, xt_bounds, z_bounds
>bfe0		62 6f 75 6e 64 73		        .text "bounds"
.bfe6						nt_spaces:
>bfe6		06 10				        .byte 6, UF
>bfe8		f4 bf fc 91 15 92		        .word nt_bl, xt_spaces, z_spaces
>bfee		73 70 61 63 65 73		        .text "spaces"
.bff4						nt_bl:
>bff4		02 00				        .byte 2, 0
>bff6		fe bf 04 83 0c 83		        .word nt_minus_trailing, xt_bl, z_bl
>bffc		62 6c				        .text "bl"
.bffe						nt_minus_trailing:
>bffe		09 10				        .byte 9, UF
>c000		0f c0 e5 a0 21 a1		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c006		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c00e		67
.c00f						nt_minus_leading:
>c00f		08 10				        .byte 8, UF
>c011		1f c0 cc a0 e4 a0		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c017		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c01f						nt_slash_string:
>c01f		07 10				        .byte 7, UF
>c021		2e c0 c1 a1 e0 a1		        .word nt_refill, xt_slash_string, z_slash_string
>c027		2f 73 74 72 69 6e 67		        .text "/string"
.c02e						nt_refill:
>c02e		06 00				        .byte 6, 0
>c030		3c c0 66 8f a7 8f		        .word nt_accept, xt_refill, z_refill
>c036		72 65 66 69 6c 6c		        .text "refill"
.c03c						nt_accept:
>c03c		06 18				        .byte 6, UF+NN
>c03e		4a c0 e4 80 dc 81		        .word nt_input_to_r, xt_accept, z_accept
>c044		61 63 63 65 70 74		        .text "accept"
.c04a						nt_input_to_r:
>c04a		07 08				        .byte 7, NN
>c04c		59 c0 da 9b ef 9b		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c052		69 6e 70 75 74 3e 72		        .text "input>r"
.c059						nt_r_to_input:
>c059		07 08				        .byte 7, NN
>c05b		68 c0 e7 9d fe 9d		        .word nt_unused, xt_r_to_input, z_r_to_input
>c061		72 3e 69 6e 70 75 74		        .text "r>input"
.c068						nt_unused:
>c068		06 00				        .byte 6, 0
>c06a		76 c0 07 96 16 96		        .word nt_depth, xt_unused, z_unused
>c070		75 6e 75 73 65 64		        .text "unused"
.c076						nt_depth:
>c076		05 00				        .byte 5, 0
>c078		83 c0 58 85 66 85		        .word nt_key, xt_depth, z_depth
>c07e		64 65 70 74 68			        .text "depth"
.c083						nt_key:
>c083		03 00				        .byte 3, 0
>c085		8e c0 c0 89 c9 89		        .word nt_keyq, xt_key, z_key
>c08b		6b 65 79			        .text "key"
.c08e						nt_keyq:
>c08e		04 00				        .byte 4, 0
>c090		9a c0 cd 89 db 89		        .word nt_allot, xt_keyq, z_keyq
>c096		6b 65 79 3f			        .text "key?"
.c09a						nt_allot:
>c09a		05 10				        .byte 5, UF
>c09c		a7 c0 27 82 8f 82		        .word nt_create, xt_allot, z_allot
>c0a2		61 6c 6c 6f 74			        .text "allot"
.c0a7						nt_create:
>c0a7		06 00				        .byte 6, 0
>c0a9		b5 c0 40 84 09 85		        .word nt_does, xt_create, z_create
>c0af		63 72 65 61 74 65		        .text "create"
.c0b5						nt_does:
>c0b5		05 05				        .byte 5, CO+IM
>c0b7		c2 c0 f5 85 03 86		        .word nt_variable, xt_does, z_does
>c0bd		64 6f 65 73 3e			        .text "does>"
.c0c2						nt_variable:
>c0c2		08 00				        .byte 8, 0
>c0c4		d2 c0 17 96 2f 96		        .word nt_constant, xt_variable, z_variable
>c0ca		76 61 72 69 61 62 6c 65		        .text "variable"
.c0d2						nt_constant:
>c0d2		08 10				        .byte 8, UF
>c0d4		e2 c0 e8 83 25 84		        .word nt_value, xt_constant, z_constant
>c0da		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c0e2						nt_value:
>c0e2		05 10				        .byte 5, UF
>c0e4		ef c0 e8 83 25 84		        .word nt_to, xt_value, z_value          ; same code as CONSTANT
>c0ea		76 61 6c 75 65			        .text "value"
.c0ef						nt_to:
>c0ef		02 0c				        .byte 2, NN+IM
>c0f1		f9 c0 90 92 cb 92		        .word nt_s_to_d, xt_to, z_to
>c0f7		74 6f				        .text "to"
.c0f9						nt_s_to_d:
>c0f9		03 10				        .byte 3, UF
>c0fb		04 c1 05 91 16 91		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c101		73 3e 64			        .text "s>d"
.c104						nt_d_to_s:
>c104		03 10				        .byte 3, UF
>c106		0f c1 82 9e 87 9e		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c10c		64 3e 73			        .text "d>s"
.c10f						nt_d_minus:
>c10f		02 10				        .byte 2, UF
>c111		19 c1 40 9e 60 9e		        .word nt_d_plus, xt_d_minus, z_d_minus
>c117		64 2d				        .text "d-"
.c119						nt_d_plus:
>c119		02 10				        .byte 2, UF
>c11b		23 c1 61 9e 81 9e		        .word nt_erase, xt_d_plus, z_d_plus
>c121		64 2b				        .text "d+"
.c123						nt_erase:
>c123		05 10				        .byte 5, UF
>c125		30 c1 d0 87 1d 88		        .word nt_blank, xt_erase, z_erase
>c12b		65 72 61 73 65			        .text "erase"
.c130						nt_blank:
>c130		05 10				        .byte 5, UF
>c132		3d c1 c3 87 1d 88		        .word nt_fill, xt_blank, z_blank
>c138		62 6c 61 6e 6b			        .text "blank"
.c13d						nt_fill:
>c13d		04 10				        .byte 4, UF
>c13f		49 c1 db 87 1d 88		        .word nt_find_name, xt_fill, z_fill
>c145		66 69 6c 6c			        .text "fill"
.c149						nt_find_name:
>c149		09 10				        .byte 9, UF
>c14b		5a c1 2d 9b 70 9b		        .word nt_tick, xt_find_name, z_find_name
>c151		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c159		65
.c15a						nt_tick:
>c15a		01 00				        .byte 1, 0
>c15c		63 c1 70 92 8f 92		        .word nt_bracket_tick, xt_tick, z_tick
>c162		27				        .text "'"
.c163						nt_bracket_tick:
>c163		03 05				        .byte 3, CO+IM
>c165		6e c1 14 83 1a 83		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c16b		5b 27 5d			        .text "[']"
.c16e						nt_name_to_int:
>c16e		08 10				        .byte 8, UF
>c170		7e c1 76 9c 92 9c		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c176		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c17e						nt_int_to_name:
>c17e		08 10				        .byte 8, UF
>c180		8e c1 f0 9b 60 9c		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c186		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c18e						nt_name_to_string:
>c18e		0b 10				        .byte 11, UF
>c190		a1 c1 93 9c a9 9c		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c196		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c19e		69 6e 67
.c1a1						nt_to_body:
>c1a1		05 10				        .byte 5, UF
>c1a3		ae c1 cc 92 ee 92		        .word nt_defer, xt_to_body, z_to_body
>c1a9		3e 62 6f 64 79			        .text ">body"
.c1ae						nt_defer:
>c1ae		05 00				        .byte 5, 0
>c1b0		bb c1 11 85 43 85		        .word nt_latestxt, xt_defer, z_defer
>c1b6		64 65 66 65 72			        .text "defer"
.c1bb						nt_latestxt:
>c1bb		08 00				        .byte 8, 0
>c1bd		cb c1 6f 9c 75 9c		        .word nt_latestnt, xt_latestxt, z_latestxt
>c1c3		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c1cb						nt_latestnt:
>c1cb		08 00				        .byte 8, 0
>c1cd		db c1 61 9c 6e 9c		        .word nt_parse_name, xt_latestnt, z_latestnt
>c1d3		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c1db						nt_parse_name:
>c1db		0a 08				        .byte 10, NN
>c1dd		ed c1 7b 8d 6b 8e		        .word nt_parse, xt_parse_name, z_parse_name
>c1e3		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c1eb		6d 65
.c1ed						nt_parse:
>c1ed		05 10				        .byte 5, UF
>c1ef		fa c1 d6 8d 6b 8e		        .word nt_execute_parsing, xt_parse, z_parse
>c1f5		70 61 72 73 65			        .text "parse"
.c1fa						nt_execute_parsing:
>c1fa		0f 10				        .byte 15, UF
>c1fc		11 c2 06 9b 2c 9b		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c202		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c20a		70 61 72 73 69 6e 67
.c211						nt_source:
>c211		06 00				        .byte 6, 0
>c213		1f c2 d6 91 ea 91		        .word nt_source_id, xt_source, z_source
>c219		73 6f 75 72 63 65		        .text "source"
.c21f						nt_source_id:
>c21f		09 00				        .byte 9, 0
>c221		30 c2 eb 91 f5 91		        .word nt_colon, xt_source_id, z_source_id
>c227		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c22f		64
.c230						nt_colon:
>c230		01 00				        .byte 1, 0
>c232		39 c2 6e 83 b0 83		        .word nt_semicolon, xt_colon, z_colon
>c238		3a				        .text ":"
.c239						nt_semicolon:
>c239		01 05				        .byte 1, CO+IM
>c23b		42 c2 17 91 75 91		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c241		3b				        .text ";"
.c242						nt_colon_noname:
>c242		07 00				        .byte 7, 0
>c244		51 c2 b1 83 cc 83		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c24a		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c251						nt_compile_comma:
>c251		08 18				        .byte 8, UF+NN
>c253		61 c2 ec 96 b7 97		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c259		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c261						nt_left_bracket:
>c261		01 05				        .byte 1, IM+CO
>c263		6a c2 f5 89 f9 89		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c269		5b				        .text "["
.c26a						nt_right_bracket:
>c26a		01 04				        .byte 1, IM
>c26c		73 c2 b1 8f b7 8f		        .word nt_literal, xt_right_bracket, z_right_bracket
>c272		5d				        .text "]"
.c273						nt_literal:
>c273		07 15				        .byte 7, IM+CO+UF
>c275		82 c2 1d 8a 5a 8a		        .word nt_sliteral, xt_literal, z_literal
>c27b		6c 69 74 65 72 61 6c		        .text "literal"
.c282						nt_sliteral:
>c282		08 15				        .byte 8, CO+IM+UF
>c284		92 c2 e1 a1 24 a2		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c28a		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c292						nt_dot_quote:
>c292		02 05				        .byte 2, CO+IM
>c294		9c c2 67 86 71 86		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c29a		2e 22				        .text ".", $22
.c29c						nt_s_quote:
>c29c		02 0c				        .byte 2, IM+NN
>c29e		a6 c2 01 90 ea 90		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2a4		73 22				        .text "s", $22
.c2a6						nt_s_backslash_quote:
>c2a6		03 04				        .byte 3, IM
>c2a8		b1 c2 e8 8f f1 8f		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2ae		73 5c 22			        .text "s", $5C, $22
.c2b1						nt_postpone:
>c2b1		08 05				        .byte 8, IM+CO
>c2b3		c1 c2 b0 8e ee 8e		        .word nt_immediate, xt_postpone, z_postpone
>c2b9		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c2c1						nt_immediate:
>c2c1		09 00				        .byte 9, 0
>c2c3		d2 c2 71 89 7c 89		        .word nt_compile_only, xt_immediate, z_immediate
>c2c9		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c2d1		65
.c2d2						nt_compile_only:
>c2d2		0c 00				        .byte 12, 0
>c2d4		e6 c2 dc 83 e7 83		        .word nt_never_native, xt_compile_only, z_compile_only
>c2da		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c2e2		6f 6e 6c 79
.c2e6						nt_never_native:
>c2e6		0c 00				        .byte 12, 0
>c2e8		fa c2 af 9c bc 9c		        .word nt_always_native, xt_never_native, z_never_native
>c2ee		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c2f6		74 69 76 65
.c2fa						nt_always_native:
>c2fa		0d 00				        .byte 13, 0
>c2fc		0f c3 57 9a 64 9a		        .word nt_allow_native, xt_always_native, z_always_native
>c302		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c30a		61 74 69 76 65
.c30f						nt_allow_native:
>c30f		0c 00				        .byte 12, 0
>c311		23 c3 4b 9a 56 9a		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c317		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c31f		74 69 76 65
.c323						nt_nc_limit:
>c323		08 08				        .byte 8, NN
>c325		33 c3 aa 9c af 9c		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c32b		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c333						nt_strip_underflow:
>c333		0f 08				        .byte 15, NN
>c335		4a c3 ff 9d 04 9e		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c33b		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c343		64 65 72 66 6c 6f 77
.c34a						nt_abort:
>c34a		05 00				        .byte 5, 0
>c34c		57 c3 5e 80 af 80		        .word nt_abort_quote, xt_abort, z_abort
>c352		61 62 6f 72 74			        .text "abort"
.c357						nt_abort_quote:
>c357		06 0d				        .byte 6, CO+IM+NN
>c359		65 c3 af 80 b9 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c35f		61 62 6f 72 74 22		        .text "abort", $22
.c365						nt_do:
>c365		02 0d				        .byte 2, CO+IM+NN
>c367		6f c3 91 85 aa 85		        .word nt_question_do, xt_do, z_do
>c36d		64 6f				        .text "do"
.c36f						nt_question_do:
>c36f		03 0d				        .byte 3, CO+IM+NN
>c371		7a c3 67 85 aa 85		        .word nt_i, xt_question_do, z_question_do
>c377		3f 64 6f			        .text "?do"
.c37a						nt_i:
>c37a		01 01				        .byte 1, CO
>c37c		83 c3 58 89 6c 89		        .word nt_j, xt_i, z_i
>c382		69				        .text "i"
.c383						nt_j:
>c383		01 01				        .byte 1, CO
>c385		8c c3 a6 89 bf 89		        .word nt_loop, xt_j, z_j
>c38b		6a				        .text "j"
.c38c						nt_loop:
>c38c		04 05				        .byte 4, CO+IM
>c38e		98 c3 84 8a fc 8a		        .word nt_plus_loop, xt_loop, z_loop
>c394		6c 6f 6f 70			        .text "loop"
.c398						nt_plus_loop:
>c398		05 05				        .byte 5, CO+IM
>c39a		a5 c3 98 8a fc 8a		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3a0		2b 6c 6f 6f 70			        .text "+loop"
.c3a5						nt_exit:
>c3a5		04 03				        .byte 4, AN+CO
>c3a7		b1 c3 32 88 33 88		        .word nt_unloop, xt_exit, z_exit
>c3ad		65 78 69 74			        .text "exit"
.c3b1						nt_unloop:
>c3b1		06 01				        .byte 6, CO
>c3b3		bf c3 f0 95 ff 95		        .word nt_leave, xt_unloop, z_unloop
>c3b9		75 6e 6c 6f 6f 70		        .text "unloop"
.c3bf						nt_leave:
>c3bf		05 05				        .byte 5, CO+IM
>c3c1		cc c3 df 89 f4 89		        .word nt_recurse, xt_leave, z_leave
>c3c7		6c 65 61 76 65			        .text "leave"
.c3cc						nt_recurse:
>c3cc		07 0d				        .byte 7, CO+IM+NN
>c3ce		db c3 29 8f 65 8f		        .word nt_quit, xt_recurse, z_recurse
>c3d4		72 65 63 75 72 73 65		        .text "recurse"
.c3db						nt_quit:
>c3db		04 00				        .byte 4, 0
>c3dd		e7 c3 60 80 af 80		        .word nt_begin, xt_quit, z_quit
>c3e3		71 75 69 74			        .text "quit"
.c3e7						nt_begin:
>c3e7		05 05				        .byte 5, CO+IM
>c3e9		f4 c3 34 89 3e 89		        .word nt_again, xt_begin, z_begin
>c3ef		62 65 67 69 6e			        .text "begin"
.c3f4						nt_again:
>c3f4		05 15				        .byte 5, CO+IM+UF
>c3f6		01 c4 1f 82 25 82		        .word nt_state, xt_again, z_again
>c3fc		61 67 61 69 6e			        .text "again"
.c401						nt_state:
>c401		05 00				        .byte 5, 0
>c403		0e c4 3b 92 45 92		        .word nt_evaluate, xt_state, z_state
>c409		73 74 61 74 65			        .text "state"
.c40e						nt_evaluate:
>c40e		08 10				        .byte 8, UF
>c410		1e c4 cb 88 1e 89		        .word nt_base, xt_evaluate, z_evaluate
>c416		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c41e						nt_base:
>c41e		04 00				        .byte 4, 0
>c420		2a c4 fb 82 03 83		        .word nt_digit_question, xt_base, z_base
>c426		62 61 73 65			        .text "base"
.c42a						nt_digit_question:
>c42a		06 10				        .byte 6, UF
>c42c		38 c4 d1 9a 05 9b		        .word nt_number, xt_digit_question, z_digit_question
>c432		64 69 67 69 74 3f		        .text "digit?"
.c438						nt_number:
>c438		06 10				        .byte 6, UF
>c43a		46 c4 d9 9c d2 9d		        .word nt_to_number, xt_number, z_number
>c440		6e 75 6d 62 65 72		        .text "number"
.c446						nt_to_number:
>c446		07 10				        .byte 7, UF
>c448		55 c4 fa 92 99 93		        .word nt_hex, xt_to_number, z_to_number
>c44e		3e 6e 75 6d 62 65 72		        .text ">number"
.c455						nt_hex:
>c455		03 00				        .byte 3, 0
>c457		60 c4 3f 89 45 89		        .word nt_decimal, xt_hex, z_hex
>c45d		68 65 78			        .text "hex"
.c460						nt_decimal:
>c460		07 00				        .byte 7, 0
>c462		6f c4 0a 85 10 85		        .word nt_count, xt_decimal, z_decimal
>c468		64 65 63 69 6d 61 6c		        .text "decimal"
.c46f						nt_count:
>c46f		05 10				        .byte 5, UF
>c471		7c c4 26 84 39 84		        .word nt_m_star, xt_count, z_count
>c477		63 6f 75 6e 74			        .text "count"
.c47c						nt_m_star:
>c47c		02 10				        .byte 2, UF
>c47e		86 c4 4c 8b 66 8b		        .word nt_um_star, xt_m_star, z_m_star
>c484		6d 2a				        .text "m*"
.c486						nt_um_star:
>c486		03 10				        .byte 3, UF
>c488		91 c4 aa 95 ef 95		        .word nt_star, xt_um_star, z_um_star
>c48e		75 6d 2a			        .text "um*"
.c491						nt_star:
>c491		01 10				        .byte 1, UF
>c493		9a c4 16 92 1e 92		        .word nt_um_slash_mod, xt_star, z_star
>c499		2a				        .text "*"
.c49a						nt_um_slash_mod:
>c49a		06 10				        .byte 6, UF
>c49c		a8 c4 68 95 a9 95		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4a2		75 6d 2f 6d 6f 64		        .text "um/mod"
.c4a8						nt_sm_slash_rem:
>c4a8		06 10				        .byte 6, UF
>c4aa		b6 c4 ad 91 d5 91		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c4b0		73 6d 2f 72 65 6d		        .text "sm/rem"
.c4b6						nt_fm_slash_mod:
>c4b6		06 10				        .byte 6, UF
>c4b8		c4 c4 8e 88 c4 88		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c4be		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c4c4						nt_slash:
>c4c4		01 10				        .byte 1, UF
>c4c6		cd c4 8b 91 ac 91		        .word nt_slash_mod, xt_slash, z_slash
>c4cc		2f				        .text "/"
.c4cd						nt_slash_mod:
>c4cd		04 10				        .byte 4, UF
>c4cf		d9 c4 92 91 ac 91		        .word nt_mod, xt_slash_mod, z_slash_mod
>c4d5		2f 6d 6f 64			        .text "/mod"
.c4d9						nt_mod:
>c4d9		03 10				        .byte 3, UF
>c4db		e4 c4 22 8c 2a 8c		        .word nt_star_slash_mod, xt_mod, z_mod
>c4e1		6d 6f 64			        .text "mod"
.c4e4						nt_star_slash_mod:
>c4e4		05 10				        .byte 5, UF
>c4e6		f1 c4 2b 92 3a 92		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c4ec		2a 2f 6d 6f 64			        .text "*/mod"
.c4f1						nt_star_slash:
>c4f1		02 10				        .byte 2, UF
>c4f3		fb c4 1f 92 2a 92		        .word nt_backslash, xt_star_slash, z_star_slash
>c4f9		2a 2f				        .text "*/"
.c4fb						nt_backslash:
>c4fb		01 04				        .byte 1, IM
>c4fd		04 c5 d0 82 fa 82		        .word nt_move, xt_backslash, z_backslash
>c503		5c				        .byte '\'
.c504						nt_move:
>c504		04 18				        .byte 4, NN+UF
>c506		10 c5 2b 8c 4c 8c		        .word nt_cmove_up, xt_move, z_move
>c50c		6d 6f 76 65			        .text "move"
.c510						nt_cmove_up:
>c510		06 10				        .byte 6, UF
>c512		1e c5 2c a0 66 a0		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c518		63 6d 6f 76 65 3e		        .text "cmove>"
.c51e						nt_cmove:
>c51e		05 10				        .byte 5, UF
>c520		2b c5 f1 9f 2b a0		        .word nt_pad, xt_cmove, z_cmove
>c526		63 6d 6f 76 65			        .text "cmove"
.c52b						nt_pad:
>c52b		03 00				        .byte 3, 0
>c52d		36 c5 3d 8d 4c 8d		        .word nt_cleave, xt_pad, z_pad
>c533		70 61 64			        .text "pad"
.c536						nt_cleave:
>c536		06 10				        .byte 6, UF
>c538		44 c5 84 9a d0 9a		        .word nt_hexstore, xt_cleave, z_cleave
>c53e		63 6c 65 61 76 65		        .text "cleave"
.c544						nt_hexstore:
>c544		08 10				        .byte 8, UF
>c546		54 c5 7c 9b ce 9b		        .word nt_within, xt_hexstore, z_hexstore
>c54c		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c554						nt_within:
>c554		06 10				        .byte 6, UF
>c556		62 c5 3a 96 4f 96		        .word nt_to_in, xt_within, z_within
>c55c		77 69 74 68 69 6e		        .text "within"
.c562						nt_to_in:
>c562		03 00				        .byte 3, 0
>c564		6d c5 ef 92 f9 92		        .word nt_less_number_sign, xt_to_in, z_to_in
>c56a		3e 69 6e			        .text ">in"
.c56d						nt_less_number_sign:
>c56d		02 00				        .byte 2, 0
>c56f		77 c5 fa 89 07 8a		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c575		3c 23				        .text "<#"
.c577						nt_number_sign:
>c577		01 10				        .byte 1, UF
>c579		80 c5 8a 8c ba 8c		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c57f		23				        .text "#"
.c580						nt_number_sign_s:
>c580		02 10				        .byte 2, UF
>c582		8a c5 dd 8c ed 8c		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c588		23 73				        .text "#s"
.c58a						nt_number_sign_greater:
>c58a		02 10				        .byte 2, UF
>c58c		94 c5 bb 8c dc 8c		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c592		23 3e				        .text "#>"
.c594						nt_hold:
>c594		04 10				        .byte 4, UF
>c596		a0 c5 46 89 57 89		        .word nt_sign, xt_hold, z_hold
>c59c		68 6f 6c 64			        .text "hold"
.c5a0						nt_sign:
>c5a0		04 10				        .byte 4, UF
>c5a2		ac c5 76 91 8a 91		        .word nt_output, xt_sign, z_sign
>c5a8		73 69 67 6e			        .text "sign"
.c5ac						nt_output:
>c5ac		06 00				        .byte 6, 0
>c5ae		ba c5 dc 9d e6 9d		        .word nt_input, xt_output, z_output
>c5b4		6f 75 74 70 75 74		        .text "output"
.c5ba						nt_input:
>c5ba		05 00				        .byte 5, 0
>c5bc		c7 c5 cf 9b d9 9b		        .word nt_havekey, xt_input, z_input
>c5c2		69 6e 70 75 74			        .text "input"
.c5c7						nt_havekey:
>c5c7		07 00				        .byte 7, 0
>c5c9		d6 c5 71 9b 7b 9b		        .word nt_cr, xt_havekey, z_havekey
>c5cf		68 61 76 65 6b 65 79		        .text "havekey"
.c5d6						nt_cr:
>c5d6		02 00				        .byte 2, 0
>c5d8		e0 c5 3a 84 3f 84		        .word nt_page, xt_cr, z_cr
>c5de		63 72				        .text "cr"
.c5e0						nt_page:
>c5e0		04 00				        .byte 4, 0
>c5e2		ec c5 4d 8d 6a 8d		        .word nt_at_xy, xt_page, z_page
>c5e8		70 61 67 65			        .text "page"
.c5ec						nt_at_xy:
>c5ec		05 10				        .byte 5, UF
>c5ee		f9 c5 a2 82 cf 82		        .word nt_marker, xt_at_xy, z_at_xy
>c5f4		61 74 2d 78 79			        .text "at-xy"
.c5f9						nt_marker:
>c5f9		06 04				        .byte 6, IM
>c5fb		07 c6 67 8b a1 8b		        .word nt_words, xt_marker, z_marker
>c601		6d 61 72 6b 65 72		        .text "marker"
.c607						nt_words:
>c607		05 00				        .byte 5, 0
>c609		14 c6 ee 99 4a 9a		        .word nt_wordsize, xt_words, z_words
>c60f		77 6f 72 64 73			        .text "words"
.c614						nt_wordsize:
>c614		08 10				        .byte 8, UF
>c616		24 c6 18 9e 38 9e		        .word nt_aligned, xt_wordsize, z_wordsize
>c61c		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c624						nt_aligned:
>c624		07 00				        .byte 7, 0
>c626		33 c6 26 82 26 82		        .word nt_align, xt_aligned, z_aligned   ; same code as ALIGN
>c62c		61 6c 69 67 6e 65 64		        .text "aligned"
.c633						nt_align:
>c633		05 00				        .byte 5, 0
>c635		40 c6 26 82 26 82		        .word nt_bell, xt_align, z_align
>c63b		61 6c 69 67 6e			        .text "align"
.c640						nt_bell:
>c640		04 00				        .byte 4, 0
>c642		4c c6 65 9a 6a 9a		        .word nt_dump, xt_bell, z_bell
>c648		62 65 6c 6c			        .text "bell"
.c64c						nt_dump:
>c64c		04 10				        .byte 4, UF
>c64e		58 c6 de 98 44 99		        .word nt_dot_s, xt_dump, z_dump
>c654		64 75 6d 70			        .text "dump"
.c658						nt_dot_s:
>c658		02 00				        .byte 2, 0
>c65a		62 c6 9a 98 dd 98		        .word +, xt_dot_s, z_dot_s
>c660		2e 73				        .text ".s"
.c662						+
.c662						nt_disasm:
>c662		06 10				        .byte 6, UF
>c664		70 c6 4d a2 53 a2		        .word +, xt_disasm, z_disasm
>c66a		64 69 73 61 73 6d		        .text "disasm"
.c670						+
.c670						nt_compare:
>c670		07 10				        .byte 7, UF
>c672		7f c6 67 a0 cb a0		        .word nt_search, xt_compare, z_compare
>c678		63 6f 6d 70 61 72 65		        .text "compare"
.c67f						nt_search:
>c67f		06 18				        .byte 6, UF+NN
>c681		8d c6 22 a1 c0 a1		        .word +, xt_search, z_search
>c687		73 65 61 72 63 68		        .text "search"
.c68d						+
.c68d						nt_environment_q:
>c68d		0c 10				        .byte 12, UF
>c68f		a1 c6 ee 86 6a 87		        .word +, xt_environment_q, z_environment_q
>c695		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c69d		65 6e 74 3f
.c6a1						+
.c6a1						nt_find:
>c6a1		04 10				        .byte 4, UF
>c6a3		ad c6 46 88 8d 88		        .word nt_word, xt_find, z_find
>c6a9		66 69 6e 64			        .text "find"
.c6ad						nt_word:
>c6ad		04 10				        .byte 4, UF
>c6af		b9 c6 50 96 93 96		        .word nt_paren, xt_word, z_word
>c6b5		77 6f 72 64			        .text "word"
.c6b9						nt_paren:
>c6b9		01 04				        .byte 1, IM
>c6bb		c2 c6 6b 8d 7a 8d		        .word nt_dot_paren, xt_paren, z_paren
>c6c1		28				        .text "("
.c6c2						nt_dot_paren:
>c6c2		02 04				        .byte 2, IM
>c6c4		cc c6 58 86 66 86		        .word nt_if, xt_dot_paren, z_dot_paren
>c6ca		2e 28				        .text ".("
.c6cc						nt_if:
>c6cc		02 0d				        .byte 2, IM+CO+NN
>c6ce		d6 c6 6d 89 70 89		        .word nt_then, xt_if, z_if
>c6d4		69 66				        .text "if"
.c6d6						nt_then:
>c6d6		04 1d				        .byte 4, UF+IM+CO+NN
>c6d8		e2 c6 bf 86 cb 86		        .word nt_else, xt_then, z_then
>c6de		74 68 65 6e			        .text "then"
.c6e2						nt_else:
>c6e2		04 1d				        .byte 4, UF+IM+CO+NN
>c6e4		ee c6 b4 86 cb 86		        .word nt_repeat, xt_else, z_else
>c6ea		65 6c 73 65			        .text "else"
.c6ee						nt_repeat:
>c6ee		06 1d				        .byte 6, UF+IM+CO+NN
>c6f0		fc c6 a8 8f b1 8f		        .word nt_until, xt_repeat, z_repeat
>c6f6		72 65 70 65 61 74		        .text "repeat"
.c6fc						nt_until:
>c6fc		05 1d				        .byte 5, UF+IM+CO+NN
>c6fe		09 c7 00 96 06 96		        .word nt_while, xt_until, z_until
>c704		75 6e 74 69 6c			        .text "until"
.c709						nt_while:
>c709		05 1d				        .byte 5, UF+IM+CO+NN
>c70b		16 c7 30 96 39 96		        .word nt_case, xt_while, z_while
>c711		77 68 69 6c 65			        .text "while"
.c716						nt_case:
>c716		04 0d				        .byte 4, IM+CO+NN
>c718		22 c7 39 9e 3f 9e		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c71e		63 61 73 65			        .text "case"
.c722						nt_of:
>c722		02 0d				        .byte 2, IM+CO+NN
>c724		2c c7 ee 8c 06 8d		        .word nt_endof, xt_of, z_of
>c72a		6f 66				        .text "of"
.c72c						nt_endof:
>c72c		05 0d				        .byte 5, IM+CO+NN
>c72e		39 c7 b4 86 cb 86		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c734		65 6e 64 6f 66			        .text "endof"
.c739						nt_endcase:
>c739		07 1d				        .byte 7, UF+IM+CO+NN
>c73b		48 c7 d6 86 ed 86		        .word nt_defer_fetch, xt_endcase, z_endcase
>c741		65 6e 64 63 61 73 65		        .text "endcase"
.c748						nt_defer_fetch:
>c748		06 10				        .byte 6, UF
>c74a		56 c7 44 85 4d 85		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c750		64 65 66 65 72 40		        .text "defer@"
.c756						nt_defer_store:
>c756		06 10				        .byte 6, UF
>c758		64 c7 4e 85 57 85		        .word nt_is, xt_defer_store, z_defer_store
>c75e		64 65 66 65 72 21		        .text "defer!"
.c764						nt_is:
>c764		02 04				        .byte 2, IM
>c766		6e c7 8d 89 a5 89		        .word nt_action_of, xt_is, z_is
>c76c		69 73				        .text "is"
.c76e						nt_action_of:
>c76e		09 04				        .byte 9, IM
>c770		7f c7 06 82 1e 82		        .word nt_useraddr, xt_action_of, z_action_of
>c776		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c77e		66
.c77f						nt_useraddr:
>c77f		08 00				        .byte 8, 0
>c781		8f c7 0d 9e 17 9e		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c787		75 73 65 72 61 64 64 72		        .text "useraddr"
.c78f						nt_buffer_colon:
>c78f		07 00				        .byte 7, 0
>c791		9e c7 1b 83 21 83		        .word +, xt_buffer_colon, z_buffer_colon
>c797		62 75 66 66 65 72 3a		        .text "buffer:"
.c79e						+
.c79e						nt_buffstatus:
>c79e		0a 00				        .byte 10, 0
>c7a0		b0 c7 9f b0 a4 b0		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7a6		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7ae		75 73
.c7b0						nt_buffblocknum:
>c7b0		0c 00				        .byte 12, 0
>c7b2		c4 c7 69 b0 6e b0		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7b8		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c7c0		6b 6e 75 6d
.c7c4						nt_blkbuffer:
>c7c4		09 00				        .byte 9, 0
>c7c6		d5 c7 5f ae 6c ae		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c7cc		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c7d4		72
.c7d5						nt_scr:
>c7d5		03 08				        .byte 3, NN
>c7d7		e0 c7 21 b1 26 b1		        .word nt_blk, xt_scr, z_scr
>c7dd		73 63 72			        .text "scr"
.c7e0						nt_blk:
>c7e0		03 08				        .byte 3, NN
>c7e2		eb c7 5a ae 5f ae		        .word nt_block_write, xt_blk, z_blk
>c7e8		62 6c 6b			        .text "blk"
.c7eb						nt_block_write:
>c7eb		0b 08				        .byte 11, NN
>c7ed		fe c7 56 b0 64 b0		        .word nt_block_write_vector, xt_block_write, z_block_write
>c7f3		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c7fb		69 74 65
.c7fe						nt_block_write_vector:
>c7fe		12 08				        .byte 18, NN
>c800		18 c8 64 b0 69 b0		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c806		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c80e		69 74 65 2d 76 65 63 74 6f 72
.c818						nt_block_read:
>c818		0a 08				        .byte 10, NN
>c81a		2a c8 3e b0 4c b0		        .word nt_block_read_vector, xt_block_read, z_block_read
>c820		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c828		61 64
.c82a						nt_block_read_vector:
>c82a		11 08				        .byte 17, NN
>c82c		43 c8 4c b0 51 b0		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c832		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c83a		61 64 2d 76 65 63 74 6f 72
.c843						nt_save_buffers:
>c843		0c 00				        .byte 12, 0
>c845		57 c8 06 b1 20 b1		        .word nt_block, xt_save_buffers, z_save_buffers
>c84b		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c853		66 65 72 73
.c857						nt_block:
>c857		05 00				        .byte 5, 0
>c859		64 c8 6d ae bf ae		        .word nt_update, xt_block, z_block
>c85f		62 6c 6f 63 6b			        .text "block"
.c864						nt_update:
>c864		06 00				        .byte 6, 0
>c866		72 c8 6b b1 73 b1		        .word nt_buffer, xt_update, z_update
>c86c		75 70 64 61 74 65		        .text "update"
.c872						nt_buffer:
>c872		06 00				        .byte 6, 0
>c874		80 c8 6e b0 9e b0		        .word nt_empty_buffers, xt_buffer, z_buffer
>c87a		62 75 66 66 65 72		        .text "buffer"
.c880						nt_empty_buffers:
>c880		0d 00				        .byte 13, 0
>c882		95 c8 a4 b0 aa b0		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c888		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c890		66 66 65 72 73
.c895						nt_flush:
>c895		05 00				        .byte 5, 0
>c897		a2 c8 ab b0 b4 b0		        .word nt_load, xt_flush, z_flush
>c89d		66 6c 75 73 68			        .text "flush"
.c8a2						nt_load:
>c8a2		04 10				        .byte 4, UF
>c8a4		ae c8 c2 b0 05 b1		        .word nt_thru, xt_load, z_load
>c8aa		6c 6f 61 64			        .text "load"
.c8ae						nt_thru:
>c8ae		04 10				        .byte 4, UF
>c8b0		ba c8 26 b1 6a b1		        .word +, xt_thru, z_thru
>c8b6		74 68 72 75			        .text "thru"
.c8ba						+
.c8ba						nt_list:
>c8ba		04 10				        .byte 4, UF
>c8bc		c6 c8 b5 b0 c1 b0		        .word nt_block_c65_init, xt_list, z_list
>c8c2		6c 69 73 74			        .text "list"
.c8c6						nt_block_c65_init:
>c8c6		0e 00				        .byte 14, 0
>c8c8		dc c8 c0 ae f5 ae		        .word +, xt_block_c65_init, z_block_c65_init
>c8ce		62 6c 6f 63 6b 2d 63 36		        .text "block-c65-init"
>c8d6		35 2d 69 6e 69 74
.c8dc						+
.c8dc						nt_block_ramdrive_init:
>c8dc		13 10				        .byte 19, UF
>c8de		f7 c8 18 af 25 af		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c8e4		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c8ec		6d 64 72 69 76 65 2d 69 6e 69 74
.c8f7						+
.c8f7						nt_definitions:
>c8f7		0b 00				        .byte 11, 0
>c8f9		0a c9 a9 b2 b1 b2		        .word nt_wordlist, xt_definitions, z_definitions
>c8ff		64 65 66 69 6e 69 74 69		        .text "definitions"
>c907		6f 6e 73
.c90a						nt_wordlist:
>c90a		08 00				        .byte 8, 0
>c90c		1a c9 14 b4 2a b4		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c912		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c91a						nt_search_wordlist:
>c91a		0f 10				        .byte 15, UF
>c91c		31 c9 4d b3 c0 b3		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c922		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c92a		6f 72 64 6c 69 73 74
.c931						nt_set_current:
>c931		0b 10				        .byte 11, UF
>c933		44 c9 c1 b3 cc b3		        .word nt_get_current, xt_set_current, z_set_current
>c939		73 65 74 2d 63 75 72 72		        .text "set-current"
>c941		65 6e 74
.c944						nt_get_current:
>c944		0b 00				        .byte 11, 0
>c946		57 c9 b9 b2 c3 b2		        .word nt_set_order, xt_get_current, z_get_current
>c94c		67 65 74 2d 63 75 72 72		        .text "get-current"
>c954		65 6e 74
.c957						nt_set_order:
>c957		09 00				        .byte 9, 0
>c959		68 c9 cd b3 00 b4		        .word nt_get_order, xt_set_order, z_set_order
>c95f		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c967		72
.c968						nt_get_order:
>c968		09 00				        .byte 9, 0
>c96a		79 c9 c4 b2 ec b2		        .word nt_root_wordlist, xt_get_order, z_get_order
>c970		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c978		72
.c979						nt_root_wordlist:
>c979		0d 00				        .byte 13, 0
>c97b		8e c9 44 b3 4c b3		        .word +, xt_root_wordlist, z_root_wordlist
>c981		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c989		64 6c 69 73 74
.c98e						+
.c98e						nt_assembler_wordlist:
>c98e		12 00				        .byte 18, 0
>c990		a8 c9 04 9e 0c 9e		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c996		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c99e		72 2d 77 6f 72 64 6c 69 73 74
.c9a8						+
.c9a8						nt_editor_wordlist:
>c9a8		0f 00				        .byte 15, 0
>c9aa		bf c9 d3 9d db 9d		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9b0		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9b8		6f 72 64 6c 69 73 74
.c9bf						+
.c9bf						nt_forth_wordlist:
>c9bf		0e 00				        .byte 14, 0
>c9c1		d5 c9 39 9e 3f 9e		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9c7		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9cf		72 64 6c 69 73 74
.c9d5						nt_only:
>c9d5		04 00				        .byte 4, 0
>c9d7		e1 c9 ed b2 f3 b2		        .word nt_also, xt_only, z_only
>c9dd		6f 6e 6c 79			        .text "only"
.c9e1						nt_also:
>c9e1		04 00				        .byte 4, 0
>c9e3		ed c9 99 b2 a8 b2		        .word nt_previous, xt_also, z_also
>c9e9		61 6c 73 6f			        .text "also"
.c9ed						nt_previous:
>c9ed		08 00				        .byte 8, 0
>c9ef		fd c9 37 b3 43 b3		        .word nt_to_order, xt_previous, z_previous
>c9f5		70 72 65 76 69 6f 75 73		        .text "previous"
.c9fd						nt_to_order:
>c9fd		06 00				        .byte 6, 0
>c9ff		0b ca 01 b4 13 b4		        .word nt_order, xt_to_order, z_to_order
>ca05		3e 6f 72 64 65 72		        .text ">order"
.ca0b						nt_order:
>ca0b		05 00				        .byte 5, 0
>ca0d		18 ca f4 b2 1e b3		        .word nt_forth, xt_order, z_order
>ca13		6f 72 64 65 72			        .text "order"
.ca18						nt_forth:
>ca18		05 00				        .byte 5, 0
>ca1a		25 ca b2 b2 b8 b2		        .word +, xt_forth, z_forth
>ca20		66 6f 72 74 68			        .text "forth"
.ca25						+
>ca25		03 08				nt_see: .byte 3, NN
>ca27		30 ca 60 99 ed 99		        .word +, xt_see, z_see
>ca2d		73 65 65			        .text "see"
.ca30						+
.ca30						nt_ed:
>ca30		03 08				        .byte 3, NN
>ca32		3b ca 67 a8 6a a8		        .word +, xt_ed, z_ed
>ca38		65 64 3a			        .text "ed:"
.ca3b						+
.ca3b						nt_cold:
>ca3b		04 00				        .byte 4, 0
>ca3d		47 ca 00 80 af 80		        .word nt_bye, xt_cold, z_cold
>ca43		63 6f 6c 64			        .text "cold"
.ca47						nt_bye:
>ca47		03				        .byte 3         ; length of word strings
>ca48		00				        .byte 0         ; status byte
>ca49		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca4b		97 98				        .word xt_bye    ; start of code block (xt of this word)
>ca4d		9a 98				        .word z_bye     ; end of code (RTS)
>ca4f		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca52						root_dictionary_start:
.ca52						nt_root_set_order:
>ca52		09 00				        .byte 9, 0
>ca54		63 ca cd b3 00 b4		        .word nt_root_forth, xt_set_order, z_set_order
>ca5a		73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca62		72
.ca63						nt_root_forth:
>ca63		05 00				        .byte 5, 0
>ca65		70 ca b2 b2 b8 b2		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca6b		66 6f 72 74 68			        .text "forth"
.ca70						nt_root_forth_wordlist:
>ca70		0e 00				        .byte 14, 0
>ca72		86 ca 39 9e 3f 9e		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca78		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca80		72 64 6c 69 73 74
.ca86						nt_root_words:
>ca86		05 00				        .byte 5, 0
>ca88		00 00 ee 99 4a 9a		        .word 0000, xt_words, z_words
>ca8e		77 6f 72 64 73			        .text "words"
.ca93						editor_dictionary_start:
.ca93						nt_editor_o:
>ca93		01 00				        .byte 1, 0
>ca95		9c ca 53 b2 98 b2		        .word nt_editor_line, xt_editor_o, z_editor_o
>ca9b		6f				        .text "o"
.ca9c						nt_editor_line:
>ca9c		04 10				        .byte 4, UF
>ca9e		a8 ca 3a b2 52 b2		        .word nt_editor_l, xt_editor_line, z_editor_line
>caa4		6c 69 6e 65			        .text "line"
.caa8						nt_editor_l:
>caa8		01 00				        .byte 1, 0
>caaa		b1 ca c0 b1 39 b2		        .word nt_editor_el, xt_editor_l, z_editor_l
>cab0		6c				        .text "l"
.cab1						nt_editor_el:
>cab1		02 00				        .byte 2, 0
>cab3		bb ca ae b1 bf b1		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cab9		65 6c				        .text "el"
.cabb						nt_editor_erase_screen:
>cabb		0c 00				        .byte 12, 0
>cabd		cf ca 9c b1 ad b1		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cac3		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cacb		72 65 65 6e
.cacf						nt_editor_enter_screen:
>cacf		0c 00				        .byte 12, 0
>cad1		00 00 80 b1 9b b1		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cad7		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cadf		72 65 65 6e
.cae3						assembler_dictionary_start:
.cae3						nt_asm_adc_h:
>cae3		05 0c						.byte 5, IM+NN
>cae5		f0 ca				                .word nt_asm_adc_x
>cae7		b1 a4 b6 a4					.word xt_asm_adc_h, z_asm_adc_h
>caeb		61 64 63 2e 23					.text "adc.#"
.caf0						nt_asm_adc_x:
>caf0		05 0c						.byte 5, IM+NN
>caf2		fd ca				                .word nt_asm_adc_y
>caf4		b6 a4 bb a4					.word xt_asm_adc_x, z_asm_adc_x
>caf8		61 64 63 2e 78					.text "adc.x"
.cafd						nt_asm_adc_y:
>cafd		05 0c						.byte 5, IM+NN
>caff		0a cb				                .word nt_asm_adc_z
>cb01		bb a4 c0 a4					.word xt_asm_adc_y, z_asm_adc_y
>cb05		61 64 63 2e 79					.text "adc.y"
.cb0a						nt_asm_adc_z:
>cb0a		05 0c						.byte 5, IM+NN
>cb0c		17 cb				                .word nt_asm_adc_zi
>cb0e		c0 a4 c5 a4					.word xt_asm_adc_z, z_asm_adc_z
>cb12		61 64 63 2e 7a					.text "adc.z"
.cb17						nt_asm_adc_zi:
>cb17		06 0c						.byte 6, IM+NN
>cb19		25 cb				                .word nt_asm_adc_ziy
>cb1b		c5 a4 ca a4					.word xt_asm_adc_zi, z_asm_adc_zi
>cb1f		61 64 63 2e 7a 69				.text "adc.zi"
.cb25						nt_asm_adc_ziy:
>cb25		07 0c						.byte 7, IM+NN
>cb27		34 cb				                .word nt_asm_adc_zx
>cb29		ca a4 cf a4					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb2d		61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb34						nt_asm_adc_zx:
>cb34		06 0c						.byte 6, IM+NN
>cb36		42 cb				                .word nt_asm_adc_zxi
>cb38		cf a4 d4 a4					.word xt_asm_adc_zx, z_asm_adc_zx
>cb3c		61 64 63 2e 7a 78				.text "adc.zx"
.cb42						nt_asm_adc_zxi:
>cb42		07 0c						.byte 7, IM+NN
>cb44		51 cb				                .word nt_asm_and
>cb46		d4 a4 d9 a4					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb4a		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb51						nt_asm_and:
>cb51		04 0c						.byte 4, IM+NN
>cb53		5d cb				                .word nt_asm_and_h
>cb55		d9 a4 de a4					.word xt_asm_and, z_asm_and
>cb59		61 6e 64 2e					.text "and."
.cb5d						nt_asm_and_h:
>cb5d		05 0c						.byte 5, IM+NN
>cb5f		6a cb				                .word nt_asm_and_x
>cb61		de a4 e3 a4					.word xt_asm_and_h, z_asm_and_h
>cb65		61 6e 64 2e 23					.text "and.#"
.cb6a						nt_asm_and_x:
>cb6a		05 0c						.byte 5, IM+NN
>cb6c		77 cb				                .word nt_asm_and_y
>cb6e		e3 a4 e8 a4					.word xt_asm_and_x, z_asm_and_x
>cb72		61 6e 64 2e 78					.text "and.x"
.cb77						nt_asm_and_y:
>cb77		05 0c						.byte 5, IM+NN
>cb79		84 cb				                .word nt_asm_and_z
>cb7b		e8 a4 ed a4					.word xt_asm_and_y, z_asm_and_y
>cb7f		61 6e 64 2e 79					.text "and.y"
.cb84						nt_asm_and_z:
>cb84		05 0c						.byte 5, IM+NN
>cb86		91 cb				                .word nt_asm_and_zi
>cb88		ed a4 f2 a4					.word xt_asm_and_z, z_asm_and_z
>cb8c		61 6e 64 2e 7a					.text "and.z"
.cb91						nt_asm_and_zi:
>cb91		06 0c						.byte 6, IM+NN
>cb93		9f cb				                .word nt_asm_and_ziy
>cb95		f2 a4 f7 a4					.word xt_asm_and_zi, z_asm_and_zi
>cb99		61 6e 64 2e 7a 69				.text "and.zi"
.cb9f						nt_asm_and_ziy:
>cb9f		07 0c						.byte 7, IM+NN
>cba1		ae cb				                .word nt_asm_and_zx
>cba3		f7 a4 fc a4					.word xt_asm_and_ziy, z_asm_and_ziy
>cba7		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbae						nt_asm_and_zx:
>cbae		06 0c						.byte 6, IM+NN
>cbb0		bc cb				                .word nt_asm_and_zxi
>cbb2		fc a4 01 a5					.word xt_asm_and_zx, z_asm_and_zx
>cbb6		61 6e 64 2e 7a 78				.text "and.zx"
.cbbc						nt_asm_and_zxi:
>cbbc		07 0c						.byte 7, IM+NN
>cbbe		cb cb				                .word nt_asm_asl
>cbc0		01 a5 06 a5					.word xt_asm_and_zxi, z_asm_and_zxi
>cbc4		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cbcb						nt_asm_asl:
>cbcb		03 0c						.byte 3, IM+NN
>cbcd		d6 cb				                .word nt_asm_asl_a
>cbcf		06 a5 0b a5					.word xt_asm_asl, z_asm_asl
>cbd3		61 73 6c					.text "asl"
.cbd6						nt_asm_asl_a:
>cbd6		05 0c						.byte 5, IM+NN
>cbd8		e3 cb				                .word nt_asm_asl_x
>cbda		0b a5 10 a5					.word xt_asm_asl_a, z_asm_asl_a
>cbde		61 73 6c 2e 61					.text "asl.a"
.cbe3						nt_asm_asl_x:
>cbe3		05 0c						.byte 5, IM+NN
>cbe5		f0 cb				                .word nt_asm_asl_z
>cbe7		10 a5 15 a5					.word xt_asm_asl_x, z_asm_asl_x
>cbeb		61 73 6c 2e 78					.text "asl.x"
.cbf0						nt_asm_asl_z:
>cbf0		05 0c						.byte 5, IM+NN
>cbf2		fd cb				                .word nt_asm_asl_zx
>cbf4		15 a5 1a a5					.word xt_asm_asl_z, z_asm_asl_z
>cbf8		61 73 6c 2e 7a					.text "asl.z"
.cbfd						nt_asm_asl_zx:
>cbfd		06 0c						.byte 6, IM+NN
>cbff		0b cc				                .word nt_asm_bcc
>cc01		1a a5 1f a5					.word xt_asm_asl_zx, z_asm_asl_zx
>cc05		61 73 6c 2e 7a 78				.text "asl.zx"
.cc0b						nt_asm_bcc:
>cc0b		03 0c						.byte 3, IM+NN
>cc0d		16 cc				                .word nt_asm_bcs
>cc0f		1f a5 24 a5					.word xt_asm_bcc, z_asm_bcc
>cc13		62 63 63					.text "bcc"
.cc16						nt_asm_bcs:
>cc16		03 0c						.byte 3, IM+NN
>cc18		21 cc				                .word nt_asm_beq
>cc1a		24 a5 2b a5					.word xt_asm_bcs, z_asm_bcs
>cc1e		62 63 73					.text "bcs"
.cc21						nt_asm_beq:
>cc21		03 0c						.byte 3, IM+NN
>cc23		2c cc				                .word nt_asm_bit
>cc25		2b a5 30 a5					.word xt_asm_beq, z_asm_beq
>cc29		62 65 71					.text "beq"
.cc2c						nt_asm_bit:
>cc2c		03 0c						.byte 3, IM+NN
>cc2e		37 cc				                .word nt_asm_bit_h
>cc30		30 a5 35 a5					.word xt_asm_bit, z_asm_bit
>cc34		62 69 74					.text "bit"
.cc37						nt_asm_bit_h:
>cc37		05 0c						.byte 5, IM+NN
>cc39		44 cc				                .word nt_asm_bit_x
>cc3b		35 a5 3a a5					.word xt_asm_bit_h, z_asm_bit_h
>cc3f		62 69 74 2e 23					.text "bit.#"
.cc44						nt_asm_bit_x:
>cc44		05 0c						.byte 5, IM+NN
>cc46		51 cc				                .word nt_asm_bit_z
>cc48		3a a5 3f a5					.word xt_asm_bit_x, z_asm_bit_x
>cc4c		62 69 74 2e 78					.text "bit.x"
.cc51						nt_asm_bit_z:
>cc51		05 0c						.byte 5, IM+NN
>cc53		5e cc				                .word nt_asm_bit_zx
>cc55		3f a5 44 a5					.word xt_asm_bit_z, z_asm_bit_z
>cc59		62 69 74 2e 7a					.text "bit.z"
.cc5e						nt_asm_bit_zx:
>cc5e		06 0c						.byte 6, IM+NN
>cc60		6c cc				                .word nt_asm_bmi
>cc62		44 a5 49 a5					.word xt_asm_bit_zx, z_asm_bit_zx
>cc66		62 69 74 2e 7a 78				.text "bit.zx"
.cc6c						nt_asm_bmi:
>cc6c		03 0c						.byte 3, IM+NN
>cc6e		77 cc				                .word nt_asm_bne
>cc70		49 a5 4e a5					.word xt_asm_bmi, z_asm_bmi
>cc74		62 6d 69					.text "bmi"
.cc77						nt_asm_bne:
>cc77		03 0c						.byte 3, IM+NN
>cc79		82 cc				                .word nt_asm_bpl
>cc7b		4e a5 53 a5					.word xt_asm_bne, z_asm_bne
>cc7f		62 6e 65					.text "bne"
.cc82						nt_asm_bpl:
>cc82		03 0c						.byte 3, IM+NN
>cc84		8d cc				                .word nt_asm_bra
>cc86		53 a5 58 a5					.word xt_asm_bpl, z_asm_bpl
>cc8a		62 70 6c					.text "bpl"
.cc8d						nt_asm_bra:
>cc8d		03 0c						.byte 3, IM+NN
>cc8f		98 cc				                .word nt_asm_brk
>cc91		58 a5 5d a5					.word xt_asm_bra, z_asm_bra
>cc95		62 72 61					.text "bra"
.cc98						nt_asm_brk:
>cc98		03 0c						.byte 3, IM+NN
>cc9a		a3 cc				                .word nt_asm_bvc
>cc9c		5d a5 62 a5					.word xt_asm_brk, z_asm_brk
>cca0		62 72 6b					.text "brk"
.cca3						nt_asm_bvc:
>cca3		03 0c						.byte 3, IM+NN
>cca5		ae cc				                .word nt_asm_bvs
>cca7		62 a5 67 a5					.word xt_asm_bvc, z_asm_bvc
>ccab		62 76 63					.text "bvc"
.ccae						nt_asm_bvs:
>ccae		03 0c						.byte 3, IM+NN
>ccb0		b9 cc				                .word nt_asm_clc
>ccb2		67 a5 6c a5					.word xt_asm_bvs, z_asm_bvs
>ccb6		62 76 73					.text "bvs"
.ccb9						nt_asm_clc:
>ccb9		03 0c						.byte 3, IM+NN
>ccbb		c4 cc				                .word nt_asm_cld
>ccbd		6c a5 71 a5					.word xt_asm_clc, z_asm_clc
>ccc1		63 6c 63					.text "clc"
.ccc4						nt_asm_cld:
>ccc4		03 0c						.byte 3, IM+NN
>ccc6		cf cc				                .word nt_asm_cli
>ccc8		71 a5 76 a5					.word xt_asm_cld, z_asm_cld
>cccc		63 6c 64					.text "cld"
.cccf						nt_asm_cli:
>cccf		03 0c						.byte 3, IM+NN
>ccd1		da cc				                .word nt_asm_clv
>ccd3		76 a5 7b a5					.word xt_asm_cli, z_asm_cli
>ccd7		63 6c 69					.text "cli"
.ccda						nt_asm_clv:
>ccda		03 0c						.byte 3, IM+NN
>ccdc		e5 cc				                .word nt_asm_cmp
>ccde		7b a5 80 a5					.word xt_asm_clv, z_asm_clv
>cce2		63 6c 76					.text "clv"
.cce5						nt_asm_cmp:
>cce5		03 0c						.byte 3, IM+NN
>cce7		f0 cc				                .word nt_asm_cmp_h
>cce9		80 a5 85 a5					.word xt_asm_cmp, z_asm_cmp
>cced		63 6d 70					.text "cmp"
.ccf0						nt_asm_cmp_h:
>ccf0		05 0c						.byte 5, IM+NN
>ccf2		fd cc				                .word nt_asm_cmp_x
>ccf4		85 a5 8a a5					.word xt_asm_cmp_h, z_asm_cmp_h
>ccf8		63 6d 70 2e 23					.text "cmp.#"
.ccfd						nt_asm_cmp_x:
>ccfd		05 0c						.byte 5, IM+NN
>ccff		0a cd				                .word nt_asm_cmp_y
>cd01		8a a5 8f a5					.word xt_asm_cmp_x, z_asm_cmp_x
>cd05		63 6d 70 2e 78					.text "cmp.x"
.cd0a						nt_asm_cmp_y:
>cd0a		05 0c						.byte 5, IM+NN
>cd0c		17 cd				                .word nt_asm_cmp_z
>cd0e		8f a5 94 a5					.word xt_asm_cmp_y, z_asm_cmp_y
>cd12		63 6d 70 2e 79					.text "cmp.y"
.cd17						nt_asm_cmp_z:
>cd17		05 0c						.byte 5, IM+NN
>cd19		24 cd				                .word nt_asm_cmp_zi
>cd1b		94 a5 99 a5					.word xt_asm_cmp_z, z_asm_cmp_z
>cd1f		63 6d 70 2e 7a					.text "cmp.z"
.cd24						nt_asm_cmp_zi:
>cd24		06 0c						.byte 6, IM+NN
>cd26		32 cd				                .word nt_asm_cmp_ziy
>cd28		99 a5 9e a5					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd2c		63 6d 70 2e 7a 69				.text "cmp.zi"
.cd32						nt_asm_cmp_ziy:
>cd32		07 0c						.byte 7, IM+NN
>cd34		41 cd				                .word nt_asm_cmp_zx
>cd36		9e a5 a3 a5					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd3a		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd41						nt_asm_cmp_zx:
>cd41		06 0c						.byte 6, IM+NN
>cd43		4f cd				                .word nt_asm_cmp_zxi
>cd45		a3 a5 a8 a5					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd49		63 6d 70 2e 7a 78				.text "cmp.zx"
.cd4f						nt_asm_cmp_zxi:
>cd4f		07 0c						.byte 7, IM+NN
>cd51		5e cd				                .word nt_asm_cpx
>cd53		a8 a5 ad a5					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd57		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd5e						nt_asm_cpx:
>cd5e		03 0c						.byte 3, IM+NN
>cd60		69 cd				                .word nt_asm_cpx_h
>cd62		ad a5 b2 a5					.word xt_asm_cpx, z_asm_cpx
>cd66		63 70 78					.text "cpx"
.cd69						nt_asm_cpx_h:
>cd69		05 0c						.byte 5, IM+NN
>cd6b		76 cd				                .word nt_asm_cpx_z
>cd6d		b2 a5 b7 a5					.word xt_asm_cpx_h, z_asm_cpx_h
>cd71		63 70 78 2e 23					.text "cpx.#"
.cd76						nt_asm_cpx_z:
>cd76		05 0c						.byte 5, IM+NN
>cd78		83 cd				                .word nt_asm_cpy
>cd7a		b7 a5 bc a5					.word xt_asm_cpx_z, z_asm_cpx_z
>cd7e		63 70 78 2e 7a					.text "cpx.z"
.cd83						nt_asm_cpy:
>cd83		03 0c						.byte 3, IM+NN
>cd85		8e cd				                .word nt_asm_cpy_h
>cd87		bc a5 c3 a5					.word xt_asm_cpy, z_asm_cpy
>cd8b		63 70 79					.text "cpy"
.cd8e						nt_asm_cpy_h:
>cd8e		05 0c						.byte 5, IM+NN
>cd90		9b cd				                .word nt_asm_cpy_z
>cd92		c3 a5 c8 a5					.word xt_asm_cpy_h, z_asm_cpy_h
>cd96		63 70 79 2e 23					.text "cpy.#"
.cd9b						nt_asm_cpy_z:
>cd9b		05 0c						.byte 5, IM+NN
>cd9d		a8 cd				                .word nt_asm_dec
>cd9f		c8 a5 cd a5					.word xt_asm_cpy_z, z_asm_cpy_z
>cda3		63 70 79 2e 7a					.text "cpy.z"
.cda8						nt_asm_dec:
>cda8		03 0c						.byte 3, IM+NN
>cdaa		b3 cd				                .word nt_asm_dec_a
>cdac		cd a5 d2 a5					.word xt_asm_dec, z_asm_dec
>cdb0		64 65 63					.text "dec"
.cdb3						nt_asm_dec_a:
>cdb3		05 0c						.byte 5, IM+NN
>cdb5		c0 cd				                .word nt_asm_dec_x
>cdb7		d2 a5 d7 a5					.word xt_asm_dec_a, z_asm_dec_a
>cdbb		64 65 63 2e 61					.text "dec.a"
.cdc0						nt_asm_dec_x:
>cdc0		05 0c						.byte 5, IM+NN
>cdc2		cd cd				                .word nt_asm_dec_z
>cdc4		d7 a5 dc a5					.word xt_asm_dec_x, z_asm_dec_x
>cdc8		64 65 63 2e 78					.text "dec.x"
.cdcd						nt_asm_dec_z:
>cdcd		05 0c						.byte 5, IM+NN
>cdcf		da cd				                .word nt_asm_dec_zx
>cdd1		dc a5 e1 a5					.word xt_asm_dec_z, z_asm_dec_z
>cdd5		64 65 63 2e 7a					.text "dec.z"
.cdda						nt_asm_dec_zx:
>cdda		06 0c						.byte 6, IM+NN
>cddc		e8 cd				                .word nt_asm_dex
>cdde		e1 a5 e6 a5					.word xt_asm_dec_zx, z_asm_dec_zx
>cde2		64 65 63 2e 7a 78				.text "dec.zx"
.cde8						nt_asm_dex:
>cde8		03 0c						.byte 3, IM+NN
>cdea		f3 cd				                .word nt_asm_dey
>cdec		e6 a5 eb a5					.word xt_asm_dex, z_asm_dex
>cdf0		64 65 78					.text "dex"
.cdf3						nt_asm_dey:
>cdf3		03 0c						.byte 3, IM+NN
>cdf5		fe cd				                .word nt_asm_eor
>cdf7		eb a5 f0 a5					.word xt_asm_dey, z_asm_dey
>cdfb		64 65 79					.text "dey"
.cdfe						nt_asm_eor:
>cdfe		03 0c						.byte 3, IM+NN
>ce00		09 ce				                .word nt_asm_eor_h
>ce02		f0 a5 f5 a5					.word xt_asm_eor, z_asm_eor
>ce06		65 6f 72					.text "eor"
.ce09						nt_asm_eor_h:
>ce09		05 0c						.byte 5, IM+NN
>ce0b		16 ce				                .word nt_asm_eor_x
>ce0d		f5 a5 fa a5					.word xt_asm_eor_h, z_asm_eor_h
>ce11		65 6f 72 2e 23					.text "eor.#"
.ce16						nt_asm_eor_x:
>ce16		05 0c						.byte 5, IM+NN
>ce18		23 ce				                .word nt_asm_eor_y
>ce1a		fa a5 ff a5					.word xt_asm_eor_x, z_asm_eor_x
>ce1e		65 6f 72 2e 78					.text "eor.x"
.ce23						nt_asm_eor_y:
>ce23		05 0c						.byte 5, IM+NN
>ce25		30 ce				                .word nt_asm_eor_z
>ce27		ff a5 04 a6					.word xt_asm_eor_y, z_asm_eor_y
>ce2b		65 6f 72 2e 79					.text "eor.y"
.ce30						nt_asm_eor_z:
>ce30		05 0c						.byte 5, IM+NN
>ce32		3d ce				                .word nt_asm_eor_zi
>ce34		04 a6 09 a6					.word xt_asm_eor_z, z_asm_eor_z
>ce38		65 6f 72 2e 7a					.text "eor.z"
.ce3d						nt_asm_eor_zi:
>ce3d		06 0c						.byte 6, IM+NN
>ce3f		4b ce				                .word nt_asm_eor_ziy
>ce41		09 a6 0e a6					.word xt_asm_eor_zi, z_asm_eor_zi
>ce45		65 6f 72 2e 7a 69				.text "eor.zi"
.ce4b						nt_asm_eor_ziy:
>ce4b		07 0c						.byte 7, IM+NN
>ce4d		5a ce				                .word nt_asm_eor_zx
>ce4f		0e a6 13 a6					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce53		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce5a						nt_asm_eor_zx:
>ce5a		06 0c						.byte 6, IM+NN
>ce5c		68 ce				                .word nt_asm_eor_zxi
>ce5e		13 a6 18 a6					.word xt_asm_eor_zx, z_asm_eor_zx
>ce62		65 6f 72 2e 7a 78				.text "eor.zx"
.ce68						nt_asm_eor_zxi:
>ce68		07 0c						.byte 7, IM+NN
>ce6a		77 ce				                .word nt_asm_inc
>ce6c		18 a6 1d a6					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce70		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce77						nt_asm_inc:
>ce77		03 0c						.byte 3, IM+NN
>ce79		82 ce				                .word nt_asm_inc_a
>ce7b		1d a6 22 a6					.word xt_asm_inc, z_asm_inc
>ce7f		69 6e 63					.text "inc"
.ce82						nt_asm_inc_a:
>ce82		05 0c						.byte 5, IM+NN
>ce84		8f ce				                .word nt_asm_inc_x
>ce86		22 a6 27 a6					.word xt_asm_inc_a, z_asm_inc_a
>ce8a		69 6e 63 2e 61					.text "inc.a"
.ce8f						nt_asm_inc_x:
>ce8f		05 0c						.byte 5, IM+NN
>ce91		9c ce				                .word nt_asm_inc_z
>ce93		27 a6 2c a6					.word xt_asm_inc_x, z_asm_inc_x
>ce97		69 6e 63 2e 78					.text "inc.x"
.ce9c						nt_asm_inc_z:
>ce9c		05 0c						.byte 5, IM+NN
>ce9e		a9 ce				                .word nt_asm_inc_zx
>cea0		2c a6 31 a6					.word xt_asm_inc_z, z_asm_inc_z
>cea4		69 6e 63 2e 7a					.text "inc.z"
.cea9						nt_asm_inc_zx:
>cea9		06 0c						.byte 6, IM+NN
>ceab		b7 ce				                .word nt_asm_inx
>cead		31 a6 36 a6					.word xt_asm_inc_zx, z_asm_inc_zx
>ceb1		69 6e 63 2e 7a 78				.text "inc.zx"
.ceb7						nt_asm_inx:
>ceb7		03 0c						.byte 3, IM+NN
>ceb9		c2 ce				                .word nt_asm_iny
>cebb		36 a6 3b a6					.word xt_asm_inx, z_asm_inx
>cebf		69 6e 78					.text "inx"
.cec2						nt_asm_iny:
>cec2		03 0c						.byte 3, IM+NN
>cec4		cd ce				                .word nt_asm_jmp
>cec6		3b a6 40 a6					.word xt_asm_iny, z_asm_iny
>ceca		69 6e 79					.text "iny"
.cecd						nt_asm_jmp:
>cecd		03 0c						.byte 3, IM+NN
>cecf		d8 ce				                .word nt_asm_jmp_i
>ced1		40 a6 45 a6					.word xt_asm_jmp, z_asm_jmp
>ced5		6a 6d 70					.text "jmp"
.ced8						nt_asm_jmp_i:
>ced8		05 0c						.byte 5, IM+NN
>ceda		e5 ce				                .word nt_asm_jmp_xi
>cedc		45 a6 4a a6					.word xt_asm_jmp_i, z_asm_jmp_i
>cee0		6a 6d 70 2e 69					.text "jmp.i"
.cee5						nt_asm_jmp_xi:
>cee5		06 0c						.byte 6, IM+NN
>cee7		f3 ce				                .word nt_asm_jsr
>cee9		4a a6 4f a6					.word xt_asm_jmp_xi, z_asm_jmp_xi
>ceed		6a 6d 70 2e 78 69				.text "jmp.xi"
.cef3						nt_asm_jsr:
>cef3		03 0c						.byte 3, IM+NN
>cef5		fe ce				                .word nt_asm_lda
>cef7		4f a6 54 a6					.word xt_asm_jsr, z_asm_jsr
>cefb		6a 73 72					.text "jsr"
.cefe						nt_asm_lda:
>cefe		03 0c						.byte 3, IM+NN
>cf00		09 cf				                .word nt_asm_lda_h
>cf02		54 a6 59 a6					.word xt_asm_lda, z_asm_lda
>cf06		6c 64 61					.text "lda"
.cf09						nt_asm_lda_h:
>cf09		05 0c						.byte 5, IM+NN
>cf0b		16 cf				                .word nt_asm_lda_x
>cf0d		59 a6 5e a6					.word xt_asm_lda_h, z_asm_lda_h
>cf11		6c 64 61 2e 23					.text "lda.#"
.cf16						nt_asm_lda_x:
>cf16		05 0c						.byte 5, IM+NN
>cf18		23 cf				                .word nt_asm_lda_y
>cf1a		5e a6 63 a6					.word xt_asm_lda_x, z_asm_lda_x
>cf1e		6c 64 61 2e 78					.text "lda.x"
.cf23						nt_asm_lda_y:
>cf23		05 0c						.byte 5, IM+NN
>cf25		30 cf				                .word nt_asm_lda_z
>cf27		63 a6 68 a6					.word xt_asm_lda_y, z_asm_lda_y
>cf2b		6c 64 61 2e 79					.text "lda.y"
.cf30						nt_asm_lda_z:
>cf30		05 0c						.byte 5, IM+NN
>cf32		3d cf				                .word nt_asm_lda_zi
>cf34		68 a6 6d a6					.word xt_asm_lda_z, z_asm_lda_z
>cf38		6c 64 61 2e 7a					.text "lda.z"
.cf3d						nt_asm_lda_zi:
>cf3d		06 0c						.byte 6, IM+NN
>cf3f		4b cf				                .word nt_asm_lda_ziy
>cf41		6d a6 72 a6					.word xt_asm_lda_zi, z_asm_lda_zi
>cf45		6c 64 61 2e 7a 69				.text "lda.zi"
.cf4b						nt_asm_lda_ziy:
>cf4b		07 0c						.byte 7, IM+NN
>cf4d		5a cf				                .word nt_asm_lda_zx
>cf4f		72 a6 77 a6					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf53		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf5a						nt_asm_lda_zx:
>cf5a		06 0c						.byte 6, IM+NN
>cf5c		68 cf				                .word nt_asm_lda_zxi
>cf5e		77 a6 7c a6					.word xt_asm_lda_zx, z_asm_lda_zx
>cf62		6c 64 61 2e 7a 78				.text "lda.zx"
.cf68						nt_asm_lda_zxi:
>cf68		07 0c						.byte 7, IM+NN
>cf6a		77 cf				                .word nt_asm_ldx
>cf6c		7c a6 81 a6					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf70		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf77						nt_asm_ldx:
>cf77		03 0c						.byte 3, IM+NN
>cf79		82 cf				                .word nt_asm_ldx_h
>cf7b		81 a6 86 a6					.word xt_asm_ldx, z_asm_ldx
>cf7f		6c 64 78					.text "ldx"
.cf82						nt_asm_ldx_h:
>cf82		05 0c						.byte 5, IM+NN
>cf84		8f cf				                .word nt_asm_ldx_y
>cf86		86 a6 8b a6					.word xt_asm_ldx_h, z_asm_ldx_h
>cf8a		6c 64 78 2e 23					.text "ldx.#"
.cf8f						nt_asm_ldx_y:
>cf8f		05 0c						.byte 5, IM+NN
>cf91		9c cf				                .word nt_asm_ldx_z
>cf93		8b a6 90 a6					.word xt_asm_ldx_y, z_asm_ldx_y
>cf97		6c 64 78 2e 79					.text "ldx.y"
.cf9c						nt_asm_ldx_z:
>cf9c		05 0c						.byte 5, IM+NN
>cf9e		a9 cf				                .word nt_asm_ldx_zy
>cfa0		90 a6 95 a6					.word xt_asm_ldx_z, z_asm_ldx_z
>cfa4		6c 64 78 2e 7a					.text "ldx.z"
.cfa9						nt_asm_ldx_zy:
>cfa9		06 0c						.byte 6, IM+NN
>cfab		b7 cf				                .word nt_asm_ldy
>cfad		95 a6 9a a6					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfb1		6c 64 78 2e 7a 79				.text "ldx.zy"
.cfb7						nt_asm_ldy:
>cfb7		03 0c						.byte 3, IM+NN
>cfb9		c2 cf				                .word nt_asm_ldy_h
>cfbb		9a a6 9f a6					.word xt_asm_ldy, z_asm_ldy
>cfbf		6c 64 79					.text "ldy"
.cfc2						nt_asm_ldy_h:
>cfc2		05 0c						.byte 5, IM+NN
>cfc4		cf cf				                .word nt_asm_ldy_x
>cfc6		9f a6 a4 a6					.word xt_asm_ldy_h, z_asm_ldy_h
>cfca		6c 64 79 2e 23					.text "ldy.#"
.cfcf						nt_asm_ldy_x:
>cfcf		05 0c						.byte 5, IM+NN
>cfd1		dc cf				                .word nt_asm_ldy_z
>cfd3		a4 a6 a9 a6					.word xt_asm_ldy_x, z_asm_ldy_x
>cfd7		6c 64 79 2e 78					.text "ldy.x"
.cfdc						nt_asm_ldy_z:
>cfdc		05 0c						.byte 5, IM+NN
>cfde		e9 cf				                .word nt_asm_ldy_zx
>cfe0		a9 a6 ae a6					.word xt_asm_ldy_z, z_asm_ldy_z
>cfe4		6c 64 79 2e 7a					.text "ldy.z"
.cfe9						nt_asm_ldy_zx:
>cfe9		06 0c						.byte 6, IM+NN
>cfeb		f7 cf				                .word nt_asm_lsr
>cfed		ae a6 b3 a6					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cff1		6c 64 79 2e 7a 78				.text "ldy.zx"
.cff7						nt_asm_lsr:
>cff7		03 0c						.byte 3, IM+NN
>cff9		02 d0				                .word nt_asm_lsr_a
>cffb		b3 a6 b8 a6					.word xt_asm_lsr, z_asm_lsr
>cfff		6c 73 72					.text "lsr"
.d002						nt_asm_lsr_a:
>d002		05 0c						.byte 5, IM+NN
>d004		0f d0				                .word nt_asm_lsr_x
>d006		b8 a6 bd a6					.word xt_asm_lsr_a, z_asm_lsr_a
>d00a		6c 73 72 2e 61					.text "lsr.a"
.d00f						nt_asm_lsr_x:
>d00f		05 0c						.byte 5, IM+NN
>d011		1c d0				                .word nt_asm_lsr_z
>d013		bd a6 c2 a6					.word xt_asm_lsr_x, z_asm_lsr_x
>d017		6c 73 72 2e 78					.text "lsr.x"
.d01c						nt_asm_lsr_z:
>d01c		05 0c						.byte 5, IM+NN
>d01e		29 d0				                .word nt_asm_lsr_zx
>d020		c2 a6 c7 a6					.word xt_asm_lsr_z, z_asm_lsr_z
>d024		6c 73 72 2e 7a					.text "lsr.z"
.d029						nt_asm_lsr_zx:
>d029		06 0c						.byte 6, IM+NN
>d02b		37 d0				                .word nt_asm_nop
>d02d		c7 a6 cc a6					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d031		6c 73 72 2e 7a 78				.text "lsr.zx"
.d037						nt_asm_nop:
>d037		03 0c						.byte 3, IM+NN
>d039		42 d0				                .word nt_asm_ora
>d03b		cc a6 d1 a6					.word xt_asm_nop, z_asm_nop
>d03f		6e 6f 70					.text "nop"
.d042						nt_asm_ora:
>d042		03 0c						.byte 3, IM+NN
>d044		4d d0				                .word nt_asm_ora_h
>d046		d1 a6 d6 a6					.word xt_asm_ora, z_asm_ora
>d04a		6f 72 61					.text "ora"
.d04d						nt_asm_ora_h:
>d04d		05 0c						.byte 5, IM+NN
>d04f		5a d0				                .word nt_asm_ora_x
>d051		d6 a6 db a6					.word xt_asm_ora_h, z_asm_ora_h
>d055		6f 72 61 2e 23					.text "ora.#"
.d05a						nt_asm_ora_x:
>d05a		05 0c						.byte 5, IM+NN
>d05c		67 d0				                .word nt_asm_ora_y
>d05e		db a6 e0 a6					.word xt_asm_ora_x, z_asm_ora_x
>d062		6f 72 61 2e 78					.text "ora.x"
.d067						nt_asm_ora_y:
>d067		05 0c						.byte 5, IM+NN
>d069		74 d0				                .word nt_asm_ora_z
>d06b		e0 a6 e5 a6					.word xt_asm_ora_y, z_asm_ora_y
>d06f		6f 72 61 2e 79					.text "ora.y"
.d074						nt_asm_ora_z:
>d074		05 0c						.byte 5, IM+NN
>d076		81 d0				                .word nt_asm_ora_zi
>d078		e5 a6 ea a6					.word xt_asm_ora_z, z_asm_ora_z
>d07c		6f 72 61 2e 7a					.text "ora.z"
.d081						nt_asm_ora_zi:
>d081		06 0c						.byte 6, IM+NN
>d083		8f d0				                .word nt_asm_ora_ziy
>d085		ea a6 f1 a6					.word xt_asm_ora_zi, z_asm_ora_zi
>d089		6f 72 61 2e 7a 69				.text "ora.zi"
.d08f						nt_asm_ora_ziy:
>d08f		07 0c						.byte 7, IM+NN
>d091		9e d0				                .word nt_asm_ora_zx
>d093		f1 a6 f6 a6					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d097		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d09e						nt_asm_ora_zx:
>d09e		06 0c						.byte 6, IM+NN
>d0a0		ac d0				                .word nt_asm_ora_zxi
>d0a2		f6 a6 fb a6					.word xt_asm_ora_zx, z_asm_ora_zx
>d0a6		6f 72 61 2e 7a 78				.text "ora.zx"
.d0ac						nt_asm_ora_zxi:
>d0ac		07 0c						.byte 7, IM+NN
>d0ae		bb d0				                .word nt_asm_pha
>d0b0		fb a6 00 a7					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0b4		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0bb						nt_asm_pha:
>d0bb		03 0c						.byte 3, IM+NN
>d0bd		c6 d0				                .word nt_asm_php
>d0bf		00 a7 05 a7					.word xt_asm_pha, z_asm_pha
>d0c3		70 68 61					.text "pha"
.d0c6						nt_asm_php:
>d0c6		03 0c						.byte 3, IM+NN
>d0c8		d1 d0				                .word nt_asm_phx
>d0ca		05 a7 0a a7					.word xt_asm_php, z_asm_php
>d0ce		70 68 70					.text "php"
.d0d1						nt_asm_phx:
>d0d1		03 0c						.byte 3, IM+NN
>d0d3		dc d0				                .word nt_asm_phy
>d0d5		0a a7 0f a7					.word xt_asm_phx, z_asm_phx
>d0d9		70 68 78					.text "phx"
.d0dc						nt_asm_phy:
>d0dc		03 0c						.byte 3, IM+NN
>d0de		e7 d0				                .word nt_asm_pla
>d0e0		0f a7 14 a7					.word xt_asm_phy, z_asm_phy
>d0e4		70 68 79					.text "phy"
.d0e7						nt_asm_pla:
>d0e7		03 0c						.byte 3, IM+NN
>d0e9		f2 d0				                .word nt_asm_plp
>d0eb		14 a7 19 a7					.word xt_asm_pla, z_asm_pla
>d0ef		70 6c 61					.text "pla"
.d0f2						nt_asm_plp:
>d0f2		03 0c						.byte 3, IM+NN
>d0f4		fd d0				                .word nt_asm_plx
>d0f6		19 a7 1e a7					.word xt_asm_plp, z_asm_plp
>d0fa		70 6c 70					.text "plp"
.d0fd						nt_asm_plx:
>d0fd		03 0c						.byte 3, IM+NN
>d0ff		08 d1				                .word nt_asm_ply
>d101		1e a7 23 a7					.word xt_asm_plx, z_asm_plx
>d105		70 6c 78					.text "plx"
.d108						nt_asm_ply:
>d108		03 0c						.byte 3, IM+NN
>d10a		13 d1				                .word nt_asm_rol
>d10c		23 a7 28 a7					.word xt_asm_ply, z_asm_ply
>d110		70 6c 79					.text "ply"
.d113						nt_asm_rol:
>d113		03 0c						.byte 3, IM+NN
>d115		1e d1				                .word nt_asm_rol_a
>d117		28 a7 2d a7					.word xt_asm_rol, z_asm_rol
>d11b		72 6f 6c					.text "rol"
.d11e						nt_asm_rol_a:
>d11e		05 0c						.byte 5, IM+NN
>d120		2b d1				                .word nt_asm_rol_x
>d122		2d a7 32 a7					.word xt_asm_rol_a, z_asm_rol_a
>d126		72 6f 6c 2e 61					.text "rol.a"
.d12b						nt_asm_rol_x:
>d12b		05 0c						.byte 5, IM+NN
>d12d		38 d1				                .word nt_asm_rol_z
>d12f		32 a7 37 a7					.word xt_asm_rol_x, z_asm_rol_x
>d133		72 6f 6c 2e 78					.text "rol.x"
.d138						nt_asm_rol_z:
>d138		05 0c						.byte 5, IM+NN
>d13a		45 d1				                .word nt_asm_rol_zx
>d13c		37 a7 3c a7					.word xt_asm_rol_z, z_asm_rol_z
>d140		72 6f 6c 2e 7a					.text "rol.z"
.d145						nt_asm_rol_zx:
>d145		06 0c						.byte 6, IM+NN
>d147		53 d1				                .word nt_asm_ror
>d149		3c a7 41 a7					.word xt_asm_rol_zx, z_asm_rol_zx
>d14d		72 6f 6c 2e 7a 78				.text "rol.zx"
.d153						nt_asm_ror:
>d153		03 0c						.byte 3, IM+NN
>d155		5e d1				                .word nt_asm_ror_a
>d157		41 a7 46 a7					.word xt_asm_ror, z_asm_ror
>d15b		72 6f 72					.text "ror"
.d15e						nt_asm_ror_a:
>d15e		05 0c						.byte 5, IM+NN
>d160		6b d1				                .word nt_asm_ror_x
>d162		46 a7 4b a7					.word xt_asm_ror_a, z_asm_ror_a
>d166		72 6f 72 2e 61					.text "ror.a"
.d16b						nt_asm_ror_x:
>d16b		05 0c						.byte 5, IM+NN
>d16d		78 d1				                .word nt_asm_ror_z
>d16f		4b a7 50 a7					.word xt_asm_ror_x, z_asm_ror_x
>d173		72 6f 72 2e 78					.text "ror.x"
.d178						nt_asm_ror_z:
>d178		05 0c						.byte 5, IM+NN
>d17a		85 d1				                .word nt_asm_ror_zx
>d17c		50 a7 55 a7					.word xt_asm_ror_z, z_asm_ror_z
>d180		72 6f 72 2e 7a					.text "ror.z"
.d185						nt_asm_ror_zx:
>d185		06 0c						.byte 6, IM+NN
>d187		93 d1				                .word nt_asm_rti
>d189		55 a7 5a a7					.word xt_asm_ror_zx, z_asm_ror_zx
>d18d		72 6f 72 2e 7a 78				.text "ror.zx"
.d193						nt_asm_rti:
>d193		03 0c						.byte 3, IM+NN
>d195		9e d1				                .word nt_asm_rts
>d197		5a a7 5f a7					.word xt_asm_rti, z_asm_rti
>d19b		72 74 69					.text "rti"
.d19e						nt_asm_rts:
>d19e		03 0c						.byte 3, IM+NN
>d1a0		a9 d1				                .word nt_asm_sbc
>d1a2		5f a7 64 a7					.word xt_asm_rts, z_asm_rts
>d1a6		72 74 73					.text "rts"
.d1a9						nt_asm_sbc:
>d1a9		03 0c						.byte 3, IM+NN
>d1ab		b4 d1				                .word nt_asm_sbc_h
>d1ad		64 a7 69 a7					.word xt_asm_sbc, z_asm_sbc
>d1b1		73 62 63					.text "sbc"
.d1b4						nt_asm_sbc_h:
>d1b4		05 0c						.byte 5, IM+NN
>d1b6		c1 d1				                .word nt_asm_sbc_x
>d1b8		69 a7 6e a7					.word xt_asm_sbc_h, z_asm_sbc_h
>d1bc		73 62 63 2e 23					.text "sbc.#"
.d1c1						nt_asm_sbc_x:
>d1c1		05 0c						.byte 5, IM+NN
>d1c3		ce d1				                .word nt_asm_sbc_y
>d1c5		6e a7 73 a7					.word xt_asm_sbc_x, z_asm_sbc_x
>d1c9		73 62 63 2e 78					.text "sbc.x"
.d1ce						nt_asm_sbc_y:
>d1ce		05 0c						.byte 5, IM+NN
>d1d0		db d1				                .word nt_asm_sbc_z
>d1d2		73 a7 78 a7					.word xt_asm_sbc_y, z_asm_sbc_y
>d1d6		73 62 63 2e 79					.text "sbc.y"
.d1db						nt_asm_sbc_z:
>d1db		05 0c						.byte 5, IM+NN
>d1dd		e8 d1				                .word nt_asm_sbc_zi
>d1df		78 a7 7d a7					.word xt_asm_sbc_z, z_asm_sbc_z
>d1e3		73 62 63 2e 7a					.text "sbc.z"
.d1e8						nt_asm_sbc_zi:
>d1e8		06 0c						.byte 6, IM+NN
>d1ea		f6 d1				                .word nt_asm_sbc_ziy
>d1ec		7d a7 82 a7					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d1f0		73 62 63 2e 7a 69				.text "sbc.zi"
.d1f6						nt_asm_sbc_ziy:
>d1f6		07 0c						.byte 7, IM+NN
>d1f8		05 d2				                .word nt_asm_sbc_zx
>d1fa		82 a7 87 a7					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d1fe		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d205						nt_asm_sbc_zx:
>d205		06 0c						.byte 6, IM+NN
>d207		13 d2				                .word nt_asm_sbc_zxi
>d209		87 a7 8c a7					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d20d		73 62 63 2e 7a 78				.text "sbc.zx"
.d213						nt_asm_sbc_zxi:
>d213		07 0c						.byte 7, IM+NN
>d215		22 d2				                .word nt_asm_sec
>d217		8c a7 90 a7					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d21b		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d222						nt_asm_sec:
>d222		03 0c						.byte 3, IM+NN
>d224		2d d2				                .word nt_asm_sed
>d226		90 a7 94 a7					.word xt_asm_sec, z_asm_sec
>d22a		73 65 63					.text "sec"
.d22d						nt_asm_sed:
>d22d		03 0c						.byte 3, IM+NN
>d22f		38 d2				                .word nt_asm_sei
>d231		94 a7 98 a7					.word xt_asm_sed, z_asm_sed
>d235		73 65 64					.text "sed"
.d238						nt_asm_sei:
>d238		03 0c						.byte 3, IM+NN
>d23a		43 d2				                .word nt_asm_sta
>d23c		98 a7 9c a7					.word xt_asm_sei, z_asm_sei
>d240		73 65 69					.text "sei"
.d243						nt_asm_sta:
>d243		03 0c						.byte 3, IM+NN
>d245		4e d2				                .word nt_asm_sta_x
>d247		9c a7 a0 a7					.word xt_asm_sta, z_asm_sta
>d24b		73 74 61					.text "sta"
.d24e						nt_asm_sta_x:
>d24e		05 0c						.byte 5, IM+NN
>d250		5b d2				                .word nt_asm_sta_y
>d252		a0 a7 a4 a7					.word xt_asm_sta_x, z_asm_sta_x
>d256		73 74 61 2e 78					.text "sta.x"
.d25b						nt_asm_sta_y:
>d25b		05 0c						.byte 5, IM+NN
>d25d		68 d2				                .word nt_asm_sta_z
>d25f		a4 a7 a8 a7					.word xt_asm_sta_y, z_asm_sta_y
>d263		73 74 61 2e 79					.text "sta.y"
.d268						nt_asm_sta_z:
>d268		05 0c						.byte 5, IM+NN
>d26a		75 d2				                .word nt_asm_sta_zi
>d26c		a8 a7 ac a7					.word xt_asm_sta_z, z_asm_sta_z
>d270		73 74 61 2e 7a					.text "sta.z"
.d275						nt_asm_sta_zi:
>d275		06 0c						.byte 6, IM+NN
>d277		83 d2				                .word nt_asm_sta_ziy
>d279		ac a7 b0 a7					.word xt_asm_sta_zi, z_asm_sta_zi
>d27d		73 74 61 2e 7a 69				.text "sta.zi"
.d283						nt_asm_sta_ziy:
>d283		07 0c						.byte 7, IM+NN
>d285		92 d2				                .word nt_asm_sta_zx
>d287		b0 a7 b4 a7					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d28b		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d292						nt_asm_sta_zx:
>d292		06 0c						.byte 6, IM+NN
>d294		a0 d2				                .word nt_asm_sta_zxi
>d296		b4 a7 b8 a7					.word xt_asm_sta_zx, z_asm_sta_zx
>d29a		73 74 61 2e 7a 78				.text "sta.zx"
.d2a0						nt_asm_sta_zxi:
>d2a0		07 0c						.byte 7, IM+NN
>d2a2		af d2				                .word nt_asm_stx
>d2a4		b8 a7 bc a7					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2a8		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2af						nt_asm_stx:
>d2af		03 0c						.byte 3, IM+NN
>d2b1		ba d2				                .word nt_asm_stx_z
>d2b3		bc a7 c0 a7					.word xt_asm_stx, z_asm_stx
>d2b7		73 74 78					.text "stx"
.d2ba						nt_asm_stx_z:
>d2ba		05 0c						.byte 5, IM+NN
>d2bc		c7 d2				                .word nt_asm_stx_zy
>d2be		c0 a7 c4 a7					.word xt_asm_stx_z, z_asm_stx_z
>d2c2		73 74 78 2e 7a					.text "stx.z"
.d2c7						nt_asm_stx_zy:
>d2c7		06 0c						.byte 6, IM+NN
>d2c9		d5 d2				                .word nt_asm_sty
>d2cb		c4 a7 c8 a7					.word xt_asm_stx_zy, z_asm_stx_zy
>d2cf		73 74 78 2e 7a 79				.text "stx.zy"
.d2d5						nt_asm_sty:
>d2d5		03 0c						.byte 3, IM+NN
>d2d7		e0 d2				                .word nt_asm_sty_z
>d2d9		c8 a7 cc a7					.word xt_asm_sty, z_asm_sty
>d2dd		73 74 79					.text "sty"
.d2e0						nt_asm_sty_z:
>d2e0		05 0c						.byte 5, IM+NN
>d2e2		ed d2				                .word nt_asm_sty_zx
>d2e4		cc a7 d0 a7					.word xt_asm_sty_z, z_asm_sty_z
>d2e8		73 74 79 2e 7a					.text "sty.z"
.d2ed						nt_asm_sty_zx:
>d2ed		06 0c						.byte 6, IM+NN
>d2ef		fb d2				                .word nt_asm_stz
>d2f1		d0 a7 d4 a7					.word xt_asm_sty_zx, z_asm_sty_zx
>d2f5		73 74 79 2e 7a 78				.text "sty.zx"
.d2fb						nt_asm_stz:
>d2fb		03 0c						.byte 3, IM+NN
>d2fd		06 d3				                .word nt_asm_stz_x
>d2ff		d4 a7 d8 a7					.word xt_asm_stz, z_asm_stz
>d303		73 74 7a					.text "stz"
.d306						nt_asm_stz_x:
>d306		05 0c						.byte 5, IM+NN
>d308		13 d3				                .word nt_asm_stz_z
>d30a		d8 a7 dc a7					.word xt_asm_stz_x, z_asm_stz_x
>d30e		73 74 7a 2e 78					.text "stz.x"
.d313						nt_asm_stz_z:
>d313		05 0c						.byte 5, IM+NN
>d315		20 d3				                .word nt_asm_stz_zx
>d317		dc a7 e0 a7					.word xt_asm_stz_z, z_asm_stz_z
>d31b		73 74 7a 2e 7a					.text "stz.z"
.d320						nt_asm_stz_zx:
>d320		06 0c						.byte 6, IM+NN
>d322		2e d3				                .word nt_asm_tax
>d324		e0 a7 e4 a7					.word xt_asm_stz_zx, z_asm_stz_zx
>d328		73 74 7a 2e 7a 78				.text "stz.zx"
.d32e						nt_asm_tax:
>d32e		03 0c						.byte 3, IM+NN
>d330		39 d3				                .word nt_asm_tay
>d332		e4 a7 e8 a7					.word xt_asm_tax, z_asm_tax
>d336		74 61 78					.text "tax"
.d339						nt_asm_tay:
>d339		03 0c						.byte 3, IM+NN
>d33b		44 d3				                .word nt_asm_trb
>d33d		e8 a7 ec a7					.word xt_asm_tay, z_asm_tay
>d341		74 61 79					.text "tay"
.d344						nt_asm_trb:
>d344		03 0c						.byte 3, IM+NN
>d346		4f d3				                .word nt_asm_trb_z
>d348		ec a7 f0 a7					.word xt_asm_trb, z_asm_trb
>d34c		74 72 62					.text "trb"
.d34f						nt_asm_trb_z:
>d34f		05 0c						.byte 5, IM+NN
>d351		5c d3				                .word nt_asm_tsb
>d353		f0 a7 f4 a7					.word xt_asm_trb_z, z_asm_trb_z
>d357		74 72 62 2e 7a					.text "trb.z"
.d35c						nt_asm_tsb:
>d35c		03 0c						.byte 3, IM+NN
>d35e		67 d3				                .word nt_asm_tsb_z
>d360		f4 a7 f8 a7					.word xt_asm_tsb, z_asm_tsb
>d364		74 73 62					.text "tsb"
.d367						nt_asm_tsb_z:
>d367		05 0c						.byte 5, IM+NN
>d369		74 d3				                .word nt_asm_tsx
>d36b		f8 a7 fc a7					.word xt_asm_tsb_z, z_asm_tsb_z
>d36f		74 73 62 2e 7a					.text "tsb.z"
.d374						nt_asm_tsx:
>d374		03 0c						.byte 3, IM+NN
>d376		7f d3				                .word nt_asm_txa
>d378		fc a7 00 a8					.word xt_asm_tsx, z_asm_tsx
>d37c		74 73 78					.text "tsx"
.d37f						nt_asm_txa:
>d37f		03 0c						.byte 3, IM+NN
>d381		8a d3				                .word nt_asm_txs
>d383		00 a8 04 a8					.word xt_asm_txa, z_asm_txa
>d387		74 78 61					.text "txa"
.d38a						nt_asm_txs:
>d38a		03 0c						.byte 3, IM+NN
>d38c		95 d3				                .word nt_asm_tya
>d38e		04 a8 08 a8					.word xt_asm_txs, z_asm_txs
>d392		74 78 73					.text "txs"
.d395						nt_asm_tya:
>d395		03 0c						.byte 3, IM+NN
>d397		a0 d3				                .word nt_asm_arrow
>d399		08 a8 0c a8					.word xt_asm_tya, z_asm_tya
>d39d		74 79 61					.text "tya"
.d3a0						nt_asm_arrow:
>d3a0		03 04				                .byte 3, IM
>d3a2		ab d3				                .word nt_asm_back_jump
>d3a4		34 89 3e 89			                .word xt_asm_arrow, z_asm_arrow
>d3a8		2d 2d 3e			                .text "-->"
.d3ab						nt_asm_back_jump:
>d3ab		02 04				                .byte 2, IM
>d3ad		b5 d3				                .word nt_asm_back_branch
>d3af		5d a8 5d a8			                .word xt_asm_back_jump, z_asm_back_jump
>d3b3		3c 6a				                .text "<j"
.d3b5						nt_asm_back_branch:
>d3b5		02 04				                .byte 2, IM
>d3b7		bf d3				                .word nt_asm_push_a
>d3b9		5e a8 66 a8			                .word xt_asm_back_branch, z_asm_back_branch
>d3bd		3c 62				                .text "<b"
.d3bf						nt_asm_push_a:
>d3bf		06 0c				                .byte 6, IM+NN
>d3c1		00 00				                .word 0000
>d3c3		46 a8 55 a8			                .word xt_asm_push_a, z_asm_push_a
>d3c7		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix         ; unused?
=1						ix += 1
=1						str_compile        = ix         ; unused?
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix         ; unused?
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_sdc     = ix
=13						ix += 1
=13						str_disasm_lit     = ix
=14						ix += 1
=14						str_disasm_0bra    = ix
=15						ix += 1
=15						str_disasm_loop    = ix
=16						ix += 1
=16						str_disasm_do      = ix
=17						ix += 1
.d3cd						string_table:
>d3cd		ef d3 f3 d3 fd d3 08 d4		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d3d5		3f d4 37 d4 2c d4 46 d4		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d3dd		4c d4 68 d4 6d d4 72 d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d3e5		83 d4 96 d4 9f d4 a8 d4		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 12-16
>d3ed		ae d4
>d3ef		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d3f3		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d3fb		64 00
>d3fd		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d405		64 20 00
>d408		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d410		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d420		4f 50 51 52 53 54 55 56 57 58 59 5a
>d42c		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d434		72 20 00
>d437		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d43f		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d446		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d44c		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d454		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d464		29 3a 20 00
>d468		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d46d		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d472		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d47a		63 69 6d 61 6c 29 3a 20 00
>d483		20 53 54 41 43 4b 20 44		s_disasm_sdc: .text " STACK DEPTH CHECK", 0
>d48b		45 50 54 48 20 43 48 45 43 4b 00
>d496		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d49e		00
>d49f		30 42 52 41 4e 43 48 20		s_disasm_0bra: .text "0BRANCH ",0
>d4a7		00
>d4a8		4c 4f 4f 50 20 00		s_disasm_loop: .text "LOOP ",0
>d4ae		44 4f 20 00			s_disasm_do: .text "DO ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d4b2						error_table:
>d4b2		ce d4 ef d4 0f d5 30 d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4ba		4d d5 5e d5 6e d5 9c d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4c2		b4 d5 d5 d5 ea d5 06 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4ca		1d d6 5c d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d4ce		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4d6		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d4e6		65 20 6d 65 6d 6f 72 79 00
>d4ef		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d4f7		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d507		20 52 45 46 49 4c 4c 00
>d50f		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d517		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d527		6e 6c 79 20 77 6f 72 64 00
>d530		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d538		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d548		20 79 65 74 00
>d54d		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d555		20 62 79 20 7a 65 72 6f 00
>d55e		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d566		66 61 69 6c 75 72 65 00
>d56e		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d576		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d586		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d596		64 20 2d 31 29 00
>d59c		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5a4		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5b4		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d5bc		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d5cc		64 20 6e 75 6d 62 65 72 00
>d5d5		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d5dd		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d5ea		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5f2		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d602		4c 4f 54 00
>d606		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d60e		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d61d		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d625		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d635		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d645		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d655		56 45 43 54 4f 52 00
>d65c		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d664		74 61 63 6b 3a 00
>d66a		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d672		44 2d 53 54 52 49 4e 47
>d67a		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d680		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d685		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d68d		2d 55 4e 49 54 2d 42 49 54 53
>d697		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d69f		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6a7		52
>d6a8		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6ae		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6b4		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6bc		53 54 41 43 4b 2d 43 45 4c 4c 53
>d6c7		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6cf		45 4c 4c 53
>d6d3		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6db		54 53
>d6dd		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6e3		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6ea						doconst:
.d6ea		ca		dex		                dex             ; make room for constant
.d6eb		ca		dex		                dex
.d6ec		68		pla		                pla             ; LSB of return address
.d6ed		85 25		sta $25		                sta tmp1
.d6ef		68		pla		                pla             ; MSB of return address
.d6f0		85 26		sta $26		                sta tmp1+1
.d6f2		a0 01		ldy #$01	                ldy #1
.d6f4		b1 25		lda ($25),y	                lda (tmp1),y
.d6f6		95 00		sta $00,x	                sta 0,x
.d6f8		c8		iny		                iny
.d6f9		b1 25		lda ($25),y	                lda (tmp1),y
.d6fb		95 01		sta $01,x	                sta 1,x
.d6fd		60		rts		                rts
.d6fe						dodefer:
.d6fe		68		pla		                pla             ; LSB
.d6ff		85 25		sta $25		                sta tmp1
.d701		68		pla		                pla             ; MSB
.d702		85 26		sta $26		                sta tmp1+1
.d704		a0 01		ldy #$01	                ldy #1
.d706		b1 25		lda ($25),y	                lda (tmp1),y
.d708		85 27		sta $27		                sta tmp2
.d70a		c8		iny		                iny
.d70b		b1 25		lda ($25),y	                lda (tmp1),y
.d70d		85 28		sta $28		                sta tmp2+1
.d70f		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d712						defer_error:
.d712		a9 03		lda #$03	                lda #err_defer
.d714		4c 98 d8	jmp $d898	                jmp error
.d717						dodoes:
.d717		7a		ply		                ply             ; LSB
.d718		68		pla		                pla             ; MSB
.d719		c8		iny		                iny
.d71a		d0 01		bne $d71d	                bne +
.d71c		1a		inc a		                ina
.d71d						+
.d71d		84 27		sty $27		                sty tmp2
.d71f		85 28		sta $28		                sta tmp2+1
.d721		ca		dex		                dex
.d722		ca		dex		                dex
.d723		7a		ply		                ply
.d724		68		pla		                pla
.d725		c8		iny		                iny
.d726		d0 01		bne $d729	                bne +
.d728		1a		inc a		                ina
.d729						+
.d729		94 00		sty $00,x	                sty 0,x         ; LSB
.d72b		95 01		sta $01,x	                sta 1,x         ; MSB
.d72d		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d730						dovar:
.d730		7a		ply		                ply             ; LSB
.d731		68		pla		                pla             ; MSB
.d732		c8		iny		                iny
.d733		d0 01		bne $d736	                bne +
.d735		1a		inc a		                ina
.d736						+
.d736		ca		dex		                dex
.d737		ca		dex		                dex
.d738		95 01		sta $01,x	                sta 1,x
.d73a		98		tya		                tya
.d73b		95 00		sta $00,x	                sta 0,x
.d73d		60		rts		                rts
.d73e						push_upvar_tos:
.d73e		ca		dex		                dex
.d73f		ca		dex		                dex
.d740		18		clc		                clc
.d741		65 08		adc $08		                adc up
.d743		95 00		sta $00,x	                sta 0,x
.d745		a5 09		lda $09		                lda up+1
.d747		90 01		bcc $d74a	                bcc +
.d749		1a		inc a		                ina
.d74a						+
.d74a		95 01		sta $01,x	                sta 1,x
.d74c		60		rts		                rts
.d74d						byte_to_ascii:
.d74d		48		pha		                pha
.d74e		4a		lsr a		                lsr             ; convert high nibble first
.d74f		4a		lsr a		                lsr
.d750		4a		lsr a		                lsr
.d751		4a		lsr a		                lsr
.d752		20 56 d7	jsr $d756	                jsr _nibble_to_ascii
.d755		68		pla		                pla
.d756						_nibble_to_ascii:
.d756		29 0f		and #$0f	                and #$F
.d758		09 30		ora #$30	                ora #'0'
.d75a		c9 3a		cmp #$3a	                cmp #'9'+1
.d75c		90 02		bcc $d760	                bcc +
.d75e		69 06		adc #$06	                adc #6
.d760		4c d3 86	jmp $86d3	+               jmp emit_a
.d763		60		rts		                rts
.d764						find_header_name:
.d764		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d766		85 27		sta $27		                sta tmp2
.d768		b5 03		lda $03,x	                lda 3,x
.d76a		85 28		sta $28		                sta tmp2+1
.d76c						_loop:
.d76c		b2 25		lda ($25)	                lda (tmp1)
.d76e		d5 00		cmp $00,x	                cmp 0,x
.d770		d0 3a		bne $d7ac	                bne _next_entry
.d772		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d774		a0 08		ldy #$08	                ldy #8
.d776		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d778		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d77a		d0 30		bne $d7ac	                bne _next_entry ; definitely not equal if any bits differ
.d77c		a5 25		lda $25		                lda tmp1
.d77e		48		pha		                pha             ; Save original address on the stack
.d77f		18		clc		                clc
.d780		69 08		adc #$08	                adc #8
.d782		85 25		sta $25		                sta tmp1
.d784		a5 26		lda $26		                lda tmp1+1
.d786		48		pha		                pha
.d787		90 03		bcc $d78c	                bcc +
.d789		1a		inc a		                ina
.d78a		85 26		sta $26		                sta tmp1+1
.d78c						+
.d78c		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d78e		88		dey		                dey
.d78f						_next_char:
.d78f		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d791		c9 5b		cmp #$5b	                cmp #'Z'+1
.d793		b0 06		bcs $d79b	                bcs _check_char
.d795		c9 41		cmp #$41	                cmp #'A'
.d797		90 02		bcc $d79b	                bcc _check_char
.d799		09 20		ora #$20	                ora #$20
.d79b						_check_char:
.d79b		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d79d		d0 03		bne $d7a2	                bne _reset_tmp1
.d79f		88		dey		                dey
.d7a0		10 ed		bpl $d78f	                bpl _next_char
.d7a2						_reset_tmp1:
.d7a2		68		pla		                pla
.d7a3		85 26		sta $26		                sta tmp1+1
.d7a5		68		pla		                pla
.d7a6		85 25		sta $25		                sta tmp1
.d7a8		98		tya		                tya             ; leave A = $FF on success
.d7a9		c8		iny		                iny             ; if Y was $FF, we succeeded
.d7aa		f0 11		beq $d7bd	                beq _done
.d7ac						_next_entry:
.d7ac		a0 02		ldy #$02	                ldy #2
.d7ae		b1 25		lda ($25),y	                lda (tmp1),y
.d7b0		48		pha		                pha
.d7b1		c8		iny		                iny
.d7b2		b1 25		lda ($25),y	                lda (tmp1),y
.d7b4		85 26		sta $26		                sta tmp1+1
.d7b6		68		pla		                pla
.d7b7		85 25		sta $25		                sta tmp1
.d7b9		05 26		ora $26		                ora tmp1+1
.d7bb		d0 af		bne $d76c	                bne _loop
.d7bd		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d7bf		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d7c0						compare_16bit:
.d7c0		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d7c2		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d7c4		f0 08		beq $d7ce	                beq _equal
.d7c6		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7c8		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7ca		70 08		bvs $d7d4	                bvs _overflow
.d7cc		80 08		bra $d7d6	                bra _not_equal
.d7ce						_equal:
.d7ce		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7d0		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7d2		50 04		bvc $d7d8	                bvc _done
.d7d4						_overflow:
.d7d4		49 80		eor #$80	                eor #$80                ; complement negative flag
.d7d6						_not_equal:
.d7d6		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d7d8						_done:
.d7d8		60		rts		                rts
.d7d9						current_to_dp:
.d7d9		a0 08		ldy #$08	                ldy #current_offset
.d7db		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d7dd		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7de		18		clc		                clc
.d7df		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d7e1		a8		tay		                tay
.d7e2		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d7e4		85 02		sta $02		                sta dp
.d7e6		c8		iny		                iny
.d7e7		b1 08		lda ($08),y	                lda (up),y
.d7e9		85 03		sta $03		                sta dp+1
.d7eb		60		rts		                rts
.d7ec						dp_to_current:
.d7ec		a0 08		ldy #$08	                ldy #current_offset
.d7ee		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d7f0		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7f1		18		clc		                clc
.d7f2		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d7f4		a8		tay		                tay
.d7f5		a5 02		lda $02		                lda dp
.d7f7		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d7f9		c8		iny		                iny
.d7fa		a5 03		lda $03		                lda dp+1
.d7fc		91 08		sta ($08),y	                sta (up),y
.d7fe		60		rts		                rts
.d7ff						interpret:
.d7ff						_loop:
.d7ff		20 7b 8d	jsr $8d7b	                jsr w_parse_name       ; ( "string" -- addr u )
.d802		b5 00		lda $00,x	                lda 0,x
.d804		15 01		ora $01,x	                ora 1,x
.d806		f0 5b		beq $d863	                beq _line_done
.d808		20 dc 93	jsr $93dc	                jsr w_two_dup          ; ( addr u -- addr u addr u )
.d80b		20 30 9b	jsr $9b30	                jsr w_find_name        ; ( addr u addr u -- addr u nt|0 )
.d80e		b5 00		lda $00,x	                lda 0,x
.d810		15 01		ora $01,x	                ora 1,x
.d812		d0 19		bne $d82d	                bne _got_name_token
.d814		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d815		e8		inx		                inx
.d816		20 dc 9c	jsr $9cdc	                jsr w_number           ; ( addr u -- u|d )
.d819		a5 1a		lda $1a		                lda state
.d81b		f0 e2		beq $d7ff	                beq _loop
.d81d		a9 20		lda #$20	                lda #%00100000
.d81f		24 1c		bit $1c		                bit status
.d821		d0 05		bne $d828	                bne _double_number
.d823		20 20 8a	jsr $8a20	                jsr w_literal
.d826		80 d7		bra $d7ff	                bra _loop
.d828						_double_number:
.d828		20 9b 9f	jsr $9f9b	                jsr w_two_literal
.d82b		80 d2		bra $d7ff	                bra _loop
.d82d						_got_name_token:
.d82d		b5 00		lda $00,x	                lda 0,x
.d82f		95 04		sta $04,x	                sta 4,x
.d831		b5 01		lda $01,x	                lda 1,x
.d833		95 05		sta $05,x	                sta 5,x
.d835		e8		inx		                inx
.d836		e8		inx		                inx
.d837		e8		inx		                inx
.d838		e8		inx		                inx                     ; ( nt )
.d839		20 16 8d	jsr $8d16	                jsr w_one_plus
.d83c		a1 00		lda ($00,x)	                lda (0,x)
.d83e		48		pha		                pha
.d83f		20 0a 8d	jsr $8d0a	                jsr w_one_minus
.d842		20 79 9c	jsr $9c79	                jsr w_name_to_int      ; ( nt - xt )
.d845		a5 1a		lda $1a		                lda state
.d847		d0 10		bne $d859	                bne _compile
.d849		68		pla		                pla
.d84a		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d84c		f0 05		beq $d853	                beq _interpret
.d84e		a9 02		lda #$02	                lda #err_compileonly
.d850		4c 98 d8	jmp $d898	                jmp error
.d853						_interpret:
.d853		20 21 88	jsr $8821	                jsr w_execute
.d856		4c ff d7	jmp $d7ff	                jmp _loop
.d859						_compile:
.d859		68		pla		                pla
.d85a		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d85c		d0 f5		bne $d853	                bne _interpret          ; IMMEDIATE word, execute right now
.d85e		20 ef 96	jsr $96ef	                jsr w_compile_comma
.d861		80 9c		bra $d7ff	                bra _loop
.d863						_line_done:
.d863		e8		inx		                inx
.d864		e8		inx		                inx
.d865		e8		inx		                inx
.d866		e8		inx		                inx
.d867		60		rts		                rts
.d868						is_printable:
.d868		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d86a		90 08		bcc $d874	                bcc _done
.d86c		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d86e		b0 03		bcs $d873	                bcs _failed
.d870		38		sec		                sec
.d871		80 01		bra $d874	                bra _done
.d873						_failed:
.d873		18		clc		                clc
.d874						_done:
.d874		60		rts		                rts
.d875						is_whitespace:
.d875		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d877		90 08		bcc $d881	                bcc _done
.d879		c9 21		cmp #$21	                cmp #AscSP+1
.d87b		b0 03		bcs $d880	                bcs _failed
.d87d		38		sec		                sec
.d87e		80 01		bra $d881	                bra _done
.d880						_failed:
.d880		18		clc		                clc
.d881						_done:
.d881		60		rts		                rts
.d882						underflow_1:
.d882		e0 77		cpx #$77	                cpx #dsp0-1
.d884		10 10		bpl $d896	                bpl underflow_error
.d886		60		rts		                rts
.d887						underflow_2:
.d887		e0 75		cpx #$75	                cpx #dsp0-3
.d889		10 0b		bpl $d896	                bpl underflow_error
.d88b		60		rts		                rts
.d88c						underflow_3:
.d88c		e0 73		cpx #$73	                cpx #dsp0-5
.d88e		10 06		bpl $d896	                bpl underflow_error
.d890		60		rts		                rts
.d891						underflow_4:
.d891		e0 71		cpx #$71	                cpx #dsp0-7
.d893		10 01		bpl $d896	                bpl underflow_error
.d895		60		rts		                rts
.d896						underflow_error:
.d896		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d898						error:
.d898		48		pha		                pha                     ; save error
.d899		20 d8 d8	jsr $d8d8	                jsr print_error
.d89c		20 3a 84	jsr $843a	                jsr w_cr
.d89f		68		pla		                pla
.d8a0		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d8a2		d0 17		bne $d8bb	                bne _no_underflow
.d8a4		a9 0d		lda #$0d	                lda #err_returnstack
.d8a6		20 d8 d8	jsr $d8d8	                jsr print_error
.d8a9		ba		tsx		                tsx
.d8aa						-
.d8aa		e8		inx		                inx
.d8ab		f0 0b		beq $d8b8	                beq +
.d8ad		20 f6 91	jsr $91f6	                jsr w_space
.d8b0		bd 00 01	lda $0100,x	                lda $100,x
.d8b3		20 4d d7	jsr $d74d	                jsr byte_to_ascii
.d8b6		80 f2		bra $d8aa	                bra -
.d8b8						+
.d8b8		20 3a 84	jsr $843a	                jsr w_cr
.d8bb						_no_underflow:
.d8bb		4c 5e 80	jmp $805e	                jmp w_abort            ; no jsr, as we clobber return stack
.d8be						print_string_no_lf:
.d8be		0a		asl a		                asl
.d8bf		a8		tay		                tay
.d8c0		b9 cd d3	lda $d3cd,y	                lda string_table,y
.d8c3		85 29		sta $29		                sta tmp3                ; LSB
.d8c5		c8		iny		                iny
.d8c6		b9 cd d3	lda $d3cd,y	                lda string_table,y
.d8c9		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d8cb						print_common:
.d8cb		a0 00		ldy #$00	                ldy #0
.d8cd						_loop:
.d8cd		b1 29		lda ($29),y	                lda (tmp3),y
.d8cf		f0 06		beq $d8d7	                beq _done               ; strings are zero-terminated
.d8d1		20 d3 86	jsr $86d3	                jsr emit_a              ; allows vectoring via output
.d8d4		c8		iny		                iny
.d8d5		80 f6		bra $d8cd	                bra _loop
.d8d7						_done:
.d8d7		60		rts		                rts
.d8d8						print_error:
.d8d8		0a		asl a		                asl
.d8d9		a8		tay		                tay
.d8da		b9 b2 d4	lda $d4b2,y	                lda error_table,y
.d8dd		85 29		sta $29		                sta tmp3                ; LSB
.d8df		c8		iny		                iny
.d8e0		b9 b2 d4	lda $d4b2,y	                lda error_table,y
.d8e3		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d8e5		20 cb d8	jsr $d8cb	                jsr print_common
.d8e8		60		rts		                rts
.d8e9						print_string:
.d8e9		20 be d8	jsr $d8be	                jsr print_string_no_lf
.d8ec		4c 3a 84	jmp $843a	                jmp w_cr               ; JSR/RTS because never compiled
.d8ef						print_u:
.d8ef		20 39 9e	jsr $9e39	                jsr w_zero                     ; 0
.d8f2		20 fa 89	jsr $89fa	                jsr w_less_number_sign         ; <#
.d8f5		20 e0 8c	jsr $8ce0	                jsr w_number_sign_s            ; #S
.d8f8		20 be 8c	jsr $8cbe	                jsr w_number_sign_greater      ; #>
.d8fb		4c e6 94	jmp $94e6	                jmp w_type                     ; JSR/RTS because never compiled
.d8fe						code_end:

;******  Return to file: platform/simulator.asm

=$f000						io_start = $f000                ; virtual hardware addresses for the simulators
>f000						                .byte ?
>f001						io_putc:        .byte ?         ; $f001     write byte to stdout
>f002						                .byte ?
>f003						io_kbhit:       .byte ?         ; $f003     read non-zero on key ready (c65 only)
>f004						io_getc:        .byte ?         ; $f004     non-blocking read input character (0 if no key)
>f005						io_clk_start:   .byte ?         ; $f006     *read* to start cycle counter
>f006						io_clk_stop:    .byte ?         ; $f007     *read* to stop the cycle counter
>f007						io_clk_cycles:  .word ?,?       ; $f008-b   32-bit cycle count in NUXI order
>f00b						                .word ?,?
>f00f						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f010						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f011						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f013						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f015						io_end:
.f015						kernel_init:
.f015		78		sei		                sei             ; Disable interrupts
.f016		a2 00		ldx #$00	                ldx #0
.f018		bd 45 f0	lda $f045,x	-               lda s_kernel_id,x
.f01b		f0 06		beq $f023	                beq _done
.f01d		20 27 f0	jsr $f027	                jsr kernel_putc
.f020		e8		inx		                inx
.f021		80 f5		bra $f018	                bra -
.f023						_done:
.f023		4c 00 80	jmp $8000	                jmp forth
.f026						kernel_bye:
.f026		00		brk #		                brk
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta io_putc
.f02a		60		rts		                rts

;******  Return to file: platform/platform-py65mon.asm

=$f003						io_bufc = io_kbhit
.f02b						kernel_getc:
.f02b		ad 03 f0	lda $f003	                lda io_bufc             ; first check the buffer
.f02e		9c 03 f0	stz $f003	                stz io_bufc
.f031		d0 05		bne $f038	                bne _done
.f033						_loop:
.f033		ad 04 f0	lda $f004	                lda io_getc
.f036		f0 fb		beq $f033	                beq _loop
.f038						_done:
.f038		60		rts		                rts
.f039						kernel_kbhit:
.f039		ad 03 f0	lda $f003	                lda io_bufc             ; do we already have a character?
.f03c		d0 06		bne $f044	                bne _done
.f03e		ad 04 f0	lda $f004	                lda io_getc             ; otherwise check and buffer the result
.f041		8d 03 f0	sta $f003	                sta io_bufc
.f044						_done:
.f044		60		rts		                rts
.f045						s_kernel_id:
>f045		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f04d		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f05d		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f06d		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		15 f0				v_nmi   .word kernel_init
>fffc		15 f0				v_reset .word kernel_init
>fffe		15 f0				v_irq   .word kernel_init

;******  End of listing
