
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Fri May 10 18:40:45 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 2d		lda #$2d	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd bb b3	lda $b3bb,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad bb b3	lda $b3bb	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 d9 b3	lda $b3d9,y	                lda cold_user_table,y
.8024		91 08		sta ($08),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad d9 b3	lda $b3d9	                lda cold_user_table
.802c		92 08		sta ($08)	                sta (up)
.802e		20 69 85	jsr $8569	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 a9		lda #$a9	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 ba		lda #$ba	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 28 8a	jsr $8a28	                jsr xt_evaluate
.8048		9c 00 7c	stz $7c00	                stz hist_buff
.804b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057		9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060						xt_abort:
.8060		a2 78		ldx #$78	                ldx #dsp0
.8062						xt_quit:
.8062		8a		txa		                txa             ; Save the DSP that we just defined
.8063		a2 ff		ldx #$ff	                ldx #rsp0
.8065		9a		txs		                txs
.8066		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067		64 04		stz $04		                stz ip
.8069		64 05		stz $05		                stz ip+1
.806b		64 0a		stz $0a		                stz insrc
.806d		64 0b		stz $0b		                stz insrc+1
.806f		a9 00		lda #$00	                lda #0
.8071		a0 04		ldy #$04	                ldy #blk_offset
.8073		91 08		sta ($08),y	                sta (up),y
.8075		c8		iny		                iny
.8076		91 08		sta ($08),y	                sta (up),y
.8078		a9 fc		lda #$fc	                lda #(256-4)
.807a		85 1f		sta $1f		                sta loopctrl
.807c		64 1a		stz $1a		                stz state
.807e		64 1b		stz $1b		                stz state+1
.8080						_get_line:
.8080		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8082		85 0c		sta $0c		                sta cib
.8084		a9 02		lda #$02	                lda #>buffer0
.8086		85 0d		sta $0d		                sta cib+1
.8088		64 0e		stz $0e		                stz ciblen
.808a		64 0f		stz $0f		                stz ciblen+1
.808c		20 cf 90	jsr $90cf	                jsr xt_refill           ; ( -- f )
.808f		b5 00		lda $00,x	                lda 0,x
.8091		d0 05		bne $8098	                bne _success
.8093		a9 06		lda #$06	                lda #err_refill
.8095		4c 19 d8	jmp $d819	                jmp error
.8098						_success:
.8098		e8		inx		                inx                     ; drop
.8099		e8		inx		                inx
.809a		20 80 d7	jsr $d780	                jsr interpret
.809d		e0 78		cpx #$78	                cpx #dsp0
.809f		f0 05		beq $80a6	                beq _stack_ok
.80a1		90 03		bcc $80a6	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a3		4c 17 d8	jmp $d817	                jmp underflow_error
.80a6						_stack_ok:
.80a6		a5 1a		lda $1a		                lda state
.80a8		f0 02		beq $80ac	                beq _print
.80aa		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80ac						_print:
.80ac		20 6a d8	jsr $d86a	                jsr print_string
.80af		80 cf		bra $8080	                bra _get_line
.80b1						z_cold:
.80b1						z_abort:
.80b1						z_quit:

;******  Processing file: platform/../words/core.asm

.80b1						xt_abort_quote:
.80b1		20 67 91	jsr $9167	                jsr xt_s_quote          ; S"
.80b4		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b6		a9 bc		lda #$bc	                lda #<abort_quote_runtime
.80b8		20 39 d6	jsr $d639	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80bb		60		rts		z_abort_quote:  rts
.80bc						abort_quote_runtime:
.80bc		b5 04		lda $04,x	                lda 4,x
.80be		15 05		ora $05,x	                ora 5,x
.80c0		f0 09		beq $80cb	                beq _done       ; if FALSE, we're done
.80c2		20 7f 96	jsr $967f	                jsr xt_type
.80c5		20 69 85	jsr $8569	                jsr xt_cr
.80c8		4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.80cb						_done:
.80cb		8a		txa		                txa
.80cc		18		clc		                clc
.80cd		69 06		adc #$06	                adc #6
.80cf		aa		tax		                tax
.80d0		60		rts		                rts
.80d1						xt_abs:
.80d1		20 03 d8	jsr $d803	                jsr underflow_1
.80d4		b5 01		lda $01,x	                lda 1,x
.80d6		10 0d		bpl $80e5	                bpl _done       ; positive number, easy money!
.80d8		38		sec		                sec
.80d9		a9 00		lda #$00	                lda #0
.80db		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80dd		95 00		sta $00,x	                sta 0,x
.80df		a9 00		lda #$00	                lda #0          ; MSB
.80e1		f5 01		sbc $01,x	                sbc 1,x
.80e3		95 01		sta $01,x	                sta 1,x
.80e5						_done:
.80e5		60		rts		z_abs:          rts
.80e6						xt_accept:
.80e6		20 08 d8	jsr $d808	                jsr underflow_2
.80e9		b5 00		lda $00,x	                lda 0,x
.80eb		15 01		ora $01,x	                ora 1,x
.80ed		d0 09		bne $80f8	                bne _not_zero
.80ef		e8		inx		                inx
.80f0		e8		inx		                inx
.80f1		74 00		stz $00,x	                stz 0,x
.80f3		74 01		stz $01,x	                stz 1,x
.80f5		4c c4 81	jmp $81c4	                jmp accept_done
.80f8						_not_zero:
.80f8		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80fa		85 27		sta $27		                sta tmp2
.80fc		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fe		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8100		85 25		sta $25		                sta tmp1
.8102		b5 03		lda $03,x	                lda 3,x
.8104		85 26		sta $26		                sta tmp1+1
.8106		e8		inx		                inx
.8107		e8		inx		                inx
.8108		a0 00		ldy #$00	                ldy #0
.810a		a5 1c		lda $1c		                lda status
.810c		29 f7		and #$f7	                and #$F7
.810e		1a		inc a		               ina
.810f		09 08		ora #$08	                ora #%00001000
.8111		85 1c		sta $1c		                sta status
.8113						accept_loop:
.8113		20 69 8b	jsr $8b69	                jsr key_a
.8116		c9 0a		cmp #$0a	                cmp #AscLF
.8118		f0 20		beq $813a	                beq _eol
.811a		c9 0d		cmp #$0d	                cmp #AscCR
.811c		f0 1c		beq $813a	                beq _eol
.811e		c9 08		cmp #$08	                cmp #AscBS
.8120		f0 22		beq $8144	                beq _backspace
.8122		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8124		f0 1e		beq $8144	                beq _backspace
.8126		c9 10		cmp #$10	                cmp #AscCP
.8128		f0 36		beq $8160	                beq _ctrl_p
.812a		c9 0e		cmp #$0e	                cmp #AscCN
.812c		f0 44		beq $8172	                beq _ctrl_n
.812e		91 25		sta ($25),y	                sta (tmp1),y
.8130		c8		iny		                iny
.8131		20 3b 88	jsr $883b	                jsr emit_a
.8134		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8136		d0 db		bne $8113	                bne accept_loop       ; fall through if buffer limit reached
.8138		80 03		bra $813d	                bra _buffer_full
.813a						_eol:
.813a		20 73 93	jsr $9373	                jsr xt_space    ; print final space
.813d						_buffer_full:
.813d		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813f		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.8141		4c c4 81	jmp $81c4	                jmp accept_done
.8144						_backspace:
.8144		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8146		d0 06		bne $814e	                bne +
.8148		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.814a		20 3b 88	jsr $883b	                jsr emit_a
.814d		c8		iny		                iny
.814e						+
.814e		88		dey		                dey
.814f		a9 08		lda #$08	                lda #AscBS      ; move back one
.8151		20 3b 88	jsr $883b	                jsr emit_a
.8154		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8156		20 3b 88	jsr $883b	                jsr emit_a
.8159		a9 08		lda #$08	                lda #AscBS      ; move back over space
.815b		20 3b 88	jsr $883b	                jsr emit_a
.815e		80 b3		bra $8113	                bra accept_loop
.8160						_ctrl_p:
.8160		a5 1c		lda $1c		                lda status
.8162		29 07		and #$07	                and #7
.8164		d0 08		bne $816e	                bne _ctrl_p_dec
.8166		a5 1c		lda $1c		                lda status
.8168		09 07		ora #$07	                ora #7
.816a		85 1c		sta $1c		                sta status
.816c		80 11		bra $817f	                bra _recall_history
.816e						_ctrl_p_dec:
.816e		c6 1c		dec $1c		                dec status
.8170		80 0d		bra $817f	                bra _recall_history
.8172						_ctrl_n:
.8172		a9 08		lda #$08	                lda #$8
.8174		24 1c		bit $1c		                bit status
.8176		d0 07		bne $817f	                bne _recall_history
.8178		a5 1c		lda $1c		                lda status
.817a		29 f7		and #$f7	                and #$F7
.817c		1a		inc a		               ina
.817d		85 1c		sta $1c		                sta status
.817f						_recall_history:
.817f		a9 08		lda #$08	                lda #%00001000
.8181		14 1c		trb $1c		                trb status
.8183		20 df 81	jsr $81df	                jsr accept_total_recall
.8186		a9 0d		lda #$0d	                lda #AscCR
.8188		20 3b 88	jsr $883b	                jsr emit_a
.818b						input_clear:
.818b		c0 00		cpy #$00	                cpy #0
.818d		f0 08		beq $8197	                beq input_cleared
.818f		a9 20		lda #$20	                lda #AscSP
.8191		20 3b 88	jsr $883b	                jsr emit_a
.8194		88		dey		                dey
.8195		80 f4		bra $818b	                bra input_clear
.8197						input_cleared:
.8197		a9 0d		lda #$0d	                lda #AscCR
.8199		20 3b 88	jsr $883b	                jsr emit_a
.819c		b1 29		lda ($29),y	                lda (tmp3),y
.819e		85 1d		sta $1d		                sta status+1
.81a0		e6 29		inc $29		                inc tmp3
.81a2		d0 02		bne $81a6	                bne +           ; Increment the upper byte on carry.
.81a4		e6 2a		inc $2a		                inc tmp3+1
.81a6						+
.81a6		a9 0d		lda #$0d	                lda #AscCR
.81a8		20 3b 88	jsr $883b	                jsr emit_a
.81ab						_history_loop:
.81ab		c4 1d		cpy $1d		                cpy status+1
.81ad		d0 03		bne $81b2	                bne +
.81af		4c 13 81	jmp $8113	                jmp accept_loop       ; Needs a long jump
.81b2						+
.81b2		c4 27		cpy $27		                cpy tmp2
.81b4		f0 0a		beq $81c0	                beq _hist_filled_buffer
.81b6		b1 29		lda ($29),y	                lda (tmp3),y
.81b8		91 25		sta ($25),y	                sta (tmp1),y
.81ba		20 3b 88	jsr $883b	                jsr emit_a
.81bd		c8		iny		                iny
.81be		80 eb		bra $81ab	                bra _history_loop
.81c0						_hist_filled_buffer:
.81c0		88		dey		                dey
.81c1		4c 13 81	jmp $8113	                jmp accept_loop
.81c4						accept_done:
.81c4		20 df 81	jsr $81df	                jsr accept_total_recall
.81c7		85 1d		sta $1d		                sta status+1
.81c9		a0 00		ldy #$00	                ldy #0
.81cb		91 29		sta ($29),y	                sta (tmp3),y
.81cd		e6 29		inc $29		                inc tmp3
.81cf		d0 02		bne $81d3	                bne +           ; Increment the upper byte on carry.
.81d1		e6 2a		inc $2a		                inc tmp3+1
.81d3						+
.81d3						_save_history_loop:
.81d3		c4 1d		cpy $1d		                cpy status+1
.81d5		f0 07		beq $81de	                beq _save_history_done
.81d7		b1 25		lda ($25),y	                lda (tmp1),y
.81d9		91 29		sta ($29),y	                sta (tmp3),y
.81db		c8		iny		                iny
.81dc		80 f5		bra $81d3	                bra _save_history_loop
.81de						_save_history_done:
.81de						z_accept:
.81de		60		rts		                rts
.81df						accept_total_recall:
.81df		a9 00		lda #$00	                lda #<hist_buff
.81e1		85 29		sta $29		                sta tmp3
.81e3		a9 7c		lda #$7c	                lda #>hist_buff
.81e5		85 2a		sta $2a		                sta tmp3+1
.81e7		a5 1c		lda $1c		                lda status
.81e9		6a		ror a		                ror
.81ea		29 03		and #$03	                and #3
.81ec		18		clc		                clc
.81ed		65 2a		adc $2a		                adc tmp3+1
.81ef		85 2a		sta $2a		                sta tmp3+1
.81f1		a5 1c		lda $1c		                lda status
.81f3		6a		ror a		                ror             ; Rotate through carry into msb.
.81f4		6a		ror a		                ror
.81f5		29 80		and #$80	                and #$80
.81f7		18		clc		                clc
.81f8		65 29		adc $29		                adc tmp3
.81fa		85 29		sta $29		                sta tmp3
.81fc		90 02		bcc $8200	                bcc +           ; Increment the upper byte on carry.
.81fe		e6 2a		inc $2a		                inc tmp3+1
.8200						+
.8200		98		tya		                tya
.8201		c9 80		cmp #$80	                cmp #$80
.8203		90 02		bcc $8207	                bcc +
.8205		a9 7f		lda #$7f	                lda #$7F
.8207						+
.8207		60		rts		                rts
.8208						xt_action_of:
.8208		a5 1a		lda $1a		                lda state
.820a		05 1b		ora $1b		                ora state+1
.820c		f0 0c		beq $821a	                beq _interpreting
.820e						_compiling:
.820e		20 21 83	jsr $8321	                jsr xt_bracket_tick
.8211		a0 86		ldy #$86	                ldy #>xt_defer_fetch
.8213		a9 7d		lda #$7d	                lda #<xt_defer_fetch
.8215		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8218		80 06		bra $8220	                bra _done
.821a						_interpreting:
.821a		20 0c 94	jsr $940c	                jsr xt_tick
.821d		20 7d 86	jsr $867d	                jsr xt_defer_fetch
.8220						_done:
.8220		60		rts		z_action_of:           rts
.8221						xt_again:
.8221		20 03 d8	jsr $d803	                jsr underflow_1
.8224		b5 01		lda $01,x	                lda 1,x
.8226		a8		tay		                tay
.8227		b5 00		lda $00,x	                lda 0,x         ; A=LSB, Y=MSB
.8229		20 3e d6	jsr $d63e	                jsr cmpl_jump
.822c		e8		inx		                inx
.822d		e8		inx		                inx
.822e		60		rts		z_again:        rts
.822f						xt_align:
.822f						xt_aligned:
.822f						z_align:
.822f						z_aligned:
.822f		60		rts		                rts             ; stripped out during native compile
.8230						xt_allot:
.8230		20 03 d8	jsr $d803	                jsr underflow_1
.8233		b5 01		lda $01,x	                lda 1,x
.8235		30 22		bmi $8259	                bmi _release
.8237		18		clc		                clc
.8238		a5 00		lda $00		                lda cp
.823a		75 00		adc $00,x	                adc 0,x
.823c		85 00		sta $00		                sta cp
.823e		a5 01		lda $01		                lda cp+1
.8240		75 01		adc $01,x	                adc 1,x
.8242		85 01		sta $01		                sta cp+1
.8244		a0 00		ldy #$00	                ldy #<cp_end
.8246		c4 00		cpy $00		                cpy cp
.8248		a9 7c		lda #$7c	                lda #>cp_end
.824a		e5 01		sbc $01		                sbc cp+1
.824c		b0 48		bcs $8296	                bcs _done               ; we're fine.
.824e		84 00		sty $00		                sty cp                  ; still #<cp_end
.8250		a9 7c		lda #$7c	                lda #>cp_end
.8252		85 01		sta $01		                sta cp+1
.8254		a9 00		lda #$00	                lda #err_allot
.8256		4c 19 d8	jmp $d819	                jmp error
.8259						_release:
.8259		ca		dex		                dex
.825a		ca		dex		                dex
.825b		a5 00		lda $00		                lda cp
.825d		95 00		sta $00,x	                sta 0,x
.825f		a5 01		lda $01		                lda cp+1
.8261		95 01		sta $01,x	                sta 1,x
.8263		20 e6 8f	jsr $8fe6	                jsr xt_plus                     ; new CP is now TOS
.8266		ca		dex		                dex
.8267		ca		dex		                dex                             ; new CP now NOS
.8268		a9 00		lda #$00	                lda #<cp0
.826a		95 00		sta $00,x	                sta 0,x
.826c		a9 03		lda #$03	                lda #>cp0
.826e		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8270		20 41 d7	jsr $d741	                jsr compare_16bit               ; still ( CP CP0 )
.8273		f0 17		beq $828c	                beq _nega_done
.8275		30 15		bmi $828c	                bmi _nega_done
.8277		a9 00		lda #$00	                lda #<cp0
.8279		85 00		sta $00		                sta cp
.827b		a9 03		lda #$03	                lda #>cp0
.827d		85 01		sta $01		                sta cp+1
.827f		a9 8b		lda #$8b	                lda #<dictionary_start
.8281		85 02		sta $02		                sta dp
.8283		a9 bb		lda #$bb	                lda #>dictionary_start
.8285		85 03		sta $03		                sta dp+1
.8287		a9 0a		lda #$0a	                lda #err_negallot
.8289		4c 19 d8	jmp $d819	                jmp error
.828c						_nega_done:
.828c		b5 02		lda $02,x	                lda 2,x
.828e		85 00		sta $00		                sta cp
.8290		b5 03		lda $03,x	                lda 3,x
.8292		85 01		sta $01		                sta cp+1
.8294		e8		inx		                inx
.8295		e8		inx		                inx                     ; drop through to _done
.8296						_done:
.8296		e8		inx		                inx
.8297		e8		inx		                inx
.8298						z_allot:
.8298		60		rts		                rts
.8299						xt_and:
.8299		20 08 d8	jsr $d808	                jsr underflow_2
.829c		b5 00		lda $00,x	                lda 0,x
.829e		35 02		and $02,x	                and 2,x
.82a0		95 02		sta $02,x	                sta 2,x
.82a2		b5 01		lda $01,x	                lda 1,x
.82a4		35 03		and $03,x	                and 3,x
.82a6		95 03		sta $03,x	                sta 3,x
.82a8		e8		inx		                inx
.82a9		e8		inx		                inx
.82aa		60		rts		z_and:          rts
.82ab						xt_at_xy:
.82ab		20 08 d8	jsr $d808	                jsr underflow_2
.82ae		a5 18		lda $18		                lda base
.82b0		48		pha		                pha
.82b1		a9 0a		lda #$0a	                lda #10
.82b3		85 18		sta $18		                sta base
.82b5		a9 1b		lda #$1b	                lda #AscESC
.82b7		20 3b 88	jsr $883b	                jsr emit_a
.82ba		a9 5b		lda #$5b	                lda #'['
.82bc		20 3b 88	jsr $883b	                jsr emit_a
.82bf		20 7c 8e	jsr $8e7c	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c2		20 70 d8	jsr $d870	                jsr print_u
.82c5		a9 3b		lda #$3b	                lda #';'
.82c7		20 3b 88	jsr $883b	                jsr emit_a
.82ca		20 7c 8e	jsr $8e7c	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82cd		20 70 d8	jsr $d870	                jsr print_u
.82d0		a9 48		lda #$48	                lda #'H'
.82d2		20 3b 88	jsr $883b	                jsr emit_a
.82d5		68		pla		                pla
.82d6		85 18		sta $18		                sta base
.82d8		60		rts		z_at_xy:        rts
.82d9						xt_backslash:
.82d9		a0 04		ldy #$04	                ldy #blk_offset
.82db		b1 08		lda ($08),y	                lda (up),y
.82dd		c8		iny		                iny
.82de		11 08		ora ($08),y	                ora (up),y
.82e0		f0 19		beq $82fb	                beq backslash_not_block
.82e2		a5 10		lda $10		                lda toin
.82e4		29 3f		and #$3f	                and #$3F
.82e6		f0 1b		beq $8303	                beq z_backslash
.82e8		c9 01		cmp #$01	                cmp #$1
.82ea		f0 17		beq $8303	                beq z_backslash
.82ec		a5 10		lda $10		                lda toin
.82ee		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82f0		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82f1		69 40		adc #$40	                adc #$40
.82f3		85 10		sta $10		                sta toin
.82f5		90 0c		bcc $8303	                bcc z_backslash
.82f7		e6 11		inc $11		                inc toin+1
.82f9		80 08		bra $8303	                bra z_backslash
.82fb						backslash_not_block:
.82fb		a5 0e		lda $0e		                lda ciblen
.82fd		85 10		sta $10		                sta toin
.82ff		a5 0f		lda $0f		                lda ciblen+1
.8301		85 11		sta $11		                sta toin+1
.8303		60		rts		z_backslash:    rts
.8304						xt_base:
.8304		ca		dex		                dex
.8305		ca		dex		                dex
.8306		a9 18		lda #$18	                lda #<base
.8308		95 00		sta $00,x	                sta 0,x         ; LSB
.830a		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.830c		60		rts		z_base:         rts
.830d						xt_begin:
.830d		20 91 8a	jsr $8a91	                jsr xt_here
.8310		60		rts		z_begin:        rts
.8311						xt_bl:
.8311		ca		dex		                dex
.8312		ca		dex		                dex
.8313		a9 20		lda #$20	                lda #AscSP
.8315		95 00		sta $00,x	                sta 0,x
.8317		74 01		stz $01,x	                stz 1,x
.8319		60		rts		z_bl:           rts
.831a						xt_bracket_char:
.831a		20 60 83	jsr $8360	                jsr xt_char
.831d		20 aa 8b	jsr $8baa	                jsr xt_literal
.8320		60		rts		z_bracket_char: rts
.8321						xt_bracket_tick:
.8321		20 0c 94	jsr $940c	                jsr xt_tick
.8324		20 aa 8b	jsr $8baa	                jsr xt_literal
.8327		60		rts		z_bracket_tick: rts
.8328						xt_buffer_colon:
.8328		20 6f 85	jsr $856f	                jsr xt_create
.832b		20 30 82	jsr $8230	                jsr xt_allot
.832e		60		rts		z_buffer_colon: rts
.832f						xt_c_comma:
.832f		20 03 d8	jsr $d803	                jsr underflow_1
.8332		b5 00		lda $00,x	                lda 0,x
.8334		20 49 d6	jsr $d649	                jsr cmpl_a
.8337		e8		inx		                inx
.8338		e8		inx		                inx
.8339		60		rts		z_c_comma:      rts
.833a						xt_c_fetch:
.833a		20 03 d8	jsr $d803	                jsr underflow_1
.833d		a1 00		lda ($00,x)	                lda (0,x)
.833f		95 00		sta $00,x	                sta 0,x
.8341		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8343		60		rts		z_c_fetch:      rts
.8344						xt_c_store:
.8344		20 08 d8	jsr $d808	                jsr underflow_2
.8347		b5 02		lda $02,x	                lda 2,x
.8349		81 00		sta ($00,x)	                sta (0,x)
.834b		e8		inx		                inx
.834c		e8		inx		                inx
.834d		e8		inx		                inx
.834e		e8		inx		                inx
.834f		60		rts		z_c_store:      rts
.8350						xt_cell_plus:
.8350		20 03 d8	jsr $d803	                jsr underflow_1
.8353		f6 00		inc $00,x	                inc 0,x
.8355		d0 02		bne $8359	                bne +
.8357		f6 01		inc $01,x	                inc 1,x
.8359						+
.8359		f6 00		inc $00,x	                inc 0,x
.835b		d0 02		bne $835f	                bne _done
.835d		f6 01		inc $01,x	                inc 1,x
.835f						_done:
.835f		60		rts		z_cell_plus:    rts
.8360						xt_char:
.8360		20 e4 8e	jsr $8ee4	                jsr xt_parse_name
.8363		b5 00		lda $00,x	                lda 0,x
.8365		15 01		ora $01,x	                ora 1,x
.8367		d0 05		bne $836e	                bne _not_empty
.8369		a9 05		lda #$05	                lda #err_noname
.836b		4c 19 d8	jmp $d819	                jmp error
.836e						_not_empty:
.836e		e8		inx		                inx             ; drop number of characters, leave addr
.836f		e8		inx		                inx
.8370		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8372		95 00		sta $00,x	                sta 0,x
.8374		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8376		60		rts		z_char:         rts
.8377						xt_chars:
.8377		20 03 d8	jsr $d803	                jsr underflow_1
.837a		60		rts		z_chars:        rts
.837b						xt_colon:
.837b		a5 1a		lda $1a		                lda state
.837d		05 1b		ora $1b		                ora state+1
.837f		f0 05		beq $8386	                beq +
.8381		a9 07		lda #$07	                lda #err_state
.8383		4c 19 d8	jmp $d819	                jmp error
.8386						+
.8386		c6 1a		dec $1a		                dec state
.8388		c6 1b		dec $1b		                dec state+1
.838a		a9 40		lda #$40	                lda #%01000000
.838c		04 1c		tsb $1c		                tsb status
.838e		20 5a d7	jsr $d75a	                jsr current_to_dp
.8391		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8393		48		pha		                pha
.8394		a5 02		lda $02		                lda dp
.8396		48		pha		                pha
.8397		a9 80		lda #$80	                lda #%10000000
.8399		04 1c		tsb $1c		                tsb status
.839b		20 6f 85	jsr $856f	                jsr xt_create
.839e		20 5a d7	jsr $d75a	                jsr current_to_dp   ; This might be able to be omitted
.83a1		a5 02		lda $02		                lda dp
.83a3		85 06		sta $06		                sta workword
.83a5		a5 03		lda $03		                lda dp+1
.83a7		85 07		sta $07		                sta workword+1
.83a9		68		pla		                pla
.83aa		85 02		sta $02		                sta dp
.83ac		68		pla		                pla
.83ad		85 03		sta $03		                sta dp+1
.83af		20 6d d7	jsr $d76d	                jsr dp_to_current
.83b2		a5 00		lda $00		                lda cp
.83b4		38		sec		                sec
.83b5		e9 03		sbc #$03	                sbc #3
.83b7		85 00		sta $00		                sta cp
.83b9		b0 02		bcs $83bd	                bcs _done
.83bb		c6 01		dec $01		                dec cp+1
.83bd						_done:
.83bd		60		rts		z_colon:        rts
.83be						xt_colon_noname:
.83be		a5 1a		lda $1a		                lda state
.83c0		05 1b		ora $1b		                ora state+1
.83c2		f0 05		beq $83c9	                beq +
.83c4		a9 07		lda #$07	                lda #err_state
.83c6		4c 19 d8	jmp $d819	                jmp error
.83c9						+
.83c9		c6 1a		dec $1a		                dec state
.83cb		c6 1b		dec $1b		                dec state+1
.83cd		a9 40		lda #$40	                lda #%01000000
.83cf		14 1c		trb $1c		                trb status
.83d1		a5 00		lda $00		                lda cp
.83d3		85 06		sta $06		                sta workword
.83d5		a5 01		lda $01		                lda cp+1
.83d7		85 07		sta $07		                sta workword+1
.83d9						_done:
.83d9		60		rts		z_colon_noname:        rts
.83da						xt_comma:
.83da		20 03 d8	jsr $d803	                jsr underflow_1
.83dd		b5 00		lda $00,x	                lda 0,x
.83df		92 00		sta ($00)	                sta (cp)
.83e1		e6 00		inc $00		                inc cp
.83e3		d0 02		bne $83e7	                bne +
.83e5		e6 01		inc $01		                inc cp+1
.83e7						+
.83e7		b5 01		lda $01,x	                lda 1,x
.83e9		92 00		sta ($00)	                sta (cp)
.83eb		e6 00		inc $00		                inc cp
.83ed		d0 02		bne $83f1	                bne _done
.83ef		e6 01		inc $01		                inc cp+1
.83f1						_done:
.83f1		e8		inx		                inx
.83f2		e8		inx		                inx
.83f3		60		rts		z_comma:        rts
.83f4						xt_compile_comma:
.83f4		20 03 d8	jsr $d803	                jsr underflow_1
.83f7		b5 01		lda $01,x	                lda 1,x                 ; MSB
.83f9		48		pha		                pha
.83fa		b5 00		lda $00,x	                lda 0,x
.83fc		48		pha		                pha                     ; LSB
.83fd		20 ee 9b	jsr $9bee	                jsr xt_int_to_name      ; ( xt -- nt )
.8400		b5 00		lda $00,x	                lda 0,x
.8402		15 01		ora $01,x	                ora 1,x
.8404		d0 03		bne $8409	                bne _check_nt
.8406		4c 03 85	jmp $8503	                jmp compile_as_jsr
.8409						_check_nt:
.8409		b5 00		lda $00,x	                lda 0,x
.840b		85 23		sta $23		                sta tmptos
.840d		b5 01		lda $01,x	                lda 1,x
.840f		85 24		sta $24		                sta tmptos+1
.8411		f6 00		inc $00,x	                inc 0,x
.8413		d0 02		bne $8417	                bne +
.8415		f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.8417						+
.8417		a1 00		lda ($00,x)	                lda (0,x)
.8419		85 29		sta $29		                sta tmp3                ; keep copy of status byte for NN
.841b		29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.841d		f0 0d		beq $842c	                beq _compile_check
.841f		a5 23		lda $23		                lda tmptos
.8421		95 00		sta $00,x	                sta 0,x
.8423		a5 24		lda $24		                lda tmptos+1
.8425		95 01		sta $01,x	                sta 1,x
.8427		20 16 9e	jsr $9e16	                jsr xt_wordsize         ; ( nt -- u )
.842a		80 25		bra $8451	                bra _compile_as_code
.842c						_compile_check:
.842c		a5 29		lda $29		                lda tmp3
.842e		29 08		and #$08	                and #NN
.8430		f0 03		beq $8435	                beq _check_size_limit
.8432						_jumpto_compile_as_jsr:
.8432		4c 03 85	jmp $8503	                jmp compile_as_jsr    ; too far for BRA
.8435						_check_size_limit:
.8435		a5 23		lda $23		                lda tmptos
.8437		95 00		sta $00,x	                sta 0,x
.8439		a5 24		lda $24		                lda tmptos+1
.843b		95 01		sta $01,x	                sta 1,x
.843d		20 16 9e	jsr $9e16	                jsr xt_wordsize         ; ( nt -- u )
.8440		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.8442		b5 01		lda $01,x	                lda 1,x
.8444		d1 08		cmp ($08),y	                cmp (up),y
.8446		90 09		bcc $8451	                bcc _compile_as_code    ; user-defined limit MSB
.8448		d0 e8		bne $8432	                bne _jumpto_compile_as_jsr
.844a		88		dey		                dey
.844b		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.844d		d5 00		cmp $00,x	                cmp 0,x
.844f		30 e1		bmi $8432	                bmi _jumpto_compile_as_jsr
.8451						_compile_as_code:
.8451		ca		dex		                dex
.8452		ca		dex		                dex                     ; ( -- u ? )
.8453		ca		dex		                dex
.8454		ca		dex		                dex                     ; ( -- u ? ? )
.8455		b5 04		lda $04,x	                lda 4,x
.8457		95 00		sta $00,x	                sta 0,x                 ; LSB of u
.8459		b5 05		lda $05,x	                lda 5,x
.845b		95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.845d		68		pla		                pla
.845e		95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8460		68		pla		                pla
.8461		95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.8463		a5 00		lda $00		                lda cp                  ; LSB of cp
.8465		95 02		sta $02,x	                sta 2,x
.8467		a5 01		lda $01		                lda cp+1
.8469		95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.846b		a0 00		ldy #$00	                ldy #0
.846d						_strip_loop:
.846d		b9 f1 84	lda $84f1,y	                lda strip_table,y      ; LSB of first word
.8470		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8472		d0 07		bne $847b	                bne _next_entry
.8474		b9 f2 84	lda $84f2,y	                lda strip_table+1,y
.8477		d5 05		cmp $05,x	                cmp 5,x
.8479		f0 0c		beq $8487	                beq _found_entry
.847b						_next_entry:
.847b		b9 f1 84	lda $84f1,y	                lda strip_table,y      ; pointing to LSB
.847e		19 f2 84	ora $84f2,y	                ora strip_table+1,y    ; get MSB
.8481		f0 22		beq $84a5	                beq _underflow_strip    ; table done, let's get out of here
.8483		c8		iny		                iny
.8484		c8		iny		                iny
.8485		80 e6		bra $846d	                bra _strip_loop
.8487						_found_entry:
.8487		98		tya		                tya
.8488		4a		lsr a		                lsr
.8489		a8		tay		                tay
.848a		b9 fd 84	lda $84fd,y	                lda strip_size,y
.848d		85 23		sta $23		                sta tmptos              ; save a copy
.848f		18		clc		                clc
.8490		75 04		adc $04,x	                adc 4,x
.8492		95 04		sta $04,x	                sta 4,x
.8494		90 02		bcc $8498	                bcc +
.8496		f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8498						+
.8498		06 23		asl $23		                asl tmptos
.849a		38		sec		                sec
.849b		b5 00		lda $00,x	                lda 0,x
.849d		e5 23		sbc $23		                sbc tmptos
.849f		95 00		sta $00,x	                sta 0,x
.84a1		b0 02		bcs $84a5	                bcs +
.84a3		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.84a5						+
.84a5						_underflow_strip:
.84a5		a0 02		ldy #$02	                ldy #uf_strip_offset
.84a7		b1 08		lda ($08),y	                lda (up),y
.84a9		c8		iny		                iny
.84aa		11 08		ora ($08),y	                ora (up),y
.84ac		f0 1c		beq $84ca	                beq cmpl_inline
.84ae		a5 29		lda $29		                lda tmp3
.84b0		29 10		and #$10	                and #UF
.84b2		f0 16		beq $84ca	                beq cmpl_inline
.84b4		18		clc		                clc
.84b5		b5 04		lda $04,x	                lda 4,x
.84b7		69 03		adc #$03	                adc #3
.84b9		95 04		sta $04,x	                sta 4,x
.84bb		90 02		bcc $84bf	                bcc +
.84bd		f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.84bf						+
.84bf		38		sec		                sec
.84c0		b5 00		lda $00,x	                lda 0,x
.84c2		e9 03		sbc #$03	                sbc #3
.84c4		95 00		sta $00,x	                sta 0,x
.84c6		b0 02		bcs $84ca	                bcs +
.84c8		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.84ca						+
.84ca						cmpl_inline:
.84ca		b5 01		lda $01,x	                lda 1,x                 ; MSB
.84cc		48		pha		                pha
.84cd		b5 00		lda $00,x	                lda 0,x                 ; LSB
.84cf		48		pha		                pha
.84d0		20 93 8d	jsr $8d93	                jsr xt_move
.84d3		18		clc		                clc
.84d4		68		pla		                pla                     ; LSB
.84d5		65 00		adc $00		                adc cp
.84d7		85 00		sta $00		                sta cp
.84d9		68		pla		                pla                     ; MSB
.84da		65 01		adc $01		                adc cp+1
.84dc		85 01		sta $01		                sta cp+1
.84de		60		rts		                rts
.84df						cmpl_inline_y:
.84df		ca		dex		                dex             ; set up stack as ( src dst n -- )
.84e0		ca		dex		                dex
.84e1		ca		dex		                dex
.84e2		ca		dex		                dex
.84e3		94 00		sty $00,x	                sty 0,x
.84e5		74 01		stz $01,x	                stz 1,x             ; assume < 256 bytes
.84e7		a5 00		lda $00		                lda cp
.84e9		95 02		sta $02,x	                sta 2,x
.84eb		a5 01		lda $01		                lda cp+1
.84ed		95 03		sta $03,x	                sta 3,x
.84ef		80 d9		bra $84ca	                bra cmpl_inline
.84f1						strip_table:
>84f1		81 90 6c 90 36 95		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>84f7		5f 96 e5 95 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.84fd						strip_size:
>84fd		04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.8503						compile_as_jsr:
.8503		68		pla		                pla             ; LSB
.8504		7a		ply		                ply             ; MSB
.8505		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8508		e8		inx		                inx             ; drop xt
.8509		e8		inx		                inx
.850a						z_compile_comma:
.850a		60		rts		                rts
.850b						xt_compile_only:
.850b		20 5a d7	jsr $d75a	                jsr current_to_dp
.850e		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8510		b1 02		lda ($02),y	                lda (dp),y
.8512		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.8514		91 02		sta ($02),y	                sta (dp),y
.8516		60		rts		z_compile_only: rts
.8517						xt_value:
.8517						xt_constant:
.8517		20 03 d8	jsr $d803	                jsr underflow_1
.851a		20 6f 85	jsr $856f	                jsr xt_create
.851d		38		sec		                sec
.851e		a5 00		lda $00		                lda cp
.8520		e9 02		sbc #$02	                sbc #2
.8522		85 25		sta $25		                sta tmp1
.8524		a5 01		lda $01		                lda cp+1
.8526		e9 00		sbc #$00	                sbc #0
.8528		85 26		sta $26		                sta tmp1+1
.852a		a9 6b		lda #$6b	                lda #<doconst           ; LSB of DOCONST
.852c		92 25		sta ($25)	                sta (tmp1)
.852e		a0 01		ldy #$01	                ldy #1
.8530		a9 d6		lda #$d6	                lda #>doconst           ; MSB of DOCONST
.8532		91 25		sta ($25),y	                sta (tmp1),y
.8534		20 da 83	jsr $83da	                jsr xt_comma            ; drop through to adjust_z
.8537						adjust_z:
.8537		20 5f 9c	jsr $9c5f	                jsr xt_latestnt         ; gives us ( -- nt )
.853a		b5 00		lda $00,x	                lda 0,x
.853c		85 25		sta $25		                sta tmp1
.853e		b5 01		lda $01,x	                lda 1,x
.8540		85 26		sta $26		                sta tmp1+1
.8542		a0 06		ldy #$06	                ldy #6
.8544		b1 25		lda ($25),y	                lda (tmp1),y
.8546		18		clc		                clc
.8547		69 02		adc #$02	                adc #2
.8549		91 25		sta ($25),y	                sta (tmp1),y
.854b		c8		iny		                iny
.854c		b1 25		lda ($25),y	                lda (tmp1),y
.854e		69 00		adc #$00	                adc #0                  ; only need carry
.8550		91 25		sta ($25),y	                sta (tmp1),y
.8552		e8		inx		                inx
.8553		e8		inx		                inx
.8554						z_value:
.8554		60		rts		z_constant:     rts
.8555						xt_count:
.8555		20 03 d8	jsr $d803	                jsr underflow_1
.8558		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.855a		a8		tay		                tay
.855b		f6 00		inc $00,x	                inc 0,x         ; LSB
.855d		d0 02		bne $8561	                bne +
.855f		f6 01		inc $01,x	                inc 1,x         ; MSB
.8561		98		tya		+               tya
.8562		ca		dex		                dex
.8563		ca		dex		                dex
.8564		95 00		sta $00,x	                sta 0,x         ; LSB
.8566		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8568		60		rts		z_count:        rts
.8569						xt_cr:
.8569		a9 0a		lda #$0a	                lda #AscLF
.856b		20 3b 88	jsr $883b	                jsr emit_a
.856e		60		rts		z_cr:           rts
.856f						xt_create:
.856f		20 e4 8e	jsr $8ee4	                jsr xt_parse_name       ; ( addr u )
.8572		b5 00		lda $00,x	                lda 0,x
.8574		15 01		ora $01,x	                ora 1,x
.8576		d0 05		bne $857d	                bne _got_name
.8578		a9 05		lda #$05	                lda #err_noname
.857a		4c 19 d8	jmp $d819	                jmp error
.857d						_got_name:
.857d		74 01		stz $01,x	                stz 1,x
.857f		20 75 95	jsr $9575	                jsr xt_two_dup          ; ( addr u addr u )
.8582		20 36 9b	jsr $9b36	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8585		b5 00		lda $00,x	                lda 0,x
.8587		15 01		ora $01,x	                ora 1,x
.8589		f0 1e		beq $85a9	                beq _new_name           ; We haven't seen this one before.
.858b		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.858c		e8		inx		                inx
.858d		24 1c		bit $1c		                bit status
.858f		10 08		bpl $8599	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8591		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8593		05 1c		ora $1c		                ora status
.8595		85 1c		sta $1c		                sta status
.8597		80 18		bra $85b1	                bra _process_name
.8599						_redefined_name:
.8599		a9 02		lda #$02	                lda #str_redefined
.859b		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.859e		20 75 95	jsr $9575	                jsr xt_two_dup           ; ( addr u addr u )
.85a1		20 7f 96	jsr $967f	                jsr xt_type
.85a4		20 73 93	jsr $9373	                jsr xt_space
.85a7		80 08		bra $85b1	                bra _process_name
.85a9						_new_name:
.85a9		e8		inx		                inx                     ; Drop flag (0) from find-name.
.85aa		e8		inx		                inx
.85ab		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.85ad		25 1c		and $1c		                and status
.85af		85 1c		sta $1c		                sta status
.85b1						_process_name:
.85b1		b5 00		lda $00,x	                lda 0,x
.85b3		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.85b5		a5 00		lda $00		                lda cp
.85b7		85 25		sta $25		                sta tmp1
.85b9		a5 01		lda $01		                lda cp+1
.85bb		85 26		sta $26		                sta tmp1+1
.85bd		b5 00		lda $00,x	                lda 0,x
.85bf		18		clc		                clc
.85c0		69 08		adc #$08	                adc #8
.85c2		85 29		sta $29		                sta tmp3                ; total header length
.85c4		18		clc		                clc
.85c5		69 03		adc #$03	                adc #3
.85c7		95 00		sta $00,x	                sta 0,x
.85c9		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.85cb		20 30 82	jsr $8230	                jsr xt_allot    ; ( addr )
.85ce		20 5a d7	jsr $d75a	                jsr current_to_dp
.85d1		a0 00		ldy #$00	                ldy #0
.85d3		a5 27		lda $27		                lda tmp2
.85d5		91 25		sta ($25),y	                sta (tmp1),y
.85d7		a9 08		lda #$08	                lda #NN
.85d9		09 20		ora #$20	                ora #HC
.85db		c8		iny		                iny
.85dc		91 25		sta ($25),y	                sta (tmp1),y
.85de		c8		iny		                iny
.85df		a5 02		lda $02		                lda dp
.85e1		91 25		sta ($25),y	                sta (tmp1),y
.85e3		c8		iny		                iny
.85e4		a5 03		lda $03		                lda dp+1
.85e6		91 25		sta ($25),y	                sta (tmp1),y
.85e8		c8		iny		                iny
.85e9		a5 26		lda $26		                lda tmp1+1
.85eb		85 03		sta $03		                sta dp+1
.85ed		a5 25		lda $25		                lda tmp1
.85ef		85 02		sta $02		                sta dp
.85f1		18		clc		                clc
.85f2		65 29		adc $29		                adc tmp3        ; add total header length
.85f4		91 25		sta ($25),y	                sta (tmp1),y
.85f6		48		pha		                pha             ; we need this in the next step
.85f7		c8		iny		                iny
.85f8		a5 26		lda $26		                lda tmp1+1
.85fa		69 00		adc #$00	                adc #0          ; only need the carry
.85fc		91 25		sta ($25),y	                sta (tmp1),y
.85fe		c8		iny		                iny
.85ff		68		pla		                pla             ; LSB of "z_" address
.8600		18		clc		                clc
.8601		69 03		adc #$03	                adc #3
.8603		91 25		sta ($25),y	                sta (tmp1),y
.8605		88		dey		                dey             ; get the MSB of xt back
.8606		b1 25		lda ($25),y	                lda (tmp1),y
.8608		69 00		adc #$00	                adc #0          ; only need the carry
.860a		c8		iny		                iny
.860b		c8		iny		                iny
.860c		91 25		sta ($25),y	                sta (tmp1),y
.860e		c8		iny		                iny
.860f		b5 00		lda $00,x	                lda 0,x
.8611		38		sec		                sec
.8612		e9 08		sbc #$08	                sbc #8
.8614		85 23		sta $23		                sta tmptos
.8616		b5 01		lda $01,x	                lda 1,x
.8618		e9 00		sbc #$00	                sbc #0          ; only need carry
.861a		85 24		sta $24		                sta tmptos+1
.861c						_name_loop:
.861c		b1 23		lda ($23),y	                lda (tmptos),y
.861e		c9 5b		cmp #$5b	                cmp #'Z'+1
.8620		b0 06		bcs $8628	                bcs _store_name
.8622		c9 41		cmp #$41	                cmp #'A'
.8624		90 02		bcc $8628	                bcc _store_name
.8626		09 20		ora #$20	                ora #$20
.8628						_store_name:
.8628		91 25		sta ($25),y	                sta (tmp1),y
.862a		c8		iny		                iny
.862b		c6 27		dec $27		                dec tmp2
.862d		d0 ed		bne $861c	                bne _name_loop
.862f		a9 20		lda #$20	                lda #OpJSR
.8631		91 25		sta ($25),y	                sta (tmp1),y
.8633		c8		iny		                iny
.8634		a9 b1		lda #$b1	                lda #<dovar
.8636		91 25		sta ($25),y	                sta (tmp1),y
.8638		c8		iny		                iny
.8639		a9 d6		lda #$d6	                lda #>dovar
.863b		91 25		sta ($25),y	                sta (tmp1),y
.863d		20 6d d7	jsr $d76d	                jsr dp_to_current
.8640		e8		inx		                inx
.8641		e8		inx		                inx
.8642		60		rts		z_create:       rts
.8643						xt_decimal:
.8643		a9 0a		lda #$0a	                lda #10
.8645		85 18		sta $18		                sta base
.8647		64 19		stz $19		                stz base+1              ; paranoid
.8649		60		rts		z_decimal:      rts
.864a						xt_defer:
.864a		20 6f 85	jsr $856f	                jsr xt_create
.864d		a5 00		lda $00		                lda cp          ; LSB
.864f		38		sec		                sec
.8650		e9 02		sbc #$02	                sbc #2
.8652		85 25		sta $25		                sta tmp1
.8654		a5 01		lda $01		                lda cp+1        ; MSB
.8656		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8658		85 26		sta $26		                sta tmp1+1
.865a		a0 00		ldy #$00	                ldy #0
.865c		a9 7f		lda #$7f	                lda #<dodefer   ; LSB
.865e		91 25		sta ($25),y	                sta (tmp1),y
.8660		c8		iny		                iny
.8661		a9 d6		lda #$d6	                lda #>dodefer   ; MSB
.8663		91 25		sta ($25),y	                sta (tmp1),y
.8665		a9 93		lda #$93	                lda #<defer_error
.8667		92 00		sta ($00)	                sta (cp)
.8669		e6 00		inc $00		                inc cp
.866b		d0 02		bne $866f	                bne +
.866d		e6 01		inc $01		                inc cp+1
.866f						+
.866f		a9 d6		lda #$d6	                lda #>defer_error
.8671		92 00		sta ($00)	                sta (cp)
.8673		e6 00		inc $00		                inc cp
.8675		d0 02		bne $8679	                bne +
.8677		e6 01		inc $01		                inc cp+1
.8679						+
.8679		20 37 85	jsr $8537	                jsr adjust_z    ; adjust header to correct length
.867c		60		rts		z_defer:        rts
.867d						xt_defer_fetch:
.867d		20 68 94	jsr $9468	                jsr xt_to_body
.8680		20 90 89	jsr $8990	                jsr xt_fetch
.8683		60		rts		z_defer_fetch:  rts
.8684						xt_defer_store:
.8684		20 68 94	jsr $9468	                jsr xt_to_body
.8687		20 e2 93	jsr $93e2	                jsr xt_store
.868a		60		rts		z_defer_store:  rts
.868b						xt_depth:
.868b		a9 78		lda #$78	                lda #dsp0
.868d		86 1e		stx $1e		                stx tmpdsp
.868f		38		sec		                sec
.8690		e5 1e		sbc $1e		                sbc tmpdsp
.8692		4a		lsr a		                lsr
.8693		ca		dex		                dex
.8694		ca		dex		                dex
.8695		95 00		sta $00,x	                sta 0,x
.8697		74 01		stz $01,x	                stz 1,x
.8699		60		rts		z_depth:        rts
.869a						xt_question_do:
.869a		a0 01		ldy #$01	                ldy #1                  ; 1 is ?DO, jump to common code
.869c		80 02		bra $86a0	                bra do_common           ; skip flag for DO
.869e						xt_do:
.869e		a0 00		ldy #$00	                ldy #0                ; 0 is DO, drop through to DO_COMMON
.86a0						do_common:
.86a0		f0 18		beq $86ba	                beq _compile_do
.86a2		ca		dex		                dex
.86a3		ca		dex		                dex
.86a4		a9 d7		lda #$d7	                lda #<question_do_runtime
.86a6		95 00		sta $00,x	                sta 0,x
.86a8		a9 86		lda #$86	                lda #>question_do_runtime
.86aa		95 01		sta $01,x	                sta 1,x
.86ac		a0 10		ldy #$10	                ldy #question_do_runtime_end-question_do_runtime
.86ae		20 df 84	jsr $84df	                jsr cmpl_inline_y
.86b1		a5 00		lda $00		                lda cp
.86b3		a4 01		ldy $01		                ldy cp+1
.86b5		48		pha		                pha
.86b6		20 45 d6	jsr $d645	                jsr cmpl_word      ; write two arbitrary placeholder bytes
.86b9		68		pla		                pla
.86ba						_compile_do:
.86ba		ca		dex		                dex
.86bb		ca		dex		                dex
.86bc		95 00		sta $00,x	                sta 0,x
.86be		98		tya		                tya
.86bf		95 01		sta $01,x	                sta 1,x
.86c1		ca		dex		                dex
.86c2		ca		dex		                dex
.86c3		a5 21		lda $21		                lda loopleave
.86c5		95 00		sta $00,x	                sta 0,x
.86c7		a5 22		lda $22		                lda loopleave+1
.86c9		95 01		sta $01,x	                sta 1,x
.86cb		64 22		stz $22		                stz loopleave+1
.86cd		a0 86		ldy #$86	                ldy #>do_runtime
.86cf		a9 e7		lda #$e7	                lda #<do_runtime
.86d1		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.86d4		4c 91 8a	jmp $8a91	                jmp xt_here
.86d7						z_question_do:
.86d7						z_do:
.86d7						question_do_runtime:
.86d7		20 75 95	jsr $9575	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.86da		20 0c 89	jsr $890c	                jsr xt_equal            ; ( -- n1 n2 f )
.86dd		20 db 8a	jsr $8adb	                jsr zero_test_runtime   ; consume f, setting Z
.86e0		f0 07		beq $86e9	                beq question_do_runtime_end+2
.86e2		e8		inx		                inx                     ; drop loop limits
.86e3		e8		inx		                inx
.86e4		e8		inx		                inx
.86e5		e8		inx		                inx
>86e6		4c				                .byte OpJMP             ; jmp
.86e7						question_do_runtime_end:
.86e7						do_runtime:
.86e7		a4 1f		ldy $1f		                ldy loopctrl
.86e9		30 05		bmi $86f0	                bmi +                   ; is this the first LCB?
.86eb		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.86ed		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.86f0						+
.86f0		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.86f1		c8		iny		                iny
.86f2		c8		iny		                iny
.86f3		c8		iny		                iny
.86f4		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.86f6		38		sec		                sec
.86f7		a9 00		lda #$00	                lda #0
.86f9		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.86fb		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.86fe		a9 80		lda #$80	                lda #$80
.8700		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.8702		99 03 01	sta $0103,y	                sta loopfufa+1,y
.8705		18		clc		                clc
.8706		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.8708		79 02 01	adc $0102,y	                adc loopfufa,y
.870b		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.870d		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.870f		79 03 01	adc $0103,y	                adc loopfufa+1,y
.8712		99 01 01	sta $0101,y	                sta loopindex+1,y
.8715		e8		inx		                inx                 ; clean up the stack
.8716		e8		inx		                inx
.8717		e8		inx		                inx
.8718		e8		inx		                inx
.8719		60		rts		                rts
.871a						xt_does:
.871a		a0 87		ldy #$87	                ldy #>does_runtime
.871c		a9 29		lda #$29	                lda #<does_runtime
.871e		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8721		a0 d6		ldy #$d6	                ldy #>dodoes
.8723		a9 98		lda #$98	                lda #<dodoes
.8725		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8728		60		rts		z_does:         rts
.8729						does_runtime:
.8729		7a		ply		                ply             ; LSB
.872a		68		pla		                pla             ; MSB
.872b		c8		iny		                iny
.872c		d0 01		bne $872f	                bne +
.872e		1a		inc a		                ina
.872f						+
.872f		84 25		sty $25		                sty tmp1
.8731		85 26		sta $26		                sta tmp1+1
.8733		20 5a d7	jsr $d75a	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8736		a5 02		lda $02		                lda dp
.8738		18		clc		                clc
.8739		69 04		adc #$04	                adc #4
.873b		85 27		sta $27		                sta tmp2
.873d		a5 03		lda $03		                lda dp+1
.873f		69 00		adc #$00	                adc #0          ; we only care about the carry
.8741		85 28		sta $28		                sta tmp2+1
.8743		b2 27		lda ($27)	                lda (tmp2)
.8745		18		clc		                clc
.8746		69 01		adc #$01	                adc #1
.8748		85 29		sta $29		                sta tmp3
.874a		a0 01		ldy #$01	                ldy #1
.874c		b1 27		lda ($27),y	                lda (tmp2),y
.874e		69 00		adc #$00	                adc #0          ; we only care about the carry
.8750		85 2a		sta $2a		                sta tmp3+1
.8752		a5 25		lda $25		                lda tmp1        ; LSB
.8754		92 29		sta ($29)	                sta (tmp3)
.8756		a5 26		lda $26		                lda tmp1+1
.8758		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.875a		60		rts		                rts
.875b						xt_dot:
.875b		20 03 d8	jsr $d803	                jsr underflow_1
.875e		20 cb 87	jsr $87cb	                jsr xt_dup                      ; ( n n )
.8761		20 d1 80	jsr $80d1	                jsr xt_abs                      ; ( n u )
.8764		20 37 9e	jsr $9e37	                jsr xt_zero                     ; ( n u 0 )
.8767		20 87 8b	jsr $8b87	                jsr xt_less_number_sign         ; ( n u 0 )
.876a		20 46 8e	jsr $8e46	                jsr xt_number_sign_s            ; ( n ud )
.876d		20 1e 91	jsr $911e	                jsr xt_rot                      ; ( ud n )
.8770		20 f8 92	jsr $92f8	                jsr xt_sign                     ; ( ud )
.8773		20 24 8e	jsr $8e24	                jsr xt_number_sign_greater      ; ( addr u )
.8776		20 7f 96	jsr $967f	                jsr xt_type
.8779		20 73 93	jsr $9373	                jsr xt_space
.877c		60		rts		z_dot:          rts
.877d						xt_dot_paren:
.877d		ca		dex		                dex
.877e		ca		dex		                dex
.877f		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8781		95 00		sta $00,x	                sta 0,x
.8783		74 01		stz $01,x	                stz 1,x
.8785		20 3f 8f	jsr $8f3f	                jsr xt_parse
.8788		20 7f 96	jsr $967f	                jsr xt_type
.878b		60		rts		z_dot_paren:    rts
.878c						xt_dot_quote:
.878c		20 67 91	jsr $9167	                jsr xt_s_quote
.878f		a0 96		ldy #$96	                ldy #>xt_type
.8791		a9 7f		lda #$7f	                lda #<xt_type
.8793		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8796		60		rts		z_dot_quote:    rts
.8797						xt_dot_r:
.8797		20 08 d8	jsr $d808	                jsr underflow_2
.879a		20 36 95	jsr $9536	                jsr xt_to_r
.879d		20 cb 87	jsr $87cb	                jsr xt_dup
.87a0		20 d1 80	jsr $80d1	                jsr xt_abs
.87a3		20 37 9e	jsr $9e37	                jsr xt_zero
.87a6		20 87 8b	jsr $8b87	                jsr xt_less_number_sign
.87a9		20 46 8e	jsr $8e46	                jsr xt_number_sign_s
.87ac		20 1e 91	jsr $911e	                jsr xt_rot
.87af		20 f8 92	jsr $92f8	                jsr xt_sign
.87b2		20 24 8e	jsr $8e24	                jsr xt_number_sign_greater
.87b5		20 81 90	jsr $9081	                jsr xt_r_from
.87b8		20 98 8e	jsr $8e98	                jsr xt_over
.87bb		20 77 8d	jsr $8d77	                jsr xt_minus
.87be		20 79 93	jsr $9379	                jsr xt_spaces
.87c1		20 7f 96	jsr $967f	                jsr xt_type
.87c4		60		rts		z_dot_r:        rts
.87c5						xt_drop:
.87c5		20 03 d8	jsr $d803	                jsr underflow_1
.87c8		e8		inx		                inx
.87c9		e8		inx		                inx
.87ca		60		rts		z_drop:         rts
.87cb						xt_dup:
.87cb		20 03 d8	jsr $d803	                jsr underflow_1
.87ce		ca		dex		                dex
.87cf		ca		dex		                dex
.87d0		b5 02		lda $02,x	                lda 2,x         ; LSB
.87d2		95 00		sta $00,x	                sta 0,x
.87d4		b5 03		lda $03,x	                lda 3,x         ; MSB
.87d6		95 01		sta $01,x	                sta 1,x
.87d8		60		rts		z_dup:          rts
.87d9						xt_else:
.87d9						xt_endof:
.87d9		20 91 8a	jsr $8a91	                jsr xt_here
.87dc		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.87df		20 3e d6	jsr $d63e	                jsr cmpl_jump
.87e2		20 f8 93	jsr $93f8	                jsr xt_swap         ; ( target orig )
.87e5						xt_then:
.87e5		20 91 8a	jsr $8a91	                jsr xt_here
.87e8		a1 02		lda ($02,x)	                lda (2,x)           ; get LSB at orig
.87ea		1a		inc a		                ina                 ; was LSB $FF?  (only check for $XXFF)
.87eb		d0 3b		bne $8828	                bne _no_opt
.87ed		20 75 95	jsr $9575	                jsr xt_two_dup
.87f0		20 f8 93	jsr $93f8	                jsr xt_swap
.87f3		20 77 8d	jsr $8d77	                jsr xt_minus        ; ( C: orig here offset )
.87f6		b5 01		lda $01,x	                lda 1,x
.87f8		d0 2c		bne $8826	                bne _too_far        ; MSB must be zero
.87fa		b5 00		lda $00,x	                lda 0,x
.87fc		3a		dec a		                dea                 ; we want here - orig - 2
.87fd		3a		dec a		                dea                 ; don't care about carry
.87fe		30 26		bmi $8826	                bmi _too_far        ; up to 127 is ok
.8800		95 00		sta $00,x	                sta 0,x             ; stash offset - 2
.8802		38		sec		                sec                 ; put orig - 2 in tmp1
.8803		b5 04		lda $04,x	                lda 4,x
.8805		e9 02		sbc #$02	                sbc #2
.8807		85 25		sta $25		                sta tmp1
.8809		b5 05		lda $05,x	                lda 5,x
.880b		e9 00		sbc #$00	                sbc #0
.880d		85 26		sta $26		                sta tmp1+1
.880f		a0 00		ldy #$00	                ldy #0
.8811						-
.8811		b9 30 88	lda $8830,y	                lda beq_opt+1,y               ; skip the jsr
.8814		91 25		sta ($25),y	                sta (tmp1),y
.8816		c8		iny		                iny
.8817		c0 03		cpy #$03	                cpy #(beq_opt_end-beq_opt-2)  ; three bytes, skip jsr and offset
.8819		d0 f6		bne $8811	                bne -
.881b		b5 00		lda $00,x	                lda 0,x             ; write the offset
.881d		91 25		sta ($25),y	                sta (tmp1),y
.881f		e8		inx		                inx                 ; clear the stack
.8820		e8		inx		                inx
.8821		e8		inx		                inx
.8822		e8		inx		                inx
.8823		e8		inx		                inx
.8824		e8		inx		                inx
.8825		60		rts		                rts                 ; all done
.8826						_too_far:
.8826		e8		inx		                inx                 ; discard the offset we calculated
.8827		e8		inx		                inx
.8828						_no_opt:
.8828		20 f8 93	jsr $93f8	                jsr xt_swap
.882b		20 e2 93	jsr $93e2	                jsr xt_store
.882e						z_else:
.882e						z_endof:
.882e		60		rts		z_then:         rts
.882f						beq_opt:
.882f		20 db 8a	jsr $8adb	                jsr zero_test_runtime       ; replaces jsr zero_branch_runtime
.8832		f0 00		beq $8834	                beq beq_opt_end             ; the beq overwrites the placeholder
.8834						beq_opt_end:
.8834						xt_emit:
.8834		20 03 d8	jsr $d803	                jsr underflow_1
.8837		b5 00		lda $00,x	                lda 0,x
.8839		e8		inx		                inx
.883a		e8		inx		                inx
.883b						emit_a:
.883b		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.883e						z_emit:
.883e						xt_endcase:
.883e		a0 87		ldy #$87	                ldy #>xt_drop
.8840		a9 c5		lda #$c5	                lda #<xt_drop
.8842		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8845						_endcase_loop:
.8845		b5 00		lda $00,x	                lda 0,x
.8847		15 01		ora $01,x	                ora 1,x
.8849		f0 05		beq $8850	                beq _done
.884b		20 e5 87	jsr $87e5	                jsr xt_then
.884e		80 f5		bra $8845	                bra _endcase_loop
.8850						_done:
.8850		e8		inx		                inx
.8851		e8		inx		                inx
.8852		60		rts		z_endcase:      rts
.8853						xt_environment_q:
.8853		20 03 d8	jsr $d803	                jsr underflow_1
.8856		a0 00		ldy #$00	                ldy #00                 ; counter for table
.8858		5a		phy		                phy
.8859						_table_loop:
.8859		20 75 95	jsr $9575	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.885c		ca		dex		                dex
.885d		ca		dex		                dex                     ; ( addr u addr u ? )
.885e		b9 d0 88	lda $88d0,y	                lda env_table_single,y
.8861		95 00		sta $00,x	                sta 0,x
.8863		c8		iny		                iny
.8864		b9 d0 88	lda $88d0,y	                lda env_table_single,y
.8867		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8869		c8		iny		                iny
.886a		15 00		ora $00,x	                ora 0,x
.886c		f0 4d		beq $88bb	                beq _table_done
.886e		5a		phy		                phy                     ; save Y, which is used by COUNT
.886f		20 55 85	jsr $8555	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8872		20 fe 9f	jsr $9ffe	                jsr xt_compare          ; ( addr u f )
.8875		7a		ply		                ply
.8876		b5 00		lda $00,x	                lda 0,x
.8878		15 01		ora $01,x	                ora 1,x
.887a		f0 04		beq $8880	                beq _got_result
.887c		e8		inx		                inx                     ; DROP, now ( addr u )
.887d		e8		inx		                inx
.887e		80 d9		bra $8859	                bra _table_loop
.8880						_got_result:
.8880		e8		inx		                inx                     ; drop flag, now ( addr u )
.8881		e8		inx		                inx
.8882		88		dey		                dey                     ; go back to index we had
.8883		88		dey		                dey
.8884		68		pla		                pla
.8885		d0 0d		bne $8894	                bne _double_result
.8887		b9 ee 88	lda $88ee,y	                lda env_results_single,y
.888a		95 02		sta $02,x	                sta 2,x
.888c		c8		iny		                iny
.888d		b9 ee 88	lda $88ee,y	                lda env_results_single,y
.8890		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8892		80 1f		bra $88b3	                bra _set_flag
.8894						_double_result:
.8894		ca		dex		                dex                     ; ( addr u ? )
.8895		ca		dex		                dex
.8896		98		tya		                tya
.8897		38		sec		                sec
.8898		e9 18		sbc #$18	                sbc #24
.889a		0a		asl a		                asl
.889b		a8		tay		                tay
.889c		b9 04 89	lda $8904,y	                lda env_results_double,y
.889f		95 02		sta $02,x	                sta 2,x
.88a1		c8		iny		                iny
.88a2		b9 04 89	lda $8904,y	                lda env_results_double,y
.88a5		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.88a7		c8		iny		                iny
.88a8		b9 04 89	lda $8904,y	                lda env_results_double,y
.88ab		95 04		sta $04,x	                sta 4,x
.88ad		c8		iny		                iny
.88ae		b9 04 89	lda $8904,y	                lda env_results_double,y
.88b1		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.88b3						_set_flag:
.88b3		a9 ff		lda #$ff	                lda #$FF
.88b5		95 00		sta $00,x	                sta 0,x
.88b7		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.88b9		80 14		bra $88cf	                bra _done
.88bb						_table_done:
.88bb		68		pla		                pla
.88bc		d0 09		bne $88c7	                bne _no_match
.88be		1a		inc a		                ina
.88bf		48		pha		                pha
.88c0		8a		txa		                txa
.88c1		18		clc		                clc
.88c2		69 06		adc #$06	                adc #6                  ; skip six bytes
.88c4		aa		tax		                tax                     ; ( addr u )
.88c5		80 92		bra $8859	                bra _table_loop
.88c7						_no_match:
.88c7		8a		txa		                txa
.88c8		18		clc		                clc
.88c9		69 0a		adc #$0a	                adc #10
.88cb		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.88cc		20 37 9e	jsr $9e37	                jsr xt_false
.88cf						_done:
.88cf						z_environment_q:
.88cf		60		rts		                rts
.88d0						env_table_single:
>88d0		b9 d5 c9 d5 cf d5 d4 d5		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>88d8		e6 d5
>88da		ee d5 f7 d5 fd d5 03 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>88e2		16 d6 22 d6 00 00		        .word envs_sc, envs_wl, 0000
.88e8						env_table_double:
>88e8		2c d6 32 d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.88ee						env_results_single:
>88ee		ff 00				        .word $00FF     ; /COUNTED-STRING
>88f0		ff 00				        .word $00FF     ; /HOLD
>88f2		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>88f4		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>88f6		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>88f8		ff 00				        .word $00FF     ; MAX-CHAR
>88fa		ff 7f				        .word $7FFF     ; MAX-N
>88fc		ff ff				        .word $FFFF     ; MAX-U
>88fe		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8900		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8902		09 00				        .word $0009     ; WORDLISTS
.8904						env_results_double:
>8904		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8908		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.890c						xt_equal:
.890c		20 08 d8	jsr $d808	                jsr underflow_2
.890f		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8911		d5 02		cmp $02,x	                cmp 2,x
.8913		d0 0a		bne $891f	                bne _false
.8915		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8917		d5 03		cmp $03,x	                cmp 3,x
.8919		d0 04		bne $891f	                bne _false
.891b		a9 ff		lda #$ff	                lda #$FF
.891d		80 02		bra $8921	                bra _done
.891f		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8921		95 02		sta $02,x	_done:          sta 2,x
.8923		95 03		sta $03,x	                sta 3,x
.8925		e8		inx		                inx
.8926		e8		inx		                inx
.8927		60		rts		z_equal:        rts
.8928						xt_blank:
.8928		ca		dex		                dex
.8929		ca		dex		                dex
.892a		a9 20		lda #$20	                lda #AscSP
.892c		95 00		sta $00,x	                sta 0,x
.892e		74 01		stz $01,x	                stz 1,x
.8930		80 06		bra $8938	                bra xt_fill     ; skip over code for ERASE
.8932						xt_erase:
.8932		ca		dex		                dex
.8933		ca		dex		                dex
.8934		74 00		stz $00,x	                stz 0,x
.8936		74 01		stz $01,x	                stz 1,x
.8938						xt_fill:
.8938		20 0d d8	jsr $d80d	                jsr underflow_3
.893b		b5 04		lda $04,x	                lda 4,x         ; LSB
.893d		85 25		sta $25		                sta tmp1
.893f		b5 05		lda $05,x	                lda 5,x
.8941		85 26		sta $26		                sta tmp1+1
.8943		b5 02		lda $02,x	                lda 2,x
.8945		85 27		sta $27		                sta tmp2
.8947		b5 03		lda $03,x	                lda 3,x
.8949		85 28		sta $28		                sta tmp2+1
.894b		b5 00		lda $00,x	                lda 0,x
.894d		a8		tay		                tay
.894e						_loop:
.894e		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8950		c5 26		cmp $26		                cmp tmp1+1
.8952		90 21		bcc $8975	                bcc _done               ; RAM_END < TMP1, so leave
.8954		d0 06		bne $895c	                bne _check_counter      ; RAM_END is not smaller and not equal
.8956		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8958		c5 25		cmp $25		                cmp tmp1
.895a		90 19		bcc $8975	                bcc _done               ; RAM_END < TMP1, so leave
.895c						_check_counter:
.895c		a5 27		lda $27		                lda tmp2
.895e		05 28		ora $28		                ora tmp2+1
.8960		f0 13		beq $8975	                beq _done
.8962		98		tya		                tya
.8963		92 25		sta ($25)	                sta (tmp1)
.8965		a5 27		lda $27		                lda tmp2
.8967		d0 02		bne $896b	                bne +
.8969		c6 28		dec $28		                dec tmp2+1
.896b		c6 27		dec $27		+               dec tmp2
.896d		e6 25		inc $25		                inc tmp1
.896f		d0 dd		bne $894e	                bne _loop
.8971		e6 26		inc $26		                inc tmp1+1
.8973		80 d9		bra $894e	                bra _loop
.8975						_done:
.8975		8a		txa		                txa
.8976		18		clc		                clc
.8977		69 06		adc #$06	                adc #6
.8979		aa		tax		                tax
.897a						z_blank:
.897a						z_erase:
.897a		60		rts		z_fill:         rts
.897b						xt_execute:
.897b		20 03 d8	jsr $d803	                jsr underflow_1
.897e		20 82 89	jsr $8982	                jsr doexecute   ; do not combine to JMP (native coding)
.8981		60		rts		z_execute:      rts
.8982						doexecute:
.8982		b5 00		lda $00,x	                lda 0,x
.8984		85 04		sta $04		                sta ip
.8986		b5 01		lda $01,x	                lda 1,x
.8988		85 05		sta $05		                sta ip+1
.898a		e8		inx		                inx
.898b		e8		inx		                inx
.898c		6c 04 00	jmp ($0004)	                jmp (ip)
.898f						xt_exit:
.898f		60		rts		                rts             ; keep before z_exit
.8990						z_exit:
.8990						xt_fetch:
.8990		20 03 d8	jsr $d803	                jsr underflow_1
.8993		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8995		a8		tay		                tay
.8996		f6 00		inc $00,x	                inc 0,x
.8998		d0 02		bne $899c	                bne +
.899a		f6 01		inc $01,x	                inc 1,x
.899c						+
.899c		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.899e		95 01		sta $01,x	                sta 1,x
.89a0		94 00		sty $00,x	                sty 0,x
.89a2		60		rts		z_fetch:        rts
.89a3						xt_find:
.89a3		20 03 d8	jsr $d803	                jsr underflow_1
.89a6		b5 01		lda $01,x	                lda 1,x                 ; MSB
.89a8		48		pha		                pha
.89a9		b5 00		lda $00,x	                lda 0,x                 ; LSB
.89ab		48		pha		                pha
.89ac		20 55 85	jsr $8555	                jsr xt_count            ; ( caddr -- addr u )
.89af		20 36 9b	jsr $9b36	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.89b2		b5 00		lda $00,x	                lda 0,x
.89b4		15 01		ora $01,x	                ora 1,x
.89b6		d0 0b		bne $89c3	                bne _found_word
.89b8		20 37 9e	jsr $9e37	                jsr xt_false            ; ( 0 0 )
.89bb		68		pla		                pla                     ; LSB of address
.89bc		95 02		sta $02,x	                sta 2,x
.89be		68		pla		                pla
.89bf		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.89c1		80 27		bra $89ea	                bra _done               ; ( addr 0 )
.89c3						_found_word:
.89c3		68		pla		                pla
.89c4		68		pla		                pla
.89c5		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( nt nt )
.89c8		20 74 9c	jsr $9c74	                jsr xt_name_to_int      ; ( nt xt )
.89cb		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( xt nt )
.89ce		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.89d0		f6 00		inc $00,x	                inc 0,x
.89d2		d0 02		bne $89d6	                bne +
.89d4		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.89d6						+
.89d6		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.89d8		29 04		and #$04	                and #IM
.89da		d0 08		bne $89e4	                bne _immediate          ; bit set, we're immediate
.89dc		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.89de		95 00		sta $00,x	                sta 0,x
.89e0		95 01		sta $01,x	                sta 1,x
.89e2		80 06		bra $89ea	                bra _done
.89e4						_immediate:
.89e4		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.89e6		95 00		sta $00,x	                sta 0,x
.89e8		74 01		stz $01,x	                stz 1,x
.89ea						_done:
.89ea		60		rts		z_find:         rts
.89eb						xt_fm_slash_mod:
.89eb		20 0d d8	jsr $d80d	                jsr underflow_3
.89ee		64 27		stz $27		                stz tmp2        ; default: n is positive
.89f0		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.89f2		10 0e		bpl $8a02	                bpl _check_d
.89f4		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.89f6		20 b2 8d	jsr $8db2	                jsr xt_negate   ; NEGATE
.89f9		20 36 95	jsr $9536	                jsr xt_to_r     ; >R
.89fc		20 a5 9e	jsr $9ea5	                jsr xt_dnegate  ; DNEGATE
.89ff		20 81 90	jsr $9081	                jsr xt_r_from   ; R>
.8a02						_check_d:
.8a02		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.8a04		10 0d		bpl $8a13	                bpl _multiply
.8a06		18		clc		                clc
.8a07		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.8a09		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8a0b		95 02		sta $02,x	                sta 2,x
.8a0d		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8a0f		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.8a11		95 03		sta $03,x	                sta 3,x
.8a13						_multiply:
.8a13		20 04 97	jsr $9704	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.8a16		a5 27		lda $27		                lda tmp2
.8a18		f0 07		beq $8a21	                beq _done
.8a1a		e8		inx		                inx             ; pretend that we SWAP
.8a1b		e8		inx		                inx
.8a1c		20 b2 8d	jsr $8db2	                jsr xt_negate
.8a1f		ca		dex		                dex
.8a20		ca		dex		                dex
.8a21						_done:
.8a21		60		rts		z_fm_slash_mod: rts
.8a22						load_evaluate:
.8a22		a9 ff		lda #$ff	                lda #$FF
.8a24		85 25		sta $25		                sta tmp1
.8a26		80 11		bra $8a39	                bra load_evaluate_start
.8a28						xt_evaluate:
.8a28		20 08 d8	jsr $d808	                jsr underflow_2
.8a2b		64 25		stz $25		                stz tmp1
.8a2d		b5 00		lda $00,x	                lda 0,x
.8a2f		15 01		ora $01,x	                ora 1,x
.8a31		d0 06		bne $8a39	                bne evaluate_got_work
.8a33		e8		inx		                inx
.8a34		e8		inx		                inx
.8a35		e8		inx		                inx
.8a36		e8		inx		                inx
.8a37		80 42		bra $8a7b	                bra evaluate_done
.8a39						load_evaluate_start:
.8a39						evaluate_got_work:
.8a39		a0 05		ldy #$05	                ldy #blk_offset+1
.8a3b		b1 08		lda ($08),y	                lda (up),y
.8a3d		48		pha		                pha
.8a3e		88		dey		                dey
.8a3f		b1 08		lda ($08),y	                lda (up),y
.8a41		48		pha		                pha
.8a42		a5 25		lda $25		                lda tmp1
.8a44		d0 05		bne $8a4b	                bne _nozero
.8a46		91 08		sta ($08),y	                sta (up),y
.8a48		c8		iny		                iny
.8a49		91 08		sta ($08),y	                sta (up),y
.8a4b						_nozero:
.8a4b		20 d8 9b	jsr $9bd8	                jsr xt_input_to_r
.8a4e		a9 ff		lda #$ff	                lda #$FF
.8a50		85 0a		sta $0a		                sta insrc
.8a52		85 0b		sta $0b		                sta insrc+1
.8a54		64 10		stz $10		                stz toin
.8a56		64 11		stz $11		                stz toin+1
.8a58		b5 00		lda $00,x	                lda 0,x
.8a5a		85 0e		sta $0e		                sta ciblen
.8a5c		b5 01		lda $01,x	                lda 1,x
.8a5e		85 0f		sta $0f		                sta ciblen+1
.8a60		b5 02		lda $02,x	                lda 2,x
.8a62		85 0c		sta $0c		                sta cib
.8a64		b5 03		lda $03,x	                lda 3,x
.8a66		85 0d		sta $0d		                sta cib+1
.8a68		e8		inx		                inx             ; A clean stack is a clean mind
.8a69		e8		inx		                inx
.8a6a		e8		inx		                inx
.8a6b		e8		inx		                inx
.8a6c		20 80 d7	jsr $d780	                jsr interpret   ; ( -- )
.8a6f		20 e5 9d	jsr $9de5	                jsr xt_r_to_input
.8a72		a0 04		ldy #$04	                ldy #blk_offset
.8a74		68		pla		                pla
.8a75		91 08		sta ($08),y	                sta (up),y
.8a77		c8		iny		                iny
.8a78		68		pla		                pla
.8a79		91 08		sta ($08),y	                sta (up),y
.8a7b						evaluate_done:
.8a7b		60		rts		z_evaluate:     rts
.8a7c						xt_greater_than:
.8a7c		20 08 d8	jsr $d808	                jsr underflow_2
.8a7f		a0 00		ldy #$00	                ldy #0          ; default false
.8a81		20 41 d7	jsr $d741	                jsr compare_16bit
.8a84		f0 03		beq $8a89	                beq _false
.8a86		10 01		bpl $8a89	                bpl _false
.8a88		88		dey		                dey
.8a89						_false:
.8a89		98		tya		                tya
.8a8a		e8		inx		                inx
.8a8b		e8		inx		                inx
.8a8c		95 00		sta $00,x	                sta 0,x
.8a8e		95 01		sta $01,x	                sta 1,x
.8a90		60		rts		z_greater_than: rts
.8a91						xt_here:
.8a91						xt_asm_arrow:
.8a91		ca		dex		                dex
.8a92		ca		dex		                dex
.8a93		a5 00		lda $00		                lda cp
.8a95		95 00		sta $00,x	                sta 0,x
.8a97		a5 01		lda $01		                lda cp+1
.8a99		95 01		sta $01,x	                sta 1,x
.8a9b						z_asm_arrow:
.8a9b		60		rts		z_here:         rts
.8a9c						xt_hex:
.8a9c		a9 10		lda #$10	                lda #16
.8a9e		85 18		sta $18		                sta base
.8aa0		64 19		stz $19		                stz base+1              ; paranoid
.8aa2		60		rts		z_hex:          rts
.8aa3						xt_hold:
.8aa3		20 03 d8	jsr $d803	                jsr underflow_1
.8aa6		a5 2b		lda $2b		                lda tohold
.8aa8		d0 02		bne $8aac	                bne +
.8aaa		c6 2c		dec $2c		                dec tohold+1
.8aac						+
.8aac		c6 2b		dec $2b		                dec tohold
.8aae		b5 00		lda $00,x	                lda 0,x
.8ab0		92 2b		sta ($2b)	                sta (tohold)
.8ab2		e8		inx		                inx
.8ab3		e8		inx		                inx
.8ab4		60		rts		z_hold:         rts
.8ab5						xt_i:
.8ab5		ca		dex		                dex
.8ab6		ca		dex		                dex
.8ab7		a4 1f		ldy $1f		                ldy loopctrl
.8ab9		38		sec		                sec
.8aba		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.8abc		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8abf		95 00		sta $00,x	                sta 0,x
.8ac1		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8ac4		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8ac7		95 01		sta $01,x	                sta 1,x
.8ac9		60		rts		z_i:            rts
.8aca						xt_if:
.8aca		a0 8a		ldy #$8a	                ldy #>zero_branch_runtime
.8acc		a9 e5		lda #$e5	                lda #<zero_branch_runtime
.8ace		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8ad1		20 91 8a	jsr $8a91	                jsr xt_here
.8ad4		a9 ff		lda #$ff	                lda #$FF
.8ad6		a8		tay		                tay
.8ad7		20 45 d6	jsr $d645	                jsr cmpl_word
.8ada		60		rts		z_if:           rts
.8adb						zero_test_runtime:
.8adb		e8		inx		                inx
.8adc		e8		inx		                inx
.8add		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.8adf		15 ff		ora $ff,x	                ora $FF,x
.8ae1		60		rts		                rts
.8ae2		d0 03		bne $8ae7	                bne zero_test_footer_end+2  ; branch fwd if non-zero
>8ae4		4c				                .byte OpJMP                 ; else JMP back
.8ae5						zero_test_footer_end:
.8ae5						zero_branch_runtime:
.8ae5		68		pla		                pla
.8ae6		85 25		sta $25		                sta tmp1
.8ae8		68		pla		                pla
.8ae9		85 26		sta $26		                sta tmp1+1
.8aeb		b5 00		lda $00,x	                lda 0,x
.8aed		15 01		ora $01,x	                ora 1,x
.8aef		f0 0d		beq $8afe	                beq _zero
.8af1		a5 25		lda $25		                lda tmp1        ; LSB
.8af3		18		clc		                clc
.8af4		69 03		adc #$03	                adc #3          ; add one to RTS address plus two address bytes
.8af6		85 25		sta $25		                sta tmp1
.8af8		90 11		bcc $8b0b	                bcc _jump
.8afa		e6 26		inc $26		                inc tmp1+1      ; MSB
.8afc		80 0d		bra $8b0b	                bra _jump
.8afe						_zero:
.8afe		a0 01		ldy #$01	                ldy #1
.8b00		b1 25		lda ($25),y	                lda (tmp1),y
.8b02		48		pha		                pha
.8b03		c8		iny		                iny
.8b04		b1 25		lda ($25),y	                lda (tmp1),y
.8b06		85 26		sta $26		                sta tmp1+1
.8b08		68		pla		                pla
.8b09		85 25		sta $25		                sta tmp1
.8b0b						_jump:
.8b0b		e8		inx		                inx
.8b0c		e8		inx		                inx
.8b0d		6c 25 00	jmp ($0025)	                jmp (tmp1)
.8b10						xt_immediate:
.8b10		20 5a d7	jsr $d75a	                jsr current_to_dp
.8b13		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8b15		b1 02		lda ($02),y	                lda (dp),y
.8b17		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.8b19		91 02		sta ($02),y	                sta (dp),y
.8b1b		60		rts		z_immediate:    rts
.8b1c						xt_invert:
.8b1c		20 03 d8	jsr $d803	                jsr underflow_1
.8b1f		a9 ff		lda #$ff	                lda #$FF
.8b21		55 00		eor $00,x	                eor 0,x         ; LSB
.8b23		95 00		sta $00,x	                sta 0,x
.8b25		a9 ff		lda #$ff	                lda #$FF
.8b27		55 01		eor $01,x	                eor 1,x         ; MSB
.8b29		95 01		sta $01,x	                sta 1,x
.8b2b		60		rts		z_invert:       rts
.8b2c						xt_is:
.8b2c		a5 1a		lda $1a		                lda state
.8b2e		05 1b		ora $1b		                ora state+1
.8b30		f0 0c		beq $8b3e	                beq _interpreting
.8b32						_compiling:
.8b32		20 21 83	jsr $8321	                jsr xt_bracket_tick
.8b35		a0 86		ldy #$86	                ldy #>xt_defer_store
.8b37		a9 84		lda #$84	                lda #<xt_defer_store
.8b39		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8b3c		80 06		bra $8b44	                bra _done
.8b3e						_interpreting:
.8b3e		20 0c 94	jsr $940c	                jsr xt_tick
.8b41		20 84 86	jsr $8684	                jsr xt_defer_store
.8b44						_done:
.8b44		60		rts		z_is:           rts
.8b45						xt_j:
.8b45		ca		dex		                dex                 ; make space on the stack
.8b46		ca		dex		                dex
.8b47		a5 1f		lda $1f		                lda loopctrl
.8b49		38		sec		                sec
.8b4a		e9 04		sbc #$04	                sbc #4
.8b4c		a8		tay		                tay
.8b4d		38		sec		                sec
.8b4e		b9 00 01	lda $0100,y	                lda loopindex,y
.8b51		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8b54		95 00		sta $00,x	                sta 0,x
.8b56		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8b59		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8b5c		95 01		sta $01,x	                sta 1,x
.8b5e		60		rts		z_j:            rts
.8b5f						xt_key:
.8b5f		20 69 8b	jsr $8b69	                jsr key_a               ; returns char in A
.8b62		ca		dex		                dex
.8b63		ca		dex		                dex
.8b64		95 00		sta $00,x	                sta 0,x
.8b66		74 01		stz $01,x	                stz 1,x
.8b68		60		rts		z_key:          rts
.8b69						key_a:
.8b69		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.8b6c						xt_leave:
.8b6c		a5 21		lda $21		                lda loopleave
.8b6e		a4 22		ldy $22		                ldy loopleave+1
.8b70		20 3e d6	jsr $d63e	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.8b73		38		sec		                sec
.8b74		a5 00		lda $00		                lda cp
.8b76		e9 02		sbc #$02	                sbc #2
.8b78		85 21		sta $21		                sta loopleave
.8b7a		a5 01		lda $01		                lda cp+1
.8b7c		b0 01		bcs $8b7f	                bcs +
.8b7e		3a		dec a		                dea
.8b7f		85 22		sta $22		+               sta loopleave+1
.8b81						z_leave:
.8b81		60		rts		                rts
.8b82						xt_left_bracket:
.8b82		64 1a		stz $1a		                stz state
.8b84		64 1b		stz $1b		                stz state+1
.8b86		60		rts		z_left_bracket: rts
.8b87						xt_less_number_sign:
.8b87		20 a6 8e	jsr $8ea6	                jsr xt_pad      ; ( addr )
.8b8a		b5 00		lda $00,x	                lda 0,x
.8b8c		85 2b		sta $2b		                sta tohold
.8b8e		b5 01		lda $01,x	                lda 1,x
.8b90		85 2c		sta $2c		                sta tohold+1
.8b92		e8		inx		                inx
.8b93		e8		inx		                inx
.8b94						z_less_number_sign:
.8b94		60		rts		                rts
.8b95						xt_less_than:
.8b95		20 08 d8	jsr $d808	                jsr underflow_2
.8b98		a0 00		ldy #$00	                ldy #0          ; default false
.8b9a		20 41 d7	jsr $d741	                jsr compare_16bit
.8b9d		f0 03		beq $8ba2	                beq _false
.8b9f		30 01		bmi $8ba2	                bmi _false
.8ba1		88		dey		                dey
.8ba2						_false:
.8ba2		98		tya		                tya
.8ba3		e8		inx		                inx
.8ba4		e8		inx		                inx
.8ba5		95 00		sta $00,x	                sta 0,x
.8ba7		95 01		sta $01,x	                sta 1,x
.8ba9		60		rts		z_less_than:    rts
.8baa						xt_literal:
.8baa		20 03 d8	jsr $d803	                jsr underflow_1
.8bad		a9 0a		lda #$0a	                lda # z_template_push_tos - template_push_tos
.8baf		20 5c d6	jsr $d65c	                jsr check_nc_limit
.8bb2		90 0c		bcc $8bc0	                bcc _inline
.8bb4		a0 8b		ldy #$8b	                ldy #>literal_runtime
.8bb6		a9 f2		lda #$f2	                lda #<literal_runtime
.8bb8		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8bbb		20 da 83	jsr $83da	                jsr xt_comma
.8bbe		80 27		bra $8be7	                bra z_literal
.8bc0						_inline:
.8bc0		a9 94		lda #$94	                lda #$94        ; sty zp,x
.8bc2		b4 01		ldy $01,x	                ldy 1,x
.8bc4		d0 02		bne $8bc8	                bne +
.8bc6		a9 74		lda #$74	                lda #$74        ; stz zp,x
.8bc8						+
.8bc8		48		pha		                pha
.8bc9		b5 00		lda $00,x	                lda 0,x
.8bcb		48		pha		                pha
.8bcc		98		tya		                tya             ; Y has the MSB
.8bcd		f0 03		beq $8bd2	                beq +
.8bcf		48		pha		                pha
.8bd0		a9 02		lda #$02	                lda #2
.8bd2						+
.8bd2		49 02		eor #$02	                eor #2          ; invert A=0/2 to Y=2/0
.8bd4		a8		tay		                tay
.8bd5		b9 e8 8b	lda $8be8,y	_copy:          lda template_push_tos,y
.8bd8		c9 ff		cmp #$ff	                cmp #$ff
.8bda		d0 01		bne $8bdd	                bne +
.8bdc		68		pla		                pla
.8bdd		20 49 d6	jsr $d649	+               jsr cmpl_a
.8be0		c8		iny		                iny
.8be1		c0 0a		cpy #$0a	                cpy #z_template_push_tos - template_push_tos
.8be3		d0 f0		bne $8bd5	                bne _copy
.8be5		e8		inx		                inx             ; drop the literal
.8be6		e8		inx		                inx
.8be7		60		rts		z_literal:      rts
.8be8						template_push_tos:
.8be8		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8bea		a9 ff		lda #$ff	                lda #$ff
.8bec		ca		dex		                dex
.8bed		ca		dex		                dex
.8bee		95 00		sta $00,x	                sta 0,x
>8bf0		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
.8bf2						z_template_push_tos:
.8bf2						literal_runtime:
.8bf2		ca		dex		                dex
.8bf3		ca		dex		                dex
.8bf4		68		pla		                pla             ; LSB
.8bf5		85 25		sta $25		                sta tmp1
.8bf7		68		pla		                pla             ; MSB
.8bf8		85 26		sta $26		                sta tmp1+1
.8bfa		a0 01		ldy #$01	                ldy #1
.8bfc		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8bfe		95 00		sta $00,x	                sta 0,x
.8c00		c8		iny		                iny
.8c01		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8c03		95 01		sta $01,x	                sta 1,x
.8c05		98		tya		                tya
.8c06		18		clc		                clc
.8c07		65 25		adc $25		                adc tmp1
.8c09		a8		tay		                tay
.8c0a		a5 26		lda $26		                lda tmp1+1
.8c0c		69 00		adc #$00	                adc #0
.8c0e		48		pha		                pha
.8c0f		5a		phy		                phy
.8c10		60		rts		                rts
.8c11						xt_loop:
.8c11		ca		dex		                dex
.8c12		ca		dex		                dex
.8c13		a9 74		lda #$74	                lda #<loop_runtime
.8c15		95 00		sta $00,x	                sta 0,x
.8c17		a9 8c		lda #$8c	                lda #>loop_runtime
.8c19		95 01		sta $01,x	                sta 1,x
.8c1b		a0 12		ldy #$12	                ldy #loop_runtime_end-loop_runtime
.8c1d		20 df 84	jsr $84df	                jsr cmpl_inline_y
.8c20		80 0f		bra $8c31	                bra xt_loop_common
.8c22						xt_plus_loop:
.8c22		ca		dex		                dex
.8c23		ca		dex		                dex
.8c24		a9 86		lda #$86	                lda #<plus_loop_runtime
.8c26		95 00		sta $00,x	                sta 0,x
.8c28		a9 8c		lda #$8c	                lda #>plus_loop_runtime
.8c2a		95 01		sta $01,x	                sta 1,x
.8c2c		a0 1b		ldy #$1b	                ldy #plus_loop_runtime_end-plus_loop_runtime
.8c2e		20 df 84	jsr $84df	                jsr cmpl_inline_y
.8c31						xt_loop_common:
.8c31		20 da 83	jsr $83da	                jsr xt_comma
.8c34		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8c36		f0 19		beq $8c51	                beq _noleave
.8c38						_next:
.8c38		a0 01		ldy #$01	                ldy #1
.8c3a		b1 21		lda ($21),y	                lda (loopleave),y
.8c3c		48		pha		                pha
.8c3d		a5 01		lda $01		                lda cp+1
.8c3f		91 21		sta ($21),y	                sta (loopleave),y
.8c41		88		dey		                dey
.8c42		b1 21		lda ($21),y	                lda (loopleave),y
.8c44		48		pha		                pha
.8c45		a5 00		lda $00		                lda cp
.8c47		91 21		sta ($21),y	                sta (loopleave),y
.8c49		68		pla		                pla
.8c4a		85 21		sta $21		                sta loopleave
.8c4c		68		pla		                pla
.8c4d		85 22		sta $22		                sta loopleave+1
.8c4f		d0 e7		bne $8c38	                bne _next
.8c51						_noleave:
.8c51		b5 00		lda $00,x	                lda 0,x
.8c53		85 21		sta $21		                sta loopleave
.8c55		b5 01		lda $01,x	                lda 1,x
.8c57		85 22		sta $22		                sta loopleave+1
.8c59		a9 8c		lda #$8c	                lda #<xt_unloop
.8c5b		95 00		sta $00,x	                sta 0,x
.8c5d		a9 97		lda #$97	                lda #>xt_unloop
.8c5f		95 01		sta $01,x	                sta 1,x
.8c61		20 f4 83	jsr $83f4	                jsr xt_compile_comma
.8c64		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8c66		f0 09		beq $8c71	                beq +
.8c68		20 91 8a	jsr $8a91	                jsr xt_here
.8c6b		20 f8 93	jsr $93f8	                jsr xt_swap
.8c6e		4c e2 93	jmp $93e2	                jmp xt_store            ; write here as ?DO jmp target and return
.8c71		e8		inx		+               inx                     ; drop the ignored word for DO
.8c72		e8		inx		                inx
.8c73						z_loop:
.8c73		60		rts		z_plus_loop:    rts
.8c74						loop_runtime:
.8c74		e6 20		inc $20		                inc loopidx0        ; increment the LSB of loopindex
.8c76		d0 0d		bne $8c85	                bne _repeat         ; avoid expensive test most of the time
.8c78		a4 1f		ldy $1f		                ldy loopctrl
.8c7a		b9 01 01	lda $0101,y	_chkv:          lda loopindex+1,y
.8c7d		1a		inc a		                ina
.8c7e		c9 80		cmp #$80	                cmp #$80
.8c80		f0 06		beq $8c88	                beq _repeat+3       ; done?  skip jmp back
.8c82		99 01 01	sta $0101,y	                sta loopindex+1,y
.8c85						_repeat:
>8c85		4c				                .byte OpJMP
.8c86						loop_runtime_end:
.8c86						plus_loop_runtime:
.8c86		18		clc		                clc
.8c87		b5 00		lda $00,x	                lda 0,x             ; LSB of step
.8c89		65 20		adc $20		                adc loopidx0
.8c8b		85 20		sta $20		                sta loopidx0
.8c8d		e8		inx		                inx                 ; dump step from TOS before MSB test
.8c8e		e8		inx		                inx                 ; since we might skip it
.8c8f		b5 ff		lda $ff,x	                lda $FF,x           ; MSB of step since 1,x == -1,x+2
.8c91		d0 02		bne $8c95	                bne _chkv           ; if it's non-zero we have to check
.8c93		90 0b		bcc $8ca0	                bcc _repeat         ; but if 0 and no carry, we're good
.8c95		b8		clv		_chkv:          clv
.8c96		a4 1f		ldy $1f		                ldy loopctrl        ; get LCB offset
.8c98		79 01 01	adc $0101,y	                adc loopindex+1,y   ; MSB of index
.8c9b		99 01 01	sta $0101,y	                sta loopindex+1,y   ; put MSB of index back on stack
.8c9e		70 03		bvs $8ca3	                bvs _repeat+3     ; skip over JMP instruction
.8ca0						_repeat:
>8ca0		4c				                .byte OpJMP
.8ca1						plus_loop_runtime_end:
.8ca1						xt_lshift:
.8ca1		20 08 d8	jsr $d808	                jsr underflow_2
.8ca4		b5 00		lda $00,x	                lda 0,x
.8ca6		29 0f		and #$0f	                and #%00001111
.8ca8		f0 08		beq $8cb2	                beq _done
.8caa		a8		tay		                tay
.8cab						_loop:
.8cab		16 02		asl $02,x	                asl 2,x
.8cad		36 03		rol $03,x	                rol 3,x
.8caf		88		dey		                dey
.8cb0		d0 f9		bne $8cab	                bne _loop
.8cb2						_done:
.8cb2		e8		inx		                inx
.8cb3		e8		inx		                inx
.8cb4		60		rts		z_lshift:       rts
.8cb5						xt_m_star:
.8cb5		20 08 d8	jsr $d808	                jsr underflow_2
.8cb8		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8cba		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8cbc		48		pha		                pha
.8cbd		20 d1 80	jsr $80d1	                jsr xt_abs
.8cc0		20 f8 93	jsr $93f8	                jsr xt_swap
.8cc3		20 d1 80	jsr $80d1	                jsr xt_abs
.8cc6		20 46 97	jsr $9746	                jsr xt_um_star          ; ( d )
.8cc9		68		pla		                pla
.8cca		10 03		bpl $8ccf	                bpl _done
.8ccc		20 a5 9e	jsr $9ea5	                jsr xt_dnegate
.8ccf						_done:
.8ccf		60		rts		z_m_star:       rts
.8cd0						xt_marker:
.8cd0		20 5a d7	jsr $d75a	                jsr current_to_dp
.8cd3		a5 02		lda $02		                lda dp
.8cd5		48		pha		                pha
.8cd6		a5 03		lda $03		                lda dp+1
.8cd8		48		pha		                pha
.8cd9		a5 00		lda $00		                lda cp
.8cdb		48		pha		                pha
.8cdc		a5 01		lda $01		                lda cp+1
.8cde		48		pha		                pha
.8cdf		20 6f 85	jsr $856f	                jsr xt_create
.8ce2		a5 00		lda $00		                lda cp          ; LSB
.8ce4		38		sec		                sec
.8ce5		e9 02		sbc #$02	                sbc #2
.8ce7		85 00		sta $00		                sta cp
.8ce9		a5 01		lda $01		                lda cp+1        ; MSB
.8ceb		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8ced		85 01		sta $01		                sta cp+1
.8cef		a0 8d		ldy #$8d	                ldy #>marker_runtime
.8cf1		a9 0e		lda #$0e	                lda #<marker_runtime
.8cf3		20 45 d6	jsr $d645	                jsr cmpl_word
.8cf6		7a		ply		                ply                     ; MSB
.8cf7		68		pla		                pla                     ; LSB
.8cf8		20 45 d6	jsr $d645	                jsr cmpl_word
.8cfb		7a		ply		                ply                     ; MSB
.8cfc		68		pla		                pla                     ; LSB
.8cfd		20 45 d6	jsr $d645	                jsr cmpl_word
.8d00		a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.8d02						_marker_loop:
.8d02		b1 08		lda ($08),y	                lda (up),y
.8d04		20 49 d6	jsr $d649	                jsr cmpl_a
.8d07		c8		iny		                iny
.8d08		98		tya		                tya
.8d09		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.8d0b		d0 f5		bne $8d02	                bne _marker_loop
.8d0d		60		rts		z_marker:       rts
.8d0e						marker_runtime:
.8d0e		68		pla		                pla
.8d0f		85 25		sta $25		                sta tmp1        ; LSB of address
.8d11		68		pla		                pla
.8d12		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8d14		e6 25		inc $25		                inc tmp1
.8d16		d0 02		bne $8d1a	                bne +
.8d18		e6 26		inc $26		                inc tmp1+1
.8d1a						+
.8d1a		a0 00		ldy #$00	                ldy #0
.8d1c		b1 25		lda ($25),y	                lda (tmp1),y
.8d1e		85 00		sta $00		                sta cp
.8d20		c8		iny		                iny
.8d21		b1 25		lda ($25),y	                lda (tmp1),y
.8d23		85 01		sta $01		                sta cp+1
.8d25		c8		iny		                iny
.8d26		b1 25		lda ($25),y	                lda (tmp1),y
.8d28		85 02		sta $02		                sta dp
.8d2a		c8		iny		                iny
.8d2b		b1 25		lda ($25),y	                lda (tmp1),y
.8d2d		85 03		sta $03		                sta dp+1
.8d2f		a0 04		ldy #$04	                ldy #4
.8d31						_marker_restore_loop:
.8d31		b1 25		lda ($25),y	                lda (tmp1), y
.8d33		91 08		sta ($08),y	                sta (up), y
.8d35		c8		iny		                iny
.8d36		98		tya		                tya
.8d37		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.8d39		d0 f6		bne $8d31	                bne _marker_restore_loop
.8d3b		20 6d d7	jsr $d76d	                jsr dp_to_current       ; Move the CURRENT DP back.
.8d3e		60		rts		                rts
.8d3f						xt_max:
.8d3f		20 08 d8	jsr $d808	                jsr underflow_2
.8d42		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8d44		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8d46		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8d48		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8d4a		50 02		bvc $8d4e	                bvc _no_overflow
.8d4c		49 80		eor #$80	                eor #$80        ; complement negative flag
.8d4e						_no_overflow:
.8d4e		30 08		bmi $8d58	                bmi _keep_nos
.8d50		b5 00		lda $00,x	                lda 0,x
.8d52		95 02		sta $02,x	                sta 2,x
.8d54		b5 01		lda $01,x	                lda 1,x
.8d56		95 03		sta $03,x	                sta 3,x
.8d58						_keep_nos:
.8d58		e8		inx		                inx
.8d59		e8		inx		                inx
.8d5a		60		rts		z_max:          rts
.8d5b						xt_min:
.8d5b		20 08 d8	jsr $d808	                jsr underflow_2
.8d5e		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8d60		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8d62		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8d64		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8d66		50 02		bvc $8d6a	                bvc _no_overflow
.8d68		49 80		eor #$80	                eor #$80
.8d6a						_no_overflow:
.8d6a		10 08		bpl $8d74	                bpl _keep_nos
.8d6c		b5 00		lda $00,x	                lda 0,x
.8d6e		95 02		sta $02,x	                sta 2,x
.8d70		b5 01		lda $01,x	                lda 1,x
.8d72		95 03		sta $03,x	                sta 3,x
.8d74						_keep_nos:
.8d74		e8		inx		                inx
.8d75		e8		inx		                inx
.8d76		60		rts		z_min:          rts
.8d77						xt_minus:
.8d77		20 08 d8	jsr $d808	                jsr underflow_2
.8d7a		38		sec		                sec
.8d7b		b5 02		lda $02,x	                lda 2,x         ; LSB
.8d7d		f5 00		sbc $00,x	                sbc 0,x
.8d7f		95 02		sta $02,x	                sta 2,x
.8d81		b5 03		lda $03,x	                lda 3,x         ; MSB
.8d83		f5 01		sbc $01,x	                sbc 1,x
.8d85		95 03		sta $03,x	                sta 3,x
.8d87		e8		inx		                inx
.8d88		e8		inx		                inx
.8d89		60		rts		z_minus:        rts
.8d8a						xt_mod:
.8d8a		20 08 d8	jsr $d808	                jsr underflow_2
.8d8d		20 12 93	jsr $9312	                jsr xt_slash_mod
.8d90		e8		inx		                inx             ; DROP
.8d91		e8		inx		                inx
.8d92						z_mod:
.8d92		60		rts		                rts
.8d93						xt_move:
.8d93		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8d95		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8d97		f0 05		beq $8d9e	                beq _lsb                ; wasn't helpful, move to LSB
.8d99		b0 0e		bcs $8da9	                bcs _to_move_up         ; we want CMOVE>
.8d9b		4c 88 9f	jmp $9f88	                jmp xt_cmove            ; JSR/RTS
.8d9e						_lsb:
.8d9e		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8da0		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8da2		f0 08		beq $8dac	                beq _equal              ; LSB is equal as well
.8da4		b0 03		bcs $8da9	                bcs _to_move_up         ; we want CMOVE>
.8da6		4c 88 9f	jmp $9f88	                jmp xt_cmove            ; JSR/RTS
.8da9						_to_move_up:
.8da9		4c c3 9f	jmp $9fc3	                jmp xt_cmove_up         ; JSR/RTS
.8dac						_equal:
.8dac		8a		txa		                txa
.8dad		18		clc		                clc
.8dae		69 06		adc #$06	                adc #6
.8db0		aa		tax		                tax
.8db1		60		rts		z_move:         rts
.8db2						xt_negate:
.8db2		20 03 d8	jsr $d803	                jsr underflow_1
.8db5		a9 00		lda #$00	        	lda #0
.8db7		38		sec		                sec
.8db8		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8dba		95 00		sta $00,x	                sta 0,x
.8dbc		a9 00		lda #$00	                lda #0
.8dbe		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8dc0		95 01		sta $01,x	                sta 1,x
.8dc2		60		rts		z_negate:       rts
.8dc3						xt_nip:
.8dc3		20 08 d8	jsr $d808	                jsr underflow_2
.8dc6		b5 00		lda $00,x	                lda 0,x         ; LSB
.8dc8		95 02		sta $02,x	                sta 2,x
.8dca		b5 01		lda $01,x	                lda 1,x         ; MSB
.8dcc		95 03		sta $03,x	                sta 3,x
.8dce		e8		inx		                inx
.8dcf		e8		inx		                inx
.8dd0		60		rts		z_nip:          rts
.8dd1						xt_not_equals:
.8dd1		20 08 d8	jsr $d808	                jsr underflow_2
.8dd4		a0 00		ldy #$00	                ldy #0                  ; default is true
.8dd6		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8dd8		d5 02		cmp $02,x	                cmp 2,x
.8dda		d0 0a		bne $8de6	                bne _not_equal
.8ddc		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8dde		d5 03		cmp $03,x	                cmp 3,x
.8de0		d0 04		bne $8de6	                bne _not_equal
.8de2		a9 ff		lda #$ff	                lda #$FF
.8de4		80 01		bra $8de7	                bra _done
.8de6						_not_equal:
.8de6		88		dey		                dey                     ; drop thru to done
.8de7						_done:
.8de7		98		tya		                tya
.8de8		e8		inx		                inx
.8de9		e8		inx		                inx
.8dea		95 00		sta $00,x	                sta 0,x
.8dec		95 01		sta $01,x	                sta 1,x
.8dee		60		rts		z_not_equals:   rts
.8def						xt_number_sign:
.8def		20 08 d8	jsr $d808	                jsr underflow_2         ; double number
.8df2		20 04 83	jsr $8304	                jsr xt_base
.8df5		20 90 89	jsr $8990	                jsr xt_fetch            ; ( ud1 base )
.8df8		20 36 95	jsr $9536	                jsr xt_to_r             ; >r
.8dfb		20 37 9e	jsr $9e37	                jsr xt_zero             ; 0
.8dfe		20 6c 90	jsr $906c	                jsr xt_r_fetch          ; r@
.8e01		20 04 97	jsr $9704	                jsr xt_um_slash_mod     ; um/mod
.8e04		20 1e 91	jsr $911e	                jsr xt_rot              ; rot
.8e07		20 1e 91	jsr $911e	                jsr xt_rot              ; rot
.8e0a		20 81 90	jsr $9081	                jsr xt_r_from           ; r>
.8e0d		20 04 97	jsr $9704	                jsr xt_um_slash_mod     ; um/mod
.8e10		20 1e 91	jsr $911e	                jsr xt_rot              ; rot
.8e13		20 1e 91	jsr $911e	                jsr xt_rot              ; ( ud rem )
.8e16		b5 00		lda $00,x	                lda 0,x
.8e18		a8		tay		                tay
.8e19		b9 5d d3	lda $d35d,y	                lda s_abc_upper,y
.8e1c		95 00		sta $00,x	                sta 0,x
.8e1e		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8e20		20 a3 8a	jsr $8aa3	                jsr xt_hold
.8e23						z_number_sign:
.8e23		60		rts		                rts
.8e24						xt_number_sign_greater:
.8e24		20 08 d8	jsr $d808	                jsr underflow_2         ; double number
.8e27		a5 2b		lda $2b		                lda tohold
.8e29		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8e2b		95 02		sta $02,x	                sta 2,x
.8e2d		a5 2c		lda $2c		                lda tohold+1
.8e2f		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8e31		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8e33		20 a6 8e	jsr $8ea6	                jsr xt_pad      ; ( addr addr pad )
.8e36		38		sec		                sec
.8e37		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8e39		f5 02		sbc $02,x	                sbc 2,x
.8e3b		95 02		sta $02,x	                sta 2,x
.8e3d		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8e3f		f5 03		sbc $03,x	                sbc 3,x
.8e41		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8e43		e8		inx		                inx
.8e44		e8		inx		                inx
.8e45						z_number_sign_greater:
.8e45		60		rts		                rts
.8e46						xt_number_sign_s:
.8e46		20 08 d8	jsr $d808	                jsr underflow_2
.8e49						_loop:
.8e49		20 ef 8d	jsr $8def	                jsr xt_number_sign
.8e4c		b5 00		lda $00,x	                lda 0,x
.8e4e		15 01		ora $01,x	                ora 1,x
.8e50		15 02		ora $02,x	                ora 2,x
.8e52		15 03		ora $03,x	                ora 3,x
.8e54		d0 f3		bne $8e49	                bne _loop
.8e56						z_number_sign_s:
.8e56		60		rts		                rts
.8e57						xt_of:
.8e57		a0 8e		ldy #$8e	                ldy #>xt_over
.8e59		a9 98		lda #$98	                lda #<xt_over
.8e5b		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8e5e		a0 89		ldy #$89	                ldy #>xt_equal
.8e60		a9 0c		lda #$0c	                lda #<xt_equal
.8e62		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8e65		20 ca 8a	jsr $8aca	                jsr xt_if
.8e68		a0 87		ldy #$87	                ldy #>xt_drop
.8e6a		a9 c5		lda #$c5	                lda #<xt_drop
.8e6c		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.8e6f		60		rts		z_of:           rts
.8e70						xt_one_minus:
.8e70		20 03 d8	jsr $d803	                jsr underflow_1
.8e73		b5 00		lda $00,x	                lda 0,x
.8e75		d0 02		bne $8e79	                bne +
.8e77		d6 01		dec $01,x	                dec 1,x
.8e79						+
.8e79		d6 00		dec $00,x	                dec 0,x
.8e7b		60		rts		z_one_minus:    rts
.8e7c						xt_char_plus:
.8e7c						xt_one_plus:
.8e7c		20 03 d8	jsr $d803	                jsr underflow_1
.8e7f		f6 00		inc $00,x	                inc 0,x
.8e81		d0 02		bne $8e85	                bne _done
.8e83		f6 01		inc $01,x	                inc 1,x
.8e85						_done:
.8e85						z_char_plus:
.8e85		60		rts		z_one_plus:     rts
.8e86						xt_or:
.8e86		20 08 d8	jsr $d808	                jsr underflow_2
.8e89		b5 00		lda $00,x	                lda 0,x
.8e8b		15 02		ora $02,x	                ora 2,x
.8e8d		95 02		sta $02,x	                sta 2,x
.8e8f		b5 01		lda $01,x	                lda 1,x
.8e91		15 03		ora $03,x	                ora 3,x
.8e93		95 03		sta $03,x	                sta 3,x
.8e95		e8		inx		                inx
.8e96		e8		inx		                inx
.8e97		60		rts		z_or:           rts
.8e98						xt_over:
.8e98		20 08 d8	jsr $d808	                jsr underflow_2
.8e9b		ca		dex		                dex
.8e9c		ca		dex		                dex
.8e9d		b5 04		lda $04,x	                lda 4,x         ; LSB
.8e9f		95 00		sta $00,x	                sta 0,x
.8ea1		b5 05		lda $05,x	                lda 5,x         ; MSB
.8ea3		95 01		sta $01,x	                sta 1,x
.8ea5		60		rts		z_over:         rts
.8ea6						xt_pad:
.8ea6		ca		dex		                dex
.8ea7		ca		dex		                dex
.8ea8		a5 00		lda $00		                lda cp
.8eaa		18		clc		                clc
.8eab		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8ead		95 00		sta $00,x	                sta 0,x
.8eaf		a5 01		lda $01		                lda cp+1
.8eb1		69 00		adc #$00	                adc #0          ; only need carry
.8eb3		95 01		sta $01,x	                sta 1,x
.8eb5		60		rts		z_pad:          rts
.8eb6						xt_page:
.8eb6		a9 1b		lda #$1b	                lda #AscESC
.8eb8		20 3b 88	jsr $883b	                jsr emit_a
.8ebb		a9 5b		lda #$5b	                lda #'['
.8ebd		20 3b 88	jsr $883b	                jsr emit_a
.8ec0		a9 32		lda #$32	                lda #'2'
.8ec2		20 3b 88	jsr $883b	                jsr emit_a
.8ec5		a9 4a		lda #$4a	                lda #'J'
.8ec7		20 3b 88	jsr $883b	                jsr emit_a
.8eca		20 37 9e	jsr $9e37	                jsr xt_zero
.8ecd		20 37 9e	jsr $9e37	                jsr xt_zero
.8ed0		20 ab 82	jsr $82ab	                jsr xt_at_xy
.8ed3		60		rts		z_page:         rts
.8ed4						xt_paren:
.8ed4		ca		dex		                dex
.8ed5		ca		dex		                dex
.8ed6		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8ed8		95 00		sta $00,x	                sta 0,x
.8eda		74 01		stz $01,x	                stz 1,x
.8edc		20 3f 8f	jsr $8f3f	                jsr xt_parse
.8edf		e8		inx		                inx
.8ee0		e8		inx		                inx
.8ee1		e8		inx		                inx
.8ee2		e8		inx		                inx
.8ee3		60		rts		z_paren:        rts
.8ee4						xt_parse_name:
.8ee4		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8ee6		38		sec		                sec
.8ee7		e5 10		sbc $10		                sbc toin
.8ee9		85 25		sta $25		                sta tmp1
.8eeb		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8eed		e5 11		sbc $11		                sbc toin+1
.8eef		85 26		sta $26		                sta tmp1+1
.8ef1		a5 25		lda $25		                lda tmp1
.8ef3		05 26		ora $26		                ora tmp1+1
.8ef5		f0 28		beq $8f1f	                beq _empty_line
.8ef7		a5 0c		lda $0c		                lda cib
.8ef9		18		clc		                clc
.8efa		65 10		adc $10		                adc toin
.8efc		85 27		sta $27		                sta tmp2                ; LSB of first character
.8efe		a5 0d		lda $0d		                lda cib+1
.8f00		65 11		adc $11		                adc toin+1
.8f02		85 28		sta $28		                sta tmp2+1              ; MSB
.8f04						_skip_loop:
.8f04		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8f06		20 f6 d7	jsr $d7f6	                jsr is_whitespace
.8f09		90 1f		bcc $8f2a	                bcc _char_found
.8f0b		e6 27		inc $27		                inc tmp2
.8f0d		d0 02		bne $8f11	                bne +
.8f0f		e6 28		inc $28		                inc tmp2+1
.8f11						+
.8f11		a5 25		lda $25		                lda tmp1
.8f13		d0 02		bne $8f17	                bne +
.8f15		c6 26		dec $26		                dec tmp1+1
.8f17		c6 25		dec $25		+               dec tmp1
.8f19		a5 25		lda $25		                lda tmp1
.8f1b		05 26		ora $26		                ora tmp1+1
.8f1d		d0 e5		bne $8f04	                bne _skip_loop          ; fall through if empty line
.8f1f						_empty_line:
.8f1f		ca		dex		                dex
.8f20		ca		dex		                dex
.8f21		ca		dex		                dex
.8f22		ca		dex		                dex
.8f23		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8f25		74 01		stz $01,x	                stz 1,x
.8f27		4c d4 8f	jmp $8fd4	                jmp z_parse_name        ; skip over PARSE
.8f2a						_char_found:
.8f2a		a5 27		lda $27		                lda tmp2
.8f2c		38		sec		                sec
.8f2d		e5 0c		sbc $0c		                sbc cib
.8f2f		85 10		sta $10		                sta toin
.8f31		a5 28		lda $28		                lda tmp2+1
.8f33		e5 0d		sbc $0d		                sbc cib+1
.8f35		85 11		sta $11		                sta toin+1
.8f37		ca		dex		                dex
.8f38		ca		dex		                dex
.8f39		a9 20		lda #$20	                lda #AscSP
.8f3b		95 00		sta $00,x	                sta 0,x
.8f3d		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8f3f						xt_parse:
.8f3f		20 03 d8	jsr $d803	                jsr underflow_1
.8f42		a5 0e		lda $0e		                lda ciblen
.8f44		05 0f		ora $0f		                ora ciblen+1
.8f46		f0 0c		beq $8f54	                beq _abort_parse
.8f48		a5 11		lda $11		                lda toin+1              ; MSB
.8f4a		c5 0f		cmp $0f		                cmp ciblen+1
.8f4c		90 0e		bcc $8f5c	                bcc _go_parse           ; unsigned comparison
.8f4e		a5 10		lda $10		                lda toin                ; LSB
.8f50		c5 0e		cmp $0e		                cmp ciblen
.8f52		90 08		bcc $8f5c	                bcc _go_parse
.8f54						_abort_parse:
.8f54		ca		dex		                dex
.8f55		ca		dex		                dex
.8f56		74 00		stz $00,x	                stz 0,x
.8f58		74 01		stz $01,x	                stz 1,x
.8f5a		80 78		bra $8fd4	                bra _done
.8f5c						_go_parse:
.8f5c		b5 00		lda $00,x	                lda 0,x
.8f5e		85 23		sta $23		                sta tmptos
.8f60		ca		dex		                dex
.8f61		ca		dex		                dex
.8f62		a5 0c		lda $0c		                lda cib
.8f64		18		clc		                clc
.8f65		65 10		adc $10		                adc toin        ; LSB
.8f67		85 25		sta $25		                sta tmp1
.8f69		85 27		sta $27		                sta tmp2
.8f6b		95 02		sta $02,x	                sta 2,x
.8f6d		a5 0d		lda $0d		                lda cib+1
.8f6f		65 11		adc $11		                adc toin+1      ; MSB
.8f71		85 26		sta $26		                sta tmp1+1
.8f73		85 28		sta $28		                sta tmp2+1
.8f75		95 03		sta $03,x	                sta 3,x
.8f77		a5 0c		lda $0c		                lda cib
.8f79		18		clc		                clc
.8f7a		65 0e		adc $0e		                adc ciblen
.8f7c		85 29		sta $29		                sta tmp3
.8f7e		a5 0d		lda $0d		                lda cib+1
.8f80		65 0f		adc $0f		                adc ciblen+1
.8f82		85 2a		sta $2a		                sta tmp3+1
.8f84		64 24		stz $24		                stz tmptos+1
.8f86						_loop:
.8f86		a5 27		lda $27		                lda tmp2
.8f88		c5 29		cmp $29		                cmp tmp3
.8f8a		d0 06		bne $8f92	                bne _not_empty
.8f8c		a5 28		lda $28		                lda tmp2+1
.8f8e		c5 2a		cmp $2a		                cmp tmp3+1
.8f90		f0 1d		beq $8faf	                beq _eol
.8f92						_not_empty:
.8f92		b2 27		lda ($27)	                lda (tmp2)
.8f94		a4 23		ldy $23		                ldy tmptos
.8f96		c0 20		cpy #$20	                cpy #AscSP
.8f98		d0 07		bne $8fa1	                bne _not_whitespace
.8f9a		20 f6 d7	jsr $d7f6	                jsr is_whitespace
.8f9d		90 02		bcc $8fa1	                bcc _not_whitespace
.8f9f		80 0c		bra $8fad	                bra _found_delimiter
.8fa1						_not_whitespace:
.8fa1		c5 23		cmp $23		                cmp tmptos
.8fa3		f0 08		beq $8fad	                beq _found_delimiter
.8fa5		e6 27		inc $27		                inc tmp2
.8fa7		d0 dd		bne $8f86	                bne _loop
.8fa9		e6 28		inc $28		                inc tmp2+1
.8fab		80 d9		bra $8f86	                bra _loop
.8fad						_found_delimiter:
.8fad		e6 24		inc $24		                inc tmptos+1
.8faf						_eol:
.8faf		a5 27		lda $27		                lda tmp2
.8fb1		38		sec		                sec
.8fb2		e5 25		sbc $25		                sbc tmp1
.8fb4		95 00		sta $00,x	                sta 0,x
.8fb6		a5 28		lda $28		                lda tmp2+1
.8fb8		e5 26		sbc $26		                sbc tmp1+1
.8fba		95 01		sta $01,x	                sta 1,x
.8fbc		a5 27		lda $27		                lda tmp2
.8fbe		38		sec		                sec
.8fbf		e5 0c		sbc $0c		                sbc cib
.8fc1		85 10		sta $10		                sta toin
.8fc3		a5 28		lda $28		                lda tmp2+1
.8fc5		e5 0d		sbc $0d		                sbc cib+1
.8fc7		85 11		sta $11		                sta toin+1
.8fc9		a5 10		lda $10		                lda toin
.8fcb		18		clc		                clc
.8fcc		65 24		adc $24		                adc tmptos+1
.8fce		85 10		sta $10		                sta toin
.8fd0		90 02		bcc $8fd4	                bcc +
.8fd2		e6 11		inc $11		                inc toin+1
.8fd4						+
.8fd4						_done:
.8fd4						z_parse_name:
.8fd4		60		rts		z_parse:        rts
.8fd5						xt_pick:
.8fd5		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8fd7		8a		txa		                txa
.8fd8		75 00		adc $00,x	                adc 0,x
.8fda		a8		tay		                tay
.8fdb		b9 02 00	lda $0002,y	                lda 0002,y
.8fde		95 00		sta $00,x	                sta 0,x
.8fe0		b9 03 00	lda $0003,y	                lda 0003,y
.8fe3		95 01		sta $01,x	                sta 1,x
.8fe5		60		rts		z_pick:         rts
.8fe6						xt_plus:
.8fe6		20 08 d8	jsr $d808	                jsr underflow_2
.8fe9		18		clc		                clc
.8fea		b5 00		lda $00,x	                lda 0,x         ; LSB
.8fec		75 02		adc $02,x	                adc 2,x
.8fee		95 02		sta $02,x	                sta 2,x
.8ff0		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8ff2		75 03		adc $03,x	                adc 3,x
.8ff4		95 03		sta $03,x	                sta 3,x
.8ff6		e8		inx		                inx
.8ff7		e8		inx		                inx
.8ff8		60		rts		z_plus:         rts
.8ff9						xt_plus_store:
.8ff9		20 08 d8	jsr $d808	                jsr underflow_2
.8ffc		b5 00		lda $00,x	                lda 0,x
.8ffe		85 25		sta $25		                sta tmp1
.9000		b5 01		lda $01,x	                lda 1,x
.9002		85 26		sta $26		                sta tmp1+1
.9004		a0 00		ldy #$00	                ldy #0          ; LSB
.9006		b1 25		lda ($25),y	                lda (tmp1),y
.9008		18		clc		                clc
.9009		75 02		adc $02,x	                adc 2,x
.900b		91 25		sta ($25),y	                sta (tmp1),y
.900d		c8		iny		                iny             ; MSB
.900e		b1 25		lda ($25),y	                lda (tmp1),y
.9010		75 03		adc $03,x	                adc 3,x
.9012		91 25		sta ($25),y	                sta (tmp1),y
.9014		e8		inx		                inx
.9015		e8		inx		                inx
.9016		e8		inx		                inx
.9017		e8		inx		                inx
.9018		60		rts		z_plus_store:   rts
.9019						xt_postpone:
.9019		20 e4 8e	jsr $8ee4	                jsr xt_parse_name               ; ( -- addr n )
.901c		b5 00		lda $00,x	                lda 0,x
.901e		15 01		ora $01,x	                ora 1,x
.9020		d0 05		bne $9027	                bne +
.9022		a9 05		lda #$05	                lda #err_noname
.9024		4c 19 d8	jmp $d819	                jmp error
.9027						+
.9027		20 36 9b	jsr $9b36	                jsr xt_find_name                ; ( -- nt | 0 )
.902a		d0 05		bne $9031	                bne +
.902c		a9 05		lda #$05	                lda #err_noname
.902e		4c 19 d8	jmp $d819	                jmp error
.9031						+
.9031		b5 00		lda $00,x	                lda 0,x
.9033		85 25		sta $25		                sta tmp1
.9035		b5 01		lda $01,x	                lda 1,x
.9037		85 26		sta $26		                sta tmp1+1
.9039		20 74 9c	jsr $9c74	                jsr xt_name_to_int              ; ( nt -- xt )
.903c		e6 25		inc $25		                inc tmp1
.903e		d0 02		bne $9042	                bne +
.9040		e6 26		inc $26		                inc tmp1+1
.9042						+
.9042		b2 25		lda ($25)	                lda (tmp1)
.9044		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9046		f0 05		beq $904d	                beq _not_immediate
.9048		20 f4 83	jsr $83f4	                jsr xt_compile_comma
.904b		80 0a		bra $9057	                bra _done
.904d						_not_immediate:
.904d		20 aa 8b	jsr $8baa	                jsr xt_literal
.9050		a0 83		ldy #$83	                ldy #>xt_compile_comma
.9052		a9 f4		lda #$f4	                lda #<xt_compile_comma
.9054		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.9057						_done:
.9057		60		rts		z_postpone:     rts
.9058						xt_question_dup:
.9058		20 03 d8	jsr $d803	                jsr underflow_1
.905b		b5 00		lda $00,x	                lda 0,x
.905d		15 01		ora $01,x	                ora 1,x
.905f		f0 0a		beq $906b	                beq _done
.9061		ca		dex		                dex
.9062		ca		dex		                dex
.9063		b5 02		lda $02,x	                lda 2,x
.9065		95 00		sta $00,x	                sta 0,x
.9067		b5 03		lda $03,x	                lda 3,x
.9069		95 01		sta $01,x	                sta 1,x
.906b						_done:
.906b		60		rts		z_question_dup: rts
.906c						xt_r_fetch:
.906c		7a		ply		                ply             ; LSB
.906d		84 25		sty $25		                sty tmp1
.906f		7a		ply		                ply             ; MSB
.9070		ca		dex		                dex
.9071		ca		dex		                dex
.9072		68		pla		                pla             ; LSB
.9073		95 00		sta $00,x	                sta 0,x
.9075		68		pla		                pla             ; MSB
.9076		95 01		sta $01,x	                sta 1,x
.9078		48		pha		                pha
.9079		b5 00		lda $00,x	                lda 0,x
.907b		48		pha		                pha
.907c		5a		phy		                phy             ; MSB
.907d		a4 25		ldy $25		                ldy tmp1
.907f		5a		phy		                phy             ; LSB
.9080		60		rts		z_r_fetch:      rts
.9081						xt_r_from:
.9081		68		pla		                pla             ; LSB
.9082		85 23		sta $23		                sta tmptos
.9084		7a		ply		                ply             ; MSB
.9085		ca		dex		                dex
.9086		ca		dex		                dex
.9087		68		pla		                pla             ; LSB
.9088		95 00		sta $00,x	                sta 0,x
.908a		68		pla		                pla             ; MSB
.908b		95 01		sta $01,x	                sta 1,x
.908d		5a		phy		                phy             ; MSB
.908e		a5 23		lda $23		                lda tmptos
.9090		48		pha		                pha             ; LSB
.9091		60		rts		z_r_from:       rts
.9092						xt_recurse:
.9092		a0 00		ldy #$00	                ldy #0
.9094		a9 20		lda #$20	                lda #OpJSR
.9096		91 00		sta ($00),y	                sta (cp),y
.9098		c8		iny		                iny
.9099		24 1c		bit $1c		                bit status
.909b		70 0c		bvs $90a9	                bvs _nt_in_workword
.909d		a5 06		lda $06		                lda workword
.909f		91 00		sta ($00),y	                sta (cp),y
.90a1		c8		iny		                iny
.90a2		a5 07		lda $07		                lda workword+1
.90a4		91 00		sta ($00),y	                sta (cp),y
.90a6		c8		iny		                iny
.90a7		80 1b		bra $90c4	                bra _update_cp
.90a9						_nt_in_workword:
.90a9		a5 06		lda $06		                lda workword            ; LSB
.90ab		18		clc		                clc
.90ac		69 04		adc #$04	                adc #4
.90ae		85 25		sta $25		                sta tmp1
.90b0		a5 07		lda $07		                lda workword+1          ; MSB
.90b2		69 00		adc #$00	                adc #0
.90b4		85 26		sta $26		                sta tmp1+1
.90b6		b2 25		lda ($25)	                lda (tmp1)
.90b8		91 00		sta ($00),y	                sta (cp),y
.90ba		5a		phy		                phy
.90bb		a0 01		ldy #$01	                ldy #1
.90bd		b1 25		lda ($25),y	                lda (tmp1),y
.90bf		7a		ply		                ply
.90c0		c8		iny		                iny
.90c1		91 00		sta ($00),y	                sta (cp),y
.90c3		c8		iny		                iny
.90c4						_update_cp:
.90c4		98		tya		                tya
.90c5		18		clc		                clc
.90c6		65 00		adc $00		                adc cp
.90c8		85 00		sta $00		                sta cp
.90ca		90 02		bcc $90ce	                bcc _done
.90cc		e6 01		inc $01		                inc cp+1
.90ce						_done:
.90ce		60		rts		z_recurse:      rts
.90cf						xt_refill:
.90cf		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.90d1		d0 2d		bne $9100	                bne _src_not_kbd
.90d3		ca		dex		                dex
.90d4		ca		dex		                dex
.90d5		ca		dex		                dex
.90d6		ca		dex		                dex
.90d7		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.90d9		95 02		sta $02,x	                sta 2,x
.90db		a5 0d		lda $0d		                lda cib+1
.90dd		95 03		sta $03,x	                sta 3,x
.90df		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.90e1		64 0f		stz $0f		                stz ciblen+1
.90e3		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.90e5		95 00		sta $00,x	                sta 0,x
.90e7		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.90e9		20 e6 80	jsr $80e6	                jsr xt_accept           ; ( addr n1 -- n2)
.90ec		b5 00		lda $00,x	                lda 0,x
.90ee		85 0e		sta $0e		                sta ciblen
.90f0		b5 01		lda $01,x	                lda 1,x
.90f2		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.90f4		64 10		stz $10		                stz toin
.90f6		64 11		stz $11		                stz toin+1
.90f8		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.90fa		95 00		sta $00,x	                sta 0,x
.90fc		95 01		sta $01,x	                sta 1,x
.90fe		80 10		bra $9110	                bra _done
.9100						_src_not_kbd:
.9100		1a		inc a		                ina
.9101		d0 08		bne $910b	                bne _src_not_string
.9103		ca		dex		                dex
.9104		ca		dex		                dex
.9105		74 00		stz $00,x	                stz 0,x
.9107		74 01		stz $01,x	                stz 1,x
.9109		80 05		bra $9110	                bra z_refill
.910b						_src_not_string:
.910b		a9 01		lda #$01	                lda #err_badsource
.910d		4c 19 d8	jmp $d819	                jmp error
.9110						_done:
.9110		60		rts		z_refill:       rts
.9111						xt_repeat:
.9111		20 21 82	jsr $8221	                jsr xt_again
.9114		4c e5 87	jmp $87e5	                jmp xt_then
.9117						z_repeat:
.9117						xt_right_bracket:
.9117		a9 ff		lda #$ff	                lda #$FF
.9119		85 1a		sta $1a		                sta state
.911b		85 1b		sta $1b		                sta state+1
.911d						z_right_bracket:
.911d		60		rts		                rts
.911e						xt_rot:
.911e		20 0d d8	jsr $d80d	                jsr underflow_3
.9121		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9123		b5 03		lda $03,x	                lda 3,x
.9125		95 05		sta $05,x	                sta 5,x
.9127		b5 01		lda $01,x	                lda 1,x
.9129		95 03		sta $03,x	                sta 3,x
.912b		94 01		sty $01,x	                sty 1,x
.912d		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.912f		b5 02		lda $02,x	                lda 2,x
.9131		95 04		sta $04,x	                sta 4,x
.9133		b5 00		lda $00,x	                lda 0,x
.9135		95 02		sta $02,x	                sta 2,x
.9137		94 00		sty $00,x	                sty 0,x
.9139		60		rts		z_rot:          rts
.913a						xt_rshift:
.913a		20 08 d8	jsr $d808	                jsr underflow_2
.913d		b5 00		lda $00,x	                lda 0,x
.913f		29 0f		and #$0f	                and #%00001111
.9141		f0 08		beq $914b	                beq _done               ; if 0 shifts, quit
.9143		a8		tay		                tay
.9144						_loop:
.9144		56 03		lsr $03,x	                lsr 3,x
.9146		76 02		ror $02,x	                ror 2,x
.9148		88		dey		                dey
.9149		d0 f9		bne $9144	                bne _loop
.914b						_done:
.914b		e8		inx		                inx
.914c		e8		inx		                inx
.914d		60		rts		z_rshift:       rts
.914e						xt_s_backslash_quote:
.914e		a9 ff		lda #$ff	                lda #$FF
.9150		85 27		sta $27		                sta tmp2
.9152		64 28		stz $28		                stz tmp2+1
.9154		20 6b 91	jsr $916b	                jsr s_quote_start
.9157						_done:
.9157						z_s_backslash_quote:
.9157		60		rts		                rts
.9158						convert_hex_value:
.9158		c9 41		cmp #$41	        cmp #'A'
.915a		90 07		bcc $9163	        bcc _digit
.915c		29 df		and #$df	        and #$DF                ; Make it uppercase.
.915e		38		sec		        sec
.915f		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.9161		80 03		bra $9166	        bra _done
.9163						_digit:
.9163		38		sec		        sec
.9164		e9 30		sbc #$30	        sbc #'0'
.9166						_done:
.9166		60		rts		        rts
.9167						xt_s_quote:
.9167		64 27		stz $27		                stz tmp2
.9169		64 28		stz $28		                stz tmp2+1
.916b						s_quote_start:
.916b		ca		dex		                dex
.916c		ca		dex		                dex
.916d		ca		dex		                dex
.916e		ca		dex		                dex
.916f		20 3e d6	jsr $d63e	                jsr cmpl_jump
.9172		a5 00		lda $00		                lda cp
.9174		95 02		sta $02,x	                sta 2,x
.9176		a5 01		lda $01		                lda cp+1
.9178		95 03		sta $03,x	                sta 3,x
.917a						_savechars_loop:
.917a		a5 11		lda $11		                lda toin+1              ; MSB
.917c		c5 0f		cmp $0f		                cmp ciblen+1
.917e		90 2a		bcc $91aa	                bcc _input_fine         ; unsigned comparison
.9180		a5 10		lda $10		                lda toin                ; LSB
.9182		c5 0e		cmp $0e		                cmp ciblen
.9184		90 24		bcc $91aa	                bcc _input_fine
.9186		a5 27		lda $27		                lda tmp2
.9188		48		pha		                pha
.9189		a5 28		lda $28		                lda tmp2+1
.918b		48		pha		                pha
.918c		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.918e		48		pha		                pha
.918f		20 cf 90	jsr $90cf	                jsr xt_refill           ; ( -- f )
.9192		68		pla		                pla
.9193		85 29		sta $29		                sta tmp3
.9195		68		pla		                pla
.9196		85 28		sta $28		                sta tmp2+1
.9198		68		pla		                pla
.9199		85 27		sta $27		                sta tmp2
.919b		b5 00		lda $00,x	                lda 0,x
.919d		15 01		ora $01,x	                ora 1,x
.919f		d0 05		bne $91a6	                bne _refill_ok
.91a1		a9 06		lda #$06	                lda #err_refill
.91a3		4c 19 d8	jmp $d819	                jmp error
.91a6						_refill_ok:
.91a6		e8		inx		                inx
.91a7		e8		inx		                inx
.91a8		80 d0		bra $917a	                bra _savechars_loop
.91aa						_input_fine:
.91aa		a5 0c		lda $0c		                lda cib
.91ac		18		clc		                clc
.91ad		65 10		adc $10		                adc toin        ; LSB
.91af		85 25		sta $25		                sta tmp1
.91b1		a5 0d		lda $0d		                lda cib+1
.91b3		65 11		adc $11		                adc toin+1      ; MSB
.91b5		85 26		sta $26		                sta tmp1+1
.91b7		b2 25		lda ($25)	                lda (tmp1)
.91b9		24 27		bit $27		                bit tmp2
.91bb		30 03		bmi $91c0	                bmi _handle_escapes    ; Only checking bit 7
.91bd		4c 43 92	jmp $9243	                jmp _regular_char
.91c0						_handle_escapes:
.91c0		24 28		bit $28		                bit tmp2+1
.91c2		30 03		bmi $91c7	                bmi _escaped
.91c4		4c 39 92	jmp $9239	                jmp _not_escaped
.91c7						_escaped:
.91c7		70 3c		bvs $9205	                bvs _check_esc_chars
.91c9		a9 01		lda #$01	                lda #1
.91cb		24 28		bit $28		                bit tmp2+1
.91cd		d0 10		bne $91df	                bne _esc_x_second_digit
.91cf		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.91d1		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.91d3		20 58 91	jsr $9158	                jsr convert_hex_value
.91d6		0a		asl a		                asl
.91d7		0a		asl a		                asl
.91d8		0a		asl a		                asl
.91d9		0a		asl a		                asl
.91da		85 29		sta $29		                sta tmp3    ; Save it for later.
.91dc		4c 4a 92	jmp $924a	                jmp _next_character
.91df						_esc_x_second_digit:
.91df		64 28		stz $28		                stz tmp2+1
.91e1		b2 25		lda ($25)	                lda (tmp1)
.91e3		20 58 91	jsr $9158	                jsr convert_hex_value
.91e6		05 29		ora $29		                ora tmp3
.91e8		4c 47 92	jmp $9247	                jmp _save_character
.91eb						_esc_tr_table:
>91eb		07				    .byte   7               ; a -> BEL (ASCII value 7)
>91ec		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>91ed		00 00				    .byte   0,0             ; c, d no escape
>91ef		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>91f0		0c				    .byte   12              ; f -> FF (ASCII value 12)
>91f1		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>91f6		0a				    .byte   10              ; l -> LF (ASCII value 10)
>91f7		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>91f8		0a				    .byte   10              ; n behaves like l --> lf
>91f9		00 00				    .byte   0,0             ; o,p
>91fb		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>91fc		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>91fd		00				    .byte   0               ; s
>91fe		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>91ff		00				    .byte   0               ; u
>9200		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9201		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9204		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9205						_check_esc_chars:
.9205		64 28		stz $28		                stz tmp2+1
.9207		c9 61		cmp #$61	                cmp #'a'
.9209		30 1a		bmi $9225	                bmi _check_esc_quote
.920b		c9 7b		cmp #$7b	                cmp #'z'+1
.920d		10 16		bpl $9225	                bpl _check_esc_quote
.920f		a8		tay		                tay
.9210		b9 8a 91	lda $918a,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9213		d0 03		bne $9218	                bne _esc_replace
.9215		98		tya		                tya                     ; revert if no translation
.9216		80 0d		bra $9225	                bra _check_esc_quote
.9218		10 2d		bpl $9247	_esc_replace:   bpl _save_character     ; simple replacement
.921a		29 7f		and #$7f	                and #$7F                ; clear hi bit
.921c		f0 29		beq $9247	                beq _save_character     ; NUL we can just output
.921e		20 49 d6	jsr $d649	                jsr cmpl_a              ; else output first char (CR)
.9221		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9223		80 22		bra $9247	                bra _save_character
.9225						_check_esc_quote:
.9225		c9 22		cmp #$22	                cmp #'"'
.9227		f0 1e		beq $9247	                beq _save_character
.9229						_check_esc_x:
.9229		c9 78		cmp #$78	                cmp #'x'
.922b		d0 06		bne $9233	                bne _check_esc_backslash
.922d		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.922f		85 28		sta $28		                sta tmp2+1
.9231		80 17		bra $924a	                bra _next_character
.9233						_check_esc_backslash:
.9233		c9 5c		cmp #$5c	                cmp #'\'
.9235		d0 0c		bne $9243	                bne _regular_char
.9237		80 0e		bra $9247	                bra _save_character
.9239						_not_escaped:
.9239		c9 5c		cmp #$5c	                cmp #'\'
.923b		d0 06		bne $9243	                bne _regular_char
.923d		a9 ff		lda #$ff	                lda #$FF
.923f		85 28		sta $28		                sta tmp2+1
.9241		80 07		bra $924a	                bra _next_character
.9243						_regular_char:
.9243		c9 22		cmp #$22	                cmp #'"'
.9245		f0 0c		beq $9253	                beq _found_string_end
.9247						_save_character:
.9247		20 49 d6	jsr $d649	                jsr cmpl_a
.924a						_next_character:
.924a		e6 10		inc $10		                inc toin
.924c		d0 02		bne $9250	                bne _savechars_loop_longjump
.924e		e6 11		inc $11		                inc toin+1
.9250						_savechars_loop_longjump:
.9250		4c 7a 91	jmp $917a	                jmp _savechars_loop
.9253						_found_string_end:
.9253		e6 10		inc $10		                inc toin
.9255		d0 02		bne $9259	                bne +
.9257		e6 11		inc $11		                inc toin+1
.9259						+
.9259		a5 00		lda $00		                lda cp
.925b		38		sec		                sec
.925c		f5 02		sbc $02,x	                sbc 2,x
.925e		95 00		sta $00,x	                sta 0,x         ; LSB
.9260		a5 01		lda $01		                lda cp+1
.9262		f5 03		sbc $03,x	                sbc 3,x
.9264		95 01		sta $01,x	                sta 1,x         ; MSB
.9266		b5 02		lda $02,x	                lda 2,x
.9268		38		sec		                sec
.9269		e9 02		sbc #$02	                sbc #2
.926b		85 25		sta $25		                sta tmp1
.926d		b5 03		lda $03,x	                lda 3,x
.926f		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9271		85 26		sta $26		                sta tmp1+1
.9273		a5 00		lda $00		                lda cp
.9275		92 25		sta ($25)	                sta (tmp1)
.9277		a0 01		ldy #$01	                ldy #1
.9279		a5 01		lda $01		                lda cp+1
.927b		91 25		sta ($25),y	                sta (tmp1),y
.927d		a5 1a		lda $1a		                lda state
.927f		05 1b		ora $1b		                ora state+1             ; paranoid
.9281		f0 03		beq $9286	                beq _done
.9283		20 a2 a1	jsr $a1a2	                jsr cmpl_sliteral         ; ( addr u -- )
.9286						_done:
.9286		60		rts		z_s_quote:      rts
.9287						xt_s_to_d:
.9287		20 03 d8	jsr $d803	                jsr underflow_1
.928a		ca		dex		                dex
.928b		ca		dex		                dex
.928c		74 00		stz $00,x	                stz 0,x
.928e		74 01		stz $01,x	                stz 1,x
.9290		b5 03		lda $03,x	                lda 3,x
.9292		10 04		bpl $9298	                bpl _done
.9294		d6 00		dec $00,x	                dec 0,x
.9296		d6 01		dec $01,x	                dec 1,x
.9298						_done:
.9298		60		rts		z_s_to_d:       rts
.9299						xt_semicolon:
.9299		24 1c		bit $1c		                bit status
.929b		70 11		bvs $92ae	                bvs _colonword
.929d		a9 60		lda #$60	                lda #OpRTS
.929f		20 49 d6	jsr $d649	                jsr cmpl_a
.92a2		ca		dex		                dex
.92a3		ca		dex		                dex
.92a4		a5 06		lda $06		                lda workword
.92a6		95 00		sta $00,x	                sta 0,x
.92a8		a5 07		lda $07		                lda workword+1
.92aa		95 01		sta $01,x	                sta 1,x
.92ac		80 45		bra $92f3	                bra _semicolon_done
.92ae						_colonword:
.92ae		a0 06		ldy #$06	                ldy #6
.92b0		a5 00		lda $00		                lda cp
.92b2		91 06		sta ($06),y	                sta (workword),y
.92b4		c8		iny		                iny
.92b5		a5 01		lda $01		                lda cp+1
.92b7		91 06		sta ($06),y	                sta (workword),y
.92b9		a9 60		lda #$60	                lda #OpRTS
.92bb		20 49 d6	jsr $d649	                jsr cmpl_a
.92be		24 1c		bit $1c		                bit status
.92c0		10 26		bpl $92e8	                bpl _new_word   ; Bit 7 is clear = new word
.92c2		ca		dex		                dex
.92c3		ca		dex		                dex
.92c4		ca		dex		                dex
.92c5		ca		dex		                dex
.92c6		b2 06		lda ($06)	                lda (workword)
.92c8		95 00		sta $00,x	                sta 0,x
.92ca		74 01		stz $01,x	                stz 1,x
.92cc		a5 06		lda $06		                lda workword
.92ce		18		clc		                clc
.92cf		69 08		adc #$08	                adc #8
.92d1		95 02		sta $02,x	                sta 2,x
.92d3		a5 07		lda $07		                lda workword+1
.92d5		69 00		adc #$00	                adc #0                  ; only want carry
.92d7		95 03		sta $03,x	                sta 3,x
.92d9		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.92db		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.92de		20 7f 96	jsr $967f	                jsr xt_type
.92e1		20 73 93	jsr $9373	                jsr xt_space
.92e4		a9 80		lda #$80	                lda #%10000000
.92e6		14 1c		trb $1c		                trb status
.92e8						_new_word:
.92e8		a5 06		lda $06		                lda workword
.92ea		85 02		sta $02		                sta dp
.92ec		a5 07		lda $07		                lda workword+1
.92ee		85 03		sta $03		                sta dp+1
.92f0		20 6d d7	jsr $d76d	                jsr dp_to_current       ; Save the updated DP to the
.92f3						_semicolon_done:
.92f3		64 1a		stz $1a		                stz state
.92f5		64 1b		stz $1b		                stz state+1
.92f7		60		rts		z_semicolon:    rts
.92f8						xt_sign:
.92f8		20 03 d8	jsr $d803	                jsr underflow_1
.92fb		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.92fd		30 04		bmi $9303	                bmi _minus
.92ff		e8		inx		                inx
.9300		e8		inx		                inx
.9301		80 09		bra $930c	                bra _done
.9303						_minus:
.9303		a9 2d		lda #$2d	                lda #'-'
.9305		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9307		74 01		stz $01,x	                stz 1,x         ; paranoid
.9309		20 a3 8a	jsr $8aa3	                jsr xt_hold
.930c						_done:
.930c		60		rts		z_sign:         rts
.930d						xt_slash:
.930d		a9 00		lda #$00	                lda #0
.930f		48		pha		                pha
.9310		80 03		bra $9315	                bra slashmod_common
.9312						xt_slash_mod:
.9312		a9 ff		lda #$ff	                lda #$FF
.9314		48		pha		                pha             ; falls through to _common
.9315						slashmod_common:
.9315		20 36 95	jsr $9536	                jsr xt_to_r             ; >R
.9318		20 87 92	jsr $9287	                jsr xt_s_to_d           ; S>D
.931b		20 81 90	jsr $9081	                jsr xt_r_from           ; R>
.931e		20 2a 93	jsr $932a	                jsr xt_sm_slash_rem     ; SM/REM
.9321		68		pla		                pla
.9322		d0 05		bne $9329	                bne _done
.9324		20 f8 93	jsr $93f8	                jsr xt_swap
.9327		e8		inx		                inx             ; DROP
.9328		e8		inx		                inx
.9329						_done:
.9329						z_slash_mod:
.9329		60		rts		z_slash:        rts
.932a						xt_sm_slash_rem:
.932a		20 0d d8	jsr $d80d	                jsr underflow_3 ; contains double number
.932d		b5 03		lda $03,x	                lda 3,x
.932f		48		pha		                pha
.9330		b5 01		lda $01,x	                lda 1,x
.9332		55 03		eor $03,x	                eor 3,x
.9334		48		pha		                pha
.9335		20 d1 80	jsr $80d1	                jsr xt_abs
.9338		e8		inx		                inx             ; pretend we pushed n1 to R
.9339		e8		inx		                inx
.933a		20 86 9e	jsr $9e86	                jsr xt_dabs
.933d		ca		dex		                dex
.933e		ca		dex		                dex
.933f		20 04 97	jsr $9704	                jsr xt_um_slash_mod     ; UM/MOD
.9342		68		pla		                pla
.9343		10 03		bpl $9348	                bpl +
.9345		20 b2 8d	jsr $8db2	                jsr xt_negate
.9348						+
.9348		68		pla		                pla
.9349		10 07		bpl $9352	                bpl _done
.934b		e8		inx		                inx             ; pretend we pushed quotient to R
.934c		e8		inx		                inx
.934d		20 b2 8d	jsr $8db2	                jsr xt_negate
.9350		ca		dex		                dex
.9351		ca		dex		                dex
.9352						_done:
.9352		60		rts		z_sm_slash_rem: rts
.9353						xt_source:
.9353		ca		dex		                dex
.9354		ca		dex		                dex
.9355		a5 0c		lda $0c		                lda cib
.9357		95 00		sta $00,x	                sta 0,x
.9359		a5 0d		lda $0d		                lda cib+1
.935b		95 01		sta $01,x	                sta 1,x
.935d		ca		dex		                dex
.935e		ca		dex		                dex
.935f		a5 0e		lda $0e		                lda ciblen
.9361		95 00		sta $00,x	                sta 0,x
.9363		a5 0f		lda $0f		                lda ciblen+1
.9365		95 01		sta $01,x	                sta 1,x
.9367		60		rts		z_source:       rts
.9368						xt_source_id:
.9368		ca		dex		                dex
.9369		ca		dex		                dex
.936a		a5 0a		lda $0a		                lda insrc
.936c		95 00		sta $00,x	                sta 0,x
.936e		a5 0b		lda $0b		                lda insrc+1
.9370		95 01		sta $01,x	                sta 1,x
.9372		60		rts		z_source_id:    rts
.9373						xt_space:
.9373		a9 20		lda #$20	                lda #AscSP
.9375		20 3b 88	jsr $883b	                jsr emit_a
.9378		60		rts		z_space:        rts
.9379						xt_spaces:
.9379		20 03 d8	jsr $d803	                jsr underflow_1
.937c		20 37 9e	jsr $9e37	                jsr xt_zero
.937f		20 3f 8d	jsr $8d3f	                jsr xt_max
.9382		b5 00		lda $00,x	                lda 0,x
.9384		15 01		ora $01,x	                ora 1,x
.9386		f0 2a		beq $93b2	                beq _done
.9388		b4 01		ldy $01,x	                ldy 1,x
.938a		d0 0c		bne $9398	                bne _lots_of_spaces
.938c		b4 00		ldy $00,x	                ldy 0,x
.938e						_quick_loop:
.938e		a9 20		lda #$20	                lda #AscSP
.9390		20 3b 88	jsr $883b	                jsr emit_a
.9393		88		dey		                dey
.9394		f0 1c		beq $93b2	                beq _done
.9396		80 f6		bra $938e	                bra _quick_loop
.9398						_lots_of_spaces:
.9398		b4 00		ldy $00,x	                ldy 0,x
.939a						_first_slow_loop:
.939a		f0 08		beq $93a4	                beq _slow_outer_loop
.939c		a9 20		lda #$20	                lda #AscSP
.939e		20 3b 88	jsr $883b	                jsr emit_a
.93a1		88		dey		                dey
.93a2		80 f6		bra $939a	                bra _first_slow_loop
.93a4						_slow_outer_loop:
.93a4		a0 00		ldy #$00	                ldy #00
.93a6						_slow_inner_loop:
.93a6		a9 20		lda #$20	                lda #AscSP
.93a8		20 3b 88	jsr $883b	                jsr emit_a
.93ab		88		dey		                dey
.93ac		d0 f8		bne $93a6	                bne _slow_inner_loop
.93ae		d6 01		dec $01,x	                dec 1,x
.93b0		d0 f2		bne $93a4	                bne _slow_outer_loop
.93b2						_done:
.93b2		e8		inx		                inx             ; drop
.93b3		e8		inx		                inx
.93b4		60		rts		z_spaces:       rts
.93b5						xt_star:
.93b5		20 08 d8	jsr $d808	                jsr underflow_2
.93b8		20 46 97	jsr $9746	                jsr xt_um_star
.93bb		e8		inx		                inx
.93bc		e8		inx		                inx
.93bd		60		rts		z_star:         rts
.93be						xt_star_slash:
.93be		20 c7 93	jsr $93c7	                jsr xt_star_slash_mod
.93c1		20 f8 93	jsr $93f8	                jsr xt_swap
.93c4		e8		inx		                inx
.93c5		e8		inx		                inx
.93c6						z_star_slash:
.93c6		60		rts		                rts
.93c7						xt_star_slash_mod:
.93c7		20 0d d8	jsr $d80d	                jsr underflow_3
.93ca		20 36 95	jsr $9536	                jsr xt_to_r
.93cd		20 b5 8c	jsr $8cb5	                jsr xt_m_star
.93d0		20 81 90	jsr $9081	                jsr xt_r_from
.93d3		20 2a 93	jsr $932a	                jsr xt_sm_slash_rem
.93d6						z_star_slash_mod:
.93d6		60		rts		                rts
.93d7						xt_state:
.93d7		ca		dex		                dex
.93d8		ca		dex		                dex
.93d9		a9 1a		lda #$1a	                lda #<state
.93db		95 00		sta $00,x	                sta 0,x
.93dd		a9 00		lda #$00	                lda #>state
.93df		95 01		sta $01,x	                sta 1,x
.93e1		60		rts		z_state:        rts
.93e2						xt_store:
.93e2		20 08 d8	jsr $d808	                jsr underflow_2
.93e5		b5 02		lda $02,x	                lda 2,x         ; LSB
.93e7		81 00		sta ($00,x)	                sta (0,x)
.93e9		f6 00		inc $00,x	                inc 0,x
.93eb		d0 02		bne $93ef	                bne +
.93ed		f6 01		inc $01,x	                inc 1,x
.93ef						+
.93ef		b5 03		lda $03,x	                lda 3,x         ; MSB
.93f1		81 00		sta ($00,x)	                sta (0,x)
.93f3		e8		inx		                inx             ; 2DROP
.93f4		e8		inx		                inx
.93f5		e8		inx		                inx
.93f6		e8		inx		                inx
.93f7		60		rts		z_store:        rts
.93f8						xt_swap:
.93f8		20 08 d8	jsr $d808	                jsr underflow_2
.93fb		b5 00		lda $00,x	                lda 0,x         ; LSB
.93fd		b4 02		ldy $02,x	                ldy 2,x
.93ff		95 02		sta $02,x	                sta 2,x
.9401		94 00		sty $00,x	                sty 0,x
.9403		b5 01		lda $01,x	                lda 1,x         ; MSB
.9405		b4 03		ldy $03,x	                ldy 3,x
.9407		95 03		sta $03,x	                sta 3,x
.9409		94 01		sty $01,x	                sty 1,x
.940b		60		rts		z_swap:         rts
.940c						xt_tick:
.940c		20 e4 8e	jsr $8ee4	                jsr xt_parse_name       ; ( -- addr u )
.940f		b5 00		lda $00,x	                lda 0,x
.9411		15 01		ora $01,x	                ora 1,x
.9413		d0 05		bne $941a	                bne +
.9415		a9 05		lda #$05	                lda #err_noname
.9417		4c 19 d8	jmp $d819	                jmp error
.941a						+
.941a		20 36 9b	jsr $9b36	                jsr xt_find_name        ; ( addr u -- nt )
.941d		b5 00		lda $00,x	                lda 0,x
.941f		15 01		ora $01,x	                ora 1,x
.9421		d0 05		bne $9428	                bne +
.9423		a9 08		lda #$08	                lda #err_syntax
.9425		4c 19 d8	jmp $d819	                jmp error
.9428						+
.9428		20 74 9c	jsr $9c74	                jsr xt_name_to_int      ; ( nt -- xt )
.942b		60		rts		z_tick:         rts
.942c						xt_to:
.942c		20 0c 94	jsr $940c	                jsr xt_tick             ; ( [n] xt )
.942f		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9431		18		clc		                clc
.9432		69 03		adc #$03	                adc #3
.9434		85 25		sta $25		                sta tmp1
.9436		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9438		69 00		adc #$00	                adc #0                  ; we just want the carry
.943a		85 26		sta $26		                sta tmp1+1
.943c		a5 1a		lda $1a		                lda state
.943e		05 1b		ora $1b		                ora state+1
.9440		f0 14		beq $9456	                beq _interpret
.9442		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.9444		95 00		sta $00,x	                sta 0,x
.9446		a5 26		lda $26		                lda tmp1+1
.9448		95 01		sta $01,x	                sta 1,x
.944a		20 aa 8b	jsr $8baa	                jsr xt_literal      ; generate the runtime for LITERAL tmp1
.944d		a0 93		ldy #$93	                ldy #>xt_store      ; write the runtime for !
.944f		a9 e2		lda #$e2	                lda #<xt_store
.9451		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.9454		80 11		bra $9467	                bra _done
.9456						_interpret:
.9456		20 08 d8	jsr $d808	                jsr underflow_2
.9459		e8		inx		                inx
.945a		e8		inx		                inx                     ; leaving just ( n )
.945b		b5 00		lda $00,x	                lda 0,x
.945d		92 25		sta ($25)	                sta (tmp1)              ; LSB
.945f		a0 01		ldy #$01	                ldy #1
.9461		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9463		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.9465		e8		inx		                inx                     ; DROP
.9466		e8		inx		                inx
.9467						_done:
.9467		60		rts		z_to:           rts
.9468						xt_to_body:
.9468		20 03 d8	jsr $d803	                jsr underflow_1
.946b		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( xt xt )
.946e		20 ee 9b	jsr $9bee	                jsr xt_int_to_name      ; ( xt nt )
.9471		f6 00		inc $00,x	                inc 0,x
.9473		d0 02		bne $9477	                bne +
.9475		f6 01		inc $01,x	                inc 1,x
.9477						+
.9477		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.9479		29 20		and #$20	                and #HC
.947b		f0 0b		beq $9488	                beq _no_cfa
.947d		18		clc		                clc
.947e		b5 02		lda $02,x	                lda 2,x         ; LSB
.9480		69 03		adc #$03	                adc #3
.9482		95 02		sta $02,x	                sta 2,x
.9484		90 02		bcc $9488	                bcc _no_cfa
.9486		f6 03		inc $03,x	                inc 3,x         ; MSB
.9488						_no_cfa:
.9488		e8		inx		                inx             ; get rid of the nt
.9489		e8		inx		                inx
.948a						_done:
.948a		60		rts		z_to_body:      rts
.948b						xt_to_in:
.948b		ca		dex		                dex
.948c		ca		dex		                dex
.948d		a9 10		lda #$10	                lda #<toin
.948f		95 00		sta $00,x	                sta 0,x
.9491		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.9493		95 01		sta $01,x	                sta 1,x
.9495		60		rts		z_to_in:        rts
.9496						xt_to_number:
.9496		20 12 d8	jsr $d812	                jsr underflow_4
.9499		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.949b		85 2d		sta $2d		                sta scratch
.949d		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.949f		85 2e		sta $2e		                sta scratch+1
.94a1		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.94a3		85 2f		sta $2f		                sta scratch+2
.94a5		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.94a7		85 30		sta $30		                sta scratch+3
.94a9		ca		dex		                dex
.94aa		ca		dex		                dex
.94ab						_loop:
.94ab		a1 04		lda ($04,x)	                lda (4,x)
.94ad		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.94af		74 01		stz $01,x	                stz 1,x                 ; paranoid
.94b1		20 da 9a	jsr $9ada	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.94b4		b5 00		lda $00,x	                lda 0,x
.94b6		d0 04		bne $94bc	                bne _digit_ok
.94b8		e8		inx		                inx
.94b9		e8		inx		                inx
.94ba		80 67		bra $9523	                bra _done       ; ( ud-lo ud-hi addr u char )
.94bc						_digit_ok:
.94bc		b5 02		lda $02,x	                lda 2,x
.94be		85 31		sta $31		                sta scratch+4
.94c0		b5 03		lda $03,x	                lda 3,x
.94c2		85 32		sta $32		                sta scratch+5
.94c4		a5 2f		lda $2f		                lda scratch+2
.94c6		95 02		sta $02,x	                sta 2,x         ; NOS
.94c8		a5 30		lda $30		                lda scratch+3
.94ca		95 03		sta $03,x	                sta 3,x
.94cc		a5 18		lda $18		                lda base
.94ce		95 00		sta $00,x	                sta 0,x         ; TOS
.94d0		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.94d2		20 46 97	jsr $9746	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.94d5		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.94d7		85 33		sta $33		                sta scratch+6
.94d9		b5 03		lda $03,x	                lda 3,x
.94db		85 34		sta $34		                sta scratch+7
.94dd		a5 2d		lda $2d		                lda scratch
.94df		95 02		sta $02,x	                sta 2,x
.94e1		a5 2e		lda $2e		                lda scratch+1
.94e3		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.94e5		a5 18		lda $18		                lda base
.94e7		95 00		sta $00,x	                sta 0,x
.94e9		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.94eb		20 46 97	jsr $9746	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.94ee		b5 00		lda $00,x	                lda 0,x
.94f0		85 2f		sta $2f		                sta scratch+2
.94f2		b5 01		lda $01,x	                lda 1,x
.94f4		85 30		sta $30		                sta scratch+3
.94f6		b5 02		lda $02,x	                lda 2,x
.94f8		85 2d		sta $2d		                sta scratch
.94fa		b5 03		lda $03,x	                lda 3,x
.94fc		85 2e		sta $2e		                sta scratch+1
.94fe		18		clc		                clc
.94ff		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.9501		65 31		adc $31		                adc scratch+4   ; n LSB
.9503		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.9505		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.9507		65 32		adc $32		                adc scratch+5   ; n MSB
.9509		85 2e		sta $2e		                sta scratch+1
.950b		a5 2f		lda $2f		                lda scratch+2   ; LSB
.950d		65 33		adc $33		                adc scratch+6
.950f		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.9511		a5 30		lda $30		                lda scratch+3   ; MSB
.9513		65 34		adc $34		                adc scratch+7
.9515		85 30		sta $30		                sta scratch+3
.9517		e8		inx		                inx
.9518		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.9519		f6 04		inc $04,x	                inc 4,x
.951b		d0 02		bne $951f	                bne +
.951d		f6 05		inc $05,x	                inc 5,x
.951f						+
.951f		d6 02		dec $02,x	                dec 2,x
.9521		d0 88		bne $94ab	                bne _loop
.9523						_done:
.9523		e8		inx		                inx
.9524		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.9525		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.9527		95 06		sta $06,x	                sta 6,x
.9529		a5 2e		lda $2e		                lda scratch+1
.952b		95 07		sta $07,x	                sta 7,x
.952d		a5 2f		lda $2f		                lda scratch+2
.952f		95 04		sta $04,x	                sta 4,x
.9531		a5 30		lda $30		                lda scratch+3
.9533		95 05		sta $05,x	                sta 5,x
.9535		60		rts		z_to_number:    rts
.9536						xt_to_r:
.9536		68		pla		                pla             ; LSB
.9537		85 23		sta $23		                sta tmptos
.9539		7a		ply		                ply             ; MSB
.953a		20 03 d8	jsr $d803	                jsr underflow_1
.953d		b5 01		lda $01,x	                lda 1,x         ; MSB
.953f		48		pha		                pha
.9540		b5 00		lda $00,x	                lda 0,x         ; LSB
.9542		48		pha		                pha
.9543		e8		inx		                inx
.9544		e8		inx		                inx
.9545		5a		phy		                phy             ; MSB
.9546		a5 23		lda $23		                lda tmptos
.9548		48		pha		                pha             ; LSB
.9549		60		rts		z_to_r:         rts
.954a						xt_true:
.954a		ca		dex		                dex
.954b		ca		dex		                dex
.954c		a9 ff		lda #$ff	                lda #$FF
.954e		95 00		sta $00,x	                sta 0,x
.9550		95 01		sta $01,x	                sta 1,x
.9552		60		rts		z_true:         rts
.9553						xt_tuck:
.9553		20 08 d8	jsr $d808	                jsr underflow_2
.9556		ca		dex		                dex
.9557		ca		dex		                dex
.9558		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.955a		b5 02		lda $02,x	                lda 2,x
.955c		95 04		sta $04,x	                sta 4,x
.955e		94 02		sty $02,x	                sty 2,x
.9560		95 00		sta $00,x	                sta 0,x
.9562		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.9564		b5 03		lda $03,x	                lda 3,x
.9566		95 05		sta $05,x	                sta 5,x
.9568		94 03		sty $03,x	                sty 3,x         ; bba
.956a		95 01		sta $01,x	                sta 1,x         ; baa
.956c		60		rts		z_tuck:         rts
.956d						xt_two_drop:
.956d		20 08 d8	jsr $d808	                jsr underflow_2
.9570		e8		inx		                inx
.9571		e8		inx		                inx
.9572		e8		inx		                inx
.9573		e8		inx		                inx
.9574		60		rts		z_two_drop:     rts
.9575						xt_two_dup:
.9575		20 08 d8	jsr $d808	                jsr underflow_2
.9578		ca		dex		                dex
.9579		ca		dex		                dex
.957a		ca		dex		                dex
.957b		ca		dex		                dex
.957c		b5 04		lda $04,x	                lda 4,x         ; TOS
.957e		95 00		sta $00,x	                sta 0,x
.9580		b5 05		lda $05,x	                lda 5,x
.9582		95 01		sta $01,x	                sta 1,x
.9584		b5 06		lda $06,x	                lda 6,x         ; NOS
.9586		95 02		sta $02,x	                sta 2,x
.9588		b5 07		lda $07,x	                lda 7,x
.958a		95 03		sta $03,x	                sta 3,x
.958c		60		rts		z_two_dup:      rts
.958d						xt_two_fetch:
.958d		20 03 d8	jsr $d803	                jsr underflow_1
.9590		b5 00		lda $00,x	                lda 0,x
.9592		85 25		sta $25		                sta tmp1
.9594		b4 01		ldy $01,x	                ldy 1,x
.9596		84 26		sty $26		                sty tmp1+1
.9598		ca		dex		                dex             ; reuse one stack element
.9599		ca		dex		                dex
.959a		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.959c		95 00		sta $00,x	                sta 0,x
.959e		a0 01		ldy #$01	                ldy #1          ; copy next
.95a0		b1 25		lda ($25),y	                lda (tmp1),y
.95a2		95 01		sta $01,x	                sta 1,x
.95a4		c8		iny		                iny             ; copy next
.95a5		b1 25		lda ($25),y	                lda (tmp1),y
.95a7		95 02		sta $02,x	                sta 2,x
.95a9		c8		iny		                iny             ; copy next
.95aa		b1 25		lda ($25),y	                lda (tmp1),y
.95ac		95 03		sta $03,x	                sta 3,x
.95ae		60		rts		z_two_fetch:    rts
.95af						xt_two_over:
.95af		20 12 d8	jsr $d812	                jsr underflow_4
.95b2		ca		dex		                dex
.95b3		ca		dex		                dex
.95b4		ca		dex		                dex
.95b5		ca		dex		                dex
.95b6		b5 08		lda $08,x	                lda 8,x
.95b8		95 00		sta $00,x	                sta 0,x
.95ba		b5 09		lda $09,x	                lda 9,x
.95bc		95 01		sta $01,x	                sta 1,x
.95be		b5 0a		lda $0a,x	                lda 10,x
.95c0		95 02		sta $02,x	                sta 2,x
.95c2		b5 0b		lda $0b,x	                lda 11,x
.95c4		95 03		sta $03,x	                sta 3,x
.95c6		60		rts		z_two_over:     rts
.95c7						xt_two_r_fetch:
.95c7		ca		dex		                dex
.95c8		ca		dex		                dex
.95c9		ca		dex		                dex
.95ca		ca		dex		                dex
.95cb		8a		txa		                txa
.95cc		ba		tsx		                tsx
.95cd		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.95ce		7a		ply		                ply
.95cf		aa		tax		                tax
.95d0		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.95d3		95 00		sta $00,x	                sta 0,x
.95d5		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.95d8		95 01		sta $01,x	                sta 1,x
.95da		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.95dd		95 02		sta $02,x	                sta 2,x
.95df		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.95e2		95 03		sta $03,x	                sta 3,x
.95e4		60		rts		z_two_r_fetch:  rts
.95e5						xt_two_r_from:
.95e5		68		pla		                pla                     ; LSB
.95e6		85 25		sta $25		                sta tmp1
.95e8		68		pla		                pla                     ; MSB
.95e9		85 26		sta $26		                sta tmp1+1
.95eb		ca		dex		                dex
.95ec		ca		dex		                dex
.95ed		ca		dex		                dex
.95ee		ca		dex		                dex
.95ef		68		pla		                pla                     ; LSB
.95f0		95 00		sta $00,x	                sta 0,x
.95f2		68		pla		                pla                     ; MSB
.95f3		95 01		sta $01,x	                sta 1,x
.95f5		68		pla		                pla                     ; LSB
.95f6		95 02		sta $02,x	                sta 2,x
.95f8		68		pla		                pla                     ; MSB
.95f9		95 03		sta $03,x	                sta 3,x
.95fb		a5 26		lda $26		                lda tmp1+1              ; MSB
.95fd		48		pha		                pha
.95fe		a5 25		lda $25		                lda tmp1                ; LSB
.9600		48		pha		                pha
.9601		60		rts		z_two_r_from:   rts
.9602						xt_two_slash:
.9602		20 03 d8	jsr $d803	                jsr underflow_1
.9605		b5 01		lda $01,x	                lda 1,x
.9607		0a		asl a		                asl                     ; save the sign
.9608		76 01		ror $01,x	                ror 1,x
.960a		76 00		ror $00,x	                ror 0,x
.960c		60		rts		z_two_slash:    rts
.960d						xt_two_star:
.960d						xt_cells:
.960d		20 03 d8	jsr $d803	                jsr underflow_1
.9610		16 00		asl $00,x	                asl 0,x
.9612		36 01		rol $01,x	                rol 1,x
.9614						z_cells:
.9614		60		rts		z_two_star:     rts
.9615						xt_two_store:
.9615		20 0d d8	jsr $d80d	                jsr underflow_3
.9618		b5 00		lda $00,x	                lda 0,x
.961a		85 25		sta $25		                sta tmp1
.961c		b4 01		ldy $01,x	                ldy 1,x
.961e		84 26		sty $26		                sty tmp1+1
.9620		e8		inx		                inx
.9621		e8		inx		                inx
.9622		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.9624		92 25		sta ($25)	                sta (tmp1)
.9626		b5 01		lda $01,x	                lda 1,x         ; copy next
.9628		a0 01		ldy #$01	                ldy #1
.962a		91 25		sta ($25),y	                sta (tmp1),y
.962c		b5 02		lda $02,x	                lda 2,x         ; copy next
.962e		c8		iny		                iny
.962f		91 25		sta ($25),y	                sta (tmp1),y
.9631		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.9633		c8		iny		                iny
.9634		91 25		sta ($25),y	                sta (tmp1),y
.9636		e8		inx		                inx             ; 2DROP
.9637		e8		inx		                inx
.9638		e8		inx		                inx
.9639		e8		inx		                inx
.963a		60		rts		z_two_store:    rts
.963b						xt_two_swap:
.963b		20 12 d8	jsr $d812	                jsr underflow_4
.963e		b5 00		lda $00,x	                lda 0,x
.9640		b4 04		ldy $04,x	                ldy 4,x
.9642		95 04		sta $04,x	                sta 4,x
.9644		94 00		sty $00,x	                sty 0,x
.9646		b5 01		lda $01,x	                lda 1,x
.9648		b4 05		ldy $05,x	                ldy 5,x
.964a		95 05		sta $05,x	                sta 5,x
.964c		94 01		sty $01,x	                sty 1,x
.964e		b5 02		lda $02,x	                lda 2,x
.9650		b4 06		ldy $06,x	                ldy 6,x
.9652		95 06		sta $06,x	                sta 6,x
.9654		94 02		sty $02,x	                sty 2,x
.9656		b5 03		lda $03,x	                lda 3,x
.9658		b4 07		ldy $07,x	                ldy 7,x
.965a		95 07		sta $07,x	                sta 7,x
.965c		94 03		sty $03,x	                sty 3,x
.965e		60		rts		z_two_swap:     rts
.965f						xt_two_to_r:
.965f		68		pla		                pla             ; LSB
.9660		85 25		sta $25		                sta tmp1
.9662		68		pla		                pla             ; MSB
.9663		85 26		sta $26		                sta tmp1+1
.9665		20 08 d8	jsr $d808	                jsr underflow_2
.9668		b5 03		lda $03,x	                lda 3,x         ; MSB
.966a		48		pha		                pha
.966b		b5 02		lda $02,x	                lda 2,x         ; LSB
.966d		48		pha		                pha
.966e		b5 01		lda $01,x	                lda 1,x         ; MSB
.9670		48		pha		                pha
.9671		b5 00		lda $00,x	                lda 0,x         ; LSB
.9673		48		pha		                pha
.9674		e8		inx		                inx
.9675		e8		inx		                inx
.9676		e8		inx		                inx
.9677		e8		inx		                inx
.9678		a5 26		lda $26		                lda tmp1+1      ; MSB
.967a		48		pha		                pha
.967b		a5 25		lda $25		                lda tmp1        ; LSB
.967d		48		pha		                pha
.967e		60		rts		z_two_to_r:     rts
.967f						xt_type:
.967f		20 08 d8	jsr $d808	                jsr underflow_2
.9682		b5 02		lda $02,x	                lda 2,x
.9684		85 25		sta $25		                sta tmp1
.9686		b5 03		lda $03,x	                lda 3,x
.9688		85 26		sta $26		                sta tmp1+1
.968a						_loop:
.968a		b5 00		lda $00,x	                lda 0,x
.968c		15 01		ora $01,x	                ora 1,x
.968e		f0 15		beq $96a5	                beq _done
.9690		b2 25		lda ($25)	                lda (tmp1)
.9692		20 3b 88	jsr $883b	                jsr emit_a      ; avoids stack foolery
.9695		e6 25		inc $25		                inc tmp1
.9697		d0 02		bne $969b	                bne +
.9699		e6 26		inc $26		                inc tmp1+1
.969b						+
.969b		b5 00		lda $00,x	                lda 0,x
.969d		d0 02		bne $96a1	                bne +
.969f		d6 01		dec $01,x	                dec 1,x
.96a1						+
.96a1		d6 00		dec $00,x	                dec 0,x
.96a3		80 e5		bra $968a	                bra _loop
.96a5						_done:
.96a5		e8		inx		                inx
.96a6		e8		inx		                inx
.96a7		e8		inx		                inx
.96a8		e8		inx		                inx
.96a9		60		rts		z_type:         rts
.96aa						xt_u_dot:
.96aa		20 03 d8	jsr $d803	                jsr underflow_1
.96ad		20 70 d8	jsr $d870	                jsr print_u
.96b0		a9 20		lda #$20	                lda #AscSP
.96b2		20 3b 88	jsr $883b	                jsr emit_a
.96b5		60		rts		z_u_dot:        rts
.96b6						xt_u_dot_r:
.96b6		20 08 d8	jsr $d808	                jsr underflow_2
.96b9		20 36 95	jsr $9536	                jsr xt_to_r
.96bc		20 37 9e	jsr $9e37	                jsr xt_zero
.96bf		20 87 8b	jsr $8b87	                jsr xt_less_number_sign
.96c2		20 46 8e	jsr $8e46	                jsr xt_number_sign_s
.96c5		20 24 8e	jsr $8e24	                jsr xt_number_sign_greater
.96c8		20 81 90	jsr $9081	                jsr xt_r_from
.96cb		20 98 8e	jsr $8e98	                jsr xt_over
.96ce		20 77 8d	jsr $8d77	                jsr xt_minus
.96d1		20 79 93	jsr $9379	                jsr xt_spaces
.96d4		20 7f 96	jsr $967f	                jsr xt_type
.96d7		60		rts		z_u_dot_r:      rts
.96d8						xt_u_greater_than:
.96d8		20 08 d8	jsr $d808	                jsr underflow_2
.96db		b5 00		lda $00,x	                lda 0,x
.96dd		d5 02		cmp $02,x	                cmp 2,x
.96df		b5 01		lda $01,x	                lda 1,x
.96e1		f5 03		sbc $03,x	                sbc 3,x
.96e3		e8		inx		                inx
.96e4		e8		inx		                inx
.96e5		a9 00		lda #$00	                lda #0
.96e7		69 ff		adc #$ff	                adc #$FF
.96e9		95 00		sta $00,x	                sta 0,x         ; store flag
.96eb		95 01		sta $01,x	                sta 1,x
.96ed		60		rts		z_u_greater_than:    rts
.96ee						xt_u_less_than:
.96ee		20 08 d8	jsr $d808	                jsr underflow_2
.96f1		b5 02		lda $02,x	                lda 2,x
.96f3		d5 00		cmp $00,x	                cmp 0,x
.96f5		b5 03		lda $03,x	                lda 3,x
.96f7		f5 01		sbc $01,x	                sbc 1,x
.96f9		e8		inx		                inx
.96fa		e8		inx		                inx
.96fb		a9 00		lda #$00	                lda #0
.96fd		69 ff		adc #$ff	                adc #$FF
.96ff		95 00		sta $00,x	                sta 0,x         ; store flag
.9701		95 01		sta $01,x	                sta 1,x
.9703		60		rts		z_u_less_than:    rts
.9704						xt_um_slash_mod:
.9704		20 0d d8	jsr $d80d	                jsr underflow_3
.9707		b5 00		lda $00,x	                lda 0,x
.9709		15 01		ora $01,x	                ora 1,x
.970b		d0 05		bne $9712	                bne _not_zero
.970d		a9 04		lda #$04	                lda #err_divzero
.970f		4c 19 d8	jmp $d819	                jmp error
.9712						_not_zero:
.9712		a9 11		lda #$11	                lda #17
.9714		85 23		sta $23		                sta tmptos
.9716						_loop:
.9716		36 04		rol $04,x	                rol 4,x
.9718		36 05		rol $05,x	                rol 5,x
.971a		c6 23		dec $23		                dec tmptos
.971c		f0 22		beq $9740	                beq _done
.971e		36 02		rol $02,x	                rol 2,x
.9720		36 03		rol $03,x	                rol 3,x
.9722		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.9724		26 25		rol $25		                rol tmp1
.9726		38		sec		                sec
.9727		b5 02		lda $02,x	                lda 2,x
.9729		f5 00		sbc $00,x	                sbc 0,x
.972b		85 26		sta $26		                sta tmp1+1
.972d		b5 03		lda $03,x	                lda 3,x
.972f		f5 01		sbc $01,x	                sbc 1,x
.9731		a8		tay		                tay
.9732		a5 25		lda $25		                lda tmp1
.9734		e9 00		sbc #$00	                sbc #0
.9736		90 de		bcc $9716	                bcc _loop
.9738		a5 26		lda $26		                lda tmp1+1
.973a		95 02		sta $02,x	                sta 2,x
.973c		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.973e		80 d6		bra $9716	                bra _loop
.9740						_done:
.9740		e8		inx		                inx
.9741		e8		inx		                inx
.9742		20 f8 93	jsr $93f8	                jsr xt_swap
.9745		60		rts		z_um_slash_mod: rts
.9746						xt_um_star:
.9746		20 08 d8	jsr $d808	                jsr underflow_2
.9749		18		clc		                clc
.974a		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.974c		e9 00		sbc #$00	                sbc #0
.974e		85 27		sta $27		                sta tmp2
.9750		b5 01		lda $01,x	                lda 1,x
.9752		e9 00		sbc #$00	                sbc #0
.9754		90 31		bcc $9787	                bcc _zero       ; is TOS zero?
.9756		85 28		sta $28		                sta tmp2+1
.9758		a9 00		lda #$00	                lda #0
.975a		85 25		sta $25		                sta tmp1
.975c		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.975e		ca		dex		                dex
.975f		ca		dex		                dex
.9760						_outer_loop:
.9760		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.9762		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.9764						_inner_loop:
.9764		90 0c		bcc $9772	                bcc _no_add
.9766		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.9768		a5 25		lda $25		                lda tmp1
.976a		65 27		adc $27		                adc tmp2
.976c		85 25		sta $25		                sta tmp1
.976e		a5 26		lda $26		                lda tmp1+1
.9770		65 28		adc $28		                adc tmp2+1
.9772						_no_add:
.9772		6a		ror a		                ror
.9773		66 25		ror $25		                ror tmp1
.9775		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.9777		88		dey		                dey
.9778		d0 ea		bne $9764	                bne _inner_loop ; go back for one more shift?
.977a		e8		inx		                inx
.977b		e4 29		cpx $29		                cpx tmp3
.977d		d0 e1		bne $9760	                bne _outer_loop ; go back for eight more shifts?
.977f		95 01		sta $01,x	                sta 1,x
.9781		a5 25		lda $25		                lda tmp1
.9783		95 00		sta $00,x	                sta 0,x
.9785		80 04		bra $978b	                bra _done
.9787						_zero:
.9787		74 02		stz $02,x	                stz 2,x
.9789		74 03		stz $03,x	                stz 3,x
.978b						_done:
.978b		60		rts		z_um_star:      rts
.978c						xt_unloop:
.978c		a4 1f		ldy $1f		                ldy loopctrl
.978e		88		dey		                dey
.978f		88		dey		                dey
.9790		88		dey		                dey
.9791		88		dey		                dey
.9792		84 1f		sty $1f		                sty loopctrl
.9794		30 05		bmi $979b	                bmi z_unloop            ; no active loops?
.9796		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.9799		85 20		sta $20		                sta loopidx0
.979b		60		rts		z_unloop:       rts
.979c						xt_until:
.979c		a0 00		ldy #$00	                ldy #0
.979e						-
.979e		b9 db 8a	lda $8adb,y	                lda zero_test_runtime,y
.97a1		c9 60		cmp #$60	                cmp #OpRTS
.97a3		f0 03		beq $97a8	                beq +
.97a5		20 49 d6	jsr $d649	                jsr cmpl_a
.97a8						+
.97a8		c8		iny		                iny
.97a9		c0 0a		cpy #$0a	                cpy #(zero_test_footer_end - zero_test_runtime)
.97ab		d0 f1		bne $979e	                bne -
.97ad		20 da 83	jsr $83da	                jsr xt_comma
.97b0		60		rts		z_until:        rts
.97b1						xt_unused:
.97b1		ca		dex		                dex
.97b2		ca		dex		                dex
.97b3		a9 00		lda #$00	                lda #<cp_end
.97b5		38		sec		                sec
.97b6		e5 00		sbc $00		                sbc cp
.97b8		95 00		sta $00,x	                sta 0,x
.97ba		a9 7c		lda #$7c	                lda #>cp_end
.97bc		e5 01		sbc $01		                sbc cp+1
.97be		95 01		sta $01,x	                sta 1,x
.97c0		60		rts		z_unused:       rts
.97c1						xt_variable:
.97c1		20 6f 85	jsr $856f	                jsr xt_create
.97c4		a9 00		lda #$00	                lda #0
.97c6		92 00		sta ($00)	                sta (cp)
.97c8		e6 00		inc $00		                inc cp
.97ca		d0 02		bne $97ce	                bne +
.97cc		e6 01		inc $01		                inc cp+1
.97ce						+
.97ce		92 00		sta ($00)	                sta (cp)
.97d0		e6 00		inc $00		                inc cp
.97d2		d0 02		bne $97d6	                bne +
.97d4		e6 01		inc $01		                inc cp+1
.97d6						+
.97d6		20 37 85	jsr $8537	                jsr adjust_z
.97d9		60		rts		z_variable:     rts
.97da						xt_while:
.97da		a0 8a		ldy #$8a	                ldy #>zero_branch_runtime
.97dc		a9 e5		lda #$e5	                lda #<zero_branch_runtime
.97de		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.97e1		20 91 8a	jsr $8a91	                jsr xt_here
.97e4		a9 ff		lda #$ff	                lda #$FF
.97e6		a8		tay		                tay
.97e7		20 45 d6	jsr $d645	                jsr cmpl_word
.97ea		20 f8 93	jsr $93f8	                jsr xt_swap
.97ed		60		rts		z_while:        rts
.97ee						xt_within:
.97ee		20 0d d8	jsr $d80d	                jsr underflow_3
.97f1		20 98 8e	jsr $8e98	                jsr xt_over
.97f4		20 77 8d	jsr $8d77	                jsr xt_minus
.97f7		20 36 95	jsr $9536	                jsr xt_to_r
.97fa		20 77 8d	jsr $8d77	                jsr xt_minus
.97fd		20 81 90	jsr $9081	                jsr xt_r_from
.9800		20 ee 96	jsr $96ee	                jsr xt_u_less_than
.9803		60		rts		z_within:       rts
.9804						xt_word:
.9804		20 03 d8	jsr $d803	                jsr underflow_1
.9807		a4 10		ldy $10		                ldy toin                ; >IN
.9809						_loop:
.9809		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.980b		f0 09		beq $9816	                beq _found_char
.980d		b1 0c		lda ($0c),y	                lda (cib),y
.980f		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.9811		d0 03		bne $9816	                bne _found_char
.9813		c8		iny		                iny
.9814		80 f3		bra $9809	                bra _loop
.9816						_found_char:
.9816		84 10		sty $10		                sty toin
.9818		20 3f 8f	jsr $8f3f	                jsr xt_parse            ; Returns ( addr u )
.981b		b5 00		lda $00,x	                lda 0,x
.981d		92 00		sta ($00)	                sta (cp)                ; Save length of string
.981f		48		pha		                pha                     ; Keep copy of length for later
.9820		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( addr u u )
.9823		a5 00		lda $00		                lda cp
.9825		18		clc		                clc
.9826		69 01		adc #$01	                adc #1
.9828		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.982a		a5 01		lda $01		                lda cp+1
.982c		69 00		adc #$00	                adc #0
.982e		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.9830		20 93 8d	jsr $8d93	                jsr xt_move
.9833		ca		dex		                dex
.9834		ca		dex		                dex
.9835		a5 00		lda $00		                lda cp
.9837		95 00		sta $00,x	                sta 0,x
.9839		a5 01		lda $01		                lda cp+1
.983b		95 01		sta $01,x	                sta 1,x
.983d		68		pla		                pla                     ; length of string
.983e		18		clc		                clc
.983f		65 00		adc $00		                adc cp
.9841		85 00		sta $00		                sta cp
.9843		90 02		bcc $9847	                bcc z_word
.9845		e6 01		inc $01		                inc cp+1
.9847		60		rts		z_word:         rts
.9848						xt_xor:
.9848		20 08 d8	jsr $d808	                jsr underflow_2
.984b		b5 00		lda $00,x	                lda 0,x
.984d		55 02		eor $02,x	                eor 2,x
.984f		95 02		sta $02,x	                sta 2,x
.9851		b5 01		lda $01,x	                lda 1,x
.9853		55 03		eor $03,x	                eor 3,x
.9855		95 03		sta $03,x	                sta 3,x
.9857		e8		inx		                inx
.9858		e8		inx		                inx
.9859		60		rts		z_xor:          rts
.985a						xt_zero_equal:
.985a		20 03 d8	jsr $d803	                jsr underflow_1
.985d		b5 00		lda $00,x	                lda 0,x
.985f		15 01		ora $01,x	                ora 1,x
.9861		f0 02		beq $9865	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.9863		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.9865						_zero:
.9865		49 ff		eor #$ff	                eor #$FF        ; now just invert
.9867						_store:
.9867		95 00		sta $00,x	                sta 0,x
.9869		95 01		sta $01,x	                sta 1,x
.986b		60		rts		z_zero_equal:   rts
.986c						xt_zero_greater:
.986c		20 03 d8	jsr $d803	                jsr underflow_1
.986f		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.9871		b5 01		lda $01,x	                lda 1,x         ; MSB
.9873		30 05		bmi $987a	                bmi _done       ; TOS is negative, keep FLASE
.9875		15 00		ora $00,x	                ora 0,x
.9877		f0 01		beq $987a	                beq _done       ; TOS is zero, keep FALSE
.9879		88		dey		                dey             ; TOS is postive, make true
.987a						_done:
.987a		98		tya		                tya
.987b		95 00		sta $00,x	                sta 0,x
.987d		95 01		sta $01,x	                sta 1,x
.987f		60		rts		z_zero_greater: rts
.9880						xt_zero_less:
.9880		20 03 d8	jsr $d803	                jsr underflow_1
.9883		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.9885		b5 01		lda $01,x	                lda 1,x         ; MSB
.9887		10 01		bpl $988a	                bpl _done       ; TOS is positive, so keep FALSE
.9889		88		dey		                dey             ; TOS is negative, make TRUE
.988a						_done:
.988a		98		tya		                tya
.988b		95 00		sta $00,x	                sta 0,x
.988d		95 01		sta $01,x	                sta 1,x
.988f		60		rts		z_zero_less:    rts
.9890						xt_zero_unequal:
.9890		20 03 d8	jsr $d803	                jsr underflow_1
.9893		b5 00		lda $00,x	                lda 0,x
.9895		15 01		ora $01,x	                ora 1,x
.9897		f0 02		beq $989b	                beq _zero
.9899		a9 ff		lda #$ff	                lda #$FF
.989b						_zero:
.989b		95 00		sta $00,x	                sta 0,x
.989d		95 01		sta $01,x	                sta 1,x
.989f		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.98a0						xt_bye:
.98a0		4c 31 f0	jmp $f031	                jmp kernel_bye
.98a3						z_bye:
.98a3						xt_dot_s:
.98a3		20 8b 86	jsr $868b	                jsr xt_depth    ; ( -- u )
.98a6		a9 3c		lda #$3c	                lda #'<'
.98a8		20 3b 88	jsr $883b	                jsr emit_a
.98ab		b5 00		lda $00,x	                lda 0,x
.98ad		48		pha		                pha
.98ae		ca		dex		                dex             ; DUP
.98af		ca		dex		                dex
.98b0		95 00		sta $00,x	                sta 0,x
.98b2		74 01		stz $01,x	                stz 1,x
.98b4		20 70 d8	jsr $d870	                jsr print_u
.98b7		a9 3e		lda #$3e	                lda #'>'
.98b9		20 3b 88	jsr $883b	                jsr emit_a
.98bc		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.98be		20 3b 88	jsr $883b	                jsr emit_a
.98c1		e8		inx		                inx
.98c2		e8		inx		                inx
.98c3		e0 78		cpx #$78	                cpx #dsp0
.98c5		f0 1e		beq $98e5	                beq _done
.98c7						_have_stack:
.98c7		7a		ply		                ply
.98c8		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.98ca		85 29		sta $29		                sta tmp3
.98cc		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.98ce						_loop:
.98ce		ca		dex		                dex
.98cf		ca		dex		                dex
.98d0		b2 29		lda ($29)	                lda (tmp3)
.98d2		95 01		sta $01,x	                sta 1,x
.98d4		c6 29		dec $29		                dec tmp3
.98d6		b2 29		lda ($29)	                lda (tmp3)
.98d8		95 00		sta $00,x	                sta 0,x
.98da		c6 29		dec $29		                dec tmp3
.98dc		5a		phy		                phy
.98dd		20 5b 87	jsr $875b	                jsr xt_dot
.98e0		7a		ply		                ply
.98e1		88		dey		                dey
.98e2		d0 ea		bne $98ce	                bne _loop
.98e4		48		pha		                pha             ; dummy to balance stack
.98e5						_done:
.98e5		68		pla		                pla
.98e6		60		rts		z_dot_s:        rts
.98e7						xt_dump:
.98e7		20 08 d8	jsr $d808	                jsr underflow_2
.98ea						_row:
.98ea		a0 10		ldy #$10	                ldy #16
.98ec		64 27		stz $27		                stz tmp2
.98ee		20 69 85	jsr $8569	                jsr xt_cr
.98f1		b5 03		lda $03,x	                lda 3,x
.98f3		20 ce d6	jsr $d6ce	                jsr byte_to_ascii
.98f6		b5 02		lda $02,x	                lda 2,x
.98f8		20 ce d6	jsr $d6ce	                jsr byte_to_ascii
.98fb		20 73 93	jsr $9373	                jsr xt_space
.98fe		20 73 93	jsr $9373	                jsr xt_space
.9901						_loop:
.9901		b5 00		lda $00,x	                lda 0,x
.9903		15 01		ora $01,x	                ora 1,x
.9905		f0 39		beq $9940	                beq _all_printed
.9907		a1 02		lda ($02,x)	                lda (2,x)
.9909		48		pha		                pha                     ; byte_to_ascii destroys A
.990a		20 ce d6	jsr $d6ce	                jsr byte_to_ascii
.990d		20 73 93	jsr $9373	                jsr xt_space
.9910		68		pla		                pla
.9911		20 e9 d7	jsr $d7e9	                jsr is_printable
.9914		b0 02		bcs $9918	                bcs _printable
.9916		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.9918						_printable:
.9918		5a		phy		                phy                     ; save counter
.9919		a4 27		ldy $27		                ldy tmp2
.991b		91 00		sta ($00),y	                sta (cp),y
.991d		e6 27		inc $27		                inc tmp2
.991f		7a		ply		                ply
.9920		c0 09		cpy #$09	                cpy #9
.9922		d0 03		bne $9927	                bne _next_char
.9924		20 73 93	jsr $9373	                jsr xt_space
.9927						_next_char:
.9927		f6 02		inc $02,x	                inc 2,x
.9929		d0 02		bne $992d	                bne _counter
.992b		f6 03		inc $03,x	                inc 3,x
.992d						_counter:
.992d		b5 00		lda $00,x	                lda 0,x
.992f		d0 02		bne $9933	                bne +
.9931		d6 01		dec $01,x	                dec 1,x
.9933						+
.9933		d6 00		dec $00,x	                dec 0,x
.9935		88		dey		                dey
.9936		d0 c9		bne $9901	                bne _loop               ; next byte
.9938		20 73 93	jsr $9373	                jsr xt_space
.993b		20 4e 99	jsr $994e	                jsr dump_print_ascii
.993e		80 aa		bra $98ea	                bra _row                ; new row
.9940						_all_printed:
.9940		a5 27		lda $27		                lda tmp2
.9942		f0 06		beq $994a	                beq _done
.9944		20 73 93	jsr $9373	                jsr xt_space
.9947		20 4e 99	jsr $994e	                jsr dump_print_ascii
.994a						_done:
.994a		20 6d 95	jsr $956d	                jsr xt_two_drop         ; one byte less than 4x INX
.994d		60		rts		z_dump:         rts
.994e						dump_print_ascii:
.994e		a0 00		ldy #$00	                ldy #0
.9950						_ascii_loop:
.9950		b1 00		lda ($00),y	                lda (cp),y
.9952		20 3b 88	jsr $883b	                jsr emit_a
.9955		c8		iny		                iny
.9956		c0 08		cpy #$08	                cpy #8
.9958		d0 03		bne $995d	                bne +
.995a		20 73 93	jsr $9373	                jsr xt_space
.995d						+
.995d		c6 27		dec $27		                dec tmp2
.995f		d0 ef		bne $9950	                bne _ascii_loop
.9961		60		rts		                rts
.9962						xt_question:
.9962		20 90 89	jsr $8990	                jsr xt_fetch
.9965		20 5b 87	jsr $875b	                jsr xt_dot
.9968		60		rts		z_question:     rts
.9969						xt_see:
.9969		20 e4 8e	jsr $8ee4	                jsr xt_parse_name       ; ( addr u )
.996c		20 36 9b	jsr $9b36	                jsr xt_find_name        ; ( nt | 0 )
.996f		b5 00		lda $00,x	                lda 0,x
.9971		15 01		ora $01,x	                ora 1,x
.9973		d0 05		bne $997a	                bne +
.9975		a9 05		lda #$05	                lda #err_noname
.9977		4c 19 d8	jmp $d819	                jmp error
.997a						+
.997a		20 69 85	jsr $8569	                jsr xt_cr
.997d		a5 18		lda $18		                lda base
.997f		48		pha		                pha
.9980		20 9c 8a	jsr $8a9c	                jsr xt_hex
.9983		a9 09		lda #$09	                lda #str_see_nt
.9985		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.9988		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( nt nt )
.998b		20 aa 96	jsr $96aa	                jsr xt_u_dot
.998e		20 73 93	jsr $9373	                jsr xt_space            ; ( nt )
.9991		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( nt nt )
.9994		20 74 9c	jsr $9c74	                jsr xt_name_to_int      ; ( nt xt )
.9997		a9 0a		lda #$0a	                lda #str_see_xt
.9999		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.999c		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( nt xt xt )
.999f		20 aa 96	jsr $96aa	                jsr xt_u_dot
.99a2		20 69 85	jsr $8569	                jsr xt_cr               ; ( nt xt )
.99a5		a9 08		lda #$08	                lda #str_see_flags
.99a7		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.99aa		20 98 8e	jsr $8e98	                jsr xt_over             ; ( nt xt nt )
.99ad		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; ( nt xt nt+1 )
.99b0		20 90 89	jsr $8990	                jsr xt_fetch            ; ( nt xt flags )
.99b3		b5 00		lda $00,x	                lda 0,x
.99b5		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.99b7						_flag_loop:
.99b7		48		pha		                pha
.99b8		29 01		and #$01	                and #%00000001
.99ba		18		clc		                clc
.99bb		69 30		adc #$30	                adc #'0'
.99bd		20 3b 88	jsr $883b	                jsr emit_a
.99c0		20 73 93	jsr $9373	                jsr xt_space
.99c3		68		pla		                pla
.99c4		6a		ror a		                ror                     ; Next flag
.99c5		88		dey		                dey
.99c6		d0 ef		bne $99b7	                bne _flag_loop
.99c8		20 69 85	jsr $8569	                jsr xt_cr
.99cb		e8		inx		                inx
.99cc		e8		inx		                inx                     ; ( nt xt )
.99cd		a9 0b		lda #$0b	                lda #str_see_size
.99cf		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.99d2		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( xt nt )
.99d5		20 16 9e	jsr $9e16	                jsr xt_wordsize         ; ( xt u )
.99d8		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.99db		20 43 86	jsr $8643	                jsr xt_decimal
.99de		20 aa 96	jsr $96aa	                jsr xt_u_dot            ; ( xt u )
.99e1		20 9c 8a	jsr $8a9c	                jsr xt_hex
.99e4		20 69 85	jsr $8569	                jsr xt_cr
.99e7		20 75 95	jsr $9575	                jsr xt_two_dup          ; ( xt u xt u )
.99ea		20 e7 98	jsr $98e7	                jsr xt_dump
.99ed		20 69 85	jsr $8569	                jsr xt_cr
.99f0		20 e4 a1	jsr $a1e4	                jsr xt_disasm
.99f3		68		pla		                pla
.99f4		85 18		sta $18		                sta base
.99f6		60		rts		z_see:          rts
.99f7						xt_words:
.99f7		20 69 85	jsr $8569	                jsr xt_cr
.99fa		a9 00		lda #$00	                lda #0
.99fc		48		pha		                pha
.99fd		ca		dex		                dex                     ; Make room on the stack for
.99fe		ca		dex		                dex                     ; a dictionary pointer.
.99ff		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.9a01						_wordlist_loop:
.9a01		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.9a03		a5 29		lda $29		                lda tmp3
.9a05		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.9a07		d0 02		bne $9a0b	                bne _have_wordlist
.9a09		80 45		bra $9a50	                bra _words_done
.9a0b						_have_wordlist:
.9a0b		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.9a0c		69 23		adc #$23	                adc #search_order_offset
.9a0e		a8		tay		                tay
.9a0f		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.9a11		0a		asl a		                asl                     ; Turn offset into cells offset.
.9a12		18		clc		                clc
.9a13		69 0a		adc #$0a	                adc #wordlists_offset
.9a15		a8		tay		                tay
.9a16		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9a18		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.9a1a		c8		iny		                iny
.9a1b		b1 08		lda ($08),y	                lda (up),y
.9a1d		95 01		sta $01,x	                sta 1,x
.9a1f						_loop:
.9a1f		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( nt nt )
.9a22		20 91 9c	jsr $9c91	                jsr xt_name_to_string   ; ( nt addr u )
.9a25		68		pla		                pla
.9a26		18		clc		                clc
.9a27		75 00		adc $00,x	                adc 0,x
.9a29		1a		inc a		                ina                     ; don't forget the space between words
.9a2a		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.9a2c		90 06		bcc $9a34	                bcc +
.9a2e		20 69 85	jsr $8569	                jsr xt_cr
.9a31		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.9a33		1a		inc a		                ina                     ; with length of this word.
.9a34						+
.9a34		48		pha		                pha
.9a35		20 7f 96	jsr $967f	                jsr xt_type             ; ( nt )
.9a38		a9 20		lda #$20	                lda #AscSP
.9a3a		20 3b 88	jsr $883b	                jsr emit_a
.9a3d		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+
.9a40		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+
.9a43		20 90 89	jsr $8990	                jsr xt_fetch            ; @ ( nt+1 )
.9a46		b5 00		lda $00,x	                lda 0,x
.9a48		15 01		ora $01,x	                ora 1,x
.9a4a		d0 d3		bne $9a1f	                bne _loop
.9a4c		e6 29		inc $29		                inc tmp3
.9a4e		80 b1		bra $9a01	                bra _wordlist_loop
.9a50						_words_done:
.9a50		68		pla		                pla                     ; dump counter
.9a51		e8		inx		                inx
.9a52		e8		inx		                inx
.9a53		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.9a54						xt_allow_native:
.9a54		20 5a d7	jsr $d75a	                jsr current_to_dp
.9a57		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a59		b1 02		lda ($02),y	                lda (dp),y
.9a5b		29 f5		and #$f5	                and #$FF-NN-AN  ; AN and NN flag is clear.
.9a5d		91 02		sta ($02),y	                sta (dp),y
.9a5f						z_allow_native:
.9a5f		60		rts		                rts
.9a60						xt_always_native:
.9a60		20 5a d7	jsr $d75a	                jsr current_to_dp
.9a63		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9a65		b1 02		lda ($02),y	                lda (dp),y
.9a67		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.9a69		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a6b		91 02		sta ($02),y	                sta (dp),y
.9a6d						z_always_native:
.9a6d		60		rts		                rts
.9a6e						xt_bell:
.9a6e		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.9a70		20 3b 88	jsr $883b	                jsr emit_a
.9a73		60		rts		z_bell:         rts
.9a74						xt_bounds:
.9a74		20 08 d8	jsr $d808	                jsr underflow_2
.9a77		18		clc		                clc
.9a78		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a7a		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9a7c		75 02		adc $02,x	                adc 2,x
.9a7e		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9a80		94 00		sty $00,x	                sty 0,x
.9a82		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9a84		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9a86		75 03		adc $03,x	                adc 3,x
.9a88		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9a8a		94 01		sty $01,x	                sty 1,x
.9a8c		60		rts		z_bounds:       rts
.9a8d						xt_cleave:
.9a8d		20 08 d8	jsr $d808	                jsr underflow_2
.9a90		20 63 a0	jsr $a063	                jsr xt_minus_leading    ; -LEADING ( addr u )
.9a93		20 d8 9b	jsr $9bd8	                jsr xt_input_to_r       ; save old imput state
.9a96		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9a98		85 0e		sta $0e		                sta ciblen
.9a9a		b5 01		lda $01,x	                lda 1,x
.9a9c		85 0f		sta $0f		                sta ciblen+1
.9a9e		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9aa0		85 0c		sta $0c		                sta cib
.9aa2		b5 03		lda $03,x	                lda 3,x
.9aa4		85 0d		sta $0d		                sta cib+1
.9aa6		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9aa8		64 11		stz $11		                stz toin+1
.9aaa		20 e4 8e	jsr $8ee4	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.9aad		b5 00		lda $00,x	                lda 0,x
.9aaf		15 01		ora $01,x	                ora 1,x
.9ab1		f0 23		beq $9ad6	                beq _done
.9ab3		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9ab5		38		sec		                sec
.9ab6		f5 00		sbc $00,x	                sbc 0,x
.9ab8		95 04		sta $04,x	                sta 4,x
.9aba		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9abc		f5 01		sbc $01,x	                sbc 1,x
.9abe		95 05		sta $05,x	                sta 5,x
.9ac0		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9ac2		18		clc		                clc
.9ac3		75 00		adc $00,x	                adc 0,x
.9ac5		95 06		sta $06,x	                sta 6,x
.9ac7		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9ac9		75 01		adc $01,x	                adc 1,x
.9acb		95 07		sta $07,x	                sta 7,x
.9acd		20 3b 96	jsr $963b	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.9ad0		20 63 a0	jsr $a063	                jsr xt_minus_leading
.9ad3		20 3b 96	jsr $963b	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.9ad6						_done:
.9ad6		20 e5 9d	jsr $9de5	                jsr xt_r_to_input
.9ad9		60		rts		z_cleave:       rts
.9ada						xt_digit_question:
.9ada		20 03 d8	jsr $d803	                jsr underflow_1
.9add		ca		dex		                dex
.9ade		ca		dex		                dex
.9adf		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9ae1		74 01		stz $01,x	                stz 1,x
.9ae3		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9ae5		b5 02		lda $02,x	                lda 2,x
.9ae7		c9 30		cmp #$30	                cmp #'0'
.9ae9		90 23		bcc $9b0e	                bcc _done               ; failure flag already set
.9aeb		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9aed		90 12		bcc $9b01	                bcc _checkbase
.9aef		c9 41		cmp #$41	                cmp #'A'
.9af1		90 1b		bcc $9b0e	                bcc _done               ; failure flag is already set
.9af3		c9 61		cmp #$61	                cmp #'a'
.9af5		90 07		bcc $9afe	                bcc _case_done          ; not lower case, too low
.9af7		c9 7b		cmp #$7b	                cmp #'z'+1
.9af9		b0 03		bcs $9afe	                bcs _case_done          ; not lower case, too high
.9afb		18		clc		                clc                     ; just right
.9afc		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9afe						_case_done:
.9afe		38		sec		                sec
.9aff		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9b01						_checkbase:
.9b01		38		sec		                sec
.9b02		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9b04		c5 18		cmp $18		                cmp base
.9b06		b0 06		bcs $9b0e	                bcs _done               ; already have false flag
.9b08		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9b0a		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9b0c		d6 01		dec $01,x	                dec 1,x
.9b0e						_done:
.9b0e						z_digit_question:
.9b0e		60		rts		                rts
.9b0f						xt_execute_parsing:
.9b0f		20 0d d8	jsr $d80d	                jsr underflow_3
.9b12		20 d8 9b	jsr $9bd8	                jsr xt_input_to_r       ; save normal input for later
.9b15		20 bb 9c	jsr $9cbb	                jsr xt_not_rote         ; -ROT ( xt addr u )
.9b18		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9b1a		85 0e		sta $0e		                sta ciblen
.9b1c		b5 01		lda $01,x	                lda 1,x
.9b1e		85 0f		sta $0f		                sta ciblen+1
.9b20		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9b22		85 0c		sta $0c		                sta cib
.9b24		b5 03		lda $03,x	                lda 3,x
.9b26		85 0d		sta $0d		                sta cib+1
.9b28		64 10		stz $10		                stz toin                ; Set >IN to zero
.9b2a		64 11		stz $11		                stz toin+1
.9b2c		20 6d 95	jsr $956d	                jsr xt_two_drop         ; 2DROP ( xt )
.9b2f		20 7b 89	jsr $897b	                jsr xt_execute
.9b32		20 e5 9d	jsr $9de5	                jsr xt_r_to_input
.9b35						z_execute_parsing:
.9b35		60		rts		                rts
.9b36						xt_find_name:
.9b36		20 08 d8	jsr $d808	                jsr underflow_2
.9b39		b5 00		lda $00,x	                lda 0,x
.9b3b		15 01		ora $01,x	                ora 1,x
.9b3d		d0 03		bne $9b42	                bne _nonempty
.9b3f		4c 73 9b	jmp $9b73	                jmp _fail_done
.9b42						_nonempty:
.9b42		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9b44						_wordlist_loop:
.9b44		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9b46		a5 29		lda $29		                lda tmp3
.9b48		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9b4a		f0 27		beq $9b73	                beq _fail_done
.9b4c		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9b4d		69 23		adc #$23	                adc #search_order_offset
.9b4f		a8		tay		                tay
.9b50		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9b52		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b53		18		clc		                clc
.9b54		69 0a		adc #$0a	                adc #wordlists_offset
.9b56		a8		tay		                tay
.9b57		b1 08		lda ($08),y	                lda (up),y
.9b59		85 25		sta $25		                sta tmp1
.9b5b		c8		iny		                iny
.9b5c		b1 08		lda ($08),y	                lda (up),y
.9b5e		85 26		sta $26		                sta tmp1+1
.9b60		20 e5 d6	jsr $d6e5	                jsr find_header_name
.9b63		d0 04		bne $9b69	                bne _success
.9b65		e6 29		inc $29		                inc tmp3
.9b67		80 db		bra $9b44	                bra _wordlist_loop
.9b69						_success:
.9b69		a5 25		lda $25		                lda tmp1
.9b6b		95 02		sta $02,x	                sta 2,x
.9b6d		a5 26		lda $26		                lda tmp1+1
.9b6f		95 03		sta $03,x	                sta 3,x
.9b71		80 04		bra $9b77	                bra _done
.9b73						_fail_done:
.9b73		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b75		74 03		stz $03,x	                stz 3,x
.9b77						_done:
.9b77		e8		inx		                inx
.9b78		e8		inx		                inx
.9b79		60		rts		z_find_name:    rts
.9b7a						xt_hexstore:
.9b7a		20 0d d8	jsr $d80d	                jsr underflow_3
.9b7d		20 cb 87	jsr $87cb	                jsr xt_dup              ; Save copy of original address
.9b80		20 5f 96	jsr $965f	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9b83						_loop:
.9b83		b5 00		lda $00,x	                lda 0,x
.9b85		15 01		ora $01,x	                ora 1,x
.9b87		f0 36		beq $9bbf	                beq _done
.9b89		20 8d 9a	jsr $9a8d	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9b8c		20 5f 96	jsr $965f	                jsr xt_two_to_r
.9b8f		20 37 9e	jsr $9e37	                jsr xt_zero
.9b92		20 37 9e	jsr $9e37	                jsr xt_zero
.9b95		20 e5 95	jsr $95e5	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9b98		20 96 94	jsr $9496	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9b9b		b5 00		lda $00,x	                lda 0,x
.9b9d		15 01		ora $01,x	                ora 1,x
.9b9f		d0 17		bne $9bb8	                bne _have_chars_left
.9ba1		20 6d 95	jsr $956d	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9ba4		20 80 9e	jsr $9e80	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9ba7		20 6c 90	jsr $906c	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9baa		20 44 83	jsr $8344	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9bad		20 81 90	jsr $9081	                jsr xt_r_from           ; R>
.9bb0		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+
.9bb3		20 36 95	jsr $9536	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9bb6		80 cb		bra $9b83	                bra _loop
.9bb8						_have_chars_left:
.9bb8		8a		txa		                txa
.9bb9		18		clc		                clc
.9bba		69 08		adc #$08	                adc #8
.9bbc		aa		tax		                tax
.9bbd		80 c4		bra $9b83	                bra _loop
.9bbf						_done:
.9bbf		e8		inx		                inx
.9bc0		e8		inx		                inx
.9bc1		e8		inx		                inx
.9bc2		e8		inx		                inx                     ; 2DROP
.9bc3		20 e5 95	jsr $95e5	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.9bc6		20 f8 93	jsr $93f8	                jsr xt_swap
.9bc9		20 77 8d	jsr $8d77	                jsr xt_minus            ; ( n )
.9bcc		60		rts		z_hexstore:     rts
.9bcd						xt_input:
.9bcd		ca		dex		                dex
.9bce		ca		dex		                dex
.9bcf		a9 14		lda #$14	                lda #<input
.9bd1		95 00		sta $00,x	                sta 0,x
.9bd3		a9 00		lda #$00	                lda #>input
.9bd5		95 01		sta $01,x	                sta 1,x
.9bd7		60		rts		z_input:        rts
.9bd8						xt_input_to_r:
.9bd8		68		pla		                pla
.9bd9		85 25		sta $25		                sta tmp1
.9bdb		68		pla		                pla
.9bdc		85 26		sta $26		                sta tmp1+1
.9bde		a0 07		ldy #$07	                ldy #7
.9be0						_loop:
.9be0		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9be3		48		pha		                pha
.9be4		88		dey		                dey
.9be5		10 f9		bpl $9be0	                bpl _loop
.9be7		a5 26		lda $26		                lda tmp1+1
.9be9		48		pha		                pha
.9bea		a5 25		lda $25		                lda tmp1
.9bec		48		pha		                pha
.9bed		60		rts		z_input_to_r: 	rts
.9bee						xt_int_to_name:
.9bee		20 03 d8	jsr $d803	                jsr underflow_1
.9bf1		ca		dex		                dex
.9bf2		ca		dex		                dex
.9bf3		74 00		stz $00,x	                stz 0,x
.9bf5		74 01		stz $01,x	                stz 1,x
.9bf7						_wordlist_loop:
.9bf7		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9bf9		0a		asl a		                asl                     ; Turn offset into cells offset.
.9bfa		18		clc		                clc
.9bfb		69 0a		adc #$0a	                adc #wordlists_offset
.9bfd		a8		tay		                tay
.9bfe		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9c00		85 27		sta $27		                sta tmp2                ; into tmp2
.9c02		c8		iny		                iny
.9c03		b1 08		lda ($08),y	                lda (up),y
.9c05		85 28		sta $28		                sta tmp2+1
.9c07		a5 27		lda $27		                lda tmp2
.9c09		05 28		ora $28		                ora tmp2+1
.9c0b		f0 36		beq $9c43	                beq _next_wordlist
.9c0d		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9c0f		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9c11		b5 03		lda $03,x	                lda 3,x
.9c13		85 2a		sta $2a		                sta tmp3+1
.9c15						_loop:
.9c15		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9c17		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9c19		c5 29		cmp $29		                cmp tmp3
.9c1b		d0 07		bne $9c24	                bne _no_match
.9c1d		c8		iny		                iny
.9c1e		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9c20		c5 2a		cmp $2a		                cmp tmp3+1
.9c22		f0 30		beq $9c54	                beq _match
.9c24						_no_match:
.9c24		18		clc		                clc
.9c25		a5 27		lda $27		                lda tmp2
.9c27		69 02		adc #$02	                adc #2
.9c29		85 27		sta $27		                sta tmp2
.9c2b		90 02		bcc $9c2f	                bcc +
.9c2d		e6 28		inc $28		                inc tmp2+1
.9c2f						+
.9c2f		a0 00		ldy #$00	                ldy #0
.9c31		b1 27		lda ($27),y	                lda (tmp2),y
.9c33		48		pha		                pha
.9c34		c8		iny		                iny
.9c35		11 27		ora ($27),y	                ora (tmp2),y
.9c37		f0 09		beq $9c42	                beq _zero
.9c39		b1 27		lda ($27),y	                lda (tmp2),y
.9c3b		85 28		sta $28		                sta tmp2+1
.9c3d		68		pla		                pla
.9c3e		85 27		sta $27		                sta tmp2
.9c40		80 d3		bra $9c15	                bra _loop
.9c42						_zero:
.9c42		68		pla		                pla             ; Leftover from above loop
.9c43						_next_wordlist:
.9c43		b5 00		lda $00,x	                lda 0,x
.9c45		1a		inc a		                ina
.9c46		95 00		sta $00,x	                sta 0,x
.9c48		c9 0c		cmp #$0c	                cmp #max_wordlists
.9c4a		d0 ab		bne $9bf7	                bne _wordlist_loop
.9c4c		e8		inx		                inx
.9c4d		e8		inx		                inx
.9c4e		74 00		stz $00,x	                stz 0,x
.9c50		74 01		stz $01,x	                stz 1,x
.9c52		80 0a		bra $9c5e	                bra z_int_to_name
.9c54						_match:
.9c54		e8		inx		                inx
.9c55		e8		inx		                inx
.9c56		a5 27		lda $27		                lda tmp2
.9c58		95 00		sta $00,x	                sta 0,x
.9c5a		a5 28		lda $28		                lda tmp2+1
.9c5c		95 01		sta $01,x	                sta 1,x
.9c5e		60		rts		z_int_to_name:  rts
.9c5f						xt_latestnt:
.9c5f		ca		dex		                dex
.9c60		ca		dex		                dex
.9c61		20 5a d7	jsr $d75a	                jsr current_to_dp
.9c64		a5 02		lda $02		                lda dp
.9c66		95 00		sta $00,x	                sta 0,x
.9c68		a5 03		lda $03		                lda dp+1
.9c6a		95 01		sta $01,x	                sta 1,x
.9c6c		60		rts		z_latestnt:     rts
.9c6d						xt_latestxt:
.9c6d		20 5f 9c	jsr $9c5f	                jsr xt_latestnt         ; ( nt )
.9c70		20 74 9c	jsr $9c74	                jsr xt_name_to_int      ; ( xt )
.9c73		60		rts		z_latestxt:     rts
.9c74						xt_name_to_int:
.9c74		20 03 d8	jsr $d803	                jsr underflow_1
.9c77		b5 00		lda $00,x	                lda 0,x
.9c79		18		clc		                clc
.9c7a		69 04		adc #$04	                adc #4
.9c7c		85 29		sta $29		                sta tmp3
.9c7e		b5 01		lda $01,x	                lda 1,x
.9c80		90 01		bcc $9c83	                bcc _done
.9c82		1a		inc a		                ina
.9c83						_done:
.9c83		85 2a		sta $2a		                sta tmp3+1
.9c85		a0 00		ldy #$00	                ldy #0
.9c87		b1 29		lda ($29),y	                lda (tmp3),y
.9c89		95 00		sta $00,x	                sta 0,x
.9c8b		c8		iny		                iny
.9c8c		b1 29		lda ($29),y	                lda (tmp3),y
.9c8e		95 01		sta $01,x	                sta 1,x
.9c90		60		rts		z_name_to_int:  rts
.9c91						xt_name_to_string:
.9c91		20 03 d8	jsr $d803	                jsr underflow_1
.9c94		ca		dex		                dex
.9c95		ca		dex		                dex
.9c96		a1 02		lda ($02,x)	                lda (2,x)
.9c98		95 00		sta $00,x	                sta 0,x
.9c9a		74 01		stz $01,x	                stz 1,x
.9c9c		b5 02		lda $02,x	                lda 2,x         ; LSB
.9c9e		18		clc		                clc
.9c9f		69 08		adc #$08	                adc #8
.9ca1		95 02		sta $02,x	                sta 2,x
.9ca3		90 02		bcc $9ca7	                bcc z_name_to_string
.9ca5		f6 03		inc $03,x	                inc 3,x         ; MSB
.9ca7						z_name_to_string:
.9ca7		60		rts		                rts
.9ca8						xt_nc_limit:
.9ca8		a9 00		lda #$00	                lda #nc_limit_offset
.9caa		4c bf d6	jmp $d6bf	                jmp push_upvar_tos
.9cad						z_nc_limit:
.9cad						xt_never_native:
.9cad		20 5a d7	jsr $d75a	                jsr current_to_dp
.9cb0		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9cb2		b1 02		lda ($02),y	                lda (dp),y
.9cb4		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9cb6		29 fd		and #$fd	                and #$FF-AN     ; and AN flag is clear.
.9cb8		91 02		sta ($02),y	                sta (dp),y
.9cba						z_never_native:
.9cba		60		rts		                rts
.9cbb						xt_not_rote:
.9cbb		20 0d d8	jsr $d80d	                jsr underflow_3
.9cbe		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9cc0		b5 03		lda $03,x	                lda 3,x
.9cc2		95 01		sta $01,x	                sta 1,x
.9cc4		b5 05		lda $05,x	                lda 5,x
.9cc6		95 03		sta $03,x	                sta 3,x
.9cc8		94 05		sty $05,x	                sty 5,x
.9cca		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9ccc		b5 02		lda $02,x	                lda 2,x
.9cce		95 00		sta $00,x	                sta 0,x
.9cd0		b5 04		lda $04,x	                lda 4,x
.9cd2		95 02		sta $02,x	                sta 2,x
.9cd4		94 04		sty $04,x	                sty 4,x
.9cd6		60		rts		z_not_rote:     rts
.9cd7						xt_number:
.9cd7		20 08 d8	jsr $d808	                jsr underflow_2
.9cda		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9cdc		a5 18		lda $18		                lda base
.9cde		48		pha		                pha
.9cdf		20 75 95	jsr $9575	                jsr xt_two_dup
.9ce2		a1 02		lda ($02,x)	                lda (2,x)
.9ce4						_check_dec:
.9ce4		c9 23		cmp #$23	                cmp #'#'
.9ce6		d0 04		bne $9cec	                bne _check_hex
.9ce8		a9 0a		lda #$0a	                lda #10
.9cea		80 42		bra $9d2e	                bra _base_changed
.9cec						_check_hex:
.9cec		c9 24		cmp #$24	                cmp #'$'
.9cee		d0 04		bne $9cf4	                bne _check_binary
.9cf0		a9 10		lda #$10	                lda #16
.9cf2		80 3a		bra $9d2e	                bra _base_changed
.9cf4						_check_binary:
.9cf4		c9 25		cmp #$25	                cmp #'%'
.9cf6		d0 04		bne $9cfc	                bne _check_char
.9cf8		a9 02		lda #$02	                lda #2
.9cfa		80 32		bra $9d2e	                bra _base_changed
.9cfc						_check_char:
.9cfc		c9 27		cmp #$27	                cmp #"'"
.9cfe		d0 3a		bne $9d3a	                bne _check_minus
.9d00		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9d02		c9 03		cmp #$03	                cmp #3
.9d04		d0 26		bne $9d2c	                bne _not_a_char
.9d06		b5 01		lda $01,x	                lda 1,x
.9d08		d0 22		bne $9d2c	                bne _not_a_char ; No compare needed to check for non-zero.
.9d0a		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d0c		18		clc		                clc
.9d0d		69 02		adc #$02	                adc #2          ; length of string
.9d0f		85 23		sta $23		                sta tmptos
.9d11		b5 03		lda $03,x	                lda 3,x
.9d13		69 00		adc #$00	                adc #0          ; only need carry
.9d15		85 24		sta $24		                sta tmptos+1
.9d17		b2 23		lda ($23)	                lda (tmptos)
.9d19		c9 27		cmp #$27	                cmp #"'"
.9d1b		d0 0f		bne $9d2c	                bne _not_a_char
.9d1d		f6 02		inc $02,x	                inc 2,x
.9d1f		d0 02		bne $9d23	                bne +
.9d21		f6 03		inc $03,x	                inc 3,x
.9d23						+
.9d23		a1 02		lda ($02,x)	                lda (2,x)
.9d25		95 02		sta $02,x	                sta 2,x
.9d27		74 03		stz $03,x	                stz 3,x
.9d29		4c ac 9d	jmp $9dac	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9d2c						_not_a_char:
.9d2c		80 5c		bra $9d8a	                bra _number_error
.9d2e						_base_changed:
.9d2e		85 18		sta $18		                sta base        ; Switch to the new base
.9d30		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d32		d0 02		bne $9d36	                bne +
.9d34		f6 03		inc $03,x	                inc 3,x
.9d36						+
.9d36		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d38		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9d3a						_check_minus:
.9d3a		c9 2d		cmp #$2d	                cmp #'-'
.9d3c		d0 0c		bne $9d4a	                bne _check_dot
.9d3e		a9 80		lda #$80	                lda #$80
.9d40		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9d42		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d44		d0 02		bne $9d48	                bne +
.9d46		f6 03		inc $03,x	                inc 3,x
.9d48						+
.9d48		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d4a						_check_dot:
.9d4a		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d4c		18		clc		                clc
.9d4d		75 00		adc $00,x	                adc 0,x         ; length of string
.9d4f		85 23		sta $23		                sta tmptos
.9d51		b5 03		lda $03,x	                lda 3,x
.9d53		69 00		adc #$00	                adc #0          ; only need carry
.9d55		85 24		sta $24		                sta tmptos+1
.9d57		a5 23		lda $23		                lda tmptos
.9d59		d0 02		bne $9d5d	                bne +
.9d5b		c6 24		dec $24		                dec tmptos+1
.9d5d						+
.9d5d		c6 23		dec $23		                dec tmptos
.9d5f		b2 23		lda ($23)	                lda (tmptos)
.9d61		c9 2e		cmp #$2e	                cmp #'.'
.9d63		d0 04		bne $9d69	                bne _main
.9d65		e6 1e		inc $1e		                inc tmpdsp
.9d67		d6 00		dec $00,x	                dec 0,x
.9d69						_main:
.9d69		ca		dex		                dex
.9d6a		ca		dex		                dex
.9d6b		ca		dex		                dex
.9d6c		ca		dex		                dex
.9d6d		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d6f		95 00		sta $00,x	                sta 0,x
.9d71		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9d73		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9d75		95 02		sta $02,x	                sta 2,x
.9d77		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9d79		95 03		sta $03,x	                sta 3,x
.9d7b		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9d7d		74 05		stz $05,x	                stz 5,x
.9d7f		74 06		stz $06,x	                stz 6,x
.9d81		74 07		stz $07,x	                stz 7,x
.9d83		20 96 94	jsr $9496	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9d86		b5 00		lda $00,x	                lda 0,x
.9d88		f0 1e		beq $9da8	                beq _all_converted
.9d8a						_number_error:
.9d8a		20 6d 95	jsr $956d	                jsr xt_two_drop ; >NUMBER modified addr u
.9d8d		20 6d 95	jsr $956d	                jsr xt_two_drop ; ud   (partially converted number)
.9d90		a9 3e		lda #$3e	                lda #'>'
.9d92		20 3b 88	jsr $883b	                jsr emit_a
.9d95		20 7f 96	jsr $967f	                jsr xt_type
.9d98		a9 3c		lda #$3c	                lda #'<'
.9d9a		20 3b 88	jsr $883b	                jsr emit_a
.9d9d		20 73 93	jsr $9373	                jsr xt_space
.9da0		68		pla		                pla
.9da1		85 18		sta $18		                sta base
.9da3		a9 08		lda #$08	                lda #err_syntax
.9da5		4c 19 d8	jmp $d819	                jmp error
.9da8						_all_converted:
.9da8		e8		inx		                inx ; Drop the current addr u
.9da9		e8		inx		                inx
.9daa		e8		inx		                inx
.9dab		e8		inx		                inx
.9dac						_drop_original_string:
.9dac		20 3b 96	jsr $963b	                jsr xt_two_swap  ; Drop the original addr u
.9daf		20 6d 95	jsr $956d	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9db2		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9db4		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9db6		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9db7		f0 0a		beq $9dc3	                beq _single
.9db9		98		tya		                tya
.9dba		04 1c		tsb $1c		                tsb status
.9dbc		90 0f		bcc $9dcd	                bcc _done       ; no minus, all done
.9dbe		20 a5 9e	jsr $9ea5	                jsr xt_dnegate
.9dc1		80 0a		bra $9dcd	                bra _done
.9dc3						_single:
.9dc3		e8		inx		                inx
.9dc4		e8		inx		                inx
.9dc5		98		tya		                tya
.9dc6		14 1c		trb $1c		                trb status
.9dc8		90 03		bcc $9dcd	                bcc _done       ; no minus, all done
.9dca		20 b2 8d	jsr $8db2	                jsr xt_negate
.9dcd						_done:
.9dcd		68		pla		                pla
.9dce		85 18		sta $18		                sta base
.9dd0		60		rts		z_number:       rts
.9dd1						xt_editor_wordlist:
.9dd1						xt_one:
.9dd1		ca		dex		                dex
.9dd2		ca		dex		                dex
.9dd3		a9 01		lda #$01	                lda #1
.9dd5		95 00		sta $00,x	                sta 0,x
.9dd7		74 01		stz $01,x	                stz 1,x
.9dd9						z_editor_wordlist:
.9dd9						z_one:
.9dd9		60		rts		                rts
.9dda						xt_output:
.9dda		ca		dex		                dex
.9ddb		ca		dex		                dex
.9ddc		a9 12		lda #$12	                lda #<output
.9dde		95 00		sta $00,x	                sta 0,x
.9de0		a9 00		lda #$00	                lda #>output
.9de2		95 01		sta $01,x	                sta 1,x
.9de4		60		rts		z_output:       rts
.9de5						xt_r_to_input:
.9de5		68		pla		                pla
.9de6		85 25		sta $25		                sta tmp1
.9de8		68		pla		                pla
.9de9		85 26		sta $26		                sta tmp1+1
.9deb		a0 00		ldy #$00	                ldy #0
.9ded						_loop:
.9ded		68		pla		                pla
.9dee		99 0a 00	sta $000a,y	                sta insrc,y
.9df1		c8		iny		                iny
.9df2		c0 08		cpy #$08	                cpy #8
.9df4		d0 f7		bne $9ded	                bne _loop
.9df6		a5 26		lda $26		                lda tmp1+1
.9df8		48		pha		                pha
.9df9		a5 25		lda $25		                lda tmp1
.9dfb		48		pha		                pha
.9dfc		60		rts		z_r_to_input: 	rts
.9dfd						xt_strip_underflow:
.9dfd		a9 02		lda #$02	                lda #uf_strip_offset
.9dff		4c bf d6	jmp $d6bf	                jmp push_upvar_tos
.9e02						z_strip_underflow:
.9e02						xt_assembler_wordlist:
.9e02						xt_two:
.9e02		ca		dex		                dex
.9e03		ca		dex		                dex
.9e04		a9 02		lda #$02	                lda #2
.9e06		95 00		sta $00,x	                sta 0,x
.9e08		74 01		stz $01,x	                stz 1,x
.9e0a						z_assembler_wordlist:
.9e0a		60		rts		z_two:          rts
.9e0b						xt_useraddr:
.9e0b		ca		dex		                dex
.9e0c		ca		dex		                dex
.9e0d		a9 08		lda #$08	                lda #<up
.9e0f		95 00		sta $00,x	                sta 0,x
.9e11		a9 00		lda #$00	                lda #>up
.9e13		95 01		sta $01,x	                sta 1,x
.9e15		60		rts		z_useraddr:     rts
.9e16						xt_wordsize:
.9e16		20 03 d8	jsr $d803	                jsr underflow_1
.9e19		b5 00		lda $00,x	                lda 0,x
.9e1b		85 25		sta $25		                sta tmp1
.9e1d		b5 01		lda $01,x	                lda 1,x
.9e1f		85 26		sta $26		                sta tmp1+1
.9e21		a0 06		ldy #$06	                ldy #6
.9e23		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9e25		88		dey		                dey
.9e26		88		dey		                dey
.9e27		38		sec		                sec
.9e28		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9e2a		95 00		sta $00,x	                sta 0,x
.9e2c		a0 07		ldy #$07	                ldy #7
.9e2e		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9e30		88		dey		                dey
.9e31		88		dey		                dey
.9e32		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9e34		95 01		sta $01,x	                sta 1,x
.9e36		60		rts		z_wordsize:     rts
.9e37						xt_case:
.9e37						xt_false:
.9e37						xt_forth_wordlist:
.9e37						xt_zero:
.9e37		ca		dex		                dex             ; push
.9e38		ca		dex		                dex
.9e39		74 00		stz $00,x	                stz 0,x
.9e3b		74 01		stz $01,x	                stz 1,x
.9e3d						z_case:
.9e3d						z_false:
.9e3d						z_forth_wordlist:
.9e3d						z_zero:
.9e3d		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9e3e						xt_d_minus:
.9e3e		20 12 d8	jsr $d812	                jsr underflow_4 ; two double numbers
.9e41		38		sec		                sec
.9e42		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9e44		f5 02		sbc $02,x	                sbc 2,x
.9e46		95 06		sta $06,x	                sta 6,x
.9e48		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9e4a		f5 03		sbc $03,x	                sbc 3,x
.9e4c		95 07		sta $07,x	                sta 7,x
.9e4e		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9e50		f5 00		sbc $00,x	                sbc 0,x
.9e52		95 04		sta $04,x	                sta 4,x
.9e54		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9e56		f5 01		sbc $01,x	                sbc 1,x
.9e58		95 05		sta $05,x	                sta 5,x
.9e5a		e8		inx		                inx
.9e5b		e8		inx		                inx
.9e5c		e8		inx		                inx
.9e5d		e8		inx		                inx
.9e5e		60		rts		z_d_minus:      rts
.9e5f						xt_d_plus:
.9e5f		20 12 d8	jsr $d812	                jsr underflow_4 ; two double numbers
.9e62		18		clc		                clc
.9e63		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9e65		75 06		adc $06,x	                adc 6,x
.9e67		95 06		sta $06,x	                sta 6,x
.9e69		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e6b		75 07		adc $07,x	                adc 7,x
.9e6d		95 07		sta $07,x	                sta 7,x
.9e6f		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9e71		75 04		adc $04,x	                adc 4,x
.9e73		95 04		sta $04,x	                sta 4,x
.9e75		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9e77		75 05		adc $05,x	                adc 5,x
.9e79		95 05		sta $05,x	                sta 5,x
.9e7b		e8		inx		                inx
.9e7c		e8		inx		                inx
.9e7d		e8		inx		                inx
.9e7e		e8		inx		                inx
.9e7f		60		rts		z_d_plus:       rts
.9e80						xt_d_to_s:
.9e80		20 08 d8	jsr $d808	                jsr underflow_2
.9e83		e8		inx		                inx
.9e84		e8		inx		                inx
.9e85		60		rts		z_d_to_s:       rts
.9e86						xt_dabs:
.9e86		20 08 d8	jsr $d808	                jsr underflow_2 ; double number
.9e89		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9e8b		10 17		bpl $9ea4	                bpl _done       ; positive, we get off light
.9e8d		a0 00		ldy #$00	                ldy #0
.9e8f		38		sec		                sec
.9e90		98		tya		                tya
.9e91		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9e93		95 02		sta $02,x	                sta 2,x
.9e95		98		tya		                tya
.9e96		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9e98		95 03		sta $03,x	                sta 3,x
.9e9a		98		tya		                tya
.9e9b		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9e9d		95 00		sta $00,x	                sta 0,x
.9e9f		98		tya		                tya
.9ea0		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9ea2		95 01		sta $01,x	                sta 1,x
.9ea4						_done:
.9ea4		60		rts		z_dabs:         rts
.9ea5						xt_dnegate:
.9ea5		20 08 d8	jsr $d808	                jsr underflow_2 ; double number
.9ea8		a0 00		ldy #$00	     		ldy #0
.9eaa		38		sec		                sec
.9eab		98		tya		                tya
.9eac		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9eae		95 02		sta $02,x	                sta 2,x
.9eb0		98		tya		                tya
.9eb1		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9eb3		95 03		sta $03,x	                sta 3,x
.9eb5		98		tya		                tya
.9eb6		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9eb8		95 00		sta $00,x	                sta 0,x
.9eba		98		tya		                tya
.9ebb		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9ebd		95 01		sta $01,x	                sta 1,x
.9ebf		60		rts		z_dnegate:      rts
.9ec0						xt_d_dot:
.9ec0		20 08 d8	jsr $d808	                jsr underflow_2
.9ec3		20 53 95	jsr $9553	                jsr xt_tuck
.9ec6		20 86 9e	jsr $9e86	                jsr xt_dabs
.9ec9		20 87 8b	jsr $8b87	                jsr xt_less_number_sign
.9ecc		20 46 8e	jsr $8e46	                jsr xt_number_sign_s
.9ecf		20 1e 91	jsr $911e	                jsr xt_rot
.9ed2		20 f8 92	jsr $92f8	                jsr xt_sign
.9ed5		20 24 8e	jsr $8e24	                jsr xt_number_sign_greater
.9ed8		20 7f 96	jsr $967f	                jsr xt_type
.9edb		20 73 93	jsr $9373	                jsr xt_space
.9ede		60		rts		z_d_dot:        rts
.9edf						xt_d_dot_r:
.9edf		20 0d d8	jsr $d80d	                jsr underflow_3
.9ee2		20 36 95	jsr $9536	                jsr xt_to_r
.9ee5		20 53 95	jsr $9553	                jsr xt_tuck
.9ee8		20 86 9e	jsr $9e86	                jsr xt_dabs
.9eeb		20 87 8b	jsr $8b87	                jsr xt_less_number_sign
.9eee		20 46 8e	jsr $8e46	                jsr xt_number_sign_s
.9ef1		20 1e 91	jsr $911e	                jsr xt_rot
.9ef4		20 f8 92	jsr $92f8	                jsr xt_sign
.9ef7		20 24 8e	jsr $8e24	                jsr xt_number_sign_greater
.9efa		20 81 90	jsr $9081	                jsr xt_r_from
.9efd		20 98 8e	jsr $8e98	                jsr xt_over
.9f00		20 77 8d	jsr $8d77	                jsr xt_minus
.9f03		20 79 93	jsr $9379	                jsr xt_spaces
.9f06		20 7f 96	jsr $967f	                jsr xt_type
.9f09		60		rts		z_d_dot_r:      rts
.9f0a						xt_two_constant:
.9f0a		20 08 d8	jsr $d808	                jsr underflow_2
.9f0d		20 6f 85	jsr $856f	                jsr xt_create
.9f10		20 f8 93	jsr $93f8	                jsr xt_swap
.9f13		20 da 83	jsr $83da	                jsr xt_comma
.9f16		20 da 83	jsr $83da	                jsr xt_comma
.9f19		20 29 87	jsr $8729	                jsr does_runtime    ; does> turns into these two routines.
.9f1c		20 98 d6	jsr $d698	                jsr dodoes
.9f1f		20 cb 87	jsr $87cb	                jsr xt_dup
.9f22		20 90 89	jsr $8990	                jsr xt_fetch
.9f25		20 f8 93	jsr $93f8	                jsr xt_swap
.9f28		20 50 83	jsr $8350	                jsr xt_cell_plus
.9f2b		20 90 89	jsr $8990	                jsr xt_fetch
.9f2e		60		rts		z_two_constant: rts
.9f2f						xt_two_literal:
.9f2f		20 08 d8	jsr $d808	                jsr underflow_2 ; double number
.9f32		a9 0a		lda #$0a	                lda # z_template_push_tos - template_push_tos
.9f34		0a		asl a		                asl
.9f35		20 5c d6	jsr $d65c	                jsr check_nc_limit
.9f38		b0 09		bcs $9f43	                bcs _no_inline
.9f3a		20 f8 93	jsr $93f8	                jsr xt_swap
.9f3d		20 aa 8b	jsr $8baa	                jsr xt_literal
.9f40		4c aa 8b	jmp $8baa	                jmp xt_literal
.9f43						_no_inline:
.9f43		20 a2 a1	jsr $a1a2	                jsr cmpl_two_literal
.9f46		60		rts		z_two_literal:  rts
.9f47						xt_two_variable:
.9f47		20 6f 85	jsr $856f	                jsr xt_create
.9f4a		ca		dex		                dex
.9f4b		ca		dex		                dex
.9f4c		a9 04		lda #$04	                lda #4
.9f4e		95 00		sta $00,x	                sta 0,x
.9f50		74 01		stz $01,x	                stz 1,x
.9f52		20 30 82	jsr $8230	                jsr xt_allot
.9f55		60		rts		z_two_variable: rts
.9f56						xt_ud_dot:
.9f56		20 08 d8	jsr $d808	                jsr underflow_2 ; double number
.9f59		20 87 8b	jsr $8b87	                jsr xt_less_number_sign
.9f5c		20 46 8e	jsr $8e46	                jsr xt_number_sign_s
.9f5f		20 24 8e	jsr $8e24	                jsr xt_number_sign_greater
.9f62		20 7f 96	jsr $967f	                jsr xt_type
.9f65		20 73 93	jsr $9373	                jsr xt_space
.9f68		60		rts		z_ud_dot:        rts
.9f69						xt_ud_dot_r:
.9f69		20 0d d8	jsr $d80d	                jsr underflow_3
.9f6c		20 36 95	jsr $9536	                jsr xt_to_r
.9f6f		20 87 8b	jsr $8b87	                jsr xt_less_number_sign
.9f72		20 46 8e	jsr $8e46	                jsr xt_number_sign_s
.9f75		20 24 8e	jsr $8e24	                jsr xt_number_sign_greater
.9f78		20 81 90	jsr $9081	                jsr xt_r_from
.9f7b		20 98 8e	jsr $8e98	                jsr xt_over
.9f7e		20 77 8d	jsr $8d77	                jsr xt_minus
.9f81		20 79 93	jsr $9379	                jsr xt_spaces
.9f84		20 7f 96	jsr $967f	                jsr xt_type
.9f87		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.9f88						xt_cmove:
.9f88		20 0d d8	jsr $d80d	                jsr underflow_3
.9f8b		b5 02		lda $02,x	                lda 2,x
.9f8d		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9f8f		b5 03		lda $03,x	                lda 3,x
.9f91		85 28		sta $28		                sta tmp2+1
.9f93		b5 04		lda $04,x	                lda 4,x
.9f95		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9f97		b5 05		lda $05,x	                lda 5,x
.9f99		85 26		sta $26		                sta tmp1+1
.9f9b		a0 00		ldy #$00	                ldy #0
.9f9d		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.9f9f		f0 0f		beq $9fb0	                beq _dopartial
.9fa1						_page:
.9fa1		b1 25		lda ($25),y	                lda (tmp1),y
.9fa3		91 27		sta ($27),y	                sta (tmp2),y
.9fa5		c8		iny		                iny
.9fa6		d0 f9		bne $9fa1	                bne _page
.9fa8		e6 26		inc $26		                inc tmp1+1
.9faa		e6 28		inc $28		                inc tmp2+1
.9fac		d6 01		dec $01,x	                dec 1,x
.9fae		d0 f1		bne $9fa1	                bne _page
.9fb0						_dopartial:
.9fb0		b5 00		lda $00,x	                lda 0,x         ; length of last page
.9fb2		f0 09		beq $9fbd	                beq _done
.9fb4						_partial:
.9fb4		b1 25		lda ($25),y	                lda (tmp1),y
.9fb6		91 27		sta ($27),y	                sta (tmp2),y
.9fb8		c8		iny		                iny
.9fb9		d6 00		dec $00,x	                dec 0,x
.9fbb		d0 f7		bne $9fb4	                bne _partial
.9fbd						_done:
.9fbd		8a		txa		                txa
.9fbe		18		clc		                clc
.9fbf		69 06		adc #$06	                adc #6
.9fc1		aa		tax		                tax
.9fc2		60		rts		z_cmove:        rts
.9fc3						xt_cmove_up:
.9fc3		20 0d d8	jsr $d80d	                jsr underflow_3
.9fc6		b5 02		lda $02,x	                lda 2,x
.9fc8		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.9fca		b5 03		lda $03,x	                lda 3,x
.9fcc		18		clc		                clc
.9fcd		75 01		adc $01,x	                adc 1,x
.9fcf		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.9fd1		b5 04		lda $04,x	                lda 4,x
.9fd3		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.9fd5		b5 05		lda $05,x	                lda 5,x
.9fd7		18		clc		                clc
.9fd8		75 01		adc $01,x	                adc 1,x
.9fda		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.9fdc		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.9fde		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.9fe0		f0 0e		beq $9ff0	                beq _nopartial
.9fe2						_outerloop:
.9fe2		88		dey		                dey
.9fe3		f0 07		beq $9fec	                beq _finishpage
.9fe5						_innerloop:
.9fe5		b1 25		lda ($25),y	                lda (tmp1),y
.9fe7		91 27		sta ($27),y	                sta (tmp2),y
.9fe9		88		dey		                dey
.9fea		d0 f9		bne $9fe5	                bne _innerloop
.9fec						_finishpage:
.9fec		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.9fee		92 27		sta ($27)	                sta (tmp2)
.9ff0						_nopartial:
.9ff0		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.9ff2		c6 28		dec $28		                dec tmp2+1
.9ff4		d6 01		dec $01,x	                dec 1,x
.9ff6		d0 ea		bne $9fe2	                bne _outerloop
.9ff8						_done:
.9ff8		8a		txa		                txa
.9ff9		18		clc		                clc
.9ffa		69 06		adc #$06	                adc #6
.9ffc		aa		tax		                tax
.9ffd		60		rts		z_cmove_up:     rts
.9ffe						xt_compare:
.9ffe		20 12 d8	jsr $d812	                jsr underflow_4
.a001		b5 02		lda $02,x	                lda 2,x
.a003		85 27		sta $27		                sta tmp2
.a005		b5 03		lda $03,x	                lda 3,x
.a007		85 28		sta $28		                sta tmp2+1
.a009		b5 06		lda $06,x	                lda 6,x
.a00b		85 25		sta $25		                sta tmp1
.a00d		b5 07		lda $07,x	                lda 7,x
.a00f		85 26		sta $26		                sta tmp1+1
.a011						_compare_loop:
.a011		b5 04		lda $04,x	                lda 4,x
.a013		15 05		ora $05,x	                ora 5,x
.a015		f0 2c		beq $a043	                beq _str1_done
.a017		b5 00		lda $00,x	                lda 0,x
.a019		15 01		ora $01,x	                ora 1,x
.a01b		f0 3a		beq $a057	                beq _greater    ; Str2 empty first
.a01d						_check_letter:
.a01d		b2 25		lda ($25)	                lda (tmp1)
.a01f		d2 27		cmp ($27)	                cmp (tmp2)
.a021		90 26		bcc $a049	                bcc _less
.a023		d0 32		bne $a057	                bne _greater
.a025						_next_letter:
.a025		e6 25		inc $25		                inc tmp1
.a027		d0 02		bne $a02b	                bne +
.a029		e6 26		inc $26		                inc tmp1+1
.a02b						+
.a02b		e6 27		inc $27		                inc tmp2
.a02d		d0 02		bne $a031	                bne +
.a02f		e6 28		inc $28		                inc tmp2+1
.a031						+
.a031		b5 04		lda $04,x	                lda 4,x
.a033		d0 02		bne $a037	                bne +
.a035		d6 05		dec $05,x	                dec 5,x
.a037						+
.a037		d6 04		dec $04,x	                dec 4,x
.a039		b5 00		lda $00,x	                lda 0,x
.a03b		d0 02		bne $a03f	                bne +
.a03d		d6 01		dec $01,x	                dec 1,x
.a03f						+
.a03f		d6 00		dec $00,x	                dec 0,x
.a041		80 ce		bra $a011	                bra _compare_loop
.a043						_str1_done:
.a043		b5 00		lda $00,x	                lda 0,x
.a045		15 01		ora $01,x	                ora 1,x
.a047		f0 08		beq $a051	                beq _equal      ; Both out of letters
.a049						_less:
.a049		a9 ff		lda #$ff	                lda #$FF
.a04b		95 06		sta $06,x	                sta 6,x
.a04d		95 07		sta $07,x	                sta 7,x
.a04f		80 0c		bra $a05d	                bra _done
.a051						_equal:
.a051		74 06		stz $06,x	                stz 6,x
.a053		74 07		stz $07,x	                stz 7,x
.a055		80 06		bra $a05d	                bra _done
.a057						_greater:
.a057		a9 01		lda #$01	                lda #1
.a059		95 06		sta $06,x	                sta 6,x
.a05b		74 07		stz $07,x	                stz 7,x
.a05d						_done:
.a05d		8a		txa		                txa
.a05e		18		clc		                clc
.a05f		69 06		adc #$06	                adc #6
.a061		aa		tax		                tax
.a062		60		rts		z_compare:      rts
.a063						xt_minus_leading:
.a063		20 08 d8	jsr $d808	                jsr underflow_2
.a066						_loop:
.a066		b5 00		lda $00,x	                lda 0,x
.a068		15 01		ora $01,x	                ora 1,x
.a06a		f0 0f		beq $a07b	                beq _done
.a06c		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a06e		20 f6 d7	jsr $d7f6	                jsr is_whitespace
.a071		90 08		bcc $a07b	                bcc _done
.a073		20 d1 9d	jsr $9dd1	                jsr xt_one              ; ( addr u 1 )
.a076		20 58 a1	jsr $a158	                jsr xt_slash_string     ; ( addr+ u-1 )
.a079		80 eb		bra $a066	                bra _loop
.a07b						_done:
.a07b						z_minus_leading:
.a07b		60		rts		                rts
.a07c						xt_minus_trailing:
.a07c		20 08 d8	jsr $d808	                jsr underflow_2
.a07f		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a081		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a083		f0 33		beq $a0b8	                beq _done
.a085		18		clc		                clc
.a086		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a088		75 00		adc $00,x	                adc 0,x
.a08a		85 25		sta $25		                sta tmp1
.a08c		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a08e		75 01		adc $01,x	                adc 1,x
.a090		85 26		sta $26		                sta tmp1+1
.a092		a5 25		lda $25		                lda tmp1
.a094		d0 02		bne $a098	                bne +
.a096		c6 26		dec $26		                dec tmp1+1
.a098						+
.a098		c6 25		dec $25		                dec tmp1
.a09a						_loop:
.a09a		b2 25		lda ($25)	                lda (tmp1)
.a09c		c9 20		cmp #$20	                cmp #AscSP
.a09e		d0 18		bne $a0b8	                bne _done
.a0a0		a5 25		lda $25		                lda tmp1
.a0a2		d0 02		bne $a0a6	                bne +
.a0a4		c6 26		dec $26		                dec tmp1+1
.a0a6						+
.a0a6		c6 25		dec $25		                dec tmp1
.a0a8		b5 00		lda $00,x	                lda 0,x
.a0aa		d0 02		bne $a0ae	                bne +
.a0ac		d6 01		dec $01,x	                dec 1,x
.a0ae						+
.a0ae		d6 00		dec $00,x	                dec 0,x
.a0b0		b5 00		lda $00,x	                lda 0,x
.a0b2		15 01		ora $01,x	                ora 1,x
.a0b4		f0 02		beq $a0b8	                beq _done       ; Count has reached zero - we're done!
.a0b6		80 e2		bra $a09a	                bra _loop
.a0b8						_done:
.a0b8						z_minus_trailing:
.a0b8		60		rts		                rts
.a0b9						xt_search:
.a0b9		20 12 d8	jsr $d812	                jsr underflow_4
.a0bc		b5 00		lda $00,x	                lda 0,x
.a0be		15 01		ora $01,x	                ora 1,x
.a0c0		d0 0b		bne $a0cd	                bne _start_search
.a0c2		e8		inx		                inx             ; Remove u2
.a0c3		e8		inx		                inx
.a0c4		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a0c6		95 00		sta $00,x	                sta 0,x
.a0c8		95 01		sta $01,x	                sta 1,x
.a0ca		4c 57 a1	jmp $a157	                jmp z_search
.a0cd						_start_search:
.a0cd		20 37 9e	jsr $9e37	                jsr xt_zero
.a0d0						_search_loop:
.a0d0		18		clc		                clc
.a0d1		b5 00		lda $00,x	                lda 0,x
.a0d3		75 02		adc $02,x	                adc 2,x
.a0d5		85 25		sta $25		                sta tmp1
.a0d7		b5 01		lda $01,x	                lda 1,x
.a0d9		75 03		adc $03,x	                adc 3,x
.a0db		d5 07		cmp $07,x	                cmp 7,x
.a0dd		90 12		bcc $a0f1	                bcc _init_comparison ; Obviously less
.a0df		d0 06		bne $a0e7	                bne _not_found
.a0e1		b5 06		lda $06,x	                lda 6,x
.a0e3		c5 25		cmp $25		                cmp tmp1
.a0e5		b0 0a		bcs $a0f1	                bcs _init_comparison
.a0e7						_not_found:
.a0e7		e8		inx		                inx             ; Remove offset
.a0e8		e8		inx		                inx
.a0e9		e8		inx		                inx             ; Remove u2
.a0ea		e8		inx		                inx
.a0eb		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a0ed		74 01		stz $01,x	                stz 1,x
.a0ef		80 66		bra $a157	                bra z_search
.a0f1						_init_comparison:
.a0f1		18		clc		                clc
.a0f2		b5 08		lda $08,x	                lda 8,x
.a0f4		75 00		adc $00,x	                adc 0,x
.a0f6		85 25		sta $25		                sta tmp1
.a0f8		b5 09		lda $09,x	                lda 9,x
.a0fa		75 01		adc $01,x	                adc 1,x
.a0fc		85 26		sta $26		                sta tmp1+1
.a0fe		b5 04		lda $04,x	                lda 4,x
.a100		85 27		sta $27		                sta tmp2
.a102		b5 05		lda $05,x	                lda 5,x
.a104		85 28		sta $28		                sta tmp2+1
.a106		b5 02		lda $02,x	                lda 2,x
.a108		85 29		sta $29		                sta tmp3
.a10a		b5 03		lda $03,x	                lda 3,x
.a10c		85 2a		sta $2a		                sta tmp3+1
.a10e						_comparison_loop:
.a10e		b2 25		lda ($25)	                lda (tmp1)
.a110		d2 27		cmp ($27)	                cmp (tmp2)
.a112		f0 05		beq $a119	                beq _letters_match
.a114		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.a117		80 b7		bra $a0d0	                bra _search_loop
.a119						_letters_match:
.a119		e6 25		inc $25		                inc tmp1
.a11b		d0 02		bne $a11f	                bne +
.a11d		e6 26		inc $26		                inc tmp1+1
.a11f						+
.a11f		e6 27		inc $27		                inc tmp2
.a121		d0 02		bne $a125	                bne +
.a123		e6 28		inc $28		                inc tmp2+1
.a125						+
.a125		a5 29		lda $29		                lda tmp3
.a127		d0 02		bne $a12b	                bne +
.a129		c6 2a		dec $2a		                dec tmp3+1
.a12b						+
.a12b		c6 29		dec $29		                dec tmp3
.a12d		a5 29		lda $29		                lda tmp3
.a12f		05 2a		ora $2a		                ora tmp3+1
.a131		d0 db		bne $a10e	                bne _comparison_loop ; Check the next letter
.a133		18		clc		                clc
.a134		b5 00		lda $00,x	                lda 0,x
.a136		75 08		adc $08,x	                adc 8,x
.a138		95 08		sta $08,x	                sta 8,x
.a13a		b5 01		lda $01,x	                lda 1,x
.a13c		75 09		adc $09,x	                adc 9,x
.a13e		95 09		sta $09,x	                sta 9,x
.a140		38		sec		                sec
.a141		b5 06		lda $06,x	                lda 6,x
.a143		f5 00		sbc $00,x	                sbc 0,x
.a145		95 06		sta $06,x	                sta 6,x
.a147		b5 07		lda $07,x	                lda 7,x
.a149		f5 01		sbc $01,x	                sbc 1,x
.a14b		95 07		sta $07,x	                sta 7,x
.a14d		e8		inx		                inx             ; drop offset
.a14e		e8		inx		                inx
.a14f		e8		inx		                inx             ; drop u2
.a150		e8		inx		                inx
.a151		a9 ff		lda #$ff	                lda #$FF
.a153		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a155		95 01		sta $01,x	                sta 1,x
.a157		60		rts		z_search:       rts
.a158						xt_slash_string:
.a158		20 0d d8	jsr $d80d	                jsr underflow_3
.a15b		18		clc		                clc             ; 3OS+TOS
.a15c		b5 00		lda $00,x	                lda 0,x
.a15e		75 04		adc $04,x	                adc 4,x
.a160		95 04		sta $04,x	                sta 4,x
.a162		b5 01		lda $01,x	                lda 1,x
.a164		75 05		adc $05,x	                adc 5,x
.a166		95 05		sta $05,x	                sta 5,x
.a168		38		sec		                sec             ; NOS-TOS
.a169		b5 02		lda $02,x	                lda 2,x
.a16b		f5 00		sbc $00,x	                sbc 0,x
.a16d		95 02		sta $02,x	                sta 2,x
.a16f		b5 03		lda $03,x	                lda 3,x
.a171		f5 01		sbc $01,x	                sbc 1,x
.a173		95 03		sta $03,x	                sta 3,x
.a175		e8		inx		                inx
.a176		e8		inx		                inx
.a177		60		rts		z_slash_string: rts
.a178						xt_sliteral:
.a178		20 08 d8	jsr $d808	                jsr underflow_2
.a17b		20 52 d6	jsr $d652	                jsr cmpl_jump_later
.a17e		20 36 95	jsr $9536	                jsr xt_to_r
.a181		20 91 8a	jsr $8a91	                jsr xt_here
.a184		20 f8 93	jsr $93f8	                jsr xt_swap
.a187		20 cb 87	jsr $87cb	                jsr xt_dup
.a18a		20 30 82	jsr $8230	                jsr xt_allot            ; reserve u bytes for string
.a18d		20 91 8a	jsr $8a91	                jsr xt_here
.a190		20 81 90	jsr $9081	                jsr xt_r_from
.a193		20 e2 93	jsr $93e2	                jsr xt_store            ; point jmp past string
.a196		20 75 95	jsr $9575	                jsr xt_two_dup
.a199		20 5f 96	jsr $965f	                jsr xt_two_to_r
.a19c		20 93 8d	jsr $8d93	                jsr xt_move             ; copy u bytes from addr -> addr'
.a19f		20 e5 95	jsr $95e5	                jsr xt_two_r_from
.a1a2						cmpl_sliteral:
.a1a2						cmpl_two_literal:
.a1a2		a0 a1		ldy #$a1	                ldy #>sliteral_runtime
.a1a4		a9 bc		lda #$bc	                lda #<sliteral_runtime
.a1a6		20 39 d6	jsr $d639	                jsr cmpl_subroutine
.a1a9		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a1ab		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a1ad		20 45 d6	jsr $d645	                jsr cmpl_word
.a1b0		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a1b2		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a1b4		20 45 d6	jsr $d645	                jsr cmpl_word
.a1b7		e8		inx		                inx
.a1b8		e8		inx		                inx
.a1b9		e8		inx		                inx
.a1ba		e8		inx		                inx
.a1bb		60		rts		z_sliteral:     rts
.a1bc						two_literal_runtime:
.a1bc						sliteral_runtime:
.a1bc		ca		dex		                dex
.a1bd		ca		dex		                dex
.a1be		ca		dex		                dex
.a1bf		ca		dex		                dex
.a1c0		68		pla		                pla
.a1c1		85 25		sta $25		                sta tmp1        ; LSB of address
.a1c3		7a		ply		                ply
.a1c4		84 26		sty $26		                sty tmp1+1      ; MSB of address
.a1c6		18		clc		                clc
.a1c7		69 04		adc #$04	                adc #4
.a1c9		90 01		bcc $a1cc	                bcc +
.a1cb		c8		iny		                iny
.a1cc						+
.a1cc		5a		phy		                phy
.a1cd		48		pha		                pha
.a1ce		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a1d0		b1 25		lda ($25),y	                lda (tmp1),y
.a1d2		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a1d4		c8		iny		                iny
.a1d5		b1 25		lda ($25),y	                lda (tmp1),y
.a1d7		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a1d9		c8		iny		                iny
.a1da		b1 25		lda ($25),y	                lda (tmp1),y
.a1dc		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a1de		c8		iny		                iny
.a1df		b1 25		lda ($25),y	                lda (tmp1),y
.a1e1		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a1e3		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a1e4						xt_disasm:
.a1e4		20 08 d8	jsr $d808	                jsr underflow_2
.a1e7		20 eb a1	jsr $a1eb	                jsr disassembler
.a1ea		60		rts		z_disasm:       rts
.a1eb						disassembler:
.a1eb		20 69 85	jsr $8569	                jsr xt_cr       ; ( addr u )
.a1ee						_byte_loop:
.a1ee		20 98 8e	jsr $8e98	                jsr xt_over     ; ( addr u addr )
.a1f1		20 aa 96	jsr $96aa	                jsr xt_u_dot    ; ( addr u )
.a1f4		20 73 93	jsr $9373	                jsr xt_space
.a1f7		a9 0f		lda #$0f	                lda #<oc_index_table
.a1f9		85 27		sta $27		                sta tmp2
.a1fb		a9 b4		lda #$b4	                lda #>oc_index_table
.a1fd		85 28		sta $28		                sta tmp2+1
.a1ff		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a201		85 2d		sta $2d		                sta scratch     ; Save opcode
.a203		0a		asl a		                asl             ; multiply by two for offset
.a204		90 02		bcc $a208	                bcc +
.a206		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a208						+
.a208		a8		tay		                tay             ; use Y as the index
.a209		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a20b		85 29		sta $29		                sta tmp3
.a20d		48		pha		                pha
.a20e		c8		iny		                iny
.a20f		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a211		85 2a		sta $2a		                sta tmp3+1
.a213		48		pha		                pha
.a214		b2 29		lda ($29)	                lda (tmp3)
.a216		a8		tay		                tay                     ; save copy of lengths byte
.a217		10 3c		bpl $a255	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a219		20 37 9e	jsr $9e37	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.a21c		f6 04		inc $04,x	                inc 4,x
.a21e		d0 02		bne $a222	                bne +
.a220		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.a222						+
.a222		b5 02		lda $02,x	                lda 2,x
.a224		d0 02		bne $a228	                bne +
.a226		d6 03		dec $03,x	                dec 3,x
.a228						+
.a228		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.a22a		a1 04		lda ($04,x)	                lda (4,x)
.a22c		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a22e		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a230		98		tya		                tya                     ; retrieve copy of lengths byte
.a231		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a232		10 14		bpl $a248	                bpl _print_operand
.a234		f6 04		inc $04,x	                inc 4,x
.a236		d0 02		bne $a23a	                bne +
.a238		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.a23a						+
.a23a		b5 02		lda $02,x	                lda 2,x
.a23c		d0 02		bne $a240	                bne +
.a23e		d6 03		dec $03,x	                dec 3,x
.a240						+
.a240		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.a242		a1 04		lda ($04,x)	                lda (4,x)
.a244		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a246		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a248						_print_operand:
.a248		ca		dex		                dex
.a249		ca		dex		                dex
.a24a		a9 05		lda #$05	                lda #5
.a24c		95 00		sta $00,x	                sta 0,x
.a24e		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.a250		20 b6 96	jsr $96b6	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.a253		80 0b		bra $a260	                bra _print_mnemonic
.a255						_no_operand:
.a255		ca		dex		                dex
.a256		ca		dex		                dex
.a257		a9 05		lda #$05	                lda #5
.a259		95 00		sta $00,x	                sta 0,x
.a25b		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.a25d		20 79 93	jsr $9379	                jsr xt_spaces           ; ( addr u )
.a260						_print_mnemonic:
.a260		20 73 93	jsr $9373	                jsr xt_space
.a263		ca		dex		                dex
.a264		ca		dex		                dex                     ; ( addr u ? )
.a265		68		pla		                pla                     ; MSB
.a266		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a268		68		pla		                pla                     ; LSB
.a269		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a26b		20 55 85	jsr $8555	                jsr xt_count            ; ( addr u addr-o u-o )
.a26e		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a270		b5 00		lda $00,x	                lda 0,x
.a272		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a274		95 00		sta $00,x	                sta 0,x
.a276		20 7f 96	jsr $967f	                jsr xt_type             ; ( addr u )
.a279		a5 2d		lda $2d		                lda scratch
.a27b		c9 20		cmp #$20	                cmp #OpJSR
.a27d		d0 4e		bne $a2cd	                bne _not_jsr
.a27f		ca		dex		                dex
.a280		ca		dex		                dex
.a281		a9 05		lda #$05	                lda #5
.a283		95 00		sta $00,x	                sta 0,x
.a285		74 01		stz $01,x	                stz 1,x
.a287		20 79 93	jsr $9379	                jsr xt_spaces
.a28a		a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.a28c		b9 b9 a2	lda $a2b9,y	_check_handler: lda _special_handlers,y
.a28f		c5 2e		cmp $2e		                cmp scratch+1
.a291		d0 07		bne $a29a	                bne _next_handler
.a293		b9 ba a2	lda $a2ba,y	                lda _special_handlers+1,y
.a296		c5 2f		cmp $2f		                cmp scratch+2
.a298		f0 0c		beq $a2a6	                beq _run_handler
.a29a		88		dey		_next_handler:  dey
.a29b		88		dey		                dey
.a29c		88		dey		                dey
.a29d		88		dey		                dey
.a29e		10 ec		bpl $a28c	                bpl _check_handler
.a2a0						_not_special:
.a2a0		20 f0 a3	jsr $a3f0	                jsr disasm_jsr
.a2a3		4c 37 a3	jmp $a337	                jmp _printing_done
.a2a6						_run_handler:
.a2a6		b9 bb a2	lda $a2bb,y	                lda _special_handlers+2,y
.a2a9		85 30		sta $30		                sta scratch+3
.a2ab		b9 bc a2	lda $a2bc,y	                lda _special_handlers+3,y
.a2ae		85 31		sta $31		                sta scratch+4
.a2b0		20 b6 a2	jsr $a2b6	                jsr _dispatch_handler
.a2b3		4c 37 a3	jmp $a337	                jmp _printing_done
.a2b6						_dispatch_handler:
.a2b6		6c 30 00	jmp ($0030)	                jmp (scratch+3)
.a2b9						_special_handlers:
>a2b9		f2 8b d2 a3			    .word literal_runtime,      disasm_literal
>a2bd		bc a1 7d a3			    .word sliteral_runtime,     disasm_sliteral
>a2c1		e5 8a b4 a3			    .word zero_branch_runtime,  disasm_0branch
>a2c5		db 8a c0 a3			    .word zero_test_runtime,    disasm_0test
>a2c9		e7 86 c8 a3			    .word do_runtime,           disasm_do
.a2cd						_end_handlers:
.a2cd						_not_jsr:
.a2cd		c9 4c		cmp #$4c	                cmp #OpJMP
.a2cf		d0 2c		bne $a2fd	                bne _not_jmp
.a2d1		a5 2e		lda $2e		                lda scratch+1   ; Copy the pointer.
.a2d3		85 30		sta $30		                sta scratch+3
.a2d5		a5 2f		lda $2f		                lda scratch+2
.a2d7		85 31		sta $31		                sta scratch+4
.a2d9		b2 30		lda ($30)	                lda (scratch+3)
.a2db		c9 20		cmp #$20	                cmp #OpJSR ; check for JSR
.a2dd		d0 58		bne $a337	                bne _printing_done
.a2df		e6 30		inc $30		                inc scratch+3
.a2e1		d0 02		bne $a2e5	                bne +
.a2e3		e6 31		inc $31		                inc scratch+4
.a2e5						+
.a2e5		b2 30		lda ($30)	                lda (scratch+3)
.a2e7		c9 bc		cmp #$bc	                cmp #<sliteral_runtime
.a2e9		d0 4c		bne $a337	                bne _printing_done
.a2eb		e6 30		inc $30		                inc scratch+3
.a2ed		d0 02		bne $a2f1	                bne +
.a2ef		e6 31		inc $31		                inc scratch+4
.a2f1						+
.a2f1		b2 30		lda ($30)	                lda (scratch+3)
.a2f3		c9 a1		cmp #$a1	                cmp #>sliteral_runtime
.a2f5		d0 40		bne $a337	                bne _printing_done
.a2f7		20 53 a3	jsr $a353	                jsr disasm_sliteral_jump
.a2fa		4c 37 a3	jmp $a337	                jmp _printing_done
.a2fd						_not_jmp:
.a2fd		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a2ff		f0 06		beq $a307	                beq _is_rel
.a301		29 1f		and #$1f	                and #$1F
.a303		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a305		d0 30		bne $a337	                bne _printing_done
.a307						_is_rel:
.a307		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a309		ca		dex		                dex
.a30a		ca		dex		                dex
.a30b		74 01		stz $01,x	                stz 1,x
.a30d		a5 2e		lda $2e		                lda scratch+1
.a30f		95 00		sta $00,x	                sta 0,x
.a311		10 04		bpl $a317	                bpl +
.a313		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a315		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a317		38		sec		+               sec                 ; start counting from address after opcode
.a318		75 04		adc $04,x	                adc 4,x
.a31a		95 00		sta $00,x	                sta 0,x
.a31c		b5 01		lda $01,x	                lda 1,x
.a31e		75 05		adc $05,x	                adc 5,x
.a320		95 01		sta $01,x	                sta 1,x
.a322		5a		phy		                phy                 ; save the direction indicator
.a323		ca		dex		                dex
.a324		ca		dex		                dex
.a325		a9 09		lda #$09	                lda #9
.a327		95 00		sta $00,x	                sta 0,x
.a329		74 01		stz $01,x	                stz 1,x
.a32b		20 b6 96	jsr $96b6	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.a32e		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.a330		20 3b 88	jsr $883b	                jsr emit_a
.a333		68		pla		                pla
.a334		20 3b 88	jsr $883b	                jsr emit_a
.a337						_printing_done:
.a337		20 69 85	jsr $8569	                jsr xt_cr
.a33a		f6 02		inc $02,x	                inc 2,x
.a33c		d0 02		bne $a340	                bne +
.a33e		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.a340						+
.a340		20 70 8e	jsr $8e70	                jsr xt_one_minus        ; ( addr+1 u-1 )
.a343		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a345		15 01		ora $01,x	                ora 1,x
.a347		f0 07		beq $a350	                beq _done
.a349		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a34b		30 03		bmi $a350	                bmi _done
.a34d		4c ee a1	jmp $a1ee	                jmp _byte_loop          ; out of range for BRA
.a350						_done:
.a350		4c 6d 95	jmp $956d	                jmp xt_two_drop         ; JSR/RTS
.a353						disasm_sliteral_jump:
.a353		20 f8 93	jsr $93f8	                jsr xt_swap
.a356		ca		dex		                dex
.a357		ca		dex		                dex
.a358		a5 2e		lda $2e		                lda scratch+1
.a35a		95 00		sta $00,x	                sta 0,x
.a35c		a5 2f		lda $2f		                lda scratch+2
.a35e		95 01		sta $01,x	                sta 1,x
.a360		20 f8 93	jsr $93f8	                jsr xt_swap
.a363		20 77 8d	jsr $8d77	                jsr xt_minus
.a366		20 70 8e	jsr $8e70	                jsr xt_one_minus
.a369		20 77 8d	jsr $8d77	                jsr xt_minus
.a36c		ca		dex		                dex
.a36d		ca		dex		                dex
.a36e		a5 2e		lda $2e		                lda scratch+1
.a370		95 00		sta $00,x	                sta 0,x
.a372		a5 2f		lda $2f		                lda scratch+2
.a374		95 01		sta $01,x	                sta 1,x
.a376		20 70 8e	jsr $8e70	                jsr xt_one_minus
.a379		20 f8 93	jsr $93f8	                jsr xt_swap ; ( new_addr new_n )
.a37c		60		rts		                rts
.a37d						disasm_sliteral:
.a37d		a9 53		lda #$53	                lda #'S'
.a37f		20 3b 88	jsr $883b	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.a382		a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.a384		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.a387		20 f8 93	jsr $93f8	                jsr xt_swap             ; switch to (u addr)
.a38a		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.a38d		20 cb 87	jsr $87cb	                jsr xt_dup
.a390		20 90 89	jsr $8990	                jsr xt_fetch
.a393		20 aa 96	jsr $96aa	                jsr xt_u_dot            ; Print the address of the string
.a396		20 02 9e	jsr $9e02	                jsr xt_two
.a399		20 e6 8f	jsr $8fe6	                jsr xt_plus
.a39c		20 cb 87	jsr $87cb	                jsr xt_dup
.a39f		20 62 99	jsr $9962	                jsr xt_question         ; Print the length of the string
.a3a2		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.a3a5		20 f8 93	jsr $93f8	                jsr xt_swap            ; ( addr+4 u )
.a3a8		ca		dex		                dex
.a3a9		ca		dex		                dex
.a3aa		a9 04		lda #$04	                lda #4
.a3ac		95 00		sta $00,x	                sta 0,x
.a3ae		74 01		stz $01,x	                stz 1,x
.a3b0		20 77 8d	jsr $8d77	                jsr xt_minus            ; ( addr+4 u-4 )
.a3b3		60		rts		                rts
.a3b4						disasm_0branch:
.a3b4		a9 30		lda #$30	                lda #'0'
.a3b6		20 3b 88	jsr $883b	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.a3b9						disasm_branch:
.a3b9		a9 0e		lda #$0e	                lda #str_disasm_bra
.a3bb		20 3f d8	jsr $d83f	                jsr print_string_no_lf ; "BRANCH "
.a3be		80 17		bra $a3d7	                bra disasm_print_literal
.a3c0						disasm_0test:
.a3c0		a9 0f		lda #$0f	                lda #str_disasm_0test
.a3c2		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.a3c5		4c 3b 88	jmp $883b	                jmp emit_a
.a3c8						disasm_do:
.a3c8		a9 44		lda #$44	                lda #'D'
.a3ca		20 3b 88	jsr $883b	                jsr emit_a
.a3cd		a9 4f		lda #$4f	                lda #'O'
.a3cf		4c 3b 88	jmp $883b	                jmp emit_a
.a3d2						disasm_literal:
.a3d2		a9 0c		lda #$0c	                lda #str_disasm_lit
.a3d4		20 3f d8	jsr $d83f	                jsr print_string_no_lf ; "LITERAL "
.a3d7						disasm_print_literal:
.a3d7		20 f8 93	jsr $93f8	                jsr xt_swap ; switch to (u addr)
.a3da		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.a3dd		20 cb 87	jsr $87cb	                jsr xt_dup
.a3e0		20 62 99	jsr $9962	                jsr xt_question ; Print the value at the address
.a3e3		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.a3e6		20 f8 93	jsr $93f8	                jsr xt_swap ; (addr+2 u)
.a3e9		20 70 8e	jsr $8e70	                jsr xt_one_minus
.a3ec		20 70 8e	jsr $8e70	                jsr xt_one_minus ; (addr+2 u-2)
.a3ef		60		rts		                rts
.a3f0						disasm_jsr:
.a3f0		ca		dex		                dex
.a3f1		ca		dex		                dex
.a3f2		a5 2e		lda $2e		                lda scratch+1
.a3f4		95 00		sta $00,x	                sta 0,x
.a3f6		a5 2f		lda $2f		                lda scratch+2
.a3f8		95 01		sta $01,x	                sta 1,x
.a3fa		20 ee 9b	jsr $9bee	                jsr xt_int_to_name
.a3fd		b5 00		lda $00,x	                lda 0,x
.a3ff		15 01		ora $01,x	                ora 1,x
.a401		f0 07		beq $a40a	                beq _disasm_no_nt
.a403		20 91 9c	jsr $9c91	                jsr xt_name_to_string
.a406		20 7f 96	jsr $967f	                jsr xt_type
.a409		60		rts		                rts
.a40a						_disasm_no_nt:
.a40a		20 c5 87	jsr $87c5	                jsr xt_drop ; the 0 indicating no name token
.a40d		ca		dex		                dex
.a40e		ca		dex		                dex
.a40f		a5 2e		lda $2e		                lda scratch+1
.a411		95 00		sta $00,x	                sta 0,x
.a413		a5 2f		lda $2f		                lda scratch+2
.a415		95 01		sta $01,x	                sta 1,x
.a417		ca		dex		                dex
.a418		ca		dex		                dex
.a419		a9 03		lda #$03	                lda #<underflow_1
.a41b		95 00		sta $00,x	                sta 0,x
.a41d		a9 d8		lda #$d8	                lda #>underflow_1
.a41f		95 01		sta $01,x	                sta 1,x
.a421		20 41 d7	jsr $d741	                jsr compare_16bit
.a424		f0 02		beq $a428	                beq _disasm_jsr_uflow_check_upper
.a426		b0 14		bcs $a43c	                bcs _disasm_jsr_unknown
.a428						_disasm_jsr_uflow_check_upper:
.a428		a9 12		lda #$12	                lda #<underflow_4
.a42a		95 00		sta $00,x	                sta 0,x
.a42c		a9 d8		lda #$d8	                lda #>underflow_4
.a42e		95 01		sta $01,x	                sta 1,x
.a430		20 41 d7	jsr $d741	                jsr compare_16bit
.a433		f0 02		beq $a437	                beq _disasm_jsr_soc
.a435		90 05		bcc $a43c	                bcc _disasm_jsr_unknown
.a437						_disasm_jsr_soc:
.a437		a9 0d		lda #$0d	                lda #str_disasm_sdc
.a439		20 3f d8	jsr $d83f	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.a43c						_disasm_jsr_unknown:
.a43c		20 6d 95	jsr $956d	                jsr xt_two_drop
.a43f		60		rts		                rts
.a440						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a440						assembler:
.a440						xt_asm_adc_h:
.a440		a9 69		lda #$69	                lda #$69
.a442		4c 9b a7	jmp $a79b	                jmp asm_common
.a445						z_asm_adc_h:
.a445						xt_asm_adc_x:
.a445		a9 7d		lda #$7d	                lda #$7D
.a447		4c 9b a7	jmp $a79b	                jmp asm_common
.a44a						z_asm_adc_x:
.a44a						xt_asm_adc_y:
.a44a		a9 79		lda #$79	                lda #$79
.a44c		4c 9b a7	jmp $a79b	                jmp asm_common
.a44f						z_asm_adc_y:
.a44f						xt_asm_adc_z:
.a44f		a9 65		lda #$65	                lda #$65
.a451		4c 9b a7	jmp $a79b	                jmp asm_common
.a454						z_asm_adc_z:
.a454						xt_asm_adc_zi:
.a454		a9 72		lda #$72	                lda #$72
.a456		4c 9b a7	jmp $a79b	                jmp asm_common
.a459						z_asm_adc_zi:
.a459						xt_asm_adc_ziy:
.a459		a9 71		lda #$71	                lda #$71
.a45b		4c 9b a7	jmp $a79b	                jmp asm_common
.a45e						z_asm_adc_ziy:
.a45e						xt_asm_adc_zx:
.a45e		a9 75		lda #$75	                lda #$75
.a460		4c 9b a7	jmp $a79b	                jmp asm_common
.a463						z_asm_adc_zx:
.a463						xt_asm_adc_zxi:
.a463		a9 61		lda #$61	                lda #$61
.a465		4c 9b a7	jmp $a79b	                jmp asm_common
.a468						z_asm_adc_zxi:
.a468						xt_asm_and:
.a468		a9 2d		lda #$2d	                lda #$2D
.a46a		4c 9b a7	jmp $a79b	                jmp asm_common
.a46d						z_asm_and:
.a46d						xt_asm_and_h:
.a46d		a9 29		lda #$29	                lda #$29
.a46f		4c 9b a7	jmp $a79b	                jmp asm_common
.a472						z_asm_and_h:
.a472						xt_asm_and_x:
.a472		a9 3d		lda #$3d	                lda #$3D
.a474		4c 9b a7	jmp $a79b	                jmp asm_common
.a477						z_asm_and_x:
.a477						xt_asm_and_y:
.a477		a9 39		lda #$39	                lda #$39
.a479		4c 9b a7	jmp $a79b	                jmp asm_common
.a47c						z_asm_and_y:
.a47c						xt_asm_and_z:
.a47c		a9 25		lda #$25	                lda #$25
.a47e		4c 9b a7	jmp $a79b	                jmp asm_common
.a481						z_asm_and_z:
.a481						xt_asm_and_zi:
.a481		a9 32		lda #$32	                lda #$32
.a483		4c 9b a7	jmp $a79b	                jmp asm_common
.a486						z_asm_and_zi:
.a486						xt_asm_and_ziy:
.a486		a9 31		lda #$31	                lda #$31
.a488		4c 9b a7	jmp $a79b	                jmp asm_common
.a48b						z_asm_and_ziy:
.a48b						xt_asm_and_zx:
.a48b		a9 35		lda #$35	                lda #$35
.a48d		4c 9b a7	jmp $a79b	                jmp asm_common
.a490						z_asm_and_zx:
.a490						xt_asm_and_zxi:
.a490		a9 21		lda #$21	                lda #$21
.a492		4c 9b a7	jmp $a79b	                jmp asm_common
.a495						z_asm_and_zxi:
.a495						xt_asm_asl:
.a495		a9 0e		lda #$0e	                lda #$0E
.a497		4c 9b a7	jmp $a79b	                jmp asm_common
.a49a						z_asm_asl:
.a49a						xt_asm_asl_a:
.a49a		a9 0a		lda #$0a	                lda #$0A
.a49c		4c 9b a7	jmp $a79b	                jmp asm_common
.a49f						z_asm_asl_a:
.a49f						xt_asm_asl_x:
.a49f		a9 1e		lda #$1e	                lda #$1E
.a4a1		4c 9b a7	jmp $a79b	                jmp asm_common
.a4a4						z_asm_asl_x:
.a4a4						xt_asm_asl_z:
.a4a4		a9 06		lda #$06	                lda #$06
.a4a6		4c 9b a7	jmp $a79b	                jmp asm_common
.a4a9						z_asm_asl_z:
.a4a9						xt_asm_asl_zx:
.a4a9		a9 16		lda #$16	                lda #$16
.a4ab		4c 9b a7	jmp $a79b	                jmp asm_common
.a4ae						z_asm_asl_zx:
.a4ae						xt_asm_bcc:
.a4ae		a9 90		lda #$90	                lda #$90
.a4b0		4c 9b a7	jmp $a79b	                jmp asm_common
.a4b3						z_asm_bcc:
.a4b3						xt_asm_bcs:
.a4b3		a9 b0		lda #$b0	                lda #$B0
.a4b5		a0 02		ldy #$02	                ldy #2
.a4b7		4c 9b a7	jmp $a79b	                jmp asm_common
.a4ba						z_asm_bcs:
.a4ba						xt_asm_beq:
.a4ba		a9 f0		lda #$f0	                lda #$F0
.a4bc		4c 9b a7	jmp $a79b	                jmp asm_common
.a4bf						z_asm_beq:
.a4bf						xt_asm_bit:
.a4bf		a9 2c		lda #$2c	                lda #$2C
.a4c1		4c 9b a7	jmp $a79b	                jmp asm_common
.a4c4						z_asm_bit:
.a4c4						xt_asm_bit_h:
.a4c4		a9 89		lda #$89	                lda #$89
.a4c6		4c 9b a7	jmp $a79b	                jmp asm_common
.a4c9						z_asm_bit_h:
.a4c9						xt_asm_bit_x:
.a4c9		a9 3c		lda #$3c	                lda #$3C
.a4cb		4c 9b a7	jmp $a79b	                jmp asm_common
.a4ce						z_asm_bit_x:
.a4ce						xt_asm_bit_z:
.a4ce		a9 24		lda #$24	                lda #$24
.a4d0		4c 9b a7	jmp $a79b	                jmp asm_common
.a4d3						z_asm_bit_z:
.a4d3						xt_asm_bit_zx:
.a4d3		a9 34		lda #$34	                lda #$34
.a4d5		4c 9b a7	jmp $a79b	                jmp asm_common
.a4d8						z_asm_bit_zx:
.a4d8						xt_asm_bmi:
.a4d8		a9 30		lda #$30	                lda #$30
.a4da		4c 9b a7	jmp $a79b	                jmp asm_common
.a4dd						z_asm_bmi:
.a4dd						xt_asm_bne:
.a4dd		a9 d0		lda #$d0	                lda #$D0
.a4df		4c 9b a7	jmp $a79b	                jmp asm_common
.a4e2						z_asm_bne:
.a4e2						xt_asm_bpl:
.a4e2		a9 10		lda #$10	                lda #$10
.a4e4		4c 9b a7	jmp $a79b	                jmp asm_common
.a4e7						z_asm_bpl:
.a4e7						xt_asm_bra:
.a4e7		a9 80		lda #$80	                lda #$80
.a4e9		4c 9b a7	jmp $a79b	                jmp asm_common
.a4ec						z_asm_bra:
.a4ec						xt_asm_brk:
.a4ec		a9 00		lda #$00	                lda #$00
.a4ee		4c 9b a7	jmp $a79b	                jmp asm_common
.a4f1						z_asm_brk:
.a4f1						xt_asm_bvc:
.a4f1		a9 50		lda #$50	                lda #$50
.a4f3		4c 9b a7	jmp $a79b	                jmp asm_common
.a4f6						z_asm_bvc:
.a4f6						xt_asm_bvs:
.a4f6		a9 70		lda #$70	                lda #$70
.a4f8		4c 9b a7	jmp $a79b	                jmp asm_common
.a4fb						z_asm_bvs:
.a4fb						xt_asm_clc:
.a4fb		a9 18		lda #$18	                lda #$18
.a4fd		4c 9b a7	jmp $a79b	                jmp asm_common
.a500						z_asm_clc:
.a500						xt_asm_cld:
.a500		a9 d8		lda #$d8	                lda #$D8
.a502		4c 9b a7	jmp $a79b	                jmp asm_common
.a505						z_asm_cld:
.a505						xt_asm_cli:
.a505		a9 58		lda #$58	                lda #$58
.a507		4c 9b a7	jmp $a79b	                jmp asm_common
.a50a						z_asm_cli:
.a50a						xt_asm_clv:
.a50a		a9 b8		lda #$b8	                lda #$B8
.a50c		4c 9b a7	jmp $a79b	                jmp asm_common
.a50f						z_asm_clv:
.a50f						xt_asm_cmp:
.a50f		a9 cd		lda #$cd	                lda #$CD
.a511		4c 9b a7	jmp $a79b	                jmp asm_common
.a514						z_asm_cmp:
.a514						xt_asm_cmp_h:
.a514		a9 c9		lda #$c9	                lda #$C9
.a516		4c 9b a7	jmp $a79b	                jmp asm_common
.a519						z_asm_cmp_h:
.a519						xt_asm_cmp_x:
.a519		a9 dd		lda #$dd	                lda #$DD
.a51b		4c 9b a7	jmp $a79b	                jmp asm_common
.a51e						z_asm_cmp_x:
.a51e						xt_asm_cmp_y:
.a51e		a9 d9		lda #$d9	                lda #$D9
.a520		4c 9b a7	jmp $a79b	                jmp asm_common
.a523						z_asm_cmp_y:
.a523						xt_asm_cmp_z:
.a523		a9 c5		lda #$c5	                lda #$C5
.a525		4c 9b a7	jmp $a79b	                jmp asm_common
.a528						z_asm_cmp_z:
.a528						xt_asm_cmp_zi:
.a528		a9 d2		lda #$d2	                lda #$D2
.a52a		4c 9b a7	jmp $a79b	                jmp asm_common
.a52d						z_asm_cmp_zi:
.a52d						xt_asm_cmp_ziy:
.a52d		a9 d1		lda #$d1	                lda #$D1
.a52f		4c 9b a7	jmp $a79b	                jmp asm_common
.a532						z_asm_cmp_ziy:
.a532						xt_asm_cmp_zx:
.a532		a9 d5		lda #$d5	                lda #$D5
.a534		4c 9b a7	jmp $a79b	                jmp asm_common
.a537						z_asm_cmp_zx:
.a537						xt_asm_cmp_zxi:
.a537		a9 c1		lda #$c1	                lda #$C1
.a539		4c 9b a7	jmp $a79b	                jmp asm_common
.a53c						z_asm_cmp_zxi:
.a53c						xt_asm_cpx:
.a53c		a9 ec		lda #$ec	                lda #$EC
.a53e		4c 9b a7	jmp $a79b	                jmp asm_common
.a541						z_asm_cpx:
.a541						xt_asm_cpx_h:
.a541		a9 e0		lda #$e0	                lda #$E0
.a543		4c 9b a7	jmp $a79b	                jmp asm_common
.a546						z_asm_cpx_h:
.a546						xt_asm_cpx_z:
.a546		a9 e4		lda #$e4	                lda #$E4
.a548		4c 9b a7	jmp $a79b	                jmp asm_common
.a54b						z_asm_cpx_z:
.a54b						xt_asm_cpy:
.a54b		a9 cc		lda #$cc	                lda #$CC
.a54d		a0 03		ldy #$03	                ldy #3
.a54f		4c 9b a7	jmp $a79b	                jmp asm_common
.a552						z_asm_cpy:
.a552						xt_asm_cpy_h:
.a552		a9 c0		lda #$c0	                lda #$C0
.a554		4c 9b a7	jmp $a79b	                jmp asm_common
.a557						z_asm_cpy_h:
.a557						xt_asm_cpy_z:
.a557		a9 c4		lda #$c4	                lda #$C4
.a559		4c 9b a7	jmp $a79b	                jmp asm_common
.a55c						z_asm_cpy_z:
.a55c						xt_asm_dec:
.a55c		a9 ce		lda #$ce	                lda #$CE
.a55e		4c 9b a7	jmp $a79b	                jmp asm_common
.a561						z_asm_dec:
.a561						xt_asm_dec_a:
.a561		a9 3a		lda #$3a	                lda #$3A
.a563		4c 9b a7	jmp $a79b	                jmp asm_common
.a566						z_asm_dec_a:
.a566						xt_asm_dec_x:
.a566		a9 de		lda #$de	                lda #$DE
.a568		4c 9b a7	jmp $a79b	                jmp asm_common
.a56b						z_asm_dec_x:
.a56b						xt_asm_dec_z:
.a56b		a9 c6		lda #$c6	                lda #$C6
.a56d		4c 9b a7	jmp $a79b	                jmp asm_common
.a570						z_asm_dec_z:
.a570						xt_asm_dec_zx:
.a570		a9 d6		lda #$d6	                lda #$D6
.a572		4c 9b a7	jmp $a79b	                jmp asm_common
.a575						z_asm_dec_zx:
.a575						xt_asm_dex:
.a575		a9 ca		lda #$ca	                lda #$CA
.a577		4c 9b a7	jmp $a79b	                jmp asm_common
.a57a						z_asm_dex:
.a57a						xt_asm_dey:
.a57a		a9 88		lda #$88	                lda #$88
.a57c		4c 9b a7	jmp $a79b	                jmp asm_common
.a57f						z_asm_dey:
.a57f						xt_asm_eor:
.a57f		a9 4d		lda #$4d	                lda #$4D
.a581		4c 9b a7	jmp $a79b	                jmp asm_common
.a584						z_asm_eor:
.a584						xt_asm_eor_h:
.a584		a9 49		lda #$49	                lda #$49
.a586		4c 9b a7	jmp $a79b	                jmp asm_common
.a589						z_asm_eor_h:
.a589						xt_asm_eor_x:
.a589		a9 5d		lda #$5d	                lda #$5D
.a58b		4c 9b a7	jmp $a79b	                jmp asm_common
.a58e						z_asm_eor_x:
.a58e						xt_asm_eor_y:
.a58e		a9 59		lda #$59	                lda #$59
.a590		4c 9b a7	jmp $a79b	                jmp asm_common
.a593						z_asm_eor_y:
.a593						xt_asm_eor_z:
.a593		a9 45		lda #$45	                lda #$45
.a595		4c 9b a7	jmp $a79b	                jmp asm_common
.a598						z_asm_eor_z:
.a598						xt_asm_eor_zi:
.a598		a9 52		lda #$52	                lda #$52
.a59a		4c 9b a7	jmp $a79b	                jmp asm_common
.a59d						z_asm_eor_zi:
.a59d						xt_asm_eor_ziy:
.a59d		a9 51		lda #$51	                lda #$51
.a59f		4c 9b a7	jmp $a79b	                jmp asm_common
.a5a2						z_asm_eor_ziy:
.a5a2						xt_asm_eor_zx:
.a5a2		a9 55		lda #$55	                lda #$55
.a5a4		4c 9b a7	jmp $a79b	                jmp asm_common
.a5a7						z_asm_eor_zx:
.a5a7						xt_asm_eor_zxi:
.a5a7		a9 41		lda #$41	                lda #$41
.a5a9		4c 9b a7	jmp $a79b	                jmp asm_common
.a5ac						z_asm_eor_zxi:
.a5ac						xt_asm_inc:
.a5ac		a9 ee		lda #$ee	                lda #$EE
.a5ae		4c 9b a7	jmp $a79b	                jmp asm_common
.a5b1						z_asm_inc:
.a5b1						xt_asm_inc_a:
.a5b1		a9 1a		lda #$1a	                lda #$1A
.a5b3		4c 9b a7	jmp $a79b	                jmp asm_common
.a5b6						z_asm_inc_a:
.a5b6						xt_asm_inc_x:
.a5b6		a9 fe		lda #$fe	                lda #$FE
.a5b8		4c 9b a7	jmp $a79b	                jmp asm_common
.a5bb						z_asm_inc_x:
.a5bb						xt_asm_inc_z:
.a5bb		a9 e6		lda #$e6	                lda #$E6
.a5bd		4c 9b a7	jmp $a79b	                jmp asm_common
.a5c0						z_asm_inc_z:
.a5c0						xt_asm_inc_zx:
.a5c0		a9 f6		lda #$f6	                lda #$F6
.a5c2		4c 9b a7	jmp $a79b	                jmp asm_common
.a5c5						z_asm_inc_zx:
.a5c5						xt_asm_inx:
.a5c5		a9 e8		lda #$e8	                lda #$E8
.a5c7		4c 9b a7	jmp $a79b	                jmp asm_common
.a5ca						z_asm_inx:
.a5ca						xt_asm_iny:
.a5ca		a9 c8		lda #$c8	                lda #$C8
.a5cc		4c 9b a7	jmp $a79b	                jmp asm_common
.a5cf						z_asm_iny:
.a5cf						xt_asm_jmp:
.a5cf		a9 4c		lda #$4c	                lda #$4C
.a5d1		4c 9b a7	jmp $a79b	                jmp asm_common
.a5d4						z_asm_jmp:
.a5d4						xt_asm_jmp_i:
.a5d4		a9 6c		lda #$6c	                lda #$6C
.a5d6		4c 9b a7	jmp $a79b	                jmp asm_common
.a5d9						z_asm_jmp_i:
.a5d9						xt_asm_jmp_xi:
.a5d9		a9 7c		lda #$7c	                lda #$7C
.a5db		4c 9b a7	jmp $a79b	                jmp asm_common
.a5de						z_asm_jmp_xi:
.a5de						xt_asm_jsr:
.a5de		a9 20		lda #$20	                lda #$20
.a5e0		4c 9b a7	jmp $a79b	                jmp asm_common
.a5e3						z_asm_jsr:
.a5e3						xt_asm_lda:
.a5e3		a9 ad		lda #$ad	                lda #$AD
.a5e5		4c 9b a7	jmp $a79b	                jmp asm_common
.a5e8						z_asm_lda:
.a5e8						xt_asm_lda_h:
.a5e8		a9 a9		lda #$a9	                lda #$A9
.a5ea		4c 9b a7	jmp $a79b	                jmp asm_common
.a5ed						z_asm_lda_h:
.a5ed						xt_asm_lda_x:
.a5ed		a9 bd		lda #$bd	                lda #$BD
.a5ef		4c 9b a7	jmp $a79b	                jmp asm_common
.a5f2						z_asm_lda_x:
.a5f2						xt_asm_lda_y:
.a5f2		a9 b9		lda #$b9	                lda #$B9
.a5f4		4c 9b a7	jmp $a79b	                jmp asm_common
.a5f7						z_asm_lda_y:
.a5f7						xt_asm_lda_z:
.a5f7		a9 a5		lda #$a5	                lda #$A5
.a5f9		4c 9b a7	jmp $a79b	                jmp asm_common
.a5fc						z_asm_lda_z:
.a5fc						xt_asm_lda_zi:
.a5fc		a9 b2		lda #$b2	                lda #$B2
.a5fe		4c 9b a7	jmp $a79b	                jmp asm_common
.a601						z_asm_lda_zi:
.a601						xt_asm_lda_ziy:
.a601		a9 b1		lda #$b1	                lda #$B1
.a603		4c 9b a7	jmp $a79b	                jmp asm_common
.a606						z_asm_lda_ziy:
.a606						xt_asm_lda_zx:
.a606		a9 b5		lda #$b5	                lda #$B5
.a608		4c 9b a7	jmp $a79b	                jmp asm_common
.a60b						z_asm_lda_zx:
.a60b						xt_asm_lda_zxi:
.a60b		a9 a1		lda #$a1	                lda #$A1
.a60d		4c 9b a7	jmp $a79b	                jmp asm_common
.a610						z_asm_lda_zxi:
.a610						xt_asm_ldx:
.a610		a9 ae		lda #$ae	                lda #$AE
.a612		4c 9b a7	jmp $a79b	                jmp asm_common
.a615						z_asm_ldx:
.a615						xt_asm_ldx_h:
.a615		a9 a2		lda #$a2	                lda #$A2
.a617		4c 9b a7	jmp $a79b	                jmp asm_common
.a61a						z_asm_ldx_h:
.a61a						xt_asm_ldx_y:
.a61a		a9 be		lda #$be	                lda #$BE
.a61c		4c 9b a7	jmp $a79b	                jmp asm_common
.a61f						z_asm_ldx_y:
.a61f						xt_asm_ldx_z:
.a61f		a9 a6		lda #$a6	                lda #$A6
.a621		4c 9b a7	jmp $a79b	                jmp asm_common
.a624						z_asm_ldx_z:
.a624						xt_asm_ldx_zy:
.a624		a9 b6		lda #$b6	                lda #$B6
.a626		4c 9b a7	jmp $a79b	                jmp asm_common
.a629						z_asm_ldx_zy:
.a629						xt_asm_ldy:
.a629		a9 ac		lda #$ac	                lda #$AC
.a62b		4c 9b a7	jmp $a79b	                jmp asm_common
.a62e						z_asm_ldy:
.a62e						xt_asm_ldy_h:
.a62e		a9 a0		lda #$a0	                lda #$A0
.a630		4c 9b a7	jmp $a79b	                jmp asm_common
.a633						z_asm_ldy_h:
.a633						xt_asm_ldy_x:
.a633		a9 bc		lda #$bc	                lda #$BC
.a635		4c 9b a7	jmp $a79b	                jmp asm_common
.a638						z_asm_ldy_x:
.a638						xt_asm_ldy_z:
.a638		a9 a4		lda #$a4	                lda #$A4
.a63a		4c 9b a7	jmp $a79b	                jmp asm_common
.a63d						z_asm_ldy_z:
.a63d						xt_asm_ldy_zx:
.a63d		a9 b4		lda #$b4	                lda #$B4
.a63f		4c 9b a7	jmp $a79b	                jmp asm_common
.a642						z_asm_ldy_zx:
.a642						xt_asm_lsr:
.a642		a9 4e		lda #$4e	                lda #$4E
.a644		4c 9b a7	jmp $a79b	                jmp asm_common
.a647						z_asm_lsr:
.a647						xt_asm_lsr_a:
.a647		a9 4a		lda #$4a	                lda #$4A
.a649		4c 9b a7	jmp $a79b	                jmp asm_common
.a64c						z_asm_lsr_a:
.a64c						xt_asm_lsr_x:
.a64c		a9 5e		lda #$5e	                lda #$5E
.a64e		4c 9b a7	jmp $a79b	                jmp asm_common
.a651						z_asm_lsr_x:
.a651						xt_asm_lsr_z:
.a651		a9 46		lda #$46	                lda #$46
.a653		4c 9b a7	jmp $a79b	                jmp asm_common
.a656						z_asm_lsr_z:
.a656						xt_asm_lsr_zx:
.a656		a9 56		lda #$56	                lda #$56
.a658		4c 9b a7	jmp $a79b	                jmp asm_common
.a65b						z_asm_lsr_zx:
.a65b						xt_asm_nop:
.a65b		a9 ea		lda #$ea	                lda #$EA
.a65d		4c 9b a7	jmp $a79b	                jmp asm_common
.a660						z_asm_nop:
.a660						xt_asm_ora:
.a660		a9 0d		lda #$0d	                lda #$0D
.a662		4c 9b a7	jmp $a79b	                jmp asm_common
.a665						z_asm_ora:
.a665						xt_asm_ora_h:
.a665		a9 09		lda #$09	                lda #$09
.a667		4c 9b a7	jmp $a79b	                jmp asm_common
.a66a						z_asm_ora_h:
.a66a						xt_asm_ora_x:
.a66a		a9 1d		lda #$1d	                lda #$1D
.a66c		4c 9b a7	jmp $a79b	                jmp asm_common
.a66f						z_asm_ora_x:
.a66f						xt_asm_ora_y:
.a66f		a9 19		lda #$19	                lda #$19
.a671		4c 9b a7	jmp $a79b	                jmp asm_common
.a674						z_asm_ora_y:
.a674						xt_asm_ora_z:
.a674		a9 05		lda #$05	                lda #$05
.a676		4c 9b a7	jmp $a79b	                jmp asm_common
.a679						z_asm_ora_z:
.a679						xt_asm_ora_zi:
.a679		a9 12		lda #$12	                lda #$12
.a67b		a0 02		ldy #$02	                ldy #2
.a67d		4c 9b a7	jmp $a79b	                jmp asm_common
.a680						z_asm_ora_zi:
.a680						xt_asm_ora_ziy:
.a680		a9 11		lda #$11	                lda #$11
.a682		4c 9b a7	jmp $a79b	                jmp asm_common
.a685						z_asm_ora_ziy:
.a685						xt_asm_ora_zx:
.a685		a9 15		lda #$15	                lda #$15
.a687		4c 9b a7	jmp $a79b	                jmp asm_common
.a68a						z_asm_ora_zx:
.a68a						xt_asm_ora_zxi:
.a68a		a9 01		lda #$01	                lda #$01
.a68c		4c 9b a7	jmp $a79b	                jmp asm_common
.a68f						z_asm_ora_zxi:
.a68f						xt_asm_pha:
.a68f		a9 48		lda #$48	                lda #$48
.a691		4c 9b a7	jmp $a79b	                jmp asm_common
.a694						z_asm_pha:
.a694						xt_asm_php:
.a694		a9 08		lda #$08	                lda #$08
.a696		4c 9b a7	jmp $a79b	                jmp asm_common
.a699						z_asm_php:
.a699						xt_asm_phx:
.a699		a9 da		lda #$da	                lda #$DA
.a69b		4c 9b a7	jmp $a79b	                jmp asm_common
.a69e						z_asm_phx:
.a69e						xt_asm_phy:
.a69e		a9 5a		lda #$5a	                lda #$5A
.a6a0		4c 9b a7	jmp $a79b	                jmp asm_common
.a6a3						z_asm_phy:
.a6a3						xt_asm_pla:
.a6a3		a9 68		lda #$68	                lda #$68
.a6a5		4c 9b a7	jmp $a79b	                jmp asm_common
.a6a8						z_asm_pla:
.a6a8						xt_asm_plp:
.a6a8		a9 28		lda #$28	                lda #$28
.a6aa		4c 9b a7	jmp $a79b	                jmp asm_common
.a6ad						z_asm_plp:
.a6ad						xt_asm_plx:
.a6ad		a9 fa		lda #$fa	                lda #$FA
.a6af		4c 9b a7	jmp $a79b	                jmp asm_common
.a6b2						z_asm_plx:
.a6b2						xt_asm_ply:
.a6b2		a9 7a		lda #$7a	                lda #$7A
.a6b4		4c 9b a7	jmp $a79b	                jmp asm_common
.a6b7						z_asm_ply:
.a6b7						xt_asm_rol:
.a6b7		a9 2e		lda #$2e	                lda #$2E
.a6b9		4c 9b a7	jmp $a79b	                jmp asm_common
.a6bc						z_asm_rol:
.a6bc						xt_asm_rol_a:
.a6bc		a9 2a		lda #$2a	                lda #$2A
.a6be		4c 9b a7	jmp $a79b	                jmp asm_common
.a6c1						z_asm_rol_a:
.a6c1						xt_asm_rol_x:
.a6c1		a9 3e		lda #$3e	                lda #$3E
.a6c3		4c 9b a7	jmp $a79b	                jmp asm_common
.a6c6						z_asm_rol_x:
.a6c6						xt_asm_rol_z:
.a6c6		a9 26		lda #$26	                lda #$26
.a6c8		4c 9b a7	jmp $a79b	                jmp asm_common
.a6cb						z_asm_rol_z:
.a6cb						xt_asm_rol_zx:
.a6cb		a9 36		lda #$36	                lda #$36
.a6cd		4c 9b a7	jmp $a79b	                jmp asm_common
.a6d0						z_asm_rol_zx:
.a6d0						xt_asm_ror:
.a6d0		a9 6e		lda #$6e	                lda #$6E
.a6d2		4c 9b a7	jmp $a79b	                jmp asm_common
.a6d5						z_asm_ror:
.a6d5						xt_asm_ror_a:
.a6d5		a9 6a		lda #$6a	                lda #$6A
.a6d7		4c 9b a7	jmp $a79b	                jmp asm_common
.a6da						z_asm_ror_a:
.a6da						xt_asm_ror_x:
.a6da		a9 7e		lda #$7e	                lda #$7E
.a6dc		4c 9b a7	jmp $a79b	                jmp asm_common
.a6df						z_asm_ror_x:
.a6df						xt_asm_ror_z:
.a6df		a9 66		lda #$66	                lda #$66
.a6e1		4c 9b a7	jmp $a79b	                jmp asm_common
.a6e4						z_asm_ror_z:
.a6e4						xt_asm_ror_zx:
.a6e4		a9 76		lda #$76	                lda #$76
.a6e6		4c 9b a7	jmp $a79b	                jmp asm_common
.a6e9						z_asm_ror_zx:
.a6e9						xt_asm_rti:
.a6e9		a9 40		lda #$40	                lda #$40
.a6eb		4c 9b a7	jmp $a79b	                jmp asm_common
.a6ee						z_asm_rti:
.a6ee						xt_asm_rts:
.a6ee		a9 60		lda #$60	                lda #$60
.a6f0		4c 9b a7	jmp $a79b	                jmp asm_common
.a6f3						z_asm_rts:
.a6f3						xt_asm_sbc:
.a6f3		a9 ed		lda #$ed	                lda #$ED
.a6f5		4c 9b a7	jmp $a79b	                jmp asm_common
.a6f8						z_asm_sbc:
.a6f8						xt_asm_sbc_h:
.a6f8		a9 e9		lda #$e9	                lda #$E9
.a6fa		4c 9b a7	jmp $a79b	                jmp asm_common
.a6fd						z_asm_sbc_h:
.a6fd						xt_asm_sbc_x:
.a6fd		a9 fd		lda #$fd	                lda #$FD
.a6ff		4c 9b a7	jmp $a79b	                jmp asm_common
.a702						z_asm_sbc_x:
.a702						xt_asm_sbc_y:
.a702		a9 f9		lda #$f9	                lda #$F9
.a704		4c 9b a7	jmp $a79b	                jmp asm_common
.a707						z_asm_sbc_y:
.a707						xt_asm_sbc_z:
.a707		a9 e5		lda #$e5	                lda #$E5
.a709		4c 9b a7	jmp $a79b	                jmp asm_common
.a70c						z_asm_sbc_z:
.a70c						xt_asm_sbc_zi:
.a70c		a9 f2		lda #$f2	                lda #$F2
.a70e		4c 9b a7	jmp $a79b	                jmp asm_common
.a711						z_asm_sbc_zi:
.a711						xt_asm_sbc_ziy:
.a711		a9 f1		lda #$f1	                lda #$F1
.a713		4c 9b a7	jmp $a79b	                jmp asm_common
.a716						z_asm_sbc_ziy:
.a716						xt_asm_sbc_zx:
.a716		a9 f5		lda #$f5	                lda #$F5
.a718		4c 9b a7	jmp $a79b	                jmp asm_common
.a71b						z_asm_sbc_zx:
.a71b						xt_asm_sbc_zxi:
.a71b		a9 e1		lda #$e1	                lda #$E1
.a71d		80 7c		bra $a79b	                bra asm_common  ; <-- limit for BRA instead of JMP
.a71f						z_asm_sbc_zxi:
.a71f						xt_asm_sec:
.a71f		a9 38		lda #$38	                lda #$38
.a721		80 78		bra $a79b	                bra asm_common
.a723						z_asm_sec:
.a723						xt_asm_sed:
.a723		a9 f8		lda #$f8	                lda #$F8
.a725		80 74		bra $a79b	                bra asm_common
.a727						z_asm_sed:
.a727						xt_asm_sei:
.a727		a9 78		lda #$78	                lda #$78
.a729		80 70		bra $a79b	                bra asm_common
.a72b						z_asm_sei:
.a72b						xt_asm_sta:
.a72b		a9 8d		lda #$8d	                lda #$8D
.a72d		80 6c		bra $a79b	                bra asm_common
.a72f						z_asm_sta:
.a72f						xt_asm_sta_x:
.a72f		a9 9d		lda #$9d	                lda #$9D
.a731		80 68		bra $a79b	                bra asm_common
.a733						z_asm_sta_x:
.a733						xt_asm_sta_y:
.a733		a9 99		lda #$99	                lda #$99
.a735		80 64		bra $a79b	                bra asm_common
.a737						z_asm_sta_y:
.a737						xt_asm_sta_z:
.a737		a9 85		lda #$85	                lda #$85
.a739		80 60		bra $a79b	                bra asm_common
.a73b						z_asm_sta_z:
.a73b						xt_asm_sta_zi:
.a73b		a9 92		lda #$92	                lda #$92
.a73d		80 5c		bra $a79b	                bra asm_common
.a73f						z_asm_sta_zi:
.a73f						xt_asm_sta_ziy:
.a73f		a9 91		lda #$91	                lda #$91
.a741		80 58		bra $a79b	                bra asm_common
.a743						z_asm_sta_ziy:
.a743						xt_asm_sta_zx:
.a743		a9 95		lda #$95	                lda #$95
.a745		80 54		bra $a79b	                bra asm_common
.a747						z_asm_sta_zx:
.a747						xt_asm_sta_zxi:
.a747		a9 81		lda #$81	                lda #$81
.a749		80 50		bra $a79b	                bra asm_common
.a74b						z_asm_sta_zxi:
.a74b						xt_asm_stx:
.a74b		a9 8e		lda #$8e	                lda #$8E
.a74d		80 4c		bra $a79b	                bra asm_common
.a74f						z_asm_stx:
.a74f						xt_asm_stx_z:
.a74f		a9 86		lda #$86	                lda #$86
.a751		80 48		bra $a79b	                bra asm_common
.a753						z_asm_stx_z:
.a753						xt_asm_stx_zy:
.a753		a9 96		lda #$96	                lda #$96
.a755		80 44		bra $a79b	                bra asm_common
.a757						z_asm_stx_zy:
.a757						xt_asm_sty:
.a757		a9 8c		lda #$8c	                lda #$8C
.a759		80 40		bra $a79b	                bra asm_common
.a75b						z_asm_sty:
.a75b						xt_asm_sty_z:
.a75b		a9 84		lda #$84	                lda #$84
.a75d		80 3c		bra $a79b	                bra asm_common
.a75f						z_asm_sty_z:
.a75f						xt_asm_sty_zx:
.a75f		a9 94		lda #$94	                lda #$94
.a761		80 38		bra $a79b	                bra asm_common
.a763						z_asm_sty_zx:
.a763						xt_asm_stz:
.a763		a9 9c		lda #$9c	                lda #$9C
.a765		80 34		bra $a79b	                bra asm_common
.a767						z_asm_stz:
.a767						xt_asm_stz_x:
.a767		a9 9e		lda #$9e	                lda #$9E
.a769		80 30		bra $a79b	                bra asm_common
.a76b						z_asm_stz_x:
.a76b						xt_asm_stz_z:
.a76b		a9 64		lda #$64	                lda #$64
.a76d		80 2c		bra $a79b	                bra asm_common
.a76f						z_asm_stz_z:
.a76f						xt_asm_stz_zx:
.a76f		a9 74		lda #$74	                lda #$74
.a771		80 28		bra $a79b	                bra asm_common
.a773						z_asm_stz_zx:
.a773						xt_asm_tax:
.a773		a9 aa		lda #$aa	                lda #$AA
.a775		80 24		bra $a79b	                bra asm_common
.a777						z_asm_tax:
.a777						xt_asm_tay:
.a777		a9 a8		lda #$a8	                lda #$A8
.a779		80 20		bra $a79b	                bra asm_common
.a77b						z_asm_tay:
.a77b						xt_asm_trb:
.a77b		a9 1c		lda #$1c	                lda #$1C
.a77d		80 1c		bra $a79b	                bra asm_common
.a77f						z_asm_trb:
.a77f						xt_asm_trb_z:
.a77f		a9 14		lda #$14	                lda #$14
.a781		80 18		bra $a79b	                bra asm_common
.a783						z_asm_trb_z:
.a783						xt_asm_tsb:
.a783		a9 0c		lda #$0c	                lda #$0C
.a785		80 14		bra $a79b	                bra asm_common
.a787						z_asm_tsb:
.a787						xt_asm_tsb_z:
.a787		a9 04		lda #$04	                lda #$04
.a789		80 10		bra $a79b	                bra asm_common
.a78b						z_asm_tsb_z:
.a78b						xt_asm_tsx:
.a78b		a9 ba		lda #$ba	                lda #$BA
.a78d		80 0c		bra $a79b	                bra asm_common
.a78f						z_asm_tsx:
.a78f						xt_asm_txa:
.a78f		a9 8a		lda #$8a	                lda #$8A
.a791		80 08		bra $a79b	                bra asm_common
.a793						z_asm_txa:
.a793						xt_asm_txs:
.a793		a9 9a		lda #$9a	                lda #$9A
.a795		80 04		bra $a79b	                bra asm_common
.a797						z_asm_txs:
.a797						xt_asm_tya:
.a797		a9 98		lda #$98	                lda #$98
.a799		80 00		bra $a79b	                bra asm_common
.a79b						z_asm_tya:
.a79b						asm_common:
.a79b		a8		tay		                tay
.a79c		20 49 d6	jsr $d649	                jsr cmpl_a
.a79f		a9 0f		lda #$0f	                lda #<oc_index_table
.a7a1		85 27		sta $27		                sta tmp2
.a7a3		a9 b4		lda #$b4	                lda #>oc_index_table
.a7a5		85 28		sta $28		                sta tmp2+1
.a7a7		98		tya		                tya             ; retrieve opcode
.a7a8		0a		asl a		                asl             ; times two for offset
.a7a9		90 02		bcc $a7ad	                bcc +
.a7ab		e6 28		inc $28		                inc tmp2+1
.a7ad						+
.a7ad		a8		tay		                tay             ; use Y as the index
.a7ae		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a7b0		85 29		sta $29		                sta tmp3
.a7b2		c8		iny		                iny
.a7b3		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a7b5		85 2a		sta $2a		                sta tmp3+1
.a7b7		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a7b9		2a		rol a		                rol
.a7ba		2a		rol a		                rol
.a7bb		2a		rol a		                rol             ; Three times because we go through Carry
.a7bc		29 03		and #$03	                and #%00000011
.a7be		a8		tay		                tay
.a7bf		88		dey		                dey
.a7c0		f0 12		beq $a7d4	                beq _done
.a7c2		20 03 d8	jsr $d803	                jsr underflow_1
.a7c5		b5 00		lda $00,x	                lda 0,x
.a7c7		20 49 d6	jsr $d649	                jsr cmpl_a      ; does not use Y
.a7ca		88		dey		                dey
.a7cb		f0 05		beq $a7d2	                beq _done_drop
.a7cd		b5 01		lda $01,x	                lda 1,x
.a7cf		20 49 d6	jsr $d649	                jsr cmpl_a      ; Fall through to _done_drop
.a7d2						_done_drop:
.a7d2		e8		inx		                inx
.a7d3		e8		inx		                inx             ; Fall through to _done
.a7d4						_done:
.a7d4		60		rts		                rts             ; Returns to original caller
.a7d5						xt_asm_push_a:
.a7d5		a0 00		ldy #$00	                ldy #0
.a7d7						_loop:
.a7d7		b9 e5 a7	lda $a7e5,y	                lda asm_push_a_data,y
.a7da		c9 ff		cmp #$ff	                cmp #$FF
.a7dc		f0 06		beq $a7e4	                beq _done
.a7de		20 49 d6	jsr $d649	                jsr cmpl_a      ; does not change Y
.a7e1		c8		iny		                iny
.a7e2		80 f3		bra $a7d7	                bra _loop
.a7e4						_done:
.a7e4						z_asm_push_a:
.a7e4		60		rts		                rts
.a7e5						asm_push_a_data:
>a7e5		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>a7eb		ff				        .byte $FF               ; terminator
.a7ec						xt_asm_back_jump:
.a7ec						z_asm_back_jump:
.a7ec		60		rts		                rts
.a7ed						xt_asm_back_branch:
.a7ed		20 91 8a	jsr $8a91	                jsr xt_here             ; ( addr-l addr-h )
.a7f0		20 77 8d	jsr $8d77	                jsr xt_minus            ; ( offset )
.a7f3		3a		dec a		                dea
.a7f4		3a		dec a		                dea
.a7f5						z_asm_back_branch:
.a7f5		60		rts		                rts
.a7f6						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a7f6						xt_ed:
.a7f6		20 fa a7	jsr $a7fa	                jsr ed6502      ; kept in separate file
.a7f9		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a7fa						ed6502:
.a7fa		a5 18		lda $18		                lda base
.a7fc		85 3a		sta $3a		                sta ed_base
.a7fe		a9 0a		lda #$0a	                lda #10
.a800		85 18		sta $18		                sta base
.a802		64 35		stz $35		                stz ed_head
.a804		64 36		stz $36		                stz ed_head+1
.a806		64 37		stz $37		                stz ed_cur
.a808		64 38		stz $38		                stz ed_cur+1
.a80a		64 39		stz $39		                stz ed_flags
.a80c		20 37 9e	jsr $9e37	                jsr xt_zero
.a80f		20 37 9e	jsr $9e37	                jsr xt_zero             ; ( addr-t u-t )
.a812		20 69 85	jsr $8569	                jsr xt_cr
.a815						ed_input_loop:
.a815		a9 81		lda #$81	                lda #%10000001
.a817		14 39		trb $39		                trb ed_flags
.a819		20 f4 ac	jsr $acf4	                jsr ed_get_input
.a81c		a5 0e		lda $0e		                lda ciblen
.a81e		d0 1f		bne $a83f	                bne _command_mode
.a820		ca		dex		                dex
.a821		ca		dex		                dex                     ; ( addr-t u-t ? )
.a822		a5 37		lda $37		                lda ed_cur
.a824		95 00		sta $00,x	                sta 0,x
.a826		a5 38		lda $38		                lda ed_cur+1
.a828		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a82a		a9 80		lda #$80	                lda #%10000000
.a82c		04 39		tsb $39		                tsb ed_flags
.a82e		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.a831		20 10 ad	jsr $ad10	                jsr ed_is_valid_line
.a834		b0 03		bcs $a839	                bcs +
.a836		4c e4 ac	jmp $ace4	                jmp ed_error_1drop
.a839						+
.a839		20 37 9e	jsr $9e37	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.a83c		4c 0a a9	jmp $a90a	                jmp _line_number_only_from_external
.a83f						_command_mode:
.a83f		20 37 9e	jsr $9e37	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a842		20 37 9e	jsr $9e37	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a845						_prefix_dot:
.a845		b2 0c		lda ($0c)	                lda (cib)
.a847		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a849		d0 3a		bne $a885	                bne _prefix_dollar
.a84b		20 05 ad	jsr $ad05	                jsr ed_have_text
.a84e		a5 37		lda $37		                lda ed_cur
.a850		95 02		sta $02,x	                sta 2,x
.a852		a5 38		lda $38		                lda ed_cur+1
.a854		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a856		a9 80		lda #$80	                lda #%10000000
.a858		04 39		tsb $39		                tsb ed_flags
.a85a		a5 0e		lda $0e		                lda ciblen
.a85c		3a		dec a		                dea                     ; sets Z if A was 1
.a85d		d0 03		bne $a862	                bne +
.a85f		4c 0a a9	jmp $a90a	                jmp _line_number_only_from_external
.a862						+
.a862		ca		dex		                dex
.a863		ca		dex		                dex
.a864		ca		dex		                dex
.a865		ca		dex		                dex
.a866		a5 0c		lda $0c		                lda cib
.a868		95 02		sta $02,x	                sta 2,x
.a86a		a5 0d		lda $0d		                lda cib+1
.a86c		95 03		sta $03,x	                sta 3,x
.a86e		a5 0e		lda $0e		                lda ciblen
.a870		95 00		sta $00,x	                sta 0,x
.a872		a5 0f		lda $0f		                lda ciblen+1
.a874		95 01		sta $01,x	                sta 1,x
.a876		20 70 8e	jsr $8e70	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a879		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a87c		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a87f		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a882		4c 62 a9	jmp $a962	                jmp _check_for_para2
.a885						_prefix_dollar:
.a885		b2 0c		lda ($0c)	                lda (cib)
.a887		c9 24		cmp #$24	                cmp #'$'
.a889		d0 1c		bne $a8a7	                bne _prefix_percent
.a88b		20 05 ad	jsr $ad05	                jsr ed_have_text
.a88e		e8		inx		                inx
.a88f		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a890		20 32 ad	jsr $ad32	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a893		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.a896		a9 80		lda #$80	                lda #%10000000
.a898		04 39		tsb $39		                tsb ed_flags
.a89a		a5 0e		lda $0e		                lda ciblen
.a89c		3a		dec a		                dea                     ; sets Z if A was 1
.a89d		d0 03		bne $a8a2	                bne +
.a89f		4c 0a a9	jmp $a90a	                jmp _line_number_only_from_external
.a8a2						+
.a8a2		a0 01		ldy #$01	                ldy #01
.a8a4		4c de a9	jmp $a9de	                jmp _check_command
.a8a7						_prefix_percent:
.a8a7		b2 0c		lda ($0c)	                lda (cib)
.a8a9		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a8ab		f0 04		beq $a8b1	                beq _whole_text
.a8ad		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a8af		d0 17		bne $a8c8	                bne _prefix_semicolon
.a8b1						_whole_text:
.a8b1		20 05 ad	jsr $ad05	                jsr ed_have_text
.a8b4		a9 01		lda #$01	                lda #01
.a8b6		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a8b8		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a8ba						_semicolon_entry:
.a8ba		e8		inx		                inx
.a8bb		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a8bc		20 32 ad	jsr $ad32	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a8bf		a9 80		lda #$80	                lda #%10000000
.a8c1		04 39		tsb $39		                tsb ed_flags
.a8c3		a0 01		ldy #$01	                ldy #01
.a8c5		4c de a9	jmp $a9de	                jmp _check_command
.a8c8						_prefix_semicolon:
.a8c8		b2 0c		lda ($0c)	                lda (cib)
.a8ca		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a8cc		d0 0d		bne $a8db	                bne _prefix_number
.a8ce		20 05 ad	jsr $ad05	                jsr ed_have_text
.a8d1		a5 37		lda $37		                lda ed_cur
.a8d3		95 02		sta $02,x	                sta 2,x
.a8d5		a5 38		lda $38		                lda ed_cur+1
.a8d7		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a8d9		80 df		bra $a8ba	                bra _semicolon_entry
.a8db						_prefix_number:
.a8db		20 37 9e	jsr $9e37	                jsr xt_zero
.a8de		20 37 9e	jsr $9e37	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.a8e1		ca		dex		                dex
.a8e2		ca		dex		                dex
.a8e3		ca		dex		                dex
.a8e4		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a8e5		a5 0c		lda $0c		                lda cib
.a8e7		95 02		sta $02,x	                sta 2,x
.a8e9		a5 0d		lda $0d		                lda cib+1
.a8eb		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a8ed		a5 0e		lda $0e		                lda ciblen
.a8ef		95 00		sta $00,x	                sta 0,x
.a8f1		a5 0f		lda $0f		                lda ciblen+1
.a8f3		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a8f5		20 96 94	jsr $9496	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a8f8		b5 00		lda $00,x	                lda 0,x
.a8fa		15 01		ora $01,x	                ora 1,x
.a8fc		d0 24		bne $a922	                bne _have_unconverted_chars
.a8fe		e8		inx		                inx
.a8ff		e8		inx		                inx
.a900		e8		inx		                inx
.a901		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a902		20 80 9e	jsr $9e80	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a905		20 bb 9c	jsr $9cbb	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.a908		e8		inx		                inx
.a909		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a90a						_line_number_only_from_external:
.a90a		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( addr-t u-t 0 u )
.a90d		20 10 ad	jsr $ad10	                jsr ed_is_valid_line
.a910		b0 03		bcs $a915	                bcs +
.a912		4c e2 ac	jmp $ace2	                jmp ed_error_2drop
.a915						+
.a915		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( addr-t u-t u 0 )
.a918		20 9f ad	jsr $ad9f	                jsr ed_para1_to_cur
.a91b		a9 80		lda #$80	                lda #%10000000
.a91d		04 39		tsb $39		                tsb ed_flags
.a91f		4c bd ab	jmp $abbd	                jmp ed_cmd_p_from_external
.a922						_have_unconverted_chars:
.a922		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a925		ca		dex		                dex
.a926		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a927		a5 0e		lda $0e		                lda ciblen
.a929		95 00		sta $00,x	                sta 0,x
.a92b		a5 0f		lda $0f		                lda ciblen+1
.a92d		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a92f		20 0c 89	jsr $890c	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a932		b5 00		lda $00,x	                lda 0,x
.a934		15 01		ora $01,x	                ora 1,x
.a936		f0 0e		beq $a946	                beq _no_command_yet
.a938		8a		txa		                txa
.a939		18		clc		                clc
.a93a		69 0a		adc #$0a	                adc #10
.a93c		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a93d		a9 80		lda #$80	                lda #%10000000
.a93f		14 39		trb $39		                trb ed_flags
.a941		a0 00		ldy #$00	                ldy #00
.a943		4c de a9	jmp $a9de	                jmp _check_command
.a946						_no_command_yet:
.a946		e8		inx		                inx
.a947		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a948		20 36 95	jsr $9536	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a94b		20 bb 9c	jsr $9cbb	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a94e		20 80 9e	jsr $9e80	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a951		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a953		95 06		sta $06,x	                sta 6,x
.a955		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a957		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a959		e8		inx		                inx
.a95a		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a95b		20 81 90	jsr $9081	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a95e		a9 80		lda #$80	                lda #%10000000
.a960		04 39		tsb $39		                tsb ed_flags
.a962						_check_for_para2:
.a962		a1 02		lda ($02,x)	                lda (2,x)
.a964		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a966		f0 0d		beq $a975	                beq _got_comma
.a968		38		sec		                sec
.a969		a5 0e		lda $0e		                lda ciblen
.a96b		f5 00		sbc $00,x	                sbc 0,x
.a96d		a8		tay		                tay
.a96e		e8		inx		                inx
.a96f		e8		inx		                inx
.a970		e8		inx		                inx
.a971		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a972		4c de a9	jmp $a9de	                jmp _check_command
.a975						_got_comma:
.a975		f6 02		inc $02,x	                inc 2,x
.a977		d0 02		bne $a97b	                bne +
.a979		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a97b						+
.a97b		b5 01		lda $01,x	                lda 1,x
.a97d		f0 02		beq $a981	                beq +
.a97f		d6 01		dec $01,x	                dec 1,x
.a981						+
.a981		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a983		a1 02		lda ($02,x)	                lda (2,x)
.a985		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a987		d0 14		bne $a99d	                bne _para2_not_dollar
.a989		38		sec		                sec
.a98a		a5 0e		lda $0e		                lda ciblen
.a98c		f5 02		sbc $02,x	                sbc 2,x
.a98e		a8		tay		                tay
.a98f		c8		iny		                iny
.a990		5a		phy		                phy
.a991		8a		txa		                txa
.a992		18		clc		                clc
.a993		69 06		adc #$06	                adc #06
.a995		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a996		20 32 ad	jsr $ad32	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a999		7a		ply		                ply
.a99a		4c de a9	jmp $a9de	                jmp _check_command
.a99d						_para2_not_dollar:
.a99d		20 36 95	jsr $9536	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.a9a0		20 37 9e	jsr $9e37	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.a9a3		20 37 9e	jsr $9e37	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.a9a6		20 1e 91	jsr $911e	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.a9a9		20 81 90	jsr $9081	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.a9ac		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.a9af		20 36 95	jsr $9536	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.a9b2		20 96 94	jsr $9496	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.a9b5		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.a9b8		20 81 90	jsr $9081	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.a9bb		20 0c 89	jsr $890c	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.a9be		b5 00		lda $00,x	                lda 0,x
.a9c0		15 01		ora $01,x	                ora 1,x
.a9c2		f0 08		beq $a9cc	                beq _second_number
.a9c4		8a		txa		                txa
.a9c5		18		clc		                clc
.a9c6		69 0c		adc #$0c	                adc #12
.a9c8		aa		tax		                tax                     ; back to ( addr-t u-t )
.a9c9		4c e6 ac	jmp $ace6	                jmp ed_error
.a9cc						_second_number:
.a9cc		e8		inx		                inx
.a9cd		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.a9ce		38		sec		                sec
.a9cf		a5 0e		lda $0e		                lda ciblen
.a9d1		f5 00		sbc $00,x	                sbc 0,x
.a9d3		48		pha		                pha
.a9d4		20 6d 95	jsr $956d	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.a9d7		20 80 9e	jsr $9e80	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.a9da		20 c3 8d	jsr $8dc3	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.a9dd		7a		ply		                ply
.a9de						_check_command:
.a9de		24 39		bit $39		                bit ed_flags
.a9e0		30 08		bmi $a9ea	                bmi _check_command_have_arg
.a9e2		a5 37		lda $37		                lda ed_cur
.a9e4		95 02		sta $02,x	                sta 2,x
.a9e6		a5 38		lda $38		                lda ed_cur+1
.a9e8		95 03		sta $03,x	                sta 3,x
.a9ea						_check_command_have_arg:
.a9ea		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.a9ec		85 25		sta $25		                sta tmp1
.a9ee		da		phx		                phx
.a9ef		a2 00		ldx #$00	                ldx #00
.a9f1						_cmd_loop:
.a9f1		bd ca ad	lda $adca,x	                lda ed_cmd_list,x
.a9f4		f0 07		beq $a9fd	                beq _illegal_command    ; zero marks end of list
.a9f6		c5 25		cmp $25		                cmp tmp1
.a9f8		f0 07		beq $aa01	                beq _found_cmd
.a9fa		e8		inx		                inx
.a9fb		80 f4		bra $a9f1	                bra _cmd_loop
.a9fd						_illegal_command:
.a9fd		fa		plx		                plx
.a9fe		4c e2 ac	jmp $ace2	                jmp ed_error_2drop
.aa01						_found_cmd:
.aa01		8a		txa		                txa
.aa02		0a		asl a		                asl
.aa03		aa		tax		                tax                     ; X * 2 for table
.aa04		7c d5 ad	jmp ($add5,x)	                jmp (ed_cmd_table,x)
.aa07						ed_next_command:
.aa07		e8		inx		                inx
.aa08		e8		inx		                inx
.aa09		e8		inx		                inx
.aa0a		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.aa0b						_next_command_empty:
.aa0b		4c 15 a8	jmp $a815	                jmp ed_input_loop
.aa0e						ed_all_done:
.aa0e		64 0e		stz $0e		                stz ciblen
.aa10		64 0f		stz $0f		                stz ciblen+1
.aa12		20 6d 95	jsr $956d	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.aa15		a5 3a		lda $3a		                lda ed_base
.aa17		85 18		sta $18		                sta base
.aa19		60		rts		                rts
.aa1a						ed_cmd_a:
.aa1a		fa		plx		                plx
.aa1b		e8		inx		                inx
.aa1c		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.aa1d						ed_entry_cmd_i:
.aa1d						ed_cmd_a_have_para:
.aa1d		20 68 ad	jsr $ad68	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.aa20		20 69 85	jsr $8569	                jsr xt_cr
.aa23						_next_string_loop:
.aa23		20 f4 ac	jsr $acf4	                jsr ed_get_input
.aa26		b2 0c		lda ($0c)	                lda (cib)
.aa28		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.aa2a		d0 16		bne $aa42	                bne _add_line
.aa2c		a4 0e		ldy $0e		                ldy ciblen
.aa2e		c0 01		cpy #$01	                cpy #01
.aa30		d0 10		bne $aa42	                bne _add_line
.aa32		a4 0f		ldy $0f		                ldy ciblen+1
.aa34		d0 0c		bne $aa42	                bne _add_line
.aa36		e8		inx		                inx
.aa37		e8		inx		                inx
.aa38		a9 40		lda #$40	                lda #%01000000
.aa3a		04 39		tsb $39		                tsb ed_flags
.aa3c		20 69 85	jsr $8569	                jsr xt_cr
.aa3f		4c 15 a8	jmp $a815	                jmp ed_input_loop
.aa42						_add_line:
.aa42		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.aa45		20 91 8a	jsr $8a91	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.aa48		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.aa4b		20 90 89	jsr $8990	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.aa4e		20 da 83	jsr $83da	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.aa51		20 53 95	jsr $9553	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.aa54		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.aa57		20 e2 93	jsr $93e2	                jsr xt_store            ; ! ( addr-t u-t here )
.aa5a		20 91 8a	jsr $8a91	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.aa5d		a5 00		lda $00		                lda cp
.aa5f		18		clc		                clc
.aa60		69 04		adc #$04	                adc #04
.aa62		85 00		sta $00		                sta cp
.aa64		90 02		bcc $aa68	                bcc +
.aa66		e6 01		inc $01		                inc cp+1
.aa68						+
.aa68		e6 37		inc $37		                inc ed_cur
.aa6a		d0 02		bne $aa6e	                bne +
.aa6c		e6 38		inc $38		                inc ed_cur+1
.aa6e						+
.aa6e		20 91 8a	jsr $8a91	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.aa71		20 cb 87	jsr $87cb	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.aa74		ca		dex		                dex
.aa75		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.aa76		a5 0c		lda $0c		                lda cib
.aa78		95 00		sta $00,x	                sta 0,x
.aa7a		a5 0d		lda $0d		                lda cib+1
.aa7c		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aa7e		20 f8 93	jsr $93f8	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aa81		ca		dex		                dex
.aa82		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aa83		a5 0e		lda $0e		                lda ciblen
.aa85		95 00		sta $00,x	                sta 0,x
.aa87		a5 0f		lda $0f		                lda ciblen+1
.aa89		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aa8b		20 93 8d	jsr $8d93	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.aa8e		18		clc		                clc
.aa8f		a5 00		lda $00		                lda cp
.aa91		65 0e		adc $0e		                adc ciblen
.aa93		85 00		sta $00		                sta cp
.aa95		90 06		bcc $aa9d	                bcc +
.aa97		a5 01		lda $01		                lda cp+1
.aa99		65 0f		adc $0f		                adc ciblen+1
.aa9b		85 01		sta $01		                sta cp+1
.aa9d						+
.aa9d		20 98 8e	jsr $8e98	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.aaa0		20 e2 93	jsr $93e2	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.aaa3		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+
.aaa6		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.aaa9		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.aaac		a5 0e		lda $0e		                lda ciblen
.aaae		95 02		sta $02,x	                sta 2,x
.aab0		a5 0f		lda $0f		                lda ciblen+1
.aab2		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.aab4		20 e2 93	jsr $93e2	                jsr xt_store            ; ! ( addr-t u-t here )
.aab7		20 69 85	jsr $8569	                jsr xt_cr
.aaba		4c 23 aa	jmp $aa23	                jmp _next_string_loop
.aabd						ed_cmd_d:
.aabd		fa		plx		                plx
.aabe		20 05 ad	jsr $ad05	                jsr ed_have_text
.aac1		20 5a ad	jsr $ad5a	                jsr ed_no_line_zero
.aac4		b5 00		lda $00,x	                lda 0,x
.aac6		15 01		ora $01,x	                ora 1,x
.aac8		d0 08		bne $aad2	                bne +
.aaca		20 98 8e	jsr $8e98	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.aacd		20 0f ab	jsr $ab0f	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.aad0		80 33		bra $ab05	                bra _cmd_d_done
.aad2						+
.aad2		20 10 ad	jsr $ad10	                jsr ed_is_valid_line      ; result is in C flag
.aad5		b0 03		bcs $aada	                bcs _cmd_d_loop
.aad7		4c e2 ac	jmp $ace2	                jmp ed_error_2drop
.aada						_cmd_d_loop:
.aada		20 75 95	jsr $9575	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.aadd		20 7c 8a	jsr $8a7c	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.aae0		b5 00		lda $00,x	                lda 0,x
.aae2		15 01		ora $01,x	                ora 1,x
.aae4		d0 0d		bne $aaf3	                bne _cmd_d_done_with_flag
.aae6		e8		inx		                inx
.aae7		e8		inx		                inx                     ; Get rid of the flag from >
.aae8		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.aaeb		20 0f ab	jsr $ab0f	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.aaee		20 70 8e	jsr $8e70	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.aaf1		80 e7		bra $aada	                bra _cmd_d_loop
.aaf3						_cmd_d_done_with_flag:
.aaf3		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.aaf4		e8		inx		                inx
.aaf5		b5 02		lda $02,x	                lda 2,x
.aaf7		d0 02		bne $aafb	                bne +
.aaf9		d6 03		dec $03,x	                dec 3,x
.aafb						+
.aafb		d6 02		dec $02,x	                dec 2,x
.aafd		b5 02		lda $02,x	                lda 2,x
.aaff		85 37		sta $37		                sta ed_cur
.ab01		b5 03		lda $03,x	                lda 3,x
.ab03		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.ab05						_cmd_d_done:
.ab05		a9 40		lda #$40	                lda #%01000000
.ab07		04 39		tsb $39		                tsb ed_flags
.ab09		20 69 85	jsr $8569	                jsr xt_cr
.ab0c		4c 07 aa	jmp $aa07	                jmp ed_next_command
.ab0f						_cmd_d_common:
.ab0f		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.ab12		20 68 ad	jsr $ad68	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.ab15		20 90 89	jsr $8990	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.ab18		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.ab1b		20 70 8e	jsr $8e70	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.ab1e		20 68 ad	jsr $ad68	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.ab21		20 e2 93	jsr $93e2	                jsr xt_store            ; ! ( addr-t u-t )
.ab24		60		rts		                rts
.ab25						ed_cmd_equ:
.ab25		fa		plx		                plx
.ab26		a5 35		lda $35		                lda ed_head
.ab28		05 36		ora $36		                ora ed_head+1
.ab2a		d0 08		bne $ab34	                bne _cmd_equ_have_text
.ab2c		ca		dex		                dex
.ab2d		ca		dex		                dex
.ab2e		74 00		stz $00,x	                stz 0,x
.ab30		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.ab32		80 21		bra $ab55	                bra _cmd_equ_done
.ab34						_cmd_equ_have_text:
.ab34		20 5a ad	jsr $ad5a	                jsr ed_no_line_zero
.ab37		24 39		bit $39		                bit ed_flags
.ab39		30 0c		bmi $ab47	                bmi _cmd_equ_have_para
.ab3b		ca		dex		                dex
.ab3c		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.ab3d		a5 37		lda $37		                lda ed_cur
.ab3f		95 00		sta $00,x	                sta 0,x
.ab41		a5 38		lda $38		                lda ed_cur+1
.ab43		95 01		sta $01,x	                sta 1,x
.ab45		80 0e		bra $ab55	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.ab47						_cmd_equ_have_para:
.ab47		b5 00		lda $00,x	                lda 0,x
.ab49		15 01		ora $01,x	                ora 1,x
.ab4b		d0 05		bne $ab52	                bne _cmd_equ_two_paras
.ab4d		20 98 8e	jsr $8e98	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.ab50		80 03		bra $ab55	                bra _cmd_equ_done
.ab52						_cmd_equ_two_paras:
.ab52		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.ab55						_cmd_equ_done:
.ab55		20 69 85	jsr $8569	                jsr xt_cr               ; number goes on new line
.ab58		20 aa 96	jsr $96aa	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.ab5b		20 69 85	jsr $8569	                jsr xt_cr
.ab5e		4c 07 aa	jmp $aa07	                jmp ed_next_command
.ab61						ed_cmd_f:
.ab61		fa		plx		                plx
.ab62		24 39		bit $39		                bit ed_flags
.ab64		30 17		bmi $ab7d	                bmi _cmd_f_have_para
.ab66		20 69 85	jsr $8569	                jsr xt_cr
.ab69		20 36 95	jsr $9536	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.ab6c		20 1e 91	jsr $911e	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.ab6f		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.ab72		20 aa 96	jsr $96aa	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.ab75		20 bb 9c	jsr $9cbb	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.ab78		20 81 90	jsr $9081	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.ab7b		80 11		bra $ab8e	                bra _cmd_f_done
.ab7d						_cmd_f_have_para:
.ab7d		20 98 8e	jsr $8e98	                jsr xt_over
.ab80		20 69 85	jsr $8569	                jsr xt_cr
.ab83		20 aa 96	jsr $96aa	                jsr xt_u_dot
.ab86		b5 02		lda $02,x	                lda 2,x
.ab88		95 06		sta $06,x	                sta 6,x
.ab8a		b5 03		lda $03,x	                lda 3,x
.ab8c		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.ab8e						_cmd_f_done:
.ab8e		20 69 85	jsr $8569	                jsr xt_cr
.ab91		4c 07 aa	jmp $aa07	                jmp ed_next_command
.ab94						ed_cmd_i:
.ab94		fa		plx		                plx
.ab95		e8		inx		                inx
.ab96		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.ab97		24 39		bit $39		                bit ed_flags
.ab99		30 08		bmi $aba3	                bmi _cmd_i_have_para
.ab9b		a5 37		lda $37		                lda ed_cur
.ab9d		95 00		sta $00,x	                sta 0,x
.ab9f		a5 38		lda $38		                lda ed_cur+1
.aba1		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.aba3						_cmd_i_have_para:
.aba3		b5 00		lda $00,x	                lda 0,x
.aba5		15 01		ora $01,x	                ora 1,x
.aba7		f0 09		beq $abb2	                beq _cmd_i_done
.aba9		20 70 8e	jsr $8e70	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.abac		20 37 9e	jsr $9e37	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.abaf		20 3f 8d	jsr $8d3f	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.abb2						_cmd_i_done:
.abb2		4c 1d aa	jmp $aa1d	                jmp ed_entry_cmd_i
.abb5						ed_cmd_n:
.abb5		fa		plx		                plx
.abb6		a9 01		lda #$01	                lda #%00000001
.abb8		04 39		tsb $39		                tsb ed_flags
.abba		80 05		bra $abc1	                bra ed_cmd_p_entry_for_cmd_n
.abbc						ed_cmd_p:
.abbc		fa		plx		                plx
.abbd						ed_cmd_p_from_external:
.abbd		a9 01		lda #$01	                lda #%00000001
.abbf		14 39		trb $39		                trb ed_flags
.abc1						ed_cmd_p_entry_for_cmd_n:
.abc1		20 05 ad	jsr $ad05	                jsr ed_have_text
.abc4		20 5a ad	jsr $ad5a	                jsr ed_no_line_zero
.abc7		20 69 85	jsr $8569	                jsr xt_cr
.abca		b5 00		lda $00,x	                lda 0,x
.abcc		15 01		ora $01,x	                ora 1,x
.abce		d0 10		bne $abe0	                bne _cmd_p_loop
.abd0		b5 02		lda $02,x	                lda 2,x
.abd2		85 37		sta $37		                sta ed_cur
.abd4		b5 03		lda $03,x	                lda 3,x
.abd6		85 38		sta $38		                sta ed_cur+1
.abd8		20 98 8e	jsr $8e98	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.abdb		20 09 ac	jsr $ac09	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.abde		80 26		bra $ac06	                bra _cmd_p_all_done
.abe0						_cmd_p_loop:
.abe0		20 75 95	jsr $9575	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.abe3		20 7c 8a	jsr $8a7c	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.abe6		b5 00		lda $00,x	                lda 0,x
.abe8		15 01		ora $01,x	                ora 1,x
.abea		d0 10		bne $abfc	                bne _cmd_p_done
.abec		e8		inx		                inx
.abed		e8		inx		                inx                     ; Get rid of the flag from >
.abee		20 98 8e	jsr $8e98	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.abf1		20 09 ac	jsr $ac09	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.abf4		f6 02		inc $02,x	                inc 2,x
.abf6		d0 02		bne $abfa	                bne +
.abf8		f6 03		inc $03,x	                inc 3,x
.abfa						+
.abfa		80 e4		bra $abe0	                bra _cmd_p_loop
.abfc						_cmd_p_done:
.abfc		e8		inx		                inx
.abfd		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.abfe		b5 00		lda $00,x	                lda 0,x
.ac00		85 37		sta $37		                sta ed_cur
.ac02		b5 01		lda $01,x	                lda 1,x
.ac04		85 38		sta $38		                sta ed_cur+1
.ac06						_cmd_p_all_done:
.ac06		4c 07 aa	jmp $aa07	                jmp ed_next_command
.ac09						_cmd_p_common:
.ac09		a5 39		lda $39		                lda ed_flags
.ac0b		4a		lsr a		                lsr                     ; bit 0 now in carry
.ac0c		90 0b		bcc $ac19	                bcc _cmd_p_common_no_num
.ac0e		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.ac11		20 aa 96	jsr $96aa	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.ac14		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ac16		20 3b 88	jsr $883b	                jsr emit_a
.ac19						_cmd_p_common_no_num:
.ac19		20 68 ad	jsr $ad68	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.ac1c		20 a8 ad	jsr $ada8	                jsr ed_print_addr
.ac1f		60		rts		                rts
.ac20						ed_cmd_q:
.ac20		fa		plx		                plx
.ac21		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.ac23		50 03		bvc $ac28	                bvc +
.ac25		4c e2 ac	jmp $ace2	                jmp ed_error_2drop
.ac28						+
.ac28		4c 0e aa	jmp $aa0e	                jmp ed_all_done            ; can't fall thru because of PLX
.ac2b						ed_cmd_qq:
.ac2b		fa		plx		                plx
.ac2c		4c 0e aa	jmp $aa0e	                jmp ed_all_done
.ac2f						ed_cmd_w:
.ac2f		fa		plx		                plx
.ac30		20 05 ad	jsr $ad05	                jsr ed_have_text
.ac33		24 39		bit $39		                bit ed_flags
.ac35		30 13		bmi $ac4a	                bmi _cmd_w_have_para
.ac37		b5 06		lda $06,x	                lda 6,x
.ac39		15 07		ora $07,x	                ora 7,x
.ac3b		d0 03		bne $ac40	                bne +
.ac3d		4c e2 ac	jmp $ace2	                jmp ed_error_2drop
.ac40						+
.ac40		b5 06		lda $06,x	                lda 6,x
.ac42		95 02		sta $02,x	                sta 2,x
.ac44		b5 07		lda $07,x	                lda 7,x
.ac46		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.ac48		80 08		bra $ac52	                bra _cmd_w_para_ready
.ac4a						_cmd_w_have_para:
.ac4a		b5 02		lda $02,x	                lda 2,x
.ac4c		95 06		sta $06,x	                sta 6,x
.ac4e		b5 03		lda $03,x	                lda 3,x
.ac50		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ac52						_cmd_w_para_ready:
.ac52		a9 35		lda #$35	                lda #<ed_head
.ac54		95 00		sta $00,x	                sta 0,x
.ac56		a9 00		lda #$00	                lda #>ed_head
.ac58		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ac5a		20 98 8e	jsr $8e98	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ac5d		20 36 95	jsr $9536	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ac60						_cmd_w_loop:
.ac60		20 90 89	jsr $8990	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ac63		b5 00		lda $00,x	                lda 0,x
.ac65		15 01		ora $01,x	                ora 1,x
.ac67		f0 55		beq $acbe	                beq _cmd_w_eol
.ac69		20 75 95	jsr $9575	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ac6c		20 5f 96	jsr $965f	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ac6f		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ac72		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ac75		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ac78		20 90 89	jsr $8990	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ac7b		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ac7e		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ac81		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ac84		20 90 89	jsr $8990	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ac87		20 bb 9c	jsr $9cbb	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ac8a		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ac8d		20 1e 91	jsr $911e	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ac90		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ac93		20 36 95	jsr $9536	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ac96		20 93 8d	jsr $8d93	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ac99		20 81 90	jsr $9081	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ac9c		20 e5 95	jsr $95e5	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ac9f		20 bb 9c	jsr $9cbb	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.aca2		20 e6 8f	jsr $8fe6	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.aca5		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.aca8		ca		dex		                dex
.aca9		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.acaa		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.acac		95 00		sta $00,x	                sta 0,x
.acae		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.acb0		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.acb3		20 e2 93	jsr $93e2	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.acb6		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.acb9		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.acbc		80 a2		bra $ac60	                bra _cmd_w_loop
.acbe						_cmd_w_eol:
.acbe		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.acc1		20 81 90	jsr $9081	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.acc4		20 77 8d	jsr $8d77	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.acc7		b5 00		lda $00,x	                lda 0,x
.acc9		95 04		sta $04,x	                sta 4,x
.accb		b5 01		lda $01,x	                lda 1,x
.accd		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.accf		20 69 85	jsr $8569	                jsr xt_cr
.acd2		20 cb 87	jsr $87cb	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.acd5		20 aa 96	jsr $96aa	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.acd8		20 69 85	jsr $8569	                jsr xt_cr
.acdb		a9 40		lda #$40	                lda #%01000000
.acdd		14 39		trb $39		                trb ed_flags
.acdf		4c 07 aa	jmp $aa07	                jmp ed_next_command
.ace2						ed_error_2drop:
.ace2		e8		inx		                inx
.ace3		e8		inx		                inx                     ; drop through to _error_1drop
.ace4						ed_error_1drop:
.ace4		e8		inx		                inx
.ace5		e8		inx		                inx                     ; drop through to _error
.ace6						ed_error:
.ace6		20 69 85	jsr $8569	                jsr xt_cr
.ace9		a9 3f		lda #$3f	                lda #'?'
.aceb		20 3b 88	jsr $883b	                jsr emit_a
.acee		20 69 85	jsr $8569	                jsr xt_cr
.acf1		4c 15 a8	jmp $a815	                jmp ed_input_loop
.acf4						ed_get_input:
.acf4		20 cf 90	jsr $90cf	                jsr xt_refill           ;  ( addr-t u-t f )
.acf7		b5 00		lda $00,x	                lda 0,x
.acf9		15 01		ora $01,x	                ora 1,x
.acfb		d0 05		bne $ad02	                bne +
.acfd		7a		ply		                ply
.acfe		7a		ply		                ply
.acff		4c e4 ac	jmp $ace4	                jmp ed_error_1drop
.ad02						+
.ad02		e8		inx		                inx
.ad03		e8		inx		                inx
.ad04		60		rts		                rts
.ad05						ed_have_text:
.ad05		a5 35		lda $35		                lda ed_head
.ad07		05 36		ora $36		                ora ed_head+1
.ad09		d0 04		bne $ad0f	                bne +
.ad0b		7a		ply		                ply
.ad0c		7a		ply		                ply
.ad0d		80 d7		bra $ace6	                bra ed_error
.ad0f						+
.ad0f		60		rts		                rts
.ad10						ed_is_valid_line:
.ad10		38		sec		                sec                             ; default is legal line number
.ad11		b5 00		lda $00,x	                lda 0,x
.ad13		15 01		ora $01,x	                ora 1,x
.ad15		f0 19		beq $ad30	                beq _is_valid_line_nope_zero    ; ( n )
.ad17		20 cb 87	jsr $87cb	                jsr xt_dup                      ; DUP ( n n )
.ad1a		20 32 ad	jsr $ad32	                jsr ed_last_line                  ; ( n n last )
.ad1d		20 f8 93	jsr $93f8	                jsr xt_swap                     ; SWAP ( n last n )
.ad20		20 95 8b	jsr $8b95	                jsr xt_less_than                ; < ( n f )
.ad23		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ad25		15 01		ora $01,x	                ora 1,x
.ad27		d0 05		bne $ad2e	                bne _is_valid_line_too_small
.ad29		e8		inx		                inx
.ad2a		e8		inx		                inx                     ; DROP flag ( n )
.ad2b		38		sec		                sec                     ; Who knows what's happened to C by now
.ad2c		80 03		bra $ad31	                bra _is_valid_line_done ; only one exit from this routine
.ad2e						_is_valid_line_too_small:
.ad2e		e8		inx		                inx
.ad2f		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ad30						_is_valid_line_nope_zero:
.ad30		18		clc		                clc                     ; drop through to _is_valid_line_done
.ad31						_is_valid_line_done:
.ad31		60		rts		                rts
.ad32						ed_last_line:
.ad32		64 25		stz $25		                stz tmp1
.ad34		64 26		stz $26		                stz tmp1+1
.ad36		ca		dex		                dex
.ad37		ca		dex		                dex                     ; ( ? )
.ad38		a9 35		lda #$35	                lda #<ed_head
.ad3a		95 00		sta $00,x	                sta 0,x
.ad3c		a9 00		lda #$00	                lda #>ed_head
.ad3e		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.ad40						_last_line_loop:
.ad40		20 90 89	jsr $8990	                jsr xt_fetch            ; ( addr | 0 )
.ad43		b5 00		lda $00,x	                lda 0,x
.ad45		15 01		ora $01,x	                ora 1,x
.ad47		f0 08		beq $ad51	                beq _last_line_done
.ad49		e6 25		inc $25		                inc tmp1
.ad4b		d0 02		bne $ad4f	                bne +
.ad4d		e6 26		inc $26		                inc tmp1+1
.ad4f						+
.ad4f		80 ef		bra $ad40	                bra _last_line_loop
.ad51						_last_line_done:
.ad51		a5 25		lda $25		                lda tmp1
.ad53		95 00		sta $00,x	                sta 0,x
.ad55		a5 26		lda $26		                lda tmp1+1
.ad57		95 01		sta $01,x	                sta 1,x                 ; ( u )
.ad59		60		rts		                rts
.ad5a						ed_no_line_zero:
.ad5a		b5 02		lda $02,x	                lda 2,x
.ad5c		15 03		ora $03,x	                ora 3,x
.ad5e		d0 07		bne $ad67	                bne _no_line_zero_done
.ad60		24 39		bit $39		                bit ed_flags
.ad62		10 03		bpl $ad67	                bpl _no_line_zero_done
.ad64		4c e2 ac	jmp $ace2	                jmp ed_error_2drop
.ad67						_no_line_zero_done:
.ad67		60		rts		                rts
.ad68						ed_num_to_addr:
.ad68		ca		dex		                dex
.ad69		ca		dex		                dex                     ; ( u ? )
.ad6a		a9 35		lda #$35	                lda #<ed_head
.ad6c		95 00		sta $00,x	                sta 0,x
.ad6e		a9 00		lda #$00	                lda #>ed_head
.ad70		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.ad72		b5 02		lda $02,x	                lda 2,x
.ad74		15 03		ora $03,x	                ora 3,x
.ad76		d0 05		bne $ad7d	                bne _num_to_addr_loop
.ad78		20 c3 8d	jsr $8dc3	                jsr xt_nip              ; ( addr-h )
.ad7b		80 21		bra $ad9e	                bra _num_to_addr_done
.ad7d						_num_to_addr_loop:
.ad7d		20 90 89	jsr $8990	                jsr xt_fetch            ; @ ( u addr1 )
.ad80		b5 00		lda $00,x	                lda 0,x
.ad82		15 01		ora $01,x	                ora 1,x
.ad84		d0 05		bne $ad8b	                bne +
.ad86		20 c3 8d	jsr $8dc3	                jsr xt_nip              ; NIP ( addr1 )
.ad89		80 13		bra $ad9e	                bra _num_to_addr_done
.ad8b						+
.ad8b		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( addr1 u )
.ad8e		20 70 8e	jsr $8e70	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.ad91		b5 00		lda $00,x	                lda 0,x
.ad93		15 01		ora $01,x	                ora 1,x
.ad95		f0 05		beq $ad9c	                beq _num_to_addr_finished
.ad97		20 f8 93	jsr $93f8	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.ad9a		80 e1		bra $ad7d	                bra _num_to_addr_loop
.ad9c						_num_to_addr_finished:
.ad9c		e8		inx		                inx
.ad9d		e8		inx		                inx                     ; ( addr )
.ad9e						_num_to_addr_done:
.ad9e		60		rts		                rts
.ad9f						ed_para1_to_cur:
.ad9f		b5 02		lda $02,x	                lda 2,x
.ada1		85 37		sta $37		                sta ed_cur
.ada3		b5 03		lda $03,x	                lda 3,x
.ada5		85 38		sta $38		                sta ed_cur+1
.ada7		60		rts		                rts
.ada8						ed_print_addr:
.ada8		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.adab		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; ( addr+2 )
.adae		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( addr+2 addr+2 )
.adb1		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.adb4		20 7c 8e	jsr $8e7c	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.adb7		20 90 89	jsr $8990	                jsr xt_fetch            ; ( addr+2 u-s )
.adba		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( u-s addr+2 )
.adbd		20 90 89	jsr $8990	                jsr xt_fetch            ; ( u-s addr-s )
.adc0		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( addr-s u-s )
.adc3		20 7f 96	jsr $967f	                jsr xt_type
.adc6		20 69 85	jsr $8569	                jsr xt_cr
.adc9		60		rts		                rts
>adca		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>add2		71 51 00
.add5						ed_cmd_table:
>add5		1a aa 61 ab 94 ab bd aa		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>addd		bc ab b5 ab
>ade1		25 ab 2f ac 20 ac 2b ac		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ade9						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ade9						xt_blk:
.ade9		a9 04		lda #$04	                lda #blk_offset
.adeb		4c bf d6	jmp $d6bf	                jmp push_upvar_tos
.adee						z_blk:
.adee						xt_blkbuffer:
.adee		ca		dex		                dex
.adef		ca		dex		                dex
.adf0		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.adf2		b1 08		lda ($08),y	                lda (up),y
.adf4		95 00		sta $00,x	                sta 0,x
.adf6		c8		iny		                iny             ; Move along to the next byte
.adf7		b1 08		lda ($08),y	                lda (up),y
.adf9		95 01		sta $01,x	                sta 1,x
.adfb		60		rts		z_blkbuffer:    rts
.adfc						xt_block:
.adfc		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.adfe		b1 08		lda ($08),y	                lda (up),y
.ae00		d5 00		cmp $00,x	                cmp 0,x
.ae02		d0 0f		bne $ae13	                bne _not_in_buffer
.ae04		c8		iny		                iny
.ae05		b1 08		lda ($08),y	                lda (up),y
.ae07		d5 01		cmp $01,x	                cmp 1,x
.ae09		d0 08		bne $ae13	                bne _not_in_buffer
.ae0b		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae0d		b1 08		lda ($08),y	                lda (up),y
.ae0f		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ae11		d0 30		bne $ae43	                bne _done       ; It's already in the buffer and in use.
.ae13						_not_in_buffer:
.ae13		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae15		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ae17		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ae19		d0 0c		bne $ae27	                bne _buffer_available ; Unused or not dirty = available
.ae1b		20 ee ad	jsr $adee	                jsr xt_blkbuffer
.ae1e		20 f8 af	jsr $aff8	                jsr xt_buffblocknum
.ae21		20 90 89	jsr $8990	                jsr xt_fetch
.ae24		20 e5 af	jsr $afe5	                jsr xt_block_write
.ae27						_buffer_available:
.ae27		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae29		b5 00		lda $00,x	                lda 0,x
.ae2b		91 08		sta ($08),y	                sta (up),y
.ae2d		c8		iny		                iny
.ae2e		b5 01		lda $01,x	                lda 1,x
.ae30		91 08		sta ($08),y	                sta (up),y
.ae32		20 ee ad	jsr $adee	                jsr xt_blkbuffer
.ae35		20 f8 93	jsr $93f8	                jsr xt_swap
.ae38		20 cd af	jsr $afcd	                jsr xt_block_read
.ae3b		a9 01		lda #$01	                lda #1
.ae3d		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae3f		91 08		sta ($08),y	                sta (up),y
.ae41		ca		dex		                dex
.ae42		ca		dex		                dex
.ae43						_done:
.ae43		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ae45		b1 08		lda ($08),y	                lda (up),y
.ae47		95 00		sta $00,x	                sta 0,x
.ae49		c8		iny		                iny
.ae4a		b1 08		lda ($08),y	                lda (up),y
.ae4c		95 01		sta $01,x	                sta 1,x
.ae4e		60		rts		z_block:        rts
.ae4f						xt_block_c65_init:
=0						io_blk_status = 0
=0						io_blk_action = 0
=0						io_blk_number = 0
=0						io_blk_buffer = 0
.ae4f		a9 ff		lda #$ff	                lda #$ff
.ae51		8d 11 f0	sta $f011	                sta io_blk_status
.ae54		a9 00		lda #$00	                lda #$0
.ae56		8d 10 f0	sta $f010	                sta io_blk_action
.ae59		ad 11 f0	lda $f011	                lda io_blk_status      ; $0 if OK, $ff otherwise
.ae5c		49 ff		eor #$ff	                eor #$ff            ; invert to forth true/false
.ae5e		ca		dex		                dex
.ae5f		ca		dex		                dex
.ae60		95 00		sta $00,x	                sta 0,x             ; true ($ff) if OK, false (0) otherwise
.ae62		95 01		sta $01,x	                sta 1,x
.ae64		ca		dex		                dex
.ae65		ca		dex		                dex
.ae66		a9 89		lda #$89	                lda #<c65_blk_read
.ae68		95 00		sta $00,x	                sta 0,x
.ae6a		a9 ae		lda #$ae	                lda #>c65_blk_read
.ae6c		95 01		sta $01,x	                sta 1,x
.ae6e		20 db af	jsr $afdb	                jsr xt_block_read_vector
.ae71		20 e2 93	jsr $93e2	                jsr xt_store
.ae74		ca		dex		                dex
.ae75		ca		dex		                dex
.ae76		a9 85		lda #$85	                lda #<c65_blk_write
.ae78		95 00		sta $00,x	                sta 0,x
.ae7a		a9 ae		lda #$ae	                lda #>c65_blk_write
.ae7c		95 01		sta $01,x	                sta 1,x
.ae7e		20 f3 af	jsr $aff3	                jsr xt_block_write_vector
.ae81		20 e2 93	jsr $93e2	                jsr xt_store
.ae84						z_block_c65_init:
.ae84		60		rts		                rts
.ae85		a0 02		ldy #$02	c65_blk_write:  ldy #2
.ae87		80 02		bra $ae8b	                bra c65_blk_rw
.ae89		a0 01		ldy #$01	c65_blk_read:   ldy #1
.ae8b		b5 00		lda $00,x	c65_blk_rw:     lda 0,x                 ; ( addr blk# )
.ae8d		8d 12 f0	sta $f012	                sta io_blk_number
.ae90		b5 01		lda $01,x	                lda 1,x
.ae92		8d 13 f0	sta $f013	                sta io_blk_number+1
.ae95		b5 02		lda $02,x	                lda 2,x
.ae97		8d 14 f0	sta $f014	                sta io_blk_buffer
.ae9a		b5 03		lda $03,x	                lda 3,x
.ae9c		8d 15 f0	sta $f015	                sta io_blk_buffer+1
.ae9f		8c 10 f0	sty $f010	                sty io_blk_action       ; trigger the r/w
.aea2		e8		inx		                inx                     ; clean up stack
.aea3		e8		inx		                inx
.aea4		e8		inx		                inx
.aea5		e8		inx		                inx
.aea6		60		rts		                rts
.aea7						xt_block_ramdrive_init:
.aea7		20 03 d8	jsr $d803	                jsr underflow_1
.aeaa		20 bc a1	jsr $a1bc	                jsr sliteral_runtime
>aead		b5 ae 18 01			                .word ramdrive_code, ramdrive_code_end-ramdrive_code
.aeb1		20 28 8a	jsr $8a28	                jsr xt_evaluate
.aeb4						z_block_ramdrive_init:
.aeb4		60		rts		                rts
.aeb5						ramdrive_code:
>aeb5		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>aebd		77 61 70 20 64 65 63 69 6d 61 6c
>aec8		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>aecf		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>aed3		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>aedb		20 72 61 6d 64 72 69 76 65
>aee4		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>aeec		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>aefa		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>af02		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af12		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>af22		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>af2a		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>af39		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>af41		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af51		31 30 32 34 20 6d 6f 76 65 20 3b
>af5c		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>af64		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>af74		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>af84		20 21
>af86		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>af8e		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>af9e		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>afae		6f 72 20 21
>afb2		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>afba		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>afca		65 20 21
.afcd						ramdrive_code_end:
.afcd						xt_block_read:
.afcd		a0 32		ldy #$32	                ldy #blockread_offset
.afcf		b1 08		lda ($08),y	                lda (up),y
.afd1		85 25		sta $25		                sta tmp1
.afd3		c8		iny		                iny
.afd4		b1 08		lda ($08),y	                lda (up),y
.afd6		85 26		sta $26		                sta tmp1+1
.afd8		6c 25 00	jmp ($0025)	                jmp (tmp1)
.afdb						z_block_read:
.afdb						xt_block_read_vector:
.afdb		a9 32		lda #$32	                lda #blockread_offset
.afdd		4c bf d6	jmp $d6bf	                jmp push_upvar_tos
.afe0						z_block_read_vector:
.afe0						xt_block_word_error:
.afe0		a9 0c		lda #$0c	                lda #err_blockwords
.afe2		4c 19 d8	jmp $d819	                jmp error       ; no RTS needed
.afe5						z_block_word_error:
.afe5						xt_block_write:
.afe5		a0 34		ldy #$34	                ldy #blockwrite_offset
.afe7		b1 08		lda ($08),y	                lda (up),y
.afe9		85 25		sta $25		                sta tmp1
.afeb		c8		iny		                iny
.afec		b1 08		lda ($08),y	                lda (up),y
.afee		85 26		sta $26		                sta tmp1+1
.aff0		6c 25 00	jmp ($0025)	                jmp (tmp1)
.aff3						z_block_write:
.aff3						xt_block_write_vector:
.aff3		a9 34		lda #$34	                lda #blockwrite_offset
.aff5		4c bf d6	jmp $d6bf	                jmp push_upvar_tos
.aff8						z_block_write_vector:
.aff8						xt_buffblocknum:
.aff8		a9 2e		lda #$2e	                lda #buffblocknum_offset
.affa		4c bf d6	jmp $d6bf	                jmp push_upvar_tos
.affd						z_buffblocknum:
.affd						xt_buffer:
.affd		a0 30		ldy #$30	                ldy #buffstatus_offset
.afff		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b001		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b003		d0 0c		bne $b011	                bne _buffer_available ; Unused or not dirty = available
.b005		20 ee ad	jsr $adee	                jsr xt_blkbuffer
.b008		20 f8 af	jsr $aff8	                jsr xt_buffblocknum
.b00b		20 90 89	jsr $8990	                jsr xt_fetch
.b00e		20 e5 af	jsr $afe5	                jsr xt_block_write
.b011						_buffer_available:
.b011		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.b013		b5 00		lda $00,x	                lda 0,x
.b015		91 08		sta ($08),y	                sta (up),y
.b017		c8		iny		                iny
.b018		b5 01		lda $01,x	                lda 1,x
.b01a		91 08		sta ($08),y	                sta (up),y
.b01c		a9 01		lda #$01	                lda #1
.b01e		a0 30		ldy #$30	                ldy #buffstatus_offset
.b020		91 08		sta ($08),y	                sta (up),y
.b022						_done:
.b022		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.b024		b1 08		lda ($08),y	                lda (up),y
.b026		95 00		sta $00,x	                sta 0,x
.b028		c8		iny		                iny
.b029		b1 08		lda ($08),y	                lda (up),y
.b02b		95 01		sta $01,x	                sta 1,x
.b02d		60		rts		z_buffer:       rts
.b02e						xt_buffstatus:
.b02e		a9 30		lda #$30	                lda #buffstatus_offset
.b030		4c bf d6	jmp $d6bf	                jmp push_upvar_tos
.b033						z_buffstatus:
.b033						xt_empty_buffers:
.b033		a0 30		ldy #$30	                ldy #buffstatus_offset
.b035		a9 00		lda #$00	                lda #0
.b037		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b039						z_empty_buffers:
.b039		60		rts		                rts
.b03a						xt_flush:
.b03a		20 95 b0	jsr $b095	                jsr xt_save_buffers
.b03d		a0 30		ldy #$30	                ldy #buffstatus_offset
.b03f		a9 00		lda #$00	                lda #0
.b041		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b043						z_flush:
.b043		60		rts		                rts
.b044						xt_list:
.b044		20 03 d8	jsr $d803	                jsr underflow_1
.b047		20 b0 b0	jsr $b0b0	                jsr xt_scr
.b04a		20 e2 93	jsr $93e2	                jsr xt_store
.b04d		20 50 b1	jsr $b150	                jsr xt_editor_l
.b050		60		rts		z_list:         rts
.b051						xt_load:
.b051		20 03 d8	jsr $d803	                jsr underflow_1
.b054		a0 05		ldy #$05	                ldy #blk_offset+1
.b056		b1 08		lda ($08),y	                lda (up),y
.b058		48		pha		                pha
.b059		88		dey		                dey
.b05a		b1 08		lda ($08),y	                lda (up),y
.b05c		48		pha		                pha
.b05d		b5 00		lda $00,x	                lda 0,x
.b05f		91 08		sta ($08),y	                sta (up),y
.b061		c8		iny		                iny
.b062		b5 01		lda $01,x	                lda 1,x
.b064		91 08		sta ($08),y	                sta (up),y
.b066		20 fc ad	jsr $adfc	                jsr xt_block
.b069		ca		dex		                dex
.b06a		ca		dex		                dex
.b06b		a9 04		lda #$04	                lda #4
.b06d		95 01		sta $01,x	                sta 1,x
.b06f		74 00		stz $00,x	                stz 0,x
.b071		20 22 8a	jsr $8a22	                jsr load_evaluate
.b074		a0 04		ldy #$04	                ldy #blk_offset
.b076		68		pla		                pla
.b077		91 08		sta ($08),y	                sta (up),y
.b079		c8		iny		                iny
.b07a		68		pla		                pla
.b07b		91 08		sta ($08),y	                sta (up),y
.b07d		88		dey		                dey
.b07e		11 08		ora ($08),y	                ora (up),y
.b080		f0 12		beq $b094	                beq _done
.b082		ca		dex		                dex
.b083		ca		dex		                dex
.b084		a0 04		ldy #$04	                ldy #blk_offset
.b086		b1 08		lda ($08),y	                lda (up),y
.b088		95 00		sta $00,x	                sta 0,x
.b08a		c8		iny		                iny
.b08b		b1 08		lda ($08),y	                lda (up),y
.b08d		95 01		sta $01,x	                sta 1,x
.b08f		20 fc ad	jsr $adfc	                jsr xt_block
.b092		e8		inx		                inx
.b093		e8		inx		                inx
.b094						_done:
.b094		60		rts		z_load:         rts
.b095						xt_save_buffers:
.b095		a0 30		ldy #$30	                ldy #buffstatus_offset
.b097		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b099		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b09b		d0 12		bne $b0af	                bne _done       ; Either not used or not dirty = done!
.b09d		20 ee ad	jsr $adee	                jsr xt_blkbuffer
.b0a0		20 f8 af	jsr $aff8	                jsr xt_buffblocknum
.b0a3		20 90 89	jsr $8990	                jsr xt_fetch
.b0a6		20 e5 af	jsr $afe5	                jsr xt_block_write
.b0a9		a9 01		lda #$01	                lda #1
.b0ab		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0ad		91 08		sta ($08),y	                sta (up),y
.b0af						_done:
.b0af		60		rts		z_save_buffers: rts
.b0b0						xt_scr:
.b0b0		a9 06		lda #$06	                lda #scr_offset
.b0b2		4c bf d6	jmp $d6bf	                jmp push_upvar_tos
.b0b5						z_scr:
.b0b5						xt_thru:
.b0b5		20 08 d8	jsr $d808	                jsr underflow_2
.b0b8		b5 01		lda $01,x	                lda 1,x
.b0ba		48		pha		                pha
.b0bb		b5 00		lda $00,x	                lda 0,x
.b0bd		48		pha		                pha
.b0be		e8		inx		                inx
.b0bf		e8		inx		                inx
.b0c0						_thru_loop:
.b0c0		b5 01		lda $01,x	                lda 1,x
.b0c2		48		pha		                pha
.b0c3		b5 00		lda $00,x	                lda 0,x
.b0c5		48		pha		                pha
.b0c6		20 51 b0	jsr $b051	                jsr xt_load
.b0c9		68		pla		                pla
.b0ca		85 25		sta $25		                sta tmp1
.b0cc		68		pla		                pla
.b0cd		85 26		sta $26		                sta tmp1+1
.b0cf		68		pla		                pla
.b0d0		85 27		sta $27		                sta tmp2
.b0d2		68		pla		                pla
.b0d3		85 28		sta $28		                sta tmp2+1
.b0d5		c5 26		cmp $26		                cmp tmp1+1
.b0d7		d0 08		bne $b0e1	                bne _next_screen
.b0d9		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b0db		c5 25		cmp $25		                cmp tmp1
.b0dd		d0 02		bne $b0e1	                bne _next_screen
.b0df		80 18		bra $b0f9	                bra _done       ; We just did the last screen.
.b0e1						_next_screen:
.b0e1		a5 28		lda $28		                lda tmp2+1
.b0e3		48		pha		                pha
.b0e4		a5 27		lda $27		                lda tmp2
.b0e6		48		pha		                pha
.b0e7		e6 25		inc $25		                inc tmp1
.b0e9		d0 02		bne $b0ed	                bne +
.b0eb		e6 26		inc $26		                inc tmp1+1
.b0ed						+
.b0ed		ca		dex		                dex
.b0ee		ca		dex		                dex
.b0ef		a5 25		lda $25		                lda tmp1
.b0f1		95 00		sta $00,x	                sta 0,x
.b0f3		a5 26		lda $26		                lda tmp1+1
.b0f5		95 01		sta $01,x	                sta 1,x
.b0f7		80 c7		bra $b0c0	                bra _thru_loop
.b0f9						_done:
.b0f9		60		rts		z_thru:         rts
.b0fa						xt_update:
.b0fa		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0fc		b1 08		lda ($08),y	                lda (up),y
.b0fe		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b100		91 08		sta ($08),y	                sta (up),y
.b102		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b103						xt_editor_screen_helper:
.b103		20 cb 87	jsr $87cb	                jsr xt_dup
.b106		20 b0 b0	jsr $b0b0	                jsr xt_scr
.b109		20 e2 93	jsr $93e2	                jsr xt_store
.b10c		20 fd af	jsr $affd	                jsr xt_buffer
.b10f						z_editor_screen_helper:
.b10f		60		rts		                rts
.b110						xt_editor_enter_screen:
.b110		20 03 b1	jsr $b103	                jsr xt_editor_screen_helper
.b113		20 c5 87	jsr $87c5	                jsr xt_drop
.b116		64 35		stz $35		                stz ed_head
.b118						_prompt_loop:
.b118		ca		dex		                dex
.b119		ca		dex		                dex
.b11a		a5 35		lda $35		                lda ed_head
.b11c		95 00		sta $00,x	                sta 0,x
.b11e		74 01		stz $01,x	                stz 1,x
.b120		20 e3 b1	jsr $b1e3	                jsr xt_editor_o
.b123		e6 35		inc $35		                inc ed_head
.b125		a9 10		lda #$10	                lda #16
.b127		c5 35		cmp $35		                cmp ed_head
.b129		d0 ed		bne $b118	                bne _prompt_loop
.b12b						z_editor_enter_screen:
.b12b		60		rts		                rts
.b12c						xt_editor_erase_screen:
.b12c		20 03 b1	jsr $b103	                jsr xt_editor_screen_helper
.b12f		ca		dex		                dex
.b130		ca		dex		                dex
.b131		74 00		stz $00,x	                stz 0,x
.b133		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b135		95 01		sta $01,x	                sta 1,x
.b137		20 28 89	jsr $8928	                jsr xt_blank
.b13a		20 fa b0	jsr $b0fa	                jsr xt_update
.b13d						z_editor_erase_screen:
.b13d		60		rts		                rts
.b13e						xt_editor_el:
.b13e		20 ca b1	jsr $b1ca	                jsr xt_editor_line
.b141		ca		dex		                dex
.b142		ca		dex		                dex
.b143		a9 40		lda #$40	                lda #64
.b145		95 00		sta $00,x	                sta 0,x
.b147		74 01		stz $01,x	                stz 1,x
.b149		20 28 89	jsr $8928	                jsr xt_blank
.b14c		20 fa b0	jsr $b0fa	                jsr xt_update
.b14f		60		rts		z_editor_el:    rts
.b150						xt_editor_l:
.b150		ca		dex		                dex             ; Put SCR on the stack.
.b151		ca		dex		                dex
.b152		a0 06		ldy #$06	                ldy #scr_offset
.b154		b1 08		lda ($08),y	                lda (up),y
.b156		95 00		sta $00,x	                sta 0,x
.b158		c8		iny		                iny
.b159		b1 08		lda ($08),y	                lda (up),y
.b15b		95 01		sta $01,x	                sta 1,x
.b15d		20 fc ad	jsr $adfc	                jsr xt_block    ; Get the current screen.
.b160		20 69 85	jsr $8569	                jsr xt_cr
.b163		80 08		bra $b16d	                bra _after_screen_msg
.b165						_screen_msg:
>b165		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b16d						_after_screen_msg:
.b16d		20 bc a1	jsr $a1bc	                jsr sliteral_runtime
>b170		65 b1 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.b174		20 7f 96	jsr $967f	                jsr xt_type
.b177		20 b0 b0	jsr $b0b0	                jsr xt_scr
.b17a		20 90 89	jsr $8990	                jsr xt_fetch
.b17d		ca		dex		                dex
.b17e		ca		dex		                dex
.b17f		a9 04		lda #$04	                lda #4          ; four spaces
.b181		95 00		sta $00,x	                sta 0,x
.b183		74 01		stz $01,x	                stz 1,x
.b185		20 b6 96	jsr $96b6	                jsr xt_u_dot_r
.b188		64 29		stz $29		                stz tmp3
.b18a						_line_loop:
.b18a		20 69 85	jsr $8569	                jsr xt_cr
.b18d		ca		dex		                dex
.b18e		ca		dex		                dex
.b18f		ca		dex		                dex
.b190		ca		dex		                dex
.b191		74 03		stz $03,x	                stz 3,x
.b193		a5 29		lda $29		                lda tmp3
.b195		95 02		sta $02,x	                sta 2,x
.b197		74 01		stz $01,x	                stz 1,x
.b199		a9 02		lda #$02	                lda #2
.b19b		95 00		sta $00,x	                sta 0,x
.b19d		20 b6 96	jsr $96b6	                jsr xt_u_dot_r
.b1a0		20 73 93	jsr $9373	                jsr xt_space
.b1a3		20 cb 87	jsr $87cb	                jsr xt_dup
.b1a6		ca		dex		                dex
.b1a7		ca		dex		                dex
.b1a8		a9 40		lda #$40	                lda #64
.b1aa		95 00		sta $00,x	                sta 0,x
.b1ac		74 01		stz $01,x	                stz 1,x
.b1ae		20 7f 96	jsr $967f	                jsr xt_type
.b1b1		18		clc		                clc
.b1b2		a9 40		lda #$40	                lda #64
.b1b4		75 00		adc $00,x	                adc 0,x
.b1b6		95 00		sta $00,x	                sta 0,x
.b1b8		90 02		bcc $b1bc	                bcc +
.b1ba		f6 01		inc $01,x	                inc 1,x
.b1bc						+
.b1bc		e6 29		inc $29		                inc tmp3
.b1be		a5 29		lda $29		                lda tmp3
.b1c0		c9 10		cmp #$10	                cmp #16
.b1c2		d0 c6		bne $b18a	                bne _line_loop
.b1c4		20 69 85	jsr $8569	                jsr xt_cr
.b1c7		e8		inx		                inx
.b1c8		e8		inx		                inx
.b1c9		60		rts		z_editor_l:            rts
.b1ca						xt_editor_line:
.b1ca		20 03 d8	jsr $d803	                jsr underflow_1
.b1cd		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b1cf						_shift_tos_left:
.b1cf		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b1d1		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b1d3		88		dey		                dey
.b1d4		d0 f9		bne $b1cf	                bne _shift_tos_left
.b1d6		20 b0 b0	jsr $b0b0	                jsr xt_scr
.b1d9		20 90 89	jsr $8990	                jsr xt_fetch
.b1dc		20 fc ad	jsr $adfc	                jsr xt_block
.b1df		20 e6 8f	jsr $8fe6	                jsr xt_plus
.b1e2		60		rts		z_editor_line:  rts
.b1e3						xt_editor_o:
.b1e3		20 69 85	jsr $8569	                jsr xt_cr
.b1e6		20 cb 87	jsr $87cb	                jsr xt_dup
.b1e9		20 02 9e	jsr $9e02	                jsr xt_two
.b1ec		20 b6 96	jsr $96b6	                jsr xt_u_dot_r
.b1ef		20 73 93	jsr $9373	                jsr xt_space
.b1f2		a9 2a		lda #$2a	                lda #'*'
.b1f4		20 3b 88	jsr $883b	                jsr emit_a
.b1f7		20 73 93	jsr $9373	                jsr xt_space
.b1fa		20 ca b1	jsr $b1ca	                jsr xt_editor_line
.b1fd		20 cb 87	jsr $87cb	                jsr xt_dup      ; Save a copy of the line address for later.
.b200		ca		dex		                dex
.b201		ca		dex		                dex
.b202		a9 40		lda #$40	                lda #64         ; chars/line
.b204		95 00		sta $00,x	                sta 0,x
.b206		74 01		stz $01,x	                stz 1,x
.b208		20 e6 80	jsr $80e6	                jsr xt_accept
.b20b		20 cb 87	jsr $87cb	                jsr xt_dup
.b20e		20 bb 9c	jsr $9cbb	                jsr xt_not_rote ; -rot
.b211		20 e6 8f	jsr $8fe6	                jsr xt_plus
.b214		ca		dex		                dex
.b215		ca		dex		                dex
.b216		a9 40		lda #$40	                lda #64         ; chars/line
.b218		95 00		sta $00,x	                sta 0,x
.b21a		74 01		stz $01,x	                stz 1,x
.b21c		20 1e 91	jsr $911e	                jsr xt_rot
.b21f		20 77 8d	jsr $8d77	                jsr xt_minus
.b222		20 28 89	jsr $8928	                jsr xt_blank
.b225		20 fa b0	jsr $b0fa	                jsr xt_update
.b228		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b229						xt_also:
.b229		20 54 b2	jsr $b254	                jsr xt_get_order
.b22c		20 98 8e	jsr $8e98	                jsr xt_over
.b22f		20 f8 93	jsr $93f8	                jsr xt_swap
.b232		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.b235		20 5d b3	jsr $b35d	                jsr xt_set_order
.b238		60		rts		z_also:         rts
.b239						xt_definitions:
.b239		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b23b		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b23d		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b23f		91 08		sta ($08),y	                sta (up),y
.b241		60		rts		z_definitions:  rts
.b242						xt_forth:
.b242		a0 23		ldy #$23	                ldy #search_order_offset
.b244		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b246		91 08		sta ($08),y	                sta (up),y
.b248						z_forth:
.b248		60		rts		                rts
.b249						xt_get_current:
.b249		ca		dex		                dex
.b24a		ca		dex		                dex
.b24b		a0 08		ldy #$08	                ldy #current_offset
.b24d		b1 08		lda ($08),y	                lda (up),y
.b24f		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b251		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b253		60		rts		z_get_current:  rts
.b254						xt_get_order:
.b254		a0 22		ldy #$22	                ldy #num_order_offset
.b256		b1 08		lda ($08),y	                lda (up),y
.b258		85 25		sta $25		                sta tmp1
.b25a		f0 16		beq $b272	                beq _done       ; If zero, there are no wordlists.
.b25c						_loop:
.b25c		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b25e		a9 23		lda #$23	                lda #search_order_offset
.b260		18		clc		                clc
.b261		65 25		adc $25		                adc tmp1
.b263		a8		tay		                tay
.b264		ca		dex		                dex
.b265		ca		dex		                dex
.b266		b1 08		lda ($08),y	                lda (up),y
.b268		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b26a		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b26c		a9 00		lda #$00	                lda #0
.b26e		c5 25		cmp $25		                cmp tmp1
.b270		d0 ea		bne $b25c	                bne _loop
.b272						_done:
.b272		ca		dex		                dex
.b273		ca		dex		                dex
.b274		a0 22		ldy #$22	                ldy #num_order_offset
.b276		b1 08		lda ($08),y	                lda (up),y
.b278		95 00		sta $00,x	                sta 0,x
.b27a		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b27c		60		rts		z_get_order:    rts
.b27d						xt_only:
.b27d		20 4a 95	jsr $954a	                jsr xt_true
.b280		20 5d b3	jsr $b35d	                jsr xt_set_order
.b283		60		rts		z_only:         rts
.b284						xt_order:
.b284		20 69 85	jsr $8569	                jsr xt_cr
.b287		20 54 b2	jsr $b254	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.b28a		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.b28c		f0 1e		beq $b2ac	                beq _drop_done
.b28e						_have_wordlists:
.b28e		a8		tay		                tay
.b28f						_loop:
.b28f		e8		inx		                inx
.b290		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.b291		b5 00		lda $00,x	                lda 0,x
.b293		5a		phy		                phy
.b294		20 af b2	jsr $b2af	                jsr order_print_wid_string   ; internal helper function
.b297		7a		ply		                ply
.b298		88		dey		                dey
.b299		d0 f4		bne $b28f	                bne _loop
.b29b		20 73 93	jsr $9373	                jsr xt_space
.b29e		20 73 93	jsr $9373	                jsr xt_space
.b2a1		20 49 b2	jsr $b249	                jsr xt_get_current      ; ( wid )
.b2a4		b5 00		lda $00,x	                lda 0,x
.b2a6		20 af b2	jsr $b2af	                jsr order_print_wid_string
.b2a9		20 69 85	jsr $8569	                jsr xt_cr
.b2ac						_drop_done:
.b2ac		e8		inx		                inx
.b2ad		e8		inx		                inx
.b2ae						z_order:
.b2ae		60		rts		                rts
.b2af						order_print_wid_string:
.b2af		c9 04		cmp #$04	                cmp #4
.b2b1		90 09		bcc $b2bc	                bcc _output_string      ; less than 4, print a real string
.b2b3		ca		dex		                dex
.b2b4		ca		dex		                dex
.b2b5		95 00		sta $00,x	                sta 0,x
.b2b7		74 01		stz $01,x	                stz 1,x
.b2b9		4c aa 96	jmp $96aa	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.b2bc						_output_string:
.b2bc		a8		tay		                tay
.b2bd		b9 c3 b2	lda $b2c3,y	                lda _wid_data,y
.b2c0		4c 3f d8	jmp $d83f	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b2c3						_wid_data:
>b2c3		04				        .byte str_wid_forth            ; WID 0: "Forth"
>b2c4		05				        .byte str_wid_editor           ; WID 1: "Editor"
>b2c5		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>b2c6		07				        .byte str_wid_root             ; WID 3: "Root"
.b2c7						xt_previous:
.b2c7		20 54 b2	jsr $b254	                jsr xt_get_order
.b2ca		20 c3 8d	jsr $8dc3	                jsr xt_nip
.b2cd		20 70 8e	jsr $8e70	                jsr xt_one_minus
.b2d0		20 5d b3	jsr $b35d	                jsr xt_set_order
.b2d3		60		rts		z_previous:     rts
.b2d4						xt_root_wordlist:
.b2d4		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b2d5		ca		dex		                dex
.b2d6		a9 03		lda #$03	                lda #3
.b2d8		95 00		sta $00,x	                sta 0,x
.b2da		74 01		stz $01,x	                stz 1,x
.b2dc						z_root_wordlist:
.b2dc		60		rts		                rts
.b2dd						xt_search_wordlist:
.b2dd		20 0d d8	jsr $d80d	                jsr underflow_3
.b2e0		a5 08		lda $08		                lda up
.b2e2		18		clc		                clc
.b2e3		69 0a		adc #$0a	                adc #wordlists_offset
.b2e5		85 27		sta $27		                sta tmp2
.b2e7		a5 09		lda $09		                lda up+1
.b2e9		69 00		adc #$00	                adc #0          ; Adding carry
.b2eb		85 28		sta $28		                sta tmp2+1
.b2ed		b5 00		lda $00,x	                lda 0,x
.b2ef		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b2f0		65 27		adc $27		                adc tmp2
.b2f2		85 27		sta $27		                sta tmp2
.b2f4		90 02		bcc $b2f8	                bcc +
.b2f6		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b2f8						+
.b2f8		e8		inx		                inx
.b2f9		e8		inx		                inx
.b2fa		b5 00		lda $00,x	                lda 0,x
.b2fc		15 01		ora $01,x	                ora 1,x
.b2fe		f0 4e		beq $b34e	                beq _done
.b300		a5 27		lda $27		                lda tmp2
.b302		05 28		ora $28		                ora tmp2+1
.b304		f0 48		beq $b34e	                beq _done
.b306		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b308		85 25		sta $25		                sta tmp1
.b30a		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b30c		d0 02		bne $b310	                bne +
.b30e		e6 28		inc $28		                inc tmp2+1
.b310						+
.b310		b2 27		lda ($27)	                lda (tmp2)
.b312		85 26		sta $26		                sta tmp1+1
.b314		20 e5 d6	jsr $d6e5	                jsr find_header_name
.b317		f0 31		beq $b34a	                beq _fail_done
.b319		e8		inx		                inx
.b31a		e8		inx		                inx
.b31b		a5 25		lda $25		                lda tmp1
.b31d		95 00		sta $00,x	                sta 0,x
.b31f		a5 26		lda $26		                lda tmp1+1
.b321		95 01		sta $01,x	                sta 1,x
.b323		20 cb 87	jsr $87cb	                jsr xt_dup              ; ( nt nt )
.b326		20 74 9c	jsr $9c74	                jsr xt_name_to_int      ; ( nt xt )
.b329		20 f8 93	jsr $93f8	                jsr xt_swap             ; ( xt nt )
.b32c		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b32e		f6 00		inc $00,x	                inc 0,x
.b330		d0 02		bne $b334	                bne +
.b332		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b334						+
.b334		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b336		29 04		and #$04	                and #IM
.b338		d0 08		bne $b342	                bne _immediate          ; bit set, we're immediate
.b33a		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b33c		95 00		sta $00,x	                sta 0,x
.b33e		95 01		sta $01,x	                sta 1,x
.b340		80 0e		bra $b350	                bra _done_nodrop
.b342						_immediate:
.b342		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b344		95 00		sta $00,x	                sta 0,x
.b346		74 01		stz $01,x	                stz 1,x
.b348		80 06		bra $b350	                bra _done_nodrop
.b34a						_fail_done:
.b34a		74 02		stz $02,x	                stz 2,x         ; failure flag
.b34c		74 03		stz $03,x	                stz 3,x
.b34e						_done:
.b34e		e8		inx		                inx
.b34f		e8		inx		                inx
.b350						_done_nodrop:
.b350						z_search_wordlist:
.b350		60		rts		                rts
.b351						xt_set_current:
.b351		20 03 d8	jsr $d803	                jsr underflow_1
.b354		a0 08		ldy #$08	                ldy #current_offset
.b356		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b358		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b35a		e8		inx		                inx
.b35b		e8		inx		                inx
.b35c		60		rts		z_set_current:  rts
.b35d						xt_set_order:
.b35d		a9 ff		lda #$ff	                lda #$FF
.b35f		d5 01		cmp $01,x	                cmp 1,x
.b361		d0 12		bne $b375	                bne _start
.b363		d5 00		cmp $00,x	                cmp 0,x
.b365		d0 0e		bne $b375	                bne _start
.b367		ca		dex		                dex             ; Make room for the count.
.b368		ca		dex		                dex
.b369		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b36b		a9 03		lda #$03	                lda #3
.b36d		95 02		sta $02,x	                sta 2,x
.b36f		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b371		a9 01		lda #$01	                lda #1
.b373		95 00		sta $00,x	                sta 0,x
.b375						_start:
.b375		a0 22		ldy #$22	                ldy #num_order_offset
.b377		b5 00		lda $00,x	                lda 0,x
.b379		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b37b		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b37d		e8		inx		                inx             ; Drop the count off the data stack.
.b37e		e8		inx		                inx
.b37f		a5 25		lda $25		                lda tmp1
.b381		f0 0d		beq $b390	                beq _done       ; If zero, there are no wordlists.
.b383		a0 23		ldy #$23	                ldy #search_order_offset
.b385						_loop:
.b385		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b387		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b389		c8		iny		                iny
.b38a		e8		inx		                inx
.b38b		e8		inx		                inx
.b38c		c6 25		dec $25		                dec tmp1
.b38e		d0 f5		bne $b385	                bne _loop
.b390						_done:
.b390		60		rts		z_set_order:    rts
.b391						xt_to_order:
.b391		20 36 95	jsr $9536	                jsr xt_to_r
.b394		20 54 b2	jsr $b254	                jsr xt_get_order
.b397		20 81 90	jsr $9081	                jsr xt_r_from
.b39a		20 f8 93	jsr $93f8	                jsr xt_swap
.b39d		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.b3a0		20 5d b3	jsr $b35d	                jsr xt_set_order
.b3a3		60		rts		z_to_order:     rts
.b3a4						xt_wordlist:
.b3a4		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b3a6		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b3a8		c9 0c		cmp #$0c	                cmp #max_wordlists
.b3aa		d0 05		bne $b3b1	                bne _ok
.b3ac		a9 0b		lda #$0b	                lda #err_wordlist
.b3ae		4c 19 d8	jmp $d819	                jmp error
.b3b1						_ok:
.b3b1		1a		inc a		                ina             ; Increment the wordlist#
.b3b2		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b3b4		ca		dex		                dex             ; and put it on the stack.
.b3b5		ca		dex		                dex
.b3b6		95 00		sta $00,x	                sta 0,x
.b3b8		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b3ba		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b3bb						cold_zp_table:
>b3bb	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b3bd	0002	8b bb				dp:         .word dictionary_start  ; Dictionary Pointer
>b3bf	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b3c1	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b3c3	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b3c5	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b3c7	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b3c9	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b3cb	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b3cd	0012	2d f0				output:     .word kernel_putc       ; vector for EMIT
>b3cf	0014	27 f0				input:      .word kernel_getc       ; vector for KEY
>b3d1	0016	00 00				havekey:    .word 0                 ; vector for KEY?
>b3d3	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b3d5	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b3d7	001c	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>b3d9	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b3da	001f					loopctrl:   .byte ?         ; Offset and flags for DO/LOOP/+LOOP control.
>b3db	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$100						lcbstack = $100
=256						loopindex = lcbstack+0      ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack+2      ; loop control block offset for limit fudge factor
>b3dc	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b3de	0023					tmptos:     .word ?         ; temporary TOS storage
>b3e0	0025					tmp1:       .word ?         ; temporary storage
>b3e2	0027					tmp2:       .word ?         ; temporary storage
>b3e4	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b3e6	002b					tohold:     .word ?         ; pointer for formatted output
>b3e8	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b3f0	0035					tmped:      .word ?,?,?     ; temporary for editors
.b3d9						cold_zp_table_end:
.b3d9						cold_user_table:
>b3d9	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b3db	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b3dd	0004	00 00				blk_offset:             .word 0         ; BLK
>b3df	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
>b3e1	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b3e2	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b3e3	000a					wordlists_offset:
>b3e3	000a	8b bb				    .word dictionary_start              ; FORTH-WORDLIST
>b3e5	000c	ea c9				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b3e7	000e	3a ca				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b3e9	0010	a9 c9				    .word root_dictionary_start         ; ROOT-WORDLIST
>b3eb	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b3f3	001a	00 00 00 00 00 00 00 00
>b3fb	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b3fc	0023					search_order_offset:
>b3fc	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b404	002b	00
>b405	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b407	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b409	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b40b	0032	e0 af				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b40d	0034	e0 af				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b40f						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b40f						oc_index_table:
>b40f		0f b6 13 b6 a7 ba a7 ba		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>b417		1b b6 21 b6 27 b6 a7 ba
>b41f		2d b6 31 b6 37 b6 a7 ba		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b427		3d b6 41 b6 45 b6 49 b6
>b42f		4e b6 52 b6 5a b6 a7 ba		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b437		61 b6 67 b6 6e b6 75 b6
>b43f		7c b6 80 b6 86 b6 a7 ba		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc__, oc1F
>b447		8c b6 90 b6 a7 ba 96 b6
>b44f		9c b6 a0 b6 a7 ba a7 ba		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b457		a8 b6 ae b6 b4 b6 ba b6
>b45f		c1 b6 c5 b6 cb b6 a7 ba		        .word oc28, oc29, oc2A, oc__, OC2C, oc2D, oc2E, oc2F
>b467		d1 b6 d5 b6 da b6 de b6
>b46f		e3 b6 e7 b6 ef b6 a7 ba		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b477		f6 b6 fe b6 05 b7 0c b7
>b47f		13 b7 17 b7 1d b7 a7 ba		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc0F
>b487		23 b7 29 b7 2f b7 49 b6
>b48f		3a b7 3e b7 a7 ba a7 ba		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b497		a7 ba 46 b7 4c b7 52 b7
>b49f		59 b7 5d b7 63 b7 a7 ba		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b4a7		69 b7 6d b7 71 b7 75 b7
>b4af		7a b7 7e b7 86 b7 a7 ba		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b4b7		a7 ba 8d b7 94 b7 9b b7
>b4bf		a2 b7 a6 b7 ac b7 a7 ba		        .word oc58, oc59, oc5A, oc__, oc__, oc__, oc5E, oc5F
>b4c7		a7 ba a7 ba b6 b7 bc b7
>b4cf		c1 b7 c5 b7 a7 ba a7 ba		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b4d7		cd b7 d3 b7 d9 b7 df b7
>b4df		e6 b7 ea b7 f0 b7 a7 ba		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b4e7		f6 b7 fc b7 00 b8 04 b8
>b4ef		09 b8 0d b8 15 b8 a7 ba		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b4f7		1c b8 23 b8 2a b8 31 b8
>b4ff		38 b8 3c b8 42 b8 a7 ba		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b507		46 b8 4d b8 53 b8 59 b8
>b50f		5e b8 62 b8 a7 ba a7 ba		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b517		6a b8 70 b8 76 b8 a7 ba
>b51f		7c b8 80 b8 86 b8 a7 ba		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b527		8a b8 8e b8 92 b8 96 b8
>b52f		9b b8 9f b8 a7 b8 a7 ba		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b537		ae b8 b5 b8 bc b8 c3 b8
>b53f		ca b8 ce b8 d4 b8 a7 ba		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b547		d8 b8 dc b8 e2 b8 e8 b8
>b54f		ed b8 f3 b8 fb b8 a7 ba		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b557		01 b9 07 b9 0d b9 13 b9
>b55f		1a b9 1e b9 24 b9 a7 ba		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b567		28 b9 2c b9 30 b9 34 b9
>b56f		39 b9 3d b9 45 b9 a7 ba		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b577		4c b9 53 b9 5a b9 61 b9
>b57f		68 b9 6c b9 72 b9 a7 ba		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b587		76 b9 7c b9 82 b9 88 b9
>b58f		8d b9 93 b9 a7 ba a7 ba		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b597		9b b9 a1 b9 a7 b9 ad b9
>b59f		b4 b9 b8 b9 be b9 a7 ba		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b5a7		c2 b9 c6 b9 ca b9 ce b9
>b5af		d3 b9 d7 b9 df b9 a7 ba		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b5b7		a7 ba e6 b9 ed b9 f4 b9
>b5bf		fb b9 ff b9 05 ba a7 ba		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b5c7		a7 ba 09 ba 0f ba 15 ba
>b5cf		1a ba 20 ba a7 ba a7 ba		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b5d7		28 ba 2e ba 34 ba 3a ba
>b5df		41 ba 45 ba 4b ba a7 ba		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b5e7		4f ba 53 ba 57 ba 5b ba
>b5ef		60 ba 64 ba 6c ba a7 ba		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b5f7		a7 ba 73 ba 7a ba 81 ba
>b5ff		88 ba 8c ba 92 ba a7 ba		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b607		a7 ba 96 ba 9c ba a2 ba
.b60f						oc_table:
>b60f		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b613		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b61b		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b621		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b627		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b62d		43 70 68 70				oc08:	.text 1*64+3, "php"
>b631		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b637		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b63d		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b641		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b645		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b649		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b64e		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b652		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b65a		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b661		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b667		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b66e		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b675		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b67c		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b680		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b686		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b68c		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b690		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b696		c5 61 73 6c 2e 78			oc1F:	.text 3*64+5, "asl.x"
>b69c		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b6a0		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b6a8		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b6ae		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b6b4		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b6ba		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b6c1		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b6c5		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b6cb		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b6d1		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b6d5		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b6da		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b6de		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b6e3		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b6e7		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b6ef		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b6f6		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b6fe		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b705		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b70c		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b713		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b717		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b71d		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b723		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b729		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b72f		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b735		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b73a		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b73e		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b746		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b74c		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b752		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b759		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b75d		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b763		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b769		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b76d		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b771		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b775		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b77a		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b77e		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b786		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b78d		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b794		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b79b		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b7a2		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b7a6		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b7ac		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b7b0		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b7b6		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b7bc		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b7c1		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b7c5		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b7cd		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b7d3		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b7d9		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b7df		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b7e6		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b7ea		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b7f0		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b7f6		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b7fc		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b800		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b804		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b809		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b80d		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b815		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b81c		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b823		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b82a		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b831		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b838		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b83c		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b842		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b846		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b84d		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b853		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b859		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b85e		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b862		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b86a		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b870		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b876		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b87c		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b880		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b886		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b88a		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b88e		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b892		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b896		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b89b		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b89f		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b8a7		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b8ae		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b8b5		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b8bc		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b8c3		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b8ca		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b8ce		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b8d4		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b8d8		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b8dc		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b8e2		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b8e8		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b8ed		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b8f3		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b8fb		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b901		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b907		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b90d		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b913		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b91a		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b91e		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b924		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b928		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b92c		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b930		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b934		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b939		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b93d		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b945		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b94c		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b953		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b95a		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b961		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b968		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b96c		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b972		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b976		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b97c		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b982		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b988		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b98d		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b993		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b99b		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b9a1		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b9a7		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b9ad		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b9b4		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b9b8		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b9be		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b9c2		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b9c6		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b9ca		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b9ce		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b9d3		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b9d7		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b9df		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b9e6		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>b9ed		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>b9f4		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>b9fb		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>b9ff		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>ba05		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>ba09		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>ba0f		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>ba15		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>ba1a		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>ba20		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>ba28		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>ba2e		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>ba34		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>ba3a		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>ba41		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>ba45		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>ba4b		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>ba4f		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>ba53		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>ba57		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>ba5b		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>ba60		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>ba64		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>ba6c		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>ba73		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>ba7a		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>ba81		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>ba88		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>ba8c		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>ba92		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>ba96		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>ba9c		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>baa2		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>baa7		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.baa9						forth_words_start:
>baa9		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bab1		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bac1		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bad1		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>bae1		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>baf1		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bb01		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>bb11		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bb21		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bb31		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bb41		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bb51		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bb61		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bb71		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bb81		78 69 74 29 20 63 72 20
.bb89						forth_words_end:
.bb89						user_words_start:
>bb89		20 20				.binary "user_words.asc"
.bb8b						user_words_end:

;******  Processing file: platform/../headers.asm

.bb8b						dictionary_start:
.bb8b						nt_drop:
>bb8b		04 10				        .byte 4, UF
>bb8d		97 bb c5 87 ca 87		        .word nt_dup, xt_drop, z_drop
>bb93		64 72 6f 70			        .text "drop"
.bb97						nt_dup:
>bb97		03 10				        .byte 3, UF
>bb99		a2 bb cb 87 d8 87		        .word nt_swap, xt_dup, z_dup
>bb9f		64 75 70			        .text "dup"
.bba2						nt_swap:
>bba2		04 10				        .byte 4, UF
>bba4		ae bb f8 93 0b 94		        .word nt_store, xt_swap, z_swap
>bbaa		73 77 61 70			        .text "swap"
.bbae						nt_store:
>bbae		01 10				        .byte 1, UF
>bbb0		b7 bb e2 93 f7 93		        .word nt_fetch, xt_store, z_store
>bbb6		21				        .text "!"
.bbb7						nt_fetch:
>bbb7		01 10				        .byte 1, UF
>bbb9		c0 bb 90 89 a2 89		        .word nt_over, xt_fetch, z_fetch
>bbbf		40				        .text "@"
.bbc0						nt_over:
>bbc0		04 10				        .byte 4, UF
>bbc2		cc bb 98 8e a5 8e		        .word nt_to_r, xt_over, z_over
>bbc8		6f 76 65 72			        .text "over"
.bbcc						nt_to_r:
>bbcc		02 11				        .byte 2, CO+UF ; native is special case
>bbce		d6 bb 36 95 49 95		        .word nt_r_from, xt_to_r, z_to_r
>bbd4		3e 72				        .text ">r"
.bbd6						nt_r_from:
>bbd6		02 01				        .byte 2, CO    ; native is special case
>bbd8		e0 bb 81 90 91 90		        .word nt_r_fetch, xt_r_from, z_r_from
>bbde		72 3e				        .text "r>"
.bbe0						nt_r_fetch:
>bbe0		02 01				        .byte 2, CO    ; native is special case
>bbe2		ea bb 6c 90 80 90		        .word nt_nip, xt_r_fetch, z_r_fetch
>bbe8		72 40				        .text "r@"
.bbea						nt_nip:
>bbea		03 10				        .byte 3, UF
>bbec		f5 bb c3 8d d0 8d		        .word nt_rot, xt_nip, z_nip
>bbf2		6e 69 70			        .text "nip"
.bbf5						nt_rot:
>bbf5		03 10				        .byte 3, UF
>bbf7		00 bc 1e 91 39 91		        .word nt_not_rote, xt_rot, z_rot
>bbfd		72 6f 74			        .text "rot"
.bc00						nt_not_rote:
>bc00		04 10				        .byte 4, UF
>bc02		0c bc bb 9c d6 9c		        .word nt_tuck, xt_not_rote, z_not_rote
>bc08		2d 72 6f 74			        .text "-rot"
.bc0c						nt_tuck:
>bc0c		04 10				        .byte 4, UF
>bc0e		18 bc 53 95 6c 95		        .word nt_comma, xt_tuck, z_tuck
>bc14		74 75 63 6b			        .text "tuck"
.bc18						nt_comma:
>bc18		01 10				        .byte 1, UF
>bc1a		21 bc da 83 f3 83		        .word nt_c_fetch, xt_comma, z_comma
>bc20		2c				        .text ","
.bc21						nt_c_fetch:
>bc21		02 10				        .byte 2, UF
>bc23		2b bc 3a 83 43 83		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bc29		63 40				        .text "c@"
.bc2b						nt_c_store:
>bc2b		02 10				        .byte 2, UF
>bc2d		35 bc 44 83 4f 83		        .word nt_plus_store, xt_c_store, z_c_store
>bc33		63 21				        .text "c!"
.bc35						nt_plus_store:
>bc35		02 10				        .byte 2, UF
>bc37		3f bc f9 8f 18 90		        .word nt_execute, xt_plus_store, z_plus_store
>bc3d		2b 21				        .text "+!"
.bc3f						nt_execute:
>bc3f		07 10				        .byte 7, UF
>bc41		4e bc 7b 89 81 89		        .word nt_emit, xt_execute, z_execute
>bc47		65 78 65 63 75 74 65		        .text "execute"
.bc4e						nt_emit:
>bc4e		04 18				        .byte 4, NN+UF
>bc50		5a bc 34 88 3e 88		        .word nt_type, xt_emit, z_emit
>bc56		65 6d 69 74			        .text "emit"
.bc5a						nt_type:
>bc5a		04 10				        .byte 4, UF
>bc5c		66 bc 7f 96 a9 96		        .word nt_dot, xt_type, z_type
>bc62		74 79 70 65			        .text "type"
.bc66						nt_dot:
>bc66		01 10				        .byte 1, UF
>bc68		6f bc 5b 87 7c 87		        .word nt_u_dot, xt_dot, z_dot
>bc6e		2e				        .text "."
.bc6f						nt_u_dot:
>bc6f		02 10				        .byte 2, UF
>bc71		79 bc aa 96 b5 96		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bc77		75 2e				        .text "u."
.bc79						nt_u_dot_r:
>bc79		03 10				        .byte 3, UF
>bc7b		84 bc b6 96 d7 96		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bc81		75 2e 72			        .text "u.r"
.bc84						nt_dot_r:
>bc84		02 10				        .byte 2, UF
>bc86		8e bc 97 87 c4 87		        .word nt_d_dot, xt_dot_r, z_dot_r
>bc8c		2e 72				        .text ".r"
.bc8e						nt_d_dot:
>bc8e		02 10				        .byte 2, UF
>bc90		98 bc c0 9e de 9e		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bc96		64 2e				        .text "d."
.bc98						nt_d_dot_r:
>bc98		03 10				        .byte 3, UF
>bc9a		a3 bc df 9e 09 9f		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bca0		64 2e 72			        .text "d.r"
.bca3						nt_ud_dot:
>bca3		03 10				        .byte 3, UF
>bca5		ae bc 56 9f 68 9f		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bcab		75 64 2e			        .text "ud."
.bcae						nt_ud_dot_r:
>bcae		04 10				        .byte 4, UF
>bcb0		ba bc 69 9f 87 9f		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bcb6		75 64 2e 72			        .text "ud.r"
.bcba						nt_question:
>bcba		01 00				        .byte 1, 0
>bcbc		c3 bc 62 99 68 99		        .word nt_false, xt_question, z_question
>bcc2		3f				        .text "?"
.bcc3						nt_false:
>bcc3		05 00				        .byte 5, 0
>bcc5		d0 bc 37 9e 3d 9e		        .word nt_true, xt_false, z_false
>bccb		66 61 6c 73 65			        .text "false"
.bcd0						nt_true:
>bcd0		04 00				        .byte 4, 0
>bcd2		dc bc 4a 95 52 95		        .word nt_space, xt_true, z_true
>bcd8		74 72 75 65			        .text "true"
.bcdc						nt_space:
>bcdc		05 00				        .byte 5, 0
>bcde		e9 bc 73 93 78 93		        .word nt_zero, xt_space, z_space
>bce4		73 70 61 63 65			        .text "space"
.bce9						nt_zero:
>bce9		01 00				        .byte 1, 0
>bceb		f2 bc 37 9e 3d 9e		        .word nt_one, xt_zero, z_zero
>bcf1		30				        .text "0"
.bcf2						nt_one:
>bcf2		01 00				        .byte 1, 0
>bcf4		fb bc d1 9d d9 9d		        .word nt_two, xt_one, z_one
>bcfa		31				        .text "1"
.bcfb						nt_two:
>bcfb		01 00				        .byte 1, 0
>bcfd		04 bd 02 9e 0a 9e		        .word nt_two_dup, xt_two, z_two
>bd03		32				        .text "2"
.bd04						nt_two_dup:
>bd04		04 10				        .byte 4, UF
>bd06		10 bd 75 95 8c 95		        .word nt_question_dup, xt_two_dup, z_two_dup
>bd0c		32 64 75 70			        .text "2dup"
.bd10						nt_question_dup:
>bd10		04 10				        .byte 4, UF
>bd12		1c bd 58 90 6b 90		        .word nt_plus, xt_question_dup, z_question_dup
>bd18		3f 64 75 70			        .text "?dup"
.bd1c						nt_plus:
>bd1c		01 10				        .byte 1, UF
>bd1e		25 bd e6 8f f8 8f		        .word nt_minus, xt_plus, z_plus
>bd24		2b				        .text "+"
.bd25						nt_minus:
>bd25		01 10				        .byte 1, UF
>bd27		2e bd 77 8d 89 8d		        .word nt_one_minus, xt_minus, z_minus
>bd2d		2d				        .text "-"
.bd2e						nt_one_minus:
>bd2e		02 10				        .byte 2, UF
>bd30		38 bd 70 8e 7b 8e		        .word nt_one_plus, xt_one_minus, z_one_minus
>bd36		31 2d				        .text "1-"
.bd38						nt_one_plus:
>bd38		02 10				        .byte 2, UF
>bd3a		42 bd 7c 8e 85 8e		        .word nt_two_star, xt_one_plus, z_one_plus
>bd40		31 2b				        .text "1+"
.bd42						nt_two_star:
>bd42		02 10				        .byte 2, UF
>bd44		4c bd 0d 96 14 96		        .word nt_two_slash, xt_two_star, z_two_star
>bd4a		32 2a				        .text "2*"
.bd4c						nt_two_slash:
>bd4c		02 10				        .byte 2, UF
>bd4e		56 bd 02 96 0c 96		        .word nt_abs, xt_two_slash, z_two_slash
>bd54		32 2f				        .text "2/"
.bd56						nt_abs:
>bd56		03 10				        .byte 3, UF
>bd58		61 bd d1 80 e5 80		        .word nt_dabs, xt_abs, z_abs
>bd5e		61 62 73			        .text "abs"
.bd61						nt_dabs:
>bd61		04 10				        .byte 4, UF
>bd63		6d bd 86 9e a4 9e		        .word nt_and, xt_dabs, z_dabs
>bd69		64 61 62 73			        .text "dabs"
.bd6d						nt_and:
>bd6d		03 10				        .byte 3, UF
>bd6f		78 bd 99 82 aa 82		        .word nt_or, xt_and, z_and
>bd75		61 6e 64			        .text "and"
.bd78						nt_or:
>bd78		02 10				        .byte 2, UF
>bd7a		82 bd 86 8e 97 8e		        .word nt_xor, xt_or, z_or
>bd80		6f 72				        .text "or"
.bd82						nt_xor:
>bd82		03 10				        .byte 3, UF
>bd84		8d bd 48 98 59 98		        .word nt_rshift, xt_xor, z_xor
>bd8a		78 6f 72			        .text "xor"
.bd8d						nt_rshift:
>bd8d		06 10				        .byte 6, UF
>bd8f		9b bd 3a 91 4d 91		        .word nt_lshift, xt_rshift, z_rshift
>bd95		72 73 68 69 66 74		        .text "rshift"
.bd9b						nt_lshift:
>bd9b		06 10				        .byte 6, UF
>bd9d		a9 bd a1 8c b4 8c		        .word nt_pick, xt_lshift, z_lshift
>bda3		6c 73 68 69 66 74		        .text "lshift"
.bda9						nt_pick:
>bda9		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bdab		b5 bd d5 8f e5 8f		        .word nt_char, xt_pick, z_pick
>bdb1		70 69 63 6b			        .text "pick"
.bdb5						nt_char:
>bdb5		04 00				        .byte 4, 0
>bdb7		c1 bd 60 83 76 83		        .word nt_bracket_char, xt_char, z_char
>bdbd		63 68 61 72			        .text "char"
.bdc1						nt_bracket_char:
>bdc1		06 05				        .byte 6, CO+IM
>bdc3		cf bd 1a 83 20 83		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bdc9		5b 63 68 61 72 5d		        .text "[char]"
.bdcf						nt_char_plus:
>bdcf		05 00				        .byte 5, 0
>bdd1		dc bd 7c 8e 85 8e		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>bdd7		63 68 61 72 2b			        .text "char+"
.bddc						nt_chars:
>bddc		05 12				        .byte 5, AN+UF   ; deleted during compile
>bdde		e9 bd 77 83 7a 83		        .word nt_cells, xt_chars, z_chars
>bde4		63 68 61 72 73			        .text "chars"
.bde9						nt_cells:
>bde9		05 00				        .byte 5, 0
>bdeb		f6 bd 0d 96 14 96		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bdf1		63 65 6c 6c 73			        .text "cells"
.bdf6						nt_cell_plus:
>bdf6		05 10				        .byte 5, UF
>bdf8		03 be 50 83 5f 83		        .word nt_here, xt_cell_plus, z_cell_plus
>bdfe		63 65 6c 6c 2b			        .text "cell+"
.be03						nt_here:
>be03		04 00				        .byte 4, 0
>be05		0f be 91 8a 9b 8a		        .word nt_equal, xt_here, z_here
>be0b		68 65 72 65			        .text "here"
.be0f						nt_equal:
>be0f		01 10				        .byte 1, UF
>be11		18 be 0c 89 27 89		        .word nt_not_equals, xt_equal, z_equal
>be17		3d				        .text "="
.be18						nt_not_equals:
>be18		02 10				        .byte 2, UF
>be1a		22 be d1 8d ee 8d		        .word nt_less_than, xt_not_equals, z_not_equals
>be20		3c 3e				        .text "<>"
.be22						nt_less_than:
>be22		01 10				        .byte 1, UF
>be24		2b be 95 8b a9 8b		        .word nt_u_less_than, xt_less_than, z_less_than
>be2a		3c				        .text "<"
.be2b						nt_u_less_than:
>be2b		02 10				        .byte 2, UF
>be2d		35 be ee 96 03 97		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>be33		75 3c				        .text "u<"
.be35						nt_u_greater_than:
>be35		02 10				        .byte 2, UF
>be37		3f be d8 96 ed 96		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>be3d		75 3e				        .text "u>"
.be3f						nt_greater_than:
>be3f		01 10				        .byte 1, UF
>be41		48 be 7c 8a 90 8a		        .word nt_zero_equal, xt_greater_than, z_greater_than
>be47		3e				        .text ">"
.be48						nt_zero_equal:
>be48		02 10				        .byte 2, UF
>be4a		52 be 5a 98 6b 98		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>be50		30 3d				        .text "0="
.be52						nt_zero_unequal:
>be52		03 10				        .byte 3, UF
>be54		5d be 90 98 9f 98		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>be5a		30 3c 3e			        .text "0<>"
.be5d						nt_zero_greater:
>be5d		02 10				        .byte 2, UF
>be5f		67 be 6c 98 7f 98		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>be65		30 3e				        .text "0>"
.be67						nt_zero_less:
>be67		02 10				        .byte 2, UF
>be69		71 be 80 98 8f 98		        .word nt_min, xt_zero_less, z_zero_less
>be6f		30 3c				        .text "0<"
.be71						nt_min:
>be71		03 10				        .byte 3, UF
>be73		7c be 5b 8d 76 8d		        .word nt_max, xt_min, z_min
>be79		6d 69 6e			        .text "min"
.be7c						nt_max:
>be7c		03 10				        .byte 3, UF
>be7e		87 be 3f 8d 5a 8d		        .word nt_two_drop, xt_max, z_max
>be84		6d 61 78			        .text "max"
.be87						nt_two_drop:
>be87		05 10				        .byte 5, UF
>be89		94 be 6d 95 74 95		        .word nt_two_swap, xt_two_drop, z_two_drop
>be8f		32 64 72 6f 70			        .text "2drop"
.be94						nt_two_swap:
>be94		05 10				        .byte 5, UF
>be96		a1 be 3b 96 5e 96		        .word nt_two_over, xt_two_swap, z_two_swap
>be9c		32 73 77 61 70			        .text "2swap"
.bea1						nt_two_over:
>bea1		05 10				        .byte 5, UF
>bea3		ae be af 95 c6 95		        .word nt_two_store, xt_two_over, z_two_over
>bea9		32 6f 76 65 72			        .text "2over"
.beae						nt_two_store:
>beae		02 10				        .byte 2, UF
>beb0		b8 be 15 96 3a 96		        .word nt_two_fetch, xt_two_store, z_two_store
>beb6		32 21				        .text "2!"
.beb8						nt_two_fetch:
>beb8		02 10				        .byte 2, UF
>beba		c2 be 8d 95 ae 95		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bec0		32 40				        .text "2@"
.bec2						nt_two_variable:
>bec2		09 00				        .byte 9, 0
>bec4		d3 be 47 9f 55 9f		        .word nt_two_constant, xt_two_variable, z_two_variable
>beca		32 76 61 72 69 61 62 6c		        .text "2variable"
>bed2		65
.bed3						nt_two_constant:
>bed3		09 10				        .byte 9, UF
>bed5		e4 be 0a 9f 2e 9f		        .word nt_two_literal, xt_two_constant, z_two_constant
>bedb		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bee3		74
.bee4						nt_two_literal:
>bee4		08 14				        .byte 8, UF+IM
>bee6		f4 be 2f 9f 46 9f		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>beec		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bef4						nt_two_r_fetch:
>bef4		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bef6		ff be c7 95 e4 95		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>befc		32 72 40			        .text "2r@"
.beff						nt_two_r_from:
>beff		03 01				        .byte 3, CO             ; native is special case
>bf01		0a bf e5 95 01 96		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bf07		32 72 3e			        .text "2r>"
.bf0a						nt_two_to_r:
>bf0a		03 11				        .byte 3, CO+UF          ; native is special case
>bf0c		15 bf 5f 96 7e 96		        .word nt_invert, xt_two_to_r, z_two_to_r
>bf12		32 3e 72			        .text "2>r"
.bf15						nt_invert:
>bf15		06 10				        .byte 6, UF
>bf17		23 bf 1c 8b 2b 8b		        .word nt_negate, xt_invert, z_invert
>bf1d		69 6e 76 65 72 74		        .text "invert"
.bf23						nt_negate:
>bf23		06 10				        .byte 6, UF
>bf25		31 bf b2 8d c2 8d		        .word nt_dnegate, xt_negate, z_negate
>bf2b		6e 65 67 61 74 65		        .text "negate"
.bf31						nt_dnegate:
>bf31		07 10				        .byte 7, UF
>bf33		40 bf a5 9e bf 9e		        .word nt_c_comma, xt_dnegate, z_dnegate
>bf39		64 6e 65 67 61 74 65		        .text "dnegate"
.bf40						nt_c_comma:
>bf40		02 10				        .byte 2, UF
>bf42		4a bf 2f 83 39 83		        .word nt_bounds, xt_c_comma, z_c_comma
>bf48		63 2c				        .text "c,"
.bf4a						nt_bounds:
>bf4a		06 10				        .byte 6, UF
>bf4c		58 bf 74 9a 8c 9a		        .word nt_spaces, xt_bounds, z_bounds
>bf52		62 6f 75 6e 64 73		        .text "bounds"
.bf58						nt_spaces:
>bf58		06 10				        .byte 6, UF
>bf5a		66 bf 79 93 b4 93		        .word nt_bl, xt_spaces, z_spaces
>bf60		73 70 61 63 65 73		        .text "spaces"
.bf66						nt_bl:
>bf66		02 00				        .byte 2, 0
>bf68		70 bf 11 83 19 83		        .word nt_minus_trailing, xt_bl, z_bl
>bf6e		62 6c				        .text "bl"
.bf70						nt_minus_trailing:
>bf70		09 10				        .byte 9, UF
>bf72		81 bf 7c a0 b8 a0		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>bf78		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>bf80		67
.bf81						nt_minus_leading:
>bf81		08 10				        .byte 8, UF
>bf83		91 bf 63 a0 7b a0		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>bf89		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.bf91						nt_slash_string:
>bf91		07 10				        .byte 7, UF
>bf93		a0 bf 58 a1 77 a1		        .word nt_refill, xt_slash_string, z_slash_string
>bf99		2f 73 74 72 69 6e 67		        .text "/string"
.bfa0						nt_refill:
>bfa0		06 00				        .byte 6, 0
>bfa2		ae bf cf 90 10 91		        .word nt_accept, xt_refill, z_refill
>bfa8		72 65 66 69 6c 6c		        .text "refill"
.bfae						nt_accept:
>bfae		06 18				        .byte 6, UF+NN
>bfb0		bc bf e6 80 de 81		        .word nt_input_to_r, xt_accept, z_accept
>bfb6		61 63 63 65 70 74		        .text "accept"
.bfbc						nt_input_to_r:
>bfbc		07 08				        .byte 7, NN
>bfbe		cb bf d8 9b ed 9b		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>bfc4		69 6e 70 75 74 3e 72		        .text "input>r"
.bfcb						nt_r_to_input:
>bfcb		07 08				        .byte 7, NN
>bfcd		da bf e5 9d fc 9d		        .word nt_unused, xt_r_to_input, z_r_to_input
>bfd3		72 3e 69 6e 70 75 74		        .text "r>input"
.bfda						nt_unused:
>bfda		06 00				        .byte 6, 0
>bfdc		e8 bf b1 97 c0 97		        .word nt_depth, xt_unused, z_unused
>bfe2		75 6e 75 73 65 64		        .text "unused"
.bfe8						nt_depth:
>bfe8		05 00				        .byte 5, 0
>bfea		f5 bf 8b 86 99 86		        .word nt_key, xt_depth, z_depth
>bff0		64 65 70 74 68			        .text "depth"
.bff5						nt_key:
>bff5		03 00				        .byte 3, 0
>bff7		00 c0 5f 8b 68 8b		        .word nt_allot, xt_key, z_key
>bffd		6b 65 79			        .text "key"
.c000						nt_allot:
>c000		05 10				        .byte 5, UF
>c002		0d c0 30 82 98 82		        .word nt_create, xt_allot, z_allot
>c008		61 6c 6c 6f 74			        .text "allot"
.c00d						nt_create:
>c00d		06 00				        .byte 6, 0
>c00f		1b c0 6f 85 42 86		        .word nt_does, xt_create, z_create
>c015		63 72 65 61 74 65		        .text "create"
.c01b						nt_does:
>c01b		05 05				        .byte 5, CO+IM
>c01d		28 c0 1a 87 28 87		        .word nt_variable, xt_does, z_does
>c023		64 6f 65 73 3e			        .text "does>"
.c028						nt_variable:
>c028		08 00				        .byte 8, 0
>c02a		38 c0 c1 97 d9 97		        .word nt_constant, xt_variable, z_variable
>c030		76 61 72 69 61 62 6c 65		        .text "variable"
.c038						nt_constant:
>c038		08 10				        .byte 8, UF
>c03a		48 c0 17 85 54 85		        .word nt_value, xt_constant, z_constant
>c040		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c048						nt_value:
>c048		05 10				        .byte 5, UF
>c04a		55 c0 17 85 54 85		        .word nt_to, xt_constant, z_constant
>c050		76 61 6c 75 65			        .text "value"
.c055						nt_to:
>c055		02 0c				        .byte 2, NN+IM
>c057		5f c0 2c 94 67 94		        .word nt_s_to_d, xt_to, z_to
>c05d		74 6f				        .text "to"
.c05f						nt_s_to_d:
>c05f		03 10				        .byte 3, UF
>c061		6a c0 87 92 98 92		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c067		73 3e 64			        .text "s>d"
.c06a						nt_d_to_s:
>c06a		03 10				        .byte 3, UF
>c06c		75 c0 80 9e 85 9e		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c072		64 3e 73			        .text "d>s"
.c075						nt_d_minus:
>c075		02 10				        .byte 2, UF
>c077		7f c0 3e 9e 5e 9e		        .word nt_d_plus, xt_d_minus, z_d_minus
>c07d		64 2d				        .text "d-"
.c07f						nt_d_plus:
>c07f		02 10				        .byte 2, UF
>c081		89 c0 5f 9e 7f 9e		        .word nt_erase, xt_d_plus, z_d_plus
>c087		64 2b				        .text "d+"
.c089						nt_erase:
>c089		05 00				        .byte 5, 0      ; underflow checked by FILL
>c08b		96 c0 32 89 7a 89		        .word nt_blank, xt_erase, z_erase
>c091		65 72 61 73 65			        .text "erase"
.c096						nt_blank:
>c096		05 00				        .byte 5, 0     ; underflow checked by FILL
>c098		a3 c0 28 89 7a 89		        .word nt_fill, xt_blank, z_blank
>c09e		62 6c 61 6e 6b			        .text "blank"
.c0a3						nt_fill:
>c0a3		04 10				        .byte 4, UF
>c0a5		af c0 38 89 7a 89		        .word nt_find_name, xt_fill, z_fill
>c0ab		66 69 6c 6c			        .text "fill"
.c0af						nt_find_name:
>c0af		09 10				        .byte 9, UF
>c0b1		c0 c0 36 9b 79 9b		        .word nt_tick, xt_find_name, z_find_name
>c0b7		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c0bf		65
.c0c0						nt_tick:
>c0c0		01 00				        .byte 1, 0
>c0c2		c9 c0 0c 94 2b 94		        .word nt_bracket_tick, xt_tick, z_tick
>c0c8		27				        .text "'"
.c0c9						nt_bracket_tick:
>c0c9		03 05				        .byte 3, CO+IM
>c0cb		d4 c0 21 83 27 83		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c0d1		5b 27 5d			        .text "[']"
.c0d4						nt_name_to_int:
>c0d4		08 10				        .byte 8, UF
>c0d6		e4 c0 74 9c 90 9c		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c0dc		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c0e4						nt_int_to_name:
>c0e4		08 10				        .byte 8, UF
>c0e6		f4 c0 ee 9b 5e 9c		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c0ec		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c0f4						nt_name_to_string:
>c0f4		0b 10				        .byte 11, UF
>c0f6		07 c1 91 9c a7 9c		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c0fc		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c104		69 6e 67
.c107						nt_to_body:
>c107		05 10				        .byte 5, UF
>c109		14 c1 68 94 8a 94		        .word nt_defer, xt_to_body, z_to_body
>c10f		3e 62 6f 64 79			        .text ">body"
.c114						nt_defer:
>c114		05 00				        .byte 5, 0
>c116		21 c1 4a 86 7c 86		        .word nt_latestxt, xt_defer, z_defer
>c11c		64 65 66 65 72			        .text "defer"
.c121						nt_latestxt:
>c121		08 00				        .byte 8, 0
>c123		31 c1 6d 9c 73 9c		        .word nt_latestnt, xt_latestxt, z_latestxt
>c129		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c131						nt_latestnt:
>c131		08 00				        .byte 8, 0
>c133		41 c1 5f 9c 6c 9c		        .word nt_parse_name, xt_latestnt, z_latestnt
>c139		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c141						nt_parse_name:
>c141		0a 08				        .byte 10, NN
>c143		53 c1 e4 8e d4 8f		        .word nt_parse, xt_parse_name, z_parse_name
>c149		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c151		6d 65
.c153						nt_parse:
>c153		05 10				        .byte 5, UF
>c155		60 c1 3f 8f d4 8f		        .word nt_execute_parsing, xt_parse, z_parse
>c15b		70 61 72 73 65			        .text "parse"
.c160						nt_execute_parsing:
>c160		0f 10				        .byte 15, UF
>c162		77 c1 0f 9b 35 9b		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c168		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c170		70 61 72 73 69 6e 67
.c177						nt_source:
>c177		06 00				        .byte 6, 0
>c179		85 c1 53 93 67 93		        .word nt_source_id, xt_source, z_source
>c17f		73 6f 75 72 63 65		        .text "source"
.c185						nt_source_id:
>c185		09 00				        .byte 9, 0
>c187		96 c1 68 93 72 93		        .word nt_colon, xt_source_id, z_source_id
>c18d		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c195		64
.c196						nt_colon:
>c196		01 00				        .byte 1, 0
>c198		9f c1 7b 83 bd 83		        .word nt_semicolon, xt_colon, z_colon
>c19e		3a				        .text ":"
.c19f						nt_semicolon:
>c19f		01 05				        .byte 1, CO+IM
>c1a1		a8 c1 99 92 f7 92		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c1a7		3b				        .text ";"
.c1a8						nt_colon_noname:
>c1a8		07 00				        .byte 7, 0
>c1aa		b7 c1 be 83 d9 83		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c1b0		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c1b7						nt_compile_comma:
>c1b7		08 18				        .byte 8, UF+NN
>c1b9		c7 c1 f4 83 0a 85		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c1bf		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c1c7						nt_left_bracket:
>c1c7		01 05				        .byte 1, IM+CO
>c1c9		d0 c1 82 8b 86 8b		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c1cf		5b				        .text "["
.c1d0						nt_right_bracket:
>c1d0		01 04				        .byte 1, IM
>c1d2		d9 c1 17 91 1d 91		        .word nt_literal, xt_right_bracket, z_right_bracket
>c1d8		5d				        .text "]"
.c1d9						nt_literal:
>c1d9		07 15				        .byte 7, IM+CO+UF
>c1db		e8 c1 aa 8b e7 8b		        .word nt_sliteral, xt_literal, z_literal
>c1e1		6c 69 74 65 72 61 6c		        .text "literal"
.c1e8						nt_sliteral:
>c1e8		08 15				        .byte 8, CO+IM+UF
>c1ea		f8 c1 78 a1 bb a1		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c1f0		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c1f8						nt_dot_quote:
>c1f8		02 05				        .byte 2, CO+IM
>c1fa		02 c2 8c 87 96 87		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c200		2e 22				        .text ".", $22
.c202						nt_s_quote:
>c202		02 0c				        .byte 2, IM+NN
>c204		0c c2 67 91 86 92		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c20a		73 22				        .text "s", $22
.c20c						nt_s_backslash_quote:
>c20c		03 04				        .byte 3, IM
>c20e		17 c2 4e 91 57 91		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c214		73 5c 22			        .text "s", $5C, $22
.c217						nt_postpone:
>c217		08 05				        .byte 8, IM+CO
>c219		27 c2 19 90 57 90		        .word nt_immediate, xt_postpone, z_postpone
>c21f		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c227						nt_immediate:
>c227		09 00				        .byte 9, 0
>c229		38 c2 10 8b 1b 8b		        .word nt_compile_only, xt_immediate, z_immediate
>c22f		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c237		65
.c238						nt_compile_only:
>c238		0c 00				        .byte 12, 0
>c23a		4c c2 0b 85 16 85		        .word nt_never_native, xt_compile_only, z_compile_only
>c240		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c248		6f 6e 6c 79
.c24c						nt_never_native:
>c24c		0c 00				        .byte 12, 0
>c24e		60 c2 ad 9c ba 9c		        .word nt_always_native, xt_never_native, z_never_native
>c254		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c25c		74 69 76 65
.c260						nt_always_native:
>c260		0d 00				        .byte 13, 0
>c262		75 c2 60 9a 6d 9a		        .word nt_allow_native, xt_always_native, z_always_native
>c268		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c270		61 74 69 76 65
.c275						nt_allow_native:
>c275		0c 00				        .byte 12, 0
>c277		89 c2 54 9a 5f 9a		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c27d		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c285		74 69 76 65
.c289						nt_nc_limit:
>c289		08 08				        .byte 8, NN
>c28b		99 c2 a8 9c ad 9c		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c291		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c299						nt_strip_underflow:
>c299		0f 08				        .byte 15, NN
>c29b		b0 c2 fd 9d 02 9e		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c2a1		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c2a9		64 65 72 66 6c 6f 77
.c2b0						nt_abort:
>c2b0		05 00				        .byte 5, 0
>c2b2		bd c2 60 80 b1 80		        .word nt_abort_quote, xt_abort, z_abort
>c2b8		61 62 6f 72 74			        .text "abort"
.c2bd						nt_abort_quote:
>c2bd		06 0d				        .byte 6, CO+IM+NN
>c2bf		cb c2 b1 80 bb 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c2c5		61 62 6f 72 74 22		        .text "abort", $22
.c2cb						nt_do:
>c2cb		02 0d				        .byte 2, CO+IM+NN
>c2cd		d5 c2 9e 86 d7 86		        .word nt_question_do, xt_do, z_do
>c2d3		64 6f				        .text "do"
.c2d5						nt_question_do:
>c2d5		03 0d				        .byte 3, CO+IM+NN
>c2d7		e0 c2 9a 86 d7 86		        .word nt_i, xt_question_do, z_question_do
>c2dd		3f 64 6f			        .text "?do"
.c2e0						nt_i:
>c2e0		01 01				        .byte 1, CO
>c2e2		e9 c2 b5 8a c9 8a		        .word nt_j, xt_i, z_i
>c2e8		69				        .text "i"
.c2e9						nt_j:
>c2e9		01 01				        .byte 1, CO
>c2eb		f2 c2 45 8b 5e 8b		        .word nt_loop, xt_j, z_j
>c2f1		6a				        .text "j"
.c2f2						nt_loop:
>c2f2		04 05				        .byte 4, CO+IM
>c2f4		fe c2 11 8c 73 8c		        .word nt_plus_loop, xt_loop, z_loop
>c2fa		6c 6f 6f 70			        .text "loop"
.c2fe						nt_plus_loop:
>c2fe		05 05				        .byte 5, CO+IM
>c300		0b c3 22 8c 73 8c		        .word nt_exit, xt_plus_loop, z_plus_loop
>c306		2b 6c 6f 6f 70			        .text "+loop"
.c30b						nt_exit:
>c30b		04 03				        .byte 4, AN+CO
>c30d		17 c3 8f 89 90 89		        .word nt_unloop, xt_exit, z_exit
>c313		65 78 69 74			        .text "exit"
.c317						nt_unloop:
>c317		06 01				        .byte 6, CO
>c319		25 c3 8c 97 9b 97		        .word nt_leave, xt_unloop, z_unloop
>c31f		75 6e 6c 6f 6f 70		        .text "unloop"
.c325						nt_leave:
>c325		05 05				        .byte 5, CO+IM
>c327		32 c3 6c 8b 81 8b		        .word nt_recurse, xt_leave, z_leave
>c32d		6c 65 61 76 65			        .text "leave"
.c332						nt_recurse:
>c332		07 0d				        .byte 7, CO+IM+NN
>c334		41 c3 92 90 ce 90		        .word nt_quit, xt_recurse, z_recurse
>c33a		72 65 63 75 72 73 65		        .text "recurse"
.c341						nt_quit:
>c341		04 00				        .byte 4, 0
>c343		4d c3 62 80 b1 80		        .word nt_begin, xt_quit, z_quit
>c349		71 75 69 74			        .text "quit"
.c34d						nt_begin:
>c34d		05 07				        .byte 5, AN+CO+IM
>c34f		5a c3 0d 83 10 83		        .word nt_again, xt_begin, z_begin
>c355		62 65 67 69 6e			        .text "begin"
.c35a						nt_again:
>c35a		05 17				        .byte 5, AN+CO+IM+UF
>c35c		67 c3 21 82 2e 82		        .word nt_state, xt_again, z_again
>c362		61 67 61 69 6e			        .text "again"
.c367						nt_state:
>c367		05 00				        .byte 5, 0
>c369		74 c3 d7 93 e1 93		        .word nt_evaluate, xt_state, z_state
>c36f		73 74 61 74 65			        .text "state"
.c374						nt_evaluate:
>c374		08 10				        .byte 8, UF
>c376		84 c3 28 8a 7b 8a		        .word nt_base, xt_evaluate, z_evaluate
>c37c		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c384						nt_base:
>c384		04 00				        .byte 4, 0
>c386		90 c3 04 83 0c 83		        .word nt_digit_question, xt_base, z_base
>c38c		62 61 73 65			        .text "base"
.c390						nt_digit_question:
>c390		06 10				        .byte 6, UF
>c392		9e c3 da 9a 0e 9b		        .word nt_number, xt_digit_question, z_digit_question
>c398		64 69 67 69 74 3f		        .text "digit?"
.c39e						nt_number:
>c39e		06 10				        .byte 6, UF
>c3a0		ac c3 d7 9c d0 9d		        .word nt_to_number, xt_number, z_number
>c3a6		6e 75 6d 62 65 72		        .text "number"
.c3ac						nt_to_number:
>c3ac		07 10				        .byte 7, UF
>c3ae		bb c3 96 94 35 95		        .word nt_hex, xt_to_number, z_to_number
>c3b4		3e 6e 75 6d 62 65 72		        .text ">number"
.c3bb						nt_hex:
>c3bb		03 00				        .byte 3, 0
>c3bd		c6 c3 9c 8a a2 8a		        .word nt_decimal, xt_hex, z_hex
>c3c3		68 65 78			        .text "hex"
.c3c6						nt_decimal:
>c3c6		07 00				        .byte 7, 0
>c3c8		d5 c3 43 86 49 86		        .word nt_count, xt_decimal, z_decimal
>c3ce		64 65 63 69 6d 61 6c		        .text "decimal"
.c3d5						nt_count:
>c3d5		05 10				        .byte 5, UF
>c3d7		e2 c3 55 85 68 85		        .word nt_m_star, xt_count, z_count
>c3dd		63 6f 75 6e 74			        .text "count"
.c3e2						nt_m_star:
>c3e2		02 10				        .byte 2, UF
>c3e4		ec c3 b5 8c cf 8c		        .word nt_um_star, xt_m_star, z_m_star
>c3ea		6d 2a				        .text "m*"
.c3ec						nt_um_star:
>c3ec		03 10				        .byte 3, UF
>c3ee		f7 c3 46 97 8b 97		        .word nt_star, xt_um_star, z_um_star
>c3f4		75 6d 2a			        .text "um*"
.c3f7						nt_star:
>c3f7		01 10				        .byte 1, UF
>c3f9		00 c4 b5 93 bd 93		        .word nt_um_slash_mod, xt_star, z_star
>c3ff		2a				        .text "*"
.c400						nt_um_slash_mod:
>c400		06 10				        .byte 6, UF
>c402		0e c4 04 97 45 97		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c408		75 6d 2f 6d 6f 64		        .text "um/mod"
.c40e						nt_sm_slash_rem:
>c40e		06 10				        .byte 6, UF
>c410		1c c4 2a 93 52 93		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c416		73 6d 2f 72 65 6d		        .text "sm/rem"
.c41c						nt_fm_slash_mod:
>c41c		06 10				        .byte 6, UF
>c41e		2a c4 eb 89 21 8a		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c424		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c42a						nt_slash:
>c42a		01 10				        .byte 1, UF
>c42c		33 c4 0d 93 29 93		        .word nt_slash_mod, xt_slash, z_slash
>c432		2f				        .text "/"
.c433						nt_slash_mod:
>c433		04 10				        .byte 4, UF
>c435		3f c4 12 93 29 93		        .word nt_mod, xt_slash_mod, z_slash_mod
>c43b		2f 6d 6f 64			        .text "/mod"
.c43f						nt_mod:
>c43f		03 10				        .byte 3, UF
>c441		4a c4 8a 8d 92 8d		        .word nt_star_slash_mod, xt_mod, z_mod
>c447		6d 6f 64			        .text "mod"
.c44a						nt_star_slash_mod:
>c44a		05 10				        .byte 5, UF
>c44c		57 c4 c7 93 d6 93		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c452		2a 2f 6d 6f 64			        .text "*/mod"
.c457						nt_star_slash:
>c457		02 10				        .byte 2, UF
>c459		61 c4 be 93 c6 93		        .word nt_backslash, xt_star_slash, z_star_slash
>c45f		2a 2f				        .text "*/"
.c461						nt_backslash:
>c461		01 04				        .byte 1, IM
>c463		6a c4 d9 82 03 83		        .word nt_move, xt_backslash, z_backslash
>c469		5c				        .byte '\'
.c46a						nt_move:
>c46a		04 18				        .byte 4, NN+UF
>c46c		76 c4 93 8d b1 8d		        .word nt_cmove_up, xt_move, z_move
>c472		6d 6f 76 65			        .text "move"
.c476						nt_cmove_up:
>c476		06 10				        .byte 6, UF
>c478		84 c4 c3 9f fd 9f		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c47e		63 6d 6f 76 65 3e		        .text "cmove>"
.c484						nt_cmove:
>c484		05 10				        .byte 5, UF
>c486		91 c4 88 9f c2 9f		        .word nt_pad, xt_cmove, z_cmove
>c48c		63 6d 6f 76 65			        .text "cmove"
.c491						nt_pad:
>c491		03 00				        .byte 3, 0
>c493		9c c4 a6 8e b5 8e		        .word nt_cleave, xt_pad, z_pad
>c499		70 61 64			        .text "pad"
.c49c						nt_cleave:
>c49c		06 10				        .byte 6, UF
>c49e		aa c4 8d 9a d9 9a		        .word nt_hexstore, xt_cleave, z_cleave
>c4a4		63 6c 65 61 76 65		        .text "cleave"
.c4aa						nt_hexstore:
>c4aa		08 10				        .byte 8, UF
>c4ac		ba c4 7a 9b cc 9b		        .word nt_within, xt_hexstore, z_hexstore
>c4b2		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c4ba						nt_within:
>c4ba		06 10				        .byte 6, UF
>c4bc		c8 c4 ee 97 03 98		        .word nt_to_in, xt_within, z_within
>c4c2		77 69 74 68 69 6e		        .text "within"
.c4c8						nt_to_in:
>c4c8		03 00				        .byte 3, 0
>c4ca		d3 c4 8b 94 95 94		        .word nt_less_number_sign, xt_to_in, z_to_in
>c4d0		3e 69 6e			        .text ">in"
.c4d3						nt_less_number_sign:
>c4d3		02 00				        .byte 2, 0
>c4d5		dd c4 87 8b 94 8b		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c4db		3c 23				        .text "<#"
.c4dd						nt_number_sign:
>c4dd		01 10				        .byte 1, UF
>c4df		e6 c4 ef 8d 23 8e		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c4e5		23				        .text "#"
.c4e6						nt_number_sign_s:
>c4e6		02 10				        .byte 2, UF
>c4e8		f0 c4 46 8e 56 8e		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c4ee		23 73				        .text "#s"
.c4f0						nt_number_sign_greater:
>c4f0		02 10				        .byte 2, UF
>c4f2		fa c4 24 8e 45 8e		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c4f8		23 3e				        .text "#>"
.c4fa						nt_hold:
>c4fa		04 10				        .byte 4, UF
>c4fc		06 c5 a3 8a b4 8a		        .word nt_sign, xt_hold, z_hold
>c502		68 6f 6c 64			        .text "hold"
.c506						nt_sign:
>c506		04 10				        .byte 4, UF
>c508		12 c5 f8 92 0c 93		        .word nt_output, xt_sign, z_sign
>c50e		73 69 67 6e			        .text "sign"
.c512						nt_output:
>c512		06 00				        .byte 6, 0
>c514		20 c5 da 9d e4 9d		        .word nt_input, xt_output, z_output
>c51a		6f 75 74 70 75 74		        .text "output"
.c520						nt_input:
>c520		05 00				        .byte 5, 0
>c522		2d c5 cd 9b d7 9b		        .word nt_cr, xt_input, z_input
>c528		69 6e 70 75 74			        .text "input"
.c52d						nt_cr:
>c52d		02 00				        .byte 2, 0
>c52f		37 c5 69 85 6e 85		        .word nt_page, xt_cr, z_cr
>c535		63 72				        .text "cr"
.c537						nt_page:
>c537		04 00				        .byte 4, 0
>c539		43 c5 b6 8e d3 8e		        .word nt_at_xy, xt_page, z_page
>c53f		70 61 67 65			        .text "page"
.c543						nt_at_xy:
>c543		05 10				        .byte 5, UF
>c545		50 c5 ab 82 d8 82		        .word nt_marker, xt_at_xy, z_at_xy
>c54b		61 74 2d 78 79			        .text "at-xy"
.c550						nt_marker:
>c550		06 04				        .byte 6, IM
>c552		5e c5 d0 8c 0d 8d		        .word nt_words, xt_marker, z_marker
>c558		6d 61 72 6b 65 72		        .text "marker"
.c55e						nt_words:
>c55e		05 00				        .byte 5, 0
>c560		6b c5 f7 99 53 9a		        .word nt_wordsize, xt_words, z_words
>c566		77 6f 72 64 73			        .text "words"
.c56b						nt_wordsize:
>c56b		08 10				        .byte 8, UF
>c56d		7b c5 16 9e 36 9e		        .word nt_aligned, xt_wordsize, z_wordsize
>c573		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c57b						nt_aligned:
>c57b		07 00				        .byte 7, 0
>c57d		8a c5 2f 82 2f 82		        .word nt_align, xt_align, z_align
>c583		61 6c 69 67 6e 65 64		        .text "aligned"
.c58a						nt_align:
>c58a		05 00				        .byte 5, 0
>c58c		97 c5 2f 82 2f 82		        .word nt_bell, xt_align, z_align
>c592		61 6c 69 67 6e			        .text "align"
.c597						nt_bell:
>c597		04 00				        .byte 4, 0
>c599		a3 c5 6e 9a 73 9a		        .word nt_dump, xt_bell, z_bell
>c59f		62 65 6c 6c			        .text "bell"
.c5a3						nt_dump:
>c5a3		04 10				        .byte 4, UF
>c5a5		af c5 e7 98 4d 99		        .word nt_dot_s, xt_dump, z_dump
>c5ab		64 75 6d 70			        .text "dump"
.c5af						nt_dot_s:
>c5af		02 00				        .byte 2, 0
>c5b1		b9 c5 a3 98 e6 98		        .word +, xt_dot_s, z_dot_s
>c5b7		2e 73				        .text ".s"
.c5b9						+
.c5b9						nt_disasm:
>c5b9		06 10				        .byte 6, UF
>c5bb		c7 c5 e4 a1 ea a1		        .word +, xt_disasm, z_disasm
>c5c1		64 69 73 61 73 6d		        .text "disasm"
.c5c7						+
.c5c7						nt_compare:
>c5c7		07 10				        .byte 7, UF
>c5c9		d6 c5 fe 9f 62 a0		        .word nt_search, xt_compare, z_compare
>c5cf		63 6f 6d 70 61 72 65		        .text "compare"
.c5d6						nt_search:
>c5d6		06 18				        .byte 6, UF+NN
>c5d8		e4 c5 b9 a0 57 a1		        .word +, xt_search, z_search
>c5de		73 65 61 72 63 68		        .text "search"
.c5e4						+
.c5e4						nt_environment_q:
>c5e4		0c 10				        .byte 12, UF
>c5e6		f8 c5 53 88 cf 88		        .word +, xt_environment_q, z_environment_q
>c5ec		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c5f4		65 6e 74 3f
.c5f8						+
.c5f8						nt_find:
>c5f8		04 10				        .byte 4, UF
>c5fa		04 c6 a3 89 ea 89		        .word nt_word, xt_find, z_find
>c600		66 69 6e 64			        .text "find"
.c604						nt_word:
>c604		04 10				        .byte 4, UF
>c606		10 c6 04 98 47 98		        .word nt_paren, xt_word, z_word
>c60c		77 6f 72 64			        .text "word"
.c610						nt_paren:
>c610		01 04				        .byte 1, IM
>c612		19 c6 d4 8e e3 8e		        .word nt_dot_paren, xt_paren, z_paren
>c618		28				        .text "("
.c619						nt_dot_paren:
>c619		02 04				        .byte 2, IM
>c61b		23 c6 7d 87 8b 87		        .word nt_if, xt_dot_paren, z_dot_paren
>c621		2e 28				        .text ".("
.c623						nt_if:
>c623		02 0d				        .byte 2, IM+CO+NN
>c625		2d c6 ca 8a da 8a		        .word nt_then, xt_if, z_if
>c62b		69 66				        .text "if"
.c62d						nt_then:
>c62d		04 0d				        .byte 4, IM+CO+NN
>c62f		39 c6 e5 87 2e 88		        .word nt_else, xt_then, z_then
>c635		74 68 65 6e			        .text "then"
.c639						nt_else:
>c639		04 0d				        .byte 4, IM+CO+NN
>c63b		45 c6 d9 87 2e 88		        .word nt_repeat, xt_else, z_else
>c641		65 6c 73 65			        .text "else"
.c645						nt_repeat:
>c645		06 0d				        .byte 6, IM+CO+NN
>c647		53 c6 11 91 17 91		        .word nt_until, xt_repeat, z_repeat
>c64d		72 65 70 65 61 74		        .text "repeat"
.c653						nt_until:
>c653		05 0d				        .byte 5, IM+CO+NN
>c655		60 c6 9c 97 b0 97		        .word nt_while, xt_until, z_until
>c65b		75 6e 74 69 6c			        .text "until"
.c660						nt_while:
>c660		05 0d				        .byte 5, IM+CO+NN
>c662		6d c6 da 97 ed 97		        .word nt_case, xt_while, z_while
>c668		77 68 69 6c 65			        .text "while"
.c66d						nt_case:
>c66d		04 0d				        .byte 4, IM+CO+NN
>c66f		79 c6 37 9e 3d 9e		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c675		63 61 73 65			        .text "case"
.c679						nt_of:
>c679		02 0d				        .byte 2, IM+CO+NN
>c67b		83 c6 57 8e 6f 8e		        .word nt_endof, xt_of, z_of
>c681		6f 66				        .text "of"
.c683						nt_endof:
>c683		05 0d				        .byte 5, IM+CO+NN
>c685		90 c6 d9 87 2e 88		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c68b		65 6e 64 6f 66			        .text "endof"
.c690						nt_endcase:
>c690		07 0d				        .byte 7, IM+CO+NN
>c692		9f c6 3e 88 52 88		        .word nt_defer_fetch, xt_endcase, z_endcase
>c698		65 6e 64 63 61 73 65		        .text "endcase"
.c69f						nt_defer_fetch:
>c69f		06 00				        .byte 6, 0
>c6a1		ad c6 7d 86 83 86		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c6a7		64 65 66 65 72 40		        .text "defer@"
.c6ad						nt_defer_store:
>c6ad		06 00				        .byte 6, 0
>c6af		bb c6 84 86 8a 86		        .word nt_is, xt_defer_store, z_defer_store
>c6b5		64 65 66 65 72 21		        .text "defer!"
.c6bb						nt_is:
>c6bb		02 04				        .byte 2, IM
>c6bd		c5 c6 2c 8b 44 8b		        .word nt_action_of, xt_is, z_is
>c6c3		69 73				        .text "is"
.c6c5						nt_action_of:
>c6c5		09 04				        .byte 9, IM
>c6c7		d6 c6 08 82 20 82		        .word nt_useraddr, xt_action_of, z_action_of
>c6cd		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c6d5		66
.c6d6						nt_useraddr:
>c6d6		08 00				        .byte 8, 0
>c6d8		e6 c6 0b 9e 15 9e		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c6de		75 73 65 72 61 64 64 72		        .text "useraddr"
.c6e6						nt_buffer_colon:
>c6e6		07 00				        .byte 7, 0
>c6e8		f5 c6 28 83 2e 83		        .word +, xt_buffer_colon, z_buffer_colon
>c6ee		62 75 66 66 65 72 3a		        .text "buffer:"
.c6f5						+
.c6f5						nt_buffstatus:
>c6f5		0a 00				        .byte 10, 0
>c6f7		07 c7 2e b0 33 b0		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c6fd		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c705		75 73
.c707						nt_buffblocknum:
>c707		0c 00				        .byte 12, 0
>c709		1b c7 f8 af fd af		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c70f		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c717		6b 6e 75 6d
.c71b						nt_blkbuffer:
>c71b		09 00				        .byte 9, 0
>c71d		2c c7 ee ad fb ad		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c723		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c72b		72
.c72c						nt_scr:
>c72c		03 08				        .byte 3, NN
>c72e		37 c7 b0 b0 b5 b0		        .word nt_blk, xt_scr, z_scr
>c734		73 63 72			        .text "scr"
.c737						nt_blk:
>c737		03 08				        .byte 3, NN
>c739		42 c7 e9 ad ee ad		        .word nt_block_write, xt_blk, z_blk
>c73f		62 6c 6b			        .text "blk"
.c742						nt_block_write:
>c742		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c744		55 c7 e5 af f3 af		        .word nt_block_write_vector, xt_block_write, z_block_write
>c74a		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c752		69 74 65
.c755						nt_block_write_vector:
>c755		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c757		6f c7 f3 af f8 af		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c75d		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c765		69 74 65 2d 76 65 63 74 6f 72
.c76f						nt_block_read:
>c76f		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c771		81 c7 cd af db af		        .word nt_block_read_vector, xt_block_read, z_block_read
>c777		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c77f		61 64
.c781						nt_block_read_vector:
>c781		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c783		9a c7 db af e0 af		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c789		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c791		61 64 2d 76 65 63 74 6f 72
.c79a						nt_save_buffers:
>c79a		0c 00				        .byte 12, 0
>c79c		ae c7 95 b0 af b0		        .word nt_block, xt_save_buffers, z_save_buffers
>c7a2		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c7aa		66 65 72 73
.c7ae						nt_block:
>c7ae		05 00				        .byte 5, 0
>c7b0		bb c7 fc ad 4e ae		        .word nt_update, xt_block, z_block
>c7b6		62 6c 6f 63 6b			        .text "block"
.c7bb						nt_update:
>c7bb		06 00				        .byte 6, 0
>c7bd		c9 c7 fa b0 02 b1		        .word nt_buffer, xt_update, z_update
>c7c3		75 70 64 61 74 65		        .text "update"
.c7c9						nt_buffer:
>c7c9		06 00				        .byte 6, 0
>c7cb		d7 c7 fd af 2d b0		        .word nt_empty_buffers, xt_buffer, z_buffer
>c7d1		62 75 66 66 65 72		        .text "buffer"
.c7d7						nt_empty_buffers:
>c7d7		0d 00				        .byte 13, 0
>c7d9		ec c7 33 b0 39 b0		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c7df		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c7e7		66 66 65 72 73
.c7ec						nt_flush:
>c7ec		05 00				        .byte 5, 0
>c7ee		f9 c7 3a b0 43 b0		        .word nt_load, xt_flush, z_flush
>c7f4		66 6c 75 73 68			        .text "flush"
.c7f9						nt_load:
>c7f9		04 10				        .byte 4, UF
>c7fb		05 c8 51 b0 94 b0		        .word nt_thru, xt_load, z_load
>c801		6c 6f 61 64			        .text "load"
.c805						nt_thru:
>c805		04 10				        .byte 4, UF
>c807		11 c8 b5 b0 f9 b0		        .word +, xt_thru, z_thru
>c80d		74 68 72 75			        .text "thru"
.c811						+
.c811						nt_list:
>c811		04 10				        .byte 4, UF
>c813		1d c8 44 b0 50 b0		        .word nt_block_c65_init, xt_list, z_list
>c819		6c 69 73 74			        .text "list"
.c81d						nt_block_c65_init:
>c81d		0e 00				        .byte 14, 0
>c81f		33 c8 4f ae 84 ae		        .word +, xt_block_c65_init, z_block_c65_init
>c825		62 6c 6f 63 6b 2d 63 36		        .text "block-c65-init"
>c82d		35 2d 69 6e 69 74
.c833						+
.c833						nt_block_ramdrive_init:
>c833		13 10				        .byte 19, UF
>c835		4e c8 a7 ae b4 ae		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c83b		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c843		6d 64 72 69 76 65 2d 69 6e 69 74
.c84e						+
.c84e						nt_definitions:
>c84e		0b 00				        .byte 11, 0
>c850		61 c8 39 b2 41 b2		        .word nt_wordlist, xt_definitions, z_definitions
>c856		64 65 66 69 6e 69 74 69		        .text "definitions"
>c85e		6f 6e 73
.c861						nt_wordlist:
>c861		08 00				        .byte 8, 0
>c863		71 c8 a4 b3 ba b3		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c869		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c871						nt_search_wordlist:
>c871		0f 10				        .byte 15, UF
>c873		88 c8 dd b2 50 b3		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c879		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c881		6f 72 64 6c 69 73 74
.c888						nt_set_current:
>c888		0b 10				        .byte 11, UF
>c88a		9b c8 51 b3 5c b3		        .word nt_get_current, xt_set_current, z_set_current
>c890		73 65 74 2d 63 75 72 72		        .text "set-current"
>c898		65 6e 74
.c89b						nt_get_current:
>c89b		0b 00				        .byte 11, 0
>c89d		ae c8 49 b2 53 b2		        .word nt_set_order, xt_get_current, z_get_current
>c8a3		67 65 74 2d 63 75 72 72		        .text "get-current"
>c8ab		65 6e 74
.c8ae						nt_set_order:
>c8ae		09 00				        .byte 9, 0
>c8b0		bf c8 5d b3 90 b3		        .word nt_get_order, xt_set_order, z_set_order
>c8b6		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c8be		72
.c8bf						nt_get_order:
>c8bf		09 00				        .byte 9, 0
>c8c1		d0 c8 54 b2 7c b2		        .word nt_root_wordlist, xt_get_order, z_get_order
>c8c7		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c8cf		72
.c8d0						nt_root_wordlist:
>c8d0		0d 00				        .byte 13, 0
>c8d2		e5 c8 d4 b2 dc b2		        .word +, xt_root_wordlist, z_root_wordlist
>c8d8		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c8e0		64 6c 69 73 74
.c8e5						+
.c8e5						nt_assembler_wordlist:
>c8e5		12 00				        .byte 18, 0
>c8e7		ff c8 02 9e 0a 9e		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c8ed		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c8f5		72 2d 77 6f 72 64 6c 69 73 74
.c8ff						+
.c8ff						nt_editor_wordlist:
>c8ff		0f 00				        .byte 15, 0
>c901		16 c9 d1 9d d9 9d		        .word +, xt_editor_wordlist, z_editor_wordlist
>c907		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c90f		6f 72 64 6c 69 73 74
.c916						+
.c916						nt_forth_wordlist:
>c916		0e 00				        .byte 14, 0
>c918		2c c9 37 9e 3d 9e		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c91e		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c926		72 64 6c 69 73 74
.c92c						nt_only:
>c92c		04 00				        .byte 4, 0
>c92e		38 c9 7d b2 83 b2		        .word nt_also, xt_only, z_only
>c934		6f 6e 6c 79			        .text "only"
.c938						nt_also:
>c938		04 00				        .byte 4, 0
>c93a		44 c9 29 b2 38 b2		        .word nt_previous, xt_also, z_also
>c940		61 6c 73 6f			        .text "also"
.c944						nt_previous:
>c944		08 00				        .byte 8, 0
>c946		54 c9 c7 b2 d3 b2		        .word nt_to_order, xt_previous, z_previous
>c94c		70 72 65 76 69 6f 75 73		        .text "previous"
.c954						nt_to_order:
>c954		06 00				        .byte 6, 0
>c956		62 c9 91 b3 a3 b3		        .word nt_order, xt_to_order, z_to_order
>c95c		3e 6f 72 64 65 72		        .text ">order"
.c962						nt_order:
>c962		05 00				        .byte 5, 0
>c964		6f c9 84 b2 ae b2		        .word nt_forth, xt_order, z_order
>c96a		6f 72 64 65 72			        .text "order"
.c96f						nt_forth:
>c96f		05 00				        .byte 5, 0
>c971		7c c9 42 b2 48 b2		        .word +, xt_forth, z_forth
>c977		66 6f 72 74 68			        .text "forth"
.c97c						+
>c97c		03 08				nt_see: .byte 3, NN
>c97e		87 c9 69 99 f6 99		        .word +, xt_see, z_see
>c984		73 65 65			        .text "see"
.c987						+
.c987						nt_ed:
>c987		03 08				        .byte 3, NN
>c989		92 c9 f6 a7 f9 a7		        .word +, xt_ed, z_ed
>c98f		65 64 3a			        .text "ed:"
.c992						+
.c992						nt_cold:
>c992		04 00				        .byte 4, 0
>c994		9e c9 00 80 b1 80		        .word nt_bye, xt_cold, z_cold
>c99a		63 6f 6c 64			        .text "cold"
.c99e						nt_bye:
>c99e		03				        .byte 3         ; length of word strings
>c99f		00				        .byte 0         ; status byte
>c9a0		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>c9a2		a0 98				        .word xt_bye    ; start of code block (xt of this word)
>c9a4		a3 98				        .word z_bye     ; end of code (RTS)
>c9a6		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.c9a9						root_dictionary_start:
.c9a9						nt_root_set_order:
>c9a9		09 00				        .byte 9, 0
>c9ab		ba c9 5d b3 90 b3		        .word nt_root_forth, xt_set_order, z_set_order
>c9b1		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c9b9		72
.c9ba						nt_root_forth:
>c9ba		05 00				        .byte 5, 0
>c9bc		c7 c9 42 b2 48 b2		        .word nt_root_forth_wordlist, xt_forth, z_forth
>c9c2		66 6f 72 74 68			        .text "forth"
.c9c7						nt_root_forth_wordlist:
>c9c7		0e 00				        .byte 14, 0
>c9c9		dd c9 37 9e 3d 9e		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>c9cf		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9d7		72 64 6c 69 73 74
.c9dd						nt_root_words:
>c9dd		05 00				        .byte 5, 0
>c9df		00 00 f7 99 53 9a		        .word 0000, xt_words, z_words
>c9e5		77 6f 72 64 73			        .text "words"
.c9ea						editor_dictionary_start:
.c9ea						nt_editor_o:
>c9ea		01 00				        .byte 1, 0
>c9ec		f3 c9 e3 b1 28 b2		        .word nt_editor_line, xt_editor_o, z_editor_o
>c9f2		6f				        .text "o"
.c9f3						nt_editor_line:
>c9f3		04 10				        .byte 4, UF
>c9f5		ff c9 ca b1 e2 b1		        .word nt_editor_l, xt_editor_line, z_editor_line
>c9fb		6c 69 6e 65			        .text "line"
.c9ff						nt_editor_l:
>c9ff		01 00				        .byte 1, 0
>ca01		08 ca 50 b1 c9 b1		        .word nt_editor_el, xt_editor_l, z_editor_l
>ca07		6c				        .text "l"
.ca08						nt_editor_el:
>ca08		02 00				        .byte 2, 0
>ca0a		12 ca 3e b1 4f b1		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>ca10		65 6c				        .text "el"
.ca12						nt_editor_erase_screen:
>ca12		0c 00				        .byte 12, 0
>ca14		26 ca 2c b1 3d b1		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>ca1a		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>ca22		72 65 65 6e
.ca26						nt_editor_enter_screen:
>ca26		0c 00				        .byte 12, 0
>ca28		00 00 10 b1 2b b1		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>ca2e		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>ca36		72 65 65 6e
.ca3a						assembler_dictionary_start:
.ca3a						nt_asm_adc_h:
>ca3a		05 0c						.byte 5, IM+NN
>ca3c		47 ca				                .word nt_asm_adc_x
>ca3e		40 a4 45 a4					.word xt_asm_adc_h, z_asm_adc_h
>ca42		61 64 63 2e 23					.text "adc.#"
.ca47						nt_asm_adc_x:
>ca47		05 0c						.byte 5, IM+NN
>ca49		54 ca				                .word nt_asm_adc_y
>ca4b		45 a4 4a a4					.word xt_asm_adc_x, z_asm_adc_x
>ca4f		61 64 63 2e 78					.text "adc.x"
.ca54						nt_asm_adc_y:
>ca54		05 0c						.byte 5, IM+NN
>ca56		61 ca				                .word nt_asm_adc_z
>ca58		4a a4 4f a4					.word xt_asm_adc_y, z_asm_adc_y
>ca5c		61 64 63 2e 79					.text "adc.y"
.ca61						nt_asm_adc_z:
>ca61		05 0c						.byte 5, IM+NN
>ca63		6e ca				                .word nt_asm_adc_zi
>ca65		4f a4 54 a4					.word xt_asm_adc_z, z_asm_adc_z
>ca69		61 64 63 2e 7a					.text "adc.z"
.ca6e						nt_asm_adc_zi:
>ca6e		06 0c						.byte 6, IM+NN
>ca70		7c ca				                .word nt_asm_adc_ziy
>ca72		54 a4 59 a4					.word xt_asm_adc_zi, z_asm_adc_zi
>ca76		61 64 63 2e 7a 69				.text "adc.zi"
.ca7c						nt_asm_adc_ziy:
>ca7c		07 0c						.byte 7, IM+NN
>ca7e		8b ca				                .word nt_asm_adc_zx
>ca80		59 a4 5e a4					.word xt_asm_adc_ziy, z_asm_adc_ziy
>ca84		61 64 63 2e 7a 69 79				.text "adc.ziy"
.ca8b						nt_asm_adc_zx:
>ca8b		06 0c						.byte 6, IM+NN
>ca8d		99 ca				                .word nt_asm_adc_zxi
>ca8f		5e a4 63 a4					.word xt_asm_adc_zx, z_asm_adc_zx
>ca93		61 64 63 2e 7a 78				.text "adc.zx"
.ca99						nt_asm_adc_zxi:
>ca99		07 0c						.byte 7, IM+NN
>ca9b		a8 ca				                .word nt_asm_and
>ca9d		63 a4 68 a4					.word xt_asm_adc_zxi, z_asm_adc_zxi
>caa1		61 64 63 2e 7a 78 69				.text "adc.zxi"
.caa8						nt_asm_and:
>caa8		04 0c						.byte 4, IM+NN
>caaa		b4 ca				                .word nt_asm_and_h
>caac		68 a4 6d a4					.word xt_asm_and, z_asm_and
>cab0		61 6e 64 2e					.text "and."
.cab4						nt_asm_and_h:
>cab4		05 0c						.byte 5, IM+NN
>cab6		c1 ca				                .word nt_asm_and_x
>cab8		6d a4 72 a4					.word xt_asm_and_h, z_asm_and_h
>cabc		61 6e 64 2e 23					.text "and.#"
.cac1						nt_asm_and_x:
>cac1		05 0c						.byte 5, IM+NN
>cac3		ce ca				                .word nt_asm_and_y
>cac5		72 a4 77 a4					.word xt_asm_and_x, z_asm_and_x
>cac9		61 6e 64 2e 78					.text "and.x"
.cace						nt_asm_and_y:
>cace		05 0c						.byte 5, IM+NN
>cad0		db ca				                .word nt_asm_and_z
>cad2		77 a4 7c a4					.word xt_asm_and_y, z_asm_and_y
>cad6		61 6e 64 2e 79					.text "and.y"
.cadb						nt_asm_and_z:
>cadb		05 0c						.byte 5, IM+NN
>cadd		e8 ca				                .word nt_asm_and_zi
>cadf		7c a4 81 a4					.word xt_asm_and_z, z_asm_and_z
>cae3		61 6e 64 2e 7a					.text "and.z"
.cae8						nt_asm_and_zi:
>cae8		06 0c						.byte 6, IM+NN
>caea		f6 ca				                .word nt_asm_and_ziy
>caec		81 a4 86 a4					.word xt_asm_and_zi, z_asm_and_zi
>caf0		61 6e 64 2e 7a 69				.text "and.zi"
.caf6						nt_asm_and_ziy:
>caf6		07 0c						.byte 7, IM+NN
>caf8		05 cb				                .word nt_asm_and_zx
>cafa		86 a4 8b a4					.word xt_asm_and_ziy, z_asm_and_ziy
>cafe		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cb05						nt_asm_and_zx:
>cb05		06 0c						.byte 6, IM+NN
>cb07		13 cb				                .word nt_asm_and_zxi
>cb09		8b a4 90 a4					.word xt_asm_and_zx, z_asm_and_zx
>cb0d		61 6e 64 2e 7a 78				.text "and.zx"
.cb13						nt_asm_and_zxi:
>cb13		07 0c						.byte 7, IM+NN
>cb15		22 cb				                .word nt_asm_asl
>cb17		90 a4 95 a4					.word xt_asm_and_zxi, z_asm_and_zxi
>cb1b		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cb22						nt_asm_asl:
>cb22		03 0c						.byte 3, IM+NN
>cb24		2d cb				                .word nt_asm_asl_a
>cb26		95 a4 9a a4					.word xt_asm_asl, z_asm_asl
>cb2a		61 73 6c					.text "asl"
.cb2d						nt_asm_asl_a:
>cb2d		05 0c						.byte 5, IM+NN
>cb2f		3a cb				                .word nt_asm_asl_x
>cb31		9a a4 9f a4					.word xt_asm_asl_a, z_asm_asl_a
>cb35		61 73 6c 2e 61					.text "asl.a"
.cb3a						nt_asm_asl_x:
>cb3a		05 0c						.byte 5, IM+NN
>cb3c		47 cb				                .word nt_asm_asl_z
>cb3e		9f a4 a4 a4					.word xt_asm_asl_x, z_asm_asl_x
>cb42		61 73 6c 2e 78					.text "asl.x"
.cb47						nt_asm_asl_z:
>cb47		05 0c						.byte 5, IM+NN
>cb49		54 cb				                .word nt_asm_asl_zx
>cb4b		a4 a4 a9 a4					.word xt_asm_asl_z, z_asm_asl_z
>cb4f		61 73 6c 2e 7a					.text "asl.z"
.cb54						nt_asm_asl_zx:
>cb54		06 0c						.byte 6, IM+NN
>cb56		62 cb				                .word nt_asm_bcc
>cb58		a9 a4 ae a4					.word xt_asm_asl_zx, z_asm_asl_zx
>cb5c		61 73 6c 2e 7a 78				.text "asl.zx"
.cb62						nt_asm_bcc:
>cb62		03 0c						.byte 3, IM+NN
>cb64		6d cb				                .word nt_asm_bcs
>cb66		ae a4 b3 a4					.word xt_asm_bcc, z_asm_bcc
>cb6a		62 63 63					.text "bcc"
.cb6d						nt_asm_bcs:
>cb6d		03 0c						.byte 3, IM+NN
>cb6f		78 cb				                .word nt_asm_beq
>cb71		b3 a4 ba a4					.word xt_asm_bcs, z_asm_bcs
>cb75		62 63 73					.text "bcs"
.cb78						nt_asm_beq:
>cb78		03 0c						.byte 3, IM+NN
>cb7a		83 cb				                .word nt_asm_bit
>cb7c		ba a4 bf a4					.word xt_asm_beq, z_asm_beq
>cb80		62 65 71					.text "beq"
.cb83						nt_asm_bit:
>cb83		03 0c						.byte 3, IM+NN
>cb85		8e cb				                .word nt_asm_bit_h
>cb87		bf a4 c4 a4					.word xt_asm_bit, z_asm_bit
>cb8b		62 69 74					.text "bit"
.cb8e						nt_asm_bit_h:
>cb8e		05 0c						.byte 5, IM+NN
>cb90		9b cb				                .word nt_asm_bit_x
>cb92		c4 a4 c9 a4					.word xt_asm_bit_h, z_asm_bit_h
>cb96		62 69 74 2e 23					.text "bit.#"
.cb9b						nt_asm_bit_x:
>cb9b		05 0c						.byte 5, IM+NN
>cb9d		a8 cb				                .word nt_asm_bit_z
>cb9f		c9 a4 ce a4					.word xt_asm_bit_x, z_asm_bit_x
>cba3		62 69 74 2e 78					.text "bit.x"
.cba8						nt_asm_bit_z:
>cba8		05 0c						.byte 5, IM+NN
>cbaa		b5 cb				                .word nt_asm_bit_zx
>cbac		ce a4 d3 a4					.word xt_asm_bit_z, z_asm_bit_z
>cbb0		62 69 74 2e 7a					.text "bit.z"
.cbb5						nt_asm_bit_zx:
>cbb5		06 0c						.byte 6, IM+NN
>cbb7		c3 cb				                .word nt_asm_bmi
>cbb9		d3 a4 d8 a4					.word xt_asm_bit_zx, z_asm_bit_zx
>cbbd		62 69 74 2e 7a 78				.text "bit.zx"
.cbc3						nt_asm_bmi:
>cbc3		03 0c						.byte 3, IM+NN
>cbc5		ce cb				                .word nt_asm_bne
>cbc7		d8 a4 dd a4					.word xt_asm_bmi, z_asm_bmi
>cbcb		62 6d 69					.text "bmi"
.cbce						nt_asm_bne:
>cbce		03 0c						.byte 3, IM+NN
>cbd0		d9 cb				                .word nt_asm_bpl
>cbd2		dd a4 e2 a4					.word xt_asm_bne, z_asm_bne
>cbd6		62 6e 65					.text "bne"
.cbd9						nt_asm_bpl:
>cbd9		03 0c						.byte 3, IM+NN
>cbdb		e4 cb				                .word nt_asm_bra
>cbdd		e2 a4 e7 a4					.word xt_asm_bpl, z_asm_bpl
>cbe1		62 70 6c					.text "bpl"
.cbe4						nt_asm_bra:
>cbe4		03 0c						.byte 3, IM+NN
>cbe6		ef cb				                .word nt_asm_brk
>cbe8		e7 a4 ec a4					.word xt_asm_bra, z_asm_bra
>cbec		62 72 61					.text "bra"
.cbef						nt_asm_brk:
>cbef		03 0c						.byte 3, IM+NN
>cbf1		fa cb				                .word nt_asm_bvc
>cbf3		ec a4 f1 a4					.word xt_asm_brk, z_asm_brk
>cbf7		62 72 6b					.text "brk"
.cbfa						nt_asm_bvc:
>cbfa		03 0c						.byte 3, IM+NN
>cbfc		05 cc				                .word nt_asm_bvs
>cbfe		f1 a4 f6 a4					.word xt_asm_bvc, z_asm_bvc
>cc02		62 76 63					.text "bvc"
.cc05						nt_asm_bvs:
>cc05		03 0c						.byte 3, IM+NN
>cc07		10 cc				                .word nt_asm_clc
>cc09		f6 a4 fb a4					.word xt_asm_bvs, z_asm_bvs
>cc0d		62 76 73					.text "bvs"
.cc10						nt_asm_clc:
>cc10		03 0c						.byte 3, IM+NN
>cc12		1b cc				                .word nt_asm_cld
>cc14		fb a4 00 a5					.word xt_asm_clc, z_asm_clc
>cc18		63 6c 63					.text "clc"
.cc1b						nt_asm_cld:
>cc1b		03 0c						.byte 3, IM+NN
>cc1d		26 cc				                .word nt_asm_cli
>cc1f		00 a5 05 a5					.word xt_asm_cld, z_asm_cld
>cc23		63 6c 64					.text "cld"
.cc26						nt_asm_cli:
>cc26		03 0c						.byte 3, IM+NN
>cc28		31 cc				                .word nt_asm_clv
>cc2a		05 a5 0a a5					.word xt_asm_cli, z_asm_cli
>cc2e		63 6c 69					.text "cli"
.cc31						nt_asm_clv:
>cc31		03 0c						.byte 3, IM+NN
>cc33		3c cc				                .word nt_asm_cmp
>cc35		0a a5 0f a5					.word xt_asm_clv, z_asm_clv
>cc39		63 6c 76					.text "clv"
.cc3c						nt_asm_cmp:
>cc3c		03 0c						.byte 3, IM+NN
>cc3e		47 cc				                .word nt_asm_cmp_h
>cc40		0f a5 14 a5					.word xt_asm_cmp, z_asm_cmp
>cc44		63 6d 70					.text "cmp"
.cc47						nt_asm_cmp_h:
>cc47		05 0c						.byte 5, IM+NN
>cc49		54 cc				                .word nt_asm_cmp_x
>cc4b		14 a5 19 a5					.word xt_asm_cmp_h, z_asm_cmp_h
>cc4f		63 6d 70 2e 23					.text "cmp.#"
.cc54						nt_asm_cmp_x:
>cc54		05 0c						.byte 5, IM+NN
>cc56		61 cc				                .word nt_asm_cmp_y
>cc58		19 a5 1e a5					.word xt_asm_cmp_x, z_asm_cmp_x
>cc5c		63 6d 70 2e 78					.text "cmp.x"
.cc61						nt_asm_cmp_y:
>cc61		05 0c						.byte 5, IM+NN
>cc63		6e cc				                .word nt_asm_cmp_z
>cc65		1e a5 23 a5					.word xt_asm_cmp_y, z_asm_cmp_y
>cc69		63 6d 70 2e 79					.text "cmp.y"
.cc6e						nt_asm_cmp_z:
>cc6e		05 0c						.byte 5, IM+NN
>cc70		7b cc				                .word nt_asm_cmp_zi
>cc72		23 a5 28 a5					.word xt_asm_cmp_z, z_asm_cmp_z
>cc76		63 6d 70 2e 7a					.text "cmp.z"
.cc7b						nt_asm_cmp_zi:
>cc7b		06 0c						.byte 6, IM+NN
>cc7d		89 cc				                .word nt_asm_cmp_ziy
>cc7f		28 a5 2d a5					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cc83		63 6d 70 2e 7a 69				.text "cmp.zi"
.cc89						nt_asm_cmp_ziy:
>cc89		07 0c						.byte 7, IM+NN
>cc8b		98 cc				                .word nt_asm_cmp_zx
>cc8d		2d a5 32 a5					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cc91		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cc98						nt_asm_cmp_zx:
>cc98		06 0c						.byte 6, IM+NN
>cc9a		a6 cc				                .word nt_asm_cmp_zxi
>cc9c		32 a5 37 a5					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cca0		63 6d 70 2e 7a 78				.text "cmp.zx"
.cca6						nt_asm_cmp_zxi:
>cca6		07 0c						.byte 7, IM+NN
>cca8		b5 cc				                .word nt_asm_cpx
>ccaa		37 a5 3c a5					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>ccae		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.ccb5						nt_asm_cpx:
>ccb5		03 0c						.byte 3, IM+NN
>ccb7		c0 cc				                .word nt_asm_cpx_h
>ccb9		3c a5 41 a5					.word xt_asm_cpx, z_asm_cpx
>ccbd		63 70 78					.text "cpx"
.ccc0						nt_asm_cpx_h:
>ccc0		05 0c						.byte 5, IM+NN
>ccc2		cd cc				                .word nt_asm_cpx_z
>ccc4		41 a5 46 a5					.word xt_asm_cpx_h, z_asm_cpx_h
>ccc8		63 70 78 2e 23					.text "cpx.#"
.cccd						nt_asm_cpx_z:
>cccd		05 0c						.byte 5, IM+NN
>cccf		da cc				                .word nt_asm_cpy
>ccd1		46 a5 4b a5					.word xt_asm_cpx_z, z_asm_cpx_z
>ccd5		63 70 78 2e 7a					.text "cpx.z"
.ccda						nt_asm_cpy:
>ccda		03 0c						.byte 3, IM+NN
>ccdc		e5 cc				                .word nt_asm_cpy_h
>ccde		4b a5 52 a5					.word xt_asm_cpy, z_asm_cpy
>cce2		63 70 79					.text "cpy"
.cce5						nt_asm_cpy_h:
>cce5		05 0c						.byte 5, IM+NN
>cce7		f2 cc				                .word nt_asm_cpy_z
>cce9		52 a5 57 a5					.word xt_asm_cpy_h, z_asm_cpy_h
>cced		63 70 79 2e 23					.text "cpy.#"
.ccf2						nt_asm_cpy_z:
>ccf2		05 0c						.byte 5, IM+NN
>ccf4		ff cc				                .word nt_asm_dec
>ccf6		57 a5 5c a5					.word xt_asm_cpy_z, z_asm_cpy_z
>ccfa		63 70 79 2e 7a					.text "cpy.z"
.ccff						nt_asm_dec:
>ccff		03 0c						.byte 3, IM+NN
>cd01		0a cd				                .word nt_asm_dec_a
>cd03		5c a5 61 a5					.word xt_asm_dec, z_asm_dec
>cd07		64 65 63					.text "dec"
.cd0a						nt_asm_dec_a:
>cd0a		05 0c						.byte 5, IM+NN
>cd0c		17 cd				                .word nt_asm_dec_x
>cd0e		61 a5 66 a5					.word xt_asm_dec_a, z_asm_dec_a
>cd12		64 65 63 2e 61					.text "dec.a"
.cd17						nt_asm_dec_x:
>cd17		05 0c						.byte 5, IM+NN
>cd19		24 cd				                .word nt_asm_dec_z
>cd1b		66 a5 6b a5					.word xt_asm_dec_x, z_asm_dec_x
>cd1f		64 65 63 2e 78					.text "dec.x"
.cd24						nt_asm_dec_z:
>cd24		05 0c						.byte 5, IM+NN
>cd26		31 cd				                .word nt_asm_dec_zx
>cd28		6b a5 70 a5					.word xt_asm_dec_z, z_asm_dec_z
>cd2c		64 65 63 2e 7a					.text "dec.z"
.cd31						nt_asm_dec_zx:
>cd31		06 0c						.byte 6, IM+NN
>cd33		3f cd				                .word nt_asm_dex
>cd35		70 a5 75 a5					.word xt_asm_dec_zx, z_asm_dec_zx
>cd39		64 65 63 2e 7a 78				.text "dec.zx"
.cd3f						nt_asm_dex:
>cd3f		03 0c						.byte 3, IM+NN
>cd41		4a cd				                .word nt_asm_dey
>cd43		75 a5 7a a5					.word xt_asm_dex, z_asm_dex
>cd47		64 65 78					.text "dex"
.cd4a						nt_asm_dey:
>cd4a		03 0c						.byte 3, IM+NN
>cd4c		55 cd				                .word nt_asm_eor
>cd4e		7a a5 7f a5					.word xt_asm_dey, z_asm_dey
>cd52		64 65 79					.text "dey"
.cd55						nt_asm_eor:
>cd55		03 0c						.byte 3, IM+NN
>cd57		60 cd				                .word nt_asm_eor_h
>cd59		7f a5 84 a5					.word xt_asm_eor, z_asm_eor
>cd5d		65 6f 72					.text "eor"
.cd60						nt_asm_eor_h:
>cd60		05 0c						.byte 5, IM+NN
>cd62		6d cd				                .word nt_asm_eor_x
>cd64		84 a5 89 a5					.word xt_asm_eor_h, z_asm_eor_h
>cd68		65 6f 72 2e 23					.text "eor.#"
.cd6d						nt_asm_eor_x:
>cd6d		05 0c						.byte 5, IM+NN
>cd6f		7a cd				                .word nt_asm_eor_y
>cd71		89 a5 8e a5					.word xt_asm_eor_x, z_asm_eor_x
>cd75		65 6f 72 2e 78					.text "eor.x"
.cd7a						nt_asm_eor_y:
>cd7a		05 0c						.byte 5, IM+NN
>cd7c		87 cd				                .word nt_asm_eor_z
>cd7e		8e a5 93 a5					.word xt_asm_eor_y, z_asm_eor_y
>cd82		65 6f 72 2e 79					.text "eor.y"
.cd87						nt_asm_eor_z:
>cd87		05 0c						.byte 5, IM+NN
>cd89		94 cd				                .word nt_asm_eor_zi
>cd8b		93 a5 98 a5					.word xt_asm_eor_z, z_asm_eor_z
>cd8f		65 6f 72 2e 7a					.text "eor.z"
.cd94						nt_asm_eor_zi:
>cd94		06 0c						.byte 6, IM+NN
>cd96		a2 cd				                .word nt_asm_eor_ziy
>cd98		98 a5 9d a5					.word xt_asm_eor_zi, z_asm_eor_zi
>cd9c		65 6f 72 2e 7a 69				.text "eor.zi"
.cda2						nt_asm_eor_ziy:
>cda2		07 0c						.byte 7, IM+NN
>cda4		b1 cd				                .word nt_asm_eor_zx
>cda6		9d a5 a2 a5					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cdaa		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cdb1						nt_asm_eor_zx:
>cdb1		06 0c						.byte 6, IM+NN
>cdb3		bf cd				                .word nt_asm_eor_zxi
>cdb5		a2 a5 a7 a5					.word xt_asm_eor_zx, z_asm_eor_zx
>cdb9		65 6f 72 2e 7a 78				.text "eor.zx"
.cdbf						nt_asm_eor_zxi:
>cdbf		07 0c						.byte 7, IM+NN
>cdc1		ce cd				                .word nt_asm_inc
>cdc3		a7 a5 ac a5					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cdc7		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cdce						nt_asm_inc:
>cdce		03 0c						.byte 3, IM+NN
>cdd0		d9 cd				                .word nt_asm_inc_a
>cdd2		ac a5 b1 a5					.word xt_asm_inc, z_asm_inc
>cdd6		69 6e 63					.text "inc"
.cdd9						nt_asm_inc_a:
>cdd9		05 0c						.byte 5, IM+NN
>cddb		e6 cd				                .word nt_asm_inc_x
>cddd		b1 a5 b6 a5					.word xt_asm_inc_a, z_asm_inc_a
>cde1		69 6e 63 2e 61					.text "inc.a"
.cde6						nt_asm_inc_x:
>cde6		05 0c						.byte 5, IM+NN
>cde8		f3 cd				                .word nt_asm_inc_z
>cdea		b6 a5 bb a5					.word xt_asm_inc_x, z_asm_inc_x
>cdee		69 6e 63 2e 78					.text "inc.x"
.cdf3						nt_asm_inc_z:
>cdf3		05 0c						.byte 5, IM+NN
>cdf5		00 ce				                .word nt_asm_inc_zx
>cdf7		bb a5 c0 a5					.word xt_asm_inc_z, z_asm_inc_z
>cdfb		69 6e 63 2e 7a					.text "inc.z"
.ce00						nt_asm_inc_zx:
>ce00		06 0c						.byte 6, IM+NN
>ce02		0e ce				                .word nt_asm_inx
>ce04		c0 a5 c5 a5					.word xt_asm_inc_zx, z_asm_inc_zx
>ce08		69 6e 63 2e 7a 78				.text "inc.zx"
.ce0e						nt_asm_inx:
>ce0e		03 0c						.byte 3, IM+NN
>ce10		19 ce				                .word nt_asm_iny
>ce12		c5 a5 ca a5					.word xt_asm_inx, z_asm_inx
>ce16		69 6e 78					.text "inx"
.ce19						nt_asm_iny:
>ce19		03 0c						.byte 3, IM+NN
>ce1b		24 ce				                .word nt_asm_jmp
>ce1d		ca a5 cf a5					.word xt_asm_iny, z_asm_iny
>ce21		69 6e 79					.text "iny"
.ce24						nt_asm_jmp:
>ce24		03 0c						.byte 3, IM+NN
>ce26		2f ce				                .word nt_asm_jmp_i
>ce28		cf a5 d4 a5					.word xt_asm_jmp, z_asm_jmp
>ce2c		6a 6d 70					.text "jmp"
.ce2f						nt_asm_jmp_i:
>ce2f		05 0c						.byte 5, IM+NN
>ce31		3c ce				                .word nt_asm_jmp_xi
>ce33		d4 a5 d9 a5					.word xt_asm_jmp_i, z_asm_jmp_i
>ce37		6a 6d 70 2e 69					.text "jmp.i"
.ce3c						nt_asm_jmp_xi:
>ce3c		06 0c						.byte 6, IM+NN
>ce3e		4a ce				                .word nt_asm_jsr
>ce40		d9 a5 de a5					.word xt_asm_jmp_xi, z_asm_jmp_xi
>ce44		6a 6d 70 2e 78 69				.text "jmp.xi"
.ce4a						nt_asm_jsr:
>ce4a		03 0c						.byte 3, IM+NN
>ce4c		55 ce				                .word nt_asm_lda
>ce4e		de a5 e3 a5					.word xt_asm_jsr, z_asm_jsr
>ce52		6a 73 72					.text "jsr"
.ce55						nt_asm_lda:
>ce55		03 0c						.byte 3, IM+NN
>ce57		60 ce				                .word nt_asm_lda_h
>ce59		e3 a5 e8 a5					.word xt_asm_lda, z_asm_lda
>ce5d		6c 64 61					.text "lda"
.ce60						nt_asm_lda_h:
>ce60		05 0c						.byte 5, IM+NN
>ce62		6d ce				                .word nt_asm_lda_x
>ce64		e8 a5 ed a5					.word xt_asm_lda_h, z_asm_lda_h
>ce68		6c 64 61 2e 23					.text "lda.#"
.ce6d						nt_asm_lda_x:
>ce6d		05 0c						.byte 5, IM+NN
>ce6f		7a ce				                .word nt_asm_lda_y
>ce71		ed a5 f2 a5					.word xt_asm_lda_x, z_asm_lda_x
>ce75		6c 64 61 2e 78					.text "lda.x"
.ce7a						nt_asm_lda_y:
>ce7a		05 0c						.byte 5, IM+NN
>ce7c		87 ce				                .word nt_asm_lda_z
>ce7e		f2 a5 f7 a5					.word xt_asm_lda_y, z_asm_lda_y
>ce82		6c 64 61 2e 79					.text "lda.y"
.ce87						nt_asm_lda_z:
>ce87		05 0c						.byte 5, IM+NN
>ce89		94 ce				                .word nt_asm_lda_zi
>ce8b		f7 a5 fc a5					.word xt_asm_lda_z, z_asm_lda_z
>ce8f		6c 64 61 2e 7a					.text "lda.z"
.ce94						nt_asm_lda_zi:
>ce94		06 0c						.byte 6, IM+NN
>ce96		a2 ce				                .word nt_asm_lda_ziy
>ce98		fc a5 01 a6					.word xt_asm_lda_zi, z_asm_lda_zi
>ce9c		6c 64 61 2e 7a 69				.text "lda.zi"
.cea2						nt_asm_lda_ziy:
>cea2		07 0c						.byte 7, IM+NN
>cea4		b1 ce				                .word nt_asm_lda_zx
>cea6		01 a6 06 a6					.word xt_asm_lda_ziy, z_asm_lda_ziy
>ceaa		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.ceb1						nt_asm_lda_zx:
>ceb1		06 0c						.byte 6, IM+NN
>ceb3		bf ce				                .word nt_asm_lda_zxi
>ceb5		06 a6 0b a6					.word xt_asm_lda_zx, z_asm_lda_zx
>ceb9		6c 64 61 2e 7a 78				.text "lda.zx"
.cebf						nt_asm_lda_zxi:
>cebf		07 0c						.byte 7, IM+NN
>cec1		ce ce				                .word nt_asm_ldx
>cec3		0b a6 10 a6					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cec7		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cece						nt_asm_ldx:
>cece		03 0c						.byte 3, IM+NN
>ced0		d9 ce				                .word nt_asm_ldx_h
>ced2		10 a6 15 a6					.word xt_asm_ldx, z_asm_ldx
>ced6		6c 64 78					.text "ldx"
.ced9						nt_asm_ldx_h:
>ced9		05 0c						.byte 5, IM+NN
>cedb		e6 ce				                .word nt_asm_ldx_y
>cedd		15 a6 1a a6					.word xt_asm_ldx_h, z_asm_ldx_h
>cee1		6c 64 78 2e 23					.text "ldx.#"
.cee6						nt_asm_ldx_y:
>cee6		05 0c						.byte 5, IM+NN
>cee8		f3 ce				                .word nt_asm_ldx_z
>ceea		1a a6 1f a6					.word xt_asm_ldx_y, z_asm_ldx_y
>ceee		6c 64 78 2e 79					.text "ldx.y"
.cef3						nt_asm_ldx_z:
>cef3		05 0c						.byte 5, IM+NN
>cef5		00 cf				                .word nt_asm_ldx_zy
>cef7		1f a6 24 a6					.word xt_asm_ldx_z, z_asm_ldx_z
>cefb		6c 64 78 2e 7a					.text "ldx.z"
.cf00						nt_asm_ldx_zy:
>cf00		06 0c						.byte 6, IM+NN
>cf02		0e cf				                .word nt_asm_ldy
>cf04		24 a6 29 a6					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cf08		6c 64 78 2e 7a 79				.text "ldx.zy"
.cf0e						nt_asm_ldy:
>cf0e		03 0c						.byte 3, IM+NN
>cf10		19 cf				                .word nt_asm_ldy_h
>cf12		29 a6 2e a6					.word xt_asm_ldy, z_asm_ldy
>cf16		6c 64 79					.text "ldy"
.cf19						nt_asm_ldy_h:
>cf19		05 0c						.byte 5, IM+NN
>cf1b		26 cf				                .word nt_asm_ldy_x
>cf1d		2e a6 33 a6					.word xt_asm_ldy_h, z_asm_ldy_h
>cf21		6c 64 79 2e 23					.text "ldy.#"
.cf26						nt_asm_ldy_x:
>cf26		05 0c						.byte 5, IM+NN
>cf28		33 cf				                .word nt_asm_ldy_z
>cf2a		33 a6 38 a6					.word xt_asm_ldy_x, z_asm_ldy_x
>cf2e		6c 64 79 2e 78					.text "ldy.x"
.cf33						nt_asm_ldy_z:
>cf33		05 0c						.byte 5, IM+NN
>cf35		40 cf				                .word nt_asm_ldy_zx
>cf37		38 a6 3d a6					.word xt_asm_ldy_z, z_asm_ldy_z
>cf3b		6c 64 79 2e 7a					.text "ldy.z"
.cf40						nt_asm_ldy_zx:
>cf40		06 0c						.byte 6, IM+NN
>cf42		4e cf				                .word nt_asm_lsr
>cf44		3d a6 42 a6					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cf48		6c 64 79 2e 7a 78				.text "ldy.zx"
.cf4e						nt_asm_lsr:
>cf4e		03 0c						.byte 3, IM+NN
>cf50		59 cf				                .word nt_asm_lsr_a
>cf52		42 a6 47 a6					.word xt_asm_lsr, z_asm_lsr
>cf56		6c 73 72					.text "lsr"
.cf59						nt_asm_lsr_a:
>cf59		05 0c						.byte 5, IM+NN
>cf5b		66 cf				                .word nt_asm_lsr_x
>cf5d		47 a6 4c a6					.word xt_asm_lsr_a, z_asm_lsr_a
>cf61		6c 73 72 2e 61					.text "lsr.a"
.cf66						nt_asm_lsr_x:
>cf66		05 0c						.byte 5, IM+NN
>cf68		73 cf				                .word nt_asm_lsr_z
>cf6a		4c a6 51 a6					.word xt_asm_lsr_x, z_asm_lsr_x
>cf6e		6c 73 72 2e 78					.text "lsr.x"
.cf73						nt_asm_lsr_z:
>cf73		05 0c						.byte 5, IM+NN
>cf75		80 cf				                .word nt_asm_lsr_zx
>cf77		51 a6 56 a6					.word xt_asm_lsr_z, z_asm_lsr_z
>cf7b		6c 73 72 2e 7a					.text "lsr.z"
.cf80						nt_asm_lsr_zx:
>cf80		06 0c						.byte 6, IM+NN
>cf82		8e cf				                .word nt_asm_nop
>cf84		56 a6 5b a6					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cf88		6c 73 72 2e 7a 78				.text "lsr.zx"
.cf8e						nt_asm_nop:
>cf8e		03 0c						.byte 3, IM+NN
>cf90		99 cf				                .word nt_asm_ora
>cf92		5b a6 60 a6					.word xt_asm_nop, z_asm_nop
>cf96		6e 6f 70					.text "nop"
.cf99						nt_asm_ora:
>cf99		03 0c						.byte 3, IM+NN
>cf9b		a4 cf				                .word nt_asm_ora_h
>cf9d		60 a6 65 a6					.word xt_asm_ora, z_asm_ora
>cfa1		6f 72 61					.text "ora"
.cfa4						nt_asm_ora_h:
>cfa4		05 0c						.byte 5, IM+NN
>cfa6		b1 cf				                .word nt_asm_ora_x
>cfa8		65 a6 6a a6					.word xt_asm_ora_h, z_asm_ora_h
>cfac		6f 72 61 2e 23					.text "ora.#"
.cfb1						nt_asm_ora_x:
>cfb1		05 0c						.byte 5, IM+NN
>cfb3		be cf				                .word nt_asm_ora_y
>cfb5		6a a6 6f a6					.word xt_asm_ora_x, z_asm_ora_x
>cfb9		6f 72 61 2e 78					.text "ora.x"
.cfbe						nt_asm_ora_y:
>cfbe		05 0c						.byte 5, IM+NN
>cfc0		cb cf				                .word nt_asm_ora_z
>cfc2		6f a6 74 a6					.word xt_asm_ora_y, z_asm_ora_y
>cfc6		6f 72 61 2e 79					.text "ora.y"
.cfcb						nt_asm_ora_z:
>cfcb		05 0c						.byte 5, IM+NN
>cfcd		d8 cf				                .word nt_asm_ora_zi
>cfcf		74 a6 79 a6					.word xt_asm_ora_z, z_asm_ora_z
>cfd3		6f 72 61 2e 7a					.text "ora.z"
.cfd8						nt_asm_ora_zi:
>cfd8		06 0c						.byte 6, IM+NN
>cfda		e6 cf				                .word nt_asm_ora_ziy
>cfdc		79 a6 80 a6					.word xt_asm_ora_zi, z_asm_ora_zi
>cfe0		6f 72 61 2e 7a 69				.text "ora.zi"
.cfe6						nt_asm_ora_ziy:
>cfe6		07 0c						.byte 7, IM+NN
>cfe8		f5 cf				                .word nt_asm_ora_zx
>cfea		80 a6 85 a6					.word xt_asm_ora_ziy, z_asm_ora_ziy
>cfee		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.cff5						nt_asm_ora_zx:
>cff5		06 0c						.byte 6, IM+NN
>cff7		03 d0				                .word nt_asm_ora_zxi
>cff9		85 a6 8a a6					.word xt_asm_ora_zx, z_asm_ora_zx
>cffd		6f 72 61 2e 7a 78				.text "ora.zx"
.d003						nt_asm_ora_zxi:
>d003		07 0c						.byte 7, IM+NN
>d005		12 d0				                .word nt_asm_pha
>d007		8a a6 8f a6					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d00b		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d012						nt_asm_pha:
>d012		03 0c						.byte 3, IM+NN
>d014		1d d0				                .word nt_asm_php
>d016		8f a6 94 a6					.word xt_asm_pha, z_asm_pha
>d01a		70 68 61					.text "pha"
.d01d						nt_asm_php:
>d01d		03 0c						.byte 3, IM+NN
>d01f		28 d0				                .word nt_asm_phx
>d021		94 a6 99 a6					.word xt_asm_php, z_asm_php
>d025		70 68 70					.text "php"
.d028						nt_asm_phx:
>d028		03 0c						.byte 3, IM+NN
>d02a		33 d0				                .word nt_asm_phy
>d02c		99 a6 9e a6					.word xt_asm_phx, z_asm_phx
>d030		70 68 78					.text "phx"
.d033						nt_asm_phy:
>d033		03 0c						.byte 3, IM+NN
>d035		3e d0				                .word nt_asm_pla
>d037		9e a6 a3 a6					.word xt_asm_phy, z_asm_phy
>d03b		70 68 79					.text "phy"
.d03e						nt_asm_pla:
>d03e		03 0c						.byte 3, IM+NN
>d040		49 d0				                .word nt_asm_plp
>d042		a3 a6 a8 a6					.word xt_asm_pla, z_asm_pla
>d046		70 6c 61					.text "pla"
.d049						nt_asm_plp:
>d049		03 0c						.byte 3, IM+NN
>d04b		54 d0				                .word nt_asm_plx
>d04d		a8 a6 ad a6					.word xt_asm_plp, z_asm_plp
>d051		70 6c 70					.text "plp"
.d054						nt_asm_plx:
>d054		03 0c						.byte 3, IM+NN
>d056		5f d0				                .word nt_asm_ply
>d058		ad a6 b2 a6					.word xt_asm_plx, z_asm_plx
>d05c		70 6c 78					.text "plx"
.d05f						nt_asm_ply:
>d05f		03 0c						.byte 3, IM+NN
>d061		6a d0				                .word nt_asm_rol
>d063		b2 a6 b7 a6					.word xt_asm_ply, z_asm_ply
>d067		70 6c 79					.text "ply"
.d06a						nt_asm_rol:
>d06a		03 0c						.byte 3, IM+NN
>d06c		75 d0				                .word nt_asm_rol_a
>d06e		b7 a6 bc a6					.word xt_asm_rol, z_asm_rol
>d072		72 6f 6c					.text "rol"
.d075						nt_asm_rol_a:
>d075		05 0c						.byte 5, IM+NN
>d077		82 d0				                .word nt_asm_rol_x
>d079		bc a6 c1 a6					.word xt_asm_rol_a, z_asm_rol_a
>d07d		72 6f 6c 2e 61					.text "rol.a"
.d082						nt_asm_rol_x:
>d082		05 0c						.byte 5, IM+NN
>d084		8f d0				                .word nt_asm_rol_z
>d086		c1 a6 c6 a6					.word xt_asm_rol_x, z_asm_rol_x
>d08a		72 6f 6c 2e 78					.text "rol.x"
.d08f						nt_asm_rol_z:
>d08f		05 0c						.byte 5, IM+NN
>d091		9c d0				                .word nt_asm_rol_zx
>d093		c6 a6 cb a6					.word xt_asm_rol_z, z_asm_rol_z
>d097		72 6f 6c 2e 7a					.text "rol.z"
.d09c						nt_asm_rol_zx:
>d09c		06 0c						.byte 6, IM+NN
>d09e		aa d0				                .word nt_asm_ror
>d0a0		cb a6 d0 a6					.word xt_asm_rol_zx, z_asm_rol_zx
>d0a4		72 6f 6c 2e 7a 78				.text "rol.zx"
.d0aa						nt_asm_ror:
>d0aa		03 0c						.byte 3, IM+NN
>d0ac		b5 d0				                .word nt_asm_ror_a
>d0ae		d0 a6 d5 a6					.word xt_asm_ror, z_asm_ror
>d0b2		72 6f 72					.text "ror"
.d0b5						nt_asm_ror_a:
>d0b5		05 0c						.byte 5, IM+NN
>d0b7		c2 d0				                .word nt_asm_ror_x
>d0b9		d5 a6 da a6					.word xt_asm_ror_a, z_asm_ror_a
>d0bd		72 6f 72 2e 61					.text "ror.a"
.d0c2						nt_asm_ror_x:
>d0c2		05 0c						.byte 5, IM+NN
>d0c4		cf d0				                .word nt_asm_ror_z
>d0c6		da a6 df a6					.word xt_asm_ror_x, z_asm_ror_x
>d0ca		72 6f 72 2e 78					.text "ror.x"
.d0cf						nt_asm_ror_z:
>d0cf		05 0c						.byte 5, IM+NN
>d0d1		dc d0				                .word nt_asm_ror_zx
>d0d3		df a6 e4 a6					.word xt_asm_ror_z, z_asm_ror_z
>d0d7		72 6f 72 2e 7a					.text "ror.z"
.d0dc						nt_asm_ror_zx:
>d0dc		06 0c						.byte 6, IM+NN
>d0de		ea d0				                .word nt_asm_rti
>d0e0		e4 a6 e9 a6					.word xt_asm_ror_zx, z_asm_ror_zx
>d0e4		72 6f 72 2e 7a 78				.text "ror.zx"
.d0ea						nt_asm_rti:
>d0ea		03 0c						.byte 3, IM+NN
>d0ec		f5 d0				                .word nt_asm_rts
>d0ee		e9 a6 ee a6					.word xt_asm_rti, z_asm_rti
>d0f2		72 74 69					.text "rti"
.d0f5						nt_asm_rts:
>d0f5		03 0c						.byte 3, IM+NN
>d0f7		00 d1				                .word nt_asm_sbc
>d0f9		ee a6 f3 a6					.word xt_asm_rts, z_asm_rts
>d0fd		72 74 73					.text "rts"
.d100						nt_asm_sbc:
>d100		03 0c						.byte 3, IM+NN
>d102		0b d1				                .word nt_asm_sbc_h
>d104		f3 a6 f8 a6					.word xt_asm_sbc, z_asm_sbc
>d108		73 62 63					.text "sbc"
.d10b						nt_asm_sbc_h:
>d10b		05 0c						.byte 5, IM+NN
>d10d		18 d1				                .word nt_asm_sbc_x
>d10f		f8 a6 fd a6					.word xt_asm_sbc_h, z_asm_sbc_h
>d113		73 62 63 2e 23					.text "sbc.#"
.d118						nt_asm_sbc_x:
>d118		05 0c						.byte 5, IM+NN
>d11a		25 d1				                .word nt_asm_sbc_y
>d11c		fd a6 02 a7					.word xt_asm_sbc_x, z_asm_sbc_x
>d120		73 62 63 2e 78					.text "sbc.x"
.d125						nt_asm_sbc_y:
>d125		05 0c						.byte 5, IM+NN
>d127		32 d1				                .word nt_asm_sbc_z
>d129		02 a7 07 a7					.word xt_asm_sbc_y, z_asm_sbc_y
>d12d		73 62 63 2e 79					.text "sbc.y"
.d132						nt_asm_sbc_z:
>d132		05 0c						.byte 5, IM+NN
>d134		3f d1				                .word nt_asm_sbc_zi
>d136		07 a7 0c a7					.word xt_asm_sbc_z, z_asm_sbc_z
>d13a		73 62 63 2e 7a					.text "sbc.z"
.d13f						nt_asm_sbc_zi:
>d13f		06 0c						.byte 6, IM+NN
>d141		4d d1				                .word nt_asm_sbc_ziy
>d143		0c a7 11 a7					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d147		73 62 63 2e 7a 69				.text "sbc.zi"
.d14d						nt_asm_sbc_ziy:
>d14d		07 0c						.byte 7, IM+NN
>d14f		5c d1				                .word nt_asm_sbc_zx
>d151		11 a7 16 a7					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d155		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d15c						nt_asm_sbc_zx:
>d15c		06 0c						.byte 6, IM+NN
>d15e		6a d1				                .word nt_asm_sbc_zxi
>d160		16 a7 1b a7					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d164		73 62 63 2e 7a 78				.text "sbc.zx"
.d16a						nt_asm_sbc_zxi:
>d16a		07 0c						.byte 7, IM+NN
>d16c		79 d1				                .word nt_asm_sec
>d16e		1b a7 1f a7					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d172		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d179						nt_asm_sec:
>d179		03 0c						.byte 3, IM+NN
>d17b		84 d1				                .word nt_asm_sed
>d17d		1f a7 23 a7					.word xt_asm_sec, z_asm_sec
>d181		73 65 63					.text "sec"
.d184						nt_asm_sed:
>d184		03 0c						.byte 3, IM+NN
>d186		8f d1				                .word nt_asm_sei
>d188		23 a7 27 a7					.word xt_asm_sed, z_asm_sed
>d18c		73 65 64					.text "sed"
.d18f						nt_asm_sei:
>d18f		03 0c						.byte 3, IM+NN
>d191		9a d1				                .word nt_asm_sta
>d193		27 a7 2b a7					.word xt_asm_sei, z_asm_sei
>d197		73 65 69					.text "sei"
.d19a						nt_asm_sta:
>d19a		03 0c						.byte 3, IM+NN
>d19c		a5 d1				                .word nt_asm_sta_x
>d19e		2b a7 2f a7					.word xt_asm_sta, z_asm_sta
>d1a2		73 74 61					.text "sta"
.d1a5						nt_asm_sta_x:
>d1a5		05 0c						.byte 5, IM+NN
>d1a7		b2 d1				                .word nt_asm_sta_y
>d1a9		2f a7 33 a7					.word xt_asm_sta_x, z_asm_sta_x
>d1ad		73 74 61 2e 78					.text "sta.x"
.d1b2						nt_asm_sta_y:
>d1b2		05 0c						.byte 5, IM+NN
>d1b4		bf d1				                .word nt_asm_sta_z
>d1b6		33 a7 37 a7					.word xt_asm_sta_y, z_asm_sta_y
>d1ba		73 74 61 2e 79					.text "sta.y"
.d1bf						nt_asm_sta_z:
>d1bf		05 0c						.byte 5, IM+NN
>d1c1		cc d1				                .word nt_asm_sta_zi
>d1c3		37 a7 3b a7					.word xt_asm_sta_z, z_asm_sta_z
>d1c7		73 74 61 2e 7a					.text "sta.z"
.d1cc						nt_asm_sta_zi:
>d1cc		06 0c						.byte 6, IM+NN
>d1ce		da d1				                .word nt_asm_sta_ziy
>d1d0		3b a7 3f a7					.word xt_asm_sta_zi, z_asm_sta_zi
>d1d4		73 74 61 2e 7a 69				.text "sta.zi"
.d1da						nt_asm_sta_ziy:
>d1da		07 0c						.byte 7, IM+NN
>d1dc		e9 d1				                .word nt_asm_sta_zx
>d1de		3f a7 43 a7					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d1e2		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d1e9						nt_asm_sta_zx:
>d1e9		06 0c						.byte 6, IM+NN
>d1eb		f7 d1				                .word nt_asm_sta_zxi
>d1ed		43 a7 47 a7					.word xt_asm_sta_zx, z_asm_sta_zx
>d1f1		73 74 61 2e 7a 78				.text "sta.zx"
.d1f7						nt_asm_sta_zxi:
>d1f7		07 0c						.byte 7, IM+NN
>d1f9		06 d2				                .word nt_asm_stx
>d1fb		47 a7 4b a7					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d1ff		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d206						nt_asm_stx:
>d206		03 0c						.byte 3, IM+NN
>d208		11 d2				                .word nt_asm_stx_z
>d20a		4b a7 4f a7					.word xt_asm_stx, z_asm_stx
>d20e		73 74 78					.text "stx"
.d211						nt_asm_stx_z:
>d211		05 0c						.byte 5, IM+NN
>d213		1e d2				                .word nt_asm_stx_zy
>d215		4f a7 53 a7					.word xt_asm_stx_z, z_asm_stx_z
>d219		73 74 78 2e 7a					.text "stx.z"
.d21e						nt_asm_stx_zy:
>d21e		06 0c						.byte 6, IM+NN
>d220		2c d2				                .word nt_asm_sty
>d222		53 a7 57 a7					.word xt_asm_stx_zy, z_asm_stx_zy
>d226		73 74 78 2e 7a 79				.text "stx.zy"
.d22c						nt_asm_sty:
>d22c		03 0c						.byte 3, IM+NN
>d22e		37 d2				                .word nt_asm_sty_z
>d230		57 a7 5b a7					.word xt_asm_sty, z_asm_sty
>d234		73 74 79					.text "sty"
.d237						nt_asm_sty_z:
>d237		05 0c						.byte 5, IM+NN
>d239		44 d2				                .word nt_asm_sty_zx
>d23b		5b a7 5f a7					.word xt_asm_sty_z, z_asm_sty_z
>d23f		73 74 79 2e 7a					.text "sty.z"
.d244						nt_asm_sty_zx:
>d244		06 0c						.byte 6, IM+NN
>d246		52 d2				                .word nt_asm_stz
>d248		5f a7 63 a7					.word xt_asm_sty_zx, z_asm_sty_zx
>d24c		73 74 79 2e 7a 78				.text "sty.zx"
.d252						nt_asm_stz:
>d252		03 0c						.byte 3, IM+NN
>d254		5d d2				                .word nt_asm_stz_x
>d256		63 a7 67 a7					.word xt_asm_stz, z_asm_stz
>d25a		73 74 7a					.text "stz"
.d25d						nt_asm_stz_x:
>d25d		05 0c						.byte 5, IM+NN
>d25f		6a d2				                .word nt_asm_stz_z
>d261		67 a7 6b a7					.word xt_asm_stz_x, z_asm_stz_x
>d265		73 74 7a 2e 78					.text "stz.x"
.d26a						nt_asm_stz_z:
>d26a		05 0c						.byte 5, IM+NN
>d26c		77 d2				                .word nt_asm_stz_zx
>d26e		6b a7 6f a7					.word xt_asm_stz_z, z_asm_stz_z
>d272		73 74 7a 2e 7a					.text "stz.z"
.d277						nt_asm_stz_zx:
>d277		06 0c						.byte 6, IM+NN
>d279		85 d2				                .word nt_asm_tax
>d27b		6f a7 73 a7					.word xt_asm_stz_zx, z_asm_stz_zx
>d27f		73 74 7a 2e 7a 78				.text "stz.zx"
.d285						nt_asm_tax:
>d285		03 0c						.byte 3, IM+NN
>d287		90 d2				                .word nt_asm_tay
>d289		73 a7 77 a7					.word xt_asm_tax, z_asm_tax
>d28d		74 61 78					.text "tax"
.d290						nt_asm_tay:
>d290		03 0c						.byte 3, IM+NN
>d292		9b d2				                .word nt_asm_trb
>d294		77 a7 7b a7					.word xt_asm_tay, z_asm_tay
>d298		74 61 79					.text "tay"
.d29b						nt_asm_trb:
>d29b		03 0c						.byte 3, IM+NN
>d29d		a6 d2				                .word nt_asm_trb_z
>d29f		7b a7 7f a7					.word xt_asm_trb, z_asm_trb
>d2a3		74 72 62					.text "trb"
.d2a6						nt_asm_trb_z:
>d2a6		05 0c						.byte 5, IM+NN
>d2a8		b3 d2				                .word nt_asm_tsb
>d2aa		7f a7 83 a7					.word xt_asm_trb_z, z_asm_trb_z
>d2ae		74 72 62 2e 7a					.text "trb.z"
.d2b3						nt_asm_tsb:
>d2b3		03 0c						.byte 3, IM+NN
>d2b5		be d2				                .word nt_asm_tsb_z
>d2b7		83 a7 87 a7					.word xt_asm_tsb, z_asm_tsb
>d2bb		74 73 62					.text "tsb"
.d2be						nt_asm_tsb_z:
>d2be		05 0c						.byte 5, IM+NN
>d2c0		cb d2				                .word nt_asm_tsx
>d2c2		87 a7 8b a7					.word xt_asm_tsb_z, z_asm_tsb_z
>d2c6		74 73 62 2e 7a					.text "tsb.z"
.d2cb						nt_asm_tsx:
>d2cb		03 0c						.byte 3, IM+NN
>d2cd		d6 d2				                .word nt_asm_txa
>d2cf		8b a7 8f a7					.word xt_asm_tsx, z_asm_tsx
>d2d3		74 73 78					.text "tsx"
.d2d6						nt_asm_txa:
>d2d6		03 0c						.byte 3, IM+NN
>d2d8		e1 d2				                .word nt_asm_txs
>d2da		8f a7 93 a7					.word xt_asm_txa, z_asm_txa
>d2de		74 78 61					.text "txa"
.d2e1						nt_asm_txs:
>d2e1		03 0c						.byte 3, IM+NN
>d2e3		ec d2				                .word nt_asm_tya
>d2e5		93 a7 97 a7					.word xt_asm_txs, z_asm_txs
>d2e9		74 78 73					.text "txs"
.d2ec						nt_asm_tya:
>d2ec		03 0c						.byte 3, IM+NN
>d2ee		f7 d2				                .word nt_asm_arrow
>d2f0		97 a7 9b a7					.word xt_asm_tya, z_asm_tya
>d2f4		74 79 61					.text "tya"
.d2f7						nt_asm_arrow:
>d2f7		03 04				                .byte 3, IM
>d2f9		02 d3				                .word nt_asm_back_jump
>d2fb		91 8a 9b 8a			                .word xt_asm_arrow, z_asm_arrow
>d2ff		2d 2d 3e			                .text "-->"
.d302						nt_asm_back_jump:
>d302		02 04				                .byte 2, IM
>d304		0c d3				                .word nt_asm_back_branch
>d306		ec a7 ec a7			                .word xt_asm_back_jump, z_asm_back_jump
>d30a		3c 6a				                .text "<j"
.d30c						nt_asm_back_branch:
>d30c		02 04				                .byte 2, IM
>d30e		16 d3				                .word nt_asm_push_a
>d310		ed a7 f5 a7			                .word xt_asm_back_branch, z_asm_back_branch
>d314		3c 62				                .text "<b"
.d316						nt_asm_push_a:
>d316		06 0c				                .byte 6, IM+NN
>d318		00 00				                .word 0000
>d31a		d5 a7 e4 a7			                .word xt_asm_push_a, z_asm_push_a
>d31e		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix
=1						ix += 1
=1						str_compile        = ix
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_sdc     = ix
=14						ix += 1
=14						str_disasm_bra     = ix
=15						ix += 1
=15						str_disasm_0test   = ix
=16						ix += 1
.d324						string_table:
>d324		44 d3 48 d3 52 d3 5d d3		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d32c		94 d3 8c d3 81 d3 9b d3		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d334		a1 d3 bd d3 c2 d3 c7 d3		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d33c		d8 d3 e1 d3 f3 d3 fb d3		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra, s_disasm_0test ; 12-15
>d344		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d348		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d350		64 00
>d352		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d35a		64 20 00
>d35d		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d365		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d375		4f 50 51 52 53 54 55 56 57 58 59 5a
>d381		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d389		72 20 00
>d38c		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d394		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d39b		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d3a1		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d3a9		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d3b9		29 3a 20 00
>d3bd		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d3c2		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d3c7		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d3cf		63 69 6d 61 6c 29 3a 20 00
>d3d8		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d3e0		00
>d3e1		53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d3e9		50 54 48 20 43 48 45 43 4b 00
>d3f3		42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
>d3fb		30 54 45 53 54 00		s_disasm_0test: .text "0TEST",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d401						error_table:
>d401		1d d4 3e d4 5e d4 7f d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d409		9c d4 ad d4 bd d4 eb d4		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d411		03 d5 24 d5 39 d5 55 d5		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d419		6c d5 ab d5			        .word es_blockwords, es_returnstack                     ; 12-13
>d41d		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d425		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d435		65 20 6d 65 6d 6f 72 79 00
>d43e		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d446		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d456		20 52 45 46 49 4c 4c 00
>d45e		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d466		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d476		6e 6c 79 20 77 6f 72 64 00
>d47f		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d487		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d497		20 79 65 74 00
>d49c		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d4a4		20 62 79 20 7a 65 72 6f 00
>d4ad		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d4b5		66 61 69 6c 75 72 65 00
>d4bd		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d4c5		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d4d5		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d4e5		64 20 2d 31 29 00
>d4eb		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d4f3		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d503		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d50b		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d51b		64 20 6e 75 6d 62 65 72 00
>d524		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d52c		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d539		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d541		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d551		4c 4f 54 00
>d555		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d55d		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d56c		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d574		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d584		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d594		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d5a4		56 45 43 54 4f 52 00
>d5ab		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d5b3		74 61 63 6b 3a 00
>d5b9		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d5c1		44 2d 53 54 52 49 4e 47
>d5c9		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d5cf		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d5d4		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d5dc		2d 55 4e 49 54 2d 42 49 54 53
>d5e6		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d5ee		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d5f6		52
>d5f7		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d5fd		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d603		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d60b		53 54 41 43 4b 2d 43 45 4c 4c 53
>d616		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d61e		45 4c 4c 53
>d622		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d62a		54 53
>d62c		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d632		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d639						cmpl_subroutine:
.d639		48		pha		                pha             ; save LSB of address
.d63a		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR
.d63c		80 03		bra $d641	                bra +
.d63e						cmpl_jump:
.d63e		48		pha		                pha             ; save LSB of address
.d63f		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP, fall thru
.d641						+
.d641		20 49 d6	jsr $d649	                jsr cmpl_a      ; compile opcode
.d644		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d645						cmpl_word:
.d645		20 49 d6	jsr $d649	                jsr cmpl_a      ; compile LSB of address
.d648		98		tya		                tya             ; fall thru for MSB
.d649						cmpl_a:
.d649		92 00		sta ($00)	                sta (cp)
.d64b		e6 00		inc $00		                inc cp
.d64d		d0 02		bne $d651	                bne _done
.d64f		e6 01		inc $01		                inc cp+1
.d651						_done:
.d651		60		rts		                rts
.d652						cmpl_jump_later:
.d652		a9 4c		lda #$4c	                lda #OpJMP
.d654		20 49 d6	jsr $d649	                jsr cmpl_a
.d657		20 91 8a	jsr $8a91	                jsr xt_here
.d65a		80 e9		bra $d645	                bra cmpl_word
.d65c						check_nc_limit:
.d65c		48		pha		                pha
.d65d		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.d65f		18		clc		                clc
.d660		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're done, leave with C=0
.d662		d0 06		bne $d66a	                bne _done
.d664		68		pla		                pla
.d665		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.d666		88		dey		                dey
.d667		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.d669		1a		inc a		                ina                     ; restore A
.d66a						_done:
.d66a		60		rts		                rts
.d66b						doconst:
.d66b		ca		dex		                dex             ; make room for constant
.d66c		ca		dex		                dex
.d66d		68		pla		                pla             ; LSB of return address
.d66e		85 25		sta $25		                sta tmp1
.d670		68		pla		                pla             ; MSB of return address
.d671		85 26		sta $26		                sta tmp1+1
.d673		a0 01		ldy #$01	                ldy #1
.d675		b1 25		lda ($25),y	                lda (tmp1),y
.d677		95 00		sta $00,x	                sta 0,x
.d679		c8		iny		                iny
.d67a		b1 25		lda ($25),y	                lda (tmp1),y
.d67c		95 01		sta $01,x	                sta 1,x
.d67e		60		rts		                rts
.d67f						dodefer:
.d67f		68		pla		                pla             ; LSB
.d680		85 25		sta $25		                sta tmp1
.d682		68		pla		                pla             ; MSB
.d683		85 26		sta $26		                sta tmp1+1
.d685		a0 01		ldy #$01	                ldy #1
.d687		b1 25		lda ($25),y	                lda (tmp1),y
.d689		85 27		sta $27		                sta tmp2
.d68b		c8		iny		                iny
.d68c		b1 25		lda ($25),y	                lda (tmp1),y
.d68e		85 28		sta $28		                sta tmp2+1
.d690		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d693						defer_error:
.d693		a9 03		lda #$03	                lda #err_defer
.d695		4c 19 d8	jmp $d819	                jmp error
.d698						dodoes:
.d698		7a		ply		                ply             ; LSB
.d699		68		pla		                pla             ; MSB
.d69a		c8		iny		                iny
.d69b		d0 01		bne $d69e	                bne +
.d69d		1a		inc a		                ina
.d69e						+
.d69e		84 27		sty $27		                sty tmp2
.d6a0		85 28		sta $28		                sta tmp2+1
.d6a2		ca		dex		                dex
.d6a3		ca		dex		                dex
.d6a4		7a		ply		                ply
.d6a5		68		pla		                pla
.d6a6		c8		iny		                iny
.d6a7		d0 01		bne $d6aa	                bne +
.d6a9		1a		inc a		                ina
.d6aa						+
.d6aa		94 00		sty $00,x	                sty 0,x         ; LSB
.d6ac		95 01		sta $01,x	                sta 1,x         ; MSB
.d6ae		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d6b1						dovar:
.d6b1		7a		ply		                ply             ; LSB
.d6b2		68		pla		                pla             ; MSB
.d6b3		c8		iny		                iny
.d6b4		d0 01		bne $d6b7	                bne +
.d6b6		1a		inc a		                ina
.d6b7						+
.d6b7		ca		dex		                dex
.d6b8		ca		dex		                dex
.d6b9		95 01		sta $01,x	                sta 1,x
.d6bb		98		tya		                tya
.d6bc		95 00		sta $00,x	                sta 0,x
.d6be		60		rts		                rts
.d6bf						push_upvar_tos:
.d6bf		ca		dex		                dex
.d6c0		ca		dex		                dex
.d6c1		18		clc		                clc
.d6c2		65 08		adc $08		                adc up
.d6c4		95 00		sta $00,x	                sta 0,x
.d6c6		a5 09		lda $09		                lda up+1
.d6c8		90 01		bcc $d6cb	                bcc +
.d6ca		1a		inc a		                ina
.d6cb						+
.d6cb		95 01		sta $01,x	                sta 1,x
.d6cd		60		rts		                rts
.d6ce						byte_to_ascii:
.d6ce		48		pha		                pha
.d6cf		4a		lsr a		                lsr             ; convert high nibble first
.d6d0		4a		lsr a		                lsr
.d6d1		4a		lsr a		                lsr
.d6d2		4a		lsr a		                lsr
.d6d3		20 d7 d6	jsr $d6d7	                jsr _nibble_to_ascii
.d6d6		68		pla		                pla
.d6d7						_nibble_to_ascii:
.d6d7		29 0f		and #$0f	                and #$F
.d6d9		09 30		ora #$30	                ora #'0'
.d6db		c9 3a		cmp #$3a	                cmp #'9'+1
.d6dd		90 02		bcc $d6e1	                bcc +
.d6df		69 06		adc #$06	                adc #6
.d6e1		4c 3b 88	jmp $883b	+               jmp emit_a
.d6e4		60		rts		                rts
.d6e5						find_header_name:
.d6e5		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d6e7		85 27		sta $27		                sta tmp2
.d6e9		b5 03		lda $03,x	                lda 3,x
.d6eb		85 28		sta $28		                sta tmp2+1
.d6ed						_loop:
.d6ed		b2 25		lda ($25)	                lda (tmp1)
.d6ef		d5 00		cmp $00,x	                cmp 0,x
.d6f1		d0 3a		bne $d72d	                bne _next_entry
.d6f3		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d6f5		a0 08		ldy #$08	                ldy #8
.d6f7		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d6f9		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d6fb		d0 30		bne $d72d	                bne _next_entry ; definitely not equal if any bits differ
.d6fd		a5 25		lda $25		                lda tmp1
.d6ff		48		pha		                pha             ; Save original address on the stack
.d700		18		clc		                clc
.d701		69 08		adc #$08	                adc #8
.d703		85 25		sta $25		                sta tmp1
.d705		a5 26		lda $26		                lda tmp1+1
.d707		48		pha		                pha
.d708		90 03		bcc $d70d	                bcc +
.d70a		1a		inc a		                ina
.d70b		85 26		sta $26		                sta tmp1+1
.d70d						+
.d70d		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d70f		88		dey		                dey
.d710						_next_char:
.d710		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d712		c9 5b		cmp #$5b	                cmp #'Z'+1
.d714		b0 06		bcs $d71c	                bcs _check_char
.d716		c9 41		cmp #$41	                cmp #'A'
.d718		90 02		bcc $d71c	                bcc _check_char
.d71a		09 20		ora #$20	                ora #$20
.d71c						_check_char:
.d71c		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d71e		d0 03		bne $d723	                bne _reset_tmp1
.d720		88		dey		                dey
.d721		10 ed		bpl $d710	                bpl _next_char
.d723						_reset_tmp1:
.d723		68		pla		                pla
.d724		85 26		sta $26		                sta tmp1+1
.d726		68		pla		                pla
.d727		85 25		sta $25		                sta tmp1
.d729		98		tya		                tya             ; leave A = $FF on success
.d72a		c8		iny		                iny             ; if Y was $FF, we succeeded
.d72b		f0 11		beq $d73e	                beq _done
.d72d						_next_entry:
.d72d		a0 02		ldy #$02	                ldy #2
.d72f		b1 25		lda ($25),y	                lda (tmp1),y
.d731		48		pha		                pha
.d732		c8		iny		                iny
.d733		b1 25		lda ($25),y	                lda (tmp1),y
.d735		85 26		sta $26		                sta tmp1+1
.d737		68		pla		                pla
.d738		85 25		sta $25		                sta tmp1
.d73a		05 26		ora $26		                ora tmp1+1
.d73c		d0 af		bne $d6ed	                bne _loop
.d73e		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d740		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d741						compare_16bit:
.d741		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d743		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d745		f0 08		beq $d74f	                beq _equal
.d747		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d749		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d74b		70 08		bvs $d755	                bvs _overflow
.d74d		80 08		bra $d757	                bra _not_equal
.d74f						_equal:
.d74f		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d751		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d753		50 04		bvc $d759	                bvc _done
.d755						_overflow:
.d755		49 80		eor #$80	                eor #$80                ; complement negative flag
.d757						_not_equal:
.d757		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d759						_done:
.d759		60		rts		                rts
.d75a						current_to_dp:
.d75a		a0 08		ldy #$08	                ldy #current_offset
.d75c		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d75e		0a		asl a		                asl             ; turn it into an offset (in cells)
.d75f		18		clc		                clc
.d760		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d762		a8		tay		                tay
.d763		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d765		85 02		sta $02		                sta dp
.d767		c8		iny		                iny
.d768		b1 08		lda ($08),y	                lda (up),y
.d76a		85 03		sta $03		                sta dp+1
.d76c		60		rts		                rts
.d76d						dp_to_current:
.d76d		a0 08		ldy #$08	                ldy #current_offset
.d76f		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d771		0a		asl a		                asl             ; turn it into an offset (in cells)
.d772		18		clc		                clc
.d773		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d775		a8		tay		                tay
.d776		a5 02		lda $02		                lda dp
.d778		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d77a		c8		iny		                iny
.d77b		a5 03		lda $03		                lda dp+1
.d77d		91 08		sta ($08),y	                sta (up),y
.d77f		60		rts		                rts
.d780						interpret:
.d780						_loop:
.d780		20 e4 8e	jsr $8ee4	                jsr xt_parse_name       ; ( "string" -- addr u )
.d783		b5 00		lda $00,x	                lda 0,x
.d785		15 01		ora $01,x	                ora 1,x
.d787		f0 5b		beq $d7e4	                beq _line_done
.d789		20 75 95	jsr $9575	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d78c		20 36 9b	jsr $9b36	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d78f		b5 00		lda $00,x	                lda 0,x
.d791		15 01		ora $01,x	                ora 1,x
.d793		d0 19		bne $d7ae	                bne _got_name_token
.d795		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d796		e8		inx		                inx
.d797		20 d7 9c	jsr $9cd7	                jsr xt_number           ; ( addr u -- u|d )
.d79a		a5 1a		lda $1a		                lda state
.d79c		f0 e2		beq $d780	                beq _loop
.d79e		a9 20		lda #$20	                lda #%00100000
.d7a0		24 1c		bit $1c		                bit status
.d7a2		d0 05		bne $d7a9	                bne _double_number
.d7a4		20 aa 8b	jsr $8baa	                jsr xt_literal
.d7a7		80 d7		bra $d780	                bra _loop
.d7a9						_double_number:
.d7a9		20 2f 9f	jsr $9f2f	                jsr xt_two_literal
.d7ac		80 d2		bra $d780	                bra _loop
.d7ae						_got_name_token:
.d7ae		b5 00		lda $00,x	                lda 0,x
.d7b0		95 04		sta $04,x	                sta 4,x
.d7b2		b5 01		lda $01,x	                lda 1,x
.d7b4		95 05		sta $05,x	                sta 5,x
.d7b6		e8		inx		                inx
.d7b7		e8		inx		                inx
.d7b8		e8		inx		                inx
.d7b9		e8		inx		                inx                     ; ( nt )
.d7ba		20 7c 8e	jsr $8e7c	                jsr xt_one_plus
.d7bd		a1 00		lda ($00,x)	                lda (0,x)
.d7bf		48		pha		                pha
.d7c0		20 70 8e	jsr $8e70	                jsr xt_one_minus
.d7c3		20 74 9c	jsr $9c74	                jsr xt_name_to_int      ; ( nt - xt )
.d7c6		a5 1a		lda $1a		                lda state
.d7c8		d0 10		bne $d7da	                bne _compile
.d7ca		68		pla		                pla
.d7cb		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d7cd		f0 05		beq $d7d4	                beq _interpret
.d7cf		a9 02		lda #$02	                lda #err_compileonly
.d7d1		4c 19 d8	jmp $d819	                jmp error
.d7d4						_interpret:
.d7d4		20 7b 89	jsr $897b	                jsr xt_execute
.d7d7		4c 80 d7	jmp $d780	                jmp _loop
.d7da						_compile:
.d7da		68		pla		                pla
.d7db		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d7dd		d0 f5		bne $d7d4	                bne _interpret          ; IMMEDIATE word, execute right now
.d7df		20 f4 83	jsr $83f4	                jsr xt_compile_comma
.d7e2		80 9c		bra $d780	                bra _loop
.d7e4						_line_done:
.d7e4		e8		inx		                inx
.d7e5		e8		inx		                inx
.d7e6		e8		inx		                inx
.d7e7		e8		inx		                inx
.d7e8		60		rts		                rts
.d7e9						is_printable:
.d7e9		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d7eb		90 08		bcc $d7f5	                bcc _done
.d7ed		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d7ef		b0 03		bcs $d7f4	                bcs _failed
.d7f1		38		sec		                sec
.d7f2		80 01		bra $d7f5	                bra _done
.d7f4						_failed:
.d7f4		18		clc		                clc
.d7f5						_done:
.d7f5		60		rts		                rts
.d7f6						is_whitespace:
.d7f6		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d7f8		90 08		bcc $d802	                bcc _done
.d7fa		c9 21		cmp #$21	                cmp #AscSP+1
.d7fc		b0 03		bcs $d801	                bcs _failed
.d7fe		38		sec		                sec
.d7ff		80 01		bra $d802	                bra _done
.d801						_failed:
.d801		18		clc		                clc
.d802						_done:
.d802		60		rts		                rts
.d803						underflow_1:
.d803		e0 77		cpx #$77	                cpx #dsp0-1
.d805		10 10		bpl $d817	                bpl underflow_error
.d807		60		rts		                rts
.d808						underflow_2:
.d808		e0 75		cpx #$75	                cpx #dsp0-3
.d80a		10 0b		bpl $d817	                bpl underflow_error
.d80c		60		rts		                rts
.d80d						underflow_3:
.d80d		e0 73		cpx #$73	                cpx #dsp0-5
.d80f		10 06		bpl $d817	                bpl underflow_error
.d811		60		rts		                rts
.d812						underflow_4:
.d812		e0 71		cpx #$71	                cpx #dsp0-7
.d814		10 01		bpl $d817	                bpl underflow_error
.d816		60		rts		                rts
.d817						underflow_error:
.d817		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d819						error:
.d819		48		pha		                pha                     ; save error
.d81a		20 59 d8	jsr $d859	                jsr print_error
.d81d		20 69 85	jsr $8569	                jsr xt_cr
.d820		68		pla		                pla
.d821		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d823		d0 17		bne $d83c	                bne _no_underflow
.d825		a9 0d		lda #$0d	                lda #err_returnstack
.d827		20 59 d8	jsr $d859	                jsr print_error
.d82a		ba		tsx		                tsx
.d82b						-
.d82b		e8		inx		                inx
.d82c		f0 0b		beq $d839	                beq +
.d82e		20 73 93	jsr $9373	                jsr xt_space
.d831		bd 00 01	lda $0100,x	                lda $100,x
.d834		20 ce d6	jsr $d6ce	                jsr byte_to_ascii
.d837		80 f2		bra $d82b	                bra -
.d839						+
.d839		20 69 85	jsr $8569	                jsr xt_cr
.d83c						_no_underflow:
.d83c		4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d83f						print_string_no_lf:
.d83f		0a		asl a		                asl
.d840		a8		tay		                tay
.d841		b9 24 d3	lda $d324,y	                lda string_table,y
.d844		85 29		sta $29		                sta tmp3                ; LSB
.d846		c8		iny		                iny
.d847		b9 24 d3	lda $d324,y	                lda string_table,y
.d84a		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d84c						print_common:
.d84c		a0 00		ldy #$00	                ldy #0
.d84e						_loop:
.d84e		b1 29		lda ($29),y	                lda (tmp3),y
.d850		f0 06		beq $d858	                beq _done               ; strings are zero-terminated
.d852		20 3b 88	jsr $883b	                jsr emit_a              ; allows vectoring via output
.d855		c8		iny		                iny
.d856		80 f6		bra $d84e	                bra _loop
.d858						_done:
.d858		60		rts		                rts
.d859						print_error:
.d859		0a		asl a		                asl
.d85a		a8		tay		                tay
.d85b		b9 01 d4	lda $d401,y	                lda error_table,y
.d85e		85 29		sta $29		                sta tmp3                ; LSB
.d860		c8		iny		                iny
.d861		b9 01 d4	lda $d401,y	                lda error_table,y
.d864		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d866		20 4c d8	jsr $d84c	                jsr print_common
.d869		60		rts		                rts
.d86a						print_string:
.d86a		20 3f d8	jsr $d83f	                jsr print_string_no_lf
.d86d		4c 69 85	jmp $8569	                jmp xt_cr               ; JSR/RTS because never compiled
.d870						print_u:
.d870		20 37 9e	jsr $9e37	                jsr xt_zero                     ; 0
.d873		20 87 8b	jsr $8b87	                jsr xt_less_number_sign         ; <#
.d876		20 46 8e	jsr $8e46	                jsr xt_number_sign_s            ; #S
.d879		20 24 8e	jsr $8e24	                jsr xt_number_sign_greater      ; #>
.d87c		4c 7f 96	jmp $967f	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm


;******  Processing file: platform/simulator.asm

=$f000						io_start = $f000
>f000						                .byte ?
>f001						io_putc:        .byte ?     ; $f001     write byte to stdout
>f002						                .word ?
>f004						io_getc:        .byte ?     ; $f004     read byte from stdin
>f005						io_peekc:       .byte ?     ; $f005     non-blocking input
>f006						io_clk_start:   .byte ?     ; $f006     *read* to start cycle counter
>f007						io_clk_stop:    .byte ?     ; $f007     *read* to stop the cycle counter
>f008						io_clk_cycles:  .word ?,?   ; $f008-b   32-bit cycle count in NUXI order
>f00c						                .word ?,?
>f010						io_blk_action:  .byte ?     ; $f010     Write to act (status=0 read=1 write=2)
>f011						io_blk_status:  .byte ?     ; $f011     Read action result (OK=0)
>f012						io_blk_number:  .word ?     ; $f012     Little endian block number 0-ffff
>f014						io_blk_buffer:  .word ?     ; $f014     Little endian memory address
.f016						io_end:
.f016						kernel_init:
.f016		78		sei		                sei             ; Disable interrupts
.f017		a2 00		ldx #$00	                ldx #0
.f019		bd 32 f0	lda $f032,x	-               lda s_kernel_id,x
.f01c		f0 06		beq $f024	                beq _done
.f01e		20 2d f0	jsr $f02d	                jsr kernel_putc
.f021		e8		inx		                inx
.f022		80 f5		bra $f019	                bra -
.f024						_done:
.f024		4c 00 80	jmp $8000	                jmp forth
.f027						kernel_getc:
.f027						_loop:
.f027		ad 04 f0	lda $f004	                lda io_getc
.f02a		f0 fb		beq $f027	                beq _loop
.f02c		60		rts		                rts
.f02d						kernel_putc:
.f02d		8d 01 f0	sta $f001	                sta io_putc
.f030		60		rts		                rts
.f031						kernel_bye:
.f031		00		brk #		                brk

;******  Return to file: platform/platform-py65mon.asm

.f032						s_kernel_id:
>f032		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f03a		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f04a		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f05a		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		16 f0				v_nmi   .word kernel_init
>fffc		16 f0				v_reset .word kernel_init
>fffe		16 f0				v_irq   .word kernel_init

;******  End of listing
