
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Sat Mar  9 19:54:03 2024

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000					ram_start = $0000          ; start of installed 32 KiB of RAM
=32767					ram_end   = $8000-1        ; end of installed RAM
=$0000					zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f					zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100					stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744					hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000					user0     = zpage            ; user and system variables
=$ff					rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff					bsize     = $ff              ; size of input/output buffers
=512					buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768					cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744					cp_end    = hist_buff        ; Last RAM byte available for code
=$ff					padoffset = $ff              ; offset from CP to PAD (holds number strings)
=					TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=["lf"]					TALI_OPTION_CR_EOL := [ "lf" ]

;******  Processing file: platform/../taliforth.asm

.8000					code0:

;******  Processing file: platform/../definitions.asm

=0					cp        = user0+0   ; Compiler Pointer
=2					dp        = user0+2   ; Dictionary Pointer
=4					workword  = user0+4   ; nt (not xt!) of word being compiled, except in
=6					insrc     = user0+6   ; input Source for SOURCE-ID
=8					cib       = user0+8   ; address of current input buffer
=10					ciblen    = user0+10  ; length of current input buffer
=12					toin      = user0+12  ; pointer to CIB (>IN in Forth)
=14					ip        = user0+14  ; Instruction Pointer (current xt)
=16					output    = user0+16  ; vector for EMIT
=18					input     = user0+18  ; vector for KEY
=20					havekey   = user0+20  ; vector for KEY?
=22					state     = user0+22  ; STATE: -1 compile, 0 interpret
=24					base      = user0+24  ; number radix, default decimal
=26					nc_limit  = user0+26  ; limit for Native Compile size
=28					uf_strip  = user0+28  ; flag to strip underflow detection code
=30					up        = user0+30  ; User Pointer (Address of user variables)
=32					status    = user0+32  ; internal status information
=34					tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
=36					tmp1      = user0+36  ; temporary storage
=38					tmp2      = user0+38  ; temporary storage
=40					tmp3      = user0+40  ; temporary storage (especially for print)
=42					tmpdsp    = user0+42  ; temporary DSP (X) storage (two bytes)
=44					tmptos    = user0+44  ; temporary TOS storage
=46					editor1   = user0+46  ; temporary for editors
=48					editor2   = user0+48  ; temporary for editors
=50					editor3   = user0+50  ; temporary for editors
=52					tohold    = user0+52  ; pointer for formatted output
=54					scratch   = user0+54  ; 8 byte scratchpad (see UM/MOD)
=120					dsp0      = zpage_end-7    ; initial Data Stack Pointer
=0					blk_offset = 0        ; BLK : UP + 0
=2					scr_offset = 2        ; SCR : UP + 2
=4					current_offset = 4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
=5					num_wordlists_offset = 5
=6					wordlists_offset = 6  ; WORDLISTS (cells) : UP + 6 to UP + 29
=30					num_order_offset = 30 ; #ORDER (byte) : UP + 30
=31					search_order_offset = 31
=12					max_wordlists = 12    ; Maximum number of wordlists supported
=40					blkbuffer_offset    = 40   ; Address of buffer
=42					buffblocknum_offset = 42   ; Block number current in buffer
=44					buffstatus_offset   = 44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
=46					blockread_offset    = 46   ; Vector to block reading routine
=48					blockwrite_offset   = 48   ; Vector to block writing routine
=$03					AscCC   = $03  ; break (CTRL-c)
=$07					AscBELL = $07  ; bell sound
=$08					AscBS   = $08  ; backspace
=$0a					AscLF   = $0a  ; line feed
=$0d					AscCR   = $0d  ; carriage return
=$1b					AscESC  = $1b  ; escape
=$20					AscSP   = $20  ; space
=$7f					AscDEL  = $7f  ; delete (CTRL-h)
=$10					AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e					AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1					CO = 1  ; Compile Only
=2					AN = 2  ; Always Native Compile
=4					IM = 4  ; Immediate Word
=8					NN = 8  ; Never Native Compile
=16					UF = 16 ; Includes Underflow Check (RESERVED)
=32					HC = 32 ; Word has Code Field Area (CFA)
=79					MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm

.8000					forth:

;******  Processing file: platform/../native_words.asm

.8000					xt_cold:
.8000	d8		cld		                cld
.8001	a9 27		lda #$27	                lda #<kernel_putc
.8003	85 10		sta $10		                sta output
.8005	a9 f0		lda #$f0	                lda #>kernel_putc
.8007	85 11		sta $11		                sta output+1
.8009	a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b					_load_zp_loop:
.800b	bd c5 80	lda $80c5,x	                lda cold_zp_table,x
.800e	95 00		sta $00,x	                sta zpage,x
.8010	ca		dex		                dex
.8011	d0 f8		bne $800b	                bne _load_zp_loop
.8013	ad c5 80	lda $80c5	                lda cold_zp_table
.8016	85 00		sta $00		                sta zpage
.8018	a2 ff		ldx #$ff	                ldx #rsp0
.801a	9a		txs		                txs
.801b	a2 78		ldx #$78	                ldx #dsp0
.801d	a0 31		ldy #$31	                ldy #cold_user_table_end-cold_user_table-1
.801f	a9 00		lda #$00	                lda #0
.8021					_load_user_vars_loop:
.8021	b9 e7 80	lda $80e7,y	                lda cold_user_table,y
.8024	91 1e		sta ($1e),y	                sta (up),y
.8026	88		dey		                dey
.8027	d0 f8		bne $8021	                bne _load_user_vars_loop
.8029	ad e7 80	lda $80e7	                lda cold_user_table
.802c	92 1e		sta ($1e)	                sta (up)
.802e	20 63 89	jsr $8963	                jsr xt_cr
.8031	ca		dex		                dex
.8032	ca		dex		                dex
.8033	ca		dex		                dex
.8034	ca		dex		                dex
.8035	a9 71		lda #$71	                lda #<forth_words_start
.8037	95 02		sta $02,x	                sta 2,x
.8039	a9 bb		lda #$bb	                lda #>forth_words_start
.803b	95 03		sta $03,x	                sta 3,x
.803d	a9 42		lda #$42	                lda #<forth_words_end
.803f	38		sec		                sec
.8040	e9 71		sbc #$71	                sbc #<forth_words_start
.8042	95 00		sta $00,x	                sta 0,x
.8044	a9 bc		lda #$bc	                lda #>forth_words_end
.8046	e9 bb		sbc #$bb	                sbc #>forth_words_start
.8048	95 01		sta $01,x	                sta 1,x
.804a	20 d5 90	jsr $90d5	                jsr xt_evaluate
.804d	ca		dex		                dex
.804e	ca		dex		                dex
.804f	ca		dex		                dex
.8050	ca		dex		                dex
.8051	a9 42		lda #$42	                lda #<user_words_start
.8053	95 02		sta $02,x	                sta 2,x
.8055	a9 bc		lda #$bc	                lda #>user_words_start
.8057	95 03		sta $03,x	                sta 3,x
.8059	a9 44		lda #$44	                lda #<user_words_end
.805b	38		sec		                sec
.805c	e9 42		sbc #$42	                sbc #<user_words_start
.805e	95 00		sta $00,x	                sta 0,x
.8060	a9 bc		lda #$bc	                lda #>user_words_end
.8062	e9 bc		sbc #$bc	                sbc #>user_words_start
.8064	95 01		sta $01,x	                sta 1,x
.8066	20 d5 90	jsr $90d5	                jsr xt_evaluate
.8069	9c 00 7c	stz $7c00	                stz hist_buff
.806c	9c 80 7c	stz $7c80	                stz hist_buff+$80
.806f	9c 00 7d	stz $7d00	                stz hist_buff+$100
.8072	9c 80 7d	stz $7d80	                stz hist_buff+$180
.8075	9c 00 7e	stz $7e00	                stz hist_buff+$200
.8078	9c 80 7e	stz $7e80	                stz hist_buff+$280
.807b	9c 00 7f	stz $7f00	                stz hist_buff+$300
.807e	9c 80 7f	stz $7f80	                stz hist_buff+$380
.8081					xt_abort:
.8081	a2 78		ldx #$78	                ldx #dsp0
.8083					xt_quit:
.8083	8a		txa		                txa             ; Save the DSP that we just defined
.8084	a2 ff		ldx #$ff	                ldx #rsp0
.8086	9a		txs		                txs
.8087	aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8088	64 0e		stz $0e		                stz ip
.808a	64 0f		stz $0f		                stz ip+1
.808c	64 06		stz $06		                stz insrc
.808e	64 07		stz $07		                stz insrc+1
.8090	64 16		stz $16		                stz state
.8092	64 17		stz $17		                stz state+1
.8094					_get_line:
.8094	a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8096	85 08		sta $08		                sta cib
.8098	a9 02		lda #$02	                lda #>buffer0
.809a	85 09		sta $09		                sta cib+1
.809c	64 0a		stz $0a		                stz ciblen
.809e	64 0b		stz $0b		                stz ciblen+1
.80a0	20 f8 9a	jsr $9af8	                jsr xt_refill           ; ( -- f )
.80a3	b5 00		lda $00,x	                lda 0,x
.80a5	d0 05		bne $80ac	                bne _success
.80a7	a9 06		lda #$06	                lda #err_refill
.80a9	4c 5a d8	jmp $d85a	                jmp error
.80ac					_success:
.80ac	e8		inx		                inx                     ; drop
.80ad	e8		inx		                inx
.80ae	20 ac d7	jsr $d7ac	                jsr interpret
.80b1	e0 78		cpx #$78	                cpx #dsp0
.80b3	f0 05		beq $80ba	                beq _stack_ok
.80b5	90 03		bcc $80ba	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80b7	4c 58 d8	jmp $d858	                jmp underflow_error
.80ba					_stack_ok:
.80ba	a5 16		lda $16		                lda state
.80bc	f0 02		beq $80c0	                beq _print
.80be	a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80c0					_print:
.80c0	20 ab d8	jsr $d8ab	                jsr print_string
.80c3	80 cf		bra $8094	                bra _get_line
.80c5					z_cold:
.80c5					z_abort:
.80c5					z_quit:
.80c5					cold_zp_table:
>80c5	00 08				        .word cp0+256+1024      ; cp moved to make room for user vars and
>80c7	44 bc				        .word dictionary_start  ; dp
>80c9	00 00				        .word 0                 ; workword
>80cb	00 00				        .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
>80cd	00 02				        .word buffer0           ; cib
>80cf	00 00				        .word 0                 ; ciblen
>80d1	00 00				        .word 0                 ; toin
>80d3	00 00				        .word 0                 ; ip
>80d5	27 f0				        .word kernel_putc       ; output
>80d7	21 f0				        .word kernel_getc       ; input
>80d9	00 00				        .word 0                 ; havekey
>80db	00 00				        .word 0                 ; state (0 = interpret)
>80dd	0a 00				        .word 10                ; base
>80df	14 00				        .word 20                ; nc-limit
>80e1	00 00				        .word 0                 ; uf_strip (off by default)
>80e3	00 03				        .word cp0               ; up (user vars put right at beginning of
>80e5	00 00				        .word 0                 ; status
.80e7					cold_zp_table_end:
.80e7					cold_user_table:
>80e7	00 00				        .word 0                         ; BLK
>80e9	00 00				        .word 0                         ; SCR
>80eb	00				        .byte 0                         ; CURRENT = FORTH-WORDLIST
>80ec	04				        .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>80ed	44 bc				        .word dictionary_start          ; FORTH-WORDLIST
>80ef	8c ca				        .word editor_dictionary_start   ; EDITOR-WORDLIST
>80f1	dc ca				        .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
>80f3	4b ca				        .word root_dictionary_start     ; ROOT-WORDLIST
>80f5	00 00 00 00 00 00 00 00		        .word 0,0,0,0,0,0,0,0           ; User wordlists
>80fd	00 00 00 00 00 00 00 00
>8105	01				        .byte 1                         ; #ORDER
>8106	00 00 00 00 00 00 00 00		        .byte 0,0,0,0,0,0,0,0,0         ; search-order
>810e	00
>810f	00 04				        .word cp0+256                   ; Address of buffer (right after USER vars)
>8111	00 00				        .word 0                         ; block in buffer
>8113	00 00				        .word 0                         ; buffer status (not in use)
>8115	5b 85				        .word xt_block_word_error       ; block-read vector
>8117	5b 85				        .word xt_block_word_error       ; block-write vector
.8119					cold_user_table_end:
.8119					xt_abort_quote:
.8119	20 4f 9d	jsr $9d4f	                jsr xt_s_quote          ; S"
.811c	a0 81		ldy #$81	                ldy #>abort_quote_runtime
.811e	a9 24		lda #$24	                lda #<abort_quote_runtime
.8120	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.8123	60		rts		z_abort_quote:  rts
.8124					abort_quote_runtime:
.8124	b5 04		lda $04,x	                lda 4,x
.8126	15 05		ora $05,x	                ora 5,x
.8128	f0 09		beq $8133	                beq _done       ; if FALSE, we're done
.812a	20 03 a5	jsr $a503	                jsr xt_type
.812d	20 63 89	jsr $8963	                jsr xt_cr
.8130	4c 81 80	jmp $8081	                jmp xt_abort    ; not JSR, so never come back
.8133					_done:
.8133	8a		txa		                txa
.8134	18		clc		                clc
.8135	69 06		adc #$06	                adc #6
.8137	aa		tax		                tax
.8138	60		rts		                rts
.8139					xt_abs:
.8139	20 44 d8	jsr $d844	                jsr underflow_1
.813c	b5 01		lda $01,x	                lda 1,x
.813e	10 0d		bpl $814d	                bpl _done       ; positive number, easy money!
.8140	38		sec		                sec
.8141	a9 00		lda #$00	                lda #0
.8143	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8145	95 00		sta $00,x	                sta 0,x
.8147	a9 00		lda #$00	                lda #0          ; MSB
.8149	f5 01		sbc $01,x	                sbc 1,x
.814b	95 01		sta $01,x	                sta 1,x
.814d					_done:
.814d	60		rts		z_abs:          rts
.814e					xt_accept:
.814e	20 49 d8	jsr $d849	                jsr underflow_2
.8151	b5 00		lda $00,x	                lda 0,x
.8153	15 01		ora $01,x	                ora 1,x
.8155	d0 09		bne $8160	                bne _not_zero
.8157	e8		inx		                inx
.8158	e8		inx		                inx
.8159	74 00		stz $00,x	                stz 0,x
.815b	74 01		stz $01,x	                stz 1,x
.815d	4c 2c 82	jmp $822c	                jmp accept_done
.8160					_not_zero:
.8160	b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.8162	85 26		sta $26		                sta tmp2
.8164	64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.8166	b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.8168	85 24		sta $24		                sta tmp1
.816a	b5 03		lda $03,x	                lda 3,x
.816c	85 25		sta $25		                sta tmp1+1
.816e	e8		inx		                inx
.816f	e8		inx		                inx
.8170	a0 00		ldy #$00	                ldy #0
.8172	a5 20		lda $20		                lda status
.8174	29 f7		and #$f7	                and #$f7
.8176	1a		inc a		               ina
.8177	09 08		ora #$08	                ora #$08
.8179	85 20		sta $20		                sta status
.817b					accept_loop:
.817b	20 38 93	jsr $9338	                jsr key_a
.817e	c9 0a		cmp #$0a	                cmp #AscLF
.8180	f0 20		beq $81a2	                beq _eol
.8182	c9 0d		cmp #$0d	                cmp #AscCR
.8184	f0 1c		beq $81a2	                beq _eol
.8186	c9 08		cmp #$08	                cmp #AscBS
.8188	f0 22		beq $81ac	                beq _backspace
.818a	c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.818c	f0 1e		beq $81ac	                beq _backspace
.818e	c9 10		cmp #$10	                cmp #AscCP
.8190	f0 36		beq $81c8	                beq _ctrl_p
.8192	c9 0e		cmp #$0e	                cmp #AscCN
.8194	f0 44		beq $81da	                beq _ctrl_n
.8196	91 24		sta ($24),y	                sta (tmp1),y
.8198	c8		iny		                iny
.8199	20 f6 8d	jsr $8df6	                jsr emit_a
.819c	c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.819e	d0 db		bne $817b	                bne accept_loop       ; fall through if buffer limit reached
.81a0	80 03		bra $81a5	                bra _buffer_full
.81a2					_eol:
.81a2	20 1e a1	jsr $a11e	                jsr xt_space    ; print final space
.81a5					_buffer_full:
.81a5	94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.81a7	74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.81a9	4c 2c 82	jmp $822c	                jmp accept_done
.81ac					_backspace:
.81ac	c0 00		cpy #$00	                cpy #0          ; buffer empty?
.81ae	d0 06		bne $81b6	                bne +
.81b0	a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.81b2	20 f6 8d	jsr $8df6	                jsr emit_a
.81b5	c8		iny		                iny
.81b6					+
.81b6	88		dey		                dey
.81b7	a9 08		lda #$08	                lda #AscBS      ; move back one
.81b9	20 f6 8d	jsr $8df6	                jsr emit_a
.81bc	a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.81be	20 f6 8d	jsr $8df6	                jsr emit_a
.81c1	a9 08		lda #$08	                lda #AscBS      ; move back over space
.81c3	20 f6 8d	jsr $8df6	                jsr emit_a
.81c6	80 b3		bra $817b	                bra accept_loop
.81c8					_ctrl_p:
.81c8	a5 20		lda $20		                lda status
.81ca	29 07		and #$07	                and #7
.81cc	d0 08		bne $81d6	                bne _ctrl_p_dec
.81ce	a5 20		lda $20		                lda status
.81d0	09 07		ora #$07	                ora #7
.81d2	85 20		sta $20		                sta status
.81d4	80 11		bra $81e7	                bra _recall_history
.81d6					_ctrl_p_dec:
.81d6	c6 20		dec $20		                dec status
.81d8	80 0d		bra $81e7	                bra _recall_history
.81da					_ctrl_n:
.81da	a9 08		lda #$08	                lda #$8
.81dc	24 20		bit $20		                bit status
.81de	d0 07		bne $81e7	                bne _recall_history
.81e0	a5 20		lda $20		                lda status
.81e2	29 f7		and #$f7	                and #$f7
.81e4	1a		inc a		               ina
.81e5	85 20		sta $20		                sta status
.81e7					_recall_history:
.81e7	a9 08		lda #$08	                lda #%00001000
.81e9	14 20		trb $20		                trb status
.81eb	20 47 82	jsr $8247	                jsr accept_total_recall
.81ee	a9 0d		lda #$0d	                lda #AscCR
.81f0	20 f6 8d	jsr $8df6	                jsr emit_a
.81f3					input_clear:
.81f3	c0 00		cpy #$00	                cpy #0
.81f5	f0 08		beq $81ff	                beq input_cleared
.81f7	a9 20		lda #$20	                lda #AscSP
.81f9	20 f6 8d	jsr $8df6	                jsr emit_a
.81fc	88		dey		                dey
.81fd	80 f4		bra $81f3	                bra input_clear
.81ff					input_cleared:
.81ff	a9 0d		lda #$0d	                lda #AscCR
.8201	20 f6 8d	jsr $8df6	                jsr emit_a
.8204	b1 28		lda ($28),y	                lda (tmp3),y
.8206	85 21		sta $21		                sta status+1
.8208	e6 28		inc $28		                inc tmp3
.820a	d0 02		bne $820e	                bne +           ; Increment the upper byte on carry.
.820c	e6 29		inc $29		                inc tmp3+1
.820e					+
.820e	a9 0d		lda #$0d	                lda #AscCR
.8210	20 f6 8d	jsr $8df6	                jsr emit_a
.8213					_history_loop:
.8213	c4 21		cpy $21		                cpy status+1
.8215	d0 03		bne $821a	                bne +
.8217	4c 7b 81	jmp $817b	                jmp accept_loop       ; Needs a long jump
.821a					+
.821a	c4 26		cpy $26		                cpy tmp2
.821c	f0 0a		beq $8228	                beq _hist_filled_buffer
.821e	b1 28		lda ($28),y	                lda (tmp3),y
.8220	91 24		sta ($24),y	                sta (tmp1),y
.8222	20 f6 8d	jsr $8df6	                jsr emit_a
.8225	c8		iny		                iny
.8226	80 eb		bra $8213	                bra _history_loop
.8228					_hist_filled_buffer:
.8228	88		dey		                dey
.8229	4c 7b 81	jmp $817b	                jmp accept_loop
.822c					accept_done:
.822c	20 47 82	jsr $8247	                jsr accept_total_recall
.822f	85 21		sta $21		                sta status+1
.8231	a0 00		ldy #$00	                ldy #0
.8233	91 28		sta ($28),y	                sta (tmp3),y
.8235	e6 28		inc $28		                inc tmp3
.8237	d0 02		bne $823b	                bne +           ; Increment the upper byte on carry.
.8239	e6 29		inc $29		                inc tmp3+1
.823b					+
.823b					_save_history_loop:
.823b	c4 21		cpy $21		                cpy status+1
.823d	f0 07		beq $8246	                beq _save_history_done
.823f	b1 24		lda ($24),y	                lda (tmp1),y
.8241	91 28		sta ($28),y	                sta (tmp3),y
.8243	c8		iny		                iny
.8244	80 f5		bra $823b	                bra _save_history_loop
.8246					_save_history_done:
.8246					z_accept:
.8246	60		rts		                rts
.8247					accept_total_recall:
.8247	a9 00		lda #$00	                lda #<hist_buff
.8249	85 28		sta $28		                sta tmp3
.824b	a9 7c		lda #$7c	                lda #>hist_buff
.824d	85 29		sta $29		                sta tmp3+1
.824f	a5 20		lda $20		                lda status
.8251	6a		ror a		                ror
.8252	29 03		and #$03	                and #3
.8254	18		clc		                clc
.8255	65 29		adc $29		                adc tmp3+1
.8257	85 29		sta $29		                sta tmp3+1
.8259	a5 20		lda $20		                lda status
.825b	6a		ror a		                ror             ; Rotate through carry into msb.
.825c	6a		ror a		                ror
.825d	29 80		and #$80	                and #$80
.825f	18		clc		                clc
.8260	65 28		adc $28		                adc tmp3
.8262	85 28		sta $28		                sta tmp3
.8264	90 02		bcc $8268	                bcc +           ; Increment the upper byte on carry.
.8266	e6 29		inc $29		                inc tmp3+1
.8268					+
.8268	98		tya		                tya
.8269	c9 80		cmp #$80	                cmp #$80
.826b	90 02		bcc $826f	                bcc +
.826d	a9 7f		lda #$7f	                lda #$7F
.826f					+
.826f	60		rts		                rts
.8270					xt_action_of:
.8270	a5 16		lda $16		                lda state
.8272	05 17		ora $17		                ora state+1
.8274	f0 0c		beq $8282	                beq _interpreting
.8276					_compiling:
.8276	20 9e 85	jsr $859e	                jsr xt_bracket_tick
.8279	a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.827b	a9 df		lda #$df	                lda #<xt_defer_fetch
.827d	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8280	80 06		bra $8288	                bra _done
.8282					_interpreting:
.8282	20 11 a2	jsr $a211	                jsr xt_tick
.8285	20 df 8a	jsr $8adf	                jsr xt_defer_fetch
.8288					_done:
.8288	60		rts		z_action_of:           rts
.8289					xt_again:
.8289	20 44 d8	jsr $d844	                jsr underflow_1
.828c	a0 00		ldy #$00	                ldy #0
.828e	a9 4c		lda #$4c	                lda #$4C        ; JMP
.8290	91 00		sta ($00),y	                sta (cp),y
.8292	c8		iny		                iny
.8293	b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8295	91 00		sta ($00),y	                sta (cp),y
.8297	c8		iny		                iny
.8298	b5 01		lda $01,x	                lda 1,x         ; MSB of address
.829a	91 00		sta ($00),y	                sta (cp),y
.829c	c8		iny		                iny
.829d	98		tya		                tya
.829e	18		clc		                clc
.829f	65 00		adc $00		                adc cp
.82a1	85 00		sta $00		                sta cp
.82a3	90 02		bcc $82a7	                bcc _done
.82a5	e6 01		inc $01		                inc cp+1
.82a7					_done:
.82a7	e8		inx		                inx
.82a8	e8		inx		                inx
.82a9	60		rts		z_again:        rts
.82aa					xt_align:
.82aa					xt_aligned:
.82aa					z_align:
.82aa	60		rts		z_aligned:      rts             ; stripped out during native compile
.82ab					xt_allot:
.82ab	20 44 d8	jsr $d844	                jsr underflow_1
.82ae	b5 01		lda $01,x	                lda 1,x
.82b0	30 22		bmi $82d4	                bmi _release
.82b2	18		clc		                clc
.82b3	a5 00		lda $00		                lda cp
.82b5	75 00		adc $00,x	                adc 0,x
.82b7	85 00		sta $00		                sta cp
.82b9	a5 01		lda $01		                lda cp+1
.82bb	75 01		adc $01,x	                adc 1,x
.82bd	85 01		sta $01		                sta cp+1
.82bf	a0 00		ldy #$00	                ldy #<cp_end
.82c1	c4 00		cpy $00		                cpy cp
.82c3	a9 7c		lda #$7c	                lda #>cp_end
.82c5	e5 01		sbc $01		                sbc cp+1
.82c7	b0 48		bcs $8311	                bcs _done               ; we're fine.
.82c9	84 00		sty $00		                sty cp                  ; still #<cp_end
.82cb	a9 7c		lda #$7c	                lda #>cp_end
.82cd	85 01		sta $01		                sta cp+1
.82cf	a9 00		lda #$00	                lda #err_allot
.82d1	4c 5a d8	jmp $d85a	                jmp error
.82d4					_release:
.82d4	ca		dex		                dex
.82d5	ca		dex		                dex
.82d6	a5 00		lda $00		                lda cp
.82d8	95 00		sta $00,x	                sta 0,x
.82da	a5 01		lda $01		                lda cp+1
.82dc	95 01		sta $01,x	                sta 1,x
.82de	20 e3 99	jsr $99e3	                jsr xt_plus                     ; new CP is now TOS
.82e1	ca		dex		                dex
.82e2	ca		dex		                dex                             ; new CP now NOS
.82e3	a9 00		lda #$00	                lda #<cp0
.82e5	95 00		sta $00,x	                sta 0,x
.82e7	a9 03		lda #$03	                lda #>cp0
.82e9	95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.82eb	20 6b d7	jsr $d76b	                jsr compare_16bit               ; still ( CP CP0 )
.82ee	f0 17		beq $8307	                beq _nega_done
.82f0	30 15		bmi $8307	                bmi _nega_done
.82f2	a9 00		lda #$00	                lda #<cp0
.82f4	85 00		sta $00		                sta cp
.82f6	a9 03		lda #$03	                lda #>cp0
.82f8	85 01		sta $01		                sta cp+1
.82fa	a9 44		lda #$44	                lda #<dictionary_start
.82fc	85 02		sta $02		                sta dp
.82fe	a9 bc		lda #$bc	                lda #>dictionary_start
.8300	85 03		sta $03		                sta dp+1
.8302	a9 0a		lda #$0a	                lda #err_negallot
.8304	4c 5a d8	jmp $d85a	                jmp error
.8307					_nega_done:
.8307	b5 02		lda $02,x	                lda 2,x
.8309	85 00		sta $00		                sta cp
.830b	b5 03		lda $03,x	                lda 3,x
.830d	85 01		sta $01		                sta cp+1
.830f	e8		inx		                inx
.8310	e8		inx		                inx                     ; drop through to _done
.8311					_done:
.8311	e8		inx		                inx
.8312	e8		inx		                inx
.8313					z_allot:
.8313	60		rts		                rts
.8314					xt_allow_native:
.8314	20 86 d7	jsr $d786	                jsr current_to_dp
.8317	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8319	b1 02		lda ($02),y	                lda (dp),y
.831b	29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.831d	91 02		sta ($02),y	                sta (dp),y
.831f					z_allow_native:
.831f	60		rts		                rts
.8320					xt_also:
.8320	20 34 91	jsr $9134	                jsr xt_get_order
.8323	20 93 98	jsr $9893	                jsr xt_over
.8326	20 ae a1	jsr $a1ae	                jsr xt_swap
.8329	20 1d 98	jsr $981d	                jsr xt_one_plus
.832c	20 1b 9d	jsr $9d1b	                jsr xt_set_order
.832f	60		rts		z_also:         rts
.8330					xt_always_native:
.8330	20 86 d7	jsr $d786	                jsr current_to_dp
.8333	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8335	b1 02		lda ($02),y	                lda (dp),y
.8337	09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.8339	29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.833b	91 02		sta ($02),y	                sta (dp),y
.833d					z_always_native:
.833d	60		rts		                rts
.833e					xt_and:
.833e	20 49 d8	jsr $d849	                jsr underflow_2
.8341	b5 00		lda $00,x	                lda 0,x
.8343	35 02		and $02,x	                and 2,x
.8345	95 02		sta $02,x	                sta 2,x
.8347	b5 01		lda $01,x	                lda 1,x
.8349	35 03		and $03,x	                and 3,x
.834b	95 03		sta $03,x	                sta 3,x
.834d	e8		inx		                inx
.834e	e8		inx		                inx
.834f	60		rts		z_and:          rts
.8350					xt_at_xy:
.8350	20 49 d8	jsr $d849	                jsr underflow_2
.8353	a5 18		lda $18		                lda base
.8355	48		pha		                pha
.8356	a9 0a		lda #$0a	                lda #10
.8358	85 18		sta $18		                sta base
.835a	a9 1b		lda #$1b	                lda #AscESC
.835c	20 f6 8d	jsr $8df6	                jsr emit_a
.835f	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.8361	20 f6 8d	jsr $8df6	                jsr emit_a
.8364	20 1d 98	jsr $981d	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8367	20 b1 d8	jsr $d8b1	                jsr print_u
.836a	a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.836c	20 f6 8d	jsr $8df6	                jsr emit_a
.836f	20 1d 98	jsr $981d	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8372	20 b1 d8	jsr $d8b1	                jsr print_u
.8375	a9 48		lda #$48	                lda #'H'
.8377	20 f6 8d	jsr $8df6	                jsr emit_a
.837a	68		pla		                pla
.837b	85 18		sta $18		                sta base
.837d	60		rts		z_at_xy:        rts
.837e					xt_backslash:
.837e	a5 0a		lda $0a		                lda ciblen
.8380	85 0c		sta $0c		                sta toin
.8382	a5 0b		lda $0b		                lda ciblen+1
.8384	85 0d		sta $0d		                sta toin+1
.8386	60		rts		z_backslash:    rts
.8387					xt_base:
.8387	ca		dex		                dex
.8388	ca		dex		                dex
.8389	a9 18		lda #$18	                lda #<base
.838b	95 00		sta $00,x	                sta 0,x         ; LSB
.838d	74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.838f	60		rts		z_base:         rts
.8390					xt_begin:
.8390	20 72 91	jsr $9172	                jsr xt_here
.8393	60		rts		z_begin:        rts
.8394					xt_bell:
.8394	a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.8396	20 f6 8d	jsr $8df6	                jsr emit_a
.8399	60		rts		z_bell:         rts
.839a					xt_bl:
.839a	ca		dex		                dex
.839b	ca		dex		                dex
.839c	a9 20		lda #$20	                lda #AscSP
.839e	95 00		sta $00,x	                sta 0,x
.83a0	74 01		stz $01,x	                stz 1,x
.83a2	60		rts		z_bl:           rts
.83a3					xt_blk:
.83a3	ca		dex		                dex
.83a4	ca		dex		                dex
.83a5	18		clc		                clc
.83a6	a5 1e		lda $1e		                lda up
.83a8	69 00		adc #$00	                adc #blk_offset ; Add offset
.83aa	95 00		sta $00,x	                sta 0,x
.83ac	a5 1f		lda $1f		                lda up+1
.83ae	69 00		adc #$00	                adc #0          ; Adding carry
.83b0	95 01		sta $01,x	                sta 1,x
.83b2	60		rts		z_blk:          rts
.83b3					xt_blkbuffer:
.83b3	ca		dex		                dex
.83b4	ca		dex		                dex
.83b5	a0 28		ldy #$28	                ldy #blkbuffer_offset
.83b7	b1 1e		lda ($1e),y	                lda (up),y
.83b9	95 00		sta $00,x	                sta 0,x
.83bb	c8		iny		                iny             ; Move along to the next byte
.83bc	b1 1e		lda ($1e),y	                lda (up),y
.83be	95 01		sta $01,x	                sta 1,x
.83c0	60		rts		z_blkbuffer:    rts
.83c1					xt_block:
.83c1	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83c3	b1 1e		lda ($1e),y	                lda (up),y
.83c5	d5 00		cmp $00,x	                cmp 0,x
.83c7	d0 0f		bne $83d8	                bne _not_in_buffer
.83c9	c8		iny		                iny
.83ca	b1 1e		lda ($1e),y	                lda (up),y
.83cc	d5 01		cmp $01,x	                cmp 1,x
.83ce	d0 08		bne $83d8	                bne _not_in_buffer
.83d0	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83d2	b1 1e		lda ($1e),y	                lda (up),y
.83d4	29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.83d6	d0 30		bne $8408	                bne _done       ; It's already in the buffer and in use.
.83d8					_not_in_buffer:
.83d8	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83da	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.83dc	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.83de	d0 0c		bne $83ec	                bne _buffer_available ; Unused or not dirty = available
.83e0	20 b3 83	jsr $83b3	                jsr xt_blkbuffer
.83e3	20 a5 85	jsr $85a5	                jsr xt_buffblocknum
.83e6	20 80 8f	jsr $8f80	                jsr xt_fetch
.83e9	20 60 85	jsr $8560	                jsr xt_block_write
.83ec					_buffer_available:
.83ec	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83ee	b5 00		lda $00,x	                lda 0,x
.83f0	91 1e		sta ($1e),y	                sta (up),y
.83f2	c8		iny		                iny
.83f3	b5 01		lda $01,x	                lda 1,x
.83f5	91 1e		sta ($1e),y	                sta (up),y
.83f7	20 b3 83	jsr $83b3	                jsr xt_blkbuffer
.83fa	20 ae a1	jsr $a1ae	                jsr xt_swap
.83fd	20 3d 85	jsr $853d	                jsr xt_block_read
.8400	a9 01		lda #$01	                lda #1
.8402	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8404	91 1e		sta ($1e),y	                sta (up),y
.8406	ca		dex		                dex
.8407	ca		dex		                dex
.8408					_done:
.8408	a0 28		ldy #$28	                ldy #blkbuffer_offset
.840a	b1 1e		lda ($1e),y	                lda (up),y
.840c	95 00		sta $00,x	                sta 0,x
.840e	c8		iny		                iny
.840f	b1 1e		lda ($1e),y	                lda (up),y
.8411	95 01		sta $01,x	                sta 1,x
.8413	60		rts		z_block:        rts
.8414					xt_block_ramdrive_init:
.8414	20 44 d8	jsr $d844	                jsr underflow_1
.8417	4c 32 85	jmp $8532	                jmp _after_ramdrive_code
.841a					_ramdrive_code:
>841a	62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>8422	77 61 70 20 64 65 63 69 6d 61 6c
>842d	20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>8434	20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>8438	20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>8440	20 72 61 6d 64 72 69 76 65
>8449	20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8451	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>845f	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>8467	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>8477	73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>8487	20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>848f	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>849e	20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>84a6	65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>84b6	31 30 32 34 20 6d 6f 76 65 20 3b
>84c1	20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>84c9	2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>84d9	6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>84e9	20 21
>84eb	20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84f3	2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>8503	62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>8513	6f 72 20 21
>8517	20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>851f	65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>852f	65 20 21
.8532					_after_ramdrive_code:
.8532	20 a9 a0	jsr $a0a9	                jsr sliteral_runtime
>8535	1a 84 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.8539	20 d5 90	jsr $90d5	                jsr xt_evaluate
.853c					z_block_ramdrive_init:
.853c	60		rts		                rts
.853d					xt_block_read:
.853d	a0 2e		ldy #$2e	                ldy #blockread_offset
.853f	b1 1e		lda ($1e),y	                lda (up),y
.8541	85 24		sta $24		                sta tmp1
.8543	c8		iny		                iny
.8544	b1 1e		lda ($1e),y	                lda (up),y
.8546	85 25		sta $25		                sta tmp1+1
.8548	6c 24 00	jmp ($0024)	                jmp (tmp1)
.854b					z_block_read:
.854b					xt_block_read_vector:
.854b	ca		dex		                dex
.854c	ca		dex		                dex
.854d	18		clc		                clc
.854e	a5 1e		lda $1e		                lda up
.8550	69 2e		adc #$2e	                adc #blockread_offset
.8552	95 00		sta $00,x	                sta 0,x
.8554	a5 1f		lda $1f		                lda up+1
.8556	69 00		adc #$00	                adc #0          ; Add carry
.8558	95 01		sta $01,x	                sta 1,x
.855a					z_block_read_vector:
.855a	60		rts		                rts
.855b					xt_block_word_error:
.855b	a9 0c		lda #$0c	                lda #err_blockwords
.855d	4c 5a d8	jmp $d85a	                jmp error       ; no RTS needed
.8560					z_block_word_error:
.8560					xt_block_write:
.8560	a0 30		ldy #$30	                ldy #blockwrite_offset
.8562	b1 1e		lda ($1e),y	                lda (up),y
.8564	85 24		sta $24		                sta tmp1
.8566	c8		iny		                iny
.8567	b1 1e		lda ($1e),y	                lda (up),y
.8569	85 25		sta $25		                sta tmp1+1
.856b	6c 24 00	jmp ($0024)	                jmp (tmp1)
.856e					z_block_write:
.856e					xt_block_write_vector:
.856e	ca		dex		                dex
.856f	ca		dex		                dex
.8570	18		clc		                clc
.8571	a5 1e		lda $1e		                lda up
.8573	69 30		adc #$30	                adc #blockwrite_offset
.8575	95 00		sta $00,x	                sta 0,x
.8577	a5 1f		lda $1f		                lda up+1
.8579	69 00		adc #$00	                adc #0          ; Add carry
.857b	95 01		sta $01,x	                sta 1,x
.857d					z_block_write_vector:
.857d	60		rts		                rts
.857e					xt_bounds:
.857e	20 49 d8	jsr $d849	                jsr underflow_2
.8581	18		clc		                clc
.8582	b5 00		lda $00,x	                lda 0,x                 ; LSB u
.8584	b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.8586	75 02		adc $02,x	                adc 2,x
.8588	95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.858a	94 00		sty $00,x	                sty 0,x
.858c	b5 01		lda $01,x	                lda 1,x                 ; MSB u
.858e	b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8590	75 03		adc $03,x	                adc 3,x
.8592	95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.8594	94 01		sty $01,x	                sty 1,x
.8596	60		rts		z_bounds:       rts
.8597					xt_bracket_char:
.8597	20 31 86	jsr $8631	                jsr xt_char
.859a	20 8a 93	jsr $938a	                jsr xt_literal
.859d	60		rts		z_bracket_char: rts
.859e					xt_bracket_tick:
.859e	20 11 a2	jsr $a211	                jsr xt_tick
.85a1	20 8a 93	jsr $938a	                jsr xt_literal
.85a4	60		rts		z_bracket_tick: rts
.85a5					xt_buffblocknum:
.85a5	ca		dex		                dex
.85a6	ca		dex		                dex
.85a7	18		clc		                clc
.85a8	a5 1e		lda $1e		                lda up
.85aa	69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.85ac	95 00		sta $00,x	                sta 0,x
.85ae	a5 1f		lda $1f		                lda up+1
.85b0	69 00		adc #$00	                adc #0                          ; Adding carry
.85b2	95 01		sta $01,x	                sta 1,x
.85b4	60		rts		z_buffblocknum: rts
.85b5					xt_buffer:
.85b5	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85b7	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.85b9	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.85bb	d0 0c		bne $85c9	                bne _buffer_available ; Unused or not dirty = available
.85bd	20 b3 83	jsr $83b3	                jsr xt_blkbuffer
.85c0	20 a5 85	jsr $85a5	                jsr xt_buffblocknum
.85c3	20 80 8f	jsr $8f80	                jsr xt_fetch
.85c6	20 60 85	jsr $8560	                jsr xt_block_write
.85c9					_buffer_available:
.85c9	a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.85cb	b5 00		lda $00,x	                lda 0,x
.85cd	91 1e		sta ($1e),y	                sta (up),y
.85cf	c8		iny		                iny
.85d0	b5 01		lda $01,x	                lda 1,x
.85d2	91 1e		sta ($1e),y	                sta (up),y
.85d4	a9 01		lda #$01	                lda #1
.85d6	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.85d8	91 1e		sta ($1e),y	                sta (up),y
.85da					_done:
.85da	a0 28		ldy #$28	                ldy #blkbuffer_offset
.85dc	b1 1e		lda ($1e),y	                lda (up),y
.85de	95 00		sta $00,x	                sta 0,x
.85e0	c8		iny		                iny
.85e1	b1 1e		lda ($1e),y	                lda (up),y
.85e3	95 01		sta $01,x	                sta 1,x
.85e5	60		rts		z_buffer:       rts
.85e6					xt_buffer_colon:
.85e6	20 69 89	jsr $8969	                jsr xt_create
.85e9	20 ab 82	jsr $82ab	                jsr xt_allot
.85ec	60		rts		z_buffer_colon: rts
.85ed					xt_buffstatus:
.85ed	ca		dex		                dex
.85ee	ca		dex		                dex
.85ef	18		clc		                clc
.85f0	a5 1e		lda $1e		                lda up
.85f2	69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85f4	95 00		sta $00,x	                sta 0,x
.85f6	a5 1f		lda $1f		                lda up+1
.85f8	69 00		adc #$00	                adc #0                  ; Adding carry
.85fa	95 01		sta $01,x	                sta 1,x
.85fc	60		rts		z_buffstatus:   rts
.85fd					xt_bye:
.85fd	4c 2b f0	jmp $f02b	                jmp platform_bye
.8600					z_bye:
.8600					xt_c_comma:
.8600	20 44 d8	jsr $d844	                jsr underflow_1
.8603	b5 00		lda $00,x	                lda 0,x
.8605	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.8608	e8		inx		                inx
.8609	e8		inx		                inx
.860a	60		rts		z_c_comma:      rts
.860b					xt_c_fetch:
.860b	20 44 d8	jsr $d844	                jsr underflow_1
.860e	a1 00		lda ($00,x)	                lda (0,x)
.8610	95 00		sta $00,x	                sta 0,x
.8612	74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8614	60		rts		z_c_fetch:      rts
.8615					xt_c_store:
.8615	20 49 d8	jsr $d849	                jsr underflow_2
.8618	b5 02		lda $02,x	                lda 2,x
.861a	81 00		sta ($00,x)	                sta (0,x)
.861c	e8		inx		                inx
.861d	e8		inx		                inx
.861e	e8		inx		                inx
.861f	e8		inx		                inx
.8620	60		rts		z_c_store:      rts
.8621					xt_cell_plus:
.8621	20 44 d8	jsr $d844	                jsr underflow_1
.8624	f6 00		inc $00,x	                inc 0,x
.8626	d0 02		bne $862a	                bne +
.8628	f6 01		inc $01,x	                inc 1,x
.862a					+
.862a	f6 00		inc $00,x	                inc 0,x
.862c	d0 02		bne $8630	                bne _done
.862e	f6 01		inc $01,x	                inc 1,x
.8630					_done:
.8630	60		rts		z_cell_plus:    rts
.8631					xt_char:
.8631	20 df 98	jsr $98df	                jsr xt_parse_name
.8634	b5 00		lda $00,x	                lda 0,x
.8636	15 01		ora $01,x	                ora 1,x
.8638	d0 05		bne $863f	                bne _not_empty
.863a	a9 05		lda #$05	                lda #err_noname
.863c	4c 5a d8	jmp $d85a	                jmp error
.863f					_not_empty:
.863f	e8		inx		                inx             ; drop number of characters, leave addr
.8640	e8		inx		                inx
.8641	a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8643	95 00		sta $00,x	                sta 0,x
.8645	74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8647	60		rts		z_char:         rts
.8648					xt_chars:
.8648	20 44 d8	jsr $d844	                jsr underflow_1
.864b	60		rts		z_chars:        rts
.864c					xt_cleave:
.864c	20 49 d8	jsr $d849	                jsr underflow_2
.864f	20 63 95	jsr $9563	                jsr xt_minus_leading    ; -LEADING ( addr u )
.8652	20 62 92	jsr $9262	                jsr xt_input_to_r       ; save old imput state
.8655	b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.8657	85 0a		sta $0a		                sta ciblen
.8659	b5 01		lda $01,x	                lda 1,x
.865b	85 0b		sta $0b		                sta ciblen+1
.865d	b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.865f	85 08		sta $08		                sta cib
.8661	b5 03		lda $03,x	                lda 3,x
.8663	85 09		sta $09		                sta cib+1
.8665	64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.8667	64 0d		stz $0d		                stz toin+1
.8669	20 df 98	jsr $98df	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.866c	b5 00		lda $00,x	                lda 0,x
.866e	15 01		ora $01,x	                ora 1,x
.8670	f0 23		beq $8695	                beq _done
.8672	b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.8674	38		sec		                sec
.8675	f5 00		sbc $00,x	                sbc 0,x
.8677	95 04		sta $04,x	                sta 4,x
.8679	b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.867b	f5 01		sbc $01,x	                sbc 1,x
.867d	95 05		sta $05,x	                sta 5,x
.867f	b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8681	18		clc		                clc
.8682	75 00		adc $00,x	                adc 0,x
.8684	95 06		sta $06,x	                sta 6,x
.8686	b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.8688	75 01		adc $01,x	                adc 1,x
.868a	95 07		sta $07,x	                sta 7,x
.868c	20 7e a4	jsr $a47e	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.868f	20 63 95	jsr $9563	                jsr xt_minus_leading
.8692	20 7e a4	jsr $a47e	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.8695					_done:
.8695	20 a3 9a	jsr $9aa3	                jsr xt_r_to_input
.8698	60		rts		z_cleave:       rts
.8699					xt_cmove:
.8699	20 4e d8	jsr $d84e	                jsr underflow_3
.869c	b5 02		lda $02,x	                lda 2,x
.869e	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86a0	b5 03		lda $03,x	                lda 3,x
.86a2	85 27		sta $27		                sta tmp2+1
.86a4	b5 04		lda $04,x	                lda 4,x
.86a6	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86a8	b5 05		lda $05,x	                lda 5,x
.86aa	85 25		sta $25		                sta tmp1+1
.86ac	a0 00		ldy #$00	                ldy #0
.86ae	b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.86b0	f0 0f		beq $86c1	                beq _dopartial
.86b2					_page:
.86b2	b1 24		lda ($24),y	                lda (tmp1),y
.86b4	91 26		sta ($26),y	                sta (tmp2),y
.86b6	c8		iny		                iny
.86b7	d0 f9		bne $86b2	                bne _page
.86b9	e6 25		inc $25		                inc tmp1+1
.86bb	e6 27		inc $27		                inc tmp2+1
.86bd	d6 01		dec $01,x	                dec 1,x
.86bf	d0 f1		bne $86b2	                bne _page
.86c1					_dopartial:
.86c1	b5 00		lda $00,x	                lda 0,x         ; length of last page
.86c3	f0 09		beq $86ce	                beq _done
.86c5					_partial:
.86c5	b1 24		lda ($24),y	                lda (tmp1),y
.86c7	91 26		sta ($26),y	                sta (tmp2),y
.86c9	c8		iny		                iny
.86ca	d6 00		dec $00,x	                dec 0,x
.86cc	d0 f7		bne $86c5	                bne _partial
.86ce					_done:
.86ce	8a		txa		                txa
.86cf	18		clc		                clc
.86d0	69 06		adc #$06	                adc #6
.86d2	aa		tax		                tax
.86d3	60		rts		z_cmove:        rts
.86d4					xt_cmove_up:
.86d4	20 4e d8	jsr $d84e	                jsr underflow_3
.86d7	b5 02		lda $02,x	                lda 2,x
.86d9	85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.86db	b5 03		lda $03,x	                lda 3,x
.86dd	18		clc		                clc
.86de	75 01		adc $01,x	                adc 1,x
.86e0	85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.86e2	b5 04		lda $04,x	                lda 4,x
.86e4	85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.86e6	b5 05		lda $05,x	                lda 5,x
.86e8	18		clc		                clc
.86e9	75 01		adc $01,x	                adc 1,x
.86eb	85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86ed	f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86ef	b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86f1	f0 0e		beq $8701	                beq _nopartial
.86f3					_outerloop:
.86f3	88		dey		                dey
.86f4	f0 07		beq $86fd	                beq _finishpage
.86f6					_innerloop:
.86f6	b1 24		lda ($24),y	                lda (tmp1),y
.86f8	91 26		sta ($26),y	                sta (tmp2),y
.86fa	88		dey		                dey
.86fb	d0 f9		bne $86f6	                bne _innerloop
.86fd					_finishpage:
.86fd	b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.86ff	92 26		sta ($26)	                sta (tmp2)
.8701					_nopartial:
.8701	c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.8703	c6 27		dec $27		                dec tmp2+1
.8705	d6 01		dec $01,x	                dec 1,x
.8707	d0 ea		bne $86f3	                bne _outerloop
.8709					_done:
.8709	8a		txa		                txa
.870a	18		clc		                clc
.870b	69 06		adc #$06	                adc #6
.870d	aa		tax		                tax
.870e	60		rts		z_cmove_up:     rts
.870f					xt_colon:
.870f	a5 16		lda $16		                lda state
.8711	05 17		ora $17		                ora state+1
.8713	f0 05		beq $871a	                beq +
.8715	a9 07		lda #$07	                lda #err_state
.8717	4c 5a d8	jmp $d85a	                jmp error
.871a					+
.871a	c6 16		dec $16		                dec state
.871c	c6 17		dec $17		                dec state+1
.871e	a9 40		lda #$40	                lda #%01000000
.8720	04 20		tsb $20		                tsb status
.8722	20 86 d7	jsr $d786	                jsr current_to_dp
.8725	a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.8727	48		pha		                pha
.8728	a5 02		lda $02		                lda dp
.872a	48		pha		                pha
.872b	a9 80		lda #$80	                lda #%10000000
.872d	04 20		tsb $20		                tsb status
.872f	20 69 89	jsr $8969	                jsr xt_create
.8732	20 86 d7	jsr $d786	                jsr current_to_dp   ; This might be able to be omitted
.8735	a5 02		lda $02		                lda dp
.8737	85 04		sta $04		                sta workword
.8739	a5 03		lda $03		                lda dp+1
.873b	85 05		sta $05		                sta workword+1
.873d	68		pla		                pla
.873e	85 02		sta $02		                sta dp
.8740	68		pla		                pla
.8741	85 03		sta $03		                sta dp+1
.8743	20 99 d7	jsr $d799	                jsr dp_to_current
.8746	a5 00		lda $00		                lda cp
.8748	38		sec		                sec
.8749	e9 03		sbc #$03	                sbc #3
.874b	85 00		sta $00		                sta cp
.874d	b0 02		bcs $8751	                bcs _done
.874f	c6 01		dec $01		                dec cp+1
.8751					_done:
.8751	60		rts		z_colon:        rts
.8752					xt_colon_noname:
.8752	a5 16		lda $16		                lda state
.8754	05 17		ora $17		                ora state+1
.8756	f0 05		beq $875d	                beq +
.8758	a9 07		lda #$07	                lda #err_state
.875a	4c 5a d8	jmp $d85a	                jmp error
.875d					+
.875d	c6 16		dec $16		                dec state
.875f	c6 17		dec $17		                dec state+1
.8761	a9 40		lda #$40	                lda #%01000000
.8763	14 20		trb $20		                trb status
.8765	a5 00		lda $00		                lda cp
.8767	85 04		sta $04		                sta workword
.8769	a5 01		lda $01		                lda cp+1
.876b	85 05		sta $05		                sta workword+1
.876d					_done:
.876d	60		rts		z_colon_noname:        rts
.876e					xt_comma:
.876e	20 44 d8	jsr $d844	                jsr underflow_1
.8771	b5 00		lda $00,x	                lda 0,x
.8773	92 00		sta ($00)	                sta (cp)
.8775	e6 00		inc $00		                inc cp
.8777	d0 02		bne $877b	                bne +
.8779	e6 01		inc $01		                inc cp+1
.877b					+
.877b	b5 01		lda $01,x	                lda 1,x
.877d	92 00		sta ($00)	                sta (cp)
.877f	e6 00		inc $00		                inc cp
.8781	d0 02		bne $8785	                bne _done
.8783	e6 01		inc $01		                inc cp+1
.8785					_done:
.8785	e8		inx		                inx
.8786	e8		inx		                inx
.8787	60		rts		z_comma:        rts
.8788					xt_compare:
.8788	20 53 d8	jsr $d853	                jsr underflow_4
.878b	b5 02		lda $02,x	                lda 2,x
.878d	85 26		sta $26		                sta tmp2
.878f	b5 03		lda $03,x	                lda 3,x
.8791	85 27		sta $27		                sta tmp2+1
.8793	b5 06		lda $06,x	                lda 6,x
.8795	85 24		sta $24		                sta tmp1
.8797	b5 07		lda $07,x	                lda 7,x
.8799	85 25		sta $25		                sta tmp1+1
.879b					_compare_loop:
.879b	b5 04		lda $04,x	                lda 4,x
.879d	15 05		ora $05,x	                ora 5,x
.879f	f0 2c		beq $87cd	                beq _str1_done
.87a1	b5 00		lda $00,x	                lda 0,x
.87a3	15 01		ora $01,x	                ora 1,x
.87a5	f0 3a		beq $87e1	                beq _greater    ; Str2 empty first
.87a7					_check_letter:
.87a7	b2 24		lda ($24)	                lda (tmp1)
.87a9	d2 26		cmp ($26)	                cmp (tmp2)
.87ab	90 26		bcc $87d3	                bcc _less
.87ad	d0 32		bne $87e1	                bne _greater
.87af					_next_letter:
.87af	e6 24		inc $24		                inc tmp1
.87b1	d0 02		bne $87b5	                bne +
.87b3	e6 25		inc $25		                inc tmp1+1
.87b5					+
.87b5	e6 26		inc $26		                inc tmp2
.87b7	d0 02		bne $87bb	                bne +
.87b9	e6 27		inc $27		                inc tmp2+1
.87bb					+
.87bb	b5 04		lda $04,x	                lda 4,x
.87bd	d0 02		bne $87c1	                bne +
.87bf	d6 05		dec $05,x	                dec 5,x
.87c1					+
.87c1	d6 04		dec $04,x	                dec 4,x
.87c3	b5 00		lda $00,x	                lda 0,x
.87c5	d0 02		bne $87c9	                bne +
.87c7	d6 01		dec $01,x	                dec 1,x
.87c9					+
.87c9	d6 00		dec $00,x	                dec 0,x
.87cb	80 ce		bra $879b	                bra _compare_loop
.87cd					_str1_done:
.87cd	b5 00		lda $00,x	                lda 0,x
.87cf	15 01		ora $01,x	                ora 1,x
.87d1	f0 08		beq $87db	                beq _equal      ; Both out of letters
.87d3					_less:
.87d3	a9 ff		lda #$ff	                lda #$FF
.87d5	95 06		sta $06,x	                sta 6,x
.87d7	95 07		sta $07,x	                sta 7,x
.87d9	80 0c		bra $87e7	                bra _done
.87db					_equal:
.87db	74 06		stz $06,x	                stz 6,x
.87dd	74 07		stz $07,x	                stz 7,x
.87df	80 06		bra $87e7	                bra _done
.87e1					_greater:
.87e1	a9 01		lda #$01	                lda #1
.87e3	95 06		sta $06,x	                sta 6,x
.87e5	74 07		stz $07,x	                stz 7,x
.87e7					_done:
.87e7	8a		txa		                txa
.87e8	18		clc		                clc
.87e9	69 06		adc #$06	                adc #6
.87eb	aa		tax		                tax
.87ec	60		rts		z_compare:      rts
.87ed					xt_compile_comma:
.87ed	20 44 d8	jsr $d844	                jsr underflow_1
.87f0	b5 01		lda $01,x	                lda 1,x                 ; MSB
.87f2	48		pha		                pha
.87f3	b5 00		lda $00,x	                lda 0,x
.87f5	48		pha		                pha                     ; LSB
.87f6	20 78 92	jsr $9278	                jsr xt_int_to_name      ; ( xt -- nt )
.87f9	b5 00		lda $00,x	                lda 0,x
.87fb	15 01		ora $01,x	                ora 1,x
.87fd	d0 03		bne $8802	                bne _check_nt
.87ff	4c ea 88	jmp $88ea	                jmp _compile_as_jump
.8802					_check_nt:
.8802	b5 00		lda $00,x	                lda 0,x
.8804	85 2c		sta $2c		                sta tmptos
.8806	b5 01		lda $01,x	                lda 1,x
.8808	85 2d		sta $2d		                sta tmptos+1
.880a	f6 00		inc $00,x	                inc 0,x
.880c	d0 02		bne $8810	                bne +
.880e	f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.8810					+
.8810	a1 00		lda ($00,x)	                lda (0,x)
.8812	85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.8814	29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.8816	f0 0d		beq $8825	                beq _compile_check
.8818	a5 2c		lda $2c		                lda tmptos
.881a	95 00		sta $00,x	                sta 0,x
.881c	a5 2d		lda $2d		                lda tmptos+1
.881e	95 01		sta $01,x	                sta 1,x
.8820	20 75 a7	jsr $a775	                jsr xt_wordsize         ; ( nt -- u )
.8823	80 27		bra $884c	                bra _compile_as_code
.8825					_compile_check:
.8825	a5 28		lda $28		                lda tmp3
.8827	29 08		and #$08	                and #NN
.8829	f0 03		beq $882e	                beq _check_size_limit
.882b	4c ea 88	jmp $88ea	                jmp _compile_as_jump    ; too far for BRA
.882e					_check_size_limit:
.882e	a5 2c		lda $2c		                lda tmptos
.8830	95 00		sta $00,x	                sta 0,x
.8832	a5 2d		lda $2d		                lda tmptos+1
.8834	95 01		sta $01,x	                sta 1,x
.8836	20 75 a7	jsr $a775	                jsr xt_wordsize         ; ( nt -- u )
.8839	b5 01		lda $01,x	                lda 1,x
.883b	c5 1b		cmp $1b		                cmp nc_limit+1
.883d	90 0d		bcc $884c	                bcc _compile_as_code    ; user-defined limit MSB
.883f	d0 08		bne $8849	                bne _jumpto_compile_as_jump
.8841	b5 00		lda $00,x	                lda 0,x
.8843	c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.8845	90 05		bcc $884c	                bcc _compile_as_code    ; Allow native compiling for less
.8847	f0 03		beq $884c	                beq _compile_as_code    ; than or equal to the limit.
.8849					_jumpto_compile_as_jump:
.8849	4c ea 88	jmp $88ea	                jmp _compile_as_jump    ; too far for BRA
.884c					_compile_as_code:
.884c	ca		dex		                dex
.884d	ca		dex		                dex                     ; ( -- u ? )
.884e	ca		dex		                dex
.884f	ca		dex		                dex                     ; ( -- u ? ? )
.8850	b5 04		lda $04,x	                lda 4,x
.8852	95 00		sta $00,x	                sta 0,x                 ; LSB of u
.8854	b5 05		lda $05,x	                lda 5,x
.8856	95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.8858	68		pla		                pla
.8859	95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.885b	68		pla		                pla
.885c	95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.885e	a5 00		lda $00		                lda cp                  ; LSB of cp
.8860	95 02		sta $02,x	                sta 2,x
.8862	a5 01		lda $01		                lda cp+1
.8864	95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.8866	a0 00		ldy #$00	                ldy #0
.8868					_strip_loop:
.8868	b9 d8 88	lda $88d8,y	                lda _strip_table,y      ; LSB of first word
.886b	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.886d	d0 07		bne $8876	                bne _next_entry
.886f	b9 d9 88	lda $88d9,y	                lda _strip_table+1,y
.8872	d5 05		cmp $05,x	                cmp 5,x
.8874	f0 0c		beq $8882	                beq _found_entry
.8876					_next_entry:
.8876	b9 d8 88	lda $88d8,y	                lda _strip_table,y      ; pointing to LSB
.8879	19 d9 88	ora $88d9,y	                ora _strip_table+1,y    ; get MSB
.887c	f0 22		beq $88a0	                beq _underflow_strip    ; table done, let's get out of here
.887e	c8		iny		                iny
.887f	c8		iny		                iny
.8880	80 e6		bra $8868	                bra _strip_loop
.8882					_found_entry:
.8882	98		tya		                tya
.8883	4a		lsr a		                lsr
.8884	a8		tay		                tay
.8885	b9 e4 88	lda $88e4,y	                lda _strip_size,y
.8888	85 2c		sta $2c		                sta tmptos              ; save a copy
.888a	18		clc		                clc
.888b	75 04		adc $04,x	                adc 4,x
.888d	95 04		sta $04,x	                sta 4,x
.888f	90 02		bcc $8893	                bcc+
.8891	f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8893					+
.8893	06 2c		asl $2c		                asl tmptos
.8895	38		sec		                sec
.8896	b5 00		lda $00,x	                lda 0,x
.8898	e5 2c		sbc $2c		                sbc tmptos
.889a	95 00		sta $00,x	                sta 0,x
.889c	b0 02		bcs $88a0	                bcs +
.889e	d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.88a0					+
.88a0					_underflow_strip:
.88a0	a5 1c		lda $1c		                lda uf_strip
.88a2	05 1d		ora $1d		                ora uf_strip+1
.88a4	f0 1c		beq $88c2	                beq _specials_done
.88a6	a5 28		lda $28		                lda tmp3
.88a8	29 10		and #$10	                and #UF
.88aa	f0 16		beq $88c2	                beq _specials_done
.88ac	18		clc		                clc
.88ad	b5 04		lda $04,x	                lda 4,x
.88af	69 03		adc #$03	                adc #3
.88b1	95 04		sta $04,x	                sta 4,x
.88b3	90 02		bcc $88b7	                bcc +
.88b5	f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.88b7					+
.88b7	38		sec		                sec
.88b8	b5 00		lda $00,x	                lda 0,x
.88ba	e9 03		sbc #$03	                sbc #3
.88bc	95 00		sta $00,x	                sta 0,x
.88be	b0 02		bcs $88c2	                bcs +
.88c0	d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.88c2					+
.88c2					_specials_done:
.88c2	b5 01		lda $01,x	                lda 1,x                 ; MSB
.88c4	48		pha		                pha
.88c5	b5 00		lda $00,x	                lda 0,x                 ; LSB
.88c7	48		pha		                pha
.88c8	20 c2 95	jsr $95c2	                jsr xt_move
.88cb	18		clc		                clc
.88cc	68		pla		                pla                     ; LSB
.88cd	65 00		adc $00		                adc cp
.88cf	85 00		sta $00		                sta cp
.88d1	68		pla		                pla                     ; MSB
.88d2	65 01		adc $01		                adc cp+1
.88d4	85 01		sta $01		                sta cp+1
.88d6	80 2c		bra $8904	                bra _done
.88d8					_strip_table:
>88d8	92 9a 7d 9a 70 a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88de	a2 a4 28 a4 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88e4					_strip_size:
>88e4	04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88ea					_compile_as_jump:
.88ea	a9 20		lda #$20	                lda #$20
.88ec	92 00		sta ($00)	                sta (cp)
.88ee	a0 01		ldy #$01	                ldy #1
.88f0	68		pla		                pla             ; LSB
.88f1	91 00		sta ($00),y	                sta (cp),y
.88f3	c8		iny		                iny
.88f4	68		pla		                pla             ; MSB
.88f5	91 00		sta ($00),y	                sta (cp),y
.88f7	a9 03		lda #$03	                lda #3
.88f9	18		clc		                clc
.88fa	65 00		adc $00		                adc cp
.88fc	85 00		sta $00		                sta cp
.88fe	90 02		bcc $8902	                bcc +
.8900	e6 01		inc $01		                inc cp+1
.8902					+
.8902	e8		inx		                inx             ; drop xt
.8903	e8		inx		                inx
.8904					_done:
.8904					z_compile_comma:
.8904	60		rts		                rts
.8905					xt_compile_only:
.8905	20 86 d7	jsr $d786	                jsr current_to_dp
.8908	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.890a	b1 02		lda ($02),y	                lda (dp),y
.890c	09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.890e	91 02		sta ($02),y	                sta (dp),y
.8910	60		rts		z_compile_only: rts
.8911					xt_value:
.8911					xt_constant:
.8911	20 44 d8	jsr $d844	                jsr underflow_1
.8914	20 69 89	jsr $8969	                jsr xt_create
.8917	38		sec		                sec
.8918	a5 00		lda $00		                lda cp
.891a	e9 02		sbc #$02	                sbc #2
.891c	85 24		sta $24		                sta tmp1
.891e	a5 01		lda $01		                lda cp+1
.8920	e9 00		sbc #$00	                sbc #0
.8922	85 25		sta $25		                sta tmp1+1
.8924	a9 00		lda #$00	                lda #<doconst           ; LSB of DOCONST
.8926	92 24		sta ($24)	                sta (tmp1)
.8928	a0 01		ldy #$01	                ldy #1
.892a	a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.892c	91 24		sta ($24),y	                sta (tmp1),y
.892e	20 6e 87	jsr $876e	                jsr xt_comma            ; drop through to adjust_z
.8931					adjust_z:
.8931	20 3b 93	jsr $933b	                jsr xt_latestnt         ; gives us ( -- nt )
.8934	b5 00		lda $00,x	                lda 0,x
.8936	85 24		sta $24		                sta tmp1
.8938	b5 01		lda $01,x	                lda 1,x
.893a	85 25		sta $25		                sta tmp1+1
.893c	a0 06		ldy #$06	                ldy #6
.893e	b1 24		lda ($24),y	                lda (tmp1),y
.8940	18		clc		                clc
.8941	69 02		adc #$02	                adc #2
.8943	91 24		sta ($24),y	                sta (tmp1),y
.8945	c8		iny		                iny
.8946	b1 24		lda ($24),y	                lda (tmp1),y
.8948	69 00		adc #$00	                adc #0                  ; only need carry
.894a	91 24		sta ($24),y	                sta (tmp1),y
.894c	e8		inx		                inx
.894d	e8		inx		                inx
.894e					z_value:
.894e	60		rts		z_constant:     rts
.894f					xt_count:
.894f	20 44 d8	jsr $d844	                jsr underflow_1
.8952	a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.8954	a8		tay		                tay
.8955	f6 00		inc $00,x	                inc 0,x         ; LSB
.8957	d0 02		bne $895b	                bne +
.8959	f6 01		inc $01,x	                inc 1,x         ; MSB
.895b	98		tya		+               tya
.895c	ca		dex		                dex
.895d	ca		dex		                dex
.895e	95 00		sta $00,x	                sta 0,x         ; LSB
.8960	74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8962	60		rts		z_count:        rts
.8963					xt_cr:
.8963	a9 0a		lda #$0a	                lda #AscLF
.8965	20 f6 8d	jsr $8df6	                jsr emit_a
.8968	60		rts		z_cr:           rts
.8969					xt_create:
.8969	20 df 98	jsr $98df	                jsr xt_parse_name       ; ( addr u )
.896c	b5 00		lda $00,x	                lda 0,x
.896e	15 01		ora $01,x	                ora 1,x
.8970	d0 05		bne $8977	                bne _got_name
.8972	a9 05		lda #$05	                lda #err_noname
.8974	4c 5a d8	jmp $d85a	                jmp error
.8977					_got_name:
.8977	74 01		stz $01,x	                stz 1,x
.8979	20 b8 a3	jsr $a3b8	                jsr xt_two_dup          ; ( addr u addr u )
.897c	20 db 8f	jsr $8fdb	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.897f	b5 00		lda $00,x	                lda 0,x
.8981	15 01		ora $01,x	                ora 1,x
.8983	f0 1e		beq $89a3	                beq _new_name           ; We haven't seen this one before.
.8985	e8		inx		                inx                     ; Drop flag (nt) from find-name.
.8986	e8		inx		                inx
.8987	24 20		bit $20		                bit status
.8989	10 08		bpl $8993	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.898b	a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.898d	05 20		ora $20		                ora status
.898f	85 20		sta $20		                sta status
.8991	80 18		bra $89ab	                bra _process_name
.8993					_redefined_name:
.8993	a9 02		lda #$02	                lda #str_redefined
.8995	20 80 d8	jsr $d880	                jsr print_string_no_lf
.8998	20 b8 a3	jsr $a3b8	                jsr xt_two_dup           ; ( addr u addr u )
.899b	20 03 a5	jsr $a503	                jsr xt_type
.899e	20 1e a1	jsr $a11e	                jsr xt_space
.89a1	80 08		bra $89ab	                bra _process_name
.89a3					_new_name:
.89a3	e8		inx		                inx                     ; Drop flag (0) from find-name.
.89a4	e8		inx		                inx
.89a5	a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.89a7	25 20		and $20		                and status
.89a9	85 20		sta $20		                sta status
.89ab					_process_name:
.89ab	b5 00		lda $00,x	                lda 0,x
.89ad	85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.89af	a5 00		lda $00		                lda cp
.89b1	85 24		sta $24		                sta tmp1
.89b3	a5 01		lda $01		                lda cp+1
.89b5	85 25		sta $25		                sta tmp1+1
.89b7	b5 00		lda $00,x	                lda 0,x
.89b9	18		clc		                clc
.89ba	69 08		adc #$08	                adc #8
.89bc	85 28		sta $28		                sta tmp3                ; total header length
.89be	18		clc		                clc
.89bf	69 03		adc #$03	                adc #3
.89c1	95 00		sta $00,x	                sta 0,x
.89c3	74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.89c5	20 ab 82	jsr $82ab	                jsr xt_allot    ; ( addr )
.89c8	20 86 d7	jsr $d786	                jsr current_to_dp
.89cb	a0 00		ldy #$00	                ldy #0
.89cd	a5 26		lda $26		                lda tmp2
.89cf	91 24		sta ($24),y	                sta (tmp1),y
.89d1	a9 08		lda #$08	                lda #NN
.89d3	09 20		ora #$20	                ora #HC
.89d5	c8		iny		                iny
.89d6	91 24		sta ($24),y	                sta (tmp1),y
.89d8	c8		iny		                iny
.89d9	a5 02		lda $02		                lda dp
.89db	91 24		sta ($24),y	                sta (tmp1),y
.89dd	c8		iny		                iny
.89de	a5 03		lda $03		                lda dp+1
.89e0	91 24		sta ($24),y	                sta (tmp1),y
.89e2	c8		iny		                iny
.89e3	a5 25		lda $25		                lda tmp1+1
.89e5	85 03		sta $03		                sta dp+1
.89e7	a5 24		lda $24		                lda tmp1
.89e9	85 02		sta $02		                sta dp
.89eb	18		clc		                clc
.89ec	65 28		adc $28		                adc tmp3        ; add total header length
.89ee	91 24		sta ($24),y	                sta (tmp1),y
.89f0	48		pha		                pha             ; we need this in the next step
.89f1	c8		iny		                iny
.89f2	a5 25		lda $25		                lda tmp1+1
.89f4	69 00		adc #$00	                adc #0          ; only need the carry
.89f6	91 24		sta ($24),y	                sta (tmp1),y
.89f8	c8		iny		                iny
.89f9	68		pla		                pla             ; LSB of "z_" address
.89fa	18		clc		                clc
.89fb	69 03		adc #$03	                adc #3
.89fd	91 24		sta ($24),y	                sta (tmp1),y
.89ff	88		dey		                dey             ; get the MSB of xt back
.8a00	b1 24		lda ($24),y	                lda (tmp1),y
.8a02	69 00		adc #$00	                adc #0          ; only need the carry
.8a04	c8		iny		                iny
.8a05	c8		iny		                iny
.8a06	91 24		sta ($24),y	                sta (tmp1),y
.8a08	c8		iny		                iny
.8a09	b5 00		lda $00,x	                lda 0,x
.8a0b	38		sec		                sec
.8a0c	e9 08		sbc #$08	                sbc #8
.8a0e	85 2c		sta $2c		                sta tmptos
.8a10	b5 01		lda $01,x	                lda 1,x
.8a12	e9 00		sbc #$00	                sbc #0          ; only need carry
.8a14	85 2d		sta $2d		                sta tmptos+1
.8a16					_name_loop:
.8a16	b1 2c		lda ($2c),y	                lda (tmptos),y
.8a18	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.8a1a	b0 07		bcs $8a23	                bcs _store_name
.8a1c	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.8a1e	90 03		bcc $8a23	                bcc _store_name
.8a20	18		clc		                clc
.8a21	69 20		adc #$20	                adc #$20
.8a23					_store_name:
.8a23	91 24		sta ($24),y	                sta (tmp1),y
.8a25	c8		iny		                iny
.8a26	c6 26		dec $26		                dec tmp2
.8a28	d0 ec		bne $8a16	                bne _name_loop
.8a2a	a9 20		lda #$20	                lda #$20        ; opcode of JSR
.8a2c	91 24		sta ($24),y	                sta (tmp1),y
.8a2e	c8		iny		                iny
.8a2f	a9 46		lda #$46	                lda #<dovar
.8a31	91 24		sta ($24),y	                sta (tmp1),y
.8a33	c8		iny		                iny
.8a34	a9 d7		lda #$d7	                lda #>dovar
.8a36	91 24		sta ($24),y	                sta (tmp1),y
.8a38	20 99 d7	jsr $d799	                jsr dp_to_current
.8a3b	e8		inx		                inx
.8a3c	e8		inx		                inx
.8a3d	60		rts		z_create:       rts
.8a3e					xt_d_minus:
.8a3e	20 53 d8	jsr $d853	                jsr underflow_4 ; two double numbers
.8a41	38		sec		                sec
.8a42	b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a44	f5 02		sbc $02,x	                sbc 2,x
.8a46	95 06		sta $06,x	                sta 6,x
.8a48	b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a4a	f5 03		sbc $03,x	                sbc 3,x
.8a4c	95 07		sta $07,x	                sta 7,x
.8a4e	b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a50	f5 00		sbc $00,x	                sbc 0,x
.8a52	95 04		sta $04,x	                sta 4,x
.8a54	b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a56	f5 01		sbc $01,x	                sbc 1,x
.8a58	95 05		sta $05,x	                sta 5,x
.8a5a	e8		inx		                inx
.8a5b	e8		inx		                inx
.8a5c	e8		inx		                inx
.8a5d	e8		inx		                inx
.8a5e	60		rts		z_d_minus:      rts
.8a5f					xt_d_plus:
.8a5f	20 53 d8	jsr $d853	                jsr underflow_4 ; two double numbers
.8a62	18		clc		                clc
.8a63	b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a65	75 06		adc $06,x	                adc 6,x
.8a67	95 06		sta $06,x	                sta 6,x
.8a69	b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a6b	75 07		adc $07,x	                adc 7,x
.8a6d	95 07		sta $07,x	                sta 7,x
.8a6f	b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a71	75 04		adc $04,x	                adc 4,x
.8a73	95 04		sta $04,x	                sta 4,x
.8a75	b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a77	75 05		adc $05,x	                adc 5,x
.8a79	95 05		sta $05,x	                sta 5,x
.8a7b	e8		inx		                inx
.8a7c	e8		inx		                inx
.8a7d	e8		inx		                inx
.8a7e	e8		inx		                inx
.8a7f	60		rts		z_d_plus:       rts
.8a80					xt_d_to_s:
.8a80	20 49 d8	jsr $d849	                jsr underflow_2
.8a83	e8		inx		                inx
.8a84	e8		inx		                inx
.8a85	60		rts		z_d_to_s:       rts
.8a86					xt_dabs:
.8a86	20 49 d8	jsr $d849	                jsr underflow_2 ; double number
.8a89	b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a8b	10 17		bpl $8aa4	                bpl _done       ; positive, we get off light
.8a8d	a0 00		ldy #$00	                ldy #0
.8a8f	38		sec		                sec
.8a90	98		tya		                tya
.8a91	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a93	95 02		sta $02,x	                sta 2,x
.8a95	98		tya		                tya
.8a96	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a98	95 03		sta $03,x	                sta 3,x
.8a9a	98		tya		                tya
.8a9b	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a9d	95 00		sta $00,x	                sta 0,x
.8a9f	98		tya		                tya
.8aa0	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8aa2	95 01		sta $01,x	                sta 1,x
.8aa4					_done:
.8aa4	60		rts		z_dabs:         rts
.8aa5					xt_decimal:
.8aa5	a9 0a		lda #$0a	                lda #10
.8aa7	85 18		sta $18		                sta base
.8aa9	64 19		stz $19		                stz base+1              ; paranoid
.8aab	60		rts		z_decimal:      rts
.8aac					xt_defer:
.8aac	20 69 89	jsr $8969	                jsr xt_create
.8aaf	a5 00		lda $00		                lda cp          ; LSB
.8ab1	38		sec		                sec
.8ab2	e9 02		sbc #$02	                sbc #2
.8ab4	85 24		sta $24		                sta tmp1
.8ab6	a5 01		lda $01		                lda cp+1        ; MSB
.8ab8	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8aba	85 25		sta $25		                sta tmp1+1
.8abc	a0 00		ldy #$00	                ldy #0
.8abe	a9 14		lda #$14	                lda #<dodefer   ; LSB
.8ac0	91 24		sta ($24),y	                sta (tmp1),y
.8ac2	c8		iny		                iny
.8ac3	a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8ac5	91 24		sta ($24),y	                sta (tmp1),y
.8ac7	a9 28		lda #$28	                lda #<defer_error
.8ac9	92 00		sta ($00)	                sta (cp)
.8acb	e6 00		inc $00		                inc cp
.8acd	d0 02		bne $8ad1	                bne +
.8acf	e6 01		inc $01		                inc cp+1
.8ad1					+
.8ad1	a9 d7		lda #$d7	                lda #>defer_error
.8ad3	92 00		sta ($00)	                sta (cp)
.8ad5	e6 00		inc $00		                inc cp
.8ad7	d0 02		bne $8adb	                bne +
.8ad9	e6 01		inc $01		                inc cp+1
.8adb					+
.8adb	20 31 89	jsr $8931	                jsr adjust_z    ; adjust header to correct length
.8ade	60		rts		z_defer:        rts
.8adf					xt_defer_fetch:
.8adf	20 8d a2	jsr $a28d	                jsr xt_to_body
.8ae2	20 80 8f	jsr $8f80	                jsr xt_fetch
.8ae5	60		rts		z_defer_fetch:  rts
.8ae6					xt_defer_store:
.8ae6	20 8d a2	jsr $a28d	                jsr xt_to_body
.8ae9	20 8d a1	jsr $a18d	                jsr xt_store
.8aec	60		rts		z_defer_store:  rts
.8aed					xt_definitions:
.8aed	a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8aef	b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8af1	a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8af3	91 1e		sta ($1e),y	                sta (up),y
.8af5	60		rts		z_definitions:  rts
.8af6					xt_depth:
.8af6	a9 78		lda #$78	                lda #dsp0
.8af8	86 2a		stx $2a		                stx tmpdsp
.8afa	38		sec		                sec
.8afb	e5 2a		sbc $2a		                sbc tmpdsp
.8afd	4a		lsr a		                lsr
.8afe	ca		dex		                dex
.8aff	ca		dex		                dex
.8b00	95 00		sta $00,x	                sta 0,x
.8b02	74 01		stz $01,x	                stz 1,x
.8b04	60		rts		z_depth:        rts
.8b05					xt_digit_question:
.8b05	20 44 d8	jsr $d844	                jsr underflow_1
.8b08	ca		dex		                dex
.8b09	ca		dex		                dex
.8b0a	74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8b0c	74 01		stz $01,x	                stz 1,x
.8b0e	74 03		stz $03,x	                stz 3,x                 ; paranoid
.8b10	b5 02		lda $02,x	                lda 2,x
.8b12	c9 30		cmp #$30	                cmp #'0'
.8b14	90 23		bcc $8b39	                bcc _done               ; failure flag already set
.8b16	c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8b18	90 12		bcc $8b2c	                bcc _checkbase
.8b1a	c9 41		cmp #$41	                cmp #'A'
.8b1c	90 1b		bcc $8b39	                bcc _done               ; failure flag is already set
.8b1e	c9 61		cmp #$61	                cmp #'a'
.8b20	90 07		bcc $8b29	                bcc _case_done          ; not lower case, too low
.8b22	c9 7b		cmp #$7b	                cmp #'z'+1
.8b24	b0 03		bcs $8b29	                bcs _case_done          ; not lower case, too high
.8b26	18		clc		                clc                     ; just right
.8b27	69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8b29					_case_done:
.8b29	38		sec		                sec
.8b2a	e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8b2c					_checkbase:
.8b2c	38		sec		                sec
.8b2d	e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8b2f	c5 18		cmp $18		                cmp base
.8b31	b0 06		bcs $8b39	                bcs _done               ; already have false flag
.8b33	95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8b35	d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8b37	d6 01		dec $01,x	                dec 1,x
.8b39					_done:
.8b39					z_digit_question:
.8b39	60		rts		                rts
.8b3a					xt_disasm:
.8b3a	20 49 d8	jsr $d849	                jsr underflow_2
.8b3d	20 d7 ac	jsr $acd7	                jsr disassembler
.8b40	60		rts		z_disasm:       rts
.8b41					xt_dnegate:
.8b41	20 49 d8	jsr $d849	                jsr underflow_2 ; double number
.8b44	a0 00		ldy #$00	     		ldy #0
.8b46	38		sec		                sec
.8b47	98		tya		                tya
.8b48	f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b4a	95 02		sta $02,x	                sta 2,x
.8b4c	98		tya		                tya
.8b4d	f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b4f	95 03		sta $03,x	                sta 3,x
.8b51	98		tya		                tya
.8b52	f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b54	95 00		sta $00,x	                sta 0,x
.8b56	98		tya		                tya
.8b57	f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b59	95 01		sta $01,x	                sta 1,x
.8b5b	60		rts		z_dnegate:      rts
.8b5c					xt_question_do:
.8b5c	a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b5e	85 24		sta $24		                sta tmp1
.8b60	80 02		bra $8b64	                bra do_common           ; skip flag for DO
.8b62					xt_do:
.8b62	64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b64					do_common:
.8b64	ca		dex		                dex
.8b65	ca		dex		                dex
.8b66	a5 00		lda $00		                lda cp
.8b68	95 00		sta $00,x	                sta 0,x                 ; LSB
.8b6a	a5 01		lda $01		                lda cp+1
.8b6c	95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b6e	a9 05		lda #$05	                lda #5                  ; we don't really care about the value,
.8b70	a8		tay		                tay                     ; so we use 5 to be tricky
.8b71					_loop:
.8b71	91 00		sta ($00),y	                sta (CP),y
.8b73	88		dey		                dey
.8b74	10 fb		bpl $8b71	                bpl _loop
.8b76	1a		inc a		                ina             ; we used 5 as a dummy value, this is why
.8b77	18		clc		                clc
.8b78	65 00		adc $00		                adc CP
.8b7a	85 00		sta $00		                sta CP
.8b7c	90 02		bcc $8b80	                bcc +
.8b7e	e6 01		inc $01		                inc CP+1
.8b80					+
.8b80	a5 24		lda $24		                lda tmp1
.8b82	f0 17		beq $8b9b	                beq _compile_do
.8b84	a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b86	5a		phy		                phy             ; save counter to calculate new CP
.8b87					-
.8b87	b9 e1 8b	lda $8be1,y	                lda question_do_runtime,y
.8b8a	91 00		sta ($00),y	                sta (cp),y
.8b8c	88		dey		                dey
.8b8d	10 f8		bpl $8b87	                bpl -
.8b8f	68		pla		                pla             ; retrieve counter
.8b90	18		clc		                clc
.8b91	65 00		adc $00		                adc cp
.8b93	85 00		sta $00		                sta cp
.8b95	a5 01		lda $01		                lda cp+1
.8b97	69 00		adc #$00	                adc #0          ; only care about carry
.8b99	85 01		sta $01		                sta cp+1        ; fall through to _compile_do
.8b9b					_compile_do:
.8b9b	a0 24		ldy #$24	                ldy #do_runtime_end-do_runtime  ; counter
.8b9d	5a		phy		                phy             ; save counter to calculate new CP
.8b9e					-
.8b9e	b9 bd 8b	lda $8bbd,y	                lda do_runtime,y
.8ba1	91 00		sta ($00),y	                sta (cp),y
.8ba3	88		dey		                dey
.8ba4	10 f8		bpl $8b9e	                bpl -
.8ba6	68		pla		                pla             ; retrieve counter
.8ba7	18		clc		                clc
.8ba8	65 00		adc $00		                adc cp
.8baa	85 00		sta $00		                sta cp
.8bac	a5 01		lda $01		                lda cp+1
.8bae	69 00		adc #$00	                adc #0          ; only care about carry
.8bb0	85 01		sta $01		                sta cp+1
.8bb2	ca		dex		                dex
.8bb3	ca		dex		                dex
.8bb4	a5 00		lda $00		                lda CP          ; LSB
.8bb6	95 00		sta $00,x	                sta 0,x
.8bb8	a5 01		lda $01		                lda CP+1        ; MSB
.8bba	95 01		sta $01,x	                sta 1,x
.8bbc					z_question_do:
.8bbc	60		rts		z_do:           rts
.8bbd					do_runtime:
.8bbd	38		sec		                sec
.8bbe	a9 00		lda #$00	                lda #0
.8bc0	f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8bc2	95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8bc4	a9 80		lda #$80	                lda #$80
.8bc6	f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8bc8	95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8bca	48		pha		                pha             ; FUFA replaces limit on R stack
.8bcb	b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8bcd	48		pha		                pha
.8bce	18		clc		                clc
.8bcf	b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8bd1	75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8bd3	95 00		sta $00,x	                sta 0,x
.8bd5	b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8bd7	75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8bd9	48		pha		                pha
.8bda	b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8bdc	48		pha		                pha
.8bdd	e8		inx		                inx
.8bde	e8		inx		                inx
.8bdf	e8		inx		                inx
.8be0	e8		inx		                inx             ; no RTS because this is copied into code
.8be1					do_runtime_end:
.8be1					question_do_runtime:
.8be1	20 b8 a3	jsr $a3b8	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8be4	20 ce 8e	jsr $8ece	                jsr xt_equal            ; ( -- n1 n2 f )
.8be7	b5 00		lda $00,x	                lda 0,x
.8be9	15 01		ora $01,x	                ora 1,x
.8beb	f0 06		beq $8bf3	                beq _do_do
.8bed	8a		txa		                txa
.8bee	18		clc		                clc
.8bef	69 06		adc #$06	                adc #6
.8bf1	aa		tax		                tax
.8bf2	60		rts		                rts
.8bf3					_do_do:
.8bf3	e8		inx		                inx             ; clear flag from EQUAL off stack
.8bf4	e8		inx		                inx             ; no RTS because this is copied into code
.8bf5					question_do_runtime_end:
.8bf5					xt_does:
.8bf5	a0 8c		ldy #$8c	                ldy #>does_runtime
.8bf7	a9 04		lda #$04	                lda #<does_runtime
.8bf9	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8bfc	a0 d7		ldy #$d7	                ldy #>dodoes
.8bfe	a9 2d		lda #$2d	                lda #<dodoes
.8c00	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8c03	60		rts		z_does:         rts
.8c04					does_runtime:
.8c04	7a		ply		                ply             ; LSB
.8c05	68		pla		                pla             ; MSB
.8c06	c8		iny		                iny
.8c07	d0 01		bne $8c0a	                bne +
.8c09	1a		inc a		                ina
.8c0a					+
.8c0a	84 24		sty $24		                sty tmp1
.8c0c	85 25		sta $25		                sta tmp1+1
.8c0e	20 86 d7	jsr $d786	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8c11	a5 02		lda $02		                lda dp
.8c13	18		clc		                clc
.8c14	69 04		adc #$04	                adc #4
.8c16	85 26		sta $26		                sta tmp2
.8c18	a5 03		lda $03		                lda dp+1
.8c1a	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c1c	85 27		sta $27		                sta tmp2+1
.8c1e	b2 26		lda ($26)	                lda (tmp2)
.8c20	18		clc		                clc
.8c21	69 01		adc #$01	                adc #1
.8c23	85 28		sta $28		                sta tmp3
.8c25	a0 01		ldy #$01	                ldy #1
.8c27	b1 26		lda ($26),y	                lda (tmp2),y
.8c29	69 00		adc #$00	                adc #0          ; we only care about the carry
.8c2b	85 29		sta $29		                sta tmp3+1
.8c2d	a5 24		lda $24		                lda tmp1        ; LSB
.8c2f	92 28		sta ($28)	                sta (tmp3)
.8c31	a5 25		lda $25		                lda tmp1+1
.8c33	91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8c35	60		rts		                rts
.8c36					xt_dot:
.8c36	20 44 d8	jsr $d844	                jsr underflow_1
.8c39	20 af 8d	jsr $8daf	                jsr xt_dup                      ; ( n n )
.8c3c	20 39 81	jsr $8139	                jsr xt_abs                      ; ( n u )
.8c3f	20 a8 a7	jsr $a7a8	                jsr xt_zero                     ; ( n u 0 )
.8c42	20 5a 93	jsr $935a	                jsr xt_less_number_sign         ; ( n u 0 )
.8c45	20 de 97	jsr $97de	                jsr xt_number_sign_s            ; ( n ud )
.8c48	20 57 9b	jsr $9b57	                jsr xt_rot                      ; ( ud n )
.8c4b	20 e7 9f	jsr $9fe7	                jsr xt_sign                     ; ( ud )
.8c4e	20 bc 97	jsr $97bc	                jsr xt_number_sign_greater      ; ( addr u )
.8c51	20 03 a5	jsr $a503	                jsr xt_type
.8c54	20 1e a1	jsr $a11e	                jsr xt_space
.8c57	60		rts		z_dot:          rts
.8c58					xt_dot_paren:
.8c58	ca		dex		                dex
.8c59	ca		dex		                dex
.8c5a	a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c5c	95 00		sta $00,x	                sta 0,x
.8c5e	74 01		stz $01,x	                stz 1,x
.8c60	20 3a 99	jsr $993a	                jsr xt_parse
.8c63	20 03 a5	jsr $a503	                jsr xt_type
.8c66	60		rts		z_dot_paren:    rts
.8c67					xt_dot_quote:
.8c67	20 4f 9d	jsr $9d4f	                jsr xt_s_quote
.8c6a	a0 a5		ldy #$a5	                ldy #>xt_type
.8c6c	a9 03		lda #$03	                lda #<xt_type
.8c6e	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8c71	60		rts		z_dot_quote:    rts
.8c72					xt_dot_r:
.8c72	20 49 d8	jsr $d849	                jsr underflow_2
.8c75	20 70 a3	jsr $a370	                jsr xt_to_r
.8c78	20 af 8d	jsr $8daf	                jsr xt_dup
.8c7b	20 39 81	jsr $8139	                jsr xt_abs
.8c7e	20 a8 a7	jsr $a7a8	                jsr xt_zero
.8c81	20 5a 93	jsr $935a	                jsr xt_less_number_sign
.8c84	20 de 97	jsr $97de	                jsr xt_number_sign_s
.8c87	20 57 9b	jsr $9b57	                jsr xt_rot
.8c8a	20 e7 9f	jsr $9fe7	                jsr xt_sign
.8c8d	20 bc 97	jsr $97bc	                jsr xt_number_sign_greater
.8c90	20 92 9a	jsr $9a92	                jsr xt_r_from
.8c93	20 93 98	jsr $9893	                jsr xt_over
.8c96	20 50 95	jsr $9550	                jsr xt_minus
.8c99	20 24 a1	jsr $a124	                jsr xt_spaces
.8c9c	20 03 a5	jsr $a503	                jsr xt_type
.8c9f	60		rts		z_dot_r:        rts
.8ca0					xt_dot_s:
.8ca0	20 f6 8a	jsr $8af6	                jsr xt_depth    ; ( -- u )
.8ca3	a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8ca5	20 f6 8d	jsr $8df6	                jsr emit_a
.8ca8	b5 00		lda $00,x	                lda 0,x
.8caa	48		pha		                pha
.8cab	ca		dex		                dex             ; DUP
.8cac	ca		dex		                dex
.8cad	95 00		sta $00,x	                sta 0,x
.8caf	74 01		stz $01,x	                stz 1,x
.8cb1	20 b1 d8	jsr $d8b1	                jsr print_u
.8cb4	a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8cb6	20 f6 8d	jsr $8df6	                jsr emit_a
.8cb9	a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8cbb	20 f6 8d	jsr $8df6	                jsr emit_a
.8cbe	e8		inx		                inx
.8cbf	e8		inx		                inx
.8cc0	e0 78		cpx #$78	                cpx #dsp0
.8cc2	f0 1e		beq $8ce2	                beq _done
.8cc4					_have_stack:
.8cc4	7a		ply		                ply
.8cc5	a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8cc7	85 28		sta $28		                sta tmp3
.8cc9	64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8ccb					_loop:
.8ccb	ca		dex		                dex
.8ccc	ca		dex		                dex
.8ccd	b2 28		lda ($28)	                lda (tmp3)
.8ccf	95 01		sta $01,x	                sta 1,x
.8cd1	c6 28		dec $28		                dec tmp3
.8cd3	b2 28		lda ($28)	                lda (tmp3)
.8cd5	95 00		sta $00,x	                sta 0,x
.8cd7	c6 28		dec $28		                dec tmp3
.8cd9	5a		phy		                phy
.8cda	20 36 8c	jsr $8c36	                jsr xt_dot
.8cdd	7a		ply		                ply
.8cde	88		dey		                dey
.8cdf	d0 ea		bne $8ccb	                bne _loop
.8ce1	48		pha		                pha             ; dummy to balance stack
.8ce2					_done:
.8ce2	68		pla		                pla
.8ce3	60		rts		z_dot_s:        rts
.8ce4					xt_d_dot:
.8ce4	20 49 d8	jsr $d849	                jsr underflow_2
.8ce7	20 8d a3	jsr $a38d	                jsr xt_tuck
.8cea	20 86 8a	jsr $8a86	                jsr xt_dabs
.8ced	20 5a 93	jsr $935a	                jsr xt_less_number_sign
.8cf0	20 de 97	jsr $97de	                jsr xt_number_sign_s
.8cf3	20 57 9b	jsr $9b57	                jsr xt_rot
.8cf6	20 e7 9f	jsr $9fe7	                jsr xt_sign
.8cf9	20 bc 97	jsr $97bc	                jsr xt_number_sign_greater
.8cfc	20 03 a5	jsr $a503	                jsr xt_type
.8cff	20 1e a1	jsr $a11e	                jsr xt_space
.8d02	60		rts		z_d_dot:        rts
.8d03					xt_d_dot_r:
.8d03	20 4e d8	jsr $d84e	                jsr underflow_3
.8d06	20 70 a3	jsr $a370	                jsr xt_to_r
.8d09	20 8d a3	jsr $a38d	                jsr xt_tuck
.8d0c	20 86 8a	jsr $8a86	                jsr xt_dabs
.8d0f	20 5a 93	jsr $935a	                jsr xt_less_number_sign
.8d12	20 de 97	jsr $97de	                jsr xt_number_sign_s
.8d15	20 57 9b	jsr $9b57	                jsr xt_rot
.8d18	20 e7 9f	jsr $9fe7	                jsr xt_sign
.8d1b	20 bc 97	jsr $97bc	                jsr xt_number_sign_greater
.8d1e	20 92 9a	jsr $9a92	                jsr xt_r_from
.8d21	20 93 98	jsr $9893	                jsr xt_over
.8d24	20 50 95	jsr $9550	                jsr xt_minus
.8d27	20 24 a1	jsr $a124	                jsr xt_spaces
.8d2a	20 03 a5	jsr $a503	                jsr xt_type
.8d2d	60		rts		z_d_dot_r:      rts
.8d2e					xt_drop:
.8d2e	20 44 d8	jsr $d844	                jsr underflow_1
.8d31	e8		inx		                inx
.8d32	e8		inx		                inx
.8d33	60		rts		z_drop:         rts
.8d34					xt_dump:
.8d34	20 49 d8	jsr $d849	                jsr underflow_2
.8d37					_row:
.8d37	a0 10		ldy #$10	                ldy #16
.8d39	64 26		stz $26		                stz tmp2
.8d3b	20 63 89	jsr $8963	                jsr xt_cr
.8d3e	b5 03		lda $03,x	                lda 3,x
.8d40	20 54 d7	jsr $d754	                jsr byte_to_ascii
.8d43	b5 02		lda $02,x	                lda 2,x
.8d45	20 54 d7	jsr $d754	                jsr byte_to_ascii
.8d48	20 1e a1	jsr $a11e	                jsr xt_space
.8d4b	20 1e a1	jsr $a11e	                jsr xt_space
.8d4e					_loop:
.8d4e	b5 00		lda $00,x	                lda 0,x
.8d50	15 01		ora $01,x	                ora 1,x
.8d52	f0 39		beq $8d8d	                beq _all_printed
.8d54	a1 02		lda ($02,x)	                lda (2,x)
.8d56	48		pha		                pha                     ; byte_to_ascii destroys A
.8d57	20 54 d7	jsr $d754	                jsr byte_to_ascii
.8d5a	20 1e a1	jsr $a11e	                jsr xt_space
.8d5d	68		pla		                pla
.8d5e	20 2a d8	jsr $d82a	                jsr is_printable
.8d61	b0 02		bcs $8d65	                bcs _printable
.8d63	a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d65					_printable:
.8d65	5a		phy		                phy                     ; save counter
.8d66	a4 26		ldy $26		                ldy tmp2
.8d68	91 00		sta ($00),y	                sta (cp),y
.8d6a	e6 26		inc $26		                inc tmp2
.8d6c	7a		ply		                ply
.8d6d	c0 09		cpy #$09	                cpy #9
.8d6f	d0 03		bne $8d74	                bne _next_char
.8d71	20 1e a1	jsr $a11e	                jsr xt_space
.8d74					_next_char:
.8d74	f6 02		inc $02,x	                inc 2,x
.8d76	d0 02		bne $8d7a	                bne _counter
.8d78	f6 03		inc $03,x	                inc 3,x
.8d7a					_counter:
.8d7a	b5 00		lda $00,x	                lda 0,x
.8d7c	d0 02		bne $8d80	                bne +
.8d7e	d6 01		dec $01,x	                dec 1,x
.8d80					+
.8d80	d6 00		dec $00,x	                dec 0,x
.8d82	88		dey		                dey
.8d83	d0 c9		bne $8d4e	                bne _loop               ; next byte
.8d85	20 1e a1	jsr $a11e	                jsr xt_space
.8d88	20 9b 8d	jsr $8d9b	                jsr dump_print_ascii
.8d8b	80 aa		bra $8d37	                bra _row                ; new row
.8d8d					_all_printed:
.8d8d	a5 26		lda $26		                lda tmp2
.8d8f	f0 06		beq $8d97	                beq _done
.8d91	20 1e a1	jsr $a11e	                jsr xt_space
.8d94	20 9b 8d	jsr $8d9b	                jsr dump_print_ascii
.8d97					_done:
.8d97	20 b0 a3	jsr $a3b0	                jsr xt_two_drop         ; one byte less than 4x INX
.8d9a	60		rts		z_dump:         rts
.8d9b					dump_print_ascii:
.8d9b	a0 00		ldy #$00	                ldy #0
.8d9d					_ascii_loop:
.8d9d	b1 00		lda ($00),y	                lda (cp),y
.8d9f	20 f6 8d	jsr $8df6	                jsr emit_a
.8da2	c8		iny		                iny
.8da3	c0 08		cpy #$08	                cpy #8
.8da5	d0 03		bne $8daa	                bne +
.8da7	20 1e a1	jsr $a11e	                jsr xt_space
.8daa					+
.8daa	c6 26		dec $26		                dec tmp2
.8dac	d0 ef		bne $8d9d	                bne _ascii_loop
.8dae	60		rts		                rts
.8daf					xt_dup:
.8daf	20 44 d8	jsr $d844	                jsr underflow_1
.8db2	ca		dex		                dex
.8db3	ca		dex		                dex
.8db4	b5 02		lda $02,x	                lda 2,x         ; LSB
.8db6	95 00		sta $00,x	                sta 0,x
.8db8	b5 03		lda $03,x	                lda 3,x         ; MSB
.8dba	95 01		sta $01,x	                sta 1,x
.8dbc	60		rts		z_dup:          rts
.8dbd					xt_ed:
.8dbd	20 82 b5	jsr $b582	                jsr ed6502      ; kept in separate file
.8dc0	60		rts		z_ed:           rts
.8dc1					xt_else:
.8dc1					xt_endof:
.8dc1	a0 8d		ldy #$8d	                ldy #>branch_runtime
.8dc3	a9 db		lda #$db	                lda #<branch_runtime
.8dc5	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8dc8	20 72 91	jsr $9172	                jsr xt_here
.8dcb	20 a8 a7	jsr $a7a8	                jsr xt_zero
.8dce	20 6e 87	jsr $876e	                jsr xt_comma
.8dd1	20 72 91	jsr $9172	                jsr xt_here
.8dd4	20 57 9b	jsr $9b57	                jsr xt_rot
.8dd7	20 8d a1	jsr $a18d	                jsr xt_store
.8dda					z_else:
.8dda					z_endof:
.8dda	60		rts		                rts
.8ddb					branch_runtime:
.8ddb	68		pla		                pla
.8ddc	85 22		sta $22		                sta tmpbranch
.8dde	68		pla		                pla
.8ddf	85 23		sta $23		                sta tmpbranch+1
.8de1	a0 01		ldy #$01	                ldy #1
.8de3	b1 22		lda ($22),y	                lda (tmpbranch),y  ; LSB
.8de5	85 24		sta $24		                sta tmp1
.8de7	c8		iny		                iny
.8de8	b1 22		lda ($22),y	                lda (tmpbranch),y  ; MSB
.8dea	85 25		sta $25		                sta tmp1+1
.8dec	6c 24 00	jmp ($0024)	                jmp (tmp1)
.8def					xt_emit:
.8def	20 44 d8	jsr $d844	                jsr underflow_1
.8df2	b5 00		lda $00,x	                lda 0,x
.8df4	e8		inx		                inx
.8df5	e8		inx		                inx
.8df6					emit_a:
.8df6	6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8df9					z_emit:
.8df9					xt_empty_buffers:
.8df9	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8dfb	a9 00		lda #$00	                lda #0
.8dfd	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8dff					z_empty_buffers:
.8dff	60		rts		                rts
.8e00					xt_endcase:
.8e00	a0 8d		ldy #$8d	                ldy #>xt_drop
.8e02	a9 2e		lda #$2e	                lda #<xt_drop
.8e04	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.8e07					_endcase_loop:
.8e07	b5 00		lda $00,x	                lda 0,x
.8e09	15 01		ora $01,x	                ora 1,x
.8e0b	f0 05		beq $8e12	                beq _done
.8e0d	20 c2 a1	jsr $a1c2	                jsr xt_then
.8e10	80 f5		bra $8e07	                bra _endcase_loop
.8e12					_done:
.8e12	e8		inx		                inx
.8e13	e8		inx		                inx
.8e14	60		rts		z_endcase:      rts
.8e15					xt_environment_q:
.8e15	20 44 d8	jsr $d844	                jsr underflow_1
.8e18	a0 00		ldy #$00	                ldy #00                 ; counter for table
.8e1a	5a		phy		                phy
.8e1b					_table_loop:
.8e1b	20 b8 a3	jsr $a3b8	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e1e	ca		dex		                dex
.8e1f	ca		dex		                dex                     ; ( addr u addr u ? )
.8e20	b9 92 8e	lda $8e92,y	                lda env_table_single,y
.8e23	95 00		sta $00,x	                sta 0,x
.8e25	c8		iny		                iny
.8e26	b9 92 8e	lda $8e92,y	                lda env_table_single,y
.8e29	95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e2b	c8		iny		                iny
.8e2c	15 00		ora $00,x	                ora 0,x
.8e2e	f0 4d		beq $8e7d	                beq _table_done
.8e30	5a		phy		                phy                     ; save Y, which is used by COUNT
.8e31	20 4f 89	jsr $894f	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e34	20 88 87	jsr $8788	                jsr xt_compare          ; ( addr u f )
.8e37	7a		ply		                ply
.8e38	b5 00		lda $00,x	                lda 0,x
.8e3a	15 01		ora $01,x	                ora 1,x
.8e3c	f0 04		beq $8e42	                beq _got_result
.8e3e	e8		inx		                inx                     ; DROP, now ( addr u )
.8e3f	e8		inx		                inx
.8e40	80 d9		bra $8e1b	                bra _table_loop
.8e42					_got_result:
.8e42	e8		inx		                inx                     ; drop flag, now ( addr u )
.8e43	e8		inx		                inx
.8e44	88		dey		                dey                     ; go back to index we had
.8e45	88		dey		                dey
.8e46	68		pla		                pla
.8e47	d0 0d		bne $8e56	                bne _double_result
.8e49	b9 b0 8e	lda $8eb0,y	                lda env_results_single,y
.8e4c	95 02		sta $02,x	                sta 2,x
.8e4e	c8		iny		                iny
.8e4f	b9 b0 8e	lda $8eb0,y	                lda env_results_single,y
.8e52	95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e54	80 1f		bra $8e75	                bra _set_flag
.8e56					_double_result:
.8e56	ca		dex		                dex                     ; ( addr u ? )
.8e57	ca		dex		                dex
.8e58	98		tya		                tya
.8e59	38		sec		                sec
.8e5a	e9 18		sbc #$18	                sbc #24
.8e5c	0a		asl a		                asl
.8e5d	a8		tay		                tay
.8e5e	b9 c6 8e	lda $8ec6,y	                lda env_results_double,y
.8e61	95 02		sta $02,x	                sta 2,x
.8e63	c8		iny		                iny
.8e64	b9 c6 8e	lda $8ec6,y	                lda env_results_double,y
.8e67	95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e69	c8		iny		                iny
.8e6a	b9 c6 8e	lda $8ec6,y	                lda env_results_double,y
.8e6d	95 04		sta $04,x	                sta 4,x
.8e6f	c8		iny		                iny
.8e70	b9 c6 8e	lda $8ec6,y	                lda env_results_double,y
.8e73	95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e75					_set_flag:
.8e75	a9 ff		lda #$ff	                lda #$ff
.8e77	95 00		sta $00,x	                sta 0,x
.8e79	95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e7b	80 14		bra $8e91	                bra _done
.8e7d					_table_done:
.8e7d	68		pla		                pla
.8e7e	d0 09		bne $8e89	                bne _no_match
.8e80	1a		inc a		                ina
.8e81	48		pha		                pha
.8e82	8a		txa		                txa
.8e83	18		clc		                clc
.8e84	69 06		adc #$06	                adc #6                  ; skip six bytes
.8e86	aa		tax		                tax                     ; ( addr u )
.8e87	80 92		bra $8e1b	                bra _table_loop
.8e89					_no_match:
.8e89	8a		txa		                txa
.8e8a	18		clc		                clc
.8e8b	69 0a		adc #$0a	                adc #10
.8e8d	aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e8e	20 79 8f	jsr $8f79	                jsr xt_false
.8e91					_done:
.8e91					z_environment_q:
.8e91	60		rts		                rts
.8e92					env_table_single:
>8e92	67 d6 77 d6 7d d6 82 d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e9a	94 d6
>8e9c	9c d6 a5 d6 ab d6 b1 d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8ea4	c4 d6 d0 d6 00 00		        .word envs_sc, envs_wl, 0000
.8eaa					env_table_double:
>8eaa	da d6 e0 d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.8eb0					env_results_single:
>8eb0	ff 7f				        .word $7FFF     ; /COUNTED-STRING
>8eb2	ff 00				        .word $00FF     ; /HOLD
>8eb4	54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8eb6	08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8eb8	00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8eba	ff 00				        .word $00FF     ; MAX-CHAR
>8ebc	ff 7f				        .word $7FFF     ; MAX-N
>8ebe	ff ff				        .word $FFFF     ; MAX-U
>8ec0	80 00				        .word $0080     ; RETURN-STACK-CELLS
>8ec2	20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8ec4	09 00				        .word $0009     ; WORDLISTS
.8ec6					env_results_double:
>8ec6	ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8eca	ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8ece					xt_equal:
.8ece	20 49 d8	jsr $d849	                jsr underflow_2
.8ed1	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8ed3	d5 02		cmp $02,x	                cmp 2,x
.8ed5	d0 0a		bne $8ee1	                bne _false
.8ed7	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8ed9	d5 03		cmp $03,x	                cmp 3,x
.8edb	d0 04		bne $8ee1	                bne _false
.8edd	a9 ff		lda #$ff	                lda #$ff
.8edf	80 02		bra $8ee3	                bra _done
.8ee1	a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8ee3	95 02		sta $02,x	_done:          sta 2,x
.8ee5	95 03		sta $03,x	                sta 3,x
.8ee7	e8		inx		                inx
.8ee8	e8		inx		                inx
.8ee9	60		rts		z_equal:        rts
.8eea					xt_blank:
.8eea	ca		dex		                dex
.8eeb	ca		dex		                dex
.8eec	a9 20		lda #$20	                lda #AscSP
.8eee	95 00		sta $00,x	                sta 0,x
.8ef0	74 01		stz $01,x	                stz 1,x
.8ef2	80 06		bra $8efa	                bra xt_fill     ; skip over code for ERASE
.8ef4					xt_erase:
.8ef4	ca		dex		                dex
.8ef5	ca		dex		                dex
.8ef6	74 00		stz $00,x	                stz 0,x
.8ef8	74 01		stz $01,x	                stz 1,x
.8efa					xt_fill:
.8efa	20 4e d8	jsr $d84e	                jsr underflow_3
.8efd	b5 04		lda $04,x	                lda 4,x         ; LSB
.8eff	85 24		sta $24		                sta tmp1
.8f01	b5 05		lda $05,x	                lda 5,x
.8f03	85 25		sta $25		                sta tmp1+1
.8f05	b5 02		lda $02,x	                lda 2,x
.8f07	85 26		sta $26		                sta tmp2
.8f09	b5 03		lda $03,x	                lda 3,x
.8f0b	85 27		sta $27		                sta tmp2+1
.8f0d	b5 00		lda $00,x	                lda 0,x
.8f0f	a8		tay		                tay
.8f10					_loop:
.8f10	a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8f12	c5 25		cmp $25		                cmp tmp1+1
.8f14	90 21		bcc $8f37	                bcc _done               ; RAM_END < TMP1, so leave
.8f16	d0 06		bne $8f1e	                bne _check_counter      ; RAM_END is not smaller and not equal
.8f18	a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8f1a	c5 24		cmp $24		                cmp tmp1
.8f1c	90 19		bcc $8f37	                bcc _done               ; RAM_END < TMP1, so leave
.8f1e					_check_counter:
.8f1e	a5 26		lda $26		                lda tmp2
.8f20	05 27		ora $27		                ora tmp2+1
.8f22	f0 13		beq $8f37	                beq _done
.8f24	98		tya		                tya
.8f25	92 24		sta ($24)	                sta (tmp1)
.8f27	a5 26		lda $26		                lda tmp2
.8f29	d0 02		bne $8f2d	                bne +
.8f2b	c6 27		dec $27		                dec tmp2+1
.8f2d	c6 26		dec $26		+               dec tmp2
.8f2f	e6 24		inc $24		                inc tmp1
.8f31	d0 dd		bne $8f10	                bne _loop
.8f33	e6 25		inc $25		                inc tmp1+1
.8f35	80 d9		bra $8f10	                bra _loop
.8f37					_done:
.8f37	8a		txa		                txa
.8f38	18		clc		                clc
.8f39	69 06		adc #$06	                adc #6
.8f3b	aa		tax		                tax
.8f3c					z_blank:
.8f3c					z_erase:
.8f3c	60		rts		z_fill:         rts
.8f3d					xt_execute:
.8f3d	20 44 d8	jsr $d844	                jsr underflow_1
.8f40	20 44 8f	jsr $8f44	                jsr doexecute   ; do not combine to JMP (native coding)
.8f43	60		rts		z_execute:      rts
.8f44					doexecute:
.8f44	b5 00		lda $00,x	                lda 0,x
.8f46	85 0e		sta $0e		                sta ip
.8f48	b5 01		lda $01,x	                lda 1,x
.8f4a	85 0f		sta $0f		                sta ip+1
.8f4c	e8		inx		                inx
.8f4d	e8		inx		                inx
.8f4e	6c 0e 00	jmp ($000e)	                jmp (ip)
.8f51					xt_execute_parsing:
.8f51	20 4e d8	jsr $d84e	                jsr underflow_3
.8f54	20 62 92	jsr $9262	                jsr xt_input_to_r       ; save normal input for later
.8f57	20 6e 96	jsr $966e	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f5a	b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f5c	85 0a		sta $0a		                sta ciblen
.8f5e	b5 01		lda $01,x	                lda 1,x
.8f60	85 0b		sta $0b		                sta ciblen+1
.8f62	b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f64	85 08		sta $08		                sta cib
.8f66	b5 03		lda $03,x	                lda 3,x
.8f68	85 09		sta $09		                sta cib+1
.8f6a	64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f6c	64 0d		stz $0d		                stz toin+1
.8f6e	20 b0 a3	jsr $a3b0	                jsr xt_two_drop         ; 2DROP ( xt )
.8f71	20 3d 8f	jsr $8f3d	                jsr xt_execute
.8f74	20 a3 9a	jsr $9aa3	                jsr xt_r_to_input
.8f77					z_execute_parsing:
.8f77	60		rts		                rts
.8f78					xt_exit:
.8f78	60		rts		                rts             ; keep before z_exit
.8f79					z_exit:
.8f79					xt_false:
.8f79	ca		dex		                dex
.8f7a	ca		dex		                dex
.8f7b	74 00		stz $00,x	                stz 0,x
.8f7d	74 01		stz $01,x	                stz 1,x
.8f7f	60		rts		z_false:        rts
.8f80					xt_fetch:
.8f80	20 44 d8	jsr $d844	                jsr underflow_1
.8f83	a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f85	a8		tay		                tay
.8f86	f6 00		inc $00,x	                inc 0,x
.8f88	d0 02		bne $8f8c	                bne +
.8f8a	f6 01		inc $01,x	                inc 1,x
.8f8c					+
.8f8c	a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f8e	95 01		sta $01,x	                sta 1,x
.8f90	94 00		sty $00,x	                sty 0,x
.8f92	60		rts		z_fetch:        rts
.8f93					xt_find:
.8f93	20 44 d8	jsr $d844	                jsr underflow_1
.8f96	b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f98	48		pha		                pha
.8f99	b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f9b	48		pha		                pha
.8f9c	20 4f 89	jsr $894f	                jsr xt_count            ; ( caddr -- addr u )
.8f9f	20 db 8f	jsr $8fdb	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8fa2	b5 00		lda $00,x	                lda 0,x
.8fa4	15 01		ora $01,x	                ora 1,x
.8fa6	d0 0b		bne $8fb3	                bne _found_word
.8fa8	20 79 8f	jsr $8f79	                jsr xt_false            ; ( 0 0 )
.8fab	68		pla		                pla                     ; LSB of address
.8fac	95 02		sta $02,x	                sta 2,x
.8fae	68		pla		                pla
.8faf	95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8fb1	80 27		bra $8fda	                bra _done               ; ( addr 0 )
.8fb3					_found_word:
.8fb3	68		pla		                pla
.8fb4	68		pla		                pla
.8fb5	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( nt nt )
.8fb8	20 e1 95	jsr $95e1	                jsr xt_name_to_int      ; ( nt xt )
.8fbb	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( xt nt )
.8fbe	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fc0	f6 00		inc $00,x	                inc 0,x
.8fc2	d0 02		bne $8fc6	                bne +
.8fc4	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fc6					+
.8fc6	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fc8	29 04		and #$04	                and #IM
.8fca	d0 08		bne $8fd4	                bne _immediate          ; bit set, we're immediate
.8fcc	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fce	95 00		sta $00,x	                sta 0,x
.8fd0	95 01		sta $01,x	                sta 1,x
.8fd2	80 06		bra $8fda	                bra _done
.8fd4					_immediate:
.8fd4	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fd6	95 00		sta $00,x	                sta 0,x
.8fd8	74 01		stz $01,x	                stz 1,x
.8fda					_done:
.8fda	60		rts		z_find:         rts
.8fdb					xt_find_name:
.8fdb	20 49 d8	jsr $d849	                jsr underflow_2
.8fde	b5 00		lda $00,x	                lda 0,x
.8fe0	15 01		ora $01,x	                ora 1,x
.8fe2	d0 03		bne $8fe7	                bne _nonempty
.8fe4	4c 80 90	jmp $9080	                jmp _fail_done
.8fe7					_nonempty:
.8fe7	64 28		stz $28		                stz tmp3                ; Start at the beginning
.8fe9					_wordlist_loop:
.8fe9	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8feb	a5 28		lda $28		                lda tmp3
.8fed	d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fef	d0 03		bne $8ff4	                bne _have_string
.8ff1	4c 80 90	jmp $9080	                jmp _fail_done
.8ff4					_have_string:
.8ff4	18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8ff5	69 1f		adc #$1f	                adc #search_order_offset
.8ff7	a8		tay		                tay
.8ff8	b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8ffa	0a		asl a		                asl                     ; Turn offset into cells offset.
.8ffb	18		clc		                clc
.8ffc	69 06		adc #$06	                adc #wordlists_offset
.8ffe	a8		tay		                tay
.8fff	b1 1e		lda ($1e),y	                lda (up),y
.9001	85 24		sta $24		                sta tmp1
.9003	c8		iny		                iny
.9004	b1 1e		lda ($1e),y	                lda (up),y
.9006	85 25		sta $25		                sta tmp1+1
.9008	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.900a	85 26		sta $26		                sta tmp2
.900c	b5 03		lda $03,x	                lda 3,x
.900e	85 27		sta $27		                sta tmp2+1
.9010					_loop:
.9010	b2 24		lda ($24)	                lda (tmp1)
.9012	d5 00		cmp $00,x	                cmp 0,x
.9014	d0 54		bne $906a	                bne _next_entry
.9016					_compare_string:
.9016	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9018	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.901a	b0 07		bcs $9023	                bcs _compare_first
.901c	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.901e	90 03		bcc $9023	                bcc _compare_first
.9020	18		clc		                clc
.9021	69 20		adc #$20	                adc #$20
.9023					_compare_first:
.9023	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9025	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9027	d0 41		bne $906a	                bne _next_entry
.9029	b5 00		lda $00,x	                lda 0,x
.902b	3a		dec a		                dea
.902c	f0 2c		beq $905a	                beq _success
.902e	a5 24		lda $24		                lda tmp1
.9030	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9031	18		clc		                clc
.9032	69 08		adc #$08	                adc #8
.9034	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9036	a5 25		lda $25		                lda tmp1+1
.9038	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9039	69 00		adc #$00	                adc #0          ; we only need the carry
.903b	85 25		sta $25		                sta tmp1+1
.903d	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.903f	88		dey		                dey
.9040					_string_loop:
.9040	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9042	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9044	b0 07		bcs $904d	                bcs _check_char
.9046	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9048	90 03		bcc $904d	                bcc _check_char
.904a	18		clc		                clc
.904b	69 20		adc #$20	                adc #$20
.904d					_check_char:
.904d	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.904f	d0 13		bne $9064	                bne _next_entry_tmp1
.9051	88		dey		                dey
.9052	d0 ec		bne $9040	                bne _string_loop
.9054					_success_tmp1:
.9054	68		pla		                pla             ; Restore tmp1 from the return stack.
.9055	85 25		sta $25		                sta tmp1+1
.9057	68		pla		                pla
.9058	85 24		sta $24		                sta tmp1
.905a					_success:
.905a	a5 24		lda $24		                lda tmp1
.905c	95 02		sta $02,x	                sta 2,x
.905e	a5 25		lda $25		                lda tmp1+1
.9060	95 03		sta $03,x	                sta 3,x
.9062	80 20		bra $9084	                bra _done
.9064					_next_entry_tmp1:
.9064	68		pla		                pla             ; Restore tmp1 from the return stack.
.9065	85 25		sta $25		                sta tmp1+1
.9067	68		pla		                pla
.9068	85 24		sta $24		                sta tmp1
.906a					_next_entry:
.906a	a0 02		ldy #$02	                ldy #2
.906c	b1 24		lda ($24),y	                lda (tmp1),y
.906e	48		pha		                pha
.906f	c8		iny		                iny
.9070	b1 24		lda ($24),y	                lda (tmp1),y
.9072	85 25		sta $25		                sta tmp1+1
.9074	68		pla		                pla
.9075	85 24		sta $24		                sta tmp1
.9077	05 25		ora $25		                ora tmp1+1
.9079	d0 95		bne $9010	                bne _loop
.907b	e6 28		inc $28		                inc tmp3
.907d	4c e9 8f	jmp $8fe9	                jmp _wordlist_loop
.9080					_fail_done:
.9080	74 02		stz $02,x	                stz 2,x         ; failure flag
.9082	74 03		stz $03,x	                stz 3,x
.9084					_done:
.9084	e8		inx		                inx
.9085	e8		inx		                inx
.9086	60		rts		z_find_name:    rts
.9087					xt_flush:
.9087	20 be 9e	jsr $9ebe	                jsr xt_save_buffers
.908a	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.908c	a9 00		lda #$00	                lda #0
.908e	91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9090					z_flush:
.9090	60		rts		                rts
.9091					xt_fm_slash_mod:
.9091	20 4e d8	jsr $d84e	                jsr underflow_3
.9094	64 26		stz $26		                stz tmp2        ; default: n is positive
.9096	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9098	10 0e		bpl $90a8	                bpl _check_d
.909a	e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.909c	20 23 96	jsr $9623	                jsr xt_negate   ; NEGATE
.909f	20 70 a3	jsr $a370	                jsr xt_to_r     ; >R
.90a2	20 41 8b	jsr $8b41	                jsr xt_dnegate  ; DNEGATE
.90a5	20 92 9a	jsr $9a92	                jsr xt_r_from   ; R>
.90a8					_check_d:
.90a8	b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.90aa	10 0d		bpl $90b9	                bpl _multiply
.90ac	18		clc		                clc
.90ad	b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.90af	75 02		adc $02,x	                adc 2,x         ; LSB of dh
.90b1	95 02		sta $02,x	                sta 2,x
.90b3	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.90b5	75 03		adc $03,x	                adc 3,x         ; MSB of dh
.90b7	95 03		sta $03,x	                sta 3,x
.90b9					_multiply:
.90b9	20 ba a5	jsr $a5ba	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90bc	a5 26		lda $26		                lda tmp2
.90be	f0 07		beq $90c7	                beq _done
.90c0	e8		inx		                inx             ; pretend that we SWAP
.90c1	e8		inx		                inx
.90c2	20 23 96	jsr $9623	                jsr xt_negate
.90c5	ca		dex		                dex
.90c6	ca		dex		                dex
.90c7					_done:
.90c7	60		rts		z_fm_slash_mod: rts
.90c8					xt_forth:
.90c8	a0 1f		ldy #$1f	                ldy #search_order_offset
.90ca	a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90cc	91 1e		sta ($1e),y	                sta (up),y
.90ce					z_forth:
.90ce	60		rts		                rts
.90cf					load_evaluate:
.90cf	a9 ff		lda #$ff	                lda #$FF
.90d1	85 24		sta $24		                sta tmp1
.90d3	80 11		bra $90e6	                bra load_evaluate_start
.90d5					xt_evaluate:
.90d5	20 49 d8	jsr $d849	                jsr underflow_2
.90d8	64 24		stz $24		                stz tmp1
.90da	b5 00		lda $00,x	                lda 0,x
.90dc	15 01		ora $01,x	                ora 1,x
.90de	d0 06		bne $90e6	                bne evaluate_got_work
.90e0	e8		inx		                inx
.90e1	e8		inx		                inx
.90e2	e8		inx		                inx
.90e3	e8		inx		                inx
.90e4	80 42		bra $9128	                bra evaluate_done
.90e6					load_evaluate_start:
.90e6					evaluate_got_work:
.90e6	a0 01		ldy #$01	                ldy #blk_offset+1
.90e8	b1 1e		lda ($1e),y	                lda (up),y
.90ea	48		pha		                pha
.90eb	88		dey		                dey
.90ec	b1 1e		lda ($1e),y	                lda (up),y
.90ee	48		pha		                pha
.90ef	a5 24		lda $24		                lda tmp1
.90f1	d0 05		bne $90f8	                bne _nozero
.90f3	91 1e		sta ($1e),y	                sta (up),y
.90f5	c8		iny		                iny
.90f6	91 1e		sta ($1e),y	                sta (up),y
.90f8					_nozero:
.90f8	20 62 92	jsr $9262	                jsr xt_input_to_r
.90fb	a9 ff		lda #$ff	                lda #$ff
.90fd	85 06		sta $06		                sta insrc
.90ff	85 07		sta $07		                sta insrc+1
.9101	64 0c		stz $0c		                stz toin
.9103	64 0d		stz $0d		                stz toin+1
.9105	b5 00		lda $00,x	                lda 0,x
.9107	85 0a		sta $0a		                sta ciblen
.9109	b5 01		lda $01,x	                lda 1,x
.910b	85 0b		sta $0b		                sta ciblen+1
.910d	b5 02		lda $02,x	                lda 2,x
.910f	85 08		sta $08		                sta cib
.9111	b5 03		lda $03,x	                lda 3,x
.9113	85 09		sta $09		                sta cib+1
.9115	e8		inx		                inx             ; A clean stack is a clean mind
.9116	e8		inx		                inx
.9117	e8		inx		                inx
.9118	e8		inx		                inx
.9119	20 ac d7	jsr $d7ac	                jsr interpret   ; ( -- )
.911c	20 a3 9a	jsr $9aa3	                jsr xt_r_to_input
.911f	a0 00		ldy #$00	                ldy #blk_offset
.9121	68		pla		                pla
.9122	91 1e		sta ($1e),y	                sta (up),y
.9124	c8		iny		                iny
.9125	68		pla		                pla
.9126	91 1e		sta ($1e),y	                sta (up),y
.9128					evaluate_done:
.9128	60		rts		z_evaluate:     rts
.9129					xt_get_current:
.9129	ca		dex		                dex
.912a	ca		dex		                dex
.912b	a0 04		ldy #$04	                ldy #current_offset
.912d	b1 1e		lda ($1e),y	                lda (up),y
.912f	95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.9131	74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.9133	60		rts		z_get_current:  rts
.9134					xt_get_order:
.9134	a0 1e		ldy #$1e	                ldy #num_order_offset
.9136	b1 1e		lda ($1e),y	                lda (up),y
.9138	85 24		sta $24		                sta tmp1
.913a	f0 16		beq $9152	                beq _done       ; If zero, there are no wordlists.
.913c					_loop:
.913c	c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.913e	a9 1f		lda #$1f	                lda #search_order_offset
.9140	18		clc		                clc
.9141	65 24		adc $24		                adc tmp1
.9143	a8		tay		                tay
.9144	ca		dex		                dex
.9145	ca		dex		                dex
.9146	b1 1e		lda ($1e),y	                lda (up),y
.9148	95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.914a	74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.914c	a9 00		lda #$00	                lda #0
.914e	c5 24		cmp $24		                cmp tmp1
.9150	d0 ea		bne $913c	                bne _loop
.9152					_done:
.9152	ca		dex		                dex
.9153	ca		dex		                dex
.9154	a0 1e		ldy #$1e	                ldy #num_order_offset
.9156	b1 1e		lda ($1e),y	                lda (up),y
.9158	95 00		sta $00,x	                sta 0,x
.915a	74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.915c	60		rts		z_get_order:    rts
.915d					xt_greater_than:
.915d	20 49 d8	jsr $d849	                jsr underflow_2
.9160	a0 00		ldy #$00	                ldy #0          ; default false
.9162	20 6b d7	jsr $d76b	                jsr compare_16bit
.9165	f0 03		beq $916a	                beq _false
.9167	10 01		bpl $916a	                bpl _false
.9169	88		dey		                dey
.916a					_false:
.916a	98		tya		                tya
.916b	e8		inx		                inx
.916c	e8		inx		                inx
.916d	95 00		sta $00,x	                sta 0,x
.916f	95 01		sta $01,x	                sta 1,x
.9171	60		rts		z_greater_than: rts
.9172					xt_here:
.9172					xt_asm_arrow:
.9172	ca		dex		                dex
.9173	ca		dex		                dex
.9174	a5 00		lda $00		                lda cp
.9176	95 00		sta $00,x	                sta 0,x
.9178	a5 01		lda $01		                lda cp+1
.917a	95 01		sta $01,x	                sta 1,x
.917c					z_asm_arrow:
.917c	60		rts		z_here:         rts
.917d					xt_hex:
.917d	a9 10		lda #$10	                lda #16
.917f	85 18		sta $18		                sta base
.9181	64 19		stz $19		                stz base+1              ; paranoid
.9183	60		rts		z_hex:          rts
.9184					xt_hexstore:
.9184	20 4e d8	jsr $d84e	                jsr underflow_3
.9187	20 af 8d	jsr $8daf	                jsr xt_dup              ; Save copy of original address
.918a	20 a2 a4	jsr $a4a2	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.918d					_loop:
.918d	b5 00		lda $00,x	                lda 0,x
.918f	15 01		ora $01,x	                ora 1,x
.9191	f0 36		beq $91c9	                beq _done
.9193	20 4c 86	jsr $864c	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9196	20 a2 a4	jsr $a4a2	                jsr xt_two_to_r
.9199	20 a8 a7	jsr $a7a8	                jsr xt_zero
.919c	20 a8 a7	jsr $a7a8	                jsr xt_zero
.919f	20 28 a4	jsr $a428	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.91a2	20 bd a2	jsr $a2bd	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.91a5	b5 00		lda $00,x	                lda 0,x
.91a7	15 01		ora $01,x	                ora 1,x
.91a9	d0 17		bne $91c2	                bne _have_chars_left
.91ab	20 b0 a3	jsr $a3b0	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.91ae	20 80 8a	jsr $8a80	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.91b1	20 7d 9a	jsr $9a7d	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.91b4	20 15 86	jsr $8615	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.91b7	20 92 9a	jsr $9a92	                jsr xt_r_from           ; R>
.91ba	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+
.91bd	20 70 a3	jsr $a370	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91c0	80 cb		bra $918d	                bra _loop
.91c2					_have_chars_left:
.91c2	8a		txa		                txa
.91c3	18		clc		                clc
.91c4	69 08		adc #$08	                adc #8
.91c6	aa		tax		                tax
.91c7	80 c4		bra $918d	                bra _loop
.91c9					_done:
.91c9	e8		inx		                inx
.91ca	e8		inx		                inx
.91cb	e8		inx		                inx
.91cc	e8		inx		                inx                     ; 2DROP
.91cd	20 28 a4	jsr $a428	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91d0	20 ae a1	jsr $a1ae	                jsr xt_swap
.91d3	20 50 95	jsr $9550	                jsr xt_minus            ; ( n )
.91d6	60		rts		z_hexstore:     rts
.91d7					xt_hold:
.91d7	20 44 d8	jsr $d844	                jsr underflow_1
.91da	a5 34		lda $34		                lda tohold
.91dc	d0 02		bne $91e0	                bne +
.91de	c6 35		dec $35		                dec tohold+1
.91e0					+
.91e0	c6 34		dec $34		                dec tohold
.91e2	b5 00		lda $00,x	                lda 0,x
.91e4	92 34		sta ($34)	                sta (tohold)
.91e6	e8		inx		                inx
.91e7	e8		inx		                inx
.91e8	60		rts		z_hold:         rts
.91e9					xt_i:
.91e9	ca		dex		                dex
.91ea	ca		dex		                dex
.91eb	86 2a		stx $2a		                stx tmpdsp
.91ed	ba		tsx		                tsx
.91ee	38		sec		                sec
.91ef	bd 01 01	lda $0101,x	                lda $0101,x     ; LSB
.91f2	fd 03 01	sbc $0103,x	                sbc $0103,x
.91f5	a8		tay		                tay
.91f6	bd 02 01	lda $0102,x	                lda $0102,x     ; MSB
.91f9	fd 04 01	sbc $0104,x	                sbc $0104,x
.91fc	a6 2a		ldx $2a		                ldx tmpdsp
.91fe	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.9200	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.9202	60		rts		z_i:            rts
.9203					xt_if:
.9203	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.9205	a9 14		lda #$14	                lda #<zero_branch_runtime
.9207	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.920a	20 72 91	jsr $9172	                jsr xt_here
.920d	20 a8 a7	jsr $a7a8	                jsr xt_zero
.9210	20 6e 87	jsr $876e	                jsr xt_comma
.9213	60		rts		z_if:           rts
.9214					zero_branch_runtime:
.9214	68		pla		                pla
.9215	85 22		sta $22		                sta tmpbranch
.9217	68		pla		                pla
.9218	85 23		sta $23		                sta tmpbranch+1
.921a	b5 00		lda $00,x	                lda 0,x
.921c	15 01		ora $01,x	                ora 1,x
.921e	f0 0f		beq $922f	                beq _zero
.9220	a5 22		lda $22		                lda tmpbranch   ; LSB
.9222	18		clc		                clc
.9223	69 02		adc #$02	                adc #2
.9225	85 24		sta $24		                sta tmp1
.9227	a5 23		lda $23		                lda tmpbranch+1 ; MSB
.9229	69 00		adc #$00	                adc #0          ; For carry
.922b	85 25		sta $25		                sta tmp1+1
.922d	80 13		bra $9242	                bra _done
.922f					_zero:
.922f	a0 01		ldy #$01	                ldy #1
.9231	b1 22		lda ($22),y	                lda (tmpbranch),y
.9233	85 24		sta $24		                sta tmp1
.9235	c8		iny		                iny
.9236	b1 22		lda ($22),y	                lda (tmpbranch),y
.9238	85 25		sta $25		                sta tmp1+1
.923a	a5 24		lda $24		                lda tmp1
.923c	d0 02		bne $9240	                bne +
.923e	c6 25		dec $25		                dec tmp1+1
.9240					+
.9240	c6 24		dec $24		                dec tmp1
.9242					_done:
.9242	a5 25		lda $25		                lda tmp1+1
.9244	48		pha		                pha             ; MSB first
.9245	a5 24		lda $24		                lda tmp1
.9247	48		pha		                pha
.9248	e8		inx		                inx
.9249	e8		inx		                inx
.924a	60		rts		                rts
.924b					xt_immediate:
.924b	20 86 d7	jsr $d786	                jsr current_to_dp
.924e	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9250	b1 02		lda ($02),y	                lda (dp),y
.9252	09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9254	91 02		sta ($02),y	                sta (dp),y
.9256	60		rts		z_immediate:    rts
.9257					xt_input:
.9257	ca		dex		                dex
.9258	ca		dex		                dex
.9259	a9 12		lda #$12	                lda #<input
.925b	95 00		sta $00,x	                sta 0,x
.925d	a9 00		lda #$00	                lda #>input
.925f	95 01		sta $01,x	                sta 1,x
.9261	60		rts		z_input:        rts
.9262					xt_input_to_r:
.9262	68		pla		                pla
.9263	85 24		sta $24		                sta tmp1
.9265	68		pla		                pla
.9266	85 25		sta $25		                sta tmp1+1
.9268	a0 07		ldy #$07	                ldy #7
.926a					_loop:
.926a	b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.926d	48		pha		                pha
.926e	88		dey		                dey
.926f	10 f9		bpl $926a	                bpl _loop
.9271	a5 25		lda $25		                lda tmp1+1
.9273	48		pha		                pha
.9274	a5 24		lda $24		                lda tmp1
.9276	48		pha		                pha
.9277	60		rts		z_input_to_r: 	rts
.9278					xt_int_to_name:
.9278	20 44 d8	jsr $d844	                jsr underflow_1
.927b	ca		dex		                dex
.927c	ca		dex		                dex
.927d	74 00		stz $00,x	                stz 0,x
.927f	74 01		stz $01,x	                stz 1,x
.9281					_wordlist_loop:
.9281	b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9283	0a		asl a		                asl                     ; Turn offset into cells offset.
.9284	18		clc		                clc
.9285	69 06		adc #$06	                adc #wordlists_offset
.9287	a8		tay		                tay
.9288	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.928a	85 26		sta $26		                sta tmp2                ; into tmp2
.928c	c8		iny		                iny
.928d	b1 1e		lda ($1e),y	                lda (up),y
.928f	85 27		sta $27		                sta tmp2+1
.9291	a5 26		lda $26		                lda tmp2
.9293	05 27		ora $27		                ora tmp2+1
.9295	f0 38		beq $92cf	                beq _next_wordlist
.9297	b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9299	85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.929b	b5 03		lda $03,x	                lda 3,x
.929d	85 29		sta $29		                sta tmp3+1
.929f					_loop:
.929f	a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.92a1	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.92a3	c5 28		cmp $28		                cmp tmp3
.92a5	d0 07		bne $92ae	                bne _no_match
.92a7	c8		iny		                iny
.92a8	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.92aa	c5 29		cmp $29		                cmp tmp3+1
.92ac	f0 32		beq $92e0	                beq _match
.92ae					_no_match:
.92ae	18		clc		                clc
.92af	a5 26		lda $26		                lda tmp2
.92b1	69 02		adc #$02	                adc #2
.92b3	85 26		sta $26		                sta tmp2
.92b5	a5 27		lda $27		                lda tmp2+1
.92b7	69 00		adc #$00	                adc #0          ; only care about carry
.92b9	85 27		sta $27		                sta tmp2+1
.92bb	a0 00		ldy #$00	                ldy #0
.92bd	b1 26		lda ($26),y	                lda (tmp2),y
.92bf	48		pha		                pha
.92c0	c8		iny		                iny
.92c1	11 26		ora ($26),y	                ora (tmp2),y
.92c3	f0 09		beq $92ce	                beq _zero
.92c5	b1 26		lda ($26),y	                lda (tmp2),y
.92c7	85 27		sta $27		                sta tmp2+1
.92c9	68		pla		                pla
.92ca	85 26		sta $26		                sta tmp2
.92cc	80 d1		bra $929f	                bra _loop
.92ce					_zero:
.92ce	68		pla		                pla             ; Leftover from above loop
.92cf					_next_wordlist:
.92cf	b5 00		lda $00,x	                lda 0,x
.92d1	1a		inc a		                ina
.92d2	95 00		sta $00,x	                sta 0,x
.92d4	c9 0c		cmp #$0c	                cmp #max_wordlists
.92d6	d0 a9		bne $9281	                bne _wordlist_loop
.92d8	e8		inx		                inx
.92d9	e8		inx		                inx
.92da	74 00		stz $00,x	                stz 0,x
.92dc	74 01		stz $01,x	                stz 1,x
.92de	80 0a		bra $92ea	                bra z_int_to_name
.92e0					_match:
.92e0	e8		inx		                inx
.92e1	e8		inx		                inx
.92e2	a5 26		lda $26		                lda tmp2
.92e4	95 00		sta $00,x	                sta 0,x
.92e6	a5 27		lda $27		                lda tmp2+1
.92e8	95 01		sta $01,x	                sta 1,x
.92ea	60		rts		z_int_to_name:  rts
.92eb					xt_invert:
.92eb	20 44 d8	jsr $d844	                jsr underflow_1
.92ee	a9 ff		lda #$ff	                lda #$FF
.92f0	55 00		eor $00,x	                eor 0,x         ; LSB
.92f2	95 00		sta $00,x	                sta 0,x
.92f4	a9 ff		lda #$ff	                lda #$FF
.92f6	55 01		eor $01,x	                eor 1,x         ; MSB
.92f8	95 01		sta $01,x	                sta 1,x
.92fa	60		rts		z_invert:       rts
.92fb					xt_is:
.92fb	a5 16		lda $16		                lda state
.92fd	05 17		ora $17		                ora state+1
.92ff	f0 0c		beq $930d	                beq _interpreting
.9301					_compiling:
.9301	20 9e 85	jsr $859e	                jsr xt_bracket_tick
.9304	a0 8a		ldy #$8a	                ldy #>xt_defer_store
.9306	a9 e6		lda #$e6	                lda #<xt_defer_store
.9308	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.930b	80 06		bra $9313	                bra _done
.930d					_interpreting:
.930d	20 11 a2	jsr $a211	                jsr xt_tick
.9310	20 e6 8a	jsr $8ae6	                jsr xt_defer_store
.9313					_done:
.9313	60		rts		z_is:           rts
.9314					xt_j:
.9314	ca		dex		                dex
.9315	ca		dex		                dex
.9316	86 2a		stx $2a		                stx tmpdsp
.9318	ba		tsx		                tsx
.9319	38		sec		                sec
.931a	bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.931d	fd 09 01	sbc $0109,x	                sbc $0109,x
.9320	a8		tay		                tay
.9321	bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.9324	fd 0a 01	sbc $010a,x	                sbc $010A,x
.9327	a6 2a		ldx $2a		                ldx tmpdsp
.9329	95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.932b	94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.932d	60		rts		z_j:            rts
.932e					xt_key:
.932e	20 38 93	jsr $9338	                jsr key_a               ; returns char in A
.9331	ca		dex		                dex
.9332	ca		dex		                dex
.9333	95 00		sta $00,x	                sta 0,x
.9335	74 01		stz $01,x	                stz 1,x
.9337	60		rts		z_key:          rts
.9338					key_a:
.9338	6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.933b					xt_latestnt:
.933b	ca		dex		                dex
.933c	ca		dex		                dex
.933d	20 86 d7	jsr $d786	                jsr current_to_dp
.9340	a5 02		lda $02		                lda dp
.9342	95 00		sta $00,x	                sta 0,x
.9344	a5 03		lda $03		                lda dp+1
.9346	95 01		sta $01,x	                sta 1,x
.9348	60		rts		z_latestnt:     rts
.9349					xt_latestxt:
.9349	20 3b 93	jsr $933b	                jsr xt_latestnt         ; ( nt )
.934c	20 e1 95	jsr $95e1	                jsr xt_name_to_int      ; ( xt )
.934f	60		rts		z_latestxt:     rts
.9350					xt_leave:
.9350	68		pla		                pla
.9351	68		pla		                pla
.9352	68		pla		                pla
.9353	68		pla		                pla
.9354	60		rts		                rts             ; this must be compiled, so keep before z_leave
.9355					z_leave:
.9355					xt_left_bracket:
.9355	64 16		stz $16		                stz state
.9357	64 17		stz $17		                stz state+1
.9359	60		rts		z_left_bracket: rts
.935a					xt_less_number_sign:
.935a	20 a1 98	jsr $98a1	                jsr xt_pad      ; ( addr )
.935d	b5 00		lda $00,x	                lda 0,x
.935f	85 34		sta $34		                sta tohold
.9361	b5 01		lda $01,x	                lda 1,x
.9363	85 35		sta $35		                sta tohold+1
.9365	e8		inx		                inx
.9366	e8		inx		                inx
.9367					z_less_number_sign:
.9367	60		rts		                rts
.9368					xt_less_than:
.9368	20 49 d8	jsr $d849	                jsr underflow_2
.936b	a0 00		ldy #$00	                ldy #0          ; default false
.936d	20 6b d7	jsr $d76b	                jsr compare_16bit
.9370	f0 03		beq $9375	                beq _false
.9372	30 01		bmi $9375	                bmi _false
.9374	88		dey		                dey
.9375					_false:
.9375	98		tya		                tya
.9376	e8		inx		                inx
.9377	e8		inx		                inx
.9378	95 00		sta $00,x	                sta 0,x
.937a	95 01		sta $01,x	                sta 1,x
.937c	60		rts		z_less_than:    rts
.937d					xt_list:
.937d	20 44 d8	jsr $d844	                jsr underflow_1
.9380	20 d9 9e	jsr $9ed9	                jsr xt_scr
.9383	20 8d a1	jsr $a18d	                jsr xt_store
.9386	20 46 a8	jsr $a846	                jsr xt_editor_l
.9389	60		rts		z_list:         rts
.938a					xt_literal:
.938a	20 44 d8	jsr $d844	                jsr underflow_1
.938d	a0 93		ldy #$93	                ldy #>literal_runtime
.938f	a9 98		lda #$98	                lda #<literal_runtime
.9391	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9394	20 6e 87	jsr $876e	                jsr xt_comma
.9397	60		rts		z_literal:      rts
.9398					literal_runtime:
.9398	ca		dex		                dex
.9399	ca		dex		                dex
.939a	68		pla		                pla             ; LSB
.939b	85 24		sta $24		                sta tmp1
.939d	68		pla		                pla             ; MSB
.939e	85 25		sta $25		                sta tmp1+1
.93a0	a0 01		ldy #$01	                ldy #1
.93a2	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.93a4	95 00		sta $00,x	                sta 0,x
.93a6	c8		iny		                iny
.93a7	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.93a9	95 01		sta $01,x	                sta 1,x
.93ab	98		tya		                tya
.93ac	18		clc		                clc
.93ad	65 24		adc $24		                adc tmp1
.93af	a8		tay		                tay
.93b0	a5 25		lda $25		                lda tmp1+1
.93b2	69 00		adc #$00	                adc #0
.93b4	48		pha		                pha
.93b5	5a		phy		                phy
.93b6	60		rts		                rts
.93b7					xt_load:
.93b7	20 44 d8	jsr $d844	                jsr underflow_1
.93ba	a0 01		ldy #$01	                ldy #blk_offset+1
.93bc	b1 1e		lda ($1e),y	                lda (up),y
.93be	48		pha		                pha
.93bf	88		dey		                dey
.93c0	b1 1e		lda ($1e),y	                lda (up),y
.93c2	48		pha		                pha
.93c3	b5 00		lda $00,x	                lda 0,x
.93c5	91 1e		sta ($1e),y	                sta (up),y
.93c7	c8		iny		                iny
.93c8	b5 01		lda $01,x	                lda 1,x
.93ca	91 1e		sta ($1e),y	                sta (up),y
.93cc	20 c1 83	jsr $83c1	                jsr xt_block
.93cf	ca		dex		                dex
.93d0	ca		dex		                dex
.93d1	a9 04		lda #$04	                lda #4
.93d3	95 01		sta $01,x	                sta 1,x
.93d5	74 00		stz $00,x	                stz 0,x
.93d7	20 cf 90	jsr $90cf	                jsr load_evaluate
.93da	a0 00		ldy #$00	                ldy #blk_offset
.93dc	68		pla		                pla
.93dd	91 1e		sta ($1e),y	                sta (up),y
.93df	c8		iny		                iny
.93e0	68		pla		                pla
.93e1	91 1e		sta ($1e),y	                sta (up),y
.93e3	88		dey		                dey
.93e4	11 1e		ora ($1e),y	                ora (up),y
.93e6	f0 12		beq $93fa	                beq _done
.93e8	ca		dex		                dex
.93e9	ca		dex		                dex
.93ea	a0 00		ldy #$00	                ldy #blk_offset
.93ec	b1 1e		lda ($1e),y	                lda (up),y
.93ee	95 00		sta $00,x	                sta 0,x
.93f0	c8		iny		                iny
.93f1	b1 1e		lda ($1e),y	                lda (up),y
.93f3	95 01		sta $01,x	                sta 1,x
.93f5	20 c1 83	jsr $83c1	                jsr xt_block
.93f8	e8		inx		                inx
.93f9	e8		inx		                inx
.93fa					_done:
.93fa	60		rts		z_load:         rts
.93fb					xt_loop:
.93fb	a0 98		ldy #$98	                ldy #>xt_one
.93fd	a9 08		lda #$08	                lda #<xt_one
.93ff	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine     ; drop through to +LOOP
.9402					xt_plus_loop:
.9402	a0 11		ldy #$11	                ldy #plus_loop_runtime_end-plus_loop_runtime
.9404	5a		phy		                phy             ; save counter to adjust CP
.9405					-
.9405	b9 69 94	lda $9469,y	                lda plus_loop_runtime,y
.9408	91 00		sta ($00),y	                sta (cp),y
.940a	88		dey		                dey
.940b	10 f8		bpl $9405	                bpl -
.940d	68		pla		                pla
.940e	18		clc		                clc
.940f	65 00		adc $00		                adc cp
.9411	85 00		sta $00		                sta cp
.9413	a5 01		lda $01		                lda cp+1
.9415	69 00		adc #$00	                adc #0          ; only need carry
.9417	85 01		sta $01		                sta cp+1
.9419	20 6e 87	jsr $876e	                jsr xt_comma
.941c	a9 68		lda #$68	                lda #$68                ; opcode for PLA
.941e	a0 06		ldy #$06	                ldy #6
.9420					-
.9420	91 00		sta ($00),y	                sta (cp),y
.9422	88		dey		                dey
.9423	10 fb		bpl $9420	                bpl -
.9425	a9 06		lda #$06	                lda #6
.9427	18		clc		                clc
.9428	65 00		adc $00		                adc cp
.942a	85 00		sta $00		                sta cp
.942c	a5 01		lda $01		                lda cp+1
.942e	69 00		adc #$00	                adc #0                  ; only need carry
.9430	85 01		sta $01		                sta cp+1
.9432	b5 00		lda $00,x	                lda 0,x
.9434	85 24		sta $24		                sta tmp1
.9436	b5 01		lda $01,x	                lda 1,x
.9438	85 25		sta $25		                sta tmp1+1
.943a	e8		inx		                inx
.943b	e8		inx		                inx
.943c	a5 00		lda $00		                lda cp
.943e	38		sec		                sec
.943f	e9 01		sbc #$01	                sbc #1
.9441	85 26		sta $26		                sta tmp2
.9443	a5 01		lda $01		                lda cp+1
.9445	e9 00		sbc #$00	                sbc #0
.9447	85 27		sta $27		                sta tmp2+1
.9449	a0 00		ldy #$00	                ldy #0
.944b	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.944d	91 24		sta ($24),y	                sta (tmp1),y
.944f	c8		iny		                iny
.9450	a5 27		lda $27		                lda tmp2+1      ; MSB
.9452	91 24		sta ($24),y	                sta (tmp1),y
.9454	c8		iny		                iny
.9455	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9457	91 24		sta ($24),y	                sta (tmp1),y
.9459	c8		iny		                iny
.945a	a9 a9		lda #$a9	                lda #$A9        ; opcode for LDA immediate
.945c	91 24		sta ($24),y	                sta (tmp1),y
.945e	c8		iny		                iny
.945f	a5 26		lda $26		                lda tmp2        ; LSB
.9461	91 24		sta ($24),y	                sta (tmp1),y
.9463	c8		iny		                iny
.9464	a9 48		lda #$48	                lda #$48        ; Opcode for PHA
.9466	91 24		sta ($24),y	                sta (tmp1),y
.9468					z_loop:
.9468	60		rts		z_plus_loop:    rts
.9469					plus_loop_runtime:
.9469	18		clc		                clc
.946a	68		pla		                pla             ; LSB of index
.946b	75 00		adc $00,x	                adc 0,x         ; LSB of step
.946d	a8		tay		                tay             ; temporary storage of LSB
.946e	b8		clv		                clv
.946f	68		pla		                pla             ; MSB of index
.9470	75 01		adc $01,x	                adc 1,x         ; MSB of step
.9472	48		pha		                pha             ; put MSB of index back on stack
.9473	98		tya		                tya             ; put LSB of index back on stack
.9474	48		pha		                pha
.9475	e8		inx		                inx             ; dump step from TOS
.9476	e8		inx		                inx
.9477	70 03		bvs $947c	                bvs _hack+3     ; skip over JMP instruction
.9479					_hack:
>9479	4c				                .byte $4C
.947a					plus_loop_runtime_end:
.947a					xt_lshift:
.947a	20 49 d8	jsr $d849	                jsr underflow_2
.947d	b5 00		lda $00,x	                lda 0,x
.947f	29 0f		and #$0f	                and #%00001111
.9481	f0 08		beq $948b	                beq _done
.9483	a8		tay		                tay
.9484					_loop:
.9484	16 02		asl $02,x	                asl 2,x
.9486	36 03		rol $03,x	                rol 3,x
.9488	88		dey		                dey
.9489	d0 f9		bne $9484	                bne _loop
.948b					_done:
.948b	e8		inx		                inx
.948c	e8		inx		                inx
.948d	60		rts		z_lshift:       rts
.948e					xt_m_star:
.948e	20 49 d8	jsr $d849	                jsr underflow_2
.9491	b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9493	55 03		eor $03,x	                eor 3,x         ; MSB of n2
.9495	48		pha		                pha
.9496	20 39 81	jsr $8139	                jsr xt_abs
.9499	20 ae a1	jsr $a1ae	                jsr xt_swap
.949c	20 39 81	jsr $8139	                jsr xt_abs
.949f	20 fc a5	jsr $a5fc	                jsr xt_um_star          ; ( d )
.94a2	68		pla		                pla
.94a3	10 03		bpl $94a8	                bpl _done
.94a5	20 41 8b	jsr $8b41	                jsr xt_dnegate
.94a8					_done:
.94a8	60		rts		z_m_star:       rts
.94a9					xt_marker:
.94a9	20 86 d7	jsr $d786	                jsr current_to_dp
.94ac	a5 02		lda $02		                lda dp
.94ae	48		pha		                pha
.94af	a5 03		lda $03		                lda dp+1
.94b1	48		pha		                pha
.94b2	a5 00		lda $00		                lda cp
.94b4	48		pha		                pha
.94b5	a5 01		lda $01		                lda cp+1
.94b7	48		pha		                pha
.94b8	20 69 89	jsr $8969	                jsr xt_create
.94bb	a5 00		lda $00		                lda cp          ; LSB
.94bd	38		sec		                sec
.94be	e9 02		sbc #$02	                sbc #2
.94c0	85 00		sta $00		                sta cp
.94c2	a5 01		lda $01		                lda cp+1        ; MSB
.94c4	e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94c6	85 01		sta $01		                sta cp+1
.94c8	a0 94		ldy #$94	                ldy #>marker_runtime
.94ca	a9 e7		lda #$e7	                lda #<marker_runtime
.94cc	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.94cf	7a		ply		                ply                     ; MSB
.94d0	68		pla		                pla                     ; LSB
.94d1	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.94d4	7a		ply		                ply                     ; MSB
.94d5	68		pla		                pla                     ; LSB
.94d6	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.94d9	a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94db					_marker_loop:
.94db	b1 1e		lda ($1e),y	                lda (up),y
.94dd	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.94e0	c8		iny		                iny
.94e1	98		tya		                tya
.94e2	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94e4	d0 f5		bne $94db	                bne _marker_loop
.94e6	60		rts		z_marker:       rts
.94e7					marker_runtime:
.94e7	68		pla		                pla
.94e8	85 24		sta $24		                sta tmp1        ; LSB of address
.94ea	68		pla		                pla
.94eb	85 25		sta $25		                sta tmp1+1      ; MSB of address
.94ed	e6 24		inc $24		                inc tmp1
.94ef	d0 02		bne $94f3	                bne +
.94f1	e6 25		inc $25		                inc tmp1+1
.94f3					+
.94f3	a0 00		ldy #$00	                ldy #0
.94f5	b1 24		lda ($24),y	                lda (tmp1),y
.94f7	85 00		sta $00		                sta cp
.94f9	c8		iny		                iny
.94fa	b1 24		lda ($24),y	                lda (tmp1),y
.94fc	85 01		sta $01		                sta cp+1
.94fe	c8		iny		                iny
.94ff	b1 24		lda ($24),y	                lda (tmp1),y
.9501	85 02		sta $02		                sta dp
.9503	c8		iny		                iny
.9504	b1 24		lda ($24),y	                lda (tmp1),y
.9506	85 03		sta $03		                sta dp+1
.9508	a0 04		ldy #$04	                ldy #4
.950a					_marker_restore_loop:
.950a	b1 24		lda ($24),y	                lda (tmp1), y
.950c	91 1e		sta ($1e),y	                sta (up), y
.950e	c8		iny		                iny
.950f	98		tya		                tya
.9510	c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.9512	d0 f6		bne $950a	                bne _marker_restore_loop
.9514	20 99 d7	jsr $d799	                jsr dp_to_current       ; Move the CURRENT DP back.
.9517	60		rts		                rts
.9518					xt_max:
.9518	20 49 d8	jsr $d849	                jsr underflow_2
.951b	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.951d	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.951f	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9521	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9523	50 02		bvc $9527	                bvc _no_overflow
.9525	49 80		eor #$80	                eor #$80        ; complement negative flag
.9527					_no_overflow:
.9527	30 08		bmi $9531	                bmi _keep_nos
.9529	b5 00		lda $00,x	                lda 0,x
.952b	95 02		sta $02,x	                sta 2,x
.952d	b5 01		lda $01,x	                lda 1,x
.952f	95 03		sta $03,x	                sta 3,x
.9531					_keep_nos:
.9531	e8		inx		                inx
.9532	e8		inx		                inx
.9533	60		rts		z_max:          rts
.9534					xt_min:
.9534	20 49 d8	jsr $d849	                jsr underflow_2
.9537	b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9539	d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.953b	b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.953d	f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.953f	50 02		bvc $9543	                bvc _no_overflow
.9541	49 80		eor #$80	                eor #$80
.9543					_no_overflow:
.9543	10 08		bpl $954d	                bpl _keep_nos
.9545	b5 00		lda $00,x	                lda 0,x
.9547	95 02		sta $02,x	                sta 2,x
.9549	b5 01		lda $01,x	                lda 1,x
.954b	95 03		sta $03,x	                sta 3,x
.954d					_keep_nos:
.954d	e8		inx		                inx
.954e	e8		inx		                inx
.954f	60		rts		z_min:          rts
.9550					xt_minus:
.9550	20 49 d8	jsr $d849	                jsr underflow_2
.9553	38		sec		                sec
.9554	b5 02		lda $02,x	                lda 2,x         ; LSB
.9556	f5 00		sbc $00,x	                sbc 0,x
.9558	95 02		sta $02,x	                sta 2,x
.955a	b5 03		lda $03,x	                lda 3,x         ; MSB
.955c	f5 01		sbc $01,x	                sbc 1,x
.955e	95 03		sta $03,x	                sta 3,x
.9560	e8		inx		                inx
.9561	e8		inx		                inx
.9562	60		rts		z_minus:        rts
.9563					xt_minus_leading:
.9563	20 49 d8	jsr $d849	                jsr underflow_2
.9566					_loop:
.9566	b5 00		lda $00,x	                lda 0,x
.9568	15 01		ora $01,x	                ora 1,x
.956a	f0 0f		beq $957b	                beq _done
.956c	a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.956e	20 37 d8	jsr $d837	                jsr is_whitespace
.9571	90 08		bcc $957b	                bcc _done
.9573	20 08 98	jsr $9808	                jsr xt_one              ; ( addr u 1 )
.9576	20 19 a0	jsr $a019	                jsr xt_slash_string     ; ( addr+ u-1 )
.9579	80 eb		bra $9566	                bra _loop
.957b					_done:
.957b					z_minus_leading:
.957b	60		rts		                rts
.957c					xt_minus_trailing:
.957c	20 49 d8	jsr $d849	                jsr underflow_2
.957f	b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9581	15 01		ora $01,x	                ora 1,x         ; MSB of n
.9583	f0 33		beq $95b8	                beq _done
.9585	18		clc		                clc
.9586	b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.9588	75 00		adc $00,x	                adc 0,x
.958a	85 24		sta $24		                sta tmp1
.958c	b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.958e	75 01		adc $01,x	                adc 1,x
.9590	85 25		sta $25		                sta tmp1+1
.9592	a5 24		lda $24		                lda tmp1
.9594	d0 02		bne $9598	                bne +
.9596	c6 25		dec $25		                dec tmp1+1
.9598					+
.9598	c6 24		dec $24		                dec tmp1
.959a					_loop:
.959a	b2 24		lda ($24)	                lda (tmp1)
.959c	c9 20		cmp #$20	                cmp #AscSP
.959e	d0 18		bne $95b8	                bne _done
.95a0	a5 24		lda $24		                lda tmp1
.95a2	d0 02		bne $95a6	                bne +
.95a4	c6 25		dec $25		                dec tmp1+1
.95a6					+
.95a6	c6 24		dec $24		                dec tmp1
.95a8	b5 00		lda $00,x	                lda 0,x
.95aa	d0 02		bne $95ae	                bne +
.95ac	d6 01		dec $01,x	                dec 1,x
.95ae					+
.95ae	d6 00		dec $00,x	                dec 0,x
.95b0	b5 00		lda $00,x	                lda 0,x
.95b2	15 01		ora $01,x	                ora 1,x
.95b4	f0 02		beq $95b8	                beq _done       ; Count has reached zero - we're done!
.95b6	80 e2		bra $959a	                bra _loop
.95b8					_done:
.95b8					z_minus_trailing:
.95b8	60		rts		                rts
.95b9					xt_mod:
.95b9	20 49 d8	jsr $d849	                jsr underflow_2
.95bc	20 01 a0	jsr $a001	                jsr xt_slash_mod
.95bf	e8		inx		                inx             ; DROP
.95c0	e8		inx		                inx
.95c1					z_mod:
.95c1	60		rts		                rts
.95c2					xt_move:
.95c2	b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95c4	d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95c6	f0 05		beq $95cd	                beq _lsb                ; wasn't helpful, move to LSB
.95c8	b0 0e		bcs $95d8	                bcs _to_move_up         ; we want CMOVE>
.95ca	4c 99 86	jmp $8699	                jmp xt_cmove            ; JSR/RTS
.95cd					_lsb:
.95cd	b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95cf	d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95d1	f0 08		beq $95db	                beq _equal              ; LSB is equal as well
.95d3	b0 03		bcs $95d8	                bcs _to_move_up         ; we want CMOVE>
.95d5	4c 99 86	jmp $8699	                jmp xt_cmove            ; JSR/RTS
.95d8					_to_move_up:
.95d8	4c d4 86	jmp $86d4	                jmp xt_cmove_up         ; JSR/RTS
.95db					_equal:
.95db	8a		txa		                txa
.95dc	18		clc		                clc
.95dd	69 06		adc #$06	                adc #6
.95df	aa		tax		                tax
.95e0	60		rts		z_move:         rts
.95e1					xt_name_to_int:
.95e1	20 44 d8	jsr $d844	                jsr underflow_1
.95e4	b5 00		lda $00,x	                lda 0,x
.95e6	18		clc		                clc
.95e7	69 04		adc #$04	                adc #4
.95e9	85 28		sta $28		                sta tmp3
.95eb	b5 01		lda $01,x	                lda 1,x
.95ed	90 01		bcc $95f0	                bcc _done
.95ef	1a		inc a		                ina
.95f0					_done:
.95f0	85 29		sta $29		                sta tmp3+1
.95f2	a0 00		ldy #$00	                ldy #0
.95f4	b1 28		lda ($28),y	                lda (tmp3),y
.95f6	95 00		sta $00,x	                sta 0,x
.95f8	c8		iny		                iny
.95f9	b1 28		lda ($28),y	                lda (tmp3),y
.95fb	95 01		sta $01,x	                sta 1,x
.95fd	60		rts		z_name_to_int:  rts
.95fe					xt_name_to_string:
.95fe	20 44 d8	jsr $d844	                jsr underflow_1
.9601	ca		dex		                dex
.9602	ca		dex		                dex
.9603	a1 02		lda ($02,x)	                lda (2,x)
.9605	95 00		sta $00,x	                sta 0,x
.9607	74 01		stz $01,x	                stz 1,x
.9609	b5 02		lda $02,x	                lda 2,x         ; LSB
.960b	18		clc		                clc
.960c	69 08		adc #$08	                adc #8
.960e	a8		tay		                tay
.960f	b5 03		lda $03,x	                lda 3,x         ; MSB
.9611	69 00		adc #$00	                adc #0          ; just need carry
.9613	95 03		sta $03,x	                sta 3,x
.9615	94 02		sty $02,x	                sty 2,x
.9617					z_name_to_string:
.9617	60		rts		                rts
.9618					xt_nc_limit:
.9618	ca		dex		                dex
.9619	ca		dex		                dex
.961a	a9 1a		lda #$1a	                lda #<nc_limit
.961c	95 00		sta $00,x	                sta 0,x
.961e	a9 00		lda #$00	                lda #>nc_limit
.9620	95 01		sta $01,x	                sta 1,x
.9622	60		rts		z_nc_limit:     rts
.9623					xt_negate:
.9623	20 44 d8	jsr $d844	                jsr underflow_1
.9626	a9 00		lda #$00	        	lda #0
.9628	38		sec		                sec
.9629	f5 00		sbc $00,x	                sbc 0,x         ; LSB
.962b	95 00		sta $00,x	                sta 0,x
.962d	a9 00		lda #$00	                lda #0
.962f	f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9631	95 01		sta $01,x	                sta 1,x
.9633	60		rts		z_negate:       rts
.9634					xt_never_native:
.9634	20 86 d7	jsr $d786	                jsr current_to_dp
.9637	a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9639	b1 02		lda ($02),y	                lda (dp),y
.963b	09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.963d	29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.963f	91 02		sta ($02),y	                sta (dp),y
.9641					z_never_native:
.9641	60		rts		                rts
.9642					xt_nip:
.9642	20 49 d8	jsr $d849	                jsr underflow_2
.9645	b5 00		lda $00,x	                lda 0,x         ; LSB
.9647	95 02		sta $02,x	                sta 2,x
.9649	b5 01		lda $01,x	                lda 1,x         ; MSB
.964b	95 03		sta $03,x	                sta 3,x
.964d	e8		inx		                inx
.964e	e8		inx		                inx
.964f	60		rts		z_nip:          rts
.9650					xt_not_equals:
.9650	20 49 d8	jsr $d849	                jsr underflow_2
.9653	a0 00		ldy #$00	                ldy #0                  ; default is true
.9655	b5 00		lda $00,x	                lda 0,x                 ; LSB
.9657	d5 02		cmp $02,x	                cmp 2,x
.9659	d0 0a		bne $9665	                bne _not_equal
.965b	b5 01		lda $01,x	                lda 1,x                 ; MSB
.965d	d5 03		cmp $03,x	                cmp 3,x
.965f	d0 04		bne $9665	                bne _not_equal
.9661	a9 ff		lda #$ff	                lda #$FF
.9663	80 01		bra $9666	                bra _done
.9665					_not_equal:
.9665	88		dey		                dey                     ; drop thru to done
.9666					_done:
.9666	98		tya		                tya
.9667	e8		inx		                inx
.9668	e8		inx		                inx
.9669	95 00		sta $00,x	                sta 0,x
.966b	95 01		sta $01,x	                sta 1,x
.966d	60		rts		z_not_equals:   rts
.966e					xt_not_rote:
.966e	20 4e d8	jsr $d84e	                jsr underflow_3
.9671	b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9673	b5 03		lda $03,x	                lda 3,x
.9675	95 01		sta $01,x	                sta 1,x
.9677	b5 05		lda $05,x	                lda 5,x
.9679	95 03		sta $03,x	                sta 3,x
.967b	94 05		sty $05,x	                sty 5,x
.967d	b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.967f	b5 02		lda $02,x	                lda 2,x
.9681	95 00		sta $00,x	                sta 0,x
.9683	b5 04		lda $04,x	                lda 4,x
.9685	95 02		sta $02,x	                sta 2,x
.9687	94 04		sty $04,x	                sty 4,x
.9689	60		rts		z_not_rote:     rts
.968a					xt_number:
.968a	20 49 d8	jsr $d849	                jsr underflow_2
.968d	64 2a		stz $2a		                stz tmpdsp      ; flag for double
.968f	64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.9691	a5 18		lda $18		                lda base
.9693	48		pha		                pha
.9694	20 b8 a3	jsr $a3b8	                jsr xt_two_dup
.9697	a1 02		lda ($02,x)	                lda (2,x)
.9699					_check_dec:
.9699	c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.969b	d0 04		bne $96a1	                bne _check_hex
.969d	a9 0a		lda #$0a	                lda #$0A
.969f	80 42		bra $96e3	                bra _base_changed
.96a1					_check_hex:
.96a1	c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.96a3	d0 04		bne $96a9	                bne _check_binary
.96a5	a9 10		lda #$10	                lda #$10
.96a7	80 3a		bra $96e3	                bra _base_changed
.96a9					_check_binary:
.96a9	c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.96ab	d0 04		bne $96b1	                bne _check_char
.96ad	a9 02		lda #$02	                lda #$02
.96af	80 32		bra $96e3	                bra _base_changed
.96b1					_check_char:
.96b1	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96b3	d0 3a		bne $96ef	                bne _check_minus
.96b5	b5 00		lda $00,x	                lda 0,x         ; Get the length
.96b7	c9 03		cmp #$03	                cmp #$03
.96b9	d0 26		bne $96e1	                bne _not_a_char
.96bb	b5 01		lda $01,x	                lda 1,x
.96bd	d0 22		bne $96e1	                bne _not_a_char ; No compare needed to check for non-zero.
.96bf	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96c1	18		clc		                clc
.96c2	69 02		adc #$02	                adc #2          ; length of string
.96c4	85 2c		sta $2c		                sta tmptos
.96c6	b5 03		lda $03,x	                lda 3,x
.96c8	69 00		adc #$00	                adc #0          ; only need carry
.96ca	85 2d		sta $2d		                sta tmptos+1
.96cc	b2 2c		lda ($2c)	                lda (tmptos)
.96ce	c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96d0	d0 0f		bne $96e1	                bne _not_a_char
.96d2	f6 02		inc $02,x	                inc 2,x
.96d4	d0 02		bne $96d8	                bne +
.96d6	f6 03		inc $03,x	                inc 3,x
.96d8					+
.96d8	a1 02		lda ($02,x)	                lda (2,x)
.96da	95 02		sta $02,x	                sta 2,x
.96dc	74 03		stz $03,x	                stz 3,x
.96de	4c 5f 97	jmp $975f	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96e1					_not_a_char:
.96e1	80 5a		bra $973d	                bra _number_error
.96e3					_base_changed:
.96e3	85 18		sta $18		                sta base        ; Switch to the new base
.96e5	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96e7	d0 02		bne $96eb	                bne +
.96e9	f6 03		inc $03,x	                inc 3,x
.96eb					+
.96eb	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96ed	a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96ef					_check_minus:
.96ef	c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96f1	d0 0a		bne $96fd	                bne _check_dot
.96f3	c6 2b		dec $2b		                dec tmpdsp+1
.96f5	f6 02		inc $02,x	                inc 2,x         ; start one character later
.96f7	d0 02		bne $96fb	                bne +
.96f9	f6 03		inc $03,x	                inc 3,x
.96fb					+
.96fb	d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96fd					_check_dot:
.96fd	b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96ff	18		clc		                clc
.9700	75 00		adc $00,x	                adc 0,x         ; length of string
.9702	85 2c		sta $2c		                sta tmptos
.9704	b5 03		lda $03,x	                lda 3,x
.9706	69 00		adc #$00	                adc #0          ; only need carry
.9708	85 2d		sta $2d		                sta tmptos+1
.970a	a5 2c		lda $2c		                lda tmptos
.970c	d0 02		bne $9710	                bne +
.970e	c6 2d		dec $2d		                dec tmptos+1
.9710					+
.9710	c6 2c		dec $2c		                dec tmptos
.9712	b2 2c		lda ($2c)	                lda (tmptos)
.9714	c9 2e		cmp #$2e	                cmp #'.'
.9716	d0 04		bne $971c	                bne _main
.9718	c6 2a		dec $2a		                dec tmpdsp
.971a	d6 00		dec $00,x	                dec 0,x
.971c					_main:
.971c	ca		dex		                dex
.971d	ca		dex		                dex
.971e	ca		dex		                dex
.971f	ca		dex		                dex
.9720	b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9722	95 00		sta $00,x	                sta 0,x
.9724	74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9726	b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9728	95 02		sta $02,x	                sta 2,x
.972a	b5 07		lda $07,x	                lda 7,x         ; MSB of address
.972c	95 03		sta $03,x	                sta 3,x
.972e	74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9730	74 05		stz $05,x	                stz 5,x
.9732	74 06		stz $06,x	                stz 6,x
.9734	74 07		stz $07,x	                stz 7,x
.9736	20 bd a2	jsr $a2bd	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.9739	b5 00		lda $00,x	                lda 0,x
.973b	f0 1e		beq $975b	                beq _all_converted
.973d					_number_error:
.973d	20 b0 a3	jsr $a3b0	                jsr xt_two_drop ; >NUMBER modified addr u
.9740	20 b0 a3	jsr $a3b0	                jsr xt_two_drop ; ud   (partially converted number)
.9743	a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9745	20 f6 8d	jsr $8df6	                jsr emit_a
.9748	20 03 a5	jsr $a503	                jsr xt_type
.974b	a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.974d	20 f6 8d	jsr $8df6	                jsr emit_a
.9750	20 1e a1	jsr $a11e	                jsr xt_space
.9753	68		pla		                pla
.9754	85 18		sta $18		                sta base
.9756	a9 08		lda #$08	                lda #err_syntax
.9758	4c 5a d8	jmp $d85a	                jmp error
.975b					_all_converted:
.975b	e8		inx		                inx ; Drop the current addr u
.975c	e8		inx		                inx
.975d	e8		inx		                inx
.975e	e8		inx		                inx
.975f					_drop_original_string:
.975f	20 7e a4	jsr $a47e	                jsr xt_two_swap  ; Drop the original addr u
.9762	20 b0 a3	jsr $a3b0	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9765	a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.9767	f0 0d		beq $9776	                beq _single
.9769	a9 20		lda #$20	                lda #%00100000
.976b	04 20		tsb $20		                tsb status
.976d	a5 2b		lda $2b		                lda tmpdsp+1
.976f	f0 12		beq $9783	                beq _done       ; no minus, all done
.9771	20 41 8b	jsr $8b41	                jsr xt_dnegate
.9774	80 0d		bra $9783	                bra _done
.9776					_single:
.9776	e8		inx		                inx
.9777	e8		inx		                inx
.9778	a9 20		lda #$20	                lda #%00100000
.977a	14 20		trb $20		                trb status
.977c	a5 2b		lda $2b		                lda tmpdsp+1
.977e	f0 03		beq $9783	                beq _done       ; no minus, all done
.9780	20 23 96	jsr $9623	                jsr xt_negate
.9783					_done:
.9783	68		pla		                pla
.9784	85 18		sta $18		                sta base
.9786	60		rts		z_number:       rts
.9787					xt_number_sign:
.9787	20 49 d8	jsr $d849	                jsr underflow_2         ; double number
.978a	20 87 83	jsr $8387	                jsr xt_base
.978d	20 80 8f	jsr $8f80	                jsr xt_fetch            ; ( ud1 base )
.9790	20 70 a3	jsr $a370	                jsr xt_to_r             ; >r
.9793	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; 0
.9796	20 7d 9a	jsr $9a7d	                jsr xt_r_fetch          ; r@
.9799	20 ba a5	jsr $a5ba	                jsr xt_um_slash_mod     ; um/mod
.979c	20 57 9b	jsr $9b57	                jsr xt_rot              ; rot
.979f	20 57 9b	jsr $9b57	                jsr xt_rot              ; rot
.97a2	20 92 9a	jsr $9a92	                jsr xt_r_from           ; r>
.97a5	20 ba a5	jsr $a5ba	                jsr xt_um_slash_mod     ; um/mod
.97a8	20 57 9b	jsr $9b57	                jsr xt_rot              ; rot
.97ab	20 57 9b	jsr $9b57	                jsr xt_rot              ; ( ud rem )
.97ae	b5 00		lda $00,x	                lda 0,x
.97b0	a8		tay		                tay
.97b1	b9 23 d4	lda $d423,y	                lda s_abc_upper,y
.97b4	95 00		sta $00,x	                sta 0,x
.97b6	74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.97b8	20 d7 91	jsr $91d7	                jsr xt_hold
.97bb					z_number_sign:
.97bb	60		rts		                rts
.97bc					xt_number_sign_greater:
.97bc	20 49 d8	jsr $d849	                jsr underflow_2         ; double number
.97bf	a5 34		lda $34		                lda tohold
.97c1	95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97c3	95 02		sta $02,x	                sta 2,x
.97c5	a5 35		lda $35		                lda tohold+1
.97c7	95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97c9	95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97cb	20 a1 98	jsr $98a1	                jsr xt_pad      ; ( addr addr pad )
.97ce	38		sec		                sec
.97cf	b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97d1	f5 02		sbc $02,x	                sbc 2,x
.97d3	95 02		sta $02,x	                sta 2,x
.97d5	b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97d7	f5 03		sbc $03,x	                sbc 3,x
.97d9	95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97db	e8		inx		                inx
.97dc	e8		inx		                inx
.97dd					z_number_sign_greater:
.97dd	60		rts		                rts
.97de					xt_number_sign_s:
.97de	20 49 d8	jsr $d849	                jsr underflow_2
.97e1					_loop:
.97e1	20 87 97	jsr $9787	                jsr xt_number_sign
.97e4	b5 00		lda $00,x	                lda 0,x
.97e6	15 01		ora $01,x	                ora 1,x
.97e8	15 02		ora $02,x	                ora 2,x
.97ea	15 03		ora $03,x	                ora 3,x
.97ec	d0 f3		bne $97e1	                bne _loop
.97ee					z_number_sign_s:
.97ee	60		rts		                rts
.97ef					xt_of:
.97ef	a0 98		ldy #$98	                ldy #>xt_over
.97f1	a9 93		lda #$93	                lda #<xt_over
.97f3	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.97f6	a0 8e		ldy #$8e	                ldy #>xt_equal
.97f8	a9 ce		lda #$ce	                lda #<xt_equal
.97fa	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.97fd	20 03 92	jsr $9203	                jsr xt_if
.9800	a0 8d		ldy #$8d	                ldy #>xt_drop
.9802	a9 2e		lda #$2e	                lda #<xt_drop
.9804	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9807	60		rts		z_of:           rts
.9808					xt_editor_wordlist:
.9808					xt_one:
.9808	ca		dex		                dex
.9809	ca		dex		                dex
.980a	a9 01		lda #$01	                lda #1
.980c	95 00		sta $00,x	                sta 0,x
.980e	74 01		stz $01,x	                stz 1,x
.9810					z_editor_wordlist:
.9810					z_one:
.9810	60		rts		                rts
.9811					xt_one_minus:
.9811	20 44 d8	jsr $d844	                jsr underflow_1
.9814	b5 00		lda $00,x	                lda 0,x
.9816	d0 02		bne $981a	                bne +
.9818	d6 01		dec $01,x	                dec 1,x
.981a					+
.981a	d6 00		dec $00,x	                dec 0,x
.981c	60		rts		z_one_minus:    rts
.981d					xt_char_plus:
.981d					xt_one_plus:
.981d	20 44 d8	jsr $d844	                jsr underflow_1
.9820	f6 00		inc $00,x	                inc 0,x
.9822	d0 02		bne $9826	                bne _done
.9824	f6 01		inc $01,x	                inc 1,x
.9826					_done:
.9826					z_char_plus:
.9826	60		rts		z_one_plus:     rts
.9827					xt_only:
.9827	ca		dex		                dex
.9828	ca		dex		                dex
.9829	a9 ff		lda #$ff	                lda #$FF
.982b	95 00		sta $00,x	                sta 0,x
.982d	95 01		sta $01,x	                sta 1,x
.982f	20 1b 9d	jsr $9d1b	                jsr xt_set_order
.9832	60		rts		z_only:         rts
.9833					xt_or:
.9833	20 49 d8	jsr $d849	                jsr underflow_2
.9836	b5 00		lda $00,x	                lda 0,x
.9838	15 02		ora $02,x	                ora 2,x
.983a	95 02		sta $02,x	                sta 2,x
.983c	b5 01		lda $01,x	                lda 1,x
.983e	15 03		ora $03,x	                ora 3,x
.9840	95 03		sta $03,x	                sta 3,x
.9842	e8		inx		                inx
.9843	e8		inx		                inx
.9844	60		rts		z_or:           rts
.9845					xt_order:
.9845	20 63 89	jsr $8963	                jsr xt_cr
.9848	20 34 91	jsr $9134	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.984b	b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.984d	f0 1e		beq $986d	                beq _drop_done
.984f					_have_wordlists:
.984f	a8		tay		                tay
.9850					_loop:
.9850	e8		inx		                inx
.9851	e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9852	b5 00		lda $00,x	                lda 0,x
.9854	5a		phy		                phy
.9855	20 70 98	jsr $9870	                jsr order_print_wid_string   ; internal helper function
.9858	7a		ply		                ply
.9859	88		dey		                dey
.985a	d0 f4		bne $9850	                bne _loop
.985c	20 1e a1	jsr $a11e	                jsr xt_space
.985f	20 1e a1	jsr $a11e	                jsr xt_space
.9862	20 29 91	jsr $9129	                jsr xt_get_current      ; ( wid )
.9865	b5 00		lda $00,x	                lda 0,x
.9867	20 70 98	jsr $9870	                jsr order_print_wid_string
.986a	20 63 89	jsr $8963	                jsr xt_cr
.986d					_drop_done:
.986d	e8		inx		                inx
.986e	e8		inx		                inx
.986f					z_order:
.986f	60		rts		                rts
.9870					order_print_wid_string:
.9870	c9 04		cmp #$04	                cmp #4
.9872	90 09		bcc $987d	                bcc _output_string      ; less than 4, print a real string
.9874	ca		dex		                dex
.9875	ca		dex		                dex
.9876	95 00		sta $00,x	                sta 0,x
.9878	74 01		stz $01,x	                stz 1,x
.987a	4c 2e a5	jmp $a52e	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.987d					_output_string:
.987d	a8		tay		                tay
.987e	b9 84 98	lda $9884,y	                lda _wid_data,y
.9881	4c 80 d8	jmp $d880	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9884					_wid_data:
>9884	03				        .byte str_wid_forth            ; WID 0: "Forth"
>9885	06				        .byte str_wid_editor           ; WID 1: "Editor"
>9886	07				        .byte str_wid_assembler        ; WID 2: "Assembler"
>9887	08				        .byte str_wid_root             ; WID 3: "Root"
.9888					xt_output:
.9888	ca		dex		                dex
.9889	ca		dex		                dex
.988a	a9 10		lda #$10	                lda #<output
.988c	95 00		sta $00,x	                sta 0,x
.988e	a9 00		lda #$00	                lda #>output
.9890	95 01		sta $01,x	                sta 1,x
.9892	60		rts		z_output:       rts
.9893					xt_over:
.9893	20 49 d8	jsr $d849	                jsr underflow_2
.9896	ca		dex		                dex
.9897	ca		dex		                dex
.9898	b5 04		lda $04,x	                lda 4,x         ; LSB
.989a	95 00		sta $00,x	                sta 0,x
.989c	b5 05		lda $05,x	                lda 5,x         ; MSB
.989e	95 01		sta $01,x	                sta 1,x
.98a0	60		rts		z_over:         rts
.98a1					xt_pad:
.98a1	ca		dex		                dex
.98a2	ca		dex		                dex
.98a3	a5 00		lda $00		                lda cp
.98a5	18		clc		                clc
.98a6	69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.98a8	95 00		sta $00,x	                sta 0,x
.98aa	a5 01		lda $01		                lda cp+1
.98ac	69 00		adc #$00	                adc #0          ; only need carry
.98ae	95 01		sta $01,x	                sta 1,x
.98b0	60		rts		z_pad:          rts
.98b1					xt_page:
.98b1	a9 1b		lda #$1b	                lda #AscESC
.98b3	20 f6 8d	jsr $8df6	                jsr emit_a
.98b6	a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.98b8	20 f6 8d	jsr $8df6	                jsr emit_a
.98bb	a9 32		lda #$32	                lda #'2'
.98bd	20 f6 8d	jsr $8df6	                jsr emit_a
.98c0	a9 4a		lda #$4a	                lda #'J'
.98c2	20 f6 8d	jsr $8df6	                jsr emit_a
.98c5	20 a8 a7	jsr $a7a8	                jsr xt_zero
.98c8	20 a8 a7	jsr $a7a8	                jsr xt_zero
.98cb	20 50 83	jsr $8350	                jsr xt_at_xy
.98ce	60		rts		z_page:         rts
.98cf					xt_paren:
.98cf	ca		dex		                dex
.98d0	ca		dex		                dex
.98d1	a9 29		lda #$29	                lda #41     ; Right parenthesis
.98d3	95 00		sta $00,x	                sta 0,x
.98d5	74 01		stz $01,x	                stz 1,x
.98d7	20 3a 99	jsr $993a	                jsr xt_parse
.98da	e8		inx		                inx
.98db	e8		inx		                inx
.98dc	e8		inx		                inx
.98dd	e8		inx		                inx
.98de	60		rts		z_paren:        rts
.98df					xt_parse_name:
.98df	a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98e1	38		sec		                sec
.98e2	e5 0c		sbc $0c		                sbc toin
.98e4	85 24		sta $24		                sta tmp1
.98e6	a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98e8	e5 0d		sbc $0d		                sbc toin+1
.98ea	85 25		sta $25		                sta tmp1+1
.98ec	a5 24		lda $24		                lda tmp1
.98ee	05 25		ora $25		                ora tmp1+1
.98f0	f0 28		beq $991a	                beq _empty_line
.98f2	a5 08		lda $08		                lda cib
.98f4	18		clc		                clc
.98f5	65 0c		adc $0c		                adc toin
.98f7	85 26		sta $26		                sta tmp2                ; LSB of first character
.98f9	a5 09		lda $09		                lda cib+1
.98fb	65 0d		adc $0d		                adc toin+1
.98fd	85 27		sta $27		                sta tmp2+1              ; MSB
.98ff					_skip_loop:
.98ff	b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.9901	20 37 d8	jsr $d837	                jsr is_whitespace
.9904	90 1f		bcc $9925	                bcc _char_found
.9906	e6 26		inc $26		                inc tmp2
.9908	d0 02		bne $990c	                bne +
.990a	e6 27		inc $27		                inc tmp2+1
.990c					+
.990c	a5 24		lda $24		                lda tmp1
.990e	d0 02		bne $9912	                bne +
.9910	c6 25		dec $25		                dec tmp1+1
.9912	c6 24		dec $24		+               dec tmp1
.9914	a5 24		lda $24		                lda tmp1
.9916	05 25		ora $25		                ora tmp1+1
.9918	d0 e5		bne $98ff	                bne _skip_loop          ; fall through if empty line
.991a					_empty_line:
.991a	ca		dex		                dex
.991b	ca		dex		                dex
.991c	ca		dex		                dex
.991d	ca		dex		                dex
.991e	74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.9920	74 01		stz $01,x	                stz 1,x
.9922	4c d1 99	jmp $99d1	                jmp z_parse_name        ; skip over PARSE
.9925					_char_found:
.9925	a5 26		lda $26		                lda tmp2
.9927	38		sec		                sec
.9928	e5 08		sbc $08		                sbc cib
.992a	85 0c		sta $0c		                sta toin
.992c	a5 27		lda $27		                lda tmp2+1
.992e	e5 09		sbc $09		                sbc cib+1
.9930	85 0d		sta $0d		                sta toin+1
.9932	ca		dex		                dex
.9933	ca		dex		                dex
.9934	a9 20		lda #$20	                lda #AscSP
.9936	95 00		sta $00,x	                sta 0,x
.9938	74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.993a					xt_parse:
.993a	20 44 d8	jsr $d844	                jsr underflow_1
.993d	a5 0a		lda $0a		                lda ciblen
.993f	05 0b		ora $0b		                ora ciblen+1
.9941	f0 0c		beq $994f	                beq _abort_parse
.9943	a5 0d		lda $0d		                lda toin+1              ; MSB
.9945	c5 0b		cmp $0b		                cmp ciblen+1
.9947	90 0e		bcc $9957	                bcc _go_parse           ; unsigned comparison
.9949	a5 0c		lda $0c		                lda toin                ; LSB
.994b	c5 0a		cmp $0a		                cmp ciblen
.994d	90 08		bcc $9957	                bcc _go_parse
.994f					_abort_parse:
.994f	ca		dex		                dex
.9950	ca		dex		                dex
.9951	74 00		stz $00,x	                stz 0,x
.9953	74 01		stz $01,x	                stz 1,x
.9955	80 7a		bra $99d1	                bra _done
.9957					_go_parse:
.9957	b5 00		lda $00,x	                lda 0,x
.9959	85 2c		sta $2c		                sta tmptos
.995b	ca		dex		                dex
.995c	ca		dex		                dex
.995d	a5 08		lda $08		                lda cib
.995f	18		clc		                clc
.9960	65 0c		adc $0c		                adc toin        ; LSB
.9962	85 24		sta $24		                sta tmp1
.9964	85 26		sta $26		                sta tmp2
.9966	95 02		sta $02,x	                sta 2,x
.9968	a5 09		lda $09		                lda cib+1
.996a	65 0d		adc $0d		                adc toin+1      ; MSB
.996c	85 25		sta $25		                sta tmp1+1
.996e	85 27		sta $27		                sta tmp2+1
.9970	95 03		sta $03,x	                sta 3,x
.9972	a5 08		lda $08		                lda cib
.9974	18		clc		                clc
.9975	65 0a		adc $0a		                adc ciblen
.9977	85 28		sta $28		                sta tmp3
.9979	a5 09		lda $09		                lda cib+1
.997b	65 0b		adc $0b		                adc ciblen+1
.997d	85 29		sta $29		                sta tmp3+1
.997f	64 2d		stz $2d		                stz tmptos+1
.9981					_loop:
.9981	a5 26		lda $26		                lda tmp2
.9983	c5 28		cmp $28		                cmp tmp3
.9985	d0 06		bne $998d	                bne _not_empty
.9987	a5 27		lda $27		                lda tmp2+1
.9989	c5 29		cmp $29		                cmp tmp3+1
.998b	f0 1d		beq $99aa	                beq _eol
.998d					_not_empty:
.998d	b2 26		lda ($26)	                lda (tmp2)
.998f	a4 2c		ldy $2c		                ldy tmptos
.9991	c0 20		cpy #$20	                cpy #AscSP
.9993	d0 07		bne $999c	                bne _not_whitespace
.9995	20 37 d8	jsr $d837	                jsr is_whitespace
.9998	90 02		bcc $999c	                bcc _not_whitespace
.999a	80 0c		bra $99a8	                bra _found_delimiter
.999c					_not_whitespace:
.999c	c5 2c		cmp $2c		                cmp tmptos
.999e	f0 08		beq $99a8	                beq _found_delimiter
.99a0	e6 26		inc $26		                inc tmp2
.99a2	d0 dd		bne $9981	                bne _loop
.99a4	e6 27		inc $27		                inc tmp2+1
.99a6	80 d9		bra $9981	                bra _loop
.99a8					_found_delimiter:
.99a8	e6 2d		inc $2d		                inc tmptos+1
.99aa					_eol:
.99aa	a5 26		lda $26		                lda tmp2
.99ac	38		sec		                sec
.99ad	e5 24		sbc $24		                sbc tmp1
.99af	95 00		sta $00,x	                sta 0,x
.99b1	a5 27		lda $27		                lda tmp2+1
.99b3	e5 25		sbc $25		                sbc tmp1+1
.99b5	95 01		sta $01,x	                sta 1,x
.99b7	a5 26		lda $26		                lda tmp2
.99b9	38		sec		                sec
.99ba	e5 08		sbc $08		                sbc cib
.99bc	85 0c		sta $0c		                sta toin
.99be	a5 27		lda $27		                lda tmp2+1
.99c0	e5 09		sbc $09		                sbc cib+1
.99c2	85 0d		sta $0d		                sta toin+1
.99c4	a5 0c		lda $0c		                lda toin
.99c6	18		clc		                clc
.99c7	65 2d		adc $2d		                adc tmptos+1
.99c9	85 0c		sta $0c		                sta toin
.99cb	a5 0d		lda $0d		                lda toin+1
.99cd	69 00		adc #$00	                adc #0          ; we only need the carry
.99cf	85 0d		sta $0d		                sta toin+1
.99d1					_done:
.99d1					z_parse_name:
.99d1	60		rts		z_parse:        rts
.99d2					xt_pick:
.99d2	16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99d4	8a		txa		                txa
.99d5	75 00		adc $00,x	                adc 0,x
.99d7	a8		tay		                tay
.99d8	b9 02 00	lda $0002,y	                lda 0002,y
.99db	95 00		sta $00,x	                sta 0,x
.99dd	b9 03 00	lda $0003,y	                lda 0003,y
.99e0	95 01		sta $01,x	                sta 1,x
.99e2	60		rts		z_pick:         rts
.99e3					xt_plus:
.99e3	20 49 d8	jsr $d849	                jsr underflow_2
.99e6	18		clc		                clc
.99e7	b5 00		lda $00,x	                lda 0,x         ; LSB
.99e9	75 02		adc $02,x	                adc 2,x
.99eb	95 02		sta $02,x	                sta 2,x
.99ed	b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99ef	75 03		adc $03,x	                adc 3,x
.99f1	95 03		sta $03,x	                sta 3,x
.99f3	e8		inx		                inx
.99f4	e8		inx		                inx
.99f5	60		rts		z_plus:         rts
.99f6					xt_plus_store:
.99f6	20 49 d8	jsr $d849	                jsr underflow_2
.99f9	b5 00		lda $00,x	                lda 0,x
.99fb	85 24		sta $24		                sta tmp1
.99fd	b5 01		lda $01,x	                lda 1,x
.99ff	85 25		sta $25		                sta tmp1+1
.9a01	a0 00		ldy #$00	                ldy #0          ; LSB
.9a03	b1 24		lda ($24),y	                lda (tmp1),y
.9a05	18		clc		                clc
.9a06	75 02		adc $02,x	                adc 2,x
.9a08	91 24		sta ($24),y	                sta (tmp1),y
.9a0a	c8		iny		                iny             ; MSB
.9a0b	b1 24		lda ($24),y	                lda (tmp1),y
.9a0d	75 03		adc $03,x	                adc 3,x
.9a0f	91 24		sta ($24),y	                sta (tmp1),y
.9a11	e8		inx		                inx
.9a12	e8		inx		                inx
.9a13	e8		inx		                inx
.9a14	e8		inx		                inx
.9a15	60		rts		z_plus_store:   rts
.9a16					xt_postpone:
.9a16	20 df 98	jsr $98df	                jsr xt_parse_name               ; ( -- addr n )
.9a19	b5 00		lda $00,x	                lda 0,x
.9a1b	15 01		ora $01,x	                ora 1,x
.9a1d	d0 05		bne $9a24	                bne +
.9a1f	a9 05		lda #$05	                lda #err_noname
.9a21	4c 5a d8	jmp $d85a	                jmp error
.9a24					+
.9a24	20 db 8f	jsr $8fdb	                jsr xt_find_name                ; ( -- nt | 0 )
.9a27	d0 05		bne $9a2e	                bne +
.9a29	a9 05		lda #$05	                lda #err_noname
.9a2b	4c 5a d8	jmp $d85a	                jmp error
.9a2e					+
.9a2e	b5 00		lda $00,x	                lda 0,x
.9a30	85 24		sta $24		                sta tmp1
.9a32	b5 01		lda $01,x	                lda 1,x
.9a34	85 25		sta $25		                sta tmp1+1
.9a36	20 e1 95	jsr $95e1	                jsr xt_name_to_int              ; ( nt -- xt )
.9a39	e6 24		inc $24		                inc tmp1
.9a3b	d0 02		bne $9a3f	                bne +
.9a3d	e6 25		inc $25		                inc tmp1+1
.9a3f					+
.9a3f	b2 24		lda ($24)	                lda (tmp1)
.9a41	29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a43	f0 05		beq $9a4a	                beq _not_immediate
.9a45	20 ed 87	jsr $87ed	                jsr xt_compile_comma
.9a48	80 0a		bra $9a54	                bra _done
.9a4a					_not_immediate:
.9a4a	20 8a 93	jsr $938a	                jsr xt_literal
.9a4d	a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a4f	a9 ed		lda #$ed	                lda #<xt_compile_comma
.9a51	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.9a54					_done:
.9a54	60		rts		z_postpone:     rts
.9a55					xt_previous:
.9a55	20 34 91	jsr $9134	                jsr xt_get_order
.9a58	20 42 96	jsr $9642	                jsr xt_nip
.9a5b	20 11 98	jsr $9811	                jsr xt_one_minus
.9a5e	20 1b 9d	jsr $9d1b	                jsr xt_set_order
.9a61	60		rts		z_previous:     rts
.9a62					xt_question:
.9a62	20 80 8f	jsr $8f80	                jsr xt_fetch
.9a65	20 36 8c	jsr $8c36	                jsr xt_dot
.9a68	60		rts		z_question:     rts
.9a69					xt_question_dup:
.9a69	20 44 d8	jsr $d844	                jsr underflow_1
.9a6c	b5 00		lda $00,x	                lda 0,x
.9a6e	15 01		ora $01,x	                ora 1,x
.9a70	f0 0a		beq $9a7c	                beq _done
.9a72	ca		dex		                dex
.9a73	ca		dex		                dex
.9a74	b5 02		lda $02,x	                lda 2,x
.9a76	95 00		sta $00,x	                sta 0,x
.9a78	b5 03		lda $03,x	                lda 3,x
.9a7a	95 01		sta $01,x	                sta 1,x
.9a7c					_done:
.9a7c	60		rts		z_question_dup: rts
.9a7d					xt_r_fetch:
.9a7d	7a		ply		                ply             ; LSB
.9a7e	84 24		sty $24		                sty tmp1
.9a80	7a		ply		                ply             ; MSB
.9a81	ca		dex		                dex
.9a82	ca		dex		                dex
.9a83	68		pla		                pla             ; LSB
.9a84	95 00		sta $00,x	                sta 0,x
.9a86	68		pla		                pla             ; MSB
.9a87	95 01		sta $01,x	                sta 1,x
.9a89	48		pha		                pha
.9a8a	b5 00		lda $00,x	                lda 0,x
.9a8c	48		pha		                pha
.9a8d	5a		phy		                phy             ; MSB
.9a8e	a4 24		ldy $24		                ldy tmp1
.9a90	5a		phy		                phy             ; LSB
.9a91	60		rts		z_r_fetch:      rts
.9a92					xt_r_from:
.9a92	68		pla		                pla             ; LSB
.9a93	85 2c		sta $2c		                sta tmptos
.9a95	7a		ply		                ply             ; MSB
.9a96	ca		dex		                dex
.9a97	ca		dex		                dex
.9a98	68		pla		                pla             ; LSB
.9a99	95 00		sta $00,x	                sta 0,x
.9a9b	68		pla		                pla             ; MSB
.9a9c	95 01		sta $01,x	                sta 1,x
.9a9e	5a		phy		                phy             ; MSB
.9a9f	a5 2c		lda $2c		                lda tmptos
.9aa1	48		pha		                pha             ; LSB
.9aa2	60		rts		z_r_from:       rts
.9aa3					xt_r_to_input:
.9aa3	68		pla		                pla
.9aa4	85 24		sta $24		                sta tmp1
.9aa6	68		pla		                pla
.9aa7	85 25		sta $25		                sta tmp1+1
.9aa9	a0 00		ldy #$00	                ldy #0
.9aab					_loop:
.9aab	68		pla		                pla
.9aac	99 06 00	sta $0006,y	                sta insrc,y
.9aaf	c8		iny		                iny
.9ab0	c0 08		cpy #$08	                cpy #8
.9ab2	d0 f7		bne $9aab	                bne _loop
.9ab4	a5 25		lda $25		                lda tmp1+1
.9ab6	48		pha		                pha
.9ab7	a5 24		lda $24		                lda tmp1
.9ab9	48		pha		                pha
.9aba	60		rts		z_r_to_input: 	rts
.9abb					xt_recurse:
.9abb	a0 00		ldy #$00	                ldy #0
.9abd	a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9abf	91 00		sta ($00),y	                sta (cp),y
.9ac1	c8		iny		                iny
.9ac2	24 20		bit $20		                bit status
.9ac4	70 0c		bvs $9ad2	                bvs _nt_in_workword
.9ac6	a5 04		lda $04		                lda workword
.9ac8	91 00		sta ($00),y	                sta (cp),y
.9aca	c8		iny		                iny
.9acb	a5 05		lda $05		                lda workword+1
.9acd	91 00		sta ($00),y	                sta (cp),y
.9acf	c8		iny		                iny
.9ad0	80 1b		bra $9aed	                bra _update_cp
.9ad2					_nt_in_workword:
.9ad2	a5 04		lda $04		                lda workword            ; LSB
.9ad4	18		clc		                clc
.9ad5	69 04		adc #$04	                adc #4
.9ad7	85 24		sta $24		                sta tmp1
.9ad9	a5 05		lda $05		                lda workword+1          ; MSB
.9adb	69 00		adc #$00	                adc #0
.9add	85 25		sta $25		                sta tmp1+1
.9adf	b2 24		lda ($24)	                lda (tmp1)
.9ae1	91 00		sta ($00),y	                sta (cp),y
.9ae3	5a		phy		                phy
.9ae4	a0 01		ldy #$01	                ldy #1
.9ae6	b1 24		lda ($24),y	                lda (tmp1),y
.9ae8	7a		ply		                ply
.9ae9	c8		iny		                iny
.9aea	91 00		sta ($00),y	                sta (cp),y
.9aec	c8		iny		                iny
.9aed					_update_cp:
.9aed	98		tya		                tya
.9aee	18		clc		                clc
.9aef	65 00		adc $00		                adc cp
.9af1	85 00		sta $00		                sta cp
.9af3	90 02		bcc $9af7	                bcc _done
.9af5	e6 01		inc $01		                inc cp+1
.9af7					_done:
.9af7	60		rts		z_recurse:      rts
.9af8					xt_refill:
.9af8	a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9afa	d0 2d		bne $9b29	                bne _src_not_kbd
.9afc	ca		dex		                dex
.9afd	ca		dex		                dex
.9afe	ca		dex		                dex
.9aff	ca		dex		                dex
.9b00	a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9b02	95 02		sta $02,x	                sta 2,x
.9b04	a5 09		lda $09		                lda cib+1
.9b06	95 03		sta $03,x	                sta 3,x
.9b08	64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9b0a	64 0b		stz $0b		                stz ciblen+1
.9b0c	a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9b0e	95 00		sta $00,x	                sta 0,x
.9b10	74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9b12	20 4e 81	jsr $814e	                jsr xt_accept           ; ( addr n1 -- n2)
.9b15	b5 00		lda $00,x	                lda 0,x
.9b17	85 0a		sta $0a		                sta ciblen
.9b19	b5 01		lda $01,x	                lda 1,x
.9b1b	85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b1d	64 0c		stz $0c		                stz toin
.9b1f	64 0d		stz $0d		                stz toin+1
.9b21	a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b23	95 00		sta $00,x	                sta 0,x
.9b25	95 01		sta $01,x	                sta 1,x
.9b27	80 10		bra $9b39	                bra _done
.9b29					_src_not_kbd:
.9b29	1a		inc a		                ina
.9b2a	d0 08		bne $9b34	                bne _src_not_string
.9b2c	ca		dex		                dex
.9b2d	ca		dex		                dex
.9b2e	74 00		stz $00,x	                stz 0,x
.9b30	74 01		stz $01,x	                stz 1,x
.9b32	80 05		bra $9b39	                bra z_refill
.9b34					_src_not_string:
.9b34	a9 01		lda #$01	                lda #err_badsource
.9b36	4c 5a d8	jmp $d85a	                jmp error
.9b39					_done:
.9b39	60		rts		z_refill:       rts
.9b3a					xt_repeat:
.9b3a	20 89 82	jsr $8289	                jsr xt_again
.9b3d	20 72 91	jsr $9172	                jsr xt_here
.9b40	20 ae a1	jsr $a1ae	                jsr xt_swap
.9b43	20 8d a1	jsr $a18d	                jsr xt_store
.9b46	60		rts		z_repeat:       rts
.9b47					xt_right_bracket:
.9b47	a9 ff		lda #$ff	                lda #$FF
.9b49	85 16		sta $16		                sta state
.9b4b	85 17		sta $17		                sta state+1
.9b4d					z_right_bracket:
.9b4d	60		rts		                rts
.9b4e					xt_root_wordlist:
.9b4e	ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b4f	ca		dex		                dex
.9b50	a9 03		lda #$03	                lda #3
.9b52	95 00		sta $00,x	                sta 0,x
.9b54	74 01		stz $01,x	                stz 1,x
.9b56					z_root_wordlist:
.9b56	60		rts		                rts
.9b57					xt_rot:
.9b57	20 4e d8	jsr $d84e	                jsr underflow_3
.9b5a	b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b5c	b5 03		lda $03,x	                lda 3,x
.9b5e	95 05		sta $05,x	                sta 5,x
.9b60	b5 01		lda $01,x	                lda 1,x
.9b62	95 03		sta $03,x	                sta 3,x
.9b64	94 01		sty $01,x	                sty 1,x
.9b66	b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b68	b5 02		lda $02,x	                lda 2,x
.9b6a	95 04		sta $04,x	                sta 4,x
.9b6c	b5 00		lda $00,x	                lda 0,x
.9b6e	95 02		sta $02,x	                sta 2,x
.9b70	94 00		sty $00,x	                sty 0,x
.9b72	60		rts		z_rot:          rts
.9b73					xt_rshift:
.9b73	20 49 d8	jsr $d849	                jsr underflow_2
.9b76	b5 00		lda $00,x	                lda 0,x
.9b78	29 0f		and #$0f	                and #%00001111
.9b7a	f0 08		beq $9b84	                beq _done               ; if 0 shifts, quit
.9b7c	a8		tay		                tay
.9b7d					_loop:
.9b7d	56 03		lsr $03,x	                lsr 3,x
.9b7f	76 02		ror $02,x	                ror 2,x
.9b81	88		dey		                dey
.9b82	d0 f9		bne $9b7d	                bne _loop
.9b84					_done:
.9b84	e8		inx		                inx
.9b85	e8		inx		                inx
.9b86	60		rts		z_rshift:       rts
.9b87					xt_s_backslash_quote:
.9b87	a9 ff		lda #$ff	                lda #$FF
.9b89	85 26		sta $26		                sta tmp2
.9b8b	64 27		stz $27		                stz tmp2+1
.9b8d	20 53 9d	jsr $9d53	                jsr s_quote_start
.9b90					_done:
.9b90					z_s_backslash_quote:
.9b90	60		rts		                rts
.9b91					convert_hex_value:
.9b91	c9 41		cmp #$41	        cmp #'A'
.9b93	90 07		bcc $9b9c	        bcc _digit
.9b95	29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b97	38		sec		        sec
.9b98	e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b9a	80 03		bra $9b9f	        bra _done
.9b9c					_digit:
.9b9c	38		sec		        sec
.9b9d	e9 30		sbc #$30	        sbc #'0'
.9b9f					_done:
.9b9f	60		rts		        rts
.9ba0					xt_search_wordlist:
.9ba0	20 4e d8	jsr $d84e	                jsr underflow_3
.9ba3	a5 1e		lda $1e		                lda up
.9ba5	18		clc		                clc
.9ba6	69 06		adc #$06	                adc #wordlists_offset
.9ba8	85 26		sta $26		                sta tmp2
.9baa	a5 1f		lda $1f		                lda up+1
.9bac	69 00		adc #$00	                adc #0          ; Adding carry
.9bae	85 27		sta $27		                sta tmp2+1
.9bb0	b5 00		lda $00,x	                lda 0,x
.9bb2	0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9bb3	65 26		adc $26		                adc tmp2
.9bb5	85 26		sta $26		                sta tmp2
.9bb7	90 02		bcc $9bbb	                bcc +
.9bb9	e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9bbb					+
.9bbb	e8		inx		                inx
.9bbc	e8		inx		                inx
.9bbd	b5 00		lda $00,x	                lda 0,x
.9bbf	15 01		ora $01,x	                ora 1,x
.9bc1	d0 03		bne $9bc6	                bne _check_wordlist
.9bc3	4c 7e 9c	jmp $9c7e	                jmp _done
.9bc6					_check_wordlist:
.9bc6	a5 26		lda $26		                lda tmp2
.9bc8	05 27		ora $27		                ora tmp2+1
.9bca	d0 03		bne $9bcf	                bne _have_string
.9bcc	4c 7e 9c	jmp $9c7e	                jmp _done
.9bcf					_have_string:
.9bcf	b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bd1	85 24		sta $24		                sta tmp1
.9bd3	e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9bd5	d0 02		bne $9bd9	                bne +
.9bd7	e6 27		inc $27		                inc tmp2+1
.9bd9					+
.9bd9	b2 26		lda ($26)	                lda (tmp2)
.9bdb	85 25		sta $25		                sta tmp1+1
.9bdd	b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9bdf	85 26		sta $26		                sta tmp2
.9be1	b5 03		lda $03,x	                lda 3,x
.9be3	85 27		sta $27		                sta tmp2+1
.9be5					_loop:
.9be5	b2 24		lda ($24)	                lda (tmp1)
.9be7	d5 00		cmp $00,x	                cmp 0,x
.9be9	d0 7b		bne $9c66	                bne _next_entry
.9beb					_compare_string:
.9beb	b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bed	c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bef	b0 07		bcs $9bf8	                bcs _compare_first
.9bf1	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bf3	90 03		bcc $9bf8	                bcc _compare_first
.9bf5	18		clc		                clc
.9bf6	69 20		adc #$20	                adc #$20
.9bf8					_compare_first:
.9bf8	a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9bfa	d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9bfc	d0 68		bne $9c66	                bne _next_entry
.9bfe	b5 00		lda $00,x	                lda 0,x
.9c00	3a		dec a		                dea
.9c01	f0 2c		beq $9c2f	                beq _success
.9c03	a5 24		lda $24		                lda tmp1
.9c05	48		pha		                pha             ; Preserve tmp1 on the return stack.
.9c06	18		clc		                clc
.9c07	69 08		adc #$08	                adc #8
.9c09	85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9c0b	a5 25		lda $25		                lda tmp1+1
.9c0d	48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9c0e	69 00		adc #$00	                adc #0          ; we only need the carry
.9c10	85 25		sta $25		                sta tmp1+1
.9c12	b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9c14	88		dey		                dey
.9c15					_string_loop:
.9c15	b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9c17	c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9c19	b0 07		bcs $9c22	                bcs _check_char
.9c1b	c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9c1d	90 03		bcc $9c22	                bcc _check_char
.9c1f	18		clc		                clc
.9c20	69 20		adc #$20	                adc #$20
.9c22					_check_char:
.9c22	d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c24	d0 3a		bne $9c60	                bne _next_entry_tmp1
.9c26	88		dey		                dey
.9c27	d0 ec		bne $9c15	                bne _string_loop
.9c29					_success_tmp1:
.9c29	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c2a	85 25		sta $25		                sta tmp1+1
.9c2c	68		pla		                pla
.9c2d	85 24		sta $24		                sta tmp1
.9c2f					_success:
.9c2f	e8		inx		                inx
.9c30	e8		inx		                inx
.9c31	a5 24		lda $24		                lda tmp1
.9c33	95 00		sta $00,x	                sta 0,x
.9c35	a5 25		lda $25		                lda tmp1+1
.9c37	95 01		sta $01,x	                sta 1,x
.9c39	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( nt nt )
.9c3c	20 e1 95	jsr $95e1	                jsr xt_name_to_int      ; ( nt xt )
.9c3f	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( xt nt )
.9c42	a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c44	f6 00		inc $00,x	                inc 0,x
.9c46	d0 02		bne $9c4a	                bne +
.9c48	f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c4a					+
.9c4a	a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c4c	29 04		and #$04	                and #IM
.9c4e	d0 08		bne $9c58	                bne _immediate          ; bit set, we're immediate
.9c50	a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c52	95 00		sta $00,x	                sta 0,x
.9c54	95 01		sta $01,x	                sta 1,x
.9c56	80 28		bra $9c80	                bra _done_nodrop
.9c58					_immediate:
.9c58	a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c5a	95 00		sta $00,x	                sta 0,x
.9c5c	74 01		stz $01,x	                stz 1,x
.9c5e	80 20		bra $9c80	                bra _done_nodrop
.9c60					_next_entry_tmp1:
.9c60	68		pla		                pla             ; Restore tmp1 from the return stack.
.9c61	85 25		sta $25		                sta tmp1+1
.9c63	68		pla		                pla
.9c64	85 24		sta $24		                sta tmp1
.9c66					_next_entry:
.9c66	a0 02		ldy #$02	                ldy #2
.9c68	b1 24		lda ($24),y	                lda (tmp1),y
.9c6a	48		pha		                pha
.9c6b	c8		iny		                iny
.9c6c	b1 24		lda ($24),y	                lda (tmp1),y
.9c6e	85 25		sta $25		                sta tmp1+1
.9c70	68		pla		                pla
.9c71	85 24		sta $24		                sta tmp1
.9c73	05 25		ora $25		                ora tmp1+1
.9c75	f0 03		beq $9c7a	                beq _fail_done
.9c77	4c e5 9b	jmp $9be5	                jmp _loop
.9c7a					_fail_done:
.9c7a	74 02		stz $02,x	                stz 2,x         ; failure flag
.9c7c	74 03		stz $03,x	                stz 3,x
.9c7e					_done:
.9c7e	e8		inx		                inx
.9c7f	e8		inx		                inx
.9c80					_done_nodrop:
.9c80					z_search_wordlist:
.9c80	60		rts		                rts
.9c81					xt_see:
.9c81	20 df 98	jsr $98df	                jsr xt_parse_name       ; ( addr u )
.9c84	20 db 8f	jsr $8fdb	                jsr xt_find_name        ; ( nt | 0 )
.9c87	b5 00		lda $00,x	                lda 0,x
.9c89	15 01		ora $01,x	                ora 1,x
.9c8b	d0 05		bne $9c92	                bne +
.9c8d	a9 05		lda #$05	                lda #err_noname
.9c8f	4c 5a d8	jmp $d85a	                jmp error
.9c92					+
.9c92	20 63 89	jsr $8963	                jsr xt_cr
.9c95	a5 18		lda $18		                lda base
.9c97	48		pha		                pha
.9c98	20 7d 91	jsr $917d	                jsr xt_hex
.9c9b	a9 0a		lda #$0a	                lda #str_see_nt
.9c9d	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9ca0	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( nt nt )
.9ca3	20 2e a5	jsr $a52e	                jsr xt_u_dot
.9ca6	20 1e a1	jsr $a11e	                jsr xt_space            ; ( nt )
.9ca9	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( nt nt )
.9cac	20 e1 95	jsr $95e1	                jsr xt_name_to_int      ; ( nt xt )
.9caf	a9 0b		lda #$0b	                lda #str_see_xt
.9cb1	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9cb4	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( nt xt xt )
.9cb7	20 2e a5	jsr $a52e	                jsr xt_u_dot
.9cba	20 63 89	jsr $8963	                jsr xt_cr               ; ( nt xt )
.9cbd	a9 09		lda #$09	                lda #str_see_flags
.9cbf	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9cc2	20 93 98	jsr $9893	                jsr xt_over             ; ( nt xt nt )
.9cc5	20 1d 98	jsr $981d	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9cc8	20 80 8f	jsr $8f80	                jsr xt_fetch            ; ( nt xt flags )
.9ccb	b5 00		lda $00,x	                lda 0,x
.9ccd	a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9ccf					_flag_loop:
.9ccf	48		pha		                pha
.9cd0	29 01		and #$01	                and #%00000001
.9cd2	18		clc		                clc
.9cd3	69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cd5	20 f6 8d	jsr $8df6	                jsr emit_a
.9cd8	20 1e a1	jsr $a11e	                jsr xt_space
.9cdb	68		pla		                pla
.9cdc	6a		ror a		                ror                     ; Next flag
.9cdd	88		dey		                dey
.9cde	d0 ef		bne $9ccf	                bne _flag_loop
.9ce0	20 63 89	jsr $8963	                jsr xt_cr
.9ce3	e8		inx		                inx
.9ce4	e8		inx		                inx                     ; ( nt xt )
.9ce5	a9 0c		lda #$0c	                lda #str_see_size
.9ce7	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9cea	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( xt nt )
.9ced	20 75 a7	jsr $a775	                jsr xt_wordsize         ; ( xt u )
.9cf0	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cf3	20 a5 8a	jsr $8aa5	                jsr xt_decimal
.9cf6	20 2e a5	jsr $a52e	                jsr xt_u_dot            ; ( xt u )
.9cf9	20 7d 91	jsr $917d	                jsr xt_hex
.9cfc	20 63 89	jsr $8963	                jsr xt_cr
.9cff	20 b8 a3	jsr $a3b8	                jsr xt_two_dup          ; ( xt u xt u )
.9d02	20 34 8d	jsr $8d34	                jsr xt_dump
.9d05	20 63 89	jsr $8963	                jsr xt_cr
.9d08	20 3a 8b	jsr $8b3a	                jsr xt_disasm
.9d0b	68		pla		                pla
.9d0c	85 18		sta $18		                sta base
.9d0e	60		rts		z_see:          rts
.9d0f					xt_set_current:
.9d0f	20 44 d8	jsr $d844	                jsr underflow_1
.9d12	a0 04		ldy #$04	                ldy #current_offset
.9d14	b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9d16	91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9d18	e8		inx		                inx
.9d19	e8		inx		                inx
.9d1a	60		rts		z_set_current:  rts
.9d1b					xt_set_order:
.9d1b	a9 ff		lda #$ff	                lda #$FF
.9d1d	d5 01		cmp $01,x	                cmp 1,x
.9d1f	d0 12		bne $9d33	                bne _start
.9d21	d5 00		cmp $00,x	                cmp 0,x
.9d23	d0 0e		bne $9d33	                bne _start
.9d25	ca		dex		                dex             ; Make room for the count.
.9d26	ca		dex		                dex
.9d27	74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d29	a9 03		lda #$03	                lda #3
.9d2b	95 02		sta $02,x	                sta 2,x
.9d2d	74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d2f	a9 01		lda #$01	                lda #1
.9d31	95 00		sta $00,x	                sta 0,x
.9d33					_start:
.9d33	a0 1e		ldy #$1e	                ldy #num_order_offset
.9d35	b5 00		lda $00,x	                lda 0,x
.9d37	91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d39	85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d3b	e8		inx		                inx             ; Drop the count off the data stack.
.9d3c	e8		inx		                inx
.9d3d	a5 24		lda $24		                lda tmp1
.9d3f	f0 0d		beq $9d4e	                beq _done       ; If zero, there are no wordlists.
.9d41	a0 1f		ldy #$1f	                ldy #search_order_offset
.9d43					_loop:
.9d43	b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d45	91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d47	c8		iny		                iny
.9d48	e8		inx		                inx
.9d49	e8		inx		                inx
.9d4a	c6 24		dec $24		                dec tmp1
.9d4c	d0 f5		bne $9d43	                bne _loop
.9d4e					_done:
.9d4e	60		rts		z_set_order:    rts
.9d4f					xt_s_quote:
.9d4f	64 26		stz $26		                stz tmp2
.9d51	64 27		stz $27		                stz tmp2+1
.9d53					s_quote_start:
.9d53	ca		dex		                dex
.9d54	ca		dex		                dex
.9d55	ca		dex		                dex
.9d56	ca		dex		                dex
.9d57	a9 4c		lda #$4c	                lda #$4C
.9d59	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9d5c	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9d5f	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9d62	a5 00		lda $00		                lda cp
.9d64	95 02		sta $02,x	                sta 2,x
.9d66	a5 01		lda $01		                lda cp+1
.9d68	95 03		sta $03,x	                sta 3,x
.9d6a					_savechars_loop:
.9d6a	a5 0d		lda $0d		                lda toin+1              ; MSB
.9d6c	c5 0b		cmp $0b		                cmp ciblen+1
.9d6e	90 2a		bcc $9d9a	                bcc _input_fine         ; unsigned comparison
.9d70	a5 0c		lda $0c		                lda toin                ; LSB
.9d72	c5 0a		cmp $0a		                cmp ciblen
.9d74	90 24		bcc $9d9a	                bcc _input_fine
.9d76	a5 26		lda $26		                lda tmp2
.9d78	48		pha		                pha
.9d79	a5 27		lda $27		                lda tmp2+1
.9d7b	48		pha		                pha
.9d7c	a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d7e	48		pha		                pha
.9d7f	20 f8 9a	jsr $9af8	                jsr xt_refill           ; ( -- f )
.9d82	68		pla		                pla
.9d83	85 28		sta $28		                sta tmp3
.9d85	68		pla		                pla
.9d86	85 27		sta $27		                sta tmp2+1
.9d88	68		pla		                pla
.9d89	85 26		sta $26		                sta tmp2
.9d8b	b5 00		lda $00,x	                lda 0,x
.9d8d	15 01		ora $01,x	                ora 1,x
.9d8f	d0 05		bne $9d96	                bne _refill_ok
.9d91	a9 06		lda #$06	                lda #err_refill
.9d93	4c 5a d8	jmp $d85a	                jmp error
.9d96					_refill_ok:
.9d96	e8		inx		                inx
.9d97	e8		inx		                inx
.9d98	80 d0		bra $9d6a	                bra _savechars_loop
.9d9a					_input_fine:
.9d9a	a5 08		lda $08		                lda cib
.9d9c	18		clc		                clc
.9d9d	65 0c		adc $0c		                adc toin        ; LSB
.9d9f	85 24		sta $24		                sta tmp1
.9da1	a5 09		lda $09		                lda cib+1
.9da3	65 0d		adc $0d		                adc toin+1      ; MSB
.9da5	85 25		sta $25		                sta tmp1+1
.9da7	b2 24		lda ($24)	                lda (tmp1)
.9da9	24 26		bit $26		                bit tmp2
.9dab	30 03		bmi $9db0	                bmi _handle_escapes    ; Only checking bit 7
.9dad	4c 68 9e	jmp $9e68	                jmp _regular_char
.9db0					_handle_escapes:
.9db0	24 27		bit $27		                bit tmp2+1
.9db2	30 03		bmi $9db7	                bmi _escaped
.9db4	4c 5e 9e	jmp $9e5e	                jmp _not_escaped
.9db7					_escaped:
.9db7	70 22		bvs $9ddb	                bvs _check_esc_chars
.9db9	a9 01		lda #$01	                lda #1
.9dbb	24 27		bit $27		                bit tmp2+1
.9dbd	d0 10		bne $9dcf	                bne _esc_x_second_digit
.9dbf	e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9dc1	b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9dc3	20 91 9b	jsr $9b91	                jsr convert_hex_value
.9dc6	0a		asl a		                asl
.9dc7	0a		asl a		                asl
.9dc8	0a		asl a		                asl
.9dc9	0a		asl a		                asl
.9dca	85 28		sta $28		                sta tmp3    ; Save it for later.
.9dcc	4c 6f 9e	jmp $9e6f	                jmp _next_character
.9dcf					_esc_x_second_digit:
.9dcf	64 27		stz $27		                stz tmp2+1
.9dd1	b2 24		lda ($24)	                lda (tmp1)
.9dd3	20 91 9b	jsr $9b91	                jsr convert_hex_value
.9dd6	05 28		ora $28		                ora tmp3
.9dd8	4c 6c 9e	jmp $9e6c	                jmp _save_character
.9ddb					_check_esc_chars:
.9ddb	64 27		stz $27		                stz tmp2+1
.9ddd					_check_esc_a:
.9ddd	c9 61		cmp #$61	                cmp #'a'
.9ddf	d0 05		bne $9de6	                bne _check_esc_b
.9de1	a9 07		lda #$07	                lda #7
.9de3	4c 6c 9e	jmp $9e6c	                jmp _save_character
.9de6					_check_esc_b:
.9de6	c9 62		cmp #$62	                cmp #'b'
.9de8	d0 05		bne $9def	                bne _check_esc_e
.9dea	a9 08		lda #$08	                lda #8
.9dec	4c 6c 9e	jmp $9e6c	                jmp _save_character
.9def					_check_esc_e:
.9def	c9 65		cmp #$65	                cmp #'e'
.9df1	d0 04		bne $9df7	                bne _check_esc_f
.9df3	a9 1b		lda #$1b	                lda #27
.9df5	80 75		bra $9e6c	                bra _save_character
.9df7					_check_esc_f:
.9df7	c9 66		cmp #$66	                cmp #'f'
.9df9	d0 04		bne $9dff	                bne _check_esc_l
.9dfb	a9 0c		lda #$0c	                lda #12
.9dfd	80 6d		bra $9e6c	                bra _save_character
.9dff					_check_esc_l:
.9dff	c9 6c		cmp #$6c	                cmp #'l'
.9e01	d0 04		bne $9e07	                bne _check_esc_m
.9e03	a9 0a		lda #$0a	                lda #10
.9e05	80 65		bra $9e6c	                bra _save_character
.9e07					_check_esc_m:
.9e07	c9 6d		cmp #$6d	                cmp #'m'
.9e09	d0 09		bne $9e14	                bne _check_esc_n
.9e0b	a9 0d		lda #$0d	                lda #13
.9e0d	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9e10	a9 0a		lda #$0a	                lda #10
.9e12	80 58		bra $9e6c	                bra _save_character
.9e14					_check_esc_n:
.9e14	c9 6e		cmp #$6e	                cmp #'n'
.9e16	d0 04		bne $9e1c	                bne _check_esc_q
.9e18	a9 0a		lda #$0a	                lda #10
.9e1a	80 50		bra $9e6c	                bra _save_character
.9e1c					_check_esc_q:
.9e1c	c9 71		cmp #$71	                cmp #'q'
.9e1e	d0 04		bne $9e24	                bne _check_esc_r
.9e20	a9 22		lda #$22	                lda #34
.9e22	80 48		bra $9e6c	                bra _save_character
.9e24					_check_esc_r:
.9e24	c9 72		cmp #$72	                cmp #'r'
.9e26	d0 04		bne $9e2c	                bne _check_esc_t
.9e28	a9 0d		lda #$0d	                lda #13
.9e2a	80 40		bra $9e6c	                bra _save_character
.9e2c					_check_esc_t:
.9e2c	c9 74		cmp #$74	                cmp #'t'
.9e2e	d0 04		bne $9e34	                bne _check_esc_v
.9e30	a9 09		lda #$09	                lda #9
.9e32	80 38		bra $9e6c	                bra _save_character
.9e34					_check_esc_v:
.9e34	c9 76		cmp #$76	                cmp #'v'
.9e36	d0 04		bne $9e3c	                bne _check_esc_z
.9e38	a9 0b		lda #$0b	                lda #11
.9e3a	80 30		bra $9e6c	                bra _save_character
.9e3c					_check_esc_z:
.9e3c	c9 7a		cmp #$7a	                cmp #'z'
.9e3e	d0 04		bne $9e44	                bne _check_esc_quote
.9e40	a9 00		lda #$00	                lda #0
.9e42	80 28		bra $9e6c	                bra _save_character
.9e44					_check_esc_quote:
.9e44	c9 22		cmp #$22	                cmp #$22
.9e46	d0 04		bne $9e4c	                bne _check_esc_x
.9e48	a9 22		lda #$22	                lda #34
.9e4a	80 20		bra $9e6c	                bra _save_character
.9e4c					_check_esc_x:
.9e4c	c9 78		cmp #$78	                cmp #'x'
.9e4e	d0 06		bne $9e56	                bne _check_esc_backslash
.9e50	a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e52	85 27		sta $27		                sta tmp2+1
.9e54	80 19		bra $9e6f	                bra _next_character
.9e56					_check_esc_backslash:
.9e56	c9 5c		cmp #$5c	                cmp #$5C
.9e58	d0 04		bne $9e5e	                bne _not_escaped
.9e5a	a9 5c		lda #$5c	                lda #92
.9e5c	80 0e		bra $9e6c	                bra _save_character
.9e5e					_not_escaped:
.9e5e	c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e60	d0 06		bne $9e68	                bne _regular_char
.9e62	a9 ff		lda #$ff	                lda #$FF
.9e64	85 27		sta $27		                sta tmp2+1
.9e66	80 07		bra $9e6f	                bra _next_character
.9e68					_regular_char:
.9e68	c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e6a	f0 0c		beq $9e78	                beq _found_string_end
.9e6c					_save_character:
.9e6c	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9e6f					_next_character:
.9e6f	e6 0c		inc $0c		                inc toin
.9e71	d0 02		bne $9e75	                bne _savechars_loop_longjump
.9e73	e6 0d		inc $0d		                inc toin+1
.9e75					_savechars_loop_longjump:
.9e75	4c 6a 9d	jmp $9d6a	                jmp _savechars_loop
.9e78					_found_string_end:
.9e78	e6 0c		inc $0c		                inc toin
.9e7a	d0 02		bne $9e7e	                bne +
.9e7c	e6 0d		inc $0d		                inc toin+1
.9e7e					+
.9e7e	a5 00		lda $00		                lda cp
.9e80	38		sec		                sec
.9e81	f5 02		sbc $02,x	                sbc 2,x
.9e83	95 00		sta $00,x	                sta 0,x         ; LSB
.9e85	a5 01		lda $01		                lda cp+1
.9e87	f5 03		sbc $03,x	                sbc 3,x
.9e89	95 01		sta $01,x	                sta 1,x         ; MSB
.9e8b	b5 02		lda $02,x	                lda 2,x
.9e8d	38		sec		                sec
.9e8e	e9 02		sbc #$02	                sbc #2
.9e90	85 24		sta $24		                sta tmp1
.9e92	b5 03		lda $03,x	                lda 3,x
.9e94	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e96	85 25		sta $25		                sta tmp1+1
.9e98	a5 00		lda $00		                lda cp
.9e9a	92 24		sta ($24)	                sta (tmp1)
.9e9c	a0 01		ldy #$01	                ldy #1
.9e9e	a5 01		lda $01		                lda cp+1
.9ea0	91 24		sta ($24),y	                sta (tmp1),y
.9ea2	a5 16		lda $16		                lda state
.9ea4	05 17		ora $17		                ora state+1             ; paranoid
.9ea6	f0 03		beq $9eab	                beq _done
.9ea8	20 8f a0	jsr $a08f	                jsr sliteral_const_str         ; ( addr u -- )
.9eab					_done:
.9eab	60		rts		z_s_quote:      rts
.9eac					xt_s_to_d:
.9eac	20 44 d8	jsr $d844	                jsr underflow_1
.9eaf	ca		dex		                dex
.9eb0	ca		dex		                dex
.9eb1	74 00		stz $00,x	                stz 0,x
.9eb3	74 01		stz $01,x	                stz 1,x
.9eb5	b5 03		lda $03,x	                lda 3,x
.9eb7	10 04		bpl $9ebd	                bpl _done
.9eb9	d6 00		dec $00,x	                dec 0,x
.9ebb	d6 01		dec $01,x	                dec 1,x
.9ebd					_done:
.9ebd	60		rts		z_s_to_d:       rts
.9ebe					xt_save_buffers:
.9ebe	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ec0	b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9ec2	c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9ec4	d0 12		bne $9ed8	                bne _done       ; Either not used or not dirty = done!
.9ec6	20 b3 83	jsr $83b3	                jsr xt_blkbuffer
.9ec9	20 a5 85	jsr $85a5	                jsr xt_buffblocknum
.9ecc	20 80 8f	jsr $8f80	                jsr xt_fetch
.9ecf	20 60 85	jsr $8560	                jsr xt_block_write
.9ed2	a9 01		lda #$01	                lda #1
.9ed4	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9ed6	91 1e		sta ($1e),y	                sta (up),y
.9ed8					_done:
.9ed8	60		rts		z_save_buffers: rts
.9ed9					xt_scr:
.9ed9	ca		dex		                dex
.9eda	ca		dex		                dex
.9edb	18		clc		                clc
.9edc	a5 1e		lda $1e		                lda up
.9ede	69 02		adc #$02	                adc #scr_offset ; Add offset
.9ee0	95 00		sta $00,x	                sta 0,x
.9ee2	a5 1f		lda $1f		                lda up+1
.9ee4	69 00		adc #$00	                adc #0          ; Adding carry
.9ee6	95 01		sta $01,x	                sta 1,x
.9ee8	60		rts		z_scr:          rts
.9ee9					xt_search:
.9ee9	20 53 d8	jsr $d853	                jsr underflow_4
.9eec	b5 00		lda $00,x	                lda 0,x
.9eee	15 01		ora $01,x	                ora 1,x
.9ef0	d0 0b		bne $9efd	                bne _start_search
.9ef2	e8		inx		                inx             ; Remove u2
.9ef3	e8		inx		                inx
.9ef4	a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ef6	95 00		sta $00,x	                sta 0,x
.9ef8	95 01		sta $01,x	                sta 1,x
.9efa	4c 87 9f	jmp $9f87	                jmp z_search
.9efd					_start_search:
.9efd	20 a8 a7	jsr $a7a8	                jsr xt_zero
.9f00					_search_loop:
.9f00	18		clc		                clc
.9f01	b5 00		lda $00,x	                lda 0,x
.9f03	75 02		adc $02,x	                adc 2,x
.9f05	85 24		sta $24		                sta tmp1
.9f07	b5 01		lda $01,x	                lda 1,x
.9f09	75 03		adc $03,x	                adc 3,x
.9f0b	d5 07		cmp $07,x	                cmp 7,x
.9f0d	90 12		bcc $9f21	                bcc _init_comparison ; Obviously less
.9f0f	d0 06		bne $9f17	                bne _not_found
.9f11	b5 06		lda $06,x	                lda 6,x
.9f13	c5 24		cmp $24		                cmp tmp1
.9f15	b0 0a		bcs $9f21	                bcs _init_comparison
.9f17					_not_found:
.9f17	e8		inx		                inx             ; Remove offset
.9f18	e8		inx		                inx
.9f19	e8		inx		                inx             ; Remove u2
.9f1a	e8		inx		                inx
.9f1b	74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9f1d	74 01		stz $01,x	                stz 1,x
.9f1f	80 66		bra $9f87	                bra z_search
.9f21					_init_comparison:
.9f21	18		clc		                clc
.9f22	b5 08		lda $08,x	                lda 8,x
.9f24	75 00		adc $00,x	                adc 0,x
.9f26	85 24		sta $24		                sta tmp1
.9f28	b5 09		lda $09,x	                lda 9,x
.9f2a	75 01		adc $01,x	                adc 1,x
.9f2c	85 25		sta $25		                sta tmp1+1
.9f2e	b5 04		lda $04,x	                lda 4,x
.9f30	85 26		sta $26		                sta tmp2
.9f32	b5 05		lda $05,x	                lda 5,x
.9f34	85 27		sta $27		                sta tmp2+1
.9f36	b5 02		lda $02,x	                lda 2,x
.9f38	85 28		sta $28		                sta tmp3
.9f3a	b5 03		lda $03,x	                lda 3,x
.9f3c	85 29		sta $29		                sta tmp3+1
.9f3e					_comparison_loop:
.9f3e	b2 24		lda ($24)	                lda (tmp1)
.9f40	d2 26		cmp ($26)	                cmp (tmp2)
.9f42	f0 05		beq $9f49	                beq _letters_match
.9f44	20 1d 98	jsr $981d	                jsr xt_one_plus
.9f47	80 b7		bra $9f00	                bra _search_loop
.9f49					_letters_match:
.9f49	e6 24		inc $24		                inc tmp1
.9f4b	d0 02		bne $9f4f	                bne +
.9f4d	e6 25		inc $25		                inc tmp1+1
.9f4f					+
.9f4f	e6 26		inc $26		                inc tmp2
.9f51	d0 02		bne $9f55	                bne +
.9f53	e6 27		inc $27		                inc tmp2+1
.9f55					+
.9f55	a5 28		lda $28		                lda tmp3
.9f57	d0 02		bne $9f5b	                bne +
.9f59	c6 29		dec $29		                dec tmp3+1
.9f5b					+
.9f5b	c6 28		dec $28		                dec tmp3
.9f5d	a5 28		lda $28		                lda tmp3
.9f5f	05 29		ora $29		                ora tmp3+1
.9f61	d0 db		bne $9f3e	                bne _comparison_loop ; Check the next letter
.9f63	18		clc		                clc
.9f64	b5 00		lda $00,x	                lda 0,x
.9f66	75 08		adc $08,x	                adc 8,x
.9f68	95 08		sta $08,x	                sta 8,x
.9f6a	b5 01		lda $01,x	                lda 1,x
.9f6c	75 09		adc $09,x	                adc 9,x
.9f6e	95 09		sta $09,x	                sta 9,x
.9f70	38		sec		                sec
.9f71	b5 06		lda $06,x	                lda 6,x
.9f73	f5 00		sbc $00,x	                sbc 0,x
.9f75	95 06		sta $06,x	                sta 6,x
.9f77	b5 07		lda $07,x	                lda 7,x
.9f79	f5 01		sbc $01,x	                sbc 1,x
.9f7b	95 07		sta $07,x	                sta 7,x
.9f7d	e8		inx		                inx             ; drop offset
.9f7e	e8		inx		                inx
.9f7f	e8		inx		                inx             ; drop u2
.9f80	e8		inx		                inx
.9f81	a9 ff		lda #$ff	                lda #$FF
.9f83	95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f85	95 01		sta $01,x	                sta 1,x
.9f87	60		rts		z_search:       rts
.9f88					xt_semicolon:
.9f88	24 20		bit $20		                bit status
.9f8a	70 11		bvs $9f9d	                bvs _colonword
.9f8c	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f8e	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9f91	ca		dex		                dex
.9f92	ca		dex		                dex
.9f93	a5 04		lda $04		                lda workword
.9f95	95 00		sta $00,x	                sta 0,x
.9f97	a5 05		lda $05		                lda workword+1
.9f99	95 01		sta $01,x	                sta 1,x
.9f9b	80 45		bra $9fe2	                bra _semicolon_done
.9f9d					_colonword:
.9f9d	a0 06		ldy #$06	                ldy #6
.9f9f	a5 00		lda $00		                lda cp
.9fa1	91 04		sta ($04),y	                sta (workword),y
.9fa3	c8		iny		                iny
.9fa4	a5 01		lda $01		                lda cp+1
.9fa6	91 04		sta ($04),y	                sta (workword),y
.9fa8	a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9faa	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.9fad	24 20		bit $20		                bit status
.9faf	10 26		bpl $9fd7	                bpl _new_word   ; Bit 7 is clear = new word
.9fb1	ca		dex		                dex
.9fb2	ca		dex		                dex
.9fb3	ca		dex		                dex
.9fb4	ca		dex		                dex
.9fb5	b2 04		lda ($04)	                lda (workword)
.9fb7	95 00		sta $00,x	                sta 0,x
.9fb9	74 01		stz $01,x	                stz 1,x
.9fbb	a5 04		lda $04		                lda workword
.9fbd	18		clc		                clc
.9fbe	69 08		adc #$08	                adc #8
.9fc0	95 02		sta $02,x	                sta 2,x
.9fc2	a5 05		lda $05		                lda workword+1
.9fc4	69 00		adc #$00	                adc #0                  ; only want carry
.9fc6	95 03		sta $03,x	                sta 3,x
.9fc8	a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9fca	20 80 d8	jsr $d880	                jsr print_string_no_lf
.9fcd	20 03 a5	jsr $a503	                jsr xt_type
.9fd0	20 1e a1	jsr $a11e	                jsr xt_space
.9fd3	a9 80		lda #$80	                lda #%10000000
.9fd5	14 20		trb $20		                trb status
.9fd7					_new_word:
.9fd7	a5 04		lda $04		                lda workword
.9fd9	85 02		sta $02		                sta dp
.9fdb	a5 05		lda $05		                lda workword+1
.9fdd	85 03		sta $03		                sta dp+1
.9fdf	20 99 d7	jsr $d799	                jsr dp_to_current       ; Save the updated DP to the
.9fe2					_semicolon_done:
.9fe2	64 16		stz $16		                stz state
.9fe4	64 17		stz $17		                stz state+1
.9fe6	60		rts		z_semicolon:    rts
.9fe7					xt_sign:
.9fe7	20 44 d8	jsr $d844	                jsr underflow_1
.9fea	b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9fec	30 04		bmi $9ff2	                bmi _minus
.9fee	e8		inx		                inx
.9fef	e8		inx		                inx
.9ff0	80 09		bra $9ffb	                bra _done
.9ff2					_minus:
.9ff2	a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9ff4	95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9ff6	74 01		stz $01,x	                stz 1,x         ; paranoid
.9ff8	20 d7 91	jsr $91d7	                jsr xt_hold
.9ffb					_done:
.9ffb	60		rts		z_sign:         rts
.9ffc					xt_slash:
.9ffc	a9 00		lda #$00	                lda #0
.9ffe	48		pha		                pha
.9fff	80 03		bra $a004	                bra slashmod_common
.a001					xt_slash_mod:
.a001	a9 ff		lda #$ff	                lda #$FF
.a003	48		pha		                pha             ; falls through to _common
.a004					slashmod_common:
.a004	20 70 a3	jsr $a370	                jsr xt_to_r             ; >R
.a007	20 ac 9e	jsr $9eac	                jsr xt_s_to_d           ; S>D
.a00a	20 92 9a	jsr $9a92	                jsr xt_r_from           ; R>
.a00d	20 d5 a0	jsr $a0d5	                jsr xt_sm_slash_rem     ; SM/REM
.a010	68		pla		                pla
.a011	d0 05		bne $a018	                bne _done
.a013	20 ae a1	jsr $a1ae	                jsr xt_swap
.a016	e8		inx		                inx             ; DROP
.a017	e8		inx		                inx
.a018					_done:
.a018					z_slash_mod:
.a018	60		rts		z_slash:        rts
.a019					xt_slash_string:
.a019	20 4e d8	jsr $d84e	                jsr underflow_3
.a01c	18		clc		                clc             ; 3OS+TOS
.a01d	b5 00		lda $00,x	                lda 0,x
.a01f	75 04		adc $04,x	                adc 4,x
.a021	95 04		sta $04,x	                sta 4,x
.a023	b5 01		lda $01,x	                lda 1,x
.a025	75 05		adc $05,x	                adc 5,x
.a027	95 05		sta $05,x	                sta 5,x
.a029	38		sec		                sec             ; NOS-TOS
.a02a	b5 02		lda $02,x	                lda 2,x
.a02c	f5 00		sbc $00,x	                sbc 0,x
.a02e	95 02		sta $02,x	                sta 2,x
.a030	b5 03		lda $03,x	                lda 3,x
.a032	f5 01		sbc $01,x	                sbc 1,x
.a034	95 03		sta $03,x	                sta 3,x
.a036	e8		inx		                inx
.a037	e8		inx		                inx
.a038	60		rts		z_slash_string: rts
.a039					xt_sliteral:
.a039	20 49 d8	jsr $d849	                jsr underflow_2
.a03c	a9 4c		lda #$4c	                lda #$4C
.a03e	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a041	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a044	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a047	8a		txa		                txa
.a048	38		sec		                sec
.a049	e9 06		sbc #$06	                sbc #6
.a04b	aa		tax		                tax
.a04c	b5 08		lda $08,x	                lda 8,x
.a04e	95 04		sta $04,x	                sta 4,x
.a050	b5 09		lda $09,x	                lda 9,x
.a052	95 05		sta $05,x	                sta 5,x
.a054	b5 06		lda $06,x	                lda 6,x
.a056	95 00		sta $00,x	                sta 0,x
.a058	b5 07		lda $07,x	                lda 7,x
.a05a	95 01		sta $01,x	                sta 1,x
.a05c	a5 00		lda $00		                lda cp
.a05e	95 08		sta $08,x	                sta 8,x
.a060	95 02		sta $02,x	                sta 2,x
.a062	a5 01		lda $01		                lda cp+1
.a064	95 09		sta $09,x	                sta 9,x
.a066	95 03		sta $03,x	                sta 3,x
.a068	20 c2 95	jsr $95c2	                jsr xt_move
.a06b	18		clc		                clc
.a06c	a5 00		lda $00		                lda cp
.a06e	75 00		adc $00,x	                adc 0,x
.a070	85 00		sta $00		                sta cp
.a072	a5 01		lda $01		                lda cp+1
.a074	75 01		adc $01,x	                adc 1,x
.a076	85 01		sta $01		                sta cp+1
.a078	b5 02		lda $02,x	                lda 2,x
.a07a	38		sec		                sec
.a07b	e9 02		sbc #$02	                sbc #2
.a07d	85 24		sta $24		                sta tmp1
.a07f	b5 03		lda $03,x	                lda 3,x
.a081	e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a083	85 25		sta $25		                sta tmp1+1
.a085	a5 00		lda $00		                lda cp
.a087	92 24		sta ($24)	                sta (tmp1)
.a089	a0 01		ldy #$01	                ldy #1
.a08b	a5 01		lda $01		                lda cp+1
.a08d	91 24		sta ($24),y	                sta (tmp1),y
.a08f					sliteral_const_str:
.a08f	a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a091	a9 a9		lda #$a9	                lda #<sliteral_runtime
.a093	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.a096	b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a098	b5 02		lda $02,x	                lda 2,x                ; address LSB
.a09a	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a09d	b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a09f	b5 00		lda $00,x	                lda 0,x                ; length LSB
.a0a1	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a0a4	e8		inx		                inx
.a0a5	e8		inx		                inx
.a0a6	e8		inx		                inx
.a0a7	e8		inx		                inx
.a0a8	60		rts		z_sliteral:     rts
.a0a9					sliteral_runtime:
.a0a9	ca		dex		                dex
.a0aa	ca		dex		                dex
.a0ab	ca		dex		                dex
.a0ac	ca		dex		                dex
.a0ad	68		pla		                pla
.a0ae	85 24		sta $24		                sta tmp1        ; LSB of address
.a0b0	68		pla		                pla
.a0b1	85 25		sta $25		                sta tmp1+1      ; MSB of address
.a0b3	a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a0b5	b1 24		lda ($24),y	                lda (tmp1),y
.a0b7	95 02		sta $02,x	                sta 2,x         ; LSB of address
.a0b9	c8		iny		                iny
.a0ba	b1 24		lda ($24),y	                lda (tmp1),y
.a0bc	95 03		sta $03,x	                sta 3,x         ; MSB of address
.a0be	c8		iny		                iny
.a0bf	b1 24		lda ($24),y	                lda (tmp1),y
.a0c1	95 00		sta $00,x	                sta 0,x         ; LSB of length
.a0c3	c8		iny		                iny
.a0c4	b1 24		lda ($24),y	                lda (tmp1),y
.a0c6	95 01		sta $01,x	                sta 1,x         ; MSB of length
.a0c8	18		clc		                clc
.a0c9	a5 24		lda $24		                lda tmp1
.a0cb	69 04		adc #$04	                adc #4
.a0cd	a8		tay		                tay             ; LSB
.a0ce	a5 25		lda $25		                lda tmp1+1
.a0d0	69 00		adc #$00	                adc #0          ; we only need carry
.a0d2	48		pha		                pha             ; MSB
.a0d3	5a		phy		                phy
.a0d4	60		rts		                rts
.a0d5					xt_sm_slash_rem:
.a0d5	20 4e d8	jsr $d84e	                jsr underflow_3 ; contains double number
.a0d8	b5 03		lda $03,x	                lda 3,x
.a0da	48		pha		                pha
.a0db	b5 01		lda $01,x	                lda 1,x
.a0dd	55 03		eor $03,x	                eor 3,x
.a0df	48		pha		                pha
.a0e0	20 39 81	jsr $8139	                jsr xt_abs
.a0e3	e8		inx		                inx             ; pretend we pushed n1 to R
.a0e4	e8		inx		                inx
.a0e5	20 86 8a	jsr $8a86	                jsr xt_dabs
.a0e8	ca		dex		                dex
.a0e9	ca		dex		                dex
.a0ea	20 ba a5	jsr $a5ba	                jsr xt_um_slash_mod     ; UM/MOD
.a0ed	68		pla		                pla
.a0ee	10 03		bpl $a0f3	                bpl +
.a0f0	20 23 96	jsr $9623	                jsr xt_negate
.a0f3					+
.a0f3	68		pla		                pla
.a0f4	10 07		bpl $a0fd	                bpl _done
.a0f6	e8		inx		                inx             ; pretend we pushed quotient to R
.a0f7	e8		inx		                inx
.a0f8	20 23 96	jsr $9623	                jsr xt_negate
.a0fb	ca		dex		                dex
.a0fc	ca		dex		                dex
.a0fd					_done:
.a0fd	60		rts		z_sm_slash_rem: rts
.a0fe					xt_source:
.a0fe	ca		dex		                dex
.a0ff	ca		dex		                dex
.a100	a5 08		lda $08		                lda cib
.a102	95 00		sta $00,x	                sta 0,x
.a104	a5 09		lda $09		                lda cib+1
.a106	95 01		sta $01,x	                sta 1,x
.a108	ca		dex		                dex
.a109	ca		dex		                dex
.a10a	a5 0a		lda $0a		                lda ciblen
.a10c	95 00		sta $00,x	                sta 0,x
.a10e	a5 0b		lda $0b		                lda ciblen+1
.a110	95 01		sta $01,x	                sta 1,x
.a112	60		rts		z_source:       rts
.a113					xt_source_id:
.a113	ca		dex		                dex
.a114	ca		dex		                dex
.a115	a5 06		lda $06		                lda insrc
.a117	95 00		sta $00,x	                sta 0,x
.a119	a5 07		lda $07		                lda insrc+1
.a11b	95 01		sta $01,x	                sta 1,x
.a11d	60		rts		z_source_id:    rts
.a11e					xt_space:
.a11e	a9 20		lda #$20	                lda #AscSP
.a120	20 f6 8d	jsr $8df6	                jsr emit_a
.a123	60		rts		z_space:        rts
.a124					xt_spaces:
.a124	20 44 d8	jsr $d844	                jsr underflow_1
.a127	20 a8 a7	jsr $a7a8	                jsr xt_zero
.a12a	20 18 95	jsr $9518	                jsr xt_max
.a12d	b5 00		lda $00,x	                lda 0,x
.a12f	15 01		ora $01,x	                ora 1,x
.a131	f0 2a		beq $a15d	                beq _done
.a133	b4 01		ldy $01,x	                ldy 1,x
.a135	d0 0c		bne $a143	                bne _lots_of_spaces
.a137	b4 00		ldy $00,x	                ldy 0,x
.a139					_quick_loop:
.a139	a9 20		lda #$20	                lda #AscSP
.a13b	20 f6 8d	jsr $8df6	                jsr emit_a
.a13e	88		dey		                dey
.a13f	f0 1c		beq $a15d	                beq _done
.a141	80 f6		bra $a139	                bra _quick_loop
.a143					_lots_of_spaces:
.a143	b4 00		ldy $00,x	                ldy 0,x
.a145					_first_slow_loop:
.a145	f0 08		beq $a14f	                beq _slow_outer_loop
.a147	a9 20		lda #$20	                lda #AscSP
.a149	20 f6 8d	jsr $8df6	                jsr emit_a
.a14c	88		dey		                dey
.a14d	80 f6		bra $a145	                bra _first_slow_loop
.a14f					_slow_outer_loop:
.a14f	a0 00		ldy #$00	                ldy #00
.a151					_slow_inner_loop:
.a151	a9 20		lda #$20	                lda #AscSP
.a153	20 f6 8d	jsr $8df6	                jsr emit_a
.a156	88		dey		                dey
.a157	d0 f8		bne $a151	                bne _slow_inner_loop
.a159	d6 01		dec $01,x	                dec 1,x
.a15b	d0 f2		bne $a14f	                bne _slow_outer_loop
.a15d					_done:
.a15d	e8		inx		                inx             ; drop
.a15e	e8		inx		                inx
.a15f	60		rts		z_spaces:       rts
.a160					xt_star:
.a160	20 49 d8	jsr $d849	                jsr underflow_2
.a163	20 fc a5	jsr $a5fc	                jsr xt_um_star
.a166	e8		inx		                inx
.a167	e8		inx		                inx
.a168	60		rts		z_star:         rts
.a169					xt_star_slash:
.a169	20 72 a1	jsr $a172	                jsr xt_star_slash_mod
.a16c	20 ae a1	jsr $a1ae	                jsr xt_swap
.a16f	e8		inx		                inx
.a170	e8		inx		                inx
.a171					z_star_slash:
.a171	60		rts		                rts
.a172					xt_star_slash_mod:
.a172	20 4e d8	jsr $d84e	                jsr underflow_3
.a175	20 70 a3	jsr $a370	                jsr xt_to_r
.a178	20 8e 94	jsr $948e	                jsr xt_m_star
.a17b	20 92 9a	jsr $9a92	                jsr xt_r_from
.a17e	20 d5 a0	jsr $a0d5	                jsr xt_sm_slash_rem
.a181					z_star_slash_mod:
.a181	60		rts		                rts
.a182					xt_state:
.a182	ca		dex		                dex
.a183	ca		dex		                dex
.a184	a9 16		lda #$16	                lda #<state
.a186	95 00		sta $00,x	                sta 0,x
.a188	a9 00		lda #$00	                lda #>state
.a18a	95 01		sta $01,x	                sta 1,x
.a18c	60		rts		z_state:        rts
.a18d					xt_store:
.a18d	20 49 d8	jsr $d849	                jsr underflow_2
.a190	b5 02		lda $02,x	                lda 2,x         ; LSB
.a192	81 00		sta ($00,x)	                sta (0,x)
.a194	f6 00		inc $00,x	                inc 0,x
.a196	d0 02		bne $a19a	                bne +
.a198	f6 01		inc $01,x	                inc 1,x
.a19a					+
.a19a	b5 03		lda $03,x	                lda 3,x         ; MSB
.a19c	81 00		sta ($00,x)	                sta (0,x)
.a19e	e8		inx		                inx             ; 2DROP
.a19f	e8		inx		                inx
.a1a0	e8		inx		                inx
.a1a1	e8		inx		                inx
.a1a2	60		rts		z_store:        rts
.a1a3					xt_strip_underflow:
.a1a3	ca		dex		                dex
.a1a4	ca		dex		                dex
.a1a5	a9 1c		lda #$1c	                lda #<uf_strip
.a1a7	95 00		sta $00,x	                sta 0,x
.a1a9	a9 00		lda #$00	                lda #>uf_strip
.a1ab	95 01		sta $01,x	                sta 1,x
.a1ad					z_strip_underflow:
.a1ad	60		rts		                rts
.a1ae					xt_swap:
.a1ae	20 49 d8	jsr $d849	                jsr underflow_2
.a1b1	b5 00		lda $00,x	                lda 0,x         ; LSB
.a1b3	b4 02		ldy $02,x	                ldy 2,x
.a1b5	95 02		sta $02,x	                sta 2,x
.a1b7	94 00		sty $00,x	                sty 0,x
.a1b9	b5 01		lda $01,x	                lda 1,x         ; MSB
.a1bb	b4 03		ldy $03,x	                ldy 3,x
.a1bd	95 03		sta $03,x	                sta 3,x
.a1bf	94 01		sty $01,x	                sty 1,x
.a1c1	60		rts		z_swap:         rts
.a1c2					xt_then:
.a1c2	20 72 91	jsr $9172	                jsr xt_here
.a1c5	20 ae a1	jsr $a1ae	                jsr xt_swap
.a1c8	20 8d a1	jsr $a18d	                jsr xt_store
.a1cb	60		rts		z_then:         rts
.a1cc					xt_thru:
.a1cc	20 49 d8	jsr $d849	                jsr underflow_2
.a1cf	b5 01		lda $01,x	                lda 1,x
.a1d1	48		pha		                pha
.a1d2	b5 00		lda $00,x	                lda 0,x
.a1d4	48		pha		                pha
.a1d5	e8		inx		                inx
.a1d6	e8		inx		                inx
.a1d7					_thru_loop:
.a1d7	b5 01		lda $01,x	                lda 1,x
.a1d9	48		pha		                pha
.a1da	b5 00		lda $00,x	                lda 0,x
.a1dc	48		pha		                pha
.a1dd	20 b7 93	jsr $93b7	                jsr xt_load
.a1e0	68		pla		                pla
.a1e1	85 24		sta $24		                sta tmp1
.a1e3	68		pla		                pla
.a1e4	85 25		sta $25		                sta tmp1+1
.a1e6	68		pla		                pla
.a1e7	85 26		sta $26		                sta tmp2
.a1e9	68		pla		                pla
.a1ea	85 27		sta $27		                sta tmp2+1
.a1ec	c5 25		cmp $25		                cmp tmp1+1
.a1ee	d0 08		bne $a1f8	                bne _next_screen
.a1f0	a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a1f2	c5 24		cmp $24		                cmp tmp1
.a1f4	d0 02		bne $a1f8	                bne _next_screen
.a1f6	80 18		bra $a210	                bra _done       ; We just did the last screen.
.a1f8					_next_screen:
.a1f8	a5 27		lda $27		                lda tmp2+1
.a1fa	48		pha		                pha
.a1fb	a5 26		lda $26		                lda tmp2
.a1fd	48		pha		                pha
.a1fe	e6 24		inc $24		                inc tmp1
.a200	d0 02		bne $a204	                bne +
.a202	e6 25		inc $25		                inc tmp1+1
.a204					+
.a204	ca		dex		                dex
.a205	ca		dex		                dex
.a206	a5 24		lda $24		                lda tmp1
.a208	95 00		sta $00,x	                sta 0,x
.a20a	a5 25		lda $25		                lda tmp1+1
.a20c	95 01		sta $01,x	                sta 1,x
.a20e	80 c7		bra $a1d7	                bra _thru_loop
.a210					_done:
.a210	60		rts		z_thru:         rts
.a211					xt_tick:
.a211	20 df 98	jsr $98df	                jsr xt_parse_name       ; ( -- addr u )
.a214	b5 00		lda $00,x	                lda 0,x
.a216	15 01		ora $01,x	                ora 1,x
.a218	d0 05		bne $a21f	                bne +
.a21a	a9 05		lda #$05	                lda #err_noname
.a21c	4c 5a d8	jmp $d85a	                jmp error
.a21f					+
.a21f	20 db 8f	jsr $8fdb	                jsr xt_find_name        ; ( addr u -- nt )
.a222	b5 00		lda $00,x	                lda 0,x
.a224	15 01		ora $01,x	                ora 1,x
.a226	d0 05		bne $a22d	                bne +
.a228	a9 08		lda #$08	                lda #err_syntax
.a22a	4c 5a d8	jmp $d85a	                jmp error
.a22d					+
.a22d	20 e1 95	jsr $95e1	                jsr xt_name_to_int      ; ( nt -- xt )
.a230	60		rts		z_tick:         rts
.a231					xt_to:
.a231	20 11 a2	jsr $a211	                jsr xt_tick             ; ( [n] xt )
.a234	b5 00		lda $00,x	                lda 0,x                 ; LSB
.a236	18		clc		                clc
.a237	69 03		adc #$03	                adc #3
.a239	85 24		sta $24		                sta tmp1
.a23b	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a23d	69 00		adc #$00	                adc #0                  ; we just want the carry
.a23f	85 25		sta $25		                sta tmp1+1
.a241	e8		inx		                inx
.a242	e8		inx		                inx                     ; ( [n] )
.a243	a5 16		lda $16		                lda state
.a245	05 17		ora $17		                ora state+1
.a247	f0 34		beq $a27d	                beq _interpret
.a249	a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a24b	a9 b5		lda #$b5	                lda #$B5
.a24d	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a250	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a252	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a255	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a257	a5 24		lda $24		                lda tmp1
.a259	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a25c	a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a25e	a9 b5		lda #$b5	                lda #$B5
.a260	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a263	a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a265	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.a268	e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a26a	d0 02		bne $a26e	                bne +
.a26c	e6 25		inc $25		                inc tmp1+1
.a26e					+
.a26e	a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a270	a5 24		lda $24		                lda tmp1
.a272	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a275	a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a277	98		tya		                tya
.a278	20 f3 d6	jsr $d6f3	                jsr cmpl_word
.a27b	80 0f		bra $a28c	                bra _done
.a27d					_interpret:
.a27d	20 44 d8	jsr $d844	                jsr underflow_1
.a280	b5 00		lda $00,x	                lda 0,x
.a282	92 24		sta ($24)	                sta (tmp1)              ; LSB
.a284	a0 01		ldy #$01	                ldy #1
.a286	b5 01		lda $01,x	                lda 1,x                 ; MSB
.a288	91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a28a	e8		inx		                inx                     ; DROP
.a28b	e8		inx		                inx
.a28c					_done:
.a28c	60		rts		z_to:           rts
.a28d					xt_to_body:
.a28d	20 44 d8	jsr $d844	                jsr underflow_1
.a290	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( xt xt )
.a293	20 78 92	jsr $9278	                jsr xt_int_to_name      ; ( xt nt )
.a296	f6 00		inc $00,x	                inc 0,x
.a298	d0 02		bne $a29c	                bne +
.a29a	f6 01		inc $01,x	                inc 1,x
.a29c					+
.a29c	a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a29e	29 20		and #$20	                and #HC
.a2a0	f0 0d		beq $a2af	                beq _no_cfa
.a2a2	18		clc		                clc
.a2a3	b5 02		lda $02,x	                lda 2,x         ; LSB
.a2a5	69 03		adc #$03	                adc #3
.a2a7	95 02		sta $02,x	                sta 2,x
.a2a9	b5 03		lda $03,x	                lda 3,x         ; MSB
.a2ab	69 00		adc #$00	                adc #0          ; we conly care about the carry
.a2ad	95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a2af					_no_cfa:
.a2af	e8		inx		                inx             ; get rid of the nt
.a2b0	e8		inx		                inx
.a2b1					_done:
.a2b1	60		rts		z_to_body:      rts
.a2b2					xt_to_in:
.a2b2	ca		dex		                dex
.a2b3	ca		dex		                dex
.a2b4	a9 0c		lda #$0c	                lda #<toin
.a2b6	95 00		sta $00,x	                sta 0,x
.a2b8	a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a2ba	95 01		sta $01,x	                sta 1,x
.a2bc	60		rts		z_to_in:        rts
.a2bd					xt_to_number:
.a2bd	20 53 d8	jsr $d853	                jsr underflow_4
.a2c0	b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a2c2	85 36		sta $36		                sta scratch
.a2c4	b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a2c6	85 37		sta $37		                sta scratch+1
.a2c8	b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a2ca	85 38		sta $38		                sta scratch+2
.a2cc	b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a2ce	85 39		sta $39		                sta scratch+3
.a2d0	ca		dex		                dex
.a2d1	ca		dex		                dex
.a2d2					_loop:
.a2d2	a1 04		lda ($04,x)	                lda (4,x)
.a2d4	95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a2d6	74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2d8	20 05 8b	jsr $8b05	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a2db	b5 00		lda $00,x	                lda 0,x
.a2dd	d0 04		bne $a2e3	                bne _digit_ok
.a2df	e8		inx		                inx
.a2e0	e8		inx		                inx
.a2e1	80 67		bra $a34a	                bra _done       ; ( ud-lo ud-hi addr u char )
.a2e3					_digit_ok:
.a2e3	b5 02		lda $02,x	                lda 2,x
.a2e5	85 3a		sta $3a		                sta scratch+4
.a2e7	b5 03		lda $03,x	                lda 3,x
.a2e9	85 3b		sta $3b		                sta scratch+5
.a2eb	a5 38		lda $38		                lda scratch+2
.a2ed	95 02		sta $02,x	                sta 2,x         ; NOS
.a2ef	a5 39		lda $39		                lda scratch+3
.a2f1	95 03		sta $03,x	                sta 3,x
.a2f3	a5 18		lda $18		                lda base
.a2f5	95 00		sta $00,x	                sta 0,x         ; TOS
.a2f7	74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a2f9	20 fc a5	jsr $a5fc	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2fc	b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2fe	85 3c		sta $3c		                sta scratch+6
.a300	b5 03		lda $03,x	                lda 3,x
.a302	85 3d		sta $3d		                sta scratch+7
.a304	a5 36		lda $36		                lda scratch
.a306	95 02		sta $02,x	                sta 2,x
.a308	a5 37		lda $37		                lda scratch+1
.a30a	95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a30c	a5 18		lda $18		                lda base
.a30e	95 00		sta $00,x	                sta 0,x
.a310	74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a312	20 fc a5	jsr $a5fc	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a315	b5 00		lda $00,x	                lda 0,x
.a317	85 38		sta $38		                sta scratch+2
.a319	b5 01		lda $01,x	                lda 1,x
.a31b	85 39		sta $39		                sta scratch+3
.a31d	b5 02		lda $02,x	                lda 2,x
.a31f	85 36		sta $36		                sta scratch
.a321	b5 03		lda $03,x	                lda 3,x
.a323	85 37		sta $37		                sta scratch+1
.a325	18		clc		                clc
.a326	a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a328	65 3a		adc $3a		                adc scratch+4   ; n LSB
.a32a	85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a32c	a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a32e	65 3b		adc $3b		                adc scratch+5   ; n MSB
.a330	85 37		sta $37		                sta scratch+1
.a332	a5 38		lda $38		                lda scratch+2   ; LSB
.a334	65 3c		adc $3c		                adc scratch+6
.a336	85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a338	a5 39		lda $39		                lda scratch+3   ; MSB
.a33a	65 3d		adc $3d		                adc scratch+7
.a33c	85 39		sta $39		                sta scratch+3
.a33e	e8		inx		                inx
.a33f	e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a340	f6 04		inc $04,x	                inc 4,x
.a342	d0 02		bne $a346	                bne +
.a344	f6 05		inc $05,x	                inc 5,x
.a346					+
.a346	d6 02		dec $02,x	                dec 2,x
.a348	d0 88		bne $a2d2	                bne _loop
.a34a					_done:
.a34a	e8		inx		                inx
.a34b	e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a34c	a5 36		lda $36		                lda scratch     ; new ud-lo
.a34e	95 06		sta $06,x	                sta 6,x
.a350	a5 37		lda $37		                lda scratch+1
.a352	95 07		sta $07,x	                sta 7,x
.a354	a5 38		lda $38		                lda scratch+2
.a356	95 04		sta $04,x	                sta 4,x
.a358	a5 39		lda $39		                lda scratch+3
.a35a	95 05		sta $05,x	                sta 5,x
.a35c	60		rts		z_to_number:    rts
.a35d					xt_to_order:
.a35d	20 70 a3	jsr $a370	                jsr xt_to_r
.a360	20 34 91	jsr $9134	                jsr xt_get_order
.a363	20 92 9a	jsr $9a92	                jsr xt_r_from
.a366	20 ae a1	jsr $a1ae	                jsr xt_swap
.a369	20 1d 98	jsr $981d	                jsr xt_one_plus
.a36c	20 1b 9d	jsr $9d1b	                jsr xt_set_order
.a36f	60		rts		z_to_order:     rts
.a370					xt_to_r:
.a370	68		pla		                pla             ; LSB
.a371	85 2c		sta $2c		                sta tmptos
.a373	7a		ply		                ply             ; MSB
.a374	20 44 d8	jsr $d844	                jsr underflow_1
.a377	b5 01		lda $01,x	                lda 1,x         ; MSB
.a379	48		pha		                pha
.a37a	b5 00		lda $00,x	                lda 0,x         ; LSB
.a37c	48		pha		                pha
.a37d	e8		inx		                inx
.a37e	e8		inx		                inx
.a37f	5a		phy		                phy             ; MSB
.a380	a5 2c		lda $2c		                lda tmptos
.a382	48		pha		                pha             ; LSB
.a383	60		rts		z_to_r:         rts
.a384					xt_true:
.a384	ca		dex		                dex
.a385	ca		dex		                dex
.a386	a9 ff		lda #$ff	                lda #$FF
.a388	95 00		sta $00,x	                sta 0,x
.a38a	95 01		sta $01,x	                sta 1,x
.a38c	60		rts		z_true:         rts
.a38d					xt_tuck:
.a38d	20 49 d8	jsr $d849	                jsr underflow_2
.a390	ca		dex		                dex
.a391	ca		dex		                dex
.a392	b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a394	b5 02		lda $02,x	                lda 2,x
.a396	95 04		sta $04,x	                sta 4,x
.a398	94 02		sty $02,x	                sty 2,x
.a39a	95 00		sta $00,x	                sta 0,x
.a39c	b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a39e	b5 03		lda $03,x	                lda 3,x
.a3a0	95 05		sta $05,x	                sta 5,x
.a3a2	94 03		sty $03,x	                sty 3,x         ; bba
.a3a4	95 01		sta $01,x	                sta 1,x         ; baa
.a3a6	60		rts		z_tuck:         rts
.a3a7					xt_assembler_wordlist:
.a3a7					xt_two:
.a3a7	ca		dex		                dex
.a3a8	ca		dex		                dex
.a3a9	a9 02		lda #$02	                lda #2
.a3ab	95 00		sta $00,x	                sta 0,x
.a3ad	74 01		stz $01,x	                stz 1,x
.a3af					z_assembler_wordlist:
.a3af	60		rts		z_two:          rts
.a3b0					xt_two_drop:
.a3b0	20 49 d8	jsr $d849	                jsr underflow_2
.a3b3	e8		inx		                inx
.a3b4	e8		inx		                inx
.a3b5	e8		inx		                inx
.a3b6	e8		inx		                inx
.a3b7	60		rts		z_two_drop:     rts
.a3b8					xt_two_dup:
.a3b8	20 49 d8	jsr $d849	                jsr underflow_2
.a3bb	ca		dex		                dex
.a3bc	ca		dex		                dex
.a3bd	ca		dex		                dex
.a3be	ca		dex		                dex
.a3bf	b5 04		lda $04,x	                lda 4,x         ; TOS
.a3c1	95 00		sta $00,x	                sta 0,x
.a3c3	b5 05		lda $05,x	                lda 5,x
.a3c5	95 01		sta $01,x	                sta 1,x
.a3c7	b5 06		lda $06,x	                lda 6,x         ; NOS
.a3c9	95 02		sta $02,x	                sta 2,x
.a3cb	b5 07		lda $07,x	                lda 7,x
.a3cd	95 03		sta $03,x	                sta 3,x
.a3cf	60		rts		z_two_dup:      rts
.a3d0					xt_two_fetch:
.a3d0	20 44 d8	jsr $d844	                jsr underflow_1
.a3d3	b5 00		lda $00,x	                lda 0,x
.a3d5	85 24		sta $24		                sta tmp1
.a3d7	b4 01		ldy $01,x	                ldy 1,x
.a3d9	84 25		sty $25		                sty tmp1+1
.a3db	ca		dex		                dex             ; reuse one stack element
.a3dc	ca		dex		                dex
.a3dd	b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a3df	95 00		sta $00,x	                sta 0,x
.a3e1	a0 01		ldy #$01	                ldy #1          ; copy next
.a3e3	b1 24		lda ($24),y	                lda (tmp1),y
.a3e5	95 01		sta $01,x	                sta 1,x
.a3e7	c8		iny		                iny             ; copy next
.a3e8	b1 24		lda ($24),y	                lda (tmp1),y
.a3ea	95 02		sta $02,x	                sta 2,x
.a3ec	c8		iny		                iny             ; copy next
.a3ed	b1 24		lda ($24),y	                lda (tmp1),y
.a3ef	95 03		sta $03,x	                sta 3,x
.a3f1	60		rts		z_two_fetch:    rts
.a3f2					xt_two_over:
.a3f2	20 53 d8	jsr $d853	                jsr underflow_4
.a3f5	ca		dex		                dex
.a3f6	ca		dex		                dex
.a3f7	ca		dex		                dex
.a3f8	ca		dex		                dex
.a3f9	b5 08		lda $08,x	                lda 8,x
.a3fb	95 00		sta $00,x	                sta 0,x
.a3fd	b5 09		lda $09,x	                lda 9,x
.a3ff	95 01		sta $01,x	                sta 1,x
.a401	b5 0a		lda $0a,x	                lda 10,x
.a403	95 02		sta $02,x	                sta 2,x
.a405	b5 0b		lda $0b,x	                lda 11,x
.a407	95 03		sta $03,x	                sta 3,x
.a409	60		rts		z_two_over:     rts
.a40a					xt_two_r_fetch:
.a40a	ca		dex		                dex
.a40b	ca		dex		                dex
.a40c	ca		dex		                dex
.a40d	ca		dex		                dex
.a40e	8a		txa		                txa
.a40f	ba		tsx		                tsx
.a410	da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a411	7a		ply		                ply
.a412	aa		tax		                tax
.a413	b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a416	95 00		sta $00,x	                sta 0,x
.a418	b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a41b	95 01		sta $01,x	                sta 1,x
.a41d	b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a420	95 02		sta $02,x	                sta 2,x
.a422	b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a425	95 03		sta $03,x	                sta 3,x
.a427	60		rts		z_two_r_fetch:  rts
.a428					xt_two_r_from:
.a428	68		pla		                pla                     ; LSB
.a429	85 24		sta $24		                sta tmp1
.a42b	68		pla		                pla                     ; MSB
.a42c	85 25		sta $25		                sta tmp1+1
.a42e	ca		dex		                dex
.a42f	ca		dex		                dex
.a430	ca		dex		                dex
.a431	ca		dex		                dex
.a432	68		pla		                pla                     ; LSB
.a433	95 00		sta $00,x	                sta 0,x
.a435	68		pla		                pla                     ; MSB
.a436	95 01		sta $01,x	                sta 1,x
.a438	68		pla		                pla                     ; LSB
.a439	95 02		sta $02,x	                sta 2,x
.a43b	68		pla		                pla                     ; MSB
.a43c	95 03		sta $03,x	                sta 3,x
.a43e	a5 25		lda $25		                lda tmp1+1              ; MSB
.a440	48		pha		                pha
.a441	a5 24		lda $24		                lda tmp1                ; LSB
.a443	48		pha		                pha
.a444	60		rts		z_two_r_from:   rts
.a445					xt_two_slash:
.a445	20 44 d8	jsr $d844	                jsr underflow_1
.a448	b5 01		lda $01,x	                lda 1,x
.a44a	0a		asl a		                asl                     ; save the sign
.a44b	76 01		ror $01,x	                ror 1,x
.a44d	76 00		ror $00,x	                ror 0,x
.a44f	60		rts		z_two_slash:    rts
.a450					xt_two_star:
.a450					xt_cells:
.a450	20 44 d8	jsr $d844	                jsr underflow_1
.a453	16 00		asl $00,x	                asl 0,x
.a455	36 01		rol $01,x	                rol 1,x
.a457					z_cells:
.a457	60		rts		z_two_star:     rts
.a458					xt_two_store:
.a458	20 4e d8	jsr $d84e	                jsr underflow_3
.a45b	b5 00		lda $00,x	                lda 0,x
.a45d	85 24		sta $24		                sta tmp1
.a45f	b4 01		ldy $01,x	                ldy 1,x
.a461	84 25		sty $25		                sty tmp1+1
.a463	e8		inx		                inx
.a464	e8		inx		                inx
.a465	b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a467	92 24		sta ($24)	                sta (tmp1)
.a469	b5 01		lda $01,x	                lda 1,x         ; copy next
.a46b	a0 01		ldy #$01	                ldy #1
.a46d	91 24		sta ($24),y	                sta (tmp1),y
.a46f	b5 02		lda $02,x	                lda 2,x         ; copy next
.a471	c8		iny		                iny
.a472	91 24		sta ($24),y	                sta (tmp1),y
.a474	b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a476	c8		iny		                iny
.a477	91 24		sta ($24),y	                sta (tmp1),y
.a479	e8		inx		                inx             ; 2DROP
.a47a	e8		inx		                inx
.a47b	e8		inx		                inx
.a47c	e8		inx		                inx
.a47d	60		rts		z_two_store:    rts
.a47e					xt_two_swap:
.a47e	20 53 d8	jsr $d853	                jsr underflow_4
.a481	b5 00		lda $00,x	                lda 0,x
.a483	b4 04		ldy $04,x	                ldy 4,x
.a485	95 04		sta $04,x	                sta 4,x
.a487	94 00		sty $00,x	                sty 0,x
.a489	b5 01		lda $01,x	                lda 1,x
.a48b	b4 05		ldy $05,x	                ldy 5,x
.a48d	95 05		sta $05,x	                sta 5,x
.a48f	94 01		sty $01,x	                sty 1,x
.a491	b5 02		lda $02,x	                lda 2,x
.a493	b4 06		ldy $06,x	                ldy 6,x
.a495	95 06		sta $06,x	                sta 6,x
.a497	94 02		sty $02,x	                sty 2,x
.a499	b5 03		lda $03,x	                lda 3,x
.a49b	b4 07		ldy $07,x	                ldy 7,x
.a49d	95 07		sta $07,x	                sta 7,x
.a49f	94 03		sty $03,x	                sty 3,x
.a4a1	60		rts		z_two_swap:     rts
.a4a2					xt_two_to_r:
.a4a2	68		pla		                pla             ; LSB
.a4a3	85 24		sta $24		                sta tmp1
.a4a5	68		pla		                pla             ; MSB
.a4a6	85 25		sta $25		                sta tmp1+1
.a4a8	20 49 d8	jsr $d849	                jsr underflow_2
.a4ab	b5 03		lda $03,x	                lda 3,x         ; MSB
.a4ad	48		pha		                pha
.a4ae	b5 02		lda $02,x	                lda 2,x         ; LSB
.a4b0	48		pha		                pha
.a4b1	b5 01		lda $01,x	                lda 1,x         ; MSB
.a4b3	48		pha		                pha
.a4b4	b5 00		lda $00,x	                lda 0,x         ; LSB
.a4b6	48		pha		                pha
.a4b7	e8		inx		                inx
.a4b8	e8		inx		                inx
.a4b9	e8		inx		                inx
.a4ba	e8		inx		                inx
.a4bb	a5 25		lda $25		                lda tmp1+1      ; MSB
.a4bd	48		pha		                pha
.a4be	a5 24		lda $24		                lda tmp1        ; LSB
.a4c0	48		pha		                pha
.a4c1	60		rts		z_two_to_r:     rts
.a4c2					xt_two_constant:
.a4c2	20 49 d8	jsr $d849	                jsr underflow_2
.a4c5	20 69 89	jsr $8969	                jsr xt_create
.a4c8	20 ae a1	jsr $a1ae	                jsr xt_swap
.a4cb	20 6e 87	jsr $876e	                jsr xt_comma
.a4ce	20 6e 87	jsr $876e	                jsr xt_comma
.a4d1	20 04 8c	jsr $8c04	                jsr does_runtime    ; does> turns into these two routines.
.a4d4	20 2d d7	jsr $d72d	                jsr dodoes
.a4d7	20 af 8d	jsr $8daf	                jsr xt_dup
.a4da	20 80 8f	jsr $8f80	                jsr xt_fetch
.a4dd	20 ae a1	jsr $a1ae	                jsr xt_swap
.a4e0	20 21 86	jsr $8621	                jsr xt_cell_plus
.a4e3	20 80 8f	jsr $8f80	                jsr xt_fetch
.a4e6	60		rts		z_two_constant: rts
.a4e7					xt_two_literal:
.a4e7	20 49 d8	jsr $d849	                jsr underflow_2 ; double number
.a4ea	20 ae a1	jsr $a1ae	                jsr xt_swap
.a4ed	20 8a 93	jsr $938a	                jsr xt_literal
.a4f0	20 8a 93	jsr $938a	                jsr xt_literal
.a4f3	60		rts		z_two_literal:  rts
.a4f4					xt_two_variable:
.a4f4	20 69 89	jsr $8969	                jsr xt_create
.a4f7	ca		dex		                dex
.a4f8	ca		dex		                dex
.a4f9	a9 04		lda #$04	                lda #4
.a4fb	95 00		sta $00,x	                sta 0,x
.a4fd	74 01		stz $01,x	                stz 1,x
.a4ff	20 ab 82	jsr $82ab	                jsr xt_allot
.a502	60		rts		z_two_variable: rts
.a503					xt_type:
.a503	20 49 d8	jsr $d849	                jsr underflow_2
.a506	b5 02		lda $02,x	                lda 2,x
.a508	85 24		sta $24		                sta tmp1
.a50a	b5 03		lda $03,x	                lda 3,x
.a50c	85 25		sta $25		                sta tmp1+1
.a50e					_loop:
.a50e	b5 00		lda $00,x	                lda 0,x
.a510	15 01		ora $01,x	                ora 1,x
.a512	f0 15		beq $a529	                beq _done
.a514	b2 24		lda ($24)	                lda (tmp1)
.a516	20 f6 8d	jsr $8df6	                jsr emit_a      ; avoids stack foolery
.a519	e6 24		inc $24		                inc tmp1
.a51b	d0 02		bne $a51f	                bne +
.a51d	e6 25		inc $25		                inc tmp1+1
.a51f					+
.a51f	b5 00		lda $00,x	                lda 0,x
.a521	d0 02		bne $a525	                bne +
.a523	d6 01		dec $01,x	                dec 1,x
.a525					+
.a525	d6 00		dec $00,x	                dec 0,x
.a527	80 e5		bra $a50e	                bra _loop
.a529					_done:
.a529	e8		inx		                inx
.a52a	e8		inx		                inx
.a52b	e8		inx		                inx
.a52c	e8		inx		                inx
.a52d	60		rts		z_type:         rts
.a52e					xt_u_dot:
.a52e	20 44 d8	jsr $d844	                jsr underflow_1
.a531	20 b1 d8	jsr $d8b1	                jsr print_u
.a534	a9 20		lda #$20	                lda #AscSP
.a536	20 f6 8d	jsr $8df6	                jsr emit_a
.a539	60		rts		z_u_dot:        rts
.a53a					xt_u_dot_r:
.a53a	20 49 d8	jsr $d849	                jsr underflow_2
.a53d	20 70 a3	jsr $a370	                jsr xt_to_r
.a540	20 a8 a7	jsr $a7a8	                jsr xt_zero
.a543	20 5a 93	jsr $935a	                jsr xt_less_number_sign
.a546	20 de 97	jsr $97de	                jsr xt_number_sign_s
.a549	20 bc 97	jsr $97bc	                jsr xt_number_sign_greater
.a54c	20 92 9a	jsr $9a92	                jsr xt_r_from
.a54f	20 93 98	jsr $9893	                jsr xt_over
.a552	20 50 95	jsr $9550	                jsr xt_minus
.a555	20 24 a1	jsr $a124	                jsr xt_spaces
.a558	20 03 a5	jsr $a503	                jsr xt_type
.a55b	60		rts		z_u_dot_r:      rts
.a55c					xt_u_greater_than:
.a55c	20 49 d8	jsr $d849	                jsr underflow_2
.a55f	b5 00		lda $00,x	                lda 0,x
.a561	d5 02		cmp $02,x	                cmp 2,x
.a563	b5 01		lda $01,x	                lda 1,x
.a565	f5 03		sbc $03,x	                sbc 3,x
.a567	e8		inx		                inx
.a568	e8		inx		                inx
.a569	a9 00		lda #$00	                lda #0
.a56b	69 ff		adc #$ff	                adc #$ff
.a56d	95 00		sta $00,x	                sta 0,x         ; store flag
.a56f	95 01		sta $01,x	                sta 1,x
.a571	60		rts		z_u_greater_than:    rts
.a572					xt_u_less_than:
.a572	20 49 d8	jsr $d849	                jsr underflow_2
.a575	b5 02		lda $02,x	                lda 2,x
.a577	d5 00		cmp $00,x	                cmp 0,x
.a579	b5 03		lda $03,x	                lda 3,x
.a57b	f5 01		sbc $01,x	                sbc 1,x
.a57d	e8		inx		                inx
.a57e	e8		inx		                inx
.a57f	a9 00		lda #$00	                lda #0
.a581	69 ff		adc #$ff	                adc #$ff
.a583	95 00		sta $00,x	                sta 0,x         ; store flag
.a585	95 01		sta $01,x	                sta 1,x
.a587	60		rts		z_u_less_than:    rts
.a588					xt_ud_dot:
.a588	20 49 d8	jsr $d849	                jsr underflow_2 ; double number
.a58b	20 5a 93	jsr $935a	                jsr xt_less_number_sign
.a58e	20 de 97	jsr $97de	                jsr xt_number_sign_s
.a591	20 bc 97	jsr $97bc	                jsr xt_number_sign_greater
.a594	20 03 a5	jsr $a503	                jsr xt_type
.a597	20 1e a1	jsr $a11e	                jsr xt_space
.a59a	60		rts		z_ud_dot:        rts
.a59b					xt_ud_dot_r:
.a59b	20 4e d8	jsr $d84e	                jsr underflow_3
.a59e	20 70 a3	jsr $a370	                jsr xt_to_r
.a5a1	20 5a 93	jsr $935a	                jsr xt_less_number_sign
.a5a4	20 de 97	jsr $97de	                jsr xt_number_sign_s
.a5a7	20 bc 97	jsr $97bc	                jsr xt_number_sign_greater
.a5aa	20 92 9a	jsr $9a92	                jsr xt_r_from
.a5ad	20 93 98	jsr $9893	                jsr xt_over
.a5b0	20 50 95	jsr $9550	                jsr xt_minus
.a5b3	20 24 a1	jsr $a124	                jsr xt_spaces
.a5b6	20 03 a5	jsr $a503	                jsr xt_type
.a5b9	60		rts		z_ud_dot_r:      rts
.a5ba					xt_um_slash_mod:
.a5ba	20 4e d8	jsr $d84e	                jsr underflow_3
.a5bd	b5 00		lda $00,x	                lda 0,x
.a5bf	15 01		ora $01,x	                ora 1,x
.a5c1	d0 05		bne $a5c8	                bne _not_zero
.a5c3	a9 04		lda #$04	                lda #err_divzero
.a5c5	4c 5a d8	jmp $d85a	                jmp error
.a5c8					_not_zero:
.a5c8	a9 11		lda #$11	                lda #17
.a5ca	85 2c		sta $2c		                sta tmptos
.a5cc					_loop:
.a5cc	36 04		rol $04,x	                rol 4,x
.a5ce	36 05		rol $05,x	                rol 5,x
.a5d0	c6 2c		dec $2c		                dec tmptos
.a5d2	f0 22		beq $a5f6	                beq _done
.a5d4	36 02		rol $02,x	                rol 2,x
.a5d6	36 03		rol $03,x	                rol 3,x
.a5d8	64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a5da	26 24		rol $24		                rol tmp1
.a5dc	38		sec		                sec
.a5dd	b5 02		lda $02,x	                lda 2,x
.a5df	f5 00		sbc $00,x	                sbc 0,x
.a5e1	85 25		sta $25		                sta tmp1+1
.a5e3	b5 03		lda $03,x	                lda 3,x
.a5e5	f5 01		sbc $01,x	                sbc 1,x
.a5e7	a8		tay		                tay
.a5e8	a5 24		lda $24		                lda tmp1
.a5ea	e9 00		sbc #$00	                sbc #0
.a5ec	90 de		bcc $a5cc	                bcc _loop
.a5ee	a5 25		lda $25		                lda tmp1+1
.a5f0	95 02		sta $02,x	                sta 2,x
.a5f2	94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a5f4	80 d6		bra $a5cc	                bra _loop
.a5f6					_done:
.a5f6	e8		inx		                inx
.a5f7	e8		inx		                inx
.a5f8	20 ae a1	jsr $a1ae	                jsr xt_swap
.a5fb	60		rts		z_um_slash_mod: rts
.a5fc					xt_um_star:
.a5fc	20 49 d8	jsr $d849	                jsr underflow_2
.a5ff	18		clc		                clc
.a600	b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a602	e9 00		sbc #$00	                sbc #0
.a604	85 26		sta $26		                sta tmp2
.a606	b5 01		lda $01,x	                lda 1,x
.a608	e9 00		sbc #$00	                sbc #0
.a60a	90 31		bcc $a63d	                bcc _zero       ; is TOS zero?
.a60c	85 27		sta $27		                sta tmp2+1
.a60e	a9 00		lda #$00	                lda #0
.a610	85 24		sta $24		                sta tmp1
.a612	86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a614	ca		dex		                dex
.a615	ca		dex		                dex
.a616					_outer_loop:
.a616	a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a618	56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a61a					_inner_loop:
.a61a	90 0c		bcc $a628	                bcc _no_add
.a61c	85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a61e	a5 24		lda $24		                lda tmp1
.a620	65 26		adc $26		                adc tmp2
.a622	85 24		sta $24		                sta tmp1
.a624	a5 25		lda $25		                lda tmp1+1
.a626	65 27		adc $27		                adc tmp2+1
.a628					_no_add:
.a628	6a		ror a		                ror
.a629	66 24		ror $24		                ror tmp1
.a62b	76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a62d	88		dey		                dey
.a62e	d0 ea		bne $a61a	                bne _inner_loop ; go back for one more shift?
.a630	e8		inx		                inx
.a631	e4 28		cpx $28		                cpx tmp3
.a633	d0 e1		bne $a616	                bne _outer_loop ; go back for eight more shifts?
.a635	95 01		sta $01,x	                sta 1,x
.a637	a5 24		lda $24		                lda tmp1
.a639	95 00		sta $00,x	                sta 0,x
.a63b	80 04		bra $a641	                bra _done
.a63d					_zero:
.a63d	74 02		stz $02,x	                stz 2,x
.a63f	74 03		stz $03,x	                stz 3,x
.a641					_done:
.a641	60		rts		z_um_star:      rts
.a642					xt_unloop:
.a642	68		pla		                pla
.a643	68		pla		                pla
.a644	68		pla		                pla
.a645	68		pla		                pla
.a646	68		pla		                pla
.a647	68		pla		                pla
.a648	60		rts		z_unloop:       rts
.a649					xt_until:
.a649	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a64b	a9 14		lda #$14	                lda #<zero_branch_runtime
.a64d	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.a650	20 6e 87	jsr $876e	                jsr xt_comma
.a653	60		rts		z_until:        rts
.a654					xt_unused:
.a654	ca		dex		                dex
.a655	ca		dex		                dex
.a656	a9 00		lda #$00	                lda #<cp_end
.a658	38		sec		                sec
.a659	e5 00		sbc $00		                sbc cp
.a65b	95 00		sta $00,x	                sta 0,x
.a65d	a9 7c		lda #$7c	                lda #>cp_end
.a65f	e5 01		sbc $01		                sbc cp+1
.a661	95 01		sta $01,x	                sta 1,x
.a663	60		rts		z_unused:       rts
.a664					xt_update:
.a664	a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a666	b1 1e		lda ($1e),y	                lda (up),y
.a668	09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a66a	91 1e		sta ($1e),y	                sta (up),y
.a66c	60		rts		z_update:       rts
.a66d					xt_useraddr:
.a66d	ca		dex		                dex
.a66e	ca		dex		                dex
.a66f	a9 1e		lda #$1e	                lda #<up
.a671	95 00		sta $00,x	                sta 0,x
.a673	a9 00		lda #$00	                lda #>up
.a675	95 01		sta $01,x	                sta 1,x
.a677	60		rts		z_useraddr:     rts
.a678					xt_variable:
.a678	20 69 89	jsr $8969	                jsr xt_create
.a67b	a9 00		lda #$00	                lda #0
.a67d	92 00		sta ($00)	                sta (cp)
.a67f	e6 00		inc $00		                inc cp
.a681	d0 02		bne $a685	                bne +
.a683	e6 01		inc $01		                inc cp+1
.a685					+
.a685	92 00		sta ($00)	                sta (cp)
.a687	e6 00		inc $00		                inc cp
.a689	d0 02		bne $a68d	                bne +
.a68b	e6 01		inc $01		                inc cp+1
.a68d					+
.a68d	20 31 89	jsr $8931	                jsr adjust_z
.a690	60		rts		z_variable:     rts
.a691					xt_while:
.a691	a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a693	a9 14		lda #$14	                lda #<zero_branch_runtime
.a695	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.a698	20 72 91	jsr $9172	                jsr xt_here
.a69b	20 a8 a7	jsr $a7a8	                jsr xt_zero
.a69e	20 6e 87	jsr $876e	                jsr xt_comma
.a6a1	20 ae a1	jsr $a1ae	                jsr xt_swap
.a6a4	60		rts		z_while:        rts
.a6a5					xt_within:
.a6a5	20 4e d8	jsr $d84e	                jsr underflow_3
.a6a8	20 93 98	jsr $9893	                jsr xt_over
.a6ab	20 50 95	jsr $9550	                jsr xt_minus
.a6ae	20 70 a3	jsr $a370	                jsr xt_to_r
.a6b1	20 50 95	jsr $9550	                jsr xt_minus
.a6b4	20 92 9a	jsr $9a92	                jsr xt_r_from
.a6b7	20 72 a5	jsr $a572	                jsr xt_u_less_than
.a6ba	60		rts		z_within:       rts
.a6bb					xt_word:
.a6bb	20 44 d8	jsr $d844	                jsr underflow_1
.a6be	a4 0c		ldy $0c		                ldy toin                ; >IN
.a6c0					_loop:
.a6c0	c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a6c2	f0 09		beq $a6cd	                beq _found_char
.a6c4	b1 08		lda ($08),y	                lda (cib),y
.a6c6	d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a6c8	d0 03		bne $a6cd	                bne _found_char
.a6ca	c8		iny		                iny
.a6cb	80 f3		bra $a6c0	                bra _loop
.a6cd					_found_char:
.a6cd	84 0c		sty $0c		                sty toin
.a6cf	20 3a 99	jsr $993a	                jsr xt_parse            ; Returns ( addr u )
.a6d2	b5 00		lda $00,x	                lda 0,x
.a6d4	92 00		sta ($00)	                sta (cp)                ; Save length of string
.a6d6	48		pha		                pha                     ; Keep copy of length for later
.a6d7	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( addr u u )
.a6da	a5 00		lda $00		                lda cp
.a6dc	18		clc		                clc
.a6dd	69 01		adc #$01	                adc #1
.a6df	95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a6e1	a5 01		lda $01		                lda cp+1
.a6e3	69 00		adc #$00	                adc #0
.a6e5	95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a6e7	20 c2 95	jsr $95c2	                jsr xt_move
.a6ea	ca		dex		                dex
.a6eb	ca		dex		                dex
.a6ec	a5 00		lda $00		                lda cp
.a6ee	95 00		sta $00,x	                sta 0,x
.a6f0	a5 01		lda $01		                lda cp+1
.a6f2	95 01		sta $01,x	                sta 1,x
.a6f4	68		pla		                pla                     ; length of string
.a6f5	18		clc		                clc
.a6f6	65 00		adc $00		                adc cp
.a6f8	85 00		sta $00		                sta cp
.a6fa	a5 01		lda $01		                lda cp+1
.a6fc	69 00		adc #$00	                adc #0                  ; we only need the carry
.a6fe	85 01		sta $01		                sta cp+1
.a700	60		rts		z_word:         rts
.a701					xt_wordlist:
.a701	a0 05		ldy #$05	                ldy #num_wordlists_offset
.a703	b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a705	c9 0c		cmp #$0c	                cmp #max_wordlists
.a707	d0 05		bne $a70e	                bne _ok
.a709	a9 0b		lda #$0b	                lda #err_wordlist
.a70b	4c 5a d8	jmp $d85a	                jmp error
.a70e					_ok:
.a70e	1a		inc a		                ina             ; Increment the wordlist#
.a70f	91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a711	ca		dex		                dex             ; and put it on the stack.
.a712	ca		dex		                dex
.a713	95 00		sta $00,x	                sta 0,x
.a715	74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a717	60		rts		z_wordlist:     rts
.a718					xt_words:
.a718	20 63 89	jsr $8963	                jsr xt_cr
.a71b	a9 00		lda #$00	                lda #0
.a71d	48		pha		                pha
.a71e	ca		dex		                dex                     ; Make room on the stack for
.a71f	ca		dex		                dex                     ; a dictionary pointer.
.a720	64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a722					_wordlist_loop:
.a722	a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a724	a5 28		lda $28		                lda tmp3
.a726	d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a728	d0 02		bne $a72c	                bne _have_wordlist
.a72a	80 45		bra $a771	                bra _words_done
.a72c					_have_wordlist:
.a72c	18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a72d	69 1f		adc #$1f	                adc #search_order_offset
.a72f	a8		tay		                tay
.a730	b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a732	0a		asl a		                asl                     ; Turn offset into cells offset.
.a733	18		clc		                clc
.a734	69 06		adc #$06	                adc #wordlists_offset
.a736	a8		tay		                tay
.a737	b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a739	95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a73b	c8		iny		                iny
.a73c	b1 1e		lda ($1e),y	                lda (up),y
.a73e	95 01		sta $01,x	                sta 1,x
.a740					_loop:
.a740	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( nt nt )
.a743	20 fe 95	jsr $95fe	                jsr xt_name_to_string   ; ( nt addr u )
.a746	68		pla		                pla
.a747	18		clc		                clc
.a748	75 00		adc $00,x	                adc 0,x
.a74a	1a		inc a		                ina                     ; don't forget the space between words
.a74b	c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a74d	90 06		bcc $a755	                bcc +
.a74f	20 63 89	jsr $8963	                jsr xt_cr
.a752	b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a754	1a		inc a		                ina                     ; with length of this word.
.a755					+
.a755	48		pha		                pha
.a756	20 03 a5	jsr $a503	                jsr xt_type             ; ( nt )
.a759	a9 20		lda #$20	                lda #AscSP
.a75b	20 f6 8d	jsr $8df6	                jsr emit_a
.a75e	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+
.a761	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+
.a764	20 80 8f	jsr $8f80	                jsr xt_fetch            ; @ ( nt+1 )
.a767	b5 00		lda $00,x	                lda 0,x
.a769	15 01		ora $01,x	                ora 1,x
.a76b	d0 d3		bne $a740	                bne _loop
.a76d	e6 28		inc $28		                inc tmp3
.a76f	80 b1		bra $a722	                bra _wordlist_loop
.a771					_words_done:
.a771	68		pla		                pla                     ; dump counter
.a772	e8		inx		                inx
.a773	e8		inx		                inx
.a774	60		rts		z_words:        rts
.a775					xt_wordsize:
.a775	20 44 d8	jsr $d844	                jsr underflow_1
.a778	b5 00		lda $00,x	                lda 0,x
.a77a	85 24		sta $24		                sta tmp1
.a77c	b5 01		lda $01,x	                lda 1,x
.a77e	85 25		sta $25		                sta tmp1+1
.a780	a0 06		ldy #$06	                ldy #6
.a782	b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a784	88		dey		                dey
.a785	88		dey		                dey
.a786	38		sec		                sec
.a787	f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a789	95 00		sta $00,x	                sta 0,x
.a78b	a0 07		ldy #$07	                ldy #7
.a78d	b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a78f	88		dey		                dey
.a790	88		dey		                dey
.a791	f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a793	95 01		sta $01,x	                sta 1,x
.a795	60		rts		z_wordsize:     rts
.a796					xt_xor:
.a796	20 49 d8	jsr $d849	                jsr underflow_2
.a799	b5 00		lda $00,x	                lda 0,x
.a79b	55 02		eor $02,x	                eor 2,x
.a79d	95 02		sta $02,x	                sta 2,x
.a79f	b5 01		lda $01,x	                lda 1,x
.a7a1	55 03		eor $03,x	                eor 3,x
.a7a3	95 03		sta $03,x	                sta 3,x
.a7a5	e8		inx		                inx
.a7a6	e8		inx		                inx
.a7a7	60		rts		z_xor:          rts
.a7a8					xt_case:
.a7a8					xt_forth_wordlist:
.a7a8					xt_zero:
.a7a8	ca		dex		                dex             ; push
.a7a9	ca		dex		                dex
.a7aa	74 00		stz $00,x	                stz 0,x
.a7ac	74 01		stz $01,x	                stz 1,x
.a7ae					z_case:
.a7ae					z_forth_wordlist:
.a7ae					z_zero:
.a7ae	60		rts		                rts
.a7af					xt_zero_equal:
.a7af	20 44 d8	jsr $d844	                jsr underflow_1
.a7b2	b5 00		lda $00,x	                lda 0,x
.a7b4	15 01		ora $01,x	                ora 1,x
.a7b6	f0 04		beq $a7bc	                beq _zero
.a7b8	a9 00		lda #$00	                lda #0
.a7ba	80 02		bra $a7be	                bra _store
.a7bc					_zero:
.a7bc	a9 ff		lda #$ff	                lda #$ff
.a7be					_store:
.a7be	95 00		sta $00,x	                sta 0,x
.a7c0	95 01		sta $01,x	                sta 1,x
.a7c2	60		rts		z_zero_equal:   rts
.a7c3					xt_zero_greater:
.a7c3	20 44 d8	jsr $d844	                jsr underflow_1
.a7c6	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a7c8	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7ca	30 05		bmi $a7d1	                bmi _done       ; TOS is negative, keep FLASE
.a7cc	15 00		ora $00,x	                ora 0,x
.a7ce	f0 01		beq $a7d1	                beq _done       ; TOS is zero, keep FALSE
.a7d0	88		dey		                dey             ; TOS is postive, make true
.a7d1					_done:
.a7d1	98		tya		                tya
.a7d2	95 00		sta $00,x	                sta 0,x
.a7d4	95 01		sta $01,x	                sta 1,x
.a7d6	60		rts		z_zero_greater: rts
.a7d7					xt_zero_less:
.a7d7	20 44 d8	jsr $d844	                jsr underflow_1
.a7da	a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a7dc	b5 01		lda $01,x	                lda 1,x         ; MSB
.a7de	10 01		bpl $a7e1	                bpl _done       ; TOS is positive, so keep FALSE
.a7e0	88		dey		                dey             ; TOS is negative, make TRUE
.a7e1					_done:
.a7e1	98		tya		                tya
.a7e2	95 00		sta $00,x	                sta 0,x
.a7e4	95 01		sta $01,x	                sta 1,x
.a7e6	60		rts		z_zero_less:    rts
.a7e7					xt_zero_unequal:
.a7e7	20 44 d8	jsr $d844	                jsr underflow_1
.a7ea	a0 00		ldy #$00	                ldy #0          ; default false
.a7ec	b5 00		lda $00,x	                lda 0,x
.a7ee	15 01		ora $01,x	                ora 1,x
.a7f0	f0 01		beq $a7f3	                beq _got_zero
.a7f2	88		dey		                dey
.a7f3					_got_zero:
.a7f3	98		tya		                tya
.a7f4	95 00		sta $00,x	                sta 0,x
.a7f6	95 01		sta $01,x	                sta 1,x
.a7f8	60		rts		z_zero_unequal: rts
.a7f9					xt_editor_screen_helper:
.a7f9	20 af 8d	jsr $8daf	                jsr xt_dup
.a7fc	20 d9 9e	jsr $9ed9	                jsr xt_scr
.a7ff	20 8d a1	jsr $a18d	                jsr xt_store
.a802	20 b5 85	jsr $85b5	                jsr xt_buffer
.a805					z_editor_screen_helper:
.a805	60		rts		                rts
.a806					xt_editor_enter_screen:
.a806	20 f9 a7	jsr $a7f9	                jsr xt_editor_screen_helper
.a809	20 2e 8d	jsr $8d2e	                jsr xt_drop
.a80c	64 2e		stz $2e		                stz editor1
.a80e					_prompt_loop:
.a80e	ca		dex		                dex
.a80f	ca		dex		                dex
.a810	a5 2e		lda $2e		                lda editor1
.a812	95 00		sta $00,x	                sta 0,x
.a814	74 01		stz $01,x	                stz 1,x
.a816	20 db a8	jsr $a8db	                jsr xt_editor_o
.a819	e6 2e		inc $2e		                inc editor1
.a81b	a9 10		lda #$10	                lda #16
.a81d	c5 2e		cmp $2e		                cmp editor1
.a81f	d0 ed		bne $a80e	                bne _prompt_loop
.a821					z_editor_enter_screen:
.a821	60		rts		                rts
.a822					xt_editor_erase_screen:
.a822	20 f9 a7	jsr $a7f9	                jsr xt_editor_screen_helper
.a825	ca		dex		                dex
.a826	ca		dex		                dex
.a827	74 00		stz $00,x	                stz 0,x
.a829	a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a82b	95 01		sta $01,x	                sta 1,x
.a82d	20 ea 8e	jsr $8eea	                jsr xt_blank
.a830	20 64 a6	jsr $a664	                jsr xt_update
.a833					z_editor_erase_screen:
.a833	60		rts		                rts
.a834					xt_editor_el:
.a834	20 c2 a8	jsr $a8c2	                jsr xt_editor_line
.a837	ca		dex		                dex
.a838	ca		dex		                dex
.a839	a9 40		lda #$40	                lda #64
.a83b	95 00		sta $00,x	                sta 0,x
.a83d	74 01		stz $01,x	                stz 1,x
.a83f	20 ea 8e	jsr $8eea	                jsr xt_blank
.a842	20 64 a6	jsr $a664	                jsr xt_update
.a845	60		rts		z_editor_el:    rts
.a846					xt_editor_l:
.a846	ca		dex		                dex             ; Put SCR on the stack.
.a847	ca		dex		                dex
.a848	a0 02		ldy #$02	                ldy #scr_offset
.a84a	b1 1e		lda ($1e),y	                lda (up),y
.a84c	95 00		sta $00,x	                sta 0,x
.a84e	c8		iny		                iny
.a84f	b1 1e		lda ($1e),y	                lda (up),y
.a851	95 01		sta $01,x	                sta 1,x
.a853	20 c1 83	jsr $83c1	                jsr xt_block    ; Get the current screen.
.a856	20 63 89	jsr $8963	                jsr xt_cr
.a859	80 08		bra $a863	                bra _after_screen_msg
.a85b					_screen_msg:
>a85b	53 63 72 65 65 6e 20 23		                .text "Screen #"
.a863					_after_screen_msg:
.a863	20 a9 a0	jsr $a0a9	                jsr sliteral_runtime
>a866	5b a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a86a	20 03 a5	jsr $a503	                jsr xt_type
.a86d	20 d9 9e	jsr $9ed9	                jsr xt_scr
.a870	20 80 8f	jsr $8f80	                jsr xt_fetch
.a873	ca		dex		                dex
.a874	ca		dex		                dex
.a875	a9 04		lda #$04	                lda #4          ; four spaces
.a877	95 00		sta $00,x	                sta 0,x
.a879	74 01		stz $01,x	                stz 1,x
.a87b	20 3a a5	jsr $a53a	                jsr xt_u_dot_r
.a87e	64 28		stz $28		                stz tmp3
.a880					_line_loop:
.a880	20 63 89	jsr $8963	                jsr xt_cr
.a883	ca		dex		                dex
.a884	ca		dex		                dex
.a885	ca		dex		                dex
.a886	ca		dex		                dex
.a887	74 03		stz $03,x	                stz 3,x
.a889	a5 28		lda $28		                lda tmp3
.a88b	95 02		sta $02,x	                sta 2,x
.a88d	74 01		stz $01,x	                stz 1,x
.a88f	a9 02		lda #$02	                lda #2
.a891	95 00		sta $00,x	                sta 0,x
.a893	20 3a a5	jsr $a53a	                jsr xt_u_dot_r
.a896	20 1e a1	jsr $a11e	                jsr xt_space
.a899	20 af 8d	jsr $8daf	                jsr xt_dup
.a89c	ca		dex		                dex
.a89d	ca		dex		                dex
.a89e	a9 40		lda #$40	                lda #64
.a8a0	95 00		sta $00,x	                sta 0,x
.a8a2	74 01		stz $01,x	                stz 1,x
.a8a4	20 03 a5	jsr $a503	                jsr xt_type
.a8a7	18		clc		                clc
.a8a8	a9 40		lda #$40	                lda #64
.a8aa	75 00		adc $00,x	                adc 0,x
.a8ac	95 00		sta $00,x	                sta 0,x
.a8ae	b5 01		lda $01,x	                lda 1,x
.a8b0	69 00		adc #$00	                adc #0      ; Add carry
.a8b2	95 01		sta $01,x	                sta 1,x
.a8b4	e6 28		inc $28		                inc tmp3
.a8b6	a5 28		lda $28		                lda tmp3
.a8b8	c9 10		cmp #$10	                cmp #16
.a8ba	d0 c4		bne $a880	                bne _line_loop
.a8bc	20 63 89	jsr $8963	                jsr xt_cr
.a8bf	e8		inx		                inx
.a8c0	e8		inx		                inx
.a8c1	60		rts		z_editor_l:            rts
.a8c2					xt_editor_line:
.a8c2	20 44 d8	jsr $d844	                jsr underflow_1
.a8c5	a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a8c7					_shift_tos_left:
.a8c7	16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a8c9	36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a8cb	88		dey		                dey
.a8cc	d0 f9		bne $a8c7	                bne _shift_tos_left
.a8ce	20 d9 9e	jsr $9ed9	                jsr xt_scr
.a8d1	20 80 8f	jsr $8f80	                jsr xt_fetch
.a8d4	20 c1 83	jsr $83c1	                jsr xt_block
.a8d7	20 e3 99	jsr $99e3	                jsr xt_plus
.a8da	60		rts		z_editor_line:  rts
.a8db					xt_editor_o:
.a8db	20 63 89	jsr $8963	                jsr xt_cr
.a8de	20 af 8d	jsr $8daf	                jsr xt_dup
.a8e1	20 a7 a3	jsr $a3a7	                jsr xt_two
.a8e4	20 3a a5	jsr $a53a	                jsr xt_u_dot_r
.a8e7	20 1e a1	jsr $a11e	                jsr xt_space
.a8ea	a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a8ec	20 f6 8d	jsr $8df6	                jsr emit_a
.a8ef	20 1e a1	jsr $a11e	                jsr xt_space
.a8f2	20 c2 a8	jsr $a8c2	                jsr xt_editor_line
.a8f5	20 af 8d	jsr $8daf	                jsr xt_dup      ; Save a copy of the line address for later.
.a8f8	ca		dex		                dex
.a8f9	ca		dex		                dex
.a8fa	a9 40		lda #$40	                lda #64         ; chars/line
.a8fc	95 00		sta $00,x	                sta 0,x
.a8fe	74 01		stz $01,x	                stz 1,x
.a900	20 4e 81	jsr $814e	                jsr xt_accept
.a903	20 af 8d	jsr $8daf	                jsr xt_dup
.a906	20 6e 96	jsr $966e	                jsr xt_not_rote ; -rot
.a909	20 e3 99	jsr $99e3	                jsr xt_plus
.a90c	ca		dex		                dex
.a90d	ca		dex		                dex
.a90e	a9 40		lda #$40	                lda #64         ; chars/line
.a910	95 00		sta $00,x	                sta 0,x
.a912	74 01		stz $01,x	                stz 1,x
.a914	20 57 9b	jsr $9b57	                jsr xt_rot
.a917	20 50 95	jsr $9550	                jsr xt_minus
.a91a	20 ea 8e	jsr $8eea	                jsr xt_blank
.a91d	20 64 a6	jsr $a664	                jsr xt_update
.a920	60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a921					assembler:
.a921					xt_asm_adc_h:
.a921	a9 69		lda #$69	                lda #$69
.a923	4c 7c ac	jmp $ac7c	                jmp asm_common
.a926					z_asm_adc_h:
.a926					xt_asm_adc_x:
.a926	a9 7d		lda #$7d	                lda #$7D
.a928	4c 7c ac	jmp $ac7c	                jmp asm_common
.a92b					z_asm_adc_x:
.a92b					xt_asm_adc_y:
.a92b	a9 79		lda #$79	                lda #$79
.a92d	4c 7c ac	jmp $ac7c	                jmp asm_common
.a930					z_asm_adc_y:
.a930					xt_asm_adc_z:
.a930	a9 65		lda #$65	                lda #$65
.a932	4c 7c ac	jmp $ac7c	                jmp asm_common
.a935					z_asm_adc_z:
.a935					xt_asm_adc_zi:
.a935	a9 72		lda #$72	                lda #$72
.a937	4c 7c ac	jmp $ac7c	                jmp asm_common
.a93a					z_asm_adc_zi:
.a93a					xt_asm_adc_ziy:
.a93a	a9 71		lda #$71	                lda #$71
.a93c	4c 7c ac	jmp $ac7c	                jmp asm_common
.a93f					z_asm_adc_ziy:
.a93f					xt_asm_adc_zx:
.a93f	a9 75		lda #$75	                lda #$75
.a941	4c 7c ac	jmp $ac7c	                jmp asm_common
.a944					z_asm_adc_zx:
.a944					xt_asm_adc_zxi:
.a944	a9 61		lda #$61	                lda #$61
.a946	4c 7c ac	jmp $ac7c	                jmp asm_common
.a949					z_asm_adc_zxi:
.a949					xt_asm_and:
.a949	a9 2d		lda #$2d	                lda #$2D
.a94b	4c 7c ac	jmp $ac7c	                jmp asm_common
.a94e					z_asm_and:
.a94e					xt_asm_and_h:
.a94e	a9 29		lda #$29	                lda #$29
.a950	4c 7c ac	jmp $ac7c	                jmp asm_common
.a953					z_asm_and_h:
.a953					xt_asm_and_x:
.a953	a9 3d		lda #$3d	                lda #$3D
.a955	4c 7c ac	jmp $ac7c	                jmp asm_common
.a958					z_asm_and_x:
.a958					xt_asm_and_y:
.a958	a9 39		lda #$39	                lda #$39
.a95a	4c 7c ac	jmp $ac7c	                jmp asm_common
.a95d					z_asm_and_y:
.a95d					xt_asm_and_z:
.a95d	a9 25		lda #$25	                lda #$25
.a95f	4c 7c ac	jmp $ac7c	                jmp asm_common
.a962					z_asm_and_z:
.a962					xt_asm_and_zi:
.a962	a9 32		lda #$32	                lda #$32
.a964	4c 7c ac	jmp $ac7c	                jmp asm_common
.a967					z_asm_and_zi:
.a967					xt_asm_and_ziy:
.a967	a9 31		lda #$31	                lda #$31
.a969	4c 7c ac	jmp $ac7c	                jmp asm_common
.a96c					z_asm_and_ziy:
.a96c					xt_asm_and_zx:
.a96c	a9 35		lda #$35	                lda #$35
.a96e	4c 7c ac	jmp $ac7c	                jmp asm_common
.a971					z_asm_and_zx:
.a971					xt_asm_and_zxi:
.a971	a9 21		lda #$21	                lda #$21
.a973	4c 7c ac	jmp $ac7c	                jmp asm_common
.a976					z_asm_and_zxi:
.a976					xt_asm_asl:
.a976	a9 0e		lda #$0e	                lda #$0E
.a978	4c 7c ac	jmp $ac7c	                jmp asm_common
.a97b					z_asm_asl:
.a97b					xt_asm_asl_a:
.a97b	a9 0a		lda #$0a	                lda #$0A
.a97d	4c 7c ac	jmp $ac7c	                jmp asm_common
.a980					z_asm_asl_a:
.a980					xt_asm_asl_x:
.a980	a9 1e		lda #$1e	                lda #$1E
.a982	4c 7c ac	jmp $ac7c	                jmp asm_common
.a985					z_asm_asl_x:
.a985					xt_asm_asl_z:
.a985	a9 06		lda #$06	                lda #$06
.a987	4c 7c ac	jmp $ac7c	                jmp asm_common
.a98a					z_asm_asl_z:
.a98a					xt_asm_asl_zx:
.a98a	a9 16		lda #$16	                lda #$16
.a98c	4c 7c ac	jmp $ac7c	                jmp asm_common
.a98f					z_asm_asl_zx:
.a98f					xt_asm_bcc:
.a98f	a9 90		lda #$90	                lda #$90
.a991	4c 7c ac	jmp $ac7c	                jmp asm_common
.a994					z_asm_bcc:
.a994					xt_asm_bcs:
.a994	a9 b0		lda #$b0	                lda #$B0
.a996	a0 02		ldy #$02	                ldy #2
.a998	4c 7c ac	jmp $ac7c	                jmp asm_common
.a99b					z_asm_bcs:
.a99b					xt_asm_beq:
.a99b	a9 f0		lda #$f0	                lda #$F0
.a99d	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9a0					z_asm_beq:
.a9a0					xt_asm_bit:
.a9a0	a9 2c		lda #$2c	                lda #$2C
.a9a2	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9a5					z_asm_bit:
.a9a5					xt_asm_bit_h:
.a9a5	a9 89		lda #$89	                lda #$89
.a9a7	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9aa					z_asm_bit_h:
.a9aa					xt_asm_bit_x:
.a9aa	a9 3c		lda #$3c	                lda #$3C
.a9ac	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9af					z_asm_bit_x:
.a9af					xt_asm_bit_z:
.a9af	a9 24		lda #$24	                lda #$24
.a9b1	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9b4					z_asm_bit_z:
.a9b4					xt_asm_bit_zx:
.a9b4	a9 34		lda #$34	                lda #$34
.a9b6	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9b9					z_asm_bit_zx:
.a9b9					xt_asm_bmi:
.a9b9	a9 30		lda #$30	                lda #$30
.a9bb	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9be					z_asm_bmi:
.a9be					xt_asm_bne:
.a9be	a9 d0		lda #$d0	                lda #$D0
.a9c0	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9c3					z_asm_bne:
.a9c3					xt_asm_bpl:
.a9c3	a9 10		lda #$10	                lda #$10
.a9c5	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9c8					z_asm_bpl:
.a9c8					xt_asm_bra:
.a9c8	a9 80		lda #$80	                lda #$80
.a9ca	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9cd					z_asm_bra:
.a9cd					xt_asm_brk:
.a9cd	a9 00		lda #$00	                lda #$00
.a9cf	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9d2					z_asm_brk:
.a9d2					xt_asm_bvc:
.a9d2	a9 50		lda #$50	                lda #$50
.a9d4	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9d7					z_asm_bvc:
.a9d7					xt_asm_bvs:
.a9d7	a9 70		lda #$70	                lda #$70
.a9d9	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9dc					z_asm_bvs:
.a9dc					xt_asm_clc:
.a9dc	a9 18		lda #$18	                lda #$18
.a9de	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9e1					z_asm_clc:
.a9e1					xt_asm_cld:
.a9e1	a9 d8		lda #$d8	                lda #$D8
.a9e3	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9e6					z_asm_cld:
.a9e6					xt_asm_cli:
.a9e6	a9 58		lda #$58	                lda #$58
.a9e8	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9eb					z_asm_cli:
.a9eb					xt_asm_clv:
.a9eb	a9 b8		lda #$b8	                lda #$B8
.a9ed	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9f0					z_asm_clv:
.a9f0					xt_asm_cmp:
.a9f0	a9 cd		lda #$cd	                lda #$CD
.a9f2	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9f5					z_asm_cmp:
.a9f5					xt_asm_cmp_h:
.a9f5	a9 c9		lda #$c9	                lda #$C9
.a9f7	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9fa					z_asm_cmp_h:
.a9fa					xt_asm_cmp_x:
.a9fa	a9 dd		lda #$dd	                lda #$DD
.a9fc	4c 7c ac	jmp $ac7c	                jmp asm_common
.a9ff					z_asm_cmp_x:
.a9ff					xt_asm_cmp_y:
.a9ff	a9 d9		lda #$d9	                lda #$D9
.aa01	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa04					z_asm_cmp_y:
.aa04					xt_asm_cmp_z:
.aa04	a9 c5		lda #$c5	                lda #$C5
.aa06	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa09					z_asm_cmp_z:
.aa09					xt_asm_cmp_zi:
.aa09	a9 d2		lda #$d2	                lda #$D2
.aa0b	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa0e					z_asm_cmp_zi:
.aa0e					xt_asm_cmp_ziy:
.aa0e	a9 d1		lda #$d1	                lda #$D1
.aa10	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa13					z_asm_cmp_ziy:
.aa13					xt_asm_cmp_zx:
.aa13	a9 d5		lda #$d5	                lda #$D5
.aa15	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa18					z_asm_cmp_zx:
.aa18					xt_asm_cmp_zxi:
.aa18	a9 c1		lda #$c1	                lda #$C1
.aa1a	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa1d					z_asm_cmp_zxi:
.aa1d					xt_asm_cpx:
.aa1d	a9 ec		lda #$ec	                lda #$EC
.aa1f	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa22					z_asm_cpx:
.aa22					xt_asm_cpx_h:
.aa22	a9 e0		lda #$e0	                lda #$E0
.aa24	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa27					z_asm_cpx_h:
.aa27					xt_asm_cpx_z:
.aa27	a9 e4		lda #$e4	                lda #$E4
.aa29	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa2c					z_asm_cpx_z:
.aa2c					xt_asm_cpy:
.aa2c	a9 cc		lda #$cc	                lda #$CC
.aa2e	a0 03		ldy #$03	                ldy #3
.aa30	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa33					z_asm_cpy:
.aa33					xt_asm_cpy_h:
.aa33	a9 c0		lda #$c0	                lda #$C0
.aa35	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa38					z_asm_cpy_h:
.aa38					xt_asm_cpy_z:
.aa38	a9 c4		lda #$c4	                lda #$C4
.aa3a	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa3d					z_asm_cpy_z:
.aa3d					xt_asm_dec:
.aa3d	a9 ce		lda #$ce	                lda #$CE
.aa3f	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa42					z_asm_dec:
.aa42					xt_asm_dec_a:
.aa42	a9 3a		lda #$3a	                lda #$3A
.aa44	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa47					z_asm_dec_a:
.aa47					xt_asm_dec_x:
.aa47	a9 de		lda #$de	                lda #$DE
.aa49	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa4c					z_asm_dec_x:
.aa4c					xt_asm_dec_z:
.aa4c	a9 c6		lda #$c6	                lda #$C6
.aa4e	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa51					z_asm_dec_z:
.aa51					xt_asm_dec_zx:
.aa51	a9 d6		lda #$d6	                lda #$D6
.aa53	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa56					z_asm_dec_zx:
.aa56					xt_asm_dex:
.aa56	a9 ca		lda #$ca	                lda #$CA
.aa58	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa5b					z_asm_dex:
.aa5b					xt_asm_dey:
.aa5b	a9 88		lda #$88	                lda #$88
.aa5d	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa60					z_asm_dey:
.aa60					xt_asm_eor:
.aa60	a9 4d		lda #$4d	                lda #$4D
.aa62	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa65					z_asm_eor:
.aa65					xt_asm_eor_h:
.aa65	a9 49		lda #$49	                lda #$49
.aa67	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa6a					z_asm_eor_h:
.aa6a					xt_asm_eor_x:
.aa6a	a9 5d		lda #$5d	                lda #$5D
.aa6c	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa6f					z_asm_eor_x:
.aa6f					xt_asm_eor_y:
.aa6f	a9 59		lda #$59	                lda #$59
.aa71	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa74					z_asm_eor_y:
.aa74					xt_asm_eor_z:
.aa74	a9 45		lda #$45	                lda #$45
.aa76	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa79					z_asm_eor_z:
.aa79					xt_asm_eor_zi:
.aa79	a9 52		lda #$52	                lda #$52
.aa7b	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa7e					z_asm_eor_zi:
.aa7e					xt_asm_eor_ziy:
.aa7e	a9 51		lda #$51	                lda #$51
.aa80	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa83					z_asm_eor_ziy:
.aa83					xt_asm_eor_zx:
.aa83	a9 55		lda #$55	                lda #$55
.aa85	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa88					z_asm_eor_zx:
.aa88					xt_asm_eor_zxi:
.aa88	a9 41		lda #$41	                lda #$41
.aa8a	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa8d					z_asm_eor_zxi:
.aa8d					xt_asm_inc:
.aa8d	a9 ee		lda #$ee	                lda #$EE
.aa8f	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa92					z_asm_inc:
.aa92					xt_asm_inc_a:
.aa92	a9 1a		lda #$1a	                lda #$1A
.aa94	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa97					z_asm_inc_a:
.aa97					xt_asm_inc_x:
.aa97	a9 fe		lda #$fe	                lda #$FE
.aa99	4c 7c ac	jmp $ac7c	                jmp asm_common
.aa9c					z_asm_inc_x:
.aa9c					xt_asm_inc_z:
.aa9c	a9 e6		lda #$e6	                lda #$E6
.aa9e	4c 7c ac	jmp $ac7c	                jmp asm_common
.aaa1					z_asm_inc_z:
.aaa1					xt_asm_inc_zx:
.aaa1	a9 f6		lda #$f6	                lda #$F6
.aaa3	4c 7c ac	jmp $ac7c	                jmp asm_common
.aaa6					z_asm_inc_zx:
.aaa6					xt_asm_inx:
.aaa6	a9 e8		lda #$e8	                lda #$E8
.aaa8	4c 7c ac	jmp $ac7c	                jmp asm_common
.aaab					z_asm_inx:
.aaab					xt_asm_iny:
.aaab	a9 c8		lda #$c8	                lda #$C8
.aaad	4c 7c ac	jmp $ac7c	                jmp asm_common
.aab0					z_asm_iny:
.aab0					xt_asm_jmp:
.aab0	a9 4c		lda #$4c	                lda #$4C
.aab2	4c 7c ac	jmp $ac7c	                jmp asm_common
.aab5					z_asm_jmp:
.aab5					xt_asm_jmp_i:
.aab5	a9 6c		lda #$6c	                lda #$6C
.aab7	4c 7c ac	jmp $ac7c	                jmp asm_common
.aaba					z_asm_jmp_i:
.aaba					xt_asm_jmp_xi:
.aaba	a9 7c		lda #$7c	                lda #$7C
.aabc	4c 7c ac	jmp $ac7c	                jmp asm_common
.aabf					z_asm_jmp_xi:
.aabf					xt_asm_jsr:
.aabf	a9 20		lda #$20	                lda #$20
.aac1	4c 7c ac	jmp $ac7c	                jmp asm_common
.aac4					z_asm_jsr:
.aac4					xt_asm_lda:
.aac4	a9 ad		lda #$ad	                lda #$AD
.aac6	4c 7c ac	jmp $ac7c	                jmp asm_common
.aac9					z_asm_lda:
.aac9					xt_asm_lda_h:
.aac9	a9 a9		lda #$a9	                lda #$A9
.aacb	4c 7c ac	jmp $ac7c	                jmp asm_common
.aace					z_asm_lda_h:
.aace					xt_asm_lda_x:
.aace	a9 bd		lda #$bd	                lda #$BD
.aad0	4c 7c ac	jmp $ac7c	                jmp asm_common
.aad3					z_asm_lda_x:
.aad3					xt_asm_lda_y:
.aad3	a9 b9		lda #$b9	                lda #$B9
.aad5	4c 7c ac	jmp $ac7c	                jmp asm_common
.aad8					z_asm_lda_y:
.aad8					xt_asm_lda_z:
.aad8	a9 a5		lda #$a5	                lda #$A5
.aada	4c 7c ac	jmp $ac7c	                jmp asm_common
.aadd					z_asm_lda_z:
.aadd					xt_asm_lda_zi:
.aadd	a9 b2		lda #$b2	                lda #$B2
.aadf	4c 7c ac	jmp $ac7c	                jmp asm_common
.aae2					z_asm_lda_zi:
.aae2					xt_asm_lda_ziy:
.aae2	a9 b1		lda #$b1	                lda #$B1
.aae4	4c 7c ac	jmp $ac7c	                jmp asm_common
.aae7					z_asm_lda_ziy:
.aae7					xt_asm_lda_zx:
.aae7	a9 b5		lda #$b5	                lda #$B5
.aae9	4c 7c ac	jmp $ac7c	                jmp asm_common
.aaec					z_asm_lda_zx:
.aaec					xt_asm_lda_zxi:
.aaec	a9 a1		lda #$a1	                lda #$A1
.aaee	4c 7c ac	jmp $ac7c	                jmp asm_common
.aaf1					z_asm_lda_zxi:
.aaf1					xt_asm_ldx:
.aaf1	a9 ae		lda #$ae	                lda #$AE
.aaf3	4c 7c ac	jmp $ac7c	                jmp asm_common
.aaf6					z_asm_ldx:
.aaf6					xt_asm_ldx_h:
.aaf6	a9 a2		lda #$a2	                lda #$A2
.aaf8	4c 7c ac	jmp $ac7c	                jmp asm_common
.aafb					z_asm_ldx_h:
.aafb					xt_asm_ldx_y:
.aafb	a9 be		lda #$be	                lda #$BE
.aafd	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab00					z_asm_ldx_y:
.ab00					xt_asm_ldx_z:
.ab00	a9 a6		lda #$a6	                lda #$A6
.ab02	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab05					z_asm_ldx_z:
.ab05					xt_asm_ldx_zy:
.ab05	a9 b6		lda #$b6	                lda #$B6
.ab07	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab0a					z_asm_ldx_zy:
.ab0a					xt_asm_ldy:
.ab0a	a9 ac		lda #$ac	                lda #$AC
.ab0c	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab0f					z_asm_ldy:
.ab0f					xt_asm_ldy_h:
.ab0f	a9 a0		lda #$a0	                lda #$A0
.ab11	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab14					z_asm_ldy_h:
.ab14					xt_asm_ldy_x:
.ab14	a9 bc		lda #$bc	                lda #$BC
.ab16	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab19					z_asm_ldy_x:
.ab19					xt_asm_ldy_z:
.ab19	a9 a4		lda #$a4	                lda #$A4
.ab1b	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab1e					z_asm_ldy_z:
.ab1e					xt_asm_ldy_zx:
.ab1e	a9 b4		lda #$b4	                lda #$B4
.ab20	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab23					z_asm_ldy_zx:
.ab23					xt_asm_lsr:
.ab23	a9 4e		lda #$4e	                lda #$4E
.ab25	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab28					z_asm_lsr:
.ab28					xt_asm_lsr_a:
.ab28	a9 4a		lda #$4a	                lda #$4A
.ab2a	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab2d					z_asm_lsr_a:
.ab2d					xt_asm_lsr_x:
.ab2d	a9 5e		lda #$5e	                lda #$5E
.ab2f	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab32					z_asm_lsr_x:
.ab32					xt_asm_lsr_z:
.ab32	a9 46		lda #$46	                lda #$46
.ab34	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab37					z_asm_lsr_z:
.ab37					xt_asm_lsr_zx:
.ab37	a9 56		lda #$56	                lda #$56
.ab39	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab3c					z_asm_lsr_zx:
.ab3c					xt_asm_nop:
.ab3c	a9 ea		lda #$ea	                lda #$EA
.ab3e	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab41					z_asm_nop:
.ab41					xt_asm_ora:
.ab41	a9 0d		lda #$0d	                lda #$0D
.ab43	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab46					z_asm_ora:
.ab46					xt_asm_ora_h:
.ab46	a9 09		lda #$09	                lda #$09
.ab48	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab4b					z_asm_ora_h:
.ab4b					xt_asm_ora_x:
.ab4b	a9 1d		lda #$1d	                lda #$1D
.ab4d	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab50					z_asm_ora_x:
.ab50					xt_asm_ora_y:
.ab50	a9 19		lda #$19	                lda #$19
.ab52	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab55					z_asm_ora_y:
.ab55					xt_asm_ora_z:
.ab55	a9 05		lda #$05	                lda #$05
.ab57	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab5a					z_asm_ora_z:
.ab5a					xt_asm_ora_zi:
.ab5a	a9 12		lda #$12	                lda #$12
.ab5c	a0 02		ldy #$02	                ldy #2
.ab5e	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab61					z_asm_ora_zi:
.ab61					xt_asm_ora_ziy:
.ab61	a9 11		lda #$11	                lda #$11
.ab63	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab66					z_asm_ora_ziy:
.ab66					xt_asm_ora_zx:
.ab66	a9 15		lda #$15	                lda #$15
.ab68	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab6b					z_asm_ora_zx:
.ab6b					xt_asm_ora_zxi:
.ab6b	a9 01		lda #$01	                lda #$01
.ab6d	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab70					z_asm_ora_zxi:
.ab70					xt_asm_pha:
.ab70	a9 48		lda #$48	                lda #$48
.ab72	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab75					z_asm_pha:
.ab75					xt_asm_php:
.ab75	a9 08		lda #$08	                lda #$08
.ab77	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab7a					z_asm_php:
.ab7a					xt_asm_phx:
.ab7a	a9 da		lda #$da	                lda #$DA
.ab7c	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab7f					z_asm_phx:
.ab7f					xt_asm_phy:
.ab7f	a9 5a		lda #$5a	                lda #$5A
.ab81	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab84					z_asm_phy:
.ab84					xt_asm_pla:
.ab84	a9 68		lda #$68	                lda #$68
.ab86	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab89					z_asm_pla:
.ab89					xt_asm_plp:
.ab89	a9 28		lda #$28	                lda #$28
.ab8b	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab8e					z_asm_plp:
.ab8e					xt_asm_plx:
.ab8e	a9 fa		lda #$fa	                lda #$FA
.ab90	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab93					z_asm_plx:
.ab93					xt_asm_ply:
.ab93	a9 7a		lda #$7a	                lda #$7A
.ab95	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab98					z_asm_ply:
.ab98					xt_asm_rol:
.ab98	a9 2e		lda #$2e	                lda #$2E
.ab9a	4c 7c ac	jmp $ac7c	                jmp asm_common
.ab9d					z_asm_rol:
.ab9d					xt_asm_rol_a:
.ab9d	a9 2a		lda #$2a	                lda #$2A
.ab9f	4c 7c ac	jmp $ac7c	                jmp asm_common
.aba2					z_asm_rol_a:
.aba2					xt_asm_rol_x:
.aba2	a9 3e		lda #$3e	                lda #$3E
.aba4	4c 7c ac	jmp $ac7c	                jmp asm_common
.aba7					z_asm_rol_x:
.aba7					xt_asm_rol_z:
.aba7	a9 26		lda #$26	                lda #$26
.aba9	4c 7c ac	jmp $ac7c	                jmp asm_common
.abac					z_asm_rol_z:
.abac					xt_asm_rol_zx:
.abac	a9 36		lda #$36	                lda #$36
.abae	4c 7c ac	jmp $ac7c	                jmp asm_common
.abb1					z_asm_rol_zx:
.abb1					xt_asm_ror:
.abb1	a9 6e		lda #$6e	                lda #$6E
.abb3	4c 7c ac	jmp $ac7c	                jmp asm_common
.abb6					z_asm_ror:
.abb6					xt_asm_ror_a:
.abb6	a9 6a		lda #$6a	                lda #$6A
.abb8	4c 7c ac	jmp $ac7c	                jmp asm_common
.abbb					z_asm_ror_a:
.abbb					xt_asm_ror_x:
.abbb	a9 7e		lda #$7e	                lda #$7E
.abbd	4c 7c ac	jmp $ac7c	                jmp asm_common
.abc0					z_asm_ror_x:
.abc0					xt_asm_ror_z:
.abc0	a9 66		lda #$66	                lda #$66
.abc2	4c 7c ac	jmp $ac7c	                jmp asm_common
.abc5					z_asm_ror_z:
.abc5					xt_asm_ror_zx:
.abc5	a9 76		lda #$76	                lda #$76
.abc7	4c 7c ac	jmp $ac7c	                jmp asm_common
.abca					z_asm_ror_zx:
.abca					xt_asm_rti:
.abca	a9 40		lda #$40	                lda #$40
.abcc	4c 7c ac	jmp $ac7c	                jmp asm_common
.abcf					z_asm_rti:
.abcf					xt_asm_rts:
.abcf	a9 60		lda #$60	                lda #$60
.abd1	4c 7c ac	jmp $ac7c	                jmp asm_common
.abd4					z_asm_rts:
.abd4					xt_asm_sbc:
.abd4	a9 ed		lda #$ed	                lda #$ED
.abd6	4c 7c ac	jmp $ac7c	                jmp asm_common
.abd9					z_asm_sbc:
.abd9					xt_asm_sbc_h:
.abd9	a9 e9		lda #$e9	                lda #$E9
.abdb	4c 7c ac	jmp $ac7c	                jmp asm_common
.abde					z_asm_sbc_h:
.abde					xt_asm_sbc_x:
.abde	a9 fd		lda #$fd	                lda #$FD
.abe0	4c 7c ac	jmp $ac7c	                jmp asm_common
.abe3					z_asm_sbc_x:
.abe3					xt_asm_sbc_y:
.abe3	a9 f9		lda #$f9	                lda #$F9
.abe5	4c 7c ac	jmp $ac7c	                jmp asm_common
.abe8					z_asm_sbc_y:
.abe8					xt_asm_sbc_z:
.abe8	a9 e5		lda #$e5	                lda #$E5
.abea	4c 7c ac	jmp $ac7c	                jmp asm_common
.abed					z_asm_sbc_z:
.abed					xt_asm_sbc_zi:
.abed	a9 f2		lda #$f2	                lda #$F2
.abef	4c 7c ac	jmp $ac7c	                jmp asm_common
.abf2					z_asm_sbc_zi:
.abf2					xt_asm_sbc_ziy:
.abf2	a9 f1		lda #$f1	                lda #$F1
.abf4	4c 7c ac	jmp $ac7c	                jmp asm_common
.abf7					z_asm_sbc_ziy:
.abf7					xt_asm_sbc_zx:
.abf7	a9 f5		lda #$f5	                lda #$F5
.abf9	4c 7c ac	jmp $ac7c	                jmp asm_common
.abfc					z_asm_sbc_zx:
.abfc					xt_asm_sbc_zxi:
.abfc	a9 e1		lda #$e1	                lda #$E1
.abfe	80 7c		bra $ac7c	                bra asm_common  ; <-- limit for BRA instead of JMP
.ac00					z_asm_sbc_zxi:
.ac00					xt_asm_sec:
.ac00	a9 38		lda #$38	                lda #$38
.ac02	80 78		bra $ac7c	                bra asm_common
.ac04					z_asm_sec:
.ac04					xt_asm_sed:
.ac04	a9 f8		lda #$f8	                lda #$F8
.ac06	80 74		bra $ac7c	                bra asm_common
.ac08					z_asm_sed:
.ac08					xt_asm_sei:
.ac08	a9 78		lda #$78	                lda #$78
.ac0a	80 70		bra $ac7c	                bra asm_common
.ac0c					z_asm_sei:
.ac0c					xt_asm_sta:
.ac0c	a9 8d		lda #$8d	                lda #$8D
.ac0e	80 6c		bra $ac7c	                bra asm_common
.ac10					z_asm_sta:
.ac10					xt_asm_sta_x:
.ac10	a9 9d		lda #$9d	                lda #$9D
.ac12	80 68		bra $ac7c	                bra asm_common
.ac14					z_asm_sta_x:
.ac14					xt_asm_sta_y:
.ac14	a9 99		lda #$99	                lda #$99
.ac16	80 64		bra $ac7c	                bra asm_common
.ac18					z_asm_sta_y:
.ac18					xt_asm_sta_z:
.ac18	a9 85		lda #$85	                lda #$85
.ac1a	80 60		bra $ac7c	                bra asm_common
.ac1c					z_asm_sta_z:
.ac1c					xt_asm_sta_zi:
.ac1c	a9 92		lda #$92	                lda #$92
.ac1e	80 5c		bra $ac7c	                bra asm_common
.ac20					z_asm_sta_zi:
.ac20					xt_asm_sta_ziy:
.ac20	a9 91		lda #$91	                lda #$91
.ac22	80 58		bra $ac7c	                bra asm_common
.ac24					z_asm_sta_ziy:
.ac24					xt_asm_sta_zx:
.ac24	a9 95		lda #$95	                lda #$95
.ac26	80 54		bra $ac7c	                bra asm_common
.ac28					z_asm_sta_zx:
.ac28					xt_asm_sta_zxi:
.ac28	a9 81		lda #$81	                lda #$81
.ac2a	80 50		bra $ac7c	                bra asm_common
.ac2c					z_asm_sta_zxi:
.ac2c					xt_asm_stx:
.ac2c	a9 8e		lda #$8e	                lda #$8E
.ac2e	80 4c		bra $ac7c	                bra asm_common
.ac30					z_asm_stx:
.ac30					xt_asm_stx_z:
.ac30	a9 86		lda #$86	                lda #$86
.ac32	80 48		bra $ac7c	                bra asm_common
.ac34					z_asm_stx_z:
.ac34					xt_asm_stx_zy:
.ac34	a9 96		lda #$96	                lda #$96
.ac36	80 44		bra $ac7c	                bra asm_common
.ac38					z_asm_stx_zy:
.ac38					xt_asm_sty:
.ac38	a9 8c		lda #$8c	                lda #$8C
.ac3a	80 40		bra $ac7c	                bra asm_common
.ac3c					z_asm_sty:
.ac3c					xt_asm_sty_z:
.ac3c	a9 84		lda #$84	                lda #$84
.ac3e	80 3c		bra $ac7c	                bra asm_common
.ac40					z_asm_sty_z:
.ac40					xt_asm_sty_zx:
.ac40	a9 94		lda #$94	                lda #$94
.ac42	80 38		bra $ac7c	                bra asm_common
.ac44					z_asm_sty_zx:
.ac44					xt_asm_stz:
.ac44	a9 9c		lda #$9c	                lda #$9C
.ac46	80 34		bra $ac7c	                bra asm_common
.ac48					z_asm_stz:
.ac48					xt_asm_stz_x:
.ac48	a9 9e		lda #$9e	                lda #$9E
.ac4a	80 30		bra $ac7c	                bra asm_common
.ac4c					z_asm_stz_x:
.ac4c					xt_asm_stz_z:
.ac4c	a9 64		lda #$64	                lda #$64
.ac4e	80 2c		bra $ac7c	                bra asm_common
.ac50					z_asm_stz_z:
.ac50					xt_asm_stz_zx:
.ac50	a9 74		lda #$74	                lda #$74
.ac52	80 28		bra $ac7c	                bra asm_common
.ac54					z_asm_stz_zx:
.ac54					xt_asm_tax:
.ac54	a9 aa		lda #$aa	                lda #$AA
.ac56	80 24		bra $ac7c	                bra asm_common
.ac58					z_asm_tax:
.ac58					xt_asm_tay:
.ac58	a9 a8		lda #$a8	                lda #$A8
.ac5a	80 20		bra $ac7c	                bra asm_common
.ac5c					z_asm_tay:
.ac5c					xt_asm_trb:
.ac5c	a9 1c		lda #$1c	                lda #$1C
.ac5e	80 1c		bra $ac7c	                bra asm_common
.ac60					z_asm_trb:
.ac60					xt_asm_trb_z:
.ac60	a9 14		lda #$14	                lda #$14
.ac62	80 18		bra $ac7c	                bra asm_common
.ac64					z_asm_trb_z:
.ac64					xt_asm_tsb:
.ac64	a9 0c		lda #$0c	                lda #$0C
.ac66	80 14		bra $ac7c	                bra asm_common
.ac68					z_asm_tsb:
.ac68					xt_asm_tsb_z:
.ac68	a9 04		lda #$04	                lda #$04
.ac6a	80 10		bra $ac7c	                bra asm_common
.ac6c					z_asm_tsb_z:
.ac6c					xt_asm_tsx:
.ac6c	a9 ba		lda #$ba	                lda #$BA
.ac6e	80 0c		bra $ac7c	                bra asm_common
.ac70					z_asm_tsx:
.ac70					xt_asm_txa:
.ac70	a9 8a		lda #$8a	                lda #$8A
.ac72	80 08		bra $ac7c	                bra asm_common
.ac74					z_asm_txa:
.ac74					xt_asm_txs:
.ac74	a9 9a		lda #$9a	                lda #$9A
.ac76	80 04		bra $ac7c	                bra asm_common
.ac78					z_asm_txs:
.ac78					xt_asm_tya:
.ac78	a9 98		lda #$98	                lda #$98
.ac7a	80 00		bra $ac7c	                bra asm_common
.ac7c					z_asm_tya:
.ac7c					asm_common:
.ac7c	a8		tay		                tay
.ac7d	20 f7 d6	jsr $d6f7	                jsr cmpl_a
.ac80	a9 e8		lda #$e8	                lda #<oc_index_table
.ac82	85 26		sta $26		                sta tmp2
.ac84	a9 ae		lda #$ae	                lda #>oc_index_table
.ac86	85 27		sta $27		                sta tmp2+1
.ac88	98		tya		                tya             ; retrieve opcode
.ac89	0a		asl a		                asl             ; times two for offset
.ac8a	90 02		bcc $ac8e	                bcc +
.ac8c	e6 27		inc $27		                inc tmp2+1
.ac8e					+
.ac8e	a8		tay		                tay             ; use Y as the index
.ac8f	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac91	85 28		sta $28		                sta tmp3
.ac93	c8		iny		                iny
.ac94	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac96	85 29		sta $29		                sta tmp3+1
.ac98	b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac9a	2a		rol a		                rol
.ac9b	2a		rol a		                rol
.ac9c	2a		rol a		                rol             ; Three times because we go through Carry
.ac9d	29 03		and #$03	                and #%00000011
.ac9f	a8		tay		                tay
.aca0	88		dey		                dey
.aca1	f0 12		beq $acb5	                beq _done
.aca3	20 44 d8	jsr $d844	                jsr underflow_1
.aca6	b5 00		lda $00,x	                lda 0,x
.aca8	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; does not use Y
.acab	88		dey		                dey
.acac	f0 05		beq $acb3	                beq _done_drop
.acae	b5 01		lda $01,x	                lda 1,x
.acb0	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; Fall through to _done_drop
.acb3					_done_drop:
.acb3	e8		inx		                inx
.acb4	e8		inx		                inx             ; Fall through to _done
.acb5					_done:
.acb5	60		rts		                rts             ; Returns to original caller
.acb6					xt_asm_push_a:
.acb6	a0 00		ldy #$00	                ldy #0
.acb8					_loop:
.acb8	b9 c6 ac	lda $acc6,y	                lda asm_push_a_data,y
.acbb	c9 ff		cmp #$ff	                cmp #$FF
.acbd	f0 06		beq $acc5	                beq _done
.acbf	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; does not change Y
.acc2	c8		iny		                iny
.acc3	80 f3		bra $acb8	                bra _loop
.acc5					_done:
.acc5					z_asm_push_a:
.acc5	60		rts		                rts
.acc6					asm_push_a_data:
>acc6	ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>accc	ff				        .byte $FF               ; terminator
.accd					xt_asm_back_jump:
.accd					z_asm_back_jump:
.accd	60		rts		                rts
.acce					xt_asm_back_branch:
.acce	20 72 91	jsr $9172	                jsr xt_here             ; ( addr-l addr-h )
.acd1	20 50 95	jsr $9550	                jsr xt_minus            ; ( offset )
.acd4	3a		dec a		                dea
.acd5	3a		dec a		                dea
.acd6					z_asm_back_branch:
.acd6	60		rts		                rts
.acd7					assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acd7					disassembler:
.acd7	20 63 89	jsr $8963	                jsr xt_cr       ; ( addr u )
.acda					_byte_loop:
.acda	20 93 98	jsr $9893	                jsr xt_over     ; ( addr u addr )
.acdd	20 2e a5	jsr $a52e	                jsr xt_u_dot    ; ( addr u )
.ace0	20 1e a1	jsr $a11e	                jsr xt_space
.ace3	a9 e8		lda #$e8	                lda #<oc_index_table
.ace5	85 26		sta $26		                sta tmp2
.ace7	a9 ae		lda #$ae	                lda #>oc_index_table
.ace9	85 27		sta $27		                sta tmp2+1
.aceb	a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.aced	85 36		sta $36		                sta scratch     ; Save opcode
.acef	0a		asl a		                asl             ; multiply by two for offset
.acf0	90 02		bcc $acf4	                bcc +
.acf2	e6 27		inc $27		                inc tmp2+1      ; we're on second page
.acf4					+
.acf4	a8		tay		                tay             ; use Y as the index
.acf5	b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.acf7	85 28		sta $28		                sta tmp3
.acf9	48		pha		                pha
.acfa	c8		iny		                iny
.acfb	b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acfd	85 29		sta $29		                sta tmp3+1
.acff	48		pha		                pha
.ad00	b2 28		lda ($28)	                lda (tmp3)
.ad02	a8		tay		                tay                     ; save copy of lengths byte
.ad03	10 3c		bpl $ad41	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.ad05	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ad08	f6 04		inc $04,x	                inc 4,x
.ad0a	d0 02		bne $ad0e	                bne +
.ad0c	f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ad0e					+
.ad0e	b5 02		lda $02,x	                lda 2,x
.ad10	d0 02		bne $ad14	                bne +
.ad12	d6 03		dec $03,x	                dec 3,x
.ad14					+
.ad14	d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.ad16	a1 04		lda ($04,x)	                lda (4,x)
.ad18	95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.ad1a	85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.ad1c	98		tya		                tya                     ; retrieve copy of lengths byte
.ad1d	2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad1e	10 14		bpl $ad34	                bpl _print_operand
.ad20	f6 04		inc $04,x	                inc 4,x
.ad22	d0 02		bne $ad26	                bne +
.ad24	f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad26					+
.ad26	b5 02		lda $02,x	                lda 2,x
.ad28	d0 02		bne $ad2c	                bne +
.ad2a	d6 03		dec $03,x	                dec 3,x
.ad2c					+
.ad2c	d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad2e	a1 04		lda ($04,x)	                lda (4,x)
.ad30	95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad32	85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad34					_print_operand:
.ad34	ca		dex		                dex
.ad35	ca		dex		                dex
.ad36	a9 05		lda #$05	                lda #5
.ad38	95 00		sta $00,x	                sta 0,x
.ad3a	74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad3c	20 3a a5	jsr $a53a	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad3f	80 0b		bra $ad4c	                bra _print_mnemonic
.ad41					_no_operand:
.ad41	ca		dex		                dex
.ad42	ca		dex		                dex
.ad43	a9 05		lda #$05	                lda #5
.ad45	95 00		sta $00,x	                sta 0,x
.ad47	74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad49	20 24 a1	jsr $a124	                jsr xt_spaces           ; ( addr u )
.ad4c					_print_mnemonic:
.ad4c	20 1e a1	jsr $a11e	                jsr xt_space
.ad4f	ca		dex		                dex
.ad50	ca		dex		                dex                     ; ( addr u ? )
.ad51	68		pla		                pla                     ; MSB
.ad52	95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad54	68		pla		                pla                     ; LSB
.ad55	95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad57	20 4f 89	jsr $894f	                jsr xt_count            ; ( addr u addr-o u-o )
.ad5a	74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad5c	b5 00		lda $00,x	                lda 0,x
.ad5e	29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad60	95 00		sta $00,x	                sta 0,x
.ad62	20 03 a5	jsr $a503	                jsr xt_type             ; ( addr u )
.ad65	a5 36		lda $36		                lda scratch
.ad67	c9 20		cmp #$20	                cmp #$20
.ad69	d0 59		bne $adc4	                bne _not_jsr
.ad6b	ca		dex		                dex
.ad6c	ca		dex		                dex
.ad6d	a9 05		lda #$05	                lda #5
.ad6f	95 00		sta $00,x	                sta 0,x
.ad71	74 01		stz $01,x	                stz 1,x
.ad73	20 24 a1	jsr $a124	                jsr xt_spaces
.ad76	a9 98		lda #$98	                lda #<literal_runtime
.ad78	c5 37		cmp $37		                cmp scratch+1
.ad7a	d0 0c		bne $ad88	                bne _not_literal
.ad7c	a9 93		lda #$93	                lda #>literal_runtime
.ad7e	c5 38		cmp $38		                cmp scratch+2
.ad80	d0 06		bne $ad88	                bne _not_literal
.ad82	20 7a ae	jsr $ae7a	                jsr disasm_literal
.ad85	4c f1 ad	jmp $adf1	                jmp _printing_done
.ad88					_not_literal:
.ad88	a9 a9		lda #$a9	                lda #<sliteral_runtime
.ad8a	c5 37		cmp $37		                cmp scratch+1
.ad8c	d0 0c		bne $ad9a	                bne _not_sliteral
.ad8e	a9 a0		lda #$a0	                lda #>sliteral_runtime
.ad90	c5 38		cmp $38		                cmp scratch+2
.ad92	d0 06		bne $ad9a	                bne _not_sliteral
.ad94	20 37 ae	jsr $ae37	                jsr disasm_sliteral
.ad97	4c f1 ad	jmp $adf1	                jmp _printing_done
.ad9a					_not_sliteral:
.ad9a	a9 14		lda #$14	                lda #<zero_branch_runtime
.ad9c	c5 37		cmp $37		                cmp scratch+1
.ad9e	d0 0c		bne $adac	                bne _not_0branch
.ada0	a9 92		lda #$92	                lda #>zero_branch_runtime
.ada2	c5 38		cmp $38		                cmp scratch+2
.ada4	d0 06		bne $adac	                bne _not_0branch
.ada6	20 6e ae	jsr $ae6e	                jsr disasm_0branch
.ada9	4c f1 ad	jmp $adf1	                jmp _printing_done
.adac					_not_0branch
.adac	a9 db		lda #$db	                lda #<branch_runtime
.adae	c5 37		cmp $37		                cmp scratch+1
.adb0	d0 0c		bne $adbe	                bne _not_branch
.adb2	a9 8d		lda #$8d	                lda #>branch_runtime
.adb4	c5 38		cmp $38		                cmp scratch+2
.adb6	d0 06		bne $adbe	                bne _not_branch
.adb8	20 73 ae	jsr $ae73	                jsr disasm_branch
.adbb	4c f1 ad	jmp $adf1	                jmp _printing_done
.adbe					_not_branch
.adbe	20 98 ae	jsr $ae98	                jsr disasm_jsr
.adc1	4c f1 ad	jmp $adf1	                jmp _printing_done
.adc4					_not_jsr:
.adc4	c9 4c		cmp #$4c	                cmp #$4C
.adc6	d0 29		bne $adf1	                bne _printing_done
.adc8	a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.adca	85 39		sta $39		                sta scratch+3
.adcc	a5 38		lda $38		                lda scratch+2
.adce	85 3a		sta $3a		                sta scratch+4
.add0	b2 39		lda ($39)	                lda (scratch+3)
.add2	c9 20		cmp #$20	                cmp #$20 ; check for JSR
.add4	d0 1b		bne $adf1	                bne _printing_done
.add6	e6 39		inc $39		                inc scratch+3
.add8	d0 02		bne $addc	                bne +
.adda	e6 3a		inc $3a		                inc scratch+4
.addc					+
.addc	b2 39		lda ($39)	                lda (scratch+3)
.adde	c9 a9		cmp #$a9	                cmp #<sliteral_runtime
.ade0	d0 0f		bne $adf1	                bne _printing_done
.ade2	e6 39		inc $39		                inc scratch+3
.ade4	d0 02		bne $ade8	                bne +
.ade6	e6 3a		inc $3a		                inc scratch+4
.ade8					+
.ade8	b2 39		lda ($39)	                lda (scratch+3)
.adea	c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.adec	d0 03		bne $adf1	                bne _printing_done
.adee	20 0d ae	jsr $ae0d	                jsr disasm_sliteral_jump
.adf1					_printing_done:
.adf1	20 63 89	jsr $8963	                jsr xt_cr
.adf4	f6 02		inc $02,x	                inc 2,x
.adf6	d0 02		bne $adfa	                bne +
.adf8	f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.adfa					+
.adfa	20 11 98	jsr $9811	                jsr xt_one_minus        ; ( addr+1 u-1 )
.adfd	b5 00		lda $00,x	                lda 0,x                 ; All done?
.adff	15 01		ora $01,x	                ora 1,x
.ae01	f0 07		beq $ae0a	                beq _done
.ae03	b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae05	30 03		bmi $ae0a	                bmi _done
.ae07	4c da ac	jmp $acda	                jmp _byte_loop          ; out of range for BRA
.ae0a					_done:
.ae0a	4c b0 a3	jmp $a3b0	                jmp xt_two_drop         ; JSR/RTS
.ae0d					disasm_sliteral_jump:
.ae0d	20 ae a1	jsr $a1ae	                jsr xt_swap
.ae10	ca		dex		                dex
.ae11	ca		dex		                dex
.ae12	a5 37		lda $37		                lda scratch+1
.ae14	95 00		sta $00,x	                sta 0,x
.ae16	a5 38		lda $38		                lda scratch+2
.ae18	95 01		sta $01,x	                sta 1,x
.ae1a	20 ae a1	jsr $a1ae	                jsr xt_swap
.ae1d	20 50 95	jsr $9550	                jsr xt_minus
.ae20	20 11 98	jsr $9811	                jsr xt_one_minus
.ae23	20 50 95	jsr $9550	                jsr xt_minus
.ae26	ca		dex		                dex
.ae27	ca		dex		                dex
.ae28	a5 37		lda $37		                lda scratch+1
.ae2a	95 00		sta $00,x	                sta 0,x
.ae2c	a5 38		lda $38		                lda scratch+2
.ae2e	95 01		sta $01,x	                sta 1,x
.ae30	20 11 98	jsr $9811	                jsr xt_one_minus
.ae33	20 ae a1	jsr $a1ae	                jsr xt_swap ; ( new_addr new_n )
.ae36	60		rts		                rts
.ae37					disasm_sliteral:
.ae37	a9 53		lda #$53	                lda #'S'
.ae39	20 f6 8d	jsr $8df6	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae3c	a9 0d		lda #$0d	                lda #str_disasm_lit     ; "LITERAL "
.ae3e	20 80 d8	jsr $d880	                jsr print_string_no_lf
.ae41	20 ae a1	jsr $a1ae	                jsr xt_swap             ; switch to (u addr)
.ae44	20 1d 98	jsr $981d	                jsr xt_one_plus
.ae47	20 af 8d	jsr $8daf	                jsr xt_dup
.ae4a	20 80 8f	jsr $8f80	                jsr xt_fetch
.ae4d	20 2e a5	jsr $a52e	                jsr xt_u_dot            ; Print the address of the string
.ae50	20 a7 a3	jsr $a3a7	                jsr xt_two
.ae53	20 e3 99	jsr $99e3	                jsr xt_plus
.ae56	20 af 8d	jsr $8daf	                jsr xt_dup
.ae59	20 62 9a	jsr $9a62	                jsr xt_question         ; Print the length of the string
.ae5c	20 1d 98	jsr $981d	                jsr xt_one_plus
.ae5f	20 ae a1	jsr $a1ae	                jsr xt_swap            ; ( addr+4 u )
.ae62	ca		dex		                dex
.ae63	ca		dex		                dex
.ae64	a9 04		lda #$04	                lda #4
.ae66	95 00		sta $00,x	                sta 0,x
.ae68	74 01		stz $01,x	                stz 1,x
.ae6a	20 50 95	jsr $9550	                jsr xt_minus            ; ( addr+4 u-4 )
.ae6d	60		rts		                rts
.ae6e					disasm_0branch:
.ae6e	a9 30		lda #$30	                lda #'0'
.ae70	20 f6 8d	jsr $8df6	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.ae73					disasm_branch:
.ae73	a9 0f		lda #$0f	                lda #str_disasm_bra
.ae75	20 80 d8	jsr $d880	                jsr print_string_no_lf ; "BRANCH "
.ae78	80 05		bra $ae7f	                bra disasm_print_literal
.ae7a					disasm_literal:
.ae7a	a9 0d		lda #$0d	                lda #str_disasm_lit
.ae7c	20 80 d8	jsr $d880	                jsr print_string_no_lf ; "LITERAL "
.ae7f					disasm_print_literal:
.ae7f	20 ae a1	jsr $a1ae	                jsr xt_swap ; switch to (u addr)
.ae82	20 1d 98	jsr $981d	                jsr xt_one_plus
.ae85	20 af 8d	jsr $8daf	                jsr xt_dup
.ae88	20 62 9a	jsr $9a62	                jsr xt_question ; Print the value at the adress
.ae8b	20 1d 98	jsr $981d	                jsr xt_one_plus
.ae8e	20 ae a1	jsr $a1ae	                jsr xt_swap ; (addr+2 u)
.ae91	20 11 98	jsr $9811	                jsr xt_one_minus
.ae94	20 11 98	jsr $9811	                jsr xt_one_minus ; (addr+2 u-2)
.ae97	60		rts		                rts
.ae98					disasm_jsr:
.ae98	ca		dex		                dex
.ae99	ca		dex		                dex
.ae9a	a5 37		lda $37		                lda scratch+1
.ae9c	95 00		sta $00,x	                sta 0,x
.ae9e	a5 38		lda $38		                lda scratch+2
.aea0	95 01		sta $01,x	                sta 1,x
.aea2	20 78 92	jsr $9278	                jsr xt_int_to_name
.aea5	b5 00		lda $00,x	                lda 0,x
.aea7	15 01		ora $01,x	                ora 1,x
.aea9	f0 07		beq $aeb2	                beq _disasm_no_nt
.aeab	20 fe 95	jsr $95fe	                jsr xt_name_to_string
.aeae	20 03 a5	jsr $a503	                jsr xt_type
.aeb1	60		rts		                rts
.aeb2					_disasm_no_nt:
.aeb2	20 2e 8d	jsr $8d2e	                jsr xt_drop ; the 0 indicating no name token
.aeb5	ca		dex		                dex
.aeb6	ca		dex		                dex
.aeb7	a5 37		lda $37		                lda scratch+1
.aeb9	95 00		sta $00,x	                sta 0,x
.aebb	a5 38		lda $38		                lda scratch+2
.aebd	95 01		sta $01,x	                sta 1,x
.aebf	ca		dex		                dex
.aec0	ca		dex		                dex
.aec1	a9 44		lda #$44	                lda #<underflow_1
.aec3	95 00		sta $00,x	                sta 0,x
.aec5	a9 d8		lda #$d8	                lda #>underflow_1
.aec7	95 01		sta $01,x	                sta 1,x
.aec9	20 6b d7	jsr $d76b	                jsr compare_16bit
.aecc	f0 02		beq $aed0	                beq _disasm_jsr_uflow_check_upper
.aece	b0 14		bcs $aee4	                bcs _disasm_jsr_unknown
.aed0					_disasm_jsr_uflow_check_upper:
.aed0	a9 53		lda #$53	                lda #<underflow_4
.aed2	95 00		sta $00,x	                sta 0,x
.aed4	a9 d8		lda #$d8	                lda #>underflow_4
.aed6	95 01		sta $01,x	                sta 1,x
.aed8	20 6b d7	jsr $d76b	                jsr compare_16bit
.aedb	f0 02		beq $aedf	                beq _disasm_jsr_soc
.aedd	90 05		bcc $aee4	                bcc _disasm_jsr_unknown
.aedf					_disasm_jsr_soc:
.aedf	a9 0e		lda #$0e	                lda #str_disasm_sdc
.aee1	20 80 d8	jsr $d880	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.aee4					_disasm_jsr_unknown:
.aee4	20 b0 a3	jsr $a3b0	                jsr xt_two_drop
.aee7	60		rts		                rts
.aee8					oc_index_table:
>aee8	e8 b0 ec b0 80 b5 80 b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>aef0	f4 b0 fa b0 00 b1 80 b5
>aef8	06 b1 0a b1 10 b1 80 b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af00	16 b1 1a b1 1e b1 22 b1
>af08	27 b1 2b b1 33 b1 80 b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af10	3a b1 40 b1 47 b1 4e b1
>af18	55 b1 59 b1 5f b1 80 b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af20	65 b1 69 b1 80 b5 6f b1
>af28	75 b1 79 b1 80 b5 80 b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af30	81 b1 87 b1 8d b1 93 b1
>af38	9a b1 9e b1 a4 b1 80 b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af40	aa b1 ae b1 b3 b1 b7 b1
>af48	bc b1 c0 b1 c8 b1 80 b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af50	cf b1 d7 b1 de b1 e5 b1
>af58	ec b1 f0 b1 f6 b1 80 b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af60	fc b1 02 b2 08 b2 22 b1
>af68	13 b2 17 b2 80 b5 80 b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>af70	80 b5 1f b2 25 b2 2b b2
>af78	32 b2 36 b2 3c b2 80 b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>af80	42 b2 46 b2 4a b2 4e b2
>af88	53 b2 57 b2 5f b2 80 b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>af90	80 b5 66 b2 6d b2 74 b2
>af98	7b b2 7f b2 85 b2 80 b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>afa0	80 b5 80 b5 8f b2 95 b2
>afa8	9a b2 9e b2 80 b5 80 b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>afb0	a6 b2 ac b2 b2 b2 b8 b2
>afb8	bf b2 c3 b2 c9 b2 80 b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afc0	cf b2 d5 b2 d9 b2 dd b2
>afc8	e2 b2 e6 b2 ee b2 80 b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>afd0	f5 b2 fc b2 03 b3 0a b3
>afd8	11 b3 15 b3 1b b3 80 b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>afe0	1f b3 26 b3 2c b3 32 b3
>afe8	37 b3 3b b3 80 b5 80 b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>aff0	43 b3 49 b3 4f b3 80 b5
>aff8	55 b3 59 b3 5f b3 80 b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b000	63 b3 67 b3 6b b3 6f b3
>b008	74 b3 78 b3 80 b3 80 b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b010	87 b3 8e b3 95 b3 9c b3
>b018	a3 b3 a7 b3 ad b3 80 b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b020	b1 b3 b5 b3 bb b3 c1 b3
>b028	c6 b3 cc b3 d4 b3 80 b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b030	da b3 e0 b3 e6 b3 ec b3
>b038	f3 b3 f7 b3 fd b3 80 b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b040	01 b4 05 b4 09 b4 0d b4
>b048	12 b4 16 b4 1e b4 80 b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b050	25 b4 2c b4 33 b4 3a b4
>b058	41 b4 45 b4 4b b4 80 b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b060	4f b4 55 b4 5b b4 61 b4
>b068	66 b4 6c b4 80 b5 80 b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b070	74 b4 7a b4 80 b4 86 b4
>b078	8d b4 91 b4 97 b4 80 b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b080	9b b4 9f b4 a3 b4 a7 b4
>b088	ac b4 b0 b4 b8 b4 80 b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b090	80 b5 bf b4 c6 b4 cd b4
>b098	d4 b4 d8 b4 de b4 80 b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0a0	80 b5 e2 b4 e8 b4 ee b4
>b0a8	f3 b4 f9 b4 80 b5 80 b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0b0	01 b5 07 b5 0d b5 13 b5
>b0b8	1a b5 1e b5 24 b5 80 b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0c0	28 b5 2c b5 30 b5 34 b5
>b0c8	39 b5 3d b5 45 b5 80 b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b0d0	80 b5 4c b5 53 b5 5a b5
>b0d8	61 b5 65 b5 6b b5 80 b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b0e0	80 b5 6f b5 75 b5 7b b5
.b0e8					oc_table:
>b0e8	83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b0ec	87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b0f4	85 74 73 62 2e 7a		        oc04:   .text 2*64+5, "tsb.z"
>b0fa	85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b100	85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b106	43 70 68 70				oc08:	.text 1*64+3, "php"
>b10a	85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b110	45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b116	c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b11a	c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b11e	c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b122	c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b127	83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b12b	87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b133	86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b13a	85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b140	86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b147	86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b14e	86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b155	43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b159	c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b15f	45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b165	c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b169	c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b16f	c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b175	c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b179	87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b181	85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b187	85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b18d	85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b193	86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b19a	43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b19e	85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1a4	45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1aa	c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b1ae	c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1b3	c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1b7	c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1bc	83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1c0	87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b1c8	86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b1cf	87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b1d7	86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b1de	86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b1e5	86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b1ec	43 73 65 63				oc38:	.text 1*64+3, "sec"
>b1f0	c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b1f6	45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b1fc	c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b202	c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b208	c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b20e	c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b213	43 72 74 69				oc40:	.text 1*64+3, "rti"
>b217	87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b21f	85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b225	85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b22b	86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b232	43 70 68 61				oc48:	.text 1*64+3, "pha"
>b236	85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b23c	45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b242	c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b246	c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b24a	c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b24e	c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b253	83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b257	87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b25f	86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b266	86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b26d	86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b274	86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b27b	43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b27f	c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b285	43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b289	c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b28f	c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b295	c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b29a	43 72 74 73				oc60:	.text 1*64+3, "rts"
>b29e	87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2a6	85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b2ac	85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2b2	85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2b8	86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2bf	43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b2c3	85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b2c9	45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b2cf	c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b2d5	c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b2d9	c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b2dd	c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b2e2	83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b2e6	87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b2ee	86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b2f5	86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b2fc	86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b303	86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b30a	86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b311	43 73 65 69				oc78:	.text 1*64+3, "sei"
>b315	c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b31b	43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b31f	c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b326	c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b32c	c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b332	c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b337	83 62 72 61				oc80:	.text 2*64+3, "bra"
>b33b	87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b343	85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b349	85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b34f	85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b355	43 64 65 79				oc88:	.text 1*64+3, "dey"
>b359	85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b35f	43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b363	c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b367	c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b36b	c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b36f	c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b374	83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b378	87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b380	86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b387	86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b38e	86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b395	86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b39c	86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3a3	43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3a7	c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b3ad	43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3b1	c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3b5	c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3bb	c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b3c1	c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b3c6	85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b3cc	87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b3d4	85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b3da	85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b3e0	85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b3e6	85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b3ec	86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b3f3	43 74 61 79				oca8:	.text 1*64+3, "tay"
>b3f7	85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b3fd	43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b401	c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b405	c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b409	c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b40d	c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b412	83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b416	87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b41e	86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b425	86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b42c	86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b433	86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b43a	86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b441	43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b445	c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b44b	43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b44f	c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b455	c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b45b	c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b461	c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b466	85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b46c	87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b474	85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b47a	85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b480	85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b486	86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b48d	43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b491	85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b497	43 64 65 78				occa:	.text 1*64+3, "dex"
>b49b	c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b49f	c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4a3	c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4a7	c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b4ac	83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4b0	87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4b8	86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4bf	86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b4c6	86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b4cd	86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b4d4	43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b4d8	c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b4de	43 70 68 78				ocda:	.text 1*64+3, "phx"
>b4e2	c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b4e8	c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b4ee	c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b4f3	85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b4f9	87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b501	85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b507	85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b50d	85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b513	86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b51a	43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b51e	85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b524	43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b528	c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b52c	c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b530	c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b534	c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b539	83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b53d	87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b545	86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b54c	86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b553	86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b55a	86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b561	43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b565	c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b56b	43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b56f	c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b575	c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b57b	c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b580	01 3f					oc__:	.text 1, "?"
.b582					disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=46					ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=48					ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=50					ed_flags = editor3  ; Flags used by ed, where
.b582					ed6502:
.b582	a5 18		lda $18		                lda base
.b584	85 33		sta $33		                sta editor3+1
.b586	a9 0a		lda #$0a	                lda #10
.b588	85 18		sta $18		                sta base
.b58a	64 2e		stz $2e		                stz ed_head
.b58c	64 2f		stz $2f		                stz ed_head+1
.b58e	64 30		stz $30		                stz ed_cur
.b590	64 31		stz $31		                stz ed_cur+1
.b592	64 32		stz $32		                stz ed_flags
.b594	20 a8 a7	jsr $a7a8	                jsr xt_zero
.b597	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; ( addr-t u-t )
.b59a	20 63 89	jsr $8963	                jsr xt_cr
.b59d					ed_input_loop:
.b59d	a9 81		lda #$81	                lda #%10000001
.b59f	14 32		trb $32		                trb ed_flags
.b5a1	20 7c ba	jsr $ba7c	                jsr ed_get_input
.b5a4	a5 0a		lda $0a		                lda ciblen
.b5a6	d0 1f		bne $b5c7	                bne _command_mode
.b5a8	ca		dex		                dex
.b5a9	ca		dex		                dex                     ; ( addr-t u-t ? )
.b5aa	a5 30		lda $30		                lda ed_cur
.b5ac	95 00		sta $00,x	                sta 0,x
.b5ae	a5 31		lda $31		                lda ed_cur+1
.b5b0	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5b2	a9 80		lda #$80	                lda #%10000000
.b5b4	04 32		tsb $32		                tsb ed_flags
.b5b6	20 1d 98	jsr $981d	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5b9	20 98 ba	jsr $ba98	                jsr ed_is_valid_line
.b5bc	b0 03		bcs $b5c1	                bcs +
.b5be	4c 6c ba	jmp $ba6c	                jmp ed_error_1drop
.b5c1					+
.b5c1	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b5c4	4c 92 b6	jmp $b692	                jmp _line_number_only_from_external
.b5c7					_command_mode:
.b5c7	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b5ca	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b5cd					_prefix_dot:
.b5cd	b2 08		lda ($08)	                lda (cib)
.b5cf	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b5d1	d0 3a		bne $b60d	                bne _prefix_dollar
.b5d3	20 8d ba	jsr $ba8d	                jsr ed_have_text
.b5d6	a5 30		lda $30		                lda ed_cur
.b5d8	95 02		sta $02,x	                sta 2,x
.b5da	a5 31		lda $31		                lda ed_cur+1
.b5dc	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b5de	a9 80		lda #$80	                lda #%10000000
.b5e0	04 32		tsb $32		                tsb ed_flags
.b5e2	a5 0a		lda $0a		                lda ciblen
.b5e4	3a		dec a		                dea                     ; sets Z if A was 1
.b5e5	d0 03		bne $b5ea	                bne +
.b5e7	4c 92 b6	jmp $b692	                jmp _line_number_only_from_external
.b5ea					+
.b5ea	ca		dex		                dex
.b5eb	ca		dex		                dex
.b5ec	ca		dex		                dex
.b5ed	ca		dex		                dex
.b5ee	a5 08		lda $08		                lda cib
.b5f0	95 02		sta $02,x	                sta 2,x
.b5f2	a5 09		lda $09		                lda cib+1
.b5f4	95 03		sta $03,x	                sta 3,x
.b5f6	a5 0a		lda $0a		                lda ciblen
.b5f8	95 00		sta $00,x	                sta 0,x
.b5fa	a5 0b		lda $0b		                lda ciblen+1
.b5fc	95 01		sta $01,x	                sta 1,x
.b5fe	20 11 98	jsr $9811	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b601	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b604	20 1d 98	jsr $981d	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b607	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b60a	4c ea b6	jmp $b6ea	                jmp _check_for_para2
.b60d					_prefix_dollar:
.b60d	b2 08		lda ($08)	                lda (cib)
.b60f	c9 24		cmp #$24	                cmp #'$'
.b611	d0 1c		bne $b62f	                bne _prefix_percent
.b613	20 8d ba	jsr $ba8d	                jsr ed_have_text
.b616	e8		inx		                inx
.b617	e8		inx		                inx                     ; ( addr-t u-t 0 )
.b618	20 ba ba	jsr $baba	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b61b	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b61e	a9 80		lda #$80	                lda #%10000000
.b620	04 32		tsb $32		                tsb ed_flags
.b622	a5 0a		lda $0a		                lda ciblen
.b624	3a		dec a		                dea                     ; sets Z if A was 1
.b625	d0 03		bne $b62a	                bne +
.b627	4c 92 b6	jmp $b692	                jmp _line_number_only_from_external
.b62a					+
.b62a	a0 01		ldy #$01	                ldy #01
.b62c	4c 66 b7	jmp $b766	                jmp _check_command
.b62f					_prefix_percent:
.b62f	b2 08		lda ($08)	                lda (cib)
.b631	c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b633	f0 04		beq $b639	                beq _whole_text
.b635	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b637	d0 17		bne $b650	                bne _prefix_semicolon
.b639					_whole_text:
.b639	20 8d ba	jsr $ba8d	                jsr ed_have_text
.b63c	a9 01		lda #$01	                lda #01
.b63e	95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b640	74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b642					_semicolon_entry:
.b642	e8		inx		                inx
.b643	e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b644	20 ba ba	jsr $baba	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b647	a9 80		lda #$80	                lda #%10000000
.b649	04 32		tsb $32		                tsb ed_flags
.b64b	a0 01		ldy #$01	                ldy #01
.b64d	4c 66 b7	jmp $b766	                jmp _check_command
.b650					_prefix_semicolon:
.b650	b2 08		lda ($08)	                lda (cib)
.b652	c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b654	d0 0d		bne $b663	                bne _prefix_number
.b656	20 8d ba	jsr $ba8d	                jsr ed_have_text
.b659	a5 30		lda $30		                lda ed_cur
.b65b	95 02		sta $02,x	                sta 2,x
.b65d	a5 31		lda $31		                lda ed_cur+1
.b65f	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b661	80 df		bra $b642	                bra _semicolon_entry
.b663					_prefix_number:
.b663	20 a8 a7	jsr $a7a8	                jsr xt_zero
.b666	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b669	ca		dex		                dex
.b66a	ca		dex		                dex
.b66b	ca		dex		                dex
.b66c	ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b66d	a5 08		lda $08		                lda cib
.b66f	95 02		sta $02,x	                sta 2,x
.b671	a5 09		lda $09		                lda cib+1
.b673	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b675	a5 0a		lda $0a		                lda ciblen
.b677	95 00		sta $00,x	                sta 0,x
.b679	a5 0b		lda $0b		                lda ciblen+1
.b67b	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b67d	20 bd a2	jsr $a2bd	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b680	b5 00		lda $00,x	                lda 0,x
.b682	15 01		ora $01,x	                ora 1,x
.b684	d0 24		bne $b6aa	                bne _have_unconverted_chars
.b686	e8		inx		                inx
.b687	e8		inx		                inx
.b688	e8		inx		                inx
.b689	e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b68a	20 80 8a	jsr $8a80	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b68d	20 6e 96	jsr $966e	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b690	e8		inx		                inx
.b691	e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b692					_line_number_only_from_external:
.b692	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b695	20 98 ba	jsr $ba98	                jsr ed_is_valid_line
.b698	b0 03		bcs $b69d	                bcs +
.b69a	4c 6a ba	jmp $ba6a	                jmp ed_error_2drop
.b69d					+
.b69d	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6a0	20 27 bb	jsr $bb27	                jsr ed_para1_to_cur
.b6a3	a9 80		lda #$80	                lda #%10000000
.b6a5	04 32		tsb $32		                tsb ed_flags
.b6a7	4c 45 b9	jmp $b945	                jmp ed_cmd_p_from_external
.b6aa					_have_unconverted_chars:
.b6aa	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b6ad	ca		dex		                dex
.b6ae	ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6af	a5 0a		lda $0a		                lda ciblen
.b6b1	95 00		sta $00,x	                sta 0,x
.b6b3	a5 0b		lda $0b		                lda ciblen+1
.b6b5	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6b7	20 ce 8e	jsr $8ece	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6ba	b5 00		lda $00,x	                lda 0,x
.b6bc	15 01		ora $01,x	                ora 1,x
.b6be	f0 0e		beq $b6ce	                beq _no_command_yet
.b6c0	8a		txa		                txa
.b6c1	18		clc		                clc
.b6c2	69 0a		adc #$0a	                adc #10
.b6c4	aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b6c5	a9 80		lda #$80	                lda #%10000000
.b6c7	14 32		trb $32		                trb ed_flags
.b6c9	a0 00		ldy #$00	                ldy #00
.b6cb	4c 66 b7	jmp $b766	                jmp _check_command
.b6ce					_no_command_yet:
.b6ce	e8		inx		                inx
.b6cf	e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b6d0	20 70 a3	jsr $a370	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b6d3	20 6e 96	jsr $966e	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b6d6	20 80 8a	jsr $8a80	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b6d9	b5 00		lda $00,x	                lda 0,x                 ; LSB
.b6db	95 06		sta $06,x	                sta 6,x
.b6dd	b5 01		lda $01,x	                lda 1,x                 ; MSB
.b6df	95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b6e1	e8		inx		                inx
.b6e2	e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b6e3	20 92 9a	jsr $9a92	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b6e6	a9 80		lda #$80	                lda #%10000000
.b6e8	04 32		tsb $32		                tsb ed_flags
.b6ea					_check_for_para2:
.b6ea	a1 02		lda ($02,x)	                lda (2,x)
.b6ec	c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b6ee	f0 0d		beq $b6fd	                beq _got_comma
.b6f0	38		sec		                sec
.b6f1	a5 0a		lda $0a		                lda ciblen
.b6f3	f5 00		sbc $00,x	                sbc 0,x
.b6f5	a8		tay		                tay
.b6f6	e8		inx		                inx
.b6f7	e8		inx		                inx
.b6f8	e8		inx		                inx
.b6f9	e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b6fa	4c 66 b7	jmp $b766	                jmp _check_command
.b6fd					_got_comma:
.b6fd	f6 02		inc $02,x	                inc 2,x
.b6ff	d0 02		bne $b703	                bne +
.b701	f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b703					+
.b703	b5 01		lda $01,x	                lda 1,x
.b705	f0 02		beq $b709	                beq +
.b707	d6 01		dec $01,x	                dec 1,x
.b709					+
.b709	d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b70b	a1 02		lda ($02,x)	                lda (2,x)
.b70d	c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b70f	d0 14		bne $b725	                bne _para2_not_dollar
.b711	38		sec		                sec
.b712	a5 0a		lda $0a		                lda ciblen
.b714	f5 02		sbc $02,x	                sbc 2,x
.b716	a8		tay		                tay
.b717	c8		iny		                iny
.b718	5a		phy		                phy
.b719	8a		txa		                txa
.b71a	18		clc		                clc
.b71b	69 06		adc #$06	                adc #06
.b71d	aa		tax		                tax                     ; ( addr-t u-t para1 )
.b71e	20 ba ba	jsr $baba	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b721	7a		ply		                ply
.b722	4c 66 b7	jmp $b766	                jmp _check_command
.b725					_para2_not_dollar:
.b725	20 70 a3	jsr $a370	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b728	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b72b	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b72e	20 57 9b	jsr $9b57	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b731	20 92 9a	jsr $9a92	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b734	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b737	20 70 a3	jsr $a370	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b73a	20 bd a2	jsr $a2bd	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b73d	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b740	20 92 9a	jsr $9a92	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b743	20 ce 8e	jsr $8ece	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b746	b5 00		lda $00,x	                lda 0,x
.b748	15 01		ora $01,x	                ora 1,x
.b74a	f0 08		beq $b754	                beq _second_number
.b74c	8a		txa		                txa
.b74d	18		clc		                clc
.b74e	69 0c		adc #$0c	                adc #12
.b750	aa		tax		                tax                     ; back to ( addr-t u-t )
.b751	4c 6e ba	jmp $ba6e	                jmp ed_error
.b754					_second_number:
.b754	e8		inx		                inx
.b755	e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b756	38		sec		                sec
.b757	a5 0a		lda $0a		                lda ciblen
.b759	f5 00		sbc $00,x	                sbc 0,x
.b75b	48		pha		                pha
.b75c	20 b0 a3	jsr $a3b0	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b75f	20 80 8a	jsr $8a80	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b762	20 42 96	jsr $9642	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b765	7a		ply		                ply
.b766					_check_command:
.b766	24 32		bit $32		                bit ed_flags
.b768	30 08		bmi $b772	                bmi _check_command_have_arg
.b76a	a5 30		lda $30		                lda ed_cur
.b76c	95 02		sta $02,x	                sta 2,x
.b76e	a5 31		lda $31		                lda ed_cur+1
.b770	95 03		sta $03,x	                sta 3,x
.b772					_check_command_have_arg:
.b772	b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b774	85 24		sta $24		                sta tmp1
.b776	da		phx		                phx
.b777	a2 00		ldx #$00	                ldx #00
.b779					_cmd_loop:
.b779	bd 52 bb	lda $bb52,x	                lda ed_cmd_list,x
.b77c	f0 07		beq $b785	                beq _illegal_command    ; zero marks end of list
.b77e	c5 24		cmp $24		                cmp tmp1
.b780	f0 07		beq $b789	                beq _found_cmd
.b782	e8		inx		                inx
.b783	80 f4		bra $b779	                bra _cmd_loop
.b785					_illegal_command:
.b785	fa		plx		                plx
.b786	4c 6a ba	jmp $ba6a	                jmp ed_error_2drop
.b789					_found_cmd:
.b789	8a		txa		                txa
.b78a	0a		asl a		                asl
.b78b	aa		tax		                tax                     ; X * 2 for table
.b78c	7c 5d bb	jmp ($bb5d,x)	                jmp (ed_cmd_table,x)
.b78f					ed_next_command:
.b78f	e8		inx		                inx
.b790	e8		inx		                inx
.b791	e8		inx		                inx
.b792	e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b793					_next_command_empty:
.b793	4c 9d b5	jmp $b59d	                jmp ed_input_loop
.b796					ed_all_done:
.b796	64 0a		stz $0a		                stz ciblen
.b798	64 0b		stz $0b		                stz ciblen+1
.b79a	20 b0 a3	jsr $a3b0	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b79d	a5 33		lda $33		                lda editor3+1
.b79f	85 18		sta $18		                sta base
.b7a1	60		rts		                rts
.b7a2					ed_cmd_a:
.b7a2	fa		plx		                plx
.b7a3	e8		inx		                inx
.b7a4	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7a5					ed_entry_cmd_i:
.b7a5					ed_cmd_a_have_para:
.b7a5	20 f0 ba	jsr $baf0	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7a8	20 63 89	jsr $8963	                jsr xt_cr
.b7ab					_next_string_loop:
.b7ab	20 7c ba	jsr $ba7c	                jsr ed_get_input
.b7ae	b2 08		lda ($08)	                lda (cib)
.b7b0	c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7b2	d0 16		bne $b7ca	                bne _add_line
.b7b4	a4 0a		ldy $0a		                ldy ciblen
.b7b6	c0 01		cpy #$01	                cpy #01
.b7b8	d0 10		bne $b7ca	                bne _add_line
.b7ba	a4 0b		ldy $0b		                ldy ciblen+1
.b7bc	d0 0c		bne $b7ca	                bne _add_line
.b7be	e8		inx		                inx
.b7bf	e8		inx		                inx
.b7c0	a9 40		lda #$40	                lda #%01000000
.b7c2	04 32		tsb $32		                tsb ed_flags
.b7c4	20 63 89	jsr $8963	                jsr xt_cr
.b7c7	4c 9d b5	jmp $b59d	                jmp ed_input_loop
.b7ca					_add_line:
.b7ca	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b7cd	20 72 91	jsr $9172	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b7d0	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b7d3	20 80 8f	jsr $8f80	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b7d6	20 6e 87	jsr $876e	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b7d9	20 8d a3	jsr $a38d	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b7dc	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b7df	20 8d a1	jsr $a18d	                jsr xt_store            ; ! ( addr-t u-t here )
.b7e2	20 72 91	jsr $9172	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b7e5	a5 00		lda $00		                lda cp
.b7e7	18		clc		                clc
.b7e8	69 04		adc #$04	                adc #04
.b7ea	85 00		sta $00		                sta cp
.b7ec	90 02		bcc $b7f0	                bcc +
.b7ee	e6 01		inc $01		                inc cp+1
.b7f0					+
.b7f0	e6 30		inc $30		                inc ed_cur
.b7f2	d0 02		bne $b7f6	                bne +
.b7f4	e6 31		inc $31		                inc ed_cur+1
.b7f6					+
.b7f6	20 72 91	jsr $9172	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b7f9	20 af 8d	jsr $8daf	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b7fc	ca		dex		                dex
.b7fd	ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b7fe	a5 08		lda $08		                lda cib
.b800	95 00		sta $00,x	                sta 0,x
.b802	a5 09		lda $09		                lda cib+1
.b804	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b806	20 ae a1	jsr $a1ae	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b809	ca		dex		                dex
.b80a	ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b80b	a5 0a		lda $0a		                lda ciblen
.b80d	95 00		sta $00,x	                sta 0,x
.b80f	a5 0b		lda $0b		                lda ciblen+1
.b811	95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b813	20 c2 95	jsr $95c2	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b816	18		clc		                clc
.b817	a5 00		lda $00		                lda cp
.b819	65 0a		adc $0a		                adc ciblen
.b81b	85 00		sta $00		                sta cp
.b81d	90 06		bcc $b825	                bcc +
.b81f	a5 01		lda $01		                lda cp+1
.b821	65 0b		adc $0b		                adc ciblen+1
.b823	85 01		sta $01		                sta cp+1
.b825					+
.b825	20 93 98	jsr $9893	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b828	20 8d a1	jsr $a18d	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b82b	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+
.b82e	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b831	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b834	a5 0a		lda $0a		                lda ciblen
.b836	95 02		sta $02,x	                sta 2,x
.b838	a5 0b		lda $0b		                lda ciblen+1
.b83a	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b83c	20 8d a1	jsr $a18d	                jsr xt_store            ; ! ( addr-t u-t here )
.b83f	20 63 89	jsr $8963	                jsr xt_cr
.b842	4c ab b7	jmp $b7ab	                jmp _next_string_loop
.b845					ed_cmd_d:
.b845	fa		plx		                plx
.b846	20 8d ba	jsr $ba8d	                jsr ed_have_text
.b849	20 e2 ba	jsr $bae2	                jsr ed_no_line_zero
.b84c	b5 00		lda $00,x	                lda 0,x
.b84e	15 01		ora $01,x	                ora 1,x
.b850	d0 08		bne $b85a	                bne +
.b852	20 93 98	jsr $9893	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b855	20 97 b8	jsr $b897	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b858	80 33		bra $b88d	                bra _cmd_d_done
.b85a					+
.b85a	20 98 ba	jsr $ba98	                jsr ed_is_valid_line      ; result is in C flag
.b85d	b0 03		bcs $b862	                bcs _cmd_d_loop
.b85f	4c 6a ba	jmp $ba6a	                jmp ed_error_2drop
.b862					_cmd_d_loop:
.b862	20 b8 a3	jsr $a3b8	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b865	20 5d 91	jsr $915d	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b868	b5 00		lda $00,x	                lda 0,x
.b86a	15 01		ora $01,x	                ora 1,x
.b86c	d0 0d		bne $b87b	                bne _cmd_d_done_with_flag
.b86e	e8		inx		                inx
.b86f	e8		inx		                inx                     ; Get rid of the flag from >
.b870	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b873	20 97 b8	jsr $b897	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b876	20 11 98	jsr $9811	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b879	80 e7		bra $b862	                bra _cmd_d_loop
.b87b					_cmd_d_done_with_flag:
.b87b	e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b87c	e8		inx		                inx
.b87d	b5 02		lda $02,x	                lda 2,x
.b87f	d0 02		bne $b883	                bne +
.b881	d6 03		dec $03,x	                dec 3,x
.b883					+
.b883	d6 02		dec $02,x	                dec 2,x
.b885	b5 02		lda $02,x	                lda 2,x
.b887	85 30		sta $30		                sta ed_cur
.b889	b5 03		lda $03,x	                lda 3,x
.b88b	85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b88d					_cmd_d_done:
.b88d	a9 40		lda #$40	                lda #%01000000
.b88f	04 32		tsb $32		                tsb ed_flags
.b891	20 63 89	jsr $8963	                jsr xt_cr
.b894	4c 8f b7	jmp $b78f	                jmp ed_next_command
.b897					_cmd_d_common:
.b897	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b89a	20 f0 ba	jsr $baf0	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b89d	20 80 8f	jsr $8f80	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8a0	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8a3	20 11 98	jsr $9811	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8a6	20 f0 ba	jsr $baf0	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8a9	20 8d a1	jsr $a18d	                jsr xt_store            ; ! ( addr-t u-t )
.b8ac	60		rts		                rts
.b8ad					ed_cmd_equ:
.b8ad	fa		plx		                plx
.b8ae	a5 2e		lda $2e		                lda ed_head
.b8b0	05 2f		ora $2f		                ora ed_head+1
.b8b2	d0 08		bne $b8bc	                bne _cmd_equ_have_text
.b8b4	ca		dex		                dex
.b8b5	ca		dex		                dex
.b8b6	74 00		stz $00,x	                stz 0,x
.b8b8	74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8ba	80 21		bra $b8dd	                bra _cmd_equ_done
.b8bc					_cmd_equ_have_text:
.b8bc	20 e2 ba	jsr $bae2	                jsr ed_no_line_zero
.b8bf	24 32		bit $32		                bit ed_flags
.b8c1	30 0c		bmi $b8cf	                bmi _cmd_equ_have_para
.b8c3	ca		dex		                dex
.b8c4	ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b8c5	a5 30		lda $30		                lda ed_cur
.b8c7	95 00		sta $00,x	                sta 0,x
.b8c9	a5 31		lda $31		                lda ed_cur+1
.b8cb	95 01		sta $01,x	                sta 1,x
.b8cd	80 0e		bra $b8dd	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b8cf					_cmd_equ_have_para:
.b8cf	b5 00		lda $00,x	                lda 0,x
.b8d1	15 01		ora $01,x	                ora 1,x
.b8d3	d0 05		bne $b8da	                bne _cmd_equ_two_paras
.b8d5	20 93 98	jsr $9893	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b8d8	80 03		bra $b8dd	                bra _cmd_equ_done
.b8da					_cmd_equ_two_paras:
.b8da	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b8dd					_cmd_equ_done:
.b8dd	20 63 89	jsr $8963	                jsr xt_cr               ; number goes on new line
.b8e0	20 2e a5	jsr $a52e	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b8e3	20 63 89	jsr $8963	                jsr xt_cr
.b8e6	4c 8f b7	jmp $b78f	                jmp ed_next_command
.b8e9					ed_cmd_f:
.b8e9	fa		plx		                plx
.b8ea	24 32		bit $32		                bit ed_flags
.b8ec	30 17		bmi $b905	                bmi _cmd_f_have_para
.b8ee	20 63 89	jsr $8963	                jsr xt_cr
.b8f1	20 70 a3	jsr $a370	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b8f4	20 57 9b	jsr $9b57	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b8f7	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b8fa	20 2e a5	jsr $a52e	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b8fd	20 6e 96	jsr $966e	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b900	20 92 9a	jsr $9a92	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b903	80 11		bra $b916	                bra _cmd_f_done
.b905					_cmd_f_have_para:
.b905	20 93 98	jsr $9893	                jsr xt_over
.b908	20 63 89	jsr $8963	                jsr xt_cr
.b90b	20 2e a5	jsr $a52e	                jsr xt_u_dot
.b90e	b5 02		lda $02,x	                lda 2,x
.b910	95 06		sta $06,x	                sta 6,x
.b912	b5 03		lda $03,x	                lda 3,x
.b914	95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b916					_cmd_f_done:
.b916	20 63 89	jsr $8963	                jsr xt_cr
.b919	4c 8f b7	jmp $b78f	                jmp ed_next_command
.b91c					ed_cmd_i:
.b91c	fa		plx		                plx
.b91d	e8		inx		                inx
.b91e	e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b91f	24 32		bit $32		                bit ed_flags
.b921	30 08		bmi $b92b	                bmi _cmd_i_have_para
.b923	a5 30		lda $30		                lda ed_cur
.b925	95 00		sta $00,x	                sta 0,x
.b927	a5 31		lda $31		                lda ed_cur+1
.b929	95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b92b					_cmd_i_have_para:
.b92b	b5 00		lda $00,x	                lda 0,x
.b92d	15 01		ora $01,x	                ora 1,x
.b92f	f0 09		beq $b93a	                beq _cmd_i_done
.b931	20 11 98	jsr $9811	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b934	20 a8 a7	jsr $a7a8	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b937	20 18 95	jsr $9518	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b93a					_cmd_i_done:
.b93a	4c a5 b7	jmp $b7a5	                jmp ed_entry_cmd_i
.b93d					ed_cmd_n:
.b93d	fa		plx		                plx
.b93e	a9 01		lda #$01	                lda #%00000001
.b940	04 32		tsb $32		                tsb ed_flags
.b942	80 05		bra $b949	                bra ed_cmd_p_entry_for_cmd_n
.b944					ed_cmd_p:
.b944	fa		plx		                plx
.b945					ed_cmd_p_from_external:
.b945	a9 01		lda #$01	                lda #%00000001
.b947	14 32		trb $32		                trb ed_flags
.b949					ed_cmd_p_entry_for_cmd_n:
.b949	20 8d ba	jsr $ba8d	                jsr ed_have_text
.b94c	20 e2 ba	jsr $bae2	                jsr ed_no_line_zero
.b94f	20 63 89	jsr $8963	                jsr xt_cr
.b952	b5 00		lda $00,x	                lda 0,x
.b954	15 01		ora $01,x	                ora 1,x
.b956	d0 10		bne $b968	                bne _cmd_p_loop
.b958	b5 02		lda $02,x	                lda 2,x
.b95a	85 30		sta $30		                sta ed_cur
.b95c	b5 03		lda $03,x	                lda 3,x
.b95e	85 31		sta $31		                sta ed_cur+1
.b960	20 93 98	jsr $9893	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b963	20 91 b9	jsr $b991	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b966	80 26		bra $b98e	                bra _cmd_p_all_done
.b968					_cmd_p_loop:
.b968	20 b8 a3	jsr $a3b8	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b96b	20 5d 91	jsr $915d	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b96e	b5 00		lda $00,x	                lda 0,x
.b970	15 01		ora $01,x	                ora 1,x
.b972	d0 10		bne $b984	                bne _cmd_p_done
.b974	e8		inx		                inx
.b975	e8		inx		                inx                     ; Get rid of the flag from >
.b976	20 93 98	jsr $9893	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b979	20 91 b9	jsr $b991	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b97c	f6 02		inc $02,x	                inc 2,x
.b97e	d0 02		bne $b982	                bne +
.b980	f6 03		inc $03,x	                inc 3,x
.b982					+
.b982	80 e4		bra $b968	                bra _cmd_p_loop
.b984					_cmd_p_done:
.b984	e8		inx		                inx
.b985	e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b986	b5 00		lda $00,x	                lda 0,x
.b988	85 30		sta $30		                sta ed_cur
.b98a	b5 01		lda $01,x	                lda 1,x
.b98c	85 31		sta $31		                sta ed_cur+1
.b98e					_cmd_p_all_done:
.b98e	4c 8f b7	jmp $b78f	                jmp ed_next_command
.b991					_cmd_p_common:
.b991	a5 32		lda $32		                lda ed_flags
.b993	4a		lsr a		                lsr                     ; bit 0 now in carry
.b994	90 0b		bcc $b9a1	                bcc _cmd_p_common_no_num
.b996	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b999	20 2e a5	jsr $a52e	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b99c	a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b99e	20 f6 8d	jsr $8df6	                jsr emit_a
.b9a1					_cmd_p_common_no_num:
.b9a1	20 f0 ba	jsr $baf0	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9a4	20 30 bb	jsr $bb30	                jsr ed_print_addr
.b9a7	60		rts		                rts
.b9a8					ed_cmd_q:
.b9a8	fa		plx		                plx
.b9a9	24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b9ab	50 03		bvc $b9b0	                bvc +
.b9ad	4c 6a ba	jmp $ba6a	                jmp ed_error_2drop
.b9b0					+
.b9b0	4c 96 b7	jmp $b796	                jmp ed_all_done            ; can't fall thru because of PLX
.b9b3					ed_cmd_qq:
.b9b3	fa		plx		                plx
.b9b4	4c 96 b7	jmp $b796	                jmp ed_all_done
.b9b7					ed_cmd_w:
.b9b7	fa		plx		                plx
.b9b8	20 8d ba	jsr $ba8d	                jsr ed_have_text
.b9bb	24 32		bit $32		                bit ed_flags
.b9bd	30 13		bmi $b9d2	                bmi _cmd_w_have_para
.b9bf	b5 06		lda $06,x	                lda 6,x
.b9c1	15 07		ora $07,x	                ora 7,x
.b9c3	d0 03		bne $b9c8	                bne +
.b9c5	4c 6a ba	jmp $ba6a	                jmp ed_error_2drop
.b9c8					+
.b9c8	b5 06		lda $06,x	                lda 6,x
.b9ca	95 02		sta $02,x	                sta 2,x
.b9cc	b5 07		lda $07,x	                lda 7,x
.b9ce	95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.b9d0	80 08		bra $b9da	                bra _cmd_w_para_ready
.b9d2					_cmd_w_have_para:
.b9d2	b5 02		lda $02,x	                lda 2,x
.b9d4	95 06		sta $06,x	                sta 6,x
.b9d6	b5 03		lda $03,x	                lda 3,x
.b9d8	95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.b9da					_cmd_w_para_ready:
.b9da	a9 2e		lda #$2e	                lda #<ed_head
.b9dc	95 00		sta $00,x	                sta 0,x
.b9de	a9 00		lda #$00	                lda #>ed_head
.b9e0	95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.b9e2	20 93 98	jsr $9893	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.b9e5	20 70 a3	jsr $a370	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.b9e8					_cmd_w_loop:
.b9e8	20 80 8f	jsr $8f80	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.b9eb	b5 00		lda $00,x	                lda 0,x
.b9ed	15 01		ora $01,x	                ora 1,x
.b9ef	f0 55		beq $ba46	                beq _cmd_w_eol
.b9f1	20 b8 a3	jsr $a3b8	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.b9f4	20 a2 a4	jsr $a4a2	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.b9f7	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.b9fa	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.b9fd	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba00	20 80 8f	jsr $8f80	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba03	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba06	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba09	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba0c	20 80 8f	jsr $8f80	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba0f	20 6e 96	jsr $966e	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba12	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba15	20 57 9b	jsr $9b57	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba18	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba1b	20 70 a3	jsr $a370	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba1e	20 c2 95	jsr $95c2	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba21	20 92 9a	jsr $9a92	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba24	20 28 a4	jsr $a428	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba27	20 6e 96	jsr $966e	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba2a	20 e3 99	jsr $99e3	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba2d	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba30	ca		dex		                dex
.ba31	ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba32	a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba34	95 00		sta $00,x	                sta 0,x
.ba36	74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba38	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba3b	20 8d a1	jsr $a18d	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba3e	20 1d 98	jsr $981d	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba41	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba44	80 a2		bra $b9e8	                bra _cmd_w_loop
.ba46					_cmd_w_eol:
.ba46	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba49	20 92 9a	jsr $9a92	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba4c	20 50 95	jsr $9550	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba4f	b5 00		lda $00,x	                lda 0,x
.ba51	95 04		sta $04,x	                sta 4,x
.ba53	b5 01		lda $01,x	                lda 1,x
.ba55	95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba57	20 63 89	jsr $8963	                jsr xt_cr
.ba5a	20 af 8d	jsr $8daf	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba5d	20 2e a5	jsr $a52e	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba60	20 63 89	jsr $8963	                jsr xt_cr
.ba63	a9 40		lda #$40	                lda #%01000000
.ba65	14 32		trb $32		                trb ed_flags
.ba67	4c 8f b7	jmp $b78f	                jmp ed_next_command
.ba6a					ed_error_2drop:
.ba6a	e8		inx		                inx
.ba6b	e8		inx		                inx                     ; drop through to _error_1drop
.ba6c					ed_error_1drop:
.ba6c	e8		inx		                inx
.ba6d	e8		inx		                inx                     ; drop through to _error
.ba6e					ed_error:
.ba6e	20 63 89	jsr $8963	                jsr xt_cr
.ba71	a9 3f		lda #$3f	                lda #'?'
.ba73	20 f6 8d	jsr $8df6	                jsr emit_a
.ba76	20 63 89	jsr $8963	                jsr xt_cr
.ba79	4c 9d b5	jmp $b59d	                jmp ed_input_loop
.ba7c					ed_get_input:
.ba7c	20 f8 9a	jsr $9af8	                jsr xt_refill           ;  ( addr-t u-t f )
.ba7f	b5 00		lda $00,x	                lda 0,x
.ba81	15 01		ora $01,x	                ora 1,x
.ba83	d0 05		bne $ba8a	                bne +
.ba85	7a		ply		                ply
.ba86	7a		ply		                ply
.ba87	4c 6c ba	jmp $ba6c	                jmp ed_error_1drop
.ba8a					+
.ba8a	e8		inx		                inx
.ba8b	e8		inx		                inx
.ba8c	60		rts		                rts
.ba8d					ed_have_text:
.ba8d	a5 2e		lda $2e		                lda ed_head
.ba8f	05 2f		ora $2f		                ora ed_head+1
.ba91	d0 04		bne $ba97	                bne +
.ba93	7a		ply		                ply
.ba94	7a		ply		                ply
.ba95	80 d7		bra $ba6e	                bra ed_error
.ba97					+
.ba97	60		rts		                rts
.ba98					ed_is_valid_line:
.ba98	38		sec		                sec                             ; default is legal line number
.ba99	b5 00		lda $00,x	                lda 0,x
.ba9b	15 01		ora $01,x	                ora 1,x
.ba9d	f0 19		beq $bab8	                beq _is_valid_line_nope_zero    ; ( n )
.ba9f	20 af 8d	jsr $8daf	                jsr xt_dup                      ; DUP ( n n )
.baa2	20 ba ba	jsr $baba	                jsr ed_last_line                  ; ( n n last )
.baa5	20 ae a1	jsr $a1ae	                jsr xt_swap                     ; SWAP ( n last n )
.baa8	20 68 93	jsr $9368	                jsr xt_less_than                ; < ( n f )
.baab	b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.baad	15 01		ora $01,x	                ora 1,x
.baaf	d0 05		bne $bab6	                bne _is_valid_line_too_small
.bab1	e8		inx		                inx
.bab2	e8		inx		                inx                     ; DROP flag ( n )
.bab3	38		sec		                sec                     ; Who knows what's happened to C by now
.bab4	80 03		bra $bab9	                bra _is_valid_line_done ; only one exit from this routine
.bab6					_is_valid_line_too_small:
.bab6	e8		inx		                inx
.bab7	e8		inx		                inx                     ; drop through to _is_valid_line_zero
.bab8					_is_valid_line_nope_zero:
.bab8	18		clc		                clc                     ; drop through to _is_valid_line_done
.bab9					_is_valid_line_done:
.bab9	60		rts		                rts
.baba					ed_last_line:
.baba	64 24		stz $24		                stz tmp1
.babc	64 25		stz $25		                stz tmp1+1
.babe	ca		dex		                dex
.babf	ca		dex		                dex                     ; ( ? )
.bac0	a9 2e		lda #$2e	                lda #<ed_head
.bac2	95 00		sta $00,x	                sta 0,x
.bac4	a9 00		lda #$00	                lda #>ed_head
.bac6	95 01		sta $01,x	                sta 1,x                 ; ( addr )
.bac8					_last_line_loop:
.bac8	20 80 8f	jsr $8f80	                jsr xt_fetch            ; ( addr | 0 )
.bacb	b5 00		lda $00,x	                lda 0,x
.bacd	15 01		ora $01,x	                ora 1,x
.bacf	f0 08		beq $bad9	                beq _last_line_done
.bad1	e6 24		inc $24		                inc tmp1
.bad3	d0 02		bne $bad7	                bne +
.bad5	e6 25		inc $25		                inc tmp1+1
.bad7					+
.bad7	80 ef		bra $bac8	                bra _last_line_loop
.bad9					_last_line_done:
.bad9	a5 24		lda $24		                lda tmp1
.badb	95 00		sta $00,x	                sta 0,x
.badd	a5 25		lda $25		                lda tmp1+1
.badf	95 01		sta $01,x	                sta 1,x                 ; ( u )
.bae1	60		rts		                rts
.bae2					ed_no_line_zero:
.bae2	b5 02		lda $02,x	                lda 2,x
.bae4	15 03		ora $03,x	                ora 3,x
.bae6	d0 07		bne $baef	                bne _no_line_zero_done
.bae8	24 32		bit $32		                bit ed_flags
.baea	10 03		bpl $baef	                bpl _no_line_zero_done
.baec	4c 6a ba	jmp $ba6a	                jmp ed_error_2drop
.baef					_no_line_zero_done:
.baef	60		rts		                rts
.baf0					ed_num_to_addr:
.baf0	ca		dex		                dex
.baf1	ca		dex		                dex                     ; ( u ? )
.baf2	a9 2e		lda #$2e	                lda #<ed_head
.baf4	95 00		sta $00,x	                sta 0,x
.baf6	a9 00		lda #$00	                lda #>ed_head
.baf8	95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bafa	b5 02		lda $02,x	                lda 2,x
.bafc	15 03		ora $03,x	                ora 3,x
.bafe	d0 05		bne $bb05	                bne _num_to_addr_loop
.bb00	20 42 96	jsr $9642	                jsr xt_nip              ; ( addr-h )
.bb03	80 21		bra $bb26	                bra _num_to_addr_done
.bb05					_num_to_addr_loop:
.bb05	20 80 8f	jsr $8f80	                jsr xt_fetch            ; @ ( u addr1 )
.bb08	b5 00		lda $00,x	                lda 0,x
.bb0a	15 01		ora $01,x	                ora 1,x
.bb0c	d0 05		bne $bb13	                bne +
.bb0e	20 42 96	jsr $9642	                jsr xt_nip              ; NIP ( addr1 )
.bb11	80 13		bra $bb26	                bra _num_to_addr_done
.bb13					+
.bb13	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( addr1 u )
.bb16	20 11 98	jsr $9811	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb19	b5 00		lda $00,x	                lda 0,x
.bb1b	15 01		ora $01,x	                ora 1,x
.bb1d	f0 05		beq $bb24	                beq _num_to_addr_finished
.bb1f	20 ae a1	jsr $a1ae	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb22	80 e1		bra $bb05	                bra _num_to_addr_loop
.bb24					_num_to_addr_finished:
.bb24	e8		inx		                inx
.bb25	e8		inx		                inx                     ; ( addr )
.bb26					_num_to_addr_done:
.bb26	60		rts		                rts
.bb27					ed_para1_to_cur:
.bb27	b5 02		lda $02,x	                lda 2,x
.bb29	85 30		sta $30		                sta ed_cur
.bb2b	b5 03		lda $03,x	                lda 3,x
.bb2d	85 31		sta $31		                sta ed_cur+1
.bb2f	60		rts		                rts
.bb30					ed_print_addr:
.bb30	20 1d 98	jsr $981d	                jsr xt_one_plus
.bb33	20 1d 98	jsr $981d	                jsr xt_one_plus         ; ( addr+2 )
.bb36	20 af 8d	jsr $8daf	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb39	20 1d 98	jsr $981d	                jsr xt_one_plus
.bb3c	20 1d 98	jsr $981d	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb3f	20 80 8f	jsr $8f80	                jsr xt_fetch            ; ( addr+2 u-s )
.bb42	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( u-s addr+2 )
.bb45	20 80 8f	jsr $8f80	                jsr xt_fetch            ; ( u-s addr-s )
.bb48	20 ae a1	jsr $a1ae	                jsr xt_swap             ; ( addr-s u-s )
.bb4b	20 03 a5	jsr $a503	                jsr xt_type
.bb4e	20 63 89	jsr $8963	                jsr xt_cr
.bb51	60		rts		                rts
>bb52	61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb5a	71 51 00
.bb5d					ed_cmd_table:
>bb5d	a2 b7 e9 b8 1c b9 45 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bb65	44 b9 3d b9
>bb69	ad b8 b7 b9 a8 b9 b3 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bb71					ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bb71					forth_words_start:
>bb71	20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bb79	61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bb89	74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bb99	20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bba9	20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bbb9	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bbc9	2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bbd9	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bbe9	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bbf9	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc09	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc19	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc29	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc39	65 78 69 74 29 20 63 72 20
.bc42					forth_words_end:
.bc42					user_words_start:
>bc42	20 20				.binary "user_words.asc"
.bc44					user_words_end:

;******  Processing file: platform/../headers.asm

.bc44					dictionary_start:
.bc44					nt_drop:
>bc44	04 10				        .byte 4, UF
>bc46	50 bc 2e 8d 33 8d		        .word nt_dup, xt_drop, z_drop
>bc4c	64 72 6f 70			        .text "drop"
.bc50					nt_dup:
>bc50	03 10				        .byte 3, UF
>bc52	5b bc af 8d bc 8d		        .word nt_swap, xt_dup, z_dup
>bc58	64 75 70			        .text "dup"
.bc5b					nt_swap:
>bc5b	04 10				        .byte 4, UF
>bc5d	67 bc ae a1 c1 a1		        .word nt_store, xt_swap, z_swap
>bc63	73 77 61 70			        .text "swap"
.bc67					nt_store:
>bc67	01 10				        .byte 1, UF
>bc69	70 bc 8d a1 a2 a1		        .word nt_fetch, xt_store, z_store
>bc6f	21				        .text "!"
.bc70					nt_fetch:
>bc70	01 10				        .byte 1, UF
>bc72	79 bc 80 8f 92 8f		        .word nt_over, xt_fetch, z_fetch
>bc78	40				        .text "@"
.bc79					nt_over:
>bc79	04 10				        .byte 4, UF
>bc7b	85 bc 93 98 a0 98		        .word nt_to_r, xt_over, z_over
>bc81	6f 76 65 72			        .text "over"
.bc85					nt_to_r:
>bc85	02 11				        .byte 2, CO+UF ; native is special case
>bc87	8f bc 70 a3 83 a3		        .word nt_r_from, xt_to_r, z_to_r
>bc8d	3e 72				        .text ">r"
.bc8f					nt_r_from:
>bc8f	02 01				        .byte 2, CO    ; native is special case
>bc91	99 bc 92 9a a2 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bc97	72 3e				        .text "r>"
.bc99					nt_r_fetch:
>bc99	02 01				        .byte 2, CO    ; native is special case
>bc9b	a3 bc 7d 9a 91 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bca1	72 40				        .text "r@"
.bca3					nt_nip:
>bca3	03 10				        .byte 3, UF
>bca5	ae bc 42 96 4f 96		        .word nt_rot, xt_nip, z_nip
>bcab	6e 69 70			        .text "nip"
.bcae					nt_rot:
>bcae	03 10				        .byte 3, UF
>bcb0	b9 bc 57 9b 72 9b		        .word nt_not_rote, xt_rot, z_rot
>bcb6	72 6f 74			        .text "rot"
.bcb9					nt_not_rote:
>bcb9	04 10				        .byte 4, UF
>bcbb	c5 bc 6e 96 89 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bcc1	2d 72 6f 74			        .text "-rot"
.bcc5					nt_tuck:
>bcc5	04 10				        .byte 4, UF
>bcc7	d1 bc 8d a3 a6 a3		        .word nt_comma, xt_tuck, z_tuck
>bccd	74 75 63 6b			        .text "tuck"
.bcd1					nt_comma:
>bcd1	01 10				        .byte 1, UF
>bcd3	da bc 6e 87 87 87		        .word nt_c_fetch, xt_comma, z_comma
>bcd9	2c				        .text ","
.bcda					nt_c_fetch:
>bcda	02 10				        .byte 2, UF
>bcdc	e4 bc 0b 86 14 86		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bce2	63 40				        .text "c@"
.bce4					nt_c_store:
>bce4	02 10				        .byte 2, UF
>bce6	ee bc 15 86 20 86		        .word nt_plus_store, xt_c_store, z_c_store
>bcec	63 21				        .text "c!"
.bcee					nt_plus_store:
>bcee	02 10				        .byte 2, UF
>bcf0	f8 bc f6 99 15 9a		        .word nt_execute, xt_plus_store, z_plus_store
>bcf6	2b 21				        .text "+!"
.bcf8					nt_execute:
>bcf8	07 10				        .byte 7, UF
>bcfa	07 bd 3d 8f 43 8f		        .word nt_emit, xt_execute, z_execute
>bd00	65 78 65 63 75 74 65		        .text "execute"
.bd07					nt_emit:
>bd07	04 18				        .byte 4, NN+UF
>bd09	13 bd ef 8d f9 8d		        .word nt_type, xt_emit, z_emit
>bd0f	65 6d 69 74			        .text "emit"
.bd13					nt_type:
>bd13	04 10				        .byte 4, UF
>bd15	1f bd 03 a5 2d a5		        .word nt_dot, xt_type, z_type
>bd1b	74 79 70 65			        .text "type"
.bd1f					nt_dot:
>bd1f	01 10				        .byte 1, UF
>bd21	28 bd 36 8c 57 8c		        .word nt_u_dot, xt_dot, z_dot
>bd27	2e				        .text "."
.bd28					nt_u_dot:
>bd28	02 10				        .byte 2, UF
>bd2a	32 bd 2e a5 39 a5		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd30	75 2e				        .text "u."
.bd32					nt_u_dot_r:
>bd32	03 10				        .byte 3, UF
>bd34	3d bd 3a a5 5b a5		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd3a	75 2e 72			        .text "u.r"
.bd3d					nt_dot_r:
>bd3d	02 10				        .byte 2, UF
>bd3f	47 bd 72 8c 9f 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd45	2e 72				        .text ".r"
.bd47					nt_d_dot:
>bd47	02 10				        .byte 2, UF
>bd49	51 bd e4 8c 02 8d		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd4f	64 2e				        .text "d."
.bd51					nt_d_dot_r:
>bd51	03 10				        .byte 3, UF
>bd53	5c bd 03 8d 2d 8d		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd59	64 2e 72			        .text "d.r"
.bd5c					nt_ud_dot:
>bd5c	03 10				        .byte 3, UF
>bd5e	67 bd 88 a5 9a a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bd64	75 64 2e			        .text "ud."
.bd67					nt_ud_dot_r:
>bd67	04 10				        .byte 4, UF
>bd69	73 bd 9b a5 b9 a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bd6f	75 64 2e 72			        .text "ud.r"
.bd73					nt_question:
>bd73	01 00				        .byte 1, 0
>bd75	7c bd 62 9a 68 9a		        .word nt_false, xt_question, z_question
>bd7b	3f				        .text "?"
.bd7c					nt_false:
>bd7c	05 00				        .byte 5, 0
>bd7e	89 bd 79 8f 7f 8f		        .word nt_true, xt_false, z_false
>bd84	66 61 6c 73 65			        .text "false"
.bd89					nt_true:
>bd89	04 00				        .byte 4, 0
>bd8b	95 bd 84 a3 8c a3		        .word nt_space, xt_true, z_true
>bd91	74 72 75 65			        .text "true"
.bd95					nt_space:
>bd95	05 00				        .byte 5, 0
>bd97	a2 bd 1e a1 23 a1		        .word nt_zero, xt_space, z_space
>bd9d	73 70 61 63 65			        .text "space"
.bda2					nt_zero:
>bda2	01 00				        .byte 1, 0
>bda4	ab bd a8 a7 ae a7		        .word nt_one, xt_zero, z_zero
>bdaa	30				        .text "0"
.bdab					nt_one:
>bdab	01 00				        .byte 1, 0
>bdad	b4 bd 08 98 10 98		        .word nt_two, xt_one, z_one
>bdb3	31				        .text "1"
.bdb4					nt_two:
>bdb4	01 00				        .byte 1, 0
>bdb6	bd bd a7 a3 af a3		        .word nt_two_dup, xt_two, z_two
>bdbc	32				        .text "2"
.bdbd					nt_two_dup:
>bdbd	04 10				        .byte 4, UF
>bdbf	c9 bd b8 a3 cf a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>bdc5	32 64 75 70			        .text "2dup"
.bdc9					nt_question_dup:
>bdc9	04 10				        .byte 4, UF
>bdcb	d5 bd 69 9a 7c 9a		        .word nt_plus, xt_question_dup, z_question_dup
>bdd1	3f 64 75 70			        .text "?dup"
.bdd5					nt_plus:
>bdd5	01 10				        .byte 1, UF
>bdd7	de bd e3 99 f5 99		        .word nt_minus, xt_plus, z_plus
>bddd	2b				        .text "+"
.bdde					nt_minus:
>bdde	01 10				        .byte 1, UF
>bde0	e7 bd 50 95 62 95		        .word nt_one_minus, xt_minus, z_minus
>bde6	2d				        .text "-"
.bde7					nt_one_minus:
>bde7	02 10				        .byte 2, UF
>bde9	f1 bd 11 98 1c 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>bdef	31 2d				        .text "1-"
.bdf1					nt_one_plus:
>bdf1	02 10				        .byte 2, UF
>bdf3	fb bd 1d 98 26 98		        .word nt_two_star, xt_one_plus, z_one_plus
>bdf9	31 2b				        .text "1+"
.bdfb					nt_two_star:
>bdfb	02 10				        .byte 2, UF
>bdfd	05 be 50 a4 57 a4		        .word nt_two_slash, xt_two_star, z_two_star
>be03	32 2a				        .text "2*"
.be05					nt_two_slash:
>be05	02 10				        .byte 2, UF
>be07	0f be 45 a4 4f a4		        .word nt_abs, xt_two_slash, z_two_slash
>be0d	32 2f				        .text "2/"
.be0f					nt_abs:
>be0f	03 10				        .byte 3, UF
>be11	1a be 39 81 4d 81		        .word nt_dabs, xt_abs, z_abs
>be17	61 62 73			        .text "abs"
.be1a					nt_dabs:
>be1a	04 10				        .byte 4, UF
>be1c	26 be 86 8a a4 8a		        .word nt_and, xt_dabs, z_dabs
>be22	64 61 62 73			        .text "dabs"
.be26					nt_and:
>be26	03 10				        .byte 3, UF
>be28	31 be 3e 83 4f 83		        .word nt_or, xt_and, z_and
>be2e	61 6e 64			        .text "and"
.be31					nt_or:
>be31	02 10				        .byte 2, UF
>be33	3b be 33 98 44 98		        .word nt_xor, xt_or, z_or
>be39	6f 72				        .text "or"
.be3b					nt_xor:
>be3b	03 10				        .byte 3, UF
>be3d	46 be 96 a7 a7 a7		        .word nt_rshift, xt_xor, z_xor
>be43	78 6f 72			        .text "xor"
.be46					nt_rshift:
>be46	06 10				        .byte 6, UF
>be48	54 be 73 9b 86 9b		        .word nt_lshift, xt_rshift, z_rshift
>be4e	72 73 68 69 66 74		        .text "rshift"
.be54					nt_lshift:
>be54	06 10				        .byte 6, UF
>be56	62 be 7a 94 8d 94		        .word nt_pick, xt_lshift, z_lshift
>be5c	6c 73 68 69 66 74		        .text "lshift"
.be62					nt_pick:
>be62	04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>be64	6e be d2 99 e2 99		        .word nt_char, xt_pick, z_pick
>be6a	70 69 63 6b			        .text "pick"
.be6e					nt_char:
>be6e	04 00				        .byte 4, 0
>be70	7a be 31 86 47 86		        .word nt_bracket_char, xt_char, z_char
>be76	63 68 61 72			        .text "char"
.be7a					nt_bracket_char:
>be7a	06 05				        .byte 6, CO+IM
>be7c	88 be 97 85 9d 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>be82	5b 63 68 61 72 5d		        .text "[char]"
.be88					nt_char_plus:
>be88	05 00				        .byte 5, 0
>be8a	95 be 1d 98 26 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>be90	63 68 61 72 2b			        .text "char+"
.be95					nt_chars:
>be95	05 12				        .byte 5, AN+UF   ; deleted during compile
>be97	a2 be 48 86 4b 86		        .word nt_cells, xt_chars, z_chars
>be9d	63 68 61 72 73			        .text "chars"
.bea2					nt_cells:
>bea2	05 00				        .byte 5, 0
>bea4	af be 50 a4 57 a4		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>beaa	63 65 6c 6c 73			        .text "cells"
.beaf					nt_cell_plus:
>beaf	05 10				        .byte 5, UF
>beb1	bc be 21 86 30 86		        .word nt_here, xt_cell_plus, z_cell_plus
>beb7	63 65 6c 6c 2b			        .text "cell+"
.bebc					nt_here:
>bebc	04 00				        .byte 4, 0
>bebe	c8 be 72 91 7c 91		        .word nt_equal, xt_here, z_here
>bec4	68 65 72 65			        .text "here"
.bec8					nt_equal:
>bec8	01 10				        .byte 1, UF
>beca	d1 be ce 8e e9 8e		        .word nt_not_equals, xt_equal, z_equal
>bed0	3d				        .text "="
.bed1					nt_not_equals:
>bed1	02 10				        .byte 2, UF
>bed3	db be 50 96 6d 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bed9	3c 3e				        .text "<>"
.bedb					nt_less_than:
>bedb	01 10				        .byte 1, UF
>bedd	e4 be 68 93 7c 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bee3	3c				        .text "<"
.bee4					nt_u_less_than:
>bee4	02 10				        .byte 2, UF
>bee6	ee be 72 a5 87 a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>beec	75 3c				        .text "u<"
.beee					nt_u_greater_than:
>beee	02 10				        .byte 2, UF
>bef0	f8 be 5c a5 71 a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bef6	75 3e				        .text "u>"
.bef8					nt_greater_than:
>bef8	01 10				        .byte 1, UF
>befa	01 bf 5d 91 71 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bf00	3e				        .text ">"
.bf01					nt_zero_equal:
>bf01	02 10				        .byte 2, UF
>bf03	0b bf af a7 c2 a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bf09	30 3d				        .text "0="
.bf0b					nt_zero_unequal:
>bf0b	03 10				        .byte 3, UF
>bf0d	16 bf e7 a7 f8 a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bf13	30 3c 3e			        .text "0<>"
.bf16					nt_zero_greater:
>bf16	02 10				        .byte 2, UF
>bf18	20 bf c3 a7 d6 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf1e	30 3e				        .text "0>"
.bf20					nt_zero_less:
>bf20	02 10				        .byte 2, UF
>bf22	2a bf d7 a7 e6 a7		        .word nt_min, xt_zero_less, z_zero_less
>bf28	30 3c				        .text "0<"
.bf2a					nt_min:
>bf2a	03 10				        .byte 3, UF
>bf2c	35 bf 34 95 4f 95		        .word nt_max, xt_min, z_min
>bf32	6d 69 6e			        .text "min"
.bf35					nt_max:
>bf35	03 10				        .byte 3, UF
>bf37	40 bf 18 95 33 95		        .word nt_two_drop, xt_max, z_max
>bf3d	6d 61 78			        .text "max"
.bf40					nt_two_drop:
>bf40	05 10				        .byte 5, UF
>bf42	4d bf b0 a3 b7 a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf48	32 64 72 6f 70			        .text "2drop"
.bf4d					nt_two_swap:
>bf4d	05 10				        .byte 5, UF
>bf4f	5a bf 7e a4 a1 a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf55	32 73 77 61 70			        .text "2swap"
.bf5a					nt_two_over:
>bf5a	05 10				        .byte 5, UF
>bf5c	67 bf f2 a3 09 a4		        .word nt_two_store, xt_two_over, z_two_over
>bf62	32 6f 76 65 72			        .text "2over"
.bf67					nt_two_store:
>bf67	02 10				        .byte 2, UF
>bf69	71 bf 58 a4 7d a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bf6f	32 21				        .text "2!"
.bf71					nt_two_fetch:
>bf71	02 10				        .byte 2, UF
>bf73	7b bf d0 a3 f1 a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bf79	32 40				        .text "2@"
.bf7b					nt_two_variable:
>bf7b	09 00				        .byte 9, 0
>bf7d	8c bf f4 a4 02 a5		        .word nt_two_constant, xt_two_variable, z_two_variable
>bf83	32 76 61 72 69 61 62 6c		        .text "2variable"
>bf8b	65
.bf8c					nt_two_constant:
>bf8c	09 10				        .byte 9, UF
>bf8e	9d bf c2 a4 e6 a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bf94	32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bf9c	74
.bf9d					nt_two_literal:
>bf9d	08 14				        .byte 8, UF+IM
>bf9f	ad bf e7 a4 f3 a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bfa5	32 6c 69 74 65 72 61 6c		        .text "2literal"
.bfad					nt_two_r_fetch:
>bfad	03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bfaf	b8 bf 0a a4 27 a4		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bfb5	32 72 40			        .text "2r@"
.bfb8					nt_two_r_from:
>bfb8	03 01				        .byte 3, CO             ; native is special case
>bfba	c3 bf 28 a4 44 a4		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bfc0	32 72 3e			        .text "2r>"
.bfc3					nt_two_to_r:
>bfc3	03 11				        .byte 3, CO+UF          ; native is special case
>bfc5	ce bf a2 a4 c1 a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>bfcb	32 3e 72			        .text "2>r"
.bfce					nt_invert:
>bfce	06 10				        .byte 6, UF
>bfd0	dc bf eb 92 fa 92		        .word nt_negate, xt_invert, z_invert
>bfd6	69 6e 76 65 72 74		        .text "invert"
.bfdc					nt_negate:
>bfdc	06 10				        .byte 6, UF
>bfde	ea bf 23 96 33 96		        .word nt_dnegate, xt_negate, z_negate
>bfe4	6e 65 67 61 74 65		        .text "negate"
.bfea					nt_dnegate:
>bfea	07 10				        .byte 7, UF
>bfec	f9 bf 41 8b 5b 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>bff2	64 6e 65 67 61 74 65		        .text "dnegate"
.bff9					nt_c_comma:
>bff9	02 10				        .byte 2, UF
>bffb	03 c0 00 86 0a 86		        .word nt_bounds, xt_c_comma, z_c_comma
>c001	63 2c				        .text "c,"
.c003					nt_bounds:
>c003	06 10				        .byte 6, UF
>c005	11 c0 7e 85 96 85		        .word nt_spaces, xt_bounds, z_bounds
>c00b	62 6f 75 6e 64 73		        .text "bounds"
.c011					nt_spaces:
>c011	06 10				        .byte 6, UF
>c013	1f c0 24 a1 5f a1		        .word nt_bl, xt_spaces, z_spaces
>c019	73 70 61 63 65 73		        .text "spaces"
.c01f					nt_bl:
>c01f	02 00				        .byte 2, 0
>c021	29 c0 9a 83 a2 83		        .word nt_minus_trailing, xt_bl, z_bl
>c027	62 6c				        .text "bl"
.c029					nt_minus_trailing:
>c029	09 10				        .byte 9, UF
>c02b	3a c0 7c 95 b8 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c031	2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c039	67
.c03a					nt_minus_leading:
>c03a	08 10				        .byte 8, UF
>c03c	4a c0 63 95 7b 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c042	2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c04a					nt_slash_string:
>c04a	07 10				        .byte 7, UF
>c04c	59 c0 19 a0 38 a0		        .word nt_refill, xt_slash_string, z_slash_string
>c052	2f 73 74 72 69 6e 67		        .text "/string"
.c059					nt_refill:
>c059	06 00				        .byte 6, 0
>c05b	67 c0 f8 9a 39 9b		        .word nt_accept, xt_refill, z_refill
>c061	72 65 66 69 6c 6c		        .text "refill"
.c067					nt_accept:
>c067	06 18				        .byte 6, UF+NN
>c069	75 c0 4e 81 46 82		        .word nt_input_to_r, xt_accept, z_accept
>c06f	61 63 63 65 70 74		        .text "accept"
.c075					nt_input_to_r:
>c075	07 08				        .byte 7, NN
>c077	84 c0 62 92 77 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c07d	69 6e 70 75 74 3e 72		        .text "input>r"
.c084					nt_r_to_input:
>c084	07 08				        .byte 7, NN
>c086	93 c0 a3 9a ba 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c08c	72 3e 69 6e 70 75 74		        .text "r>input"
.c093					nt_unused:
>c093	06 00				        .byte 6, 0
>c095	a1 c0 54 a6 63 a6		        .word nt_depth, xt_unused, z_unused
>c09b	75 6e 75 73 65 64		        .text "unused"
.c0a1					nt_depth:
>c0a1	05 00				        .byte 5, 0
>c0a3	ae c0 f6 8a 04 8b		        .word nt_key, xt_depth, z_depth
>c0a9	64 65 70 74 68			        .text "depth"
.c0ae					nt_key:
>c0ae	03 00				        .byte 3, 0
>c0b0	b9 c0 2e 93 37 93		        .word nt_allot, xt_key, z_key
>c0b6	6b 65 79			        .text "key"
.c0b9					nt_allot:
>c0b9	05 10				        .byte 5, UF
>c0bb	c6 c0 ab 82 13 83		        .word nt_create, xt_allot, z_allot
>c0c1	61 6c 6c 6f 74			        .text "allot"
.c0c6					nt_create:
>c0c6	06 00				        .byte 6, 0
>c0c8	d4 c0 69 89 3d 8a		        .word nt_does, xt_create, z_create
>c0ce	63 72 65 61 74 65		        .text "create"
.c0d4					nt_does:
>c0d4	05 05				        .byte 5, CO+IM
>c0d6	e1 c0 f5 8b 03 8c		        .word nt_variable, xt_does, z_does
>c0dc	64 6f 65 73 3e			        .text "does>"
.c0e1					nt_variable:
>c0e1	08 00				        .byte 8, 0
>c0e3	f1 c0 78 a6 90 a6		        .word nt_constant, xt_variable, z_variable
>c0e9	76 61 72 69 61 62 6c 65		        .text "variable"
.c0f1					nt_constant:
>c0f1	08 10				        .byte 8, UF
>c0f3	01 c1 11 89 4e 89		        .word nt_value, xt_constant, z_constant
>c0f9	63 6f 6e 73 74 61 6e 74		        .text "constant"
.c101					nt_value:
>c101	05 10				        .byte 5, UF
>c103	0e c1 11 89 4e 89		        .word nt_to, xt_constant, z_constant
>c109	76 61 6c 75 65			        .text "value"
.c10e					nt_to:
>c10e	02 0c				        .byte 2, NN+IM
>c110	18 c1 31 a2 8c a2		        .word nt_s_to_d, xt_to, z_to
>c116	74 6f				        .text "to"
.c118					nt_s_to_d:
>c118	03 10				        .byte 3, UF
>c11a	23 c1 ac 9e bd 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c120	73 3e 64			        .text "s>d"
.c123					nt_d_to_s:
>c123	03 10				        .byte 3, UF
>c125	2e c1 80 8a 85 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c12b	64 3e 73			        .text "d>s"
.c12e					nt_d_minus:
>c12e	02 10				        .byte 2, UF
>c130	38 c1 3e 8a 5e 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c136	64 2d				        .text "d-"
.c138					nt_d_plus:
>c138	02 10				        .byte 2, UF
>c13a	42 c1 5f 8a 7f 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c140	64 2b				        .text "d+"
.c142					nt_erase:
>c142	05 00				        .byte 5, 0      ; underflow checked by FILL
>c144	4f c1 f4 8e 3c 8f		        .word nt_blank, xt_erase, z_erase
>c14a	65 72 61 73 65			        .text "erase"
.c14f					nt_blank:
>c14f	05 00				        .byte 5, 0     ; underflow checked by FILL
>c151	5c c1 ea 8e 3c 8f		        .word nt_fill, xt_blank, z_blank
>c157	62 6c 61 6e 6b			        .text "blank"
.c15c					nt_fill:
>c15c	04 10				        .byte 4, UF
>c15e	68 c1 fa 8e 3c 8f		        .word nt_find_name, xt_fill, z_fill
>c164	66 69 6c 6c			        .text "fill"
.c168					nt_find_name:
>c168	09 10				        .byte 9, UF
>c16a	79 c1 db 8f 86 90		        .word nt_tick, xt_find_name, z_find_name
>c170	66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c178	65
.c179					nt_tick:
>c179	01 00				        .byte 1, 0
>c17b	82 c1 11 a2 30 a2		        .word nt_bracket_tick, xt_tick, z_tick
>c181	27				        .text "'"
.c182					nt_bracket_tick:
>c182	03 05				        .byte 3, CO+IM
>c184	8d c1 9e 85 a4 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c18a	5b 27 5d			        .text "[']"
.c18d					nt_name_to_int:
>c18d	08 10				        .byte 8, UF
>c18f	9d c1 e1 95 fd 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c195	6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c19d					nt_int_to_name:
>c19d	08 10				        .byte 8, UF
>c19f	ad c1 78 92 ea 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c1a5	69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c1ad					nt_name_to_string:
>c1ad	0b 10				        .byte 11, UF
>c1af	c0 c1 fe 95 17 96		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c1b5	6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1bd	69 6e 67
.c1c0					nt_to_body:
>c1c0	05 10				        .byte 5, UF
>c1c2	cd c1 8d a2 b1 a2		        .word nt_defer, xt_to_body, z_to_body
>c1c8	3e 62 6f 64 79			        .text ">body"
.c1cd					nt_defer:
>c1cd	05 00				        .byte 5, 0
>c1cf	da c1 ac 8a de 8a		        .word nt_latestxt, xt_defer, z_defer
>c1d5	64 65 66 65 72			        .text "defer"
.c1da					nt_latestxt:
>c1da	08 00				        .byte 8, 0
>c1dc	ea c1 49 93 4f 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c1e2	6c 61 74 65 73 74 78 74		        .text "latestxt"
.c1ea					nt_latestnt:
>c1ea	08 00				        .byte 8, 0
>c1ec	fa c1 3b 93 48 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c1f2	6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c1fa					nt_parse_name:
>c1fa	0a 08				        .byte 10, NN
>c1fc	0c c2 df 98 d1 99		        .word nt_parse, xt_parse_name, z_parse_name
>c202	70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c20a	6d 65
.c20c					nt_parse:
>c20c	05 10				        .byte 5, UF
>c20e	19 c2 3a 99 d1 99		        .word nt_execute_parsing, xt_parse, z_parse
>c214	70 61 72 73 65			        .text "parse"
.c219					nt_execute_parsing:
>c219	0f 10				        .byte 15, UF
>c21b	30 c2 51 8f 77 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c221	65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c229	70 61 72 73 69 6e 67
.c230					nt_source:
>c230	06 00				        .byte 6, 0
>c232	3e c2 fe a0 12 a1		        .word nt_source_id, xt_source, z_source
>c238	73 6f 75 72 63 65		        .text "source"
.c23e					nt_source_id:
>c23e	09 00				        .byte 9, 0
>c240	4f c2 13 a1 1d a1		        .word nt_colon, xt_source_id, z_source_id
>c246	73 6f 75 72 63 65 2d 69		        .text "source-id"
>c24e	64
.c24f					nt_colon:
>c24f	01 00				        .byte 1, 0
>c251	58 c2 0f 87 51 87		        .word nt_semicolon, xt_colon, z_colon
>c257	3a				        .text ":"
.c258					nt_semicolon:
>c258	01 05				        .byte 1, CO+IM
>c25a	61 c2 88 9f e6 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c260	3b				        .text ";"
.c261					nt_colon_noname:
>c261	07 00				        .byte 7, 0
>c263	70 c2 52 87 6d 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c269	3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c270					nt_compile_comma:
>c270	08 18				        .byte 8, UF+NN
>c272	80 c2 ed 87 04 89		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c278	63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c280					nt_left_bracket:
>c280	01 05				        .byte 1, IM+CO
>c282	89 c2 55 93 59 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c288	5b				        .text "["
.c289					nt_right_bracket:
>c289	01 04				        .byte 1, IM
>c28b	92 c2 47 9b 4d 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c291	5d				        .text "]"
.c292					nt_literal:
>c292	07 15				        .byte 7, IM+CO+UF
>c294	a1 c2 8a 93 97 93		        .word nt_sliteral, xt_literal, z_literal
>c29a	6c 69 74 65 72 61 6c		        .text "literal"
.c2a1					nt_sliteral:
>c2a1	08 15				        .byte 8, CO+IM+UF
>c2a3	b1 c2 39 a0 a8 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c2a9	73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c2b1					nt_dot_quote:
>c2b1	02 05				        .byte 2, CO+IM
>c2b3	bb c2 67 8c 71 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2b9	2e 22				        .text ".", $22
.c2bb					nt_s_quote:
>c2bb	02 0c				        .byte 2, IM+NN
>c2bd	c5 c2 4f 9d ab 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c2c3	73 22				        .text "s", $22
.c2c5					nt_s_backslash_quote:
>c2c5	03 04				        .byte 3, IM
>c2c7	d0 c2 87 9b 90 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c2cd	73 5c 22			        .text "s", $5C, $22
.c2d0					nt_postpone:
>c2d0	08 05				        .byte 8, IM+CO
>c2d2	e0 c2 16 9a 54 9a		        .word nt_immediate, xt_postpone, z_postpone
>c2d8	70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c2e0					nt_immediate:
>c2e0	09 00				        .byte 9, 0
>c2e2	f1 c2 4b 92 56 92		        .word nt_compile_only, xt_immediate, z_immediate
>c2e8	69 6d 6d 65 64 69 61 74		        .text "immediate"
>c2f0	65
.c2f1					nt_compile_only:
>c2f1	0c 00				        .byte 12, 0
>c2f3	05 c3 05 89 10 89		        .word nt_never_native, xt_compile_only, z_compile_only
>c2f9	63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c301	6f 6e 6c 79
.c305					nt_never_native:
>c305	0c 00				        .byte 12, 0
>c307	19 c3 34 96 41 96		        .word nt_always_native, xt_never_native, z_never_native
>c30d	6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c315	74 69 76 65
.c319					nt_always_native:
>c319	0d 00				        .byte 13, 0
>c31b	2e c3 30 83 3d 83		        .word nt_allow_native, xt_always_native, z_always_native
>c321	61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c329	61 74 69 76 65
.c32e					nt_allow_native:
>c32e	0c 00				        .byte 12, 0
>c330	42 c3 14 83 1f 83		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c336	61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c33e	74 69 76 65
.c342					nt_nc_limit:
>c342	08 00				        .byte 8, 0
>c344	52 c3 18 96 22 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c34a	6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c352					nt_strip_underflow:
>c352	0f 00				        .byte 15, 0
>c354	69 c3 a3 a1 ad a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c35a	73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c362	64 65 72 66 6c 6f 77
.c369					nt_abort:
>c369	05 00				        .byte 5, 0
>c36b	76 c3 81 80 c5 80		        .word nt_abort_quote, xt_abort, z_abort
>c371	61 62 6f 72 74			        .text "abort"
.c376					nt_abort_quote:
>c376	06 0d				        .byte 6, CO+IM+NN
>c378	84 c3 19 81 23 81		        .word nt_do, xt_abort_quote, z_abort_quote
>c37e	61 62 6f 72 74 22		        .text "abort", $22
.c384					nt_do:
>c384	02 0d				        .byte 2, CO+IM+NN
>c386	8e c3 62 8b bc 8b		        .word nt_question_do, xt_do, z_do
>c38c	64 6f				        .text "do"
.c38e					nt_question_do:
>c38e	03 0d				        .byte 3, CO+IM+NN
>c390	99 c3 5c 8b bc 8b		        .word nt_i, xt_question_do, z_question_do
>c396	3f 64 6f			        .text "?do"
.c399					nt_i:
>c399	01 03				        .byte 1, AN+CO
>c39b	a2 c3 e9 91 02 92		        .word nt_j, xt_i, z_i
>c3a1	69				        .text "i"
.c3a2					nt_j:
>c3a2	01 03				        .byte 1, AN+CO
>c3a4	ab c3 14 93 2d 93		        .word nt_loop, xt_j, z_j
>c3aa	6a				        .text "j"
.c3ab					nt_loop:
>c3ab	04 05				        .byte 4, CO+IM
>c3ad	b7 c3 fb 93 68 94		        .word nt_plus_loop, xt_loop, z_loop
>c3b3	6c 6f 6f 70			        .text "loop"
.c3b7					nt_plus_loop:
>c3b7	05 05				        .byte 5, CO+IM
>c3b9	c4 c3 02 94 68 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3bf	2b 6c 6f 6f 70			        .text "+loop"
.c3c4					nt_exit:
>c3c4	04 03				        .byte 4, AN+CO
>c3c6	d0 c3 78 8f 79 8f		        .word nt_unloop, xt_exit, z_exit
>c3cc	65 78 69 74			        .text "exit"
.c3d0					nt_unloop:
>c3d0	06 03				        .byte 6, AN+CO
>c3d2	de c3 42 a6 48 a6		        .word nt_leave, xt_unloop, z_unloop
>c3d8	75 6e 6c 6f 6f 70		        .text "unloop"
.c3de					nt_leave:
>c3de	05 03				        .byte 5, AN+CO
>c3e0	eb c3 50 93 55 93		        .word nt_recurse, xt_leave, z_leave
>c3e6	6c 65 61 76 65			        .text "leave"
.c3eb					nt_recurse:
>c3eb	07 0d				        .byte 7, CO+IM+NN
>c3ed	fa c3 bb 9a f7 9a		        .word nt_quit, xt_recurse, z_recurse
>c3f3	72 65 63 75 72 73 65		        .text "recurse"
.c3fa					nt_quit:
>c3fa	04 00				        .byte 4, 0
>c3fc	06 c4 83 80 c5 80		        .word nt_begin, xt_quit, z_quit
>c402	71 75 69 74			        .text "quit"
.c406					nt_begin:
>c406	05 07				        .byte 5, AN+CO+IM
>c408	13 c4 90 83 93 83		        .word nt_again, xt_begin, z_begin
>c40e	62 65 67 69 6e			        .text "begin"
.c413					nt_again:
>c413	05 17				        .byte 5, AN+CO+IM+UF
>c415	20 c4 89 82 a9 82		        .word nt_state, xt_again, z_again
>c41b	61 67 61 69 6e			        .text "again"
.c420					nt_state:
>c420	05 00				        .byte 5, 0
>c422	2d c4 82 a1 8c a1		        .word nt_evaluate, xt_state, z_state
>c428	73 74 61 74 65			        .text "state"
.c42d					nt_evaluate:
>c42d	08 10				        .byte 8, UF
>c42f	3d c4 d5 90 28 91		        .word nt_base, xt_evaluate, z_evaluate
>c435	65 76 61 6c 75 61 74 65		        .text "evaluate"
.c43d					nt_base:
>c43d	04 00				        .byte 4, 0
>c43f	49 c4 87 83 8f 83		        .word nt_digit_question, xt_base, z_base
>c445	62 61 73 65			        .text "base"
.c449					nt_digit_question:
>c449	06 10				        .byte 6, UF
>c44b	57 c4 05 8b 39 8b		        .word nt_number, xt_digit_question, z_digit_question
>c451	64 69 67 69 74 3f		        .text "digit?"
.c457					nt_number:
>c457	06 10				        .byte 6, UF
>c459	65 c4 8a 96 86 97		        .word nt_to_number, xt_number, z_number
>c45f	6e 75 6d 62 65 72		        .text "number"
.c465					nt_to_number:
>c465	07 10				        .byte 7, UF
>c467	74 c4 bd a2 5c a3		        .word nt_hex, xt_to_number, z_to_number
>c46d	3e 6e 75 6d 62 65 72		        .text ">number"
.c474					nt_hex:
>c474	03 00				        .byte 3, 0
>c476	7f c4 7d 91 83 91		        .word nt_decimal, xt_hex, z_hex
>c47c	68 65 78			        .text "hex"
.c47f					nt_decimal:
>c47f	07 00				        .byte 7, 0
>c481	8e c4 a5 8a ab 8a		        .word nt_count, xt_decimal, z_decimal
>c487	64 65 63 69 6d 61 6c		        .text "decimal"
.c48e					nt_count:
>c48e	05 10				        .byte 5, UF
>c490	9b c4 4f 89 62 89		        .word nt_m_star, xt_count, z_count
>c496	63 6f 75 6e 74			        .text "count"
.c49b					nt_m_star:
>c49b	02 10				        .byte 2, UF
>c49d	a5 c4 8e 94 a8 94		        .word nt_um_star, xt_m_star, z_m_star
>c4a3	6d 2a				        .text "m*"
.c4a5					nt_um_star:
>c4a5	03 10				        .byte 3, UF
>c4a7	b0 c4 fc a5 41 a6		        .word nt_star, xt_um_star, z_um_star
>c4ad	75 6d 2a			        .text "um*"
.c4b0					nt_star:
>c4b0	01 10				        .byte 1, UF
>c4b2	b9 c4 60 a1 68 a1		        .word nt_um_slash_mod, xt_star, z_star
>c4b8	2a				        .text "*"
.c4b9					nt_um_slash_mod:
>c4b9	06 10				        .byte 6, UF
>c4bb	c7 c4 ba a5 fb a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c4c1	75 6d 2f 6d 6f 64		        .text "um/mod"
.c4c7					nt_sm_slash_rem:
>c4c7	06 10				        .byte 6, UF
>c4c9	d5 c4 d5 a0 fd a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c4cf	73 6d 2f 72 65 6d		        .text "sm/rem"
.c4d5					nt_fm_slash_mod:
>c4d5	06 10				        .byte 6, UF
>c4d7	e3 c4 91 90 c7 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c4dd	66 6d 2f 6d 6f 64		        .text "fm/mod"
.c4e3					nt_slash:
>c4e3	01 10				        .byte 1, UF
>c4e5	ec c4 fc 9f 18 a0		        .word nt_slash_mod, xt_slash, z_slash
>c4eb	2f				        .text "/"
.c4ec					nt_slash_mod:
>c4ec	04 10				        .byte 4, UF
>c4ee	f8 c4 01 a0 18 a0		        .word nt_mod, xt_slash_mod, z_slash_mod
>c4f4	2f 6d 6f 64			        .text "/mod"
.c4f8					nt_mod:
>c4f8	03 10				        .byte 3, UF
>c4fa	03 c5 b9 95 c1 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c500	6d 6f 64			        .text "mod"
.c503					nt_star_slash_mod:
>c503	05 10				        .byte 5, UF
>c505	10 c5 72 a1 81 a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c50b	2a 2f 6d 6f 64			        .text "*/mod"
.c510					nt_star_slash:
>c510	02 10				        .byte 2, UF
>c512	1a c5 69 a1 71 a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c518	2a 2f				        .text "*/"
.c51a					nt_backslash:
>c51a	01 04				        .byte 1, IM
>c51c	23 c5 7e 83 86 83		        .word nt_move, xt_backslash, z_backslash
>c522	5c				        .byte $5c
.c523					nt_move:
>c523	04 18				        .byte 4, NN+UF
>c525	2f c5 c2 95 e0 95		        .word nt_cmove_up, xt_move, z_move
>c52b	6d 6f 76 65			        .text "move"
.c52f					nt_cmove_up:
>c52f	06 10				        .byte 6, UF
>c531	3d c5 d4 86 0e 87		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c537	63 6d 6f 76 65 3e		        .text "cmove>"
.c53d					nt_cmove:
>c53d	05 10				        .byte 5, UF
>c53f	4a c5 99 86 d3 86		        .word nt_pad, xt_cmove, z_cmove
>c545	63 6d 6f 76 65			        .text "cmove"
.c54a					nt_pad:
>c54a	03 00				        .byte 3, 0
>c54c	55 c5 a1 98 b0 98		        .word nt_cleave, xt_pad, z_pad
>c552	70 61 64			        .text "pad"
.c555					nt_cleave:
>c555	06 10				        .byte 6, UF
>c557	63 c5 4c 86 98 86		        .word nt_hexstore, xt_cleave, z_cleave
>c55d	63 6c 65 61 76 65		        .text "cleave"
.c563					nt_hexstore:
>c563	08 10				        .byte 8, UF
>c565	73 c5 84 91 d6 91		        .word nt_within, xt_hexstore, z_hexstore
>c56b	68 65 78 73 74 6f 72 65		        .text "hexstore"
.c573					nt_within:
>c573	06 10				        .byte 6, UF
>c575	81 c5 a5 a6 ba a6		        .word nt_to_in, xt_within, z_within
>c57b	77 69 74 68 69 6e		        .text "within"
.c581					nt_to_in:
>c581	03 00				        .byte 3, 0
>c583	8c c5 b2 a2 bc a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c589	3e 69 6e			        .text ">in"
.c58c					nt_less_number_sign:
>c58c	02 00				        .byte 2, 0
>c58e	96 c5 5a 93 67 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c594	3c 23				        .text "<#"
.c596					nt_number_sign:
>c596	01 10				        .byte 1, UF
>c598	9f c5 87 97 bb 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c59e	23				        .text "#"
.c59f					nt_number_sign_s:
>c59f	02 10				        .byte 2, UF
>c5a1	a9 c5 de 97 ee 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c5a7	23 73				        .text "#s"
.c5a9					nt_number_sign_greater:
>c5a9	02 10				        .byte 2, UF
>c5ab	b3 c5 bc 97 dd 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c5b1	23 3e				        .text "#>"
.c5b3					nt_hold:
>c5b3	04 10				        .byte 4, UF
>c5b5	bf c5 d7 91 e8 91		        .word nt_sign, xt_hold, z_hold
>c5bb	68 6f 6c 64			        .text "hold"
.c5bf					nt_sign:
>c5bf	04 10				        .byte 4, UF
>c5c1	cb c5 e7 9f fb 9f		        .word nt_output, xt_sign, z_sign
>c5c7	73 69 67 6e			        .text "sign"
.c5cb					nt_output:
>c5cb	06 00				        .byte 6, 0
>c5cd	d9 c5 88 98 92 98		        .word nt_input, xt_output, z_output
>c5d3	6f 75 74 70 75 74		        .text "output"
.c5d9					nt_input:
>c5d9	05 00				        .byte 5, 0
>c5db	e6 c5 57 92 61 92		        .word nt_cr, xt_input, z_input
>c5e1	69 6e 70 75 74			        .text "input"
.c5e6					nt_cr:
>c5e6	02 00				        .byte 2, 0
>c5e8	f0 c5 63 89 68 89		        .word nt_page, xt_cr, z_cr
>c5ee	63 72				        .text "cr"
.c5f0					nt_page:
>c5f0	04 00				        .byte 4, 0
>c5f2	fc c5 b1 98 ce 98		        .word nt_at_xy, xt_page, z_page
>c5f8	70 61 67 65			        .text "page"
.c5fc					nt_at_xy:
>c5fc	05 10				        .byte 5, UF
>c5fe	09 c6 50 83 7d 83		        .word nt_marker, xt_at_xy, z_at_xy
>c604	61 74 2d 78 79			        .text "at-xy"
.c609					nt_marker:
>c609	06 04				        .byte 6, IM
>c60b	17 c6 a9 94 e6 94		        .word nt_words, xt_marker, z_marker
>c611	6d 61 72 6b 65 72		        .text "marker"
.c617					nt_words:
>c617	05 00				        .byte 5, 0
>c619	24 c6 18 a7 74 a7		        .word nt_wordsize, xt_words, z_words
>c61f	77 6f 72 64 73			        .text "words"
.c624					nt_wordsize:
>c624	08 10				        .byte 8, UF
>c626	34 c6 75 a7 95 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c62c	77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c634					nt_aligned:
>c634	07 00				        .byte 7, 0
>c636	43 c6 aa 82 aa 82		        .word nt_align, xt_align, z_align
>c63c	61 6c 69 67 6e 65 64		        .text "aligned"
.c643					nt_align:
>c643	05 00				        .byte 5, 0
>c645	50 c6 aa 82 aa 82		        .word nt_bell, xt_align, z_align
>c64b	61 6c 69 67 6e			        .text "align"
.c650					nt_bell:
>c650	04 00				        .byte 4, 0
>c652	5c c6 94 83 99 83		        .word nt_dump, xt_bell, z_bell
>c658	62 65 6c 6c			        .text "bell"
.c65c					nt_dump:
>c65c	04 10				        .byte 4, UF
>c65e	68 c6 34 8d 9a 8d		        .word nt_dot_s, xt_dump, z_dump
>c664	64 75 6d 70			        .text "dump"
.c668					nt_dot_s:
>c668	02 00				        .byte 2, 0
>c66a	72 c6 a0 8c e3 8c		        .word nt_disasm, xt_dot_s, z_dot_s
>c670	2e 73				        .text ".s"
.c672					nt_disasm:
>c672	06 10				        .byte 6, UF
>c674	80 c6 3a 8b 40 8b		        .word nt_compare, xt_disasm, z_disasm
>c67a	64 69 73 61 73 6d		        .text "disasm"
.c680					nt_compare:
>c680	07 10				        .byte 7, UF
>c682	8f c6 88 87 ec 87		        .word nt_search, xt_compare, z_compare
>c688	63 6f 6d 70 61 72 65		        .text "compare"
.c68f					nt_search:
>c68f	06 18				        .byte 6, UF+NN
>c691	9d c6 e9 9e 87 9f		        .word +, xt_search, z_search
>c697	73 65 61 72 63 68		        .text "search"
.c69d					+
.c69d					nt_environment_q:
>c69d	0c 10				        .byte 12, UF
>c69f	b1 c6 15 8e 91 8e		        .word +, xt_environment_q, z_environment_q
>c6a5	65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6ad	65 6e 74 3f
.c6b1					+
.c6b1					nt_find:
>c6b1	04 10				        .byte 4, UF
>c6b3	bd c6 93 8f da 8f		        .word nt_word, xt_find, z_find
>c6b9	66 69 6e 64			        .text "find"
.c6bd					nt_word:
>c6bd	04 10				        .byte 4, UF
>c6bf	c9 c6 bb a6 00 a7		        .word nt_paren, xt_word, z_word
>c6c5	77 6f 72 64			        .text "word"
.c6c9					nt_paren:
>c6c9	01 04				        .byte 1, IM
>c6cb	d2 c6 cf 98 de 98		        .word nt_dot_paren, xt_paren, z_paren
>c6d1	28				        .text "("
.c6d2					nt_dot_paren:
>c6d2	02 04				        .byte 2, IM
>c6d4	dc c6 58 8c 66 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c6da	2e 28				        .text ".("
.c6dc					nt_if:
>c6dc	02 0d				        .byte 2, IM+CO+NN
>c6de	e6 c6 03 92 13 92		        .word nt_then, xt_if, z_if
>c6e4	69 66				        .text "if"
.c6e6					nt_then:
>c6e6	04 0d				        .byte 4, IM+CO+NN
>c6e8	f2 c6 c2 a1 cb a1		        .word nt_else, xt_then, z_then
>c6ee	74 68 65 6e			        .text "then"
.c6f2					nt_else:
>c6f2	04 0d				        .byte 4, IM+CO+NN
>c6f4	fe c6 c1 8d da 8d		        .word nt_repeat, xt_else, z_else
>c6fa	65 6c 73 65			        .text "else"
.c6fe					nt_repeat:
>c6fe	06 0d				        .byte 6, IM+CO+NN
>c700	0c c7 3a 9b 46 9b		        .word nt_until, xt_repeat, z_repeat
>c706	72 65 70 65 61 74		        .text "repeat"
.c70c					nt_until:
>c70c	05 0d				        .byte 5, IM+CO+NN
>c70e	19 c7 49 a6 53 a6		        .word nt_while, xt_until, z_until
>c714	75 6e 74 69 6c			        .text "until"
.c719					nt_while:
>c719	05 0d				        .byte 5, IM+CO+NN
>c71b	26 c7 91 a6 a4 a6		        .word nt_case, xt_while, z_while
>c721	77 68 69 6c 65			        .text "while"
.c726					nt_case:
>c726	04 0d				        .byte 4, IM+CO+NN
>c728	32 c7 a8 a7 ae a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c72e	63 61 73 65			        .text "case"
.c732					nt_of:
>c732	02 0d				        .byte 2, IM+CO+NN
>c734	3c c7 ef 97 07 98		        .word nt_endof, xt_of, z_of
>c73a	6f 66				        .text "of"
.c73c					nt_endof:
>c73c	05 0d				        .byte 5, IM+CO+NN
>c73e	49 c7 c1 8d da 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c744	65 6e 64 6f 66			        .text "endof"
.c749					nt_endcase:
>c749	07 0d				        .byte 7, IM+CO+NN
>c74b	58 c7 00 8e 14 8e		        .word nt_defer_fetch, xt_endcase, z_endcase
>c751	65 6e 64 63 61 73 65		        .text "endcase"
.c758					nt_defer_fetch:
>c758	06 00				        .byte 6, 0
>c75a	66 c7 df 8a e5 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c760	64 65 66 65 72 40		        .text "defer@"
.c766					nt_defer_store:
>c766	06 00				        .byte 6, 0
>c768	74 c7 e6 8a ec 8a		        .word nt_is, xt_defer_store, z_defer_store
>c76e	64 65 66 65 72 21		        .text "defer!"
.c774					nt_is:
>c774	02 04				        .byte 2, IM
>c776	7e c7 fb 92 13 93		        .word nt_action_of, xt_is, z_is
>c77c	69 73				        .text "is"
.c77e					nt_action_of:
>c77e	09 04				        .byte 9, IM
>c780	8f c7 70 82 88 82		        .word nt_useraddr, xt_action_of, z_action_of
>c786	61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c78e	66
.c78f					nt_useraddr:
>c78f	08 00				        .byte 8, 0
>c791	9f c7 6d a6 77 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c797	75 73 65 72 61 64 64 72		        .text "useraddr"
.c79f					nt_buffer_colon:
>c79f	07 00				        .byte 7, 0
>c7a1	ae c7 e6 85 ec 85		        .word +, xt_buffer_colon, z_buffer_colon
>c7a7	62 75 66 66 65 72 3a		        .text "buffer:"
.c7ae					+
.c7ae					nt_buffstatus:
>c7ae	0a 00				        .byte 10, 0
>c7b0	c0 c7 ed 85 fc 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7b6	62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7be	75 73
.c7c0					nt_buffblocknum:
>c7c0	0c 00				        .byte 12, 0
>c7c2	d4 c7 a5 85 b4 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c7c8	62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c7d0	6b 6e 75 6d
.c7d4					nt_blkbuffer:
>c7d4	09 00				        .byte 9, 0
>c7d6	e5 c7 b3 83 c0 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c7dc	62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c7e4	72
.c7e5					nt_scr:
>c7e5	03 00				        .byte 3, 0
>c7e7	f0 c7 d9 9e e8 9e		        .word nt_blk, xt_scr, z_scr
>c7ed	73 63 72			        .text "scr"
.c7f0					nt_blk:
>c7f0	03 00				        .byte 3, 0
>c7f2	fb c7 a3 83 b2 83		        .word nt_block_write, xt_blk, z_blk
>c7f8	62 6c 6b			        .text "blk"
.c7fb					nt_block_write:
>c7fb	0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c7fd	0e c8 60 85 6e 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c803	62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c80b	69 74 65
.c80e					nt_block_write_vector:
>c80e	12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c810	28 c8 6e 85 7d 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c816	62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c81e	69 74 65 2d 76 65 63 74 6f 72
.c828					nt_block_read:
>c828	0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c82a	3a c8 3d 85 4b 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c830	62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c838	61 64
.c83a					nt_block_read_vector:
>c83a	11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c83c	53 c8 4b 85 5a 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c842	62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c84a	61 64 2d 76 65 63 74 6f 72
.c853					nt_save_buffers:
>c853	0c 00				        .byte 12, 0
>c855	67 c8 be 9e d8 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c85b	73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c863	66 65 72 73
.c867					nt_block:
>c867	05 00				        .byte 5, 0
>c869	74 c8 c1 83 13 84		        .word nt_update, xt_block, z_block
>c86f	62 6c 6f 63 6b			        .text "block"
.c874					nt_update:
>c874	06 00				        .byte 6, 0
>c876	82 c8 64 a6 6c a6		        .word nt_buffer, xt_update, z_update
>c87c	75 70 64 61 74 65		        .text "update"
.c882					nt_buffer:
>c882	06 00				        .byte 6, 0
>c884	90 c8 b5 85 e5 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c88a	62 75 66 66 65 72		        .text "buffer"
.c890					nt_empty_buffers:
>c890	0d 00				        .byte 13, 0
>c892	a5 c8 f9 8d ff 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c898	65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c8a0	66 66 65 72 73
.c8a5					nt_flush:
>c8a5	05 00				        .byte 5, 0
>c8a7	b2 c8 87 90 90 90		        .word nt_load, xt_flush, z_flush
>c8ad	66 6c 75 73 68			        .text "flush"
.c8b2					nt_load:
>c8b2	04 10				        .byte 4, UF
>c8b4	be c8 b7 93 fa 93		        .word nt_thru, xt_load, z_load
>c8ba	6c 6f 61 64			        .text "load"
.c8be					nt_thru:
>c8be	04 10				        .byte 4, UF
>c8c0	ca c8 cc a1 10 a2		        .word nt_list, xt_thru, z_thru
>c8c6	74 68 72 75			        .text "thru"
.c8ca					nt_list:
>c8ca	04 10				        .byte 4, UF
>c8cc	d6 c8 7d 93 89 93		        .word +, xt_list, z_list
>c8d2	6c 69 73 74			        .text "list"
.c8d6					+
.c8d6					nt_block_ramdrive_init:
>c8d6	13 10				        .byte 19, UF
>c8d8	f1 c8 14 84 3c 85		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c8de	62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c8e6	6d 64 72 69 76 65 2d 69 6e 69 74
.c8f1					+
.c8f1					nt_definitions:
>c8f1	0b 00				        .byte 11, 0
>c8f3	04 c9 ed 8a f5 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c8f9	64 65 66 69 6e 69 74 69		        .text "definitions"
>c901	6f 6e 73
.c904					nt_wordlist:
>c904	08 00				        .byte 8, 0
>c906	14 c9 01 a7 17 a7		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c90c	77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c914					nt_search_wordlist:
>c914	0f 10				        .byte 15, UF
>c916	2b c9 a0 9b 80 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c91c	73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c924	6f 72 64 6c 69 73 74
.c92b					nt_set_current:
>c92b	0b 10				        .byte 11, UF
>c92d	3e c9 0f 9d 1a 9d		        .word nt_get_current, xt_set_current, z_set_current
>c933	73 65 74 2d 63 75 72 72		        .text "set-current"
>c93b	65 6e 74
.c93e					nt_get_current:
>c93e	0b 00				        .byte 11, 0
>c940	51 c9 29 91 33 91		        .word nt_set_order, xt_get_current, z_get_current
>c946	67 65 74 2d 63 75 72 72		        .text "get-current"
>c94e	65 6e 74
.c951					nt_set_order:
>c951	09 00				        .byte 9, 0
>c953	62 c9 1b 9d 4e 9d		        .word nt_get_order, xt_set_order, z_set_order
>c959	73 65 74 2d 6f 72 64 65		        .text "set-order"
>c961	72
.c962					nt_get_order:
>c962	09 00				        .byte 9, 0
>c964	73 c9 34 91 5c 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c96a	67 65 74 2d 6f 72 64 65		        .text "get-order"
>c972	72
.c973					nt_root_wordlist:
>c973	0d 00				        .byte 13, 0
>c975	88 c9 4e 9b 56 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c97b	72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c983	64 6c 69 73 74
.c988					+
.c988					nt_assembler_wordlist:
>c988	12 00				        .byte 18, 0
>c98a	a2 c9 a7 a3 af a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c990	61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c998	72 2d 77 6f 72 64 6c 69 73 74
.c9a2					+
.c9a2					nt_editor_wordlist:
>c9a2	0f 00				        .byte 15, 0
>c9a4	b9 c9 08 98 10 98		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9aa	65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9b2	6f 72 64 6c 69 73 74
.c9b9					+
.c9b9					nt_forth_wordlist:
>c9b9	0e 00				        .byte 14, 0
>c9bb	cf c9 a8 a7 ae a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c9c1	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9c9	72 64 6c 69 73 74
.c9cf					nt_only:
>c9cf	04 00				        .byte 4, 0
>c9d1	db c9 27 98 32 98		        .word nt_also, xt_only, z_only
>c9d7	6f 6e 6c 79			        .text "only"
.c9db					nt_also:
>c9db	04 00				        .byte 4, 0
>c9dd	e7 c9 20 83 2f 83		        .word nt_previous, xt_also, z_also
>c9e3	61 6c 73 6f			        .text "also"
.c9e7					nt_previous:
>c9e7	08 00				        .byte 8, 0
>c9e9	f7 c9 55 9a 61 9a		        .word nt_to_order, xt_previous, z_previous
>c9ef	70 72 65 76 69 6f 75 73		        .text "previous"
.c9f7					nt_to_order:
>c9f7	06 00				        .byte 6, 0
>c9f9	05 ca 5d a3 6f a3		        .word nt_order, xt_to_order, z_to_order
>c9ff	3e 6f 72 64 65 72		        .text ">order"
.ca05					nt_order:
>ca05	05 00				        .byte 5, 0
>ca07	12 ca 45 98 6f 98		        .word nt_forth, xt_order, z_order
>ca0d	6f 72 64 65 72			        .text "order"
.ca12					nt_forth:
>ca12	05 00				        .byte 5, 0
>ca14	1f ca c8 90 ce 90		        .word +, xt_forth, z_forth
>ca1a	66 6f 72 74 68			        .text "forth"
.ca1f					+
>ca1f	03 08				nt_see: .byte 3, NN
>ca21	2a ca 81 9c 0e 9d		        .word +, xt_see, z_see
>ca27	73 65 65			        .text "see"
.ca2a					+
.ca2a					nt_ed:
>ca2a	02 08				        .byte 2, NN
>ca2c	34 ca bd 8d c0 8d		        .word +, xt_ed, z_ed
>ca32	65 64				        .text "ed"
.ca34					+
.ca34					nt_cold:
>ca34	04 00				        .byte 4, 0
>ca36	40 ca 00 80 c5 80		        .word nt_bye, xt_cold, z_cold
>ca3c	63 6f 6c 64			        .text "cold"
.ca40					nt_bye:
>ca40	03				        .byte 3         ; length of word strings
>ca41	00				        .byte 0         ; status byte
>ca42	00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca44	fd 85				        .word xt_bye    ; start of code block (xt of this word)
>ca46	00 86				        .word z_bye     ; end of code (RTS)
>ca48	62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca4b					root_dictionary_start:
.ca4b					nt_root_set_order:
>ca4b	09 00				        .byte 9, 0
>ca4d	5c ca 1b 9d 4e 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca53	73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca5b	72
.ca5c					nt_root_forth:
>ca5c	05 00				        .byte 5, 0
>ca5e	69 ca c8 90 ce 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>ca64	66 6f 72 74 68			        .text "forth"
.ca69					nt_root_forth_wordlist:
>ca69	0e 00				        .byte 14, 0
>ca6b	7f ca a8 a7 ae a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>ca71	66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca79	72 64 6c 69 73 74
.ca7f					nt_root_words:
>ca7f	05 00				        .byte 5, 0
>ca81	00 00 18 a7 74 a7		        .word 0000, xt_words, z_words
>ca87	77 6f 72 64 73			        .text "words"
.ca8c					editor_dictionary_start:
.ca8c					nt_editor_o:
>ca8c	01 00				        .byte 1, 0
>ca8e	95 ca db a8 20 a9		        .word nt_editor_line, xt_editor_o, z_editor_o
>ca94	6f				        .text "o"
.ca95					nt_editor_line:
>ca95	04 10				        .byte 4, UF
>ca97	a1 ca c2 a8 da a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>ca9d	6c 69 6e 65			        .text "line"
.caa1					nt_editor_l:
>caa1	01 00				        .byte 1, 0
>caa3	aa ca 46 a8 c1 a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>caa9	6c				        .text "l"
.caaa					nt_editor_el:
>caaa	02 00				        .byte 2, 0
>caac	b4 ca 34 a8 45 a8		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>cab2	65 6c				        .text "el"
.cab4					nt_editor_erase_screen:
>cab4	0c 00				        .byte 12, 0
>cab6	c8 ca 22 a8 33 a8		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cabc	65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cac4	72 65 65 6e
.cac8					nt_editor_enter_screen:
>cac8	0c 00				        .byte 12, 0
>caca	00 00 06 a8 21 a8		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cad0	65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cad8	72 65 65 6e
.cadc					assembler_dictionary_start:
.cadc					nt_asm_adc_h:
>cadc	05 0c						.byte 5, IM+NN
>cade	e9 ca				                .word nt_asm_adc_x
>cae0	21 a9 26 a9					.word xt_asm_adc_h, z_asm_adc_h
>cae4	61 64 63 2e 23					.text "adc.#"
.cae9					nt_asm_adc_x:
>cae9	05 0c						.byte 5, IM+NN
>caeb	f6 ca				                .word nt_asm_adc_y
>caed	26 a9 2b a9					.word xt_asm_adc_x, z_asm_adc_x
>caf1	61 64 63 2e 78					.text "adc.x"
.caf6					nt_asm_adc_y:
>caf6	05 0c						.byte 5, IM+NN
>caf8	03 cb				                .word nt_asm_adc_z
>cafa	2b a9 30 a9					.word xt_asm_adc_y, z_asm_adc_y
>cafe	61 64 63 2e 79					.text "adc.y"
.cb03					nt_asm_adc_z:
>cb03	05 0c						.byte 5, IM+NN
>cb05	10 cb				                .word nt_asm_adc_zi
>cb07	30 a9 35 a9					.word xt_asm_adc_z, z_asm_adc_z
>cb0b	61 64 63 2e 7a					.text "adc.z"
.cb10					nt_asm_adc_zi:
>cb10	06 0c						.byte 6, IM+NN
>cb12	1e cb				                .word nt_asm_adc_ziy
>cb14	35 a9 3a a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cb18	61 64 63 2e 7a 69				.text "adc.zi"
.cb1e					nt_asm_adc_ziy:
>cb1e	07 0c						.byte 7, IM+NN
>cb20	2d cb				                .word nt_asm_adc_zx
>cb22	3a a9 3f a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb26	61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb2d					nt_asm_adc_zx:
>cb2d	06 0c						.byte 6, IM+NN
>cb2f	3b cb				                .word nt_asm_adc_zxi
>cb31	3f a9 44 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb35	61 64 63 2e 7a 78				.text "adc.zx"
.cb3b					nt_asm_adc_zxi:
>cb3b	07 0c						.byte 7, IM+NN
>cb3d	4a cb				                .word nt_asm_and
>cb3f	44 a9 49 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb43	61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb4a					nt_asm_and:
>cb4a	04 0c						.byte 4, IM+NN
>cb4c	56 cb				                .word nt_asm_and_h
>cb4e	49 a9 4e a9					.word xt_asm_and, z_asm_and
>cb52	61 6e 64 2e					.text "and."
.cb56					nt_asm_and_h:
>cb56	05 0c						.byte 5, IM+NN
>cb58	63 cb				                .word nt_asm_and_x
>cb5a	4e a9 53 a9					.word xt_asm_and_h, z_asm_and_h
>cb5e	61 6e 64 2e 23					.text "and.#"
.cb63					nt_asm_and_x:
>cb63	05 0c						.byte 5, IM+NN
>cb65	70 cb				                .word nt_asm_and_y
>cb67	53 a9 58 a9					.word xt_asm_and_x, z_asm_and_x
>cb6b	61 6e 64 2e 78					.text "and.x"
.cb70					nt_asm_and_y:
>cb70	05 0c						.byte 5, IM+NN
>cb72	7d cb				                .word nt_asm_and_z
>cb74	58 a9 5d a9					.word xt_asm_and_y, z_asm_and_y
>cb78	61 6e 64 2e 79					.text "and.y"
.cb7d					nt_asm_and_z:
>cb7d	05 0c						.byte 5, IM+NN
>cb7f	8a cb				                .word nt_asm_and_zi
>cb81	5d a9 62 a9					.word xt_asm_and_z, z_asm_and_z
>cb85	61 6e 64 2e 7a					.text "and.z"
.cb8a					nt_asm_and_zi:
>cb8a	06 0c						.byte 6, IM+NN
>cb8c	98 cb				                .word nt_asm_and_ziy
>cb8e	62 a9 67 a9					.word xt_asm_and_zi, z_asm_and_zi
>cb92	61 6e 64 2e 7a 69				.text "and.zi"
.cb98					nt_asm_and_ziy:
>cb98	07 0c						.byte 7, IM+NN
>cb9a	a7 cb				                .word nt_asm_and_zx
>cb9c	67 a9 6c a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cba0	61 6e 64 2e 7a 69 79				.text "and.ziy"
.cba7					nt_asm_and_zx:
>cba7	06 0c						.byte 6, IM+NN
>cba9	b5 cb				                .word nt_asm_and_zxi
>cbab	6c a9 71 a9					.word xt_asm_and_zx, z_asm_and_zx
>cbaf	61 6e 64 2e 7a 78				.text "and.zx"
.cbb5					nt_asm_and_zxi:
>cbb5	07 0c						.byte 7, IM+NN
>cbb7	c4 cb				                .word nt_asm_asl
>cbb9	71 a9 76 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cbbd	61 6e 64 2e 7a 78 69				.text "and.zxi"
.cbc4					nt_asm_asl:
>cbc4	03 0c						.byte 3, IM+NN
>cbc6	cf cb				                .word nt_asm_asl_a
>cbc8	76 a9 7b a9					.word xt_asm_asl, z_asm_asl
>cbcc	61 73 6c					.text "asl"
.cbcf					nt_asm_asl_a:
>cbcf	05 0c						.byte 5, IM+NN
>cbd1	dc cb				                .word nt_asm_asl_x
>cbd3	7b a9 80 a9					.word xt_asm_asl_a, z_asm_asl_a
>cbd7	61 73 6c 2e 61					.text "asl.a"
.cbdc					nt_asm_asl_x:
>cbdc	05 0c						.byte 5, IM+NN
>cbde	e9 cb				                .word nt_asm_asl_z
>cbe0	80 a9 85 a9					.word xt_asm_asl_x, z_asm_asl_x
>cbe4	61 73 6c 2e 78					.text "asl.x"
.cbe9					nt_asm_asl_z:
>cbe9	05 0c						.byte 5, IM+NN
>cbeb	f6 cb				                .word nt_asm_asl_zx
>cbed	85 a9 8a a9					.word xt_asm_asl_z, z_asm_asl_z
>cbf1	61 73 6c 2e 7a					.text "asl.z"
.cbf6					nt_asm_asl_zx:
>cbf6	06 0c						.byte 6, IM+NN
>cbf8	04 cc				                .word nt_asm_bcc
>cbfa	8a a9 8f a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cbfe	61 73 6c 2e 7a 78				.text "asl.zx"
.cc04					nt_asm_bcc:
>cc04	03 0c						.byte 3, IM+NN
>cc06	0f cc				                .word nt_asm_bcs
>cc08	8f a9 94 a9					.word xt_asm_bcc, z_asm_bcc
>cc0c	62 63 63					.text "bcc"
.cc0f					nt_asm_bcs:
>cc0f	03 0c						.byte 3, IM+NN
>cc11	1a cc				                .word nt_asm_beq
>cc13	94 a9 9b a9					.word xt_asm_bcs, z_asm_bcs
>cc17	62 63 73					.text "bcs"
.cc1a					nt_asm_beq:
>cc1a	03 0c						.byte 3, IM+NN
>cc1c	25 cc				                .word nt_asm_bit
>cc1e	9b a9 a0 a9					.word xt_asm_beq, z_asm_beq
>cc22	62 65 71					.text "beq"
.cc25					nt_asm_bit:
>cc25	03 0c						.byte 3, IM+NN
>cc27	30 cc				                .word nt_asm_bit_h
>cc29	a0 a9 a5 a9					.word xt_asm_bit, z_asm_bit
>cc2d	62 69 74					.text "bit"
.cc30					nt_asm_bit_h:
>cc30	05 0c						.byte 5, IM+NN
>cc32	3d cc				                .word nt_asm_bit_x
>cc34	a5 a9 aa a9					.word xt_asm_bit_h, z_asm_bit_h
>cc38	62 69 74 2e 23					.text "bit.#"
.cc3d					nt_asm_bit_x:
>cc3d	05 0c						.byte 5, IM+NN
>cc3f	4a cc				                .word nt_asm_bit_z
>cc41	aa a9 af a9					.word xt_asm_bit_x, z_asm_bit_x
>cc45	62 69 74 2e 78					.text "bit.x"
.cc4a					nt_asm_bit_z:
>cc4a	05 0c						.byte 5, IM+NN
>cc4c	57 cc				                .word nt_asm_bit_zx
>cc4e	af a9 b4 a9					.word xt_asm_bit_z, z_asm_bit_z
>cc52	62 69 74 2e 7a					.text "bit.z"
.cc57					nt_asm_bit_zx:
>cc57	06 0c						.byte 6, IM+NN
>cc59	65 cc				                .word nt_asm_bmi
>cc5b	b4 a9 b9 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc5f	62 69 74 2e 7a 78				.text "bit.zx"
.cc65					nt_asm_bmi:
>cc65	03 0c						.byte 3, IM+NN
>cc67	70 cc				                .word nt_asm_bne
>cc69	b9 a9 be a9					.word xt_asm_bmi, z_asm_bmi
>cc6d	62 6d 69					.text "bmi"
.cc70					nt_asm_bne:
>cc70	03 0c						.byte 3, IM+NN
>cc72	7b cc				                .word nt_asm_bpl
>cc74	be a9 c3 a9					.word xt_asm_bne, z_asm_bne
>cc78	62 6e 65					.text "bne"
.cc7b					nt_asm_bpl:
>cc7b	03 0c						.byte 3, IM+NN
>cc7d	86 cc				                .word nt_asm_bra
>cc7f	c3 a9 c8 a9					.word xt_asm_bpl, z_asm_bpl
>cc83	62 70 6c					.text "bpl"
.cc86					nt_asm_bra:
>cc86	03 0c						.byte 3, IM+NN
>cc88	91 cc				                .word nt_asm_brk
>cc8a	c8 a9 cd a9					.word xt_asm_bra, z_asm_bra
>cc8e	62 72 61					.text "bra"
.cc91					nt_asm_brk:
>cc91	03 0c						.byte 3, IM+NN
>cc93	9c cc				                .word nt_asm_bvc
>cc95	cd a9 d2 a9					.word xt_asm_brk, z_asm_brk
>cc99	62 72 6b					.text "brk"
.cc9c					nt_asm_bvc:
>cc9c	03 0c						.byte 3, IM+NN
>cc9e	a7 cc				                .word nt_asm_bvs
>cca0	d2 a9 d7 a9					.word xt_asm_bvc, z_asm_bvc
>cca4	62 76 63					.text "bvc"
.cca7					nt_asm_bvs:
>cca7	03 0c						.byte 3, IM+NN
>cca9	b2 cc				                .word nt_asm_clc
>ccab	d7 a9 dc a9					.word xt_asm_bvs, z_asm_bvs
>ccaf	62 76 73					.text "bvs"
.ccb2					nt_asm_clc:
>ccb2	03 0c						.byte 3, IM+NN
>ccb4	bd cc				                .word nt_asm_cld
>ccb6	dc a9 e1 a9					.word xt_asm_clc, z_asm_clc
>ccba	63 6c 63					.text "clc"
.ccbd					nt_asm_cld:
>ccbd	03 0c						.byte 3, IM+NN
>ccbf	c8 cc				                .word nt_asm_cli
>ccc1	e1 a9 e6 a9					.word xt_asm_cld, z_asm_cld
>ccc5	63 6c 64					.text "cld"
.ccc8					nt_asm_cli:
>ccc8	03 0c						.byte 3, IM+NN
>ccca	d3 cc				                .word nt_asm_clv
>cccc	e6 a9 eb a9					.word xt_asm_cli, z_asm_cli
>ccd0	63 6c 69					.text "cli"
.ccd3					nt_asm_clv:
>ccd3	03 0c						.byte 3, IM+NN
>ccd5	de cc				                .word nt_asm_cmp
>ccd7	eb a9 f0 a9					.word xt_asm_clv, z_asm_clv
>ccdb	63 6c 76					.text "clv"
.ccde					nt_asm_cmp:
>ccde	03 0c						.byte 3, IM+NN
>cce0	e9 cc				                .word nt_asm_cmp_h
>cce2	f0 a9 f5 a9					.word xt_asm_cmp, z_asm_cmp
>cce6	63 6d 70					.text "cmp"
.cce9					nt_asm_cmp_h:
>cce9	05 0c						.byte 5, IM+NN
>cceb	f6 cc				                .word nt_asm_cmp_x
>cced	f5 a9 fa a9					.word xt_asm_cmp_h, z_asm_cmp_h
>ccf1	63 6d 70 2e 23					.text "cmp.#"
.ccf6					nt_asm_cmp_x:
>ccf6	05 0c						.byte 5, IM+NN
>ccf8	03 cd				                .word nt_asm_cmp_y
>ccfa	fa a9 ff a9					.word xt_asm_cmp_x, z_asm_cmp_x
>ccfe	63 6d 70 2e 78					.text "cmp.x"
.cd03					nt_asm_cmp_y:
>cd03	05 0c						.byte 5, IM+NN
>cd05	10 cd				                .word nt_asm_cmp_z
>cd07	ff a9 04 aa					.word xt_asm_cmp_y, z_asm_cmp_y
>cd0b	63 6d 70 2e 79					.text "cmp.y"
.cd10					nt_asm_cmp_z:
>cd10	05 0c						.byte 5, IM+NN
>cd12	1d cd				                .word nt_asm_cmp_zi
>cd14	04 aa 09 aa					.word xt_asm_cmp_z, z_asm_cmp_z
>cd18	63 6d 70 2e 7a					.text "cmp.z"
.cd1d					nt_asm_cmp_zi:
>cd1d	06 0c						.byte 6, IM+NN
>cd1f	2b cd				                .word nt_asm_cmp_ziy
>cd21	09 aa 0e aa					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd25	63 6d 70 2e 7a 69				.text "cmp.zi"
.cd2b					nt_asm_cmp_ziy:
>cd2b	07 0c						.byte 7, IM+NN
>cd2d	3a cd				                .word nt_asm_cmp_zx
>cd2f	0e aa 13 aa					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd33	63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd3a					nt_asm_cmp_zx:
>cd3a	06 0c						.byte 6, IM+NN
>cd3c	48 cd				                .word nt_asm_cmp_zxi
>cd3e	13 aa 18 aa					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd42	63 6d 70 2e 7a 78				.text "cmp.zx"
.cd48					nt_asm_cmp_zxi:
>cd48	07 0c						.byte 7, IM+NN
>cd4a	57 cd				                .word nt_asm_cpx
>cd4c	18 aa 1d aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd50	63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd57					nt_asm_cpx:
>cd57	03 0c						.byte 3, IM+NN
>cd59	62 cd				                .word nt_asm_cpx_h
>cd5b	1d aa 22 aa					.word xt_asm_cpx, z_asm_cpx
>cd5f	63 70 78					.text "cpx"
.cd62					nt_asm_cpx_h:
>cd62	05 0c						.byte 5, IM+NN
>cd64	6f cd				                .word nt_asm_cpx_z
>cd66	22 aa 27 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>cd6a	63 70 78 2e 23					.text "cpx.#"
.cd6f					nt_asm_cpx_z:
>cd6f	05 0c						.byte 5, IM+NN
>cd71	7c cd				                .word nt_asm_cpy
>cd73	27 aa 2c aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cd77	63 70 78 2e 7a					.text "cpx.z"
.cd7c					nt_asm_cpy:
>cd7c	03 0c						.byte 3, IM+NN
>cd7e	87 cd				                .word nt_asm_cpy_h
>cd80	2c aa 33 aa					.word xt_asm_cpy, z_asm_cpy
>cd84	63 70 79					.text "cpy"
.cd87					nt_asm_cpy_h:
>cd87	05 0c						.byte 5, IM+NN
>cd89	94 cd				                .word nt_asm_cpy_z
>cd8b	33 aa 38 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cd8f	63 70 79 2e 23					.text "cpy.#"
.cd94					nt_asm_cpy_z:
>cd94	05 0c						.byte 5, IM+NN
>cd96	a1 cd				                .word nt_asm_dec
>cd98	38 aa 3d aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cd9c	63 70 79 2e 7a					.text "cpy.z"
.cda1					nt_asm_dec:
>cda1	03 0c						.byte 3, IM+NN
>cda3	ac cd				                .word nt_asm_dec_a
>cda5	3d aa 42 aa					.word xt_asm_dec, z_asm_dec
>cda9	64 65 63					.text "dec"
.cdac					nt_asm_dec_a:
>cdac	05 0c						.byte 5, IM+NN
>cdae	b9 cd				                .word nt_asm_dec_x
>cdb0	42 aa 47 aa					.word xt_asm_dec_a, z_asm_dec_a
>cdb4	64 65 63 2e 61					.text "dec.a"
.cdb9					nt_asm_dec_x:
>cdb9	05 0c						.byte 5, IM+NN
>cdbb	c6 cd				                .word nt_asm_dec_z
>cdbd	47 aa 4c aa					.word xt_asm_dec_x, z_asm_dec_x
>cdc1	64 65 63 2e 78					.text "dec.x"
.cdc6					nt_asm_dec_z:
>cdc6	05 0c						.byte 5, IM+NN
>cdc8	d3 cd				                .word nt_asm_dec_zx
>cdca	4c aa 51 aa					.word xt_asm_dec_z, z_asm_dec_z
>cdce	64 65 63 2e 7a					.text "dec.z"
.cdd3					nt_asm_dec_zx:
>cdd3	06 0c						.byte 6, IM+NN
>cdd5	e1 cd				                .word nt_asm_dex
>cdd7	51 aa 56 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>cddb	64 65 63 2e 7a 78				.text "dec.zx"
.cde1					nt_asm_dex:
>cde1	03 0c						.byte 3, IM+NN
>cde3	ec cd				                .word nt_asm_dey
>cde5	56 aa 5b aa					.word xt_asm_dex, z_asm_dex
>cde9	64 65 78					.text "dex"
.cdec					nt_asm_dey:
>cdec	03 0c						.byte 3, IM+NN
>cdee	f7 cd				                .word nt_asm_eor
>cdf0	5b aa 60 aa					.word xt_asm_dey, z_asm_dey
>cdf4	64 65 79					.text "dey"
.cdf7					nt_asm_eor:
>cdf7	03 0c						.byte 3, IM+NN
>cdf9	02 ce				                .word nt_asm_eor_h
>cdfb	60 aa 65 aa					.word xt_asm_eor, z_asm_eor
>cdff	65 6f 72					.text "eor"
.ce02					nt_asm_eor_h:
>ce02	05 0c						.byte 5, IM+NN
>ce04	0f ce				                .word nt_asm_eor_x
>ce06	65 aa 6a aa					.word xt_asm_eor_h, z_asm_eor_h
>ce0a	65 6f 72 2e 23					.text "eor.#"
.ce0f					nt_asm_eor_x:
>ce0f	05 0c						.byte 5, IM+NN
>ce11	1c ce				                .word nt_asm_eor_y
>ce13	6a aa 6f aa					.word xt_asm_eor_x, z_asm_eor_x
>ce17	65 6f 72 2e 78					.text "eor.x"
.ce1c					nt_asm_eor_y:
>ce1c	05 0c						.byte 5, IM+NN
>ce1e	29 ce				                .word nt_asm_eor_z
>ce20	6f aa 74 aa					.word xt_asm_eor_y, z_asm_eor_y
>ce24	65 6f 72 2e 79					.text "eor.y"
.ce29					nt_asm_eor_z:
>ce29	05 0c						.byte 5, IM+NN
>ce2b	36 ce				                .word nt_asm_eor_zi
>ce2d	74 aa 79 aa					.word xt_asm_eor_z, z_asm_eor_z
>ce31	65 6f 72 2e 7a					.text "eor.z"
.ce36					nt_asm_eor_zi:
>ce36	06 0c						.byte 6, IM+NN
>ce38	44 ce				                .word nt_asm_eor_ziy
>ce3a	79 aa 7e aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce3e	65 6f 72 2e 7a 69				.text "eor.zi"
.ce44					nt_asm_eor_ziy:
>ce44	07 0c						.byte 7, IM+NN
>ce46	53 ce				                .word nt_asm_eor_zx
>ce48	7e aa 83 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce4c	65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce53					nt_asm_eor_zx:
>ce53	06 0c						.byte 6, IM+NN
>ce55	61 ce				                .word nt_asm_eor_zxi
>ce57	83 aa 88 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce5b	65 6f 72 2e 7a 78				.text "eor.zx"
.ce61					nt_asm_eor_zxi:
>ce61	07 0c						.byte 7, IM+NN
>ce63	70 ce				                .word nt_asm_inc
>ce65	88 aa 8d aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>ce69	65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ce70					nt_asm_inc:
>ce70	03 0c						.byte 3, IM+NN
>ce72	7b ce				                .word nt_asm_inc_a
>ce74	8d aa 92 aa					.word xt_asm_inc, z_asm_inc
>ce78	69 6e 63					.text "inc"
.ce7b					nt_asm_inc_a:
>ce7b	05 0c						.byte 5, IM+NN
>ce7d	88 ce				                .word nt_asm_inc_x
>ce7f	92 aa 97 aa					.word xt_asm_inc_a, z_asm_inc_a
>ce83	69 6e 63 2e 61					.text "inc.a"
.ce88					nt_asm_inc_x:
>ce88	05 0c						.byte 5, IM+NN
>ce8a	95 ce				                .word nt_asm_inc_z
>ce8c	97 aa 9c aa					.word xt_asm_inc_x, z_asm_inc_x
>ce90	69 6e 63 2e 78					.text "inc.x"
.ce95					nt_asm_inc_z:
>ce95	05 0c						.byte 5, IM+NN
>ce97	a2 ce				                .word nt_asm_inc_zx
>ce99	9c aa a1 aa					.word xt_asm_inc_z, z_asm_inc_z
>ce9d	69 6e 63 2e 7a					.text "inc.z"
.cea2					nt_asm_inc_zx:
>cea2	06 0c						.byte 6, IM+NN
>cea4	b0 ce				                .word nt_asm_inx
>cea6	a1 aa a6 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>ceaa	69 6e 63 2e 7a 78				.text "inc.zx"
.ceb0					nt_asm_inx:
>ceb0	03 0c						.byte 3, IM+NN
>ceb2	bb ce				                .word nt_asm_iny
>ceb4	a6 aa ab aa					.word xt_asm_inx, z_asm_inx
>ceb8	69 6e 78					.text "inx"
.cebb					nt_asm_iny:
>cebb	03 0c						.byte 3, IM+NN
>cebd	c6 ce				                .word nt_asm_jmp
>cebf	ab aa b0 aa					.word xt_asm_iny, z_asm_iny
>cec3	69 6e 79					.text "iny"
.cec6					nt_asm_jmp:
>cec6	03 0c						.byte 3, IM+NN
>cec8	d1 ce				                .word nt_asm_jmp_i
>ceca	b0 aa b5 aa					.word xt_asm_jmp, z_asm_jmp
>cece	6a 6d 70					.text "jmp"
.ced1					nt_asm_jmp_i:
>ced1	05 0c						.byte 5, IM+NN
>ced3	de ce				                .word nt_asm_jmp_xi
>ced5	b5 aa ba aa					.word xt_asm_jmp_i, z_asm_jmp_i
>ced9	6a 6d 70 2e 69					.text "jmp.i"
.cede					nt_asm_jmp_xi:
>cede	06 0c						.byte 6, IM+NN
>cee0	ec ce				                .word nt_asm_jsr
>cee2	ba aa bf aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cee6	6a 6d 70 2e 78 69				.text "jmp.xi"
.ceec					nt_asm_jsr:
>ceec	03 0c						.byte 3, IM+NN
>ceee	f7 ce				                .word nt_asm_lda
>cef0	bf aa c4 aa					.word xt_asm_jsr, z_asm_jsr
>cef4	6a 73 72					.text "jsr"
.cef7					nt_asm_lda:
>cef7	03 0c						.byte 3, IM+NN
>cef9	02 cf				                .word nt_asm_lda_h
>cefb	c4 aa c9 aa					.word xt_asm_lda, z_asm_lda
>ceff	6c 64 61					.text "lda"
.cf02					nt_asm_lda_h:
>cf02	05 0c						.byte 5, IM+NN
>cf04	0f cf				                .word nt_asm_lda_x
>cf06	c9 aa ce aa					.word xt_asm_lda_h, z_asm_lda_h
>cf0a	6c 64 61 2e 23					.text "lda.#"
.cf0f					nt_asm_lda_x:
>cf0f	05 0c						.byte 5, IM+NN
>cf11	1c cf				                .word nt_asm_lda_y
>cf13	ce aa d3 aa					.word xt_asm_lda_x, z_asm_lda_x
>cf17	6c 64 61 2e 78					.text "lda.x"
.cf1c					nt_asm_lda_y:
>cf1c	05 0c						.byte 5, IM+NN
>cf1e	29 cf				                .word nt_asm_lda_z
>cf20	d3 aa d8 aa					.word xt_asm_lda_y, z_asm_lda_y
>cf24	6c 64 61 2e 79					.text "lda.y"
.cf29					nt_asm_lda_z:
>cf29	05 0c						.byte 5, IM+NN
>cf2b	36 cf				                .word nt_asm_lda_zi
>cf2d	d8 aa dd aa					.word xt_asm_lda_z, z_asm_lda_z
>cf31	6c 64 61 2e 7a					.text "lda.z"
.cf36					nt_asm_lda_zi:
>cf36	06 0c						.byte 6, IM+NN
>cf38	44 cf				                .word nt_asm_lda_ziy
>cf3a	dd aa e2 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cf3e	6c 64 61 2e 7a 69				.text "lda.zi"
.cf44					nt_asm_lda_ziy:
>cf44	07 0c						.byte 7, IM+NN
>cf46	53 cf				                .word nt_asm_lda_zx
>cf48	e2 aa e7 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf4c	6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf53					nt_asm_lda_zx:
>cf53	06 0c						.byte 6, IM+NN
>cf55	61 cf				                .word nt_asm_lda_zxi
>cf57	e7 aa ec aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf5b	6c 64 61 2e 7a 78				.text "lda.zx"
.cf61					nt_asm_lda_zxi:
>cf61	07 0c						.byte 7, IM+NN
>cf63	70 cf				                .word nt_asm_ldx
>cf65	ec aa f1 aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cf69	6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cf70					nt_asm_ldx:
>cf70	03 0c						.byte 3, IM+NN
>cf72	7b cf				                .word nt_asm_ldx_h
>cf74	f1 aa f6 aa					.word xt_asm_ldx, z_asm_ldx
>cf78	6c 64 78					.text "ldx"
.cf7b					nt_asm_ldx_h:
>cf7b	05 0c						.byte 5, IM+NN
>cf7d	88 cf				                .word nt_asm_ldx_y
>cf7f	f6 aa fb aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cf83	6c 64 78 2e 23					.text "ldx.#"
.cf88					nt_asm_ldx_y:
>cf88	05 0c						.byte 5, IM+NN
>cf8a	95 cf				                .word nt_asm_ldx_z
>cf8c	fb aa 00 ab					.word xt_asm_ldx_y, z_asm_ldx_y
>cf90	6c 64 78 2e 79					.text "ldx.y"
.cf95					nt_asm_ldx_z:
>cf95	05 0c						.byte 5, IM+NN
>cf97	a2 cf				                .word nt_asm_ldx_zy
>cf99	00 ab 05 ab					.word xt_asm_ldx_z, z_asm_ldx_z
>cf9d	6c 64 78 2e 7a					.text "ldx.z"
.cfa2					nt_asm_ldx_zy:
>cfa2	06 0c						.byte 6, IM+NN
>cfa4	b0 cf				                .word nt_asm_ldy
>cfa6	05 ab 0a ab					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfaa	6c 64 78 2e 7a 79				.text "ldx.zy"
.cfb0					nt_asm_ldy:
>cfb0	03 0c						.byte 3, IM+NN
>cfb2	bb cf				                .word nt_asm_ldy_h
>cfb4	0a ab 0f ab					.word xt_asm_ldy, z_asm_ldy
>cfb8	6c 64 79					.text "ldy"
.cfbb					nt_asm_ldy_h:
>cfbb	05 0c						.byte 5, IM+NN
>cfbd	c8 cf				                .word nt_asm_ldy_x
>cfbf	0f ab 14 ab					.word xt_asm_ldy_h, z_asm_ldy_h
>cfc3	6c 64 79 2e 23					.text "ldy.#"
.cfc8					nt_asm_ldy_x:
>cfc8	05 0c						.byte 5, IM+NN
>cfca	d5 cf				                .word nt_asm_ldy_z
>cfcc	14 ab 19 ab					.word xt_asm_ldy_x, z_asm_ldy_x
>cfd0	6c 64 79 2e 78					.text "ldy.x"
.cfd5					nt_asm_ldy_z:
>cfd5	05 0c						.byte 5, IM+NN
>cfd7	e2 cf				                .word nt_asm_ldy_zx
>cfd9	19 ab 1e ab					.word xt_asm_ldy_z, z_asm_ldy_z
>cfdd	6c 64 79 2e 7a					.text "ldy.z"
.cfe2					nt_asm_ldy_zx:
>cfe2	06 0c						.byte 6, IM+NN
>cfe4	f0 cf				                .word nt_asm_lsr
>cfe6	1e ab 23 ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cfea	6c 64 79 2e 7a 78				.text "ldy.zx"
.cff0					nt_asm_lsr:
>cff0	03 0c						.byte 3, IM+NN
>cff2	fb cf				                .word nt_asm_lsr_a
>cff4	23 ab 28 ab					.word xt_asm_lsr, z_asm_lsr
>cff8	6c 73 72					.text "lsr"
.cffb					nt_asm_lsr_a:
>cffb	05 0c						.byte 5, IM+NN
>cffd	08 d0				                .word nt_asm_lsr_x
>cfff	28 ab 2d ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d003	6c 73 72 2e 61					.text "lsr.a"
.d008					nt_asm_lsr_x:
>d008	05 0c						.byte 5, IM+NN
>d00a	15 d0				                .word nt_asm_lsr_z
>d00c	2d ab 32 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d010	6c 73 72 2e 78					.text "lsr.x"
.d015					nt_asm_lsr_z:
>d015	05 0c						.byte 5, IM+NN
>d017	22 d0				                .word nt_asm_lsr_zx
>d019	32 ab 37 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d01d	6c 73 72 2e 7a					.text "lsr.z"
.d022					nt_asm_lsr_zx:
>d022	06 0c						.byte 6, IM+NN
>d024	30 d0				                .word nt_asm_nop
>d026	37 ab 3c ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d02a	6c 73 72 2e 7a 78				.text "lsr.zx"
.d030					nt_asm_nop:
>d030	03 0c						.byte 3, IM+NN
>d032	3b d0				                .word nt_asm_ora
>d034	3c ab 41 ab					.word xt_asm_nop, z_asm_nop
>d038	6e 6f 70					.text "nop"
.d03b					nt_asm_ora:
>d03b	03 0c						.byte 3, IM+NN
>d03d	46 d0				                .word nt_asm_ora_h
>d03f	41 ab 46 ab					.word xt_asm_ora, z_asm_ora
>d043	6f 72 61					.text "ora"
.d046					nt_asm_ora_h:
>d046	05 0c						.byte 5, IM+NN
>d048	53 d0				                .word nt_asm_ora_x
>d04a	46 ab 4b ab					.word xt_asm_ora_h, z_asm_ora_h
>d04e	6f 72 61 2e 23					.text "ora.#"
.d053					nt_asm_ora_x:
>d053	05 0c						.byte 5, IM+NN
>d055	60 d0				                .word nt_asm_ora_y
>d057	4b ab 50 ab					.word xt_asm_ora_x, z_asm_ora_x
>d05b	6f 72 61 2e 78					.text "ora.x"
.d060					nt_asm_ora_y:
>d060	05 0c						.byte 5, IM+NN
>d062	6d d0				                .word nt_asm_ora_z
>d064	50 ab 55 ab					.word xt_asm_ora_y, z_asm_ora_y
>d068	6f 72 61 2e 79					.text "ora.y"
.d06d					nt_asm_ora_z:
>d06d	05 0c						.byte 5, IM+NN
>d06f	7a d0				                .word nt_asm_ora_zi
>d071	55 ab 5a ab					.word xt_asm_ora_z, z_asm_ora_z
>d075	6f 72 61 2e 7a					.text "ora.z"
.d07a					nt_asm_ora_zi:
>d07a	06 0c						.byte 6, IM+NN
>d07c	88 d0				                .word nt_asm_ora_ziy
>d07e	5a ab 61 ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d082	6f 72 61 2e 7a 69				.text "ora.zi"
.d088					nt_asm_ora_ziy:
>d088	07 0c						.byte 7, IM+NN
>d08a	97 d0				                .word nt_asm_ora_zx
>d08c	61 ab 66 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d090	6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d097					nt_asm_ora_zx:
>d097	06 0c						.byte 6, IM+NN
>d099	a5 d0				                .word nt_asm_ora_zxi
>d09b	66 ab 6b ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d09f	6f 72 61 2e 7a 78				.text "ora.zx"
.d0a5					nt_asm_ora_zxi:
>d0a5	07 0c						.byte 7, IM+NN
>d0a7	b4 d0				                .word nt_asm_pha
>d0a9	6b ab 70 ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0ad	6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0b4					nt_asm_pha:
>d0b4	03 0c						.byte 3, IM+NN
>d0b6	bf d0				                .word nt_asm_php
>d0b8	70 ab 75 ab					.word xt_asm_pha, z_asm_pha
>d0bc	70 68 61					.text "pha"
.d0bf					nt_asm_php:
>d0bf	03 0c						.byte 3, IM+NN
>d0c1	ca d0				                .word nt_asm_phx
>d0c3	75 ab 7a ab					.word xt_asm_php, z_asm_php
>d0c7	70 68 70					.text "php"
.d0ca					nt_asm_phx:
>d0ca	03 0c						.byte 3, IM+NN
>d0cc	d5 d0				                .word nt_asm_phy
>d0ce	7a ab 7f ab					.word xt_asm_phx, z_asm_phx
>d0d2	70 68 78					.text "phx"
.d0d5					nt_asm_phy:
>d0d5	03 0c						.byte 3, IM+NN
>d0d7	e0 d0				                .word nt_asm_pla
>d0d9	7f ab 84 ab					.word xt_asm_phy, z_asm_phy
>d0dd	70 68 79					.text "phy"
.d0e0					nt_asm_pla:
>d0e0	03 0c						.byte 3, IM+NN
>d0e2	eb d0				                .word nt_asm_plp
>d0e4	84 ab 89 ab					.word xt_asm_pla, z_asm_pla
>d0e8	70 6c 61					.text "pla"
.d0eb					nt_asm_plp:
>d0eb	03 0c						.byte 3, IM+NN
>d0ed	f6 d0				                .word nt_asm_plx
>d0ef	89 ab 8e ab					.word xt_asm_plp, z_asm_plp
>d0f3	70 6c 70					.text "plp"
.d0f6					nt_asm_plx:
>d0f6	03 0c						.byte 3, IM+NN
>d0f8	01 d1				                .word nt_asm_ply
>d0fa	8e ab 93 ab					.word xt_asm_plx, z_asm_plx
>d0fe	70 6c 78					.text "plx"
.d101					nt_asm_ply:
>d101	03 0c						.byte 3, IM+NN
>d103	0c d1				                .word nt_asm_rol
>d105	93 ab 98 ab					.word xt_asm_ply, z_asm_ply
>d109	70 6c 79					.text "ply"
.d10c					nt_asm_rol:
>d10c	03 0c						.byte 3, IM+NN
>d10e	17 d1				                .word nt_asm_rol_a
>d110	98 ab 9d ab					.word xt_asm_rol, z_asm_rol
>d114	72 6f 6c					.text "rol"
.d117					nt_asm_rol_a:
>d117	05 0c						.byte 5, IM+NN
>d119	24 d1				                .word nt_asm_rol_x
>d11b	9d ab a2 ab					.word xt_asm_rol_a, z_asm_rol_a
>d11f	72 6f 6c 2e 61					.text "rol.a"
.d124					nt_asm_rol_x:
>d124	05 0c						.byte 5, IM+NN
>d126	31 d1				                .word nt_asm_rol_z
>d128	a2 ab a7 ab					.word xt_asm_rol_x, z_asm_rol_x
>d12c	72 6f 6c 2e 78					.text "rol.x"
.d131					nt_asm_rol_z:
>d131	05 0c						.byte 5, IM+NN
>d133	3e d1				                .word nt_asm_rol_zx
>d135	a7 ab ac ab					.word xt_asm_rol_z, z_asm_rol_z
>d139	72 6f 6c 2e 7a					.text "rol.z"
.d13e					nt_asm_rol_zx:
>d13e	06 0c						.byte 6, IM+NN
>d140	4c d1				                .word nt_asm_ror
>d142	ac ab b1 ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d146	72 6f 6c 2e 7a 78				.text "rol.zx"
.d14c					nt_asm_ror:
>d14c	03 0c						.byte 3, IM+NN
>d14e	57 d1				                .word nt_asm_ror_a
>d150	b1 ab b6 ab					.word xt_asm_ror, z_asm_ror
>d154	72 6f 72					.text "ror"
.d157					nt_asm_ror_a:
>d157	05 0c						.byte 5, IM+NN
>d159	64 d1				                .word nt_asm_ror_x
>d15b	b6 ab bb ab					.word xt_asm_ror_a, z_asm_ror_a
>d15f	72 6f 72 2e 61					.text "ror.a"
.d164					nt_asm_ror_x:
>d164	05 0c						.byte 5, IM+NN
>d166	71 d1				                .word nt_asm_ror_z
>d168	bb ab c0 ab					.word xt_asm_ror_x, z_asm_ror_x
>d16c	72 6f 72 2e 78					.text "ror.x"
.d171					nt_asm_ror_z:
>d171	05 0c						.byte 5, IM+NN
>d173	7e d1				                .word nt_asm_ror_zx
>d175	c0 ab c5 ab					.word xt_asm_ror_z, z_asm_ror_z
>d179	72 6f 72 2e 7a					.text "ror.z"
.d17e					nt_asm_ror_zx:
>d17e	06 0c						.byte 6, IM+NN
>d180	8c d1				                .word nt_asm_rti
>d182	c5 ab ca ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d186	72 6f 72 2e 7a 78				.text "ror.zx"
.d18c					nt_asm_rti:
>d18c	03 0c						.byte 3, IM+NN
>d18e	97 d1				                .word nt_asm_rts
>d190	ca ab cf ab					.word xt_asm_rti, z_asm_rti
>d194	72 74 69					.text "rti"
.d197					nt_asm_rts:
>d197	03 0c						.byte 3, IM+NN
>d199	a2 d1				                .word nt_asm_sbc
>d19b	cf ab d4 ab					.word xt_asm_rts, z_asm_rts
>d19f	72 74 73					.text "rts"
.d1a2					nt_asm_sbc:
>d1a2	03 0c						.byte 3, IM+NN
>d1a4	ad d1				                .word nt_asm_sbc_h
>d1a6	d4 ab d9 ab					.word xt_asm_sbc, z_asm_sbc
>d1aa	73 62 63					.text "sbc"
.d1ad					nt_asm_sbc_h:
>d1ad	05 0c						.byte 5, IM+NN
>d1af	ba d1				                .word nt_asm_sbc_x
>d1b1	d9 ab de ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d1b5	73 62 63 2e 23					.text "sbc.#"
.d1ba					nt_asm_sbc_x:
>d1ba	05 0c						.byte 5, IM+NN
>d1bc	c7 d1				                .word nt_asm_sbc_y
>d1be	de ab e3 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d1c2	73 62 63 2e 78					.text "sbc.x"
.d1c7					nt_asm_sbc_y:
>d1c7	05 0c						.byte 5, IM+NN
>d1c9	d4 d1				                .word nt_asm_sbc_z
>d1cb	e3 ab e8 ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d1cf	73 62 63 2e 79					.text "sbc.y"
.d1d4					nt_asm_sbc_z:
>d1d4	05 0c						.byte 5, IM+NN
>d1d6	e1 d1				                .word nt_asm_sbc_zi
>d1d8	e8 ab ed ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d1dc	73 62 63 2e 7a					.text "sbc.z"
.d1e1					nt_asm_sbc_zi:
>d1e1	06 0c						.byte 6, IM+NN
>d1e3	ef d1				                .word nt_asm_sbc_ziy
>d1e5	ed ab f2 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d1e9	73 62 63 2e 7a 69				.text "sbc.zi"
.d1ef					nt_asm_sbc_ziy:
>d1ef	07 0c						.byte 7, IM+NN
>d1f1	fe d1				                .word nt_asm_sbc_zx
>d1f3	f2 ab f7 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d1f7	73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d1fe					nt_asm_sbc_zx:
>d1fe	06 0c						.byte 6, IM+NN
>d200	0c d2				                .word nt_asm_sbc_zxi
>d202	f7 ab fc ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d206	73 62 63 2e 7a 78				.text "sbc.zx"
.d20c					nt_asm_sbc_zxi:
>d20c	07 0c						.byte 7, IM+NN
>d20e	1b d2				                .word nt_asm_sec
>d210	fc ab 00 ac					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d214	73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d21b					nt_asm_sec:
>d21b	03 0c						.byte 3, IM+NN
>d21d	26 d2				                .word nt_asm_sed
>d21f	00 ac 04 ac					.word xt_asm_sec, z_asm_sec
>d223	73 65 63					.text "sec"
.d226					nt_asm_sed:
>d226	03 0c						.byte 3, IM+NN
>d228	31 d2				                .word nt_asm_sei
>d22a	04 ac 08 ac					.word xt_asm_sed, z_asm_sed
>d22e	73 65 64					.text "sed"
.d231					nt_asm_sei:
>d231	03 0c						.byte 3, IM+NN
>d233	3c d2				                .word nt_asm_sta
>d235	08 ac 0c ac					.word xt_asm_sei, z_asm_sei
>d239	73 65 69					.text "sei"
.d23c					nt_asm_sta:
>d23c	03 0c						.byte 3, IM+NN
>d23e	47 d2				                .word nt_asm_sta_x
>d240	0c ac 10 ac					.word xt_asm_sta, z_asm_sta
>d244	73 74 61					.text "sta"
.d247					nt_asm_sta_x:
>d247	05 0c						.byte 5, IM+NN
>d249	54 d2				                .word nt_asm_sta_y
>d24b	10 ac 14 ac					.word xt_asm_sta_x, z_asm_sta_x
>d24f	73 74 61 2e 78					.text "sta.x"
.d254					nt_asm_sta_y:
>d254	05 0c						.byte 5, IM+NN
>d256	61 d2				                .word nt_asm_sta_z
>d258	14 ac 18 ac					.word xt_asm_sta_y, z_asm_sta_y
>d25c	73 74 61 2e 79					.text "sta.y"
.d261					nt_asm_sta_z:
>d261	05 0c						.byte 5, IM+NN
>d263	6e d2				                .word nt_asm_sta_zi
>d265	18 ac 1c ac					.word xt_asm_sta_z, z_asm_sta_z
>d269	73 74 61 2e 7a					.text "sta.z"
.d26e					nt_asm_sta_zi:
>d26e	06 0c						.byte 6, IM+NN
>d270	7c d2				                .word nt_asm_sta_ziy
>d272	1c ac 20 ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d276	73 74 61 2e 7a 69				.text "sta.zi"
.d27c					nt_asm_sta_ziy:
>d27c	07 0c						.byte 7, IM+NN
>d27e	8b d2				                .word nt_asm_sta_zx
>d280	20 ac 24 ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d284	73 74 61 2e 7a 69 79				.text "sta.ziy"
.d28b					nt_asm_sta_zx:
>d28b	06 0c						.byte 6, IM+NN
>d28d	99 d2				                .word nt_asm_sta_zxi
>d28f	24 ac 28 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d293	73 74 61 2e 7a 78				.text "sta.zx"
.d299					nt_asm_sta_zxi:
>d299	07 0c						.byte 7, IM+NN
>d29b	a8 d2				                .word nt_asm_stx
>d29d	28 ac 2c ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2a1	73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2a8					nt_asm_stx:
>d2a8	03 0c						.byte 3, IM+NN
>d2aa	b3 d2				                .word nt_asm_stx_z
>d2ac	2c ac 30 ac					.word xt_asm_stx, z_asm_stx
>d2b0	73 74 78					.text "stx"
.d2b3					nt_asm_stx_z:
>d2b3	05 0c						.byte 5, IM+NN
>d2b5	c0 d2				                .word nt_asm_stx_zy
>d2b7	30 ac 34 ac					.word xt_asm_stx_z, z_asm_stx_z
>d2bb	73 74 78 2e 7a					.text "stx.z"
.d2c0					nt_asm_stx_zy:
>d2c0	06 0c						.byte 6, IM+NN
>d2c2	ce d2				                .word nt_asm_sty
>d2c4	34 ac 38 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d2c8	73 74 78 2e 7a 79				.text "stx.zy"
.d2ce					nt_asm_sty:
>d2ce	03 0c						.byte 3, IM+NN
>d2d0	d9 d2				                .word nt_asm_sty_z
>d2d2	38 ac 3c ac					.word xt_asm_sty, z_asm_sty
>d2d6	73 74 79					.text "sty"
.d2d9					nt_asm_sty_z:
>d2d9	05 0c						.byte 5, IM+NN
>d2db	e6 d2				                .word nt_asm_sty_zx
>d2dd	3c ac 40 ac					.word xt_asm_sty_z, z_asm_sty_z
>d2e1	73 74 79 2e 7a					.text "sty.z"
.d2e6					nt_asm_sty_zx:
>d2e6	06 0c						.byte 6, IM+NN
>d2e8	f4 d2				                .word nt_asm_stz
>d2ea	40 ac 44 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d2ee	73 74 79 2e 7a 78				.text "sty.zx"
.d2f4					nt_asm_stz:
>d2f4	03 0c						.byte 3, IM+NN
>d2f6	ff d2				                .word nt_asm_stz_x
>d2f8	44 ac 48 ac					.word xt_asm_stz, z_asm_stz
>d2fc	73 74 7a					.text "stz"
.d2ff					nt_asm_stz_x:
>d2ff	05 0c						.byte 5, IM+NN
>d301	0c d3				                .word nt_asm_stz_z
>d303	48 ac 4c ac					.word xt_asm_stz_x, z_asm_stz_x
>d307	73 74 7a 2e 78					.text "stz.x"
.d30c					nt_asm_stz_z:
>d30c	05 0c						.byte 5, IM+NN
>d30e	19 d3				                .word nt_asm_stz_zx
>d310	4c ac 50 ac					.word xt_asm_stz_z, z_asm_stz_z
>d314	73 74 7a 2e 7a					.text "stz.z"
.d319					nt_asm_stz_zx:
>d319	06 0c						.byte 6, IM+NN
>d31b	27 d3				                .word nt_asm_tax
>d31d	50 ac 54 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d321	73 74 7a 2e 7a 78				.text "stz.zx"
.d327					nt_asm_tax:
>d327	03 0c						.byte 3, IM+NN
>d329	32 d3				                .word nt_asm_tay
>d32b	54 ac 58 ac					.word xt_asm_tax, z_asm_tax
>d32f	74 61 78					.text "tax"
.d332					nt_asm_tay:
>d332	03 0c						.byte 3, IM+NN
>d334	3d d3				                .word nt_asm_trb
>d336	58 ac 5c ac					.word xt_asm_tay, z_asm_tay
>d33a	74 61 79					.text "tay"
.d33d					nt_asm_trb:
>d33d	03 0c						.byte 3, IM+NN
>d33f	48 d3				                .word nt_asm_trb_z
>d341	5c ac 60 ac					.word xt_asm_trb, z_asm_trb
>d345	74 72 62					.text "trb"
.d348					nt_asm_trb_z:
>d348	05 0c						.byte 5, IM+NN
>d34a	55 d3				                .word nt_asm_tsb
>d34c	60 ac 64 ac					.word xt_asm_trb_z, z_asm_trb_z
>d350	74 72 62 2e 7a					.text "trb.z"
.d355					nt_asm_tsb:
>d355	03 0c						.byte 3, IM+NN
>d357	60 d3				                .word nt_asm_tsb_z
>d359	64 ac 68 ac					.word xt_asm_tsb, z_asm_tsb
>d35d	74 73 62					.text "tsb"
.d360					nt_asm_tsb_z:
>d360	05 0c						.byte 5, IM+NN
>d362	6d d3				                .word nt_asm_tsx
>d364	68 ac 6c ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d368	74 73 62 2e 7a					.text "tsb.z"
.d36d					nt_asm_tsx:
>d36d	03 0c						.byte 3, IM+NN
>d36f	78 d3				                .word nt_asm_txa
>d371	6c ac 70 ac					.word xt_asm_tsx, z_asm_tsx
>d375	74 73 78					.text "tsx"
.d378					nt_asm_txa:
>d378	03 0c						.byte 3, IM+NN
>d37a	83 d3				                .word nt_asm_txs
>d37c	70 ac 74 ac					.word xt_asm_txa, z_asm_txa
>d380	74 78 61					.text "txa"
.d383					nt_asm_txs:
>d383	03 0c						.byte 3, IM+NN
>d385	8e d3				                .word nt_asm_tya
>d387	74 ac 78 ac					.word xt_asm_txs, z_asm_txs
>d38b	74 78 73					.text "txs"
.d38e					nt_asm_tya:
>d38e	03 0c						.byte 3, IM+NN
>d390	99 d3				                .word nt_asm_arrow
>d392	78 ac 7c ac					.word xt_asm_tya, z_asm_tya
>d396	74 79 61					.text "tya"
.d399					nt_asm_arrow:
>d399	03 04				                .byte 3, IM
>d39b	a4 d3				                .word nt_asm_back_jump
>d39d	72 91 7c 91			                .word xt_asm_arrow, z_asm_arrow
>d3a1	2d 2d 3e			                .text "-->"
.d3a4					nt_asm_back_jump:
>d3a4	02 04				                .byte 2, IM
>d3a6	ae d3				                .word nt_asm_back_branch
>d3a8	cd ac cd ac			                .word xt_asm_back_jump, z_asm_back_jump
>d3ac	3c 6a				                .text "<j"
.d3ae					nt_asm_back_branch:
>d3ae	02 04				                .byte 2, IM
>d3b0	b8 d3				                .word nt_asm_push_a
>d3b2	ce ac d6 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d3b6	3c 62				                .text "<b"
.d3b8					nt_asm_push_a:
>d3b8	06 0c				                .byte 6, IM+NN
>d3ba	00 00				                .word 0000
>d3bc	b6 ac c5 ac			                .word xt_asm_push_a, z_asm_push_a
>d3c0	70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0					str_ok             =  0
=1					str_compile        =  1
=2					str_redefined      =  2
=3					str_wid_forth      =  3
=4					str_abc_lower      =  4
=5					str_abc_upper      =  5
=6					str_wid_editor     =  6
=7					str_wid_assembler  =  7
=8					str_wid_root       =  8
=9					str_see_flags      =  9
=10					str_see_nt         = 10
=11					str_see_xt         = 11
=12					str_see_size       = 12
=13					str_disasm_lit     = 13
=14					str_disasm_sdc     = 14
=15					str_disasm_bra     = 15
.d3c6					string_table:
>d3c6	e6 d3 ea d3 f4 d3 5a d4		        .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
>d3ce	ff d3
>d3d0	23 d4 52 d4 47 d4 61 d4		        .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
>d3d8	67 d4 83 d4 88 d4 8d d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
>d3e0	9e d4 a7 d4 b9 d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 13-15
>d3e6	20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d3ea	20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d3f2	64 00
>d3f4	72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d3fc	64 20 00
>d3ff	30 31 32 33 34 35 36 37		s_abc_lower:  .text "0123456789abcdefghijklmnopqrstuvwxyz"
>d407	38 39 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e
>d417	6f 70 71 72 73 74 75 76 77 78 79 7a
>d423	30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d42b	38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d43b	4f 50 51 52 53 54 55 56 57 58 59 5a
>d447	41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d44f	72 20 00
>d452	45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d45a	46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d461	52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d467	66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d46f	4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d47f	29 3a 20 00
>d483	6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d488	78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d48d	73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d495	63 69 6d 61 6c 29 3a 20 00
>d49e	4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d4a6	00
>d4a7	53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d4af	50 54 48 20 43 48 45 43 4b 00
>d4b9	42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0					err_allot        = 0
=1					err_badsource    = 1
=2					err_compileonly  = 2
=3					err_defer        = 3
=4					err_divzero      = 4
=5					err_noname       = 5
=6					err_refill       = 6
=7					err_state        = 7
=8					err_syntax       = 8
=9					err_underflow    = 9
=10					err_negallot     = 10
=11					err_wordlist     = 11
=12					err_blockwords   = 12
=13					err_returnstack  = 13
.d4c1					error_table:
>d4c1	dd d4 fe d4 1e d5 3f d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4c9	5c d5 6d d5 7d d5 ab d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4d1	c3 d5 d2 d5 e7 d5 03 d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4d9	1a d6 59 d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d4dd	41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4e5	69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d4f5	65 20 6d 65 6d 6f 72 79 00
>d4fe	49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d506	53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d516	20 52 45 46 49 4c 4c 00
>d51e	49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d526	74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d536	6e 6c 79 20 77 6f 72 64 00
>d53f	44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d547	77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d557	20 79 65 74 00
>d55c	44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d564	20 62 79 20 7a 65 72 6f 00
>d56d	50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d575	66 61 69 6c 75 72 65 00
>d57d	51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d585	6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d595	20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d5a5	64 20 2d 31 29 00
>d5ab	41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5b3	69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5c3	55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word", 0
>d5cb	64 20 77 6f 72 64 00
>d5d2	44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d5da	63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d5e7	4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d5ef	72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d5ff	4c 4f 54 00
>d603	4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d60b	69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d61a	50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d622	73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d632	4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d642	61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d652	56 45 43 54 4f 52 00
>d659	52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d661	74 61 63 6b 3a 00
>d667	0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d66f	44 2d 53 54 52 49 4e 47
>d677	05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d67d	04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d682	11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d68a	2d 55 4e 49 54 2d 42 49 54 53
>d694	07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d69c	08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6a4	52
>d6a5	05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6ab	05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6b1	12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6b9	53 54 41 43 4b 2d 43 45 4c 4c 53
>d6c4	0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6cc	45 4c 4c 53
>d6d0	09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d6d8	54 53
>d6da	05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d6e0	06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d6e7					cmpl_subroutine:
.d6e7	48		pha		                pha             ; save LSB of address
.d6e8	a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d6ea	80 03		bra $d6ef	                bra cmpl_common
.d6ec					cmpl_jump:
.d6ec	48		pha		                pha             ; save LSB of address
.d6ed	a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d6ef					cmpl_common:
.d6ef	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; compile opcode
.d6f2	68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d6f3					cmpl_word:
.d6f3	20 f7 d6	jsr $d6f7	                jsr cmpl_a      ; compile LSB of address
.d6f6	98		tya		                tya             ; fall thru for MSB
.d6f7					cmpl_a:
.d6f7	92 00		sta ($00)	                sta (cp)
.d6f9	e6 00		inc $00		                inc cp
.d6fb	d0 02		bne $d6ff	                bne _done
.d6fd	e6 01		inc $01		                inc cp+1
.d6ff					_done:
.d6ff	60		rts		                rts
.d700					doconst:
.d700	ca		dex		                dex             ; make room for constant
.d701	ca		dex		                dex
.d702	68		pla		                pla             ; LSB of return address
.d703	85 24		sta $24		                sta tmp1
.d705	68		pla		                pla             ; MSB of return address
.d706	85 25		sta $25		                sta tmp1+1
.d708	a0 01		ldy #$01	                ldy #1
.d70a	b1 24		lda ($24),y	                lda (tmp1),y
.d70c	95 00		sta $00,x	                sta 0,x
.d70e	c8		iny		                iny
.d70f	b1 24		lda ($24),y	                lda (tmp1),y
.d711	95 01		sta $01,x	                sta 1,x
.d713	60		rts		                rts
.d714					dodefer:
.d714	68		pla		                pla             ; LSB
.d715	85 24		sta $24		                sta tmp1
.d717	68		pla		                pla             ; MSB
.d718	85 25		sta $25		                sta tmp1+1
.d71a	a0 01		ldy #$01	                ldy #1
.d71c	b1 24		lda ($24),y	                lda (tmp1),y
.d71e	85 26		sta $26		                sta tmp2
.d720	c8		iny		                iny
.d721	b1 24		lda ($24),y	                lda (tmp1),y
.d723	85 27		sta $27		                sta tmp2+1
.d725	6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d728					defer_error:
.d728	a9 03		lda #$03	                lda #err_defer
.d72a	4c 5a d8	jmp $d85a	                jmp error
.d72d					dodoes:
.d72d	7a		ply		                ply             ; LSB
.d72e	68		pla		                pla             ; MSB
.d72f	c8		iny		                iny
.d730	d0 01		bne $d733	                bne +
.d732	1a		inc a		                ina
.d733					+
.d733	84 26		sty $26		                sty tmp2
.d735	85 27		sta $27		                sta tmp2+1
.d737	ca		dex		                dex
.d738	ca		dex		                dex
.d739	7a		ply		                ply
.d73a	68		pla		                pla
.d73b	c8		iny		                iny
.d73c	d0 01		bne $d73f	                bne +
.d73e	1a		inc a		                ina
.d73f					+
.d73f	94 00		sty $00,x	                sty 0,x         ; LSB
.d741	95 01		sta $01,x	                sta 1,x         ; MSB
.d743	6c 26 00	jmp ($0026)	                jmp (tmp2)
.d746					dovar:
.d746	7a		ply		                ply             ; LSB
.d747	68		pla		                pla             ; MSB
.d748	c8		iny		                iny
.d749	d0 01		bne $d74c	                bne +
.d74b	1a		inc a		                ina
.d74c					+
.d74c	ca		dex		                dex
.d74d	ca		dex		                dex
.d74e	95 01		sta $01,x	                sta 1,x
.d750	98		tya		                tya
.d751	95 00		sta $00,x	                sta 0,x
.d753	60		rts		                rts
.d754					byte_to_ascii:
.d754	48		pha		                pha
.d755	4a		lsr a		                lsr             ; convert high nibble first
.d756	4a		lsr a		                lsr
.d757	4a		lsr a		                lsr
.d758	4a		lsr a		                lsr
.d759	20 5d d7	jsr $d75d	                jsr _nibble_to_ascii
.d75c	68		pla		                pla
.d75d					_nibble_to_ascii:
.d75d	29 0f		and #$0f	                and #$0F
.d75f	09 30		ora #$30	                ora #'0'
.d761	c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d763	90 02		bcc $d767	                bcc +
.d765	69 06		adc #$06	                adc #$06
.d767	4c f6 8d	jmp $8df6	+               jmp emit_a
.d76a	60		rts		                rts
.d76b					compare_16bit:
.d76b	b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d76d	d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d76f	f0 0a		beq $d77b	                beq _equal
.d771	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d773	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d775	09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d777	70 08		bvs $d781	                bvs _overflow
.d779	80 08		bra $d783	                bra _not_equal
.d77b					_equal:
.d77b	b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d77d	f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d77f	50 04		bvc $d785	                bvc _done
.d781					_overflow:
.d781	49 80		eor #$80	                eor #$80                ; complement negative flag
.d783					_not_equal:
.d783	09 01		ora #$01	                ora #1                  ; if overflow, we can't be eqal
.d785					_done:
.d785	60		rts		                rts
.d786					current_to_dp:
.d786	a0 04		ldy #$04	                ldy #current_offset
.d788	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d78a	0a		asl a		                asl             ; turn it into an offset (in cells)
.d78b	18		clc		                clc
.d78c	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d78e	a8		tay		                tay
.d78f	b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d791	85 02		sta $02		                sta dp
.d793	c8		iny		                iny
.d794	b1 1e		lda ($1e),y	                lda (up),y
.d796	85 03		sta $03		                sta dp+1
.d798	60		rts		                rts
.d799					dp_to_current:
.d799	a0 04		ldy #$04	                ldy #current_offset
.d79b	b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d79d	0a		asl a		                asl             ; turn it into an offset (in cells)
.d79e	18		clc		                clc
.d79f	69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7a1	a8		tay		                tay
.d7a2	a5 02		lda $02		                lda dp
.d7a4	91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d7a6	c8		iny		                iny
.d7a7	a5 03		lda $03		                lda dp+1
.d7a9	91 1e		sta ($1e),y	                sta (up),y
.d7ab	60		rts		                rts
.d7ac					interpret:
.d7ac					_loop:
.d7ac	20 df 98	jsr $98df	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7af	b5 00		lda $00,x	                lda 0,x
.d7b1	15 01		ora $01,x	                ora 1,x
.d7b3	f0 70		beq $d825	                beq _line_done
.d7b5	20 b8 a3	jsr $a3b8	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7b8	20 db 8f	jsr $8fdb	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7bb	b5 00		lda $00,x	                lda 0,x
.d7bd	15 01		ora $01,x	                ora 1,x
.d7bf	d0 28		bne $d7e9	                bne _got_name_token
.d7c1	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7c2	e8		inx		                inx
.d7c3	20 8a 96	jsr $968a	                jsr xt_number           ; ( addr u -- u|d )
.d7c6	a5 16		lda $16		                lda state
.d7c8	f0 e2		beq $d7ac	                beq _loop
.d7ca	a9 20		lda #$20	                lda #$20
.d7cc	24 20		bit $20		                bit status
.d7ce	f0 0d		beq $d7dd	                beq _single_number
.d7d0	20 ae a1	jsr $a1ae	                jsr xt_swap
.d7d3	a0 93		ldy #$93	                ldy #>literal_runtime
.d7d5	a9 98		lda #$98	                lda #<literal_runtime
.d7d7	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.d7da	20 6e 87	jsr $876e	                jsr xt_comma
.d7dd					_single_number:
.d7dd	a0 93		ldy #$93	                ldy #>literal_runtime
.d7df	a9 98		lda #$98	                lda #<literal_runtime
.d7e1	20 e7 d6	jsr $d6e7	                jsr cmpl_subroutine
.d7e4	20 6e 87	jsr $876e	                jsr xt_comma
.d7e7	80 c3		bra $d7ac	                bra _loop
.d7e9					_got_name_token:
.d7e9	b5 00		lda $00,x	                lda 0,x
.d7eb	95 04		sta $04,x	                sta 4,x
.d7ed	b5 01		lda $01,x	                lda 1,x
.d7ef	95 05		sta $05,x	                sta 5,x
.d7f1	e8		inx		                inx
.d7f2	e8		inx		                inx
.d7f3	e8		inx		                inx
.d7f4	e8		inx		                inx                     ; ( nt )
.d7f5	b5 00		lda $00,x	                lda 0,x
.d7f7	85 22		sta $22		                sta tmpbranch
.d7f9	b5 01		lda $01,x	                lda 1,x
.d7fb	85 23		sta $23		                sta tmpbranch+1
.d7fd	20 e1 95	jsr $95e1	                jsr xt_name_to_int      ; ( nt - xt )
.d800	a5 16		lda $16		                lda state
.d802	d0 13		bne $d817	                bne _compile
.d804	a0 01		ldy #$01	                ldy #1
.d806	b1 22		lda ($22),y	                lda (tmpbranch),y
.d808	29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d80a	f0 05		beq $d811	                beq _interpret
.d80c	a9 02		lda #$02	                lda #err_compileonly
.d80e	4c 5a d8	jmp $d85a	                jmp error
.d811					_interpret:
.d811	20 3d 8f	jsr $8f3d	                jsr xt_execute
.d814	4c ac d7	jmp $d7ac	                jmp _loop
.d817					_compile:
.d817	a0 01		ldy #$01	                ldy #1
.d819	b1 22		lda ($22),y	                lda (tmpbranch),y
.d81b	29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d81d	d0 f2		bne $d811	                bne _interpret          ; IMMEDIATE word, execute right now
.d81f	20 ed 87	jsr $87ed	                jsr xt_compile_comma
.d822	4c ac d7	jmp $d7ac	                jmp _loop
.d825					_line_done:
.d825	e8		inx		                inx
.d826	e8		inx		                inx
.d827	e8		inx		                inx
.d828	e8		inx		                inx
.d829	60		rts		                rts
.d82a					is_printable:
.d82a	c9 20		cmp #$20	                cmp #AscSP              ; $20
.d82c	90 08		bcc $d836	                bcc _done
.d82e	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d830	b0 03		bcs $d835	                bcs _failed
.d832	38		sec		                sec
.d833	80 01		bra $d836	                bra _done
.d835					_failed:
.d835	18		clc		                clc
.d836					_done:
.d836	60		rts		                rts
.d837					is_whitespace:
.d837	c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d839	90 08		bcc $d843	                bcc _done
.d83b	c9 21		cmp #$21	                cmp #AscSP+1
.d83d	b0 03		bcs $d842	                bcs _failed
.d83f	38		sec		                sec
.d840	80 01		bra $d843	                bra _done
.d842					_failed:
.d842	18		clc		                clc
.d843					_done:
.d843	60		rts		                rts
.d844					underflow_1:
.d844	e0 77		cpx #$77	                cpx #dsp0-1
.d846	10 10		bpl $d858	                bpl underflow_error
.d848	60		rts		                rts
.d849					underflow_2:
.d849	e0 75		cpx #$75	                cpx #dsp0-3
.d84b	10 0b		bpl $d858	                bpl underflow_error
.d84d	60		rts		                rts
.d84e					underflow_3:
.d84e	e0 73		cpx #$73	                cpx #dsp0-5
.d850	10 06		bpl $d858	                bpl underflow_error
.d852	60		rts		                rts
.d853					underflow_4:
.d853	e0 71		cpx #$71	                cpx #dsp0-7
.d855	10 01		bpl $d858	                bpl underflow_error
.d857	60		rts		                rts
.d858					underflow_error:
.d858	a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d85a					error:
.d85a	48		pha		                pha                     ; save error
.d85b	20 9a d8	jsr $d89a	                jsr print_error
.d85e	20 63 89	jsr $8963	                jsr xt_cr
.d861	68		pla		                pla
.d862	c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d864	d0 17		bne $d87d	                bne _no_underflow
.d866	a9 0d		lda #$0d	                lda #err_returnstack
.d868	20 9a d8	jsr $d89a	                jsr print_error
.d86b	ba		tsx		                tsx
.d86c					-
.d86c	e8		inx		                inx
.d86d	f0 0b		beq $d87a	                beq +
.d86f	20 1e a1	jsr $a11e	                jsr xt_space
.d872	bd 00 01	lda $0100,x	                lda $100,x
.d875	20 54 d7	jsr $d754	                jsr byte_to_ascii
.d878	80 f2		bra $d86c	                bra -
.d87a					+
.d87a	20 63 89	jsr $8963	                jsr xt_cr
.d87d					_no_underflow:
.d87d	4c 81 80	jmp $8081	                jmp xt_abort            ; no jsr, as we clobber return stack
.d880					print_string_no_lf:
.d880	0a		asl a		                asl
.d881	a8		tay		                tay
.d882	b9 c6 d3	lda $d3c6,y	                lda string_table,y
.d885	85 28		sta $28		                sta tmp3                ; LSB
.d887	c8		iny		                iny
.d888	b9 c6 d3	lda $d3c6,y	                lda string_table,y
.d88b	85 29		sta $29		                sta tmp3+1              ; MSB
.d88d					print_common:
.d88d	a0 00		ldy #$00	                ldy #0
.d88f					_loop:
.d88f	b1 28		lda ($28),y	                lda (tmp3),y
.d891	f0 06		beq $d899	                beq _done               ; strings are zero-terminated
.d893	20 f6 8d	jsr $8df6	                jsr emit_a              ; allows vectoring via output
.d896	c8		iny		                iny
.d897	80 f6		bra $d88f	                bra _loop
.d899					_done:
.d899	60		rts		                rts
.d89a					print_error:
.d89a	0a		asl a		                asl
.d89b	a8		tay		                tay
.d89c	b9 c1 d4	lda $d4c1,y	                lda error_table,y
.d89f	85 28		sta $28		                sta tmp3                ; LSB
.d8a1	c8		iny		                iny
.d8a2	b9 c1 d4	lda $d4c1,y	                lda error_table,y
.d8a5	85 29		sta $29		                sta tmp3+1              ; MSB
.d8a7	20 8d d8	jsr $d88d	                jsr print_common
.d8aa	60		rts		                rts
.d8ab					print_string:
.d8ab	20 80 d8	jsr $d880	                jsr print_string_no_lf
.d8ae	4c 63 89	jmp $8963	                jmp xt_cr               ; JSR/RTS because never compiled
.d8b1					print_u:
.d8b1	20 a8 a7	jsr $a7a8	                jsr xt_zero                     ; 0
.d8b4	20 5a 93	jsr $935a	                jsr xt_less_number_sign         ; <#
.d8b7	20 de 97	jsr $97de	                jsr xt_number_sign_s            ; #S
.d8ba	20 bc 97	jsr $97bc	                jsr xt_number_sign_greater      ; #>
.d8bd	4c 03 a5	jmp $a503	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010					v_nmi:
.f010					v_reset:
.f010					v_irq:
.f010					kernel_init:
.f010	78		sei		                sei             ; Disable interrupts
.f011	a2 00		ldx #$00	                ldx #0
.f013	bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016	f0 06		beq $f01e	                beq _done
.f018	20 27 f0	jsr $f027	                jsr kernel_putc
.f01b	e8		inx		                inx
.f01c	80 f5		bra $f013	                bra -
.f01e					_done:
.f01e	4c 00 80	jmp $8000	                jmp forth
.f021					kernel_getc:
.f021					_loop:
.f021	ad 04 f0	lda $f004	                lda $f004
.f024	f0 fb		beq $f021	                beq _loop
.f026	60		rts		                rts
.f027					kernel_putc:
.f027	8d 01 f0	sta $f001	                sta $f001
.f02a	60		rts		                rts
.f02b					platform_bye:
.f02b	00		brk #		                brk
.f02c					s_kernel_id:
>f02c	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034	74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044	6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054	28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa	10 f0				.word v_nmi
>fffc	10 f0				.word v_reset
>fffe	10 f0				.word v_irq

;******  End of listing
