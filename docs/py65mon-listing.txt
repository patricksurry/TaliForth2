
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Tue Mar 26 21:05:02 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0000						ram_start = $0000          ; start of installed 32 KiB of RAM
=32767						ram_end   = $8000-1        ; end of installed RAM
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=512						buffer0   = stack0+$100      ; input buffer ($0200-$027f)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../native_words.asm

.8000						xt_cold:
.8000		d8		cld		                cld
.8001		a9 27		lda #$27	                lda #<kernel_putc
.8003		85 10		sta $10		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 11		sta $11		                sta output+1
.8009		a2 21		ldx #$21	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd cb a8	lda $a8cb,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad cb a8	lda $a8cb	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 31		ldy #$31	                ldy #cold_user_table_end-cold_user_table-1
.801f		a9 00		lda #$00	                lda #0
.8021						_load_user_vars_loop:
.8021		b9 ed a8	lda $a8ed,y	                lda cold_user_table,y
.8024		91 1e		sta ($1e),y	                sta (up),y
.8026		88		dey		                dey
.8027		d0 f8		bne $8021	                bne _load_user_vars_loop
.8029		ad ed a8	lda $a8ed	                lda cold_user_table
.802c		92 1e		sta ($1e)	                sta (up)
.802e		20 2a 89	jsr $892a	                jsr xt_cr
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		ca		dex		                dex
.8034		ca		dex		                dex
.8035		a9 b0		lda #$b0	                lda #<forth_words_start
.8037		95 02		sta $02,x	                sta 2,x
.8039		a9 bb		lda #$bb	                lda #>forth_words_start
.803b		95 03		sta $03,x	                sta 3,x
.803d		a9 d3		lda #$d3	                lda #<(user_words_end-forth_words_start)
.803f		95 00		sta $00,x	                sta 0,x
.8041		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8043		95 01		sta $01,x	                sta 1,x
.8045		20 ba 90	jsr $90ba	                jsr xt_evaluate
.8048		9c 00 7c	stz $7c00	                stz hist_buff
.804b		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804e		9c 00 7d	stz $7d00	                stz hist_buff+$100
.8051		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8054		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8057		9c 80 7e	stz $7e80	                stz hist_buff+$280
.805a		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805d		9c 80 7f	stz $7f80	                stz hist_buff+$380
.8060						xt_abort:
.8060		a2 78		ldx #$78	                ldx #dsp0
.8062						xt_quit:
.8062		8a		txa		                txa             ; Save the DSP that we just defined
.8063		a2 ff		ldx #$ff	                ldx #rsp0
.8065		9a		txs		                txs
.8066		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8067		64 0e		stz $0e		                stz ip
.8069		64 0f		stz $0f		                stz ip+1
.806b		64 06		stz $06		                stz insrc
.806d		64 07		stz $07		                stz insrc+1
.806f		a9 00		lda #$00	                lda #0
.8071		a0 00		ldy #$00	                ldy #blk_offset
.8073		91 1e		sta ($1e),y	                sta (up),y
.8075		c8		iny		                iny
.8076		91 1e		sta ($1e),y	                sta (up),y
.8078		64 16		stz $16		                stz state
.807a		64 17		stz $17		                stz state+1
.807c						_get_line:
.807c		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.807e		85 08		sta $08		                sta cib
.8080		a9 02		lda #$02	                lda #>buffer0
.8082		85 09		sta $09		                sta cib+1
.8084		64 0a		stz $0a		                stz ciblen
.8086		64 0b		stz $0b		                stz ciblen+1
.8088		20 dc 9a	jsr $9adc	                jsr xt_refill           ; ( -- f )
.808b		b5 00		lda $00,x	                lda 0,x
.808d		d0 05		bne $8094	                bne _success
.808f		a9 06		lda #$06	                lda #err_refill
.8091		4c 85 d8	jmp $d885	                jmp error
.8094						_success:
.8094		e8		inx		                inx                     ; drop
.8095		e8		inx		                inx
.8096		20 d7 d7	jsr $d7d7	                jsr interpret
.8099		e0 78		cpx #$78	                cpx #dsp0
.809b		f0 05		beq $80a2	                beq _stack_ok
.809d		90 03		bcc $80a2	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.809f		4c 83 d8	jmp $d883	                jmp underflow_error
.80a2						_stack_ok:
.80a2		a5 16		lda $16		                lda state
.80a4		f0 02		beq $80a8	                beq _print
.80a6		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80a8						_print:
.80a8		20 d6 d8	jsr $d8d6	                jsr print_string
.80ab		80 cf		bra $807c	                bra _get_line
.80ad						z_cold:
.80ad						z_abort:
.80ad						z_quit:
.80ad						xt_abort_quote:
.80ad		20 2c 9d	jsr $9d2c	                jsr xt_s_quote          ; S"
.80b0		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b2		a9 b8		lda #$b8	                lda #<abort_quote_runtime
.80b4		20 12 d7	jsr $d712	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b7		60		rts		z_abort_quote:  rts
.80b8						abort_quote_runtime:
.80b8		b5 04		lda $04,x	                lda 4,x
.80ba		15 05		ora $05,x	                ora 5,x
.80bc		f0 09		beq $80c7	                beq _done       ; if FALSE, we're done
.80be		20 a7 a4	jsr $a4a7	                jsr xt_type
.80c1		20 2a 89	jsr $892a	                jsr xt_cr
.80c4		4c 60 80	jmp $8060	                jmp xt_abort    ; not JSR, so never come back
.80c7						_done:
.80c7		8a		txa		                txa
.80c8		18		clc		                clc
.80c9		69 06		adc #$06	                adc #6
.80cb		aa		tax		                tax
.80cc		60		rts		                rts
.80cd						xt_abs:
.80cd		20 6f d8	jsr $d86f	                jsr underflow_1
.80d0		b5 01		lda $01,x	                lda 1,x
.80d2		10 0d		bpl $80e1	                bpl _done       ; positive number, easy money!
.80d4		38		sec		                sec
.80d5		a9 00		lda #$00	                lda #0
.80d7		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80d9		95 00		sta $00,x	                sta 0,x
.80db		a9 00		lda #$00	                lda #0          ; MSB
.80dd		f5 01		sbc $01,x	                sbc 1,x
.80df		95 01		sta $01,x	                sta 1,x
.80e1						_done:
.80e1		60		rts		z_abs:          rts
.80e2						xt_accept:
.80e2		20 74 d8	jsr $d874	                jsr underflow_2
.80e5		b5 00		lda $00,x	                lda 0,x
.80e7		15 01		ora $01,x	                ora 1,x
.80e9		d0 09		bne $80f4	                bne _not_zero
.80eb		e8		inx		                inx
.80ec		e8		inx		                inx
.80ed		74 00		stz $00,x	                stz 0,x
.80ef		74 01		stz $01,x	                stz 1,x
.80f1		4c c0 81	jmp $81c0	                jmp accept_done
.80f4						_not_zero:
.80f4		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f6		85 26		sta $26		                sta tmp2
.80f8		64 27		stz $27		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fa		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fc		85 24		sta $24		                sta tmp1
.80fe		b5 03		lda $03,x	                lda 3,x
.8100		85 25		sta $25		                sta tmp1+1
.8102		e8		inx		                inx
.8103		e8		inx		                inx
.8104		a0 00		ldy #$00	                ldy #0
.8106		a5 20		lda $20		                lda status
.8108		29 f7		and #$f7	                and #$f7
.810a		1a		inc a		               ina
.810b		09 08		ora #$08	                ora #$08
.810d		85 20		sta $20		                sta status
.810f						accept_loop:
.810f		20 19 93	jsr $9319	                jsr key_a
.8112		c9 0a		cmp #$0a	                cmp #AscLF
.8114		f0 20		beq $8136	                beq _eol
.8116		c9 0d		cmp #$0d	                cmp #AscCR
.8118		f0 1c		beq $8136	                beq _eol
.811a		c9 08		cmp #$08	                cmp #AscBS
.811c		f0 22		beq $8140	                beq _backspace
.811e		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8120		f0 1e		beq $8140	                beq _backspace
.8122		c9 10		cmp #$10	                cmp #AscCP
.8124		f0 36		beq $815c	                beq _ctrl_p
.8126		c9 0e		cmp #$0e	                cmp #AscCN
.8128		f0 44		beq $816e	                beq _ctrl_n
.812a		91 24		sta ($24),y	                sta (tmp1),y
.812c		c8		iny		                iny
.812d		20 db 8d	jsr $8ddb	                jsr emit_a
.8130		c4 26		cpy $26		                cpy tmp2        ; reached character limit?
.8132		d0 db		bne $810f	                bne accept_loop       ; fall through if buffer limit reached
.8134		80 03		bra $8139	                bra _buffer_full
.8136						_eol:
.8136		20 cc a0	jsr $a0cc	                jsr xt_space    ; print final space
.8139						_buffer_full:
.8139		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813b		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813d		4c c0 81	jmp $81c0	                jmp accept_done
.8140						_backspace:
.8140		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8142		d0 06		bne $814a	                bne +
.8144		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8146		20 db 8d	jsr $8ddb	                jsr emit_a
.8149		c8		iny		                iny
.814a						+
.814a		88		dey		                dey
.814b		a9 08		lda #$08	                lda #AscBS      ; move back one
.814d		20 db 8d	jsr $8ddb	                jsr emit_a
.8150		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8152		20 db 8d	jsr $8ddb	                jsr emit_a
.8155		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8157		20 db 8d	jsr $8ddb	                jsr emit_a
.815a		80 b3		bra $810f	                bra accept_loop
.815c						_ctrl_p:
.815c		a5 20		lda $20		                lda status
.815e		29 07		and #$07	                and #7
.8160		d0 08		bne $816a	                bne _ctrl_p_dec
.8162		a5 20		lda $20		                lda status
.8164		09 07		ora #$07	                ora #7
.8166		85 20		sta $20		                sta status
.8168		80 11		bra $817b	                bra _recall_history
.816a						_ctrl_p_dec:
.816a		c6 20		dec $20		                dec status
.816c		80 0d		bra $817b	                bra _recall_history
.816e						_ctrl_n:
.816e		a9 08		lda #$08	                lda #$8
.8170		24 20		bit $20		                bit status
.8172		d0 07		bne $817b	                bne _recall_history
.8174		a5 20		lda $20		                lda status
.8176		29 f7		and #$f7	                and #$f7
.8178		1a		inc a		               ina
.8179		85 20		sta $20		                sta status
.817b						_recall_history:
.817b		a9 08		lda #$08	                lda #%00001000
.817d		14 20		trb $20		                trb status
.817f		20 db 81	jsr $81db	                jsr accept_total_recall
.8182		a9 0d		lda #$0d	                lda #AscCR
.8184		20 db 8d	jsr $8ddb	                jsr emit_a
.8187						input_clear:
.8187		c0 00		cpy #$00	                cpy #0
.8189		f0 08		beq $8193	                beq input_cleared
.818b		a9 20		lda #$20	                lda #AscSP
.818d		20 db 8d	jsr $8ddb	                jsr emit_a
.8190		88		dey		                dey
.8191		80 f4		bra $8187	                bra input_clear
.8193						input_cleared:
.8193		a9 0d		lda #$0d	                lda #AscCR
.8195		20 db 8d	jsr $8ddb	                jsr emit_a
.8198		b1 28		lda ($28),y	                lda (tmp3),y
.819a		85 21		sta $21		                sta status+1
.819c		e6 28		inc $28		                inc tmp3
.819e		d0 02		bne $81a2	                bne +           ; Increment the upper byte on carry.
.81a0		e6 29		inc $29		                inc tmp3+1
.81a2						+
.81a2		a9 0d		lda #$0d	                lda #AscCR
.81a4		20 db 8d	jsr $8ddb	                jsr emit_a
.81a7						_history_loop:
.81a7		c4 21		cpy $21		                cpy status+1
.81a9		d0 03		bne $81ae	                bne +
.81ab		4c 0f 81	jmp $810f	                jmp accept_loop       ; Needs a long jump
.81ae						+
.81ae		c4 26		cpy $26		                cpy tmp2
.81b0		f0 0a		beq $81bc	                beq _hist_filled_buffer
.81b2		b1 28		lda ($28),y	                lda (tmp3),y
.81b4		91 24		sta ($24),y	                sta (tmp1),y
.81b6		20 db 8d	jsr $8ddb	                jsr emit_a
.81b9		c8		iny		                iny
.81ba		80 eb		bra $81a7	                bra _history_loop
.81bc						_hist_filled_buffer:
.81bc		88		dey		                dey
.81bd		4c 0f 81	jmp $810f	                jmp accept_loop
.81c0						accept_done:
.81c0		20 db 81	jsr $81db	                jsr accept_total_recall
.81c3		85 21		sta $21		                sta status+1
.81c5		a0 00		ldy #$00	                ldy #0
.81c7		91 28		sta ($28),y	                sta (tmp3),y
.81c9		e6 28		inc $28		                inc tmp3
.81cb		d0 02		bne $81cf	                bne +           ; Increment the upper byte on carry.
.81cd		e6 29		inc $29		                inc tmp3+1
.81cf						+
.81cf						_save_history_loop:
.81cf		c4 21		cpy $21		                cpy status+1
.81d1		f0 07		beq $81da	                beq _save_history_done
.81d3		b1 24		lda ($24),y	                lda (tmp1),y
.81d5		91 28		sta ($28),y	                sta (tmp3),y
.81d7		c8		iny		                iny
.81d8		80 f5		bra $81cf	                bra _save_history_loop
.81da						_save_history_done:
.81da						z_accept:
.81da		60		rts		                rts
.81db						accept_total_recall:
.81db		a9 00		lda #$00	                lda #<hist_buff
.81dd		85 28		sta $28		                sta tmp3
.81df		a9 7c		lda #$7c	                lda #>hist_buff
.81e1		85 29		sta $29		                sta tmp3+1
.81e3		a5 20		lda $20		                lda status
.81e5		6a		ror a		                ror
.81e6		29 03		and #$03	                and #3
.81e8		18		clc		                clc
.81e9		65 29		adc $29		                adc tmp3+1
.81eb		85 29		sta $29		                sta tmp3+1
.81ed		a5 20		lda $20		                lda status
.81ef		6a		ror a		                ror             ; Rotate through carry into msb.
.81f0		6a		ror a		                ror
.81f1		29 80		and #$80	                and #$80
.81f3		18		clc		                clc
.81f4		65 28		adc $28		                adc tmp3
.81f6		85 28		sta $28		                sta tmp3
.81f8		90 02		bcc $81fc	                bcc +           ; Increment the upper byte on carry.
.81fa		e6 29		inc $29		                inc tmp3+1
.81fc						+
.81fc		98		tya		                tya
.81fd		c9 80		cmp #$80	                cmp #$80
.81ff		90 02		bcc $8203	                bcc +
.8201		a9 7f		lda #$7f	                lda #$7F
.8203						+
.8203		60		rts		                rts
.8204						xt_action_of:
.8204		a5 16		lda $16		                lda state
.8206		05 17		ora $17		                ora state+1
.8208		f0 0c		beq $8216	                beq _interpreting
.820a						_compiling:
.820a		20 54 85	jsr $8554	                jsr xt_bracket_tick
.820d		a0 8a		ldy #$8a	                ldy #>xt_defer_fetch
.820f		a9 a6		lda #$a6	                lda #<xt_defer_fetch
.8211		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.8214		80 06		bra $821c	                bra _done
.8216						_interpreting:
.8216		20 b5 a1	jsr $a1b5	                jsr xt_tick
.8219		20 a6 8a	jsr $8aa6	                jsr xt_defer_fetch
.821c						_done:
.821c		60		rts		z_action_of:           rts
.821d						xt_again:
.821d		20 6f d8	jsr $d86f	                jsr underflow_1
.8220		a0 00		ldy #$00	                ldy #0
.8222		a9 4c		lda #$4c	                lda #$4C        ; JMP
.8224		91 00		sta ($00),y	                sta (cp),y
.8226		c8		iny		                iny
.8227		b5 00		lda $00,x	                lda 0,x         ; LSB of address
.8229		91 00		sta ($00),y	                sta (cp),y
.822b		c8		iny		                iny
.822c		b5 01		lda $01,x	                lda 1,x         ; MSB of address
.822e		91 00		sta ($00),y	                sta (cp),y
.8230		c8		iny		                iny
.8231		98		tya		                tya
.8232		18		clc		                clc
.8233		65 00		adc $00		                adc cp
.8235		85 00		sta $00		                sta cp
.8237		90 02		bcc $823b	                bcc _done
.8239		e6 01		inc $01		                inc cp+1
.823b						_done:
.823b		e8		inx		                inx
.823c		e8		inx		                inx
.823d		60		rts		z_again:        rts
.823e						xt_align:
.823e						xt_aligned:
.823e						z_align:
.823e		60		rts		z_aligned:      rts             ; stripped out during native compile
.823f						xt_allot:
.823f		20 6f d8	jsr $d86f	                jsr underflow_1
.8242		b5 01		lda $01,x	                lda 1,x
.8244		30 22		bmi $8268	                bmi _release
.8246		18		clc		                clc
.8247		a5 00		lda $00		                lda cp
.8249		75 00		adc $00,x	                adc 0,x
.824b		85 00		sta $00		                sta cp
.824d		a5 01		lda $01		                lda cp+1
.824f		75 01		adc $01,x	                adc 1,x
.8251		85 01		sta $01		                sta cp+1
.8253		a0 00		ldy #$00	                ldy #<cp_end
.8255		c4 00		cpy $00		                cpy cp
.8257		a9 7c		lda #$7c	                lda #>cp_end
.8259		e5 01		sbc $01		                sbc cp+1
.825b		b0 48		bcs $82a5	                bcs _done               ; we're fine.
.825d		84 00		sty $00		                sty cp                  ; still #<cp_end
.825f		a9 7c		lda #$7c	                lda #>cp_end
.8261		85 01		sta $01		                sta cp+1
.8263		a9 00		lda #$00	                lda #err_allot
.8265		4c 85 d8	jmp $d885	                jmp error
.8268						_release:
.8268		ca		dex		                dex
.8269		ca		dex		                dex
.826a		a5 00		lda $00		                lda cp
.826c		95 00		sta $00,x	                sta 0,x
.826e		a5 01		lda $01		                lda cp+1
.8270		95 01		sta $01,x	                sta 1,x
.8272		20 c7 99	jsr $99c7	                jsr xt_plus                     ; new CP is now TOS
.8275		ca		dex		                dex
.8276		ca		dex		                dex                             ; new CP now NOS
.8277		a9 00		lda #$00	                lda #<cp0
.8279		95 00		sta $00,x	                sta 0,x
.827b		a9 03		lda #$03	                lda #>cp0
.827d		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.827f		20 96 d7	jsr $d796	                jsr compare_16bit               ; still ( CP CP0 )
.8282		f0 17		beq $829b	                beq _nega_done
.8284		30 15		bmi $829b	                bmi _nega_done
.8286		a9 00		lda #$00	                lda #<cp0
.8288		85 00		sta $00		                sta cp
.828a		a9 03		lda #$03	                lda #>cp0
.828c		85 01		sta $01		                sta cp+1
.828e		a9 83		lda #$83	                lda #<dictionary_start
.8290		85 02		sta $02		                sta dp
.8292		a9 bc		lda #$bc	                lda #>dictionary_start
.8294		85 03		sta $03		                sta dp+1
.8296		a9 0a		lda #$0a	                lda #err_negallot
.8298		4c 85 d8	jmp $d885	                jmp error
.829b						_nega_done:
.829b		b5 02		lda $02,x	                lda 2,x
.829d		85 00		sta $00		                sta cp
.829f		b5 03		lda $03,x	                lda 3,x
.82a1		85 01		sta $01		                sta cp+1
.82a3		e8		inx		                inx
.82a4		e8		inx		                inx                     ; drop through to _done
.82a5						_done:
.82a5		e8		inx		                inx
.82a6		e8		inx		                inx
.82a7						z_allot:
.82a7		60		rts		                rts
.82a8						xt_allow_native:
.82a8		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.82ab		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82ad		b1 02		lda ($02),y	                lda (dp),y
.82af		29 f5		and #$f5	                and #$ff-NN-AN  ; AN and NN flag is clear.
.82b1		91 02		sta ($02),y	                sta (dp),y
.82b3						z_allow_native:
.82b3		60		rts		                rts
.82b4						xt_also:
.82b4		20 19 91	jsr $9119	                jsr xt_get_order
.82b7		20 77 98	jsr $9877	                jsr xt_over
.82ba		20 5c a1	jsr $a15c	                jsr xt_swap
.82bd		20 01 98	jsr $9801	                jsr xt_one_plus
.82c0		20 f8 9c	jsr $9cf8	                jsr xt_set_order
.82c3		60		rts		z_also:         rts
.82c4						xt_always_native:
.82c4		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.82c7		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.82c9		b1 02		lda ($02),y	                lda (dp),y
.82cb		09 02		ora #$02	                ora #AN         ; Make sure AN flag is set
.82cd		29 f7		and #$f7	                and #$ff-NN     ; and NN flag is clear.
.82cf		91 02		sta ($02),y	                sta (dp),y
.82d1						z_always_native:
.82d1		60		rts		                rts
.82d2						xt_and:
.82d2		20 74 d8	jsr $d874	                jsr underflow_2
.82d5		b5 00		lda $00,x	                lda 0,x
.82d7		35 02		and $02,x	                and 2,x
.82d9		95 02		sta $02,x	                sta 2,x
.82db		b5 01		lda $01,x	                lda 1,x
.82dd		35 03		and $03,x	                and 3,x
.82df		95 03		sta $03,x	                sta 3,x
.82e1		e8		inx		                inx
.82e2		e8		inx		                inx
.82e3		60		rts		z_and:          rts
.82e4						xt_at_xy:
.82e4		20 74 d8	jsr $d874	                jsr underflow_2
.82e7		a5 18		lda $18		                lda base
.82e9		48		pha		                pha
.82ea		a9 0a		lda #$0a	                lda #10
.82ec		85 18		sta $18		                sta base
.82ee		a9 1b		lda #$1b	                lda #AscESC
.82f0		20 db 8d	jsr $8ddb	                jsr emit_a
.82f3		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.82f5		20 db 8d	jsr $8ddb	                jsr emit_a
.82f8		20 01 98	jsr $9801	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82fb		20 dc d8	jsr $d8dc	                jsr print_u
.82fe		a9 3b		lda #$3b	                lda #$3B        ; ASCII for ";"
.8300		20 db 8d	jsr $8ddb	                jsr emit_a
.8303		20 01 98	jsr $9801	                jsr xt_one_plus ; AT-XY is zero based, but ANSI is 1 based
.8306		20 dc d8	jsr $d8dc	                jsr print_u
.8309		a9 48		lda #$48	                lda #'H'
.830b		20 db 8d	jsr $8ddb	                jsr emit_a
.830e		68		pla		                pla
.830f		85 18		sta $18		                sta base
.8311		60		rts		z_at_xy:        rts
.8312						xt_backslash:
.8312		a0 00		ldy #$00	                ldy #blk_offset
.8314		b1 1e		lda ($1e),y	                lda (up),y
.8316		c8		iny		                iny
.8317		11 1e		ora ($1e),y	                ora (up),y
.8319		f0 19		beq $8334	                beq backslash_not_block
.831b		a5 0c		lda $0c		                lda toin
.831d		29 3f		and #$3f	                and #$3F
.831f		f0 1b		beq $833c	                beq z_backslash
.8321		c9 01		cmp #$01	                cmp #$01
.8323		f0 17		beq $833c	                beq z_backslash
.8325		a5 0c		lda $0c		                lda toin
.8327		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.8329		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.832a		69 40		adc #$40	                adc #$40
.832c		85 0c		sta $0c		                sta toin
.832e		90 0c		bcc $833c	                bcc z_backslash
.8330		e6 0d		inc $0d		                inc toin+1
.8332		80 08		bra $833c	                bra z_backslash
.8334						backslash_not_block:
.8334		a5 0a		lda $0a		                lda ciblen
.8336		85 0c		sta $0c		                sta toin
.8338		a5 0b		lda $0b		                lda ciblen+1
.833a		85 0d		sta $0d		                sta toin+1
.833c		60		rts		z_backslash:    rts
.833d						xt_base:
.833d		ca		dex		                dex
.833e		ca		dex		                dex
.833f		a9 18		lda #$18	                lda #<base
.8341		95 00		sta $00,x	                sta 0,x         ; LSB
.8343		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8345		60		rts		z_base:         rts
.8346						xt_begin:
.8346		20 57 91	jsr $9157	                jsr xt_here
.8349		60		rts		z_begin:        rts
.834a						xt_bell:
.834a		a9 07		lda #$07	                lda #7          ; ASCII value for BELl
.834c		20 db 8d	jsr $8ddb	                jsr emit_a
.834f		60		rts		z_bell:         rts
.8350						xt_bl:
.8350		ca		dex		                dex
.8351		ca		dex		                dex
.8352		a9 20		lda #$20	                lda #AscSP
.8354		95 00		sta $00,x	                sta 0,x
.8356		74 01		stz $01,x	                stz 1,x
.8358		60		rts		z_bl:           rts
.8359						xt_blk:
.8359		ca		dex		                dex
.835a		ca		dex		                dex
.835b		18		clc		                clc
.835c		a5 1e		lda $1e		                lda up
.835e		69 00		adc #$00	                adc #blk_offset ; Add offset
.8360		95 00		sta $00,x	                sta 0,x
.8362		a5 1f		lda $1f		                lda up+1
.8364		69 00		adc #$00	                adc #0          ; Adding carry
.8366		95 01		sta $01,x	                sta 1,x
.8368		60		rts		z_blk:          rts
.8369						xt_blkbuffer:
.8369		ca		dex		                dex
.836a		ca		dex		                dex
.836b		a0 28		ldy #$28	                ldy #blkbuffer_offset
.836d		b1 1e		lda ($1e),y	                lda (up),y
.836f		95 00		sta $00,x	                sta 0,x
.8371		c8		iny		                iny             ; Move along to the next byte
.8372		b1 1e		lda ($1e),y	                lda (up),y
.8374		95 01		sta $01,x	                sta 1,x
.8376		60		rts		z_blkbuffer:    rts
.8377						xt_block:
.8377		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8379		b1 1e		lda ($1e),y	                lda (up),y
.837b		d5 00		cmp $00,x	                cmp 0,x
.837d		d0 0f		bne $838e	                bne _not_in_buffer
.837f		c8		iny		                iny
.8380		b1 1e		lda ($1e),y	                lda (up),y
.8382		d5 01		cmp $01,x	                cmp 1,x
.8384		d0 08		bne $838e	                bne _not_in_buffer
.8386		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8388		b1 1e		lda ($1e),y	                lda (up),y
.838a		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.838c		d0 30		bne $83be	                bne _done       ; It's already in the buffer and in use.
.838e						_not_in_buffer:
.838e		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8390		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.8392		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8394		d0 0c		bne $83a2	                bne _buffer_available ; Unused or not dirty = available
.8396		20 69 83	jsr $8369	                jsr xt_blkbuffer
.8399		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.839c		20 65 8f	jsr $8f65	                jsr xt_fetch
.839f		20 16 85	jsr $8516	                jsr xt_block_write
.83a2						_buffer_available:
.83a2		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.83a4		b5 00		lda $00,x	                lda 0,x
.83a6		91 1e		sta ($1e),y	                sta (up),y
.83a8		c8		iny		                iny
.83a9		b5 01		lda $01,x	                lda 1,x
.83ab		91 1e		sta ($1e),y	                sta (up),y
.83ad		20 69 83	jsr $8369	                jsr xt_blkbuffer
.83b0		20 5c a1	jsr $a15c	                jsr xt_swap
.83b3		20 f3 84	jsr $84f3	                jsr xt_block_read
.83b6		a9 01		lda #$01	                lda #1
.83b8		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.83ba		91 1e		sta ($1e),y	                sta (up),y
.83bc		ca		dex		                dex
.83bd		ca		dex		                dex
.83be						_done:
.83be		a0 28		ldy #$28	                ldy #blkbuffer_offset
.83c0		b1 1e		lda ($1e),y	                lda (up),y
.83c2		95 00		sta $00,x	                sta 0,x
.83c4		c8		iny		                iny
.83c5		b1 1e		lda ($1e),y	                lda (up),y
.83c7		95 01		sta $01,x	                sta 1,x
.83c9		60		rts		z_block:        rts
.83ca						xt_block_ramdrive_init:
.83ca		20 6f d8	jsr $d86f	                jsr underflow_1
.83cd		4c e8 84	jmp $84e8	                jmp _after_ramdrive_code
.83d0						_ramdrive_code:
>83d0		62 61 73 65 20 40 20 73		        .text "base @ swap decimal"
>83d8		77 61 70 20 64 65 63 69 6d 61 6c
>83e3		20 31 30 32 34 20 2a		        .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>83ea		20 64 75 70			        .text " dup"    ; ( Save a copy for formatting it at the end )
>83ee		20 62 75 66 66 65 72 3a		        .text " buffer: ramdrive" ; ( Create ramdrive )
>83f6		20 72 61 6d 64 72 69 76 65
>83ff		20 3a 20 62 6c 6f 63 6b		        .text " : block-read-ramdrive"  ; ( addr u -- )
>8407		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>8415		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + swap 1024 move ;"
>841d		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>842d		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>843d		20 3a 20 62 6c 6f 63 6b		        .text " : block-write-ramdrive" ; ( addr u -- )
>8445		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>8454		20 72 61 6d 64 72 69 76		        .text " ramdrive swap 1024 * + 1024 move ;"
>845c		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>846c		31 30 32 34 20 6d 6f 76 65 20 3b
>8477		20 27 20 62 6c 6f 63 6b		        .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>847f		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>848f		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>849f		20 21
>84a1		20 27 20 62 6c 6f 63 6b		        .text " ' block-write-ramdrive block-write-vector !"
>84a9		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>84b9		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>84c9		6f 72 20 21
>84cd		20 72 61 6d 64 72 69 76		        .text " ramdrive swap blank base !"
>84d5		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>84e5		65 20 21
.84e8						_after_ramdrive_code:
.84e8		20 57 a0	jsr $a057	                jsr sliteral_runtime
>84eb		d0 83 18 01			.word _ramdrive_code, _after_ramdrive_code-_ramdrive_code
.84ef		20 ba 90	jsr $90ba	                jsr xt_evaluate
.84f2						z_block_ramdrive_init:
.84f2		60		rts		                rts
.84f3						xt_block_read:
.84f3		a0 2e		ldy #$2e	                ldy #blockread_offset
.84f5		b1 1e		lda ($1e),y	                lda (up),y
.84f7		85 24		sta $24		                sta tmp1
.84f9		c8		iny		                iny
.84fa		b1 1e		lda ($1e),y	                lda (up),y
.84fc		85 25		sta $25		                sta tmp1+1
.84fe		6c 24 00	jmp ($0024)	                jmp (tmp1)
.8501						z_block_read:
.8501						xt_block_read_vector:
.8501		ca		dex		                dex
.8502		ca		dex		                dex
.8503		18		clc		                clc
.8504		a5 1e		lda $1e		                lda up
.8506		69 2e		adc #$2e	                adc #blockread_offset
.8508		95 00		sta $00,x	                sta 0,x
.850a		a5 1f		lda $1f		                lda up+1
.850c		69 00		adc #$00	                adc #0          ; Add carry
.850e		95 01		sta $01,x	                sta 1,x
.8510						z_block_read_vector:
.8510		60		rts		                rts
.8511						xt_block_word_error:
.8511		a9 0c		lda #$0c	                lda #err_blockwords
.8513		4c 85 d8	jmp $d885	                jmp error       ; no RTS needed
.8516						z_block_word_error:
.8516						xt_block_write:
.8516		a0 30		ldy #$30	                ldy #blockwrite_offset
.8518		b1 1e		lda ($1e),y	                lda (up),y
.851a		85 24		sta $24		                sta tmp1
.851c		c8		iny		                iny
.851d		b1 1e		lda ($1e),y	                lda (up),y
.851f		85 25		sta $25		                sta tmp1+1
.8521		6c 24 00	jmp ($0024)	                jmp (tmp1)
.8524						z_block_write:
.8524						xt_block_write_vector:
.8524		ca		dex		                dex
.8525		ca		dex		                dex
.8526		18		clc		                clc
.8527		a5 1e		lda $1e		                lda up
.8529		69 30		adc #$30	                adc #blockwrite_offset
.852b		95 00		sta $00,x	                sta 0,x
.852d		a5 1f		lda $1f		                lda up+1
.852f		69 00		adc #$00	                adc #0          ; Add carry
.8531		95 01		sta $01,x	                sta 1,x
.8533						z_block_write_vector:
.8533		60		rts		                rts
.8534						xt_bounds:
.8534		20 74 d8	jsr $d874	                jsr underflow_2
.8537		18		clc		                clc
.8538		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.853a		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.853c		75 02		adc $02,x	                adc 2,x
.853e		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.8540		94 00		sty $00,x	                sty 0,x
.8542		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.8544		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.8546		75 03		adc $03,x	                adc 3,x
.8548		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.854a		94 01		sty $01,x	                sty 1,x
.854c		60		rts		z_bounds:       rts
.854d						xt_bracket_char:
.854d		20 e7 85	jsr $85e7	                jsr xt_char
.8550		20 6b 93	jsr $936b	                jsr xt_literal
.8553		60		rts		z_bracket_char: rts
.8554						xt_bracket_tick:
.8554		20 b5 a1	jsr $a1b5	                jsr xt_tick
.8557		20 6b 93	jsr $936b	                jsr xt_literal
.855a		60		rts		z_bracket_tick: rts
.855b						xt_buffblocknum:
.855b		ca		dex		                dex
.855c		ca		dex		                dex
.855d		18		clc		                clc
.855e		a5 1e		lda $1e		                lda up
.8560		69 2a		adc #$2a	                adc #buffblocknum_offset        ; Add offset
.8562		95 00		sta $00,x	                sta 0,x
.8564		a5 1f		lda $1f		                lda up+1
.8566		69 00		adc #$00	                adc #0                          ; Adding carry
.8568		95 01		sta $01,x	                sta 1,x
.856a		60		rts		z_buffblocknum: rts
.856b						xt_buffer:
.856b		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.856d		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.856f		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.8571		d0 0c		bne $857f	                bne _buffer_available ; Unused or not dirty = available
.8573		20 69 83	jsr $8369	                jsr xt_blkbuffer
.8576		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.8579		20 65 8f	jsr $8f65	                jsr xt_fetch
.857c		20 16 85	jsr $8516	                jsr xt_block_write
.857f						_buffer_available:
.857f		a0 2a		ldy #$2a	                ldy #buffblocknum_offset
.8581		b5 00		lda $00,x	                lda 0,x
.8583		91 1e		sta ($1e),y	                sta (up),y
.8585		c8		iny		                iny
.8586		b5 01		lda $01,x	                lda 1,x
.8588		91 1e		sta ($1e),y	                sta (up),y
.858a		a9 01		lda #$01	                lda #1
.858c		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.858e		91 1e		sta ($1e),y	                sta (up),y
.8590						_done:
.8590		a0 28		ldy #$28	                ldy #blkbuffer_offset
.8592		b1 1e		lda ($1e),y	                lda (up),y
.8594		95 00		sta $00,x	                sta 0,x
.8596		c8		iny		                iny
.8597		b1 1e		lda ($1e),y	                lda (up),y
.8599		95 01		sta $01,x	                sta 1,x
.859b		60		rts		z_buffer:       rts
.859c						xt_buffer_colon:
.859c		20 30 89	jsr $8930	                jsr xt_create
.859f		20 3f 82	jsr $823f	                jsr xt_allot
.85a2		60		rts		z_buffer_colon: rts
.85a3						xt_buffstatus:
.85a3		ca		dex		                dex
.85a4		ca		dex		                dex
.85a5		18		clc		                clc
.85a6		a5 1e		lda $1e		                lda up
.85a8		69 2c		adc #$2c	                adc #buffstatus_offset  ; Add offset
.85aa		95 00		sta $00,x	                sta 0,x
.85ac		a5 1f		lda $1f		                lda up+1
.85ae		69 00		adc #$00	                adc #0                  ; Adding carry
.85b0		95 01		sta $01,x	                sta 1,x
.85b2		60		rts		z_buffstatus:   rts
.85b3						xt_bye:
.85b3		4c 2b f0	jmp $f02b	                jmp platform_bye
.85b6						z_bye:
.85b6						xt_c_comma:
.85b6		20 6f d8	jsr $d86f	                jsr underflow_1
.85b9		b5 00		lda $00,x	                lda 0,x
.85bb		20 22 d7	jsr $d722	                jsr cmpl_a
.85be		e8		inx		                inx
.85bf		e8		inx		                inx
.85c0		60		rts		z_c_comma:      rts
.85c1						xt_c_fetch:
.85c1		20 6f d8	jsr $d86f	                jsr underflow_1
.85c4		a1 00		lda ($00,x)	                lda (0,x)
.85c6		95 00		sta $00,x	                sta 0,x
.85c8		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.85ca		60		rts		z_c_fetch:      rts
.85cb						xt_c_store:
.85cb		20 74 d8	jsr $d874	                jsr underflow_2
.85ce		b5 02		lda $02,x	                lda 2,x
.85d0		81 00		sta ($00,x)	                sta (0,x)
.85d2		e8		inx		                inx
.85d3		e8		inx		                inx
.85d4		e8		inx		                inx
.85d5		e8		inx		                inx
.85d6		60		rts		z_c_store:      rts
.85d7						xt_cell_plus:
.85d7		20 6f d8	jsr $d86f	                jsr underflow_1
.85da		f6 00		inc $00,x	                inc 0,x
.85dc		d0 02		bne $85e0	                bne +
.85de		f6 01		inc $01,x	                inc 1,x
.85e0						+
.85e0		f6 00		inc $00,x	                inc 0,x
.85e2		d0 02		bne $85e6	                bne _done
.85e4		f6 01		inc $01,x	                inc 1,x
.85e6						_done:
.85e6		60		rts		z_cell_plus:    rts
.85e7						xt_char:
.85e7		20 c3 98	jsr $98c3	                jsr xt_parse_name
.85ea		b5 00		lda $00,x	                lda 0,x
.85ec		15 01		ora $01,x	                ora 1,x
.85ee		d0 05		bne $85f5	                bne _not_empty
.85f0		a9 05		lda #$05	                lda #err_noname
.85f2		4c 85 d8	jmp $d885	                jmp error
.85f5						_not_empty:
.85f5		e8		inx		                inx             ; drop number of characters, leave addr
.85f6		e8		inx		                inx
.85f7		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.85f9		95 00		sta $00,x	                sta 0,x
.85fb		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.85fd		60		rts		z_char:         rts
.85fe						xt_chars:
.85fe		20 6f d8	jsr $d86f	                jsr underflow_1
.8601		60		rts		z_chars:        rts
.8602						xt_cleave:
.8602		20 74 d8	jsr $d874	                jsr underflow_2
.8605		20 47 95	jsr $9547	                jsr xt_minus_leading    ; -LEADING ( addr u )
.8608		20 43 92	jsr $9243	                jsr xt_input_to_r       ; save old imput state
.860b		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.860d		85 0a		sta $0a		                sta ciblen
.860f		b5 01		lda $01,x	                lda 1,x
.8611		85 0b		sta $0b		                sta ciblen+1
.8613		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.8615		85 08		sta $08		                sta cib
.8617		b5 03		lda $03,x	                lda 3,x
.8619		85 09		sta $09		                sta cib+1
.861b		64 0c		stz $0c		                stz toin        ; >IN pointer is zero
.861d		64 0d		stz $0d		                stz toin+1
.861f		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( addr u addr-s u-s )
.8622		b5 00		lda $00,x	                lda 0,x
.8624		15 01		ora $01,x	                ora 1,x
.8626		f0 23		beq $864b	                beq _done
.8628		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.862a		38		sec		                sec
.862b		f5 00		sbc $00,x	                sbc 0,x
.862d		95 04		sta $04,x	                sta 4,x
.862f		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.8631		f5 01		sbc $01,x	                sbc 1,x
.8633		95 05		sta $05,x	                sta 5,x
.8635		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.8637		18		clc		                clc
.8638		75 00		adc $00,x	                adc 0,x
.863a		95 06		sta $06,x	                sta 6,x
.863c		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.863e		75 01		adc $01,x	                adc 1,x
.8640		95 07		sta $07,x	                sta 7,x
.8642		20 22 a4	jsr $a422	                jsr xt_two_swap         ; ( addr-s u-s addr u )
.8645		20 47 95	jsr $9547	                jsr xt_minus_leading
.8648		20 22 a4	jsr $a422	                jsr xt_two_swap         ; ( addr u addr-s u-s )
.864b						_done:
.864b		20 87 9a	jsr $9a87	                jsr xt_r_to_input
.864e		60		rts		z_cleave:       rts
.864f						xt_cmove:
.864f		20 79 d8	jsr $d879	                jsr underflow_3
.8652		b5 02		lda $02,x	                lda 2,x
.8654		85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8656		b5 03		lda $03,x	                lda 3,x
.8658		85 27		sta $27		                sta tmp2+1
.865a		b5 04		lda $04,x	                lda 4,x
.865c		85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.865e		b5 05		lda $05,x	                lda 5,x
.8660		85 25		sta $25		                sta tmp1+1
.8662		a0 00		ldy #$00	                ldy #0
.8664		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.8666		f0 0f		beq $8677	                beq _dopartial
.8668						_page:
.8668		b1 24		lda ($24),y	                lda (tmp1),y
.866a		91 26		sta ($26),y	                sta (tmp2),y
.866c		c8		iny		                iny
.866d		d0 f9		bne $8668	                bne _page
.866f		e6 25		inc $25		                inc tmp1+1
.8671		e6 27		inc $27		                inc tmp2+1
.8673		d6 01		dec $01,x	                dec 1,x
.8675		d0 f1		bne $8668	                bne _page
.8677						_dopartial:
.8677		b5 00		lda $00,x	                lda 0,x         ; length of last page
.8679		f0 09		beq $8684	                beq _done
.867b						_partial:
.867b		b1 24		lda ($24),y	                lda (tmp1),y
.867d		91 26		sta ($26),y	                sta (tmp2),y
.867f		c8		iny		                iny
.8680		d6 00		dec $00,x	                dec 0,x
.8682		d0 f7		bne $867b	                bne _partial
.8684						_done:
.8684		8a		txa		                txa
.8685		18		clc		                clc
.8686		69 06		adc #$06	                adc #6
.8688		aa		tax		                tax
.8689		60		rts		z_cmove:        rts
.868a						xt_cmove_up:
.868a		20 79 d8	jsr $d879	                jsr underflow_3
.868d		b5 02		lda $02,x	                lda 2,x
.868f		85 26		sta $26		                sta tmp2        ; use tmp2 because easier to remember
.8691		b5 03		lda $03,x	                lda 3,x
.8693		18		clc		                clc
.8694		75 01		adc $01,x	                adc 1,x
.8696		85 27		sta $27		                sta tmp2+1      ; point to last page of destination
.8698		b5 04		lda $04,x	                lda 4,x
.869a		85 24		sta $24		                sta tmp1        ; use tmp1 because easier to remember
.869c		b5 05		lda $05,x	                lda 5,x
.869e		18		clc		                clc
.869f		75 01		adc $01,x	                adc 1,x
.86a1		85 25		sta $25		                sta tmp1+1      ; point to last page of source
.86a3		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.86a5		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.86a7		f0 0e		beq $86b7	                beq _nopartial
.86a9						_outerloop:
.86a9		88		dey		                dey
.86aa		f0 07		beq $86b3	                beq _finishpage
.86ac						_innerloop:
.86ac		b1 24		lda ($24),y	                lda (tmp1),y
.86ae		91 26		sta ($26),y	                sta (tmp2),y
.86b0		88		dey		                dey
.86b1		d0 f9		bne $86ac	                bne _innerloop
.86b3						_finishpage:
.86b3		b2 24		lda ($24)	                lda (tmp1)      ; handle y = 0 separately
.86b5		92 26		sta ($26)	                sta (tmp2)
.86b7						_nopartial:
.86b7		c6 25		dec $25		                dec tmp1+1      ; back up to previous pages
.86b9		c6 27		dec $27		                dec tmp2+1
.86bb		d6 01		dec $01,x	                dec 1,x
.86bd		d0 ea		bne $86a9	                bne _outerloop
.86bf						_done:
.86bf		8a		txa		                txa
.86c0		18		clc		                clc
.86c1		69 06		adc #$06	                adc #6
.86c3		aa		tax		                tax
.86c4		60		rts		z_cmove_up:     rts
.86c5						xt_colon:
.86c5		a5 16		lda $16		                lda state
.86c7		05 17		ora $17		                ora state+1
.86c9		f0 05		beq $86d0	                beq +
.86cb		a9 07		lda #$07	                lda #err_state
.86cd		4c 85 d8	jmp $d885	                jmp error
.86d0						+
.86d0		c6 16		dec $16		                dec state
.86d2		c6 17		dec $17		                dec state+1
.86d4		a9 40		lda #$40	                lda #%01000000
.86d6		04 20		tsb $20		                tsb status
.86d8		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.86db		a5 03		lda $03		                lda dp+1            ; CREATE uses a lot of variables
.86dd		48		pha		                pha
.86de		a5 02		lda $02		                lda dp
.86e0		48		pha		                pha
.86e1		a9 80		lda #$80	                lda #%10000000
.86e3		04 20		tsb $20		                tsb status
.86e5		20 30 89	jsr $8930	                jsr xt_create
.86e8		20 b1 d7	jsr $d7b1	                jsr current_to_dp   ; This might be able to be omitted
.86eb		a5 02		lda $02		                lda dp
.86ed		85 04		sta $04		                sta workword
.86ef		a5 03		lda $03		                lda dp+1
.86f1		85 05		sta $05		                sta workword+1
.86f3		68		pla		                pla
.86f4		85 02		sta $02		                sta dp
.86f6		68		pla		                pla
.86f7		85 03		sta $03		                sta dp+1
.86f9		20 c4 d7	jsr $d7c4	                jsr dp_to_current
.86fc		a5 00		lda $00		                lda cp
.86fe		38		sec		                sec
.86ff		e9 03		sbc #$03	                sbc #3
.8701		85 00		sta $00		                sta cp
.8703		b0 02		bcs $8707	                bcs _done
.8705		c6 01		dec $01		                dec cp+1
.8707						_done:
.8707		60		rts		z_colon:        rts
.8708						xt_colon_noname:
.8708		a5 16		lda $16		                lda state
.870a		05 17		ora $17		                ora state+1
.870c		f0 05		beq $8713	                beq +
.870e		a9 07		lda #$07	                lda #err_state
.8710		4c 85 d8	jmp $d885	                jmp error
.8713						+
.8713		c6 16		dec $16		                dec state
.8715		c6 17		dec $17		                dec state+1
.8717		a9 40		lda #$40	                lda #%01000000
.8719		14 20		trb $20		                trb status
.871b		a5 00		lda $00		                lda cp
.871d		85 04		sta $04		                sta workword
.871f		a5 01		lda $01		                lda cp+1
.8721		85 05		sta $05		                sta workword+1
.8723						_done:
.8723		60		rts		z_colon_noname:        rts
.8724						xt_comma:
.8724		20 6f d8	jsr $d86f	                jsr underflow_1
.8727		b5 00		lda $00,x	                lda 0,x
.8729		92 00		sta ($00)	                sta (cp)
.872b		e6 00		inc $00		                inc cp
.872d		d0 02		bne $8731	                bne +
.872f		e6 01		inc $01		                inc cp+1
.8731						+
.8731		b5 01		lda $01,x	                lda 1,x
.8733		92 00		sta ($00)	                sta (cp)
.8735		e6 00		inc $00		                inc cp
.8737		d0 02		bne $873b	                bne _done
.8739		e6 01		inc $01		                inc cp+1
.873b						_done:
.873b		e8		inx		                inx
.873c		e8		inx		                inx
.873d		60		rts		z_comma:        rts
.873e						xt_compare:
.873e		20 7e d8	jsr $d87e	                jsr underflow_4
.8741		b5 02		lda $02,x	                lda 2,x
.8743		85 26		sta $26		                sta tmp2
.8745		b5 03		lda $03,x	                lda 3,x
.8747		85 27		sta $27		                sta tmp2+1
.8749		b5 06		lda $06,x	                lda 6,x
.874b		85 24		sta $24		                sta tmp1
.874d		b5 07		lda $07,x	                lda 7,x
.874f		85 25		sta $25		                sta tmp1+1
.8751						_compare_loop:
.8751		b5 04		lda $04,x	                lda 4,x
.8753		15 05		ora $05,x	                ora 5,x
.8755		f0 2c		beq $8783	                beq _str1_done
.8757		b5 00		lda $00,x	                lda 0,x
.8759		15 01		ora $01,x	                ora 1,x
.875b		f0 3a		beq $8797	                beq _greater    ; Str2 empty first
.875d						_check_letter:
.875d		b2 24		lda ($24)	                lda (tmp1)
.875f		d2 26		cmp ($26)	                cmp (tmp2)
.8761		90 26		bcc $8789	                bcc _less
.8763		d0 32		bne $8797	                bne _greater
.8765						_next_letter:
.8765		e6 24		inc $24		                inc tmp1
.8767		d0 02		bne $876b	                bne +
.8769		e6 25		inc $25		                inc tmp1+1
.876b						+
.876b		e6 26		inc $26		                inc tmp2
.876d		d0 02		bne $8771	                bne +
.876f		e6 27		inc $27		                inc tmp2+1
.8771						+
.8771		b5 04		lda $04,x	                lda 4,x
.8773		d0 02		bne $8777	                bne +
.8775		d6 05		dec $05,x	                dec 5,x
.8777						+
.8777		d6 04		dec $04,x	                dec 4,x
.8779		b5 00		lda $00,x	                lda 0,x
.877b		d0 02		bne $877f	                bne +
.877d		d6 01		dec $01,x	                dec 1,x
.877f						+
.877f		d6 00		dec $00,x	                dec 0,x
.8781		80 ce		bra $8751	                bra _compare_loop
.8783						_str1_done:
.8783		b5 00		lda $00,x	                lda 0,x
.8785		15 01		ora $01,x	                ora 1,x
.8787		f0 08		beq $8791	                beq _equal      ; Both out of letters
.8789						_less:
.8789		a9 ff		lda #$ff	                lda #$FF
.878b		95 06		sta $06,x	                sta 6,x
.878d		95 07		sta $07,x	                sta 7,x
.878f		80 0c		bra $879d	                bra _done
.8791						_equal:
.8791		74 06		stz $06,x	                stz 6,x
.8793		74 07		stz $07,x	                stz 7,x
.8795		80 06		bra $879d	                bra _done
.8797						_greater:
.8797		a9 01		lda #$01	                lda #1
.8799		95 06		sta $06,x	                sta 6,x
.879b		74 07		stz $07,x	                stz 7,x
.879d						_done:
.879d		8a		txa		                txa
.879e		18		clc		                clc
.879f		69 06		adc #$06	                adc #6
.87a1		aa		tax		                tax
.87a2		60		rts		z_compare:      rts
.87a3						xt_compile_comma:
.87a3		20 6f d8	jsr $d86f	                jsr underflow_1
.87a6		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87a8		48		pha		                pha
.87a9		b5 00		lda $00,x	                lda 0,x
.87ab		48		pha		                pha                     ; LSB
.87ac		20 59 92	jsr $9259	                jsr xt_int_to_name      ; ( xt -- nt )
.87af		b5 00		lda $00,x	                lda 0,x
.87b1		15 01		ora $01,x	                ora 1,x
.87b3		d0 03		bne $87b8	                bne _check_nt
.87b5		4c b1 88	jmp $88b1	                jmp compile_as_jump
.87b8						_check_nt:
.87b8		b5 00		lda $00,x	                lda 0,x
.87ba		85 2c		sta $2c		                sta tmptos
.87bc		b5 01		lda $01,x	                lda 1,x
.87be		85 2d		sta $2d		                sta tmptos+1
.87c0		f6 00		inc $00,x	                inc 0,x
.87c2		d0 02		bne $87c6	                bne +
.87c4		f6 01		inc $01,x	                inc 1,x                 ; ( nt -- nt+1 )
.87c6						+
.87c6		a1 00		lda ($00,x)	                lda (0,x)
.87c8		85 28		sta $28		                sta tmp3                ; keep copy of status byte for NN
.87ca		29 02		and #$02	                and #AN                 ; mask all but Always Native (AN) bit
.87cc		f0 0d		beq $87db	                beq _compile_check
.87ce		a5 2c		lda $2c		                lda tmptos
.87d0		95 00		sta $00,x	                sta 0,x
.87d2		a5 2d		lda $2d		                lda tmptos+1
.87d4		95 01		sta $01,x	                sta 1,x
.87d6		20 23 a7	jsr $a723	                jsr xt_wordsize         ; ( nt -- u )
.87d9		80 27		bra $8802	                bra _compile_as_code
.87db						_compile_check:
.87db		a5 28		lda $28		                lda tmp3
.87dd		29 08		and #$08	                and #NN
.87df		f0 03		beq $87e4	                beq _check_size_limit
.87e1		4c b1 88	jmp $88b1	                jmp compile_as_jump    ; too far for BRA
.87e4						_check_size_limit:
.87e4		a5 2c		lda $2c		                lda tmptos
.87e6		95 00		sta $00,x	                sta 0,x
.87e8		a5 2d		lda $2d		                lda tmptos+1
.87ea		95 01		sta $01,x	                sta 1,x
.87ec		20 23 a7	jsr $a723	                jsr xt_wordsize         ; ( nt -- u )
.87ef		b5 01		lda $01,x	                lda 1,x
.87f1		c5 1b		cmp $1b		                cmp nc_limit+1
.87f3		90 0d		bcc $8802	                bcc _compile_as_code    ; user-defined limit MSB
.87f5		d0 08		bne $87ff	                bne _jumpto_compile_as_jump
.87f7		b5 00		lda $00,x	                lda 0,x
.87f9		c5 1a		cmp $1a		                cmp nc_limit            ; user-defined limit LSB
.87fb		90 05		bcc $8802	                bcc _compile_as_code    ; Allow native compiling for less
.87fd		f0 03		beq $8802	                beq _compile_as_code    ; than or equal to the limit.
.87ff						_jumpto_compile_as_jump:
.87ff		4c b1 88	jmp $88b1	                jmp compile_as_jump    ; too far for BRA
.8802						_compile_as_code:
.8802		ca		dex		                dex
.8803		ca		dex		                dex                     ; ( -- u ? )
.8804		ca		dex		                dex
.8805		ca		dex		                dex                     ; ( -- u ? ? )
.8806		b5 04		lda $04,x	                lda 4,x
.8808		95 00		sta $00,x	                sta 0,x                 ; LSB of u
.880a		b5 05		lda $05,x	                lda 5,x
.880c		95 01		sta $01,x	                sta 1,x                 ; ( -- u ? u )
.880e		68		pla		                pla
.880f		95 04		sta $04,x	                sta 4,x                 ; LSB of xt
.8811		68		pla		                pla
.8812		95 05		sta $05,x	                sta 5,x                 ; ( -- xt ? u )
.8814		a5 00		lda $00		                lda cp                  ; LSB of cp
.8816		95 02		sta $02,x	                sta 2,x
.8818		a5 01		lda $01		                lda cp+1
.881a		95 03		sta $03,x	                sta 3,x                 ; ( -- xt cp u )
.881c		a0 00		ldy #$00	                ldy #0
.881e						_strip_loop:
.881e		b9 9f 88	lda $889f,y	                lda strip_table,y      ; LSB of first word
.8821		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of xt
.8823		d0 07		bne $882c	                bne _next_entry
.8825		b9 a0 88	lda $88a0,y	                lda strip_table+1,y
.8828		d5 05		cmp $05,x	                cmp 5,x
.882a		f0 0c		beq $8838	                beq _found_entry
.882c						_next_entry:
.882c		b9 9f 88	lda $889f,y	                lda strip_table,y      ; pointing to LSB
.882f		19 a0 88	ora $88a0,y	                ora strip_table+1,y    ; get MSB
.8832		f0 22		beq $8856	                beq _underflow_strip    ; table done, let's get out of here
.8834		c8		iny		                iny
.8835		c8		iny		                iny
.8836		80 e6		bra $881e	                bra _strip_loop
.8838						_found_entry:
.8838		98		tya		                tya
.8839		4a		lsr a		                lsr
.883a		a8		tay		                tay
.883b		b9 ab 88	lda $88ab,y	                lda strip_size,y
.883e		85 2c		sta $2c		                sta tmptos              ; save a copy
.8840		18		clc		                clc
.8841		75 04		adc $04,x	                adc 4,x
.8843		95 04		sta $04,x	                sta 4,x
.8845		90 02		bcc $8849	                bcc+
.8847		f6 05		inc $05,x	                inc 5,x                 ; we just care about the carry
.8849						+
.8849		06 2c		asl $2c		                asl tmptos
.884b		38		sec		                sec
.884c		b5 00		lda $00,x	                lda 0,x
.884e		e5 2c		sbc $2c		                sbc tmptos
.8850		95 00		sta $00,x	                sta 0,x
.8852		b0 02		bcs $8856	                bcs +
.8854		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.8856						+
.8856						_underflow_strip:
.8856		a5 1c		lda $1c		                lda uf_strip
.8858		05 1d		ora $1d		                ora uf_strip+1
.885a		f0 1c		beq $8878	                beq cmpl_inline
.885c		a5 28		lda $28		                lda tmp3
.885e		29 10		and #$10	                and #UF
.8860		f0 16		beq $8878	                beq cmpl_inline
.8862		18		clc		                clc
.8863		b5 04		lda $04,x	                lda 4,x
.8865		69 03		adc #$03	                adc #3
.8867		95 04		sta $04,x	                sta 4,x
.8869		90 02		bcc $886d	                bcc +
.886b		f6 05		inc $05,x	                inc 5,x                  ; we just care about the carry
.886d						+
.886d		38		sec		                sec
.886e		b5 00		lda $00,x	                lda 0,x
.8870		e9 03		sbc #$03	                sbc #3
.8872		95 00		sta $00,x	                sta 0,x
.8874		b0 02		bcs $8878	                bcs +
.8876		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.8878						+
.8878						cmpl_inline:
.8878		b5 01		lda $01,x	                lda 1,x                 ; MSB
.887a		48		pha		                pha
.887b		b5 00		lda $00,x	                lda 0,x                 ; LSB
.887d		48		pha		                pha
.887e		20 a6 95	jsr $95a6	                jsr xt_move
.8881		18		clc		                clc
.8882		68		pla		                pla                     ; LSB
.8883		65 00		adc $00		                adc cp
.8885		85 00		sta $00		                sta cp
.8887		68		pla		                pla                     ; MSB
.8888		65 01		adc $01		                adc cp+1
.888a		85 01		sta $01		                sta cp+1
.888c		60		rts		                rts
.888d						cmpl_inline_y:
.888d		ca		dex		                dex             ; set up stack as ( src dst n -- )
.888e		ca		dex		                dex
.888f		ca		dex		                dex
.8890		ca		dex		                dex
.8891		94 00		sty $00,x	                sty 0,x
.8893		74 01		stz $01,x	                stz 1,x             ; assume < 256 bytes
.8895		a5 00		lda $00		                lda cp
.8897		95 02		sta $02,x	                sta 2,x
.8899		a5 01		lda $01		                lda cp+1
.889b		95 03		sta $03,x	                sta 3,x
.889d		80 d9		bra $8878	                bra cmpl_inline
.889f						strip_table:
>889f		76 9a 61 9a 14 a3		                .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
>88a5		46 a4 cc a3 00 00		                .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
.88ab						strip_size:
>88ab		04 04 04 06 06 00		                .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
.88b1						compile_as_jump:
.88b1		a9 20		lda #$20	                lda #$20
.88b3		92 00		sta ($00)	                sta (cp)
.88b5		a0 01		ldy #$01	                ldy #1
.88b7		68		pla		                pla             ; LSB
.88b8		91 00		sta ($00),y	                sta (cp),y
.88ba		c8		iny		                iny
.88bb		68		pla		                pla             ; MSB
.88bc		91 00		sta ($00),y	                sta (cp),y
.88be		a9 03		lda #$03	                lda #3
.88c0		18		clc		                clc
.88c1		65 00		adc $00		                adc cp
.88c3		85 00		sta $00		                sta cp
.88c5		90 02		bcc $88c9	                bcc +
.88c7		e6 01		inc $01		                inc cp+1
.88c9						+
.88c9		e8		inx		                inx             ; drop xt
.88ca		e8		inx		                inx
.88cb						z_compile_comma:
.88cb		60		rts		                rts
.88cc						xt_compile_only:
.88cc		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.88cf		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.88d1		b1 02		lda ($02),y	                lda (dp),y
.88d3		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.88d5		91 02		sta ($02),y	                sta (dp),y
.88d7		60		rts		z_compile_only: rts
.88d8						xt_value:
.88d8						xt_constant:
.88d8		20 6f d8	jsr $d86f	                jsr underflow_1
.88db		20 30 89	jsr $8930	                jsr xt_create
.88de		38		sec		                sec
.88df		a5 00		lda $00		                lda cp
.88e1		e9 02		sbc #$02	                sbc #2
.88e3		85 24		sta $24		                sta tmp1
.88e5		a5 01		lda $01		                lda cp+1
.88e7		e9 00		sbc #$00	                sbc #0
.88e9		85 25		sta $25		                sta tmp1+1
.88eb		a9 2b		lda #$2b	                lda #<doconst           ; LSB of DOCONST
.88ed		92 24		sta ($24)	                sta (tmp1)
.88ef		a0 01		ldy #$01	                ldy #1
.88f1		a9 d7		lda #$d7	                lda #>doconst           ; MSB of DOCONST
.88f3		91 24		sta ($24),y	                sta (tmp1),y
.88f5		20 24 87	jsr $8724	                jsr xt_comma            ; drop through to adjust_z
.88f8						adjust_z:
.88f8		20 1c 93	jsr $931c	                jsr xt_latestnt         ; gives us ( -- nt )
.88fb		b5 00		lda $00,x	                lda 0,x
.88fd		85 24		sta $24		                sta tmp1
.88ff		b5 01		lda $01,x	                lda 1,x
.8901		85 25		sta $25		                sta tmp1+1
.8903		a0 06		ldy #$06	                ldy #6
.8905		b1 24		lda ($24),y	                lda (tmp1),y
.8907		18		clc		                clc
.8908		69 02		adc #$02	                adc #2
.890a		91 24		sta ($24),y	                sta (tmp1),y
.890c		c8		iny		                iny
.890d		b1 24		lda ($24),y	                lda (tmp1),y
.890f		69 00		adc #$00	                adc #0                  ; only need carry
.8911		91 24		sta ($24),y	                sta (tmp1),y
.8913		e8		inx		                inx
.8914		e8		inx		                inx
.8915						z_value:
.8915		60		rts		z_constant:     rts
.8916						xt_count:
.8916		20 6f d8	jsr $d86f	                jsr underflow_1
.8919		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.891b		a8		tay		                tay
.891c		f6 00		inc $00,x	                inc 0,x         ; LSB
.891e		d0 02		bne $8922	                bne +
.8920		f6 01		inc $01,x	                inc 1,x         ; MSB
.8922		98		tya		+               tya
.8923		ca		dex		                dex
.8924		ca		dex		                dex
.8925		95 00		sta $00,x	                sta 0,x         ; LSB
.8927		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.8929		60		rts		z_count:        rts
.892a						xt_cr:
.892a		a9 0a		lda #$0a	                lda #AscLF
.892c		20 db 8d	jsr $8ddb	                jsr emit_a
.892f		60		rts		z_cr:           rts
.8930						xt_create:
.8930		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( addr u )
.8933		b5 00		lda $00,x	                lda 0,x
.8935		15 01		ora $01,x	                ora 1,x
.8937		d0 05		bne $893e	                bne _got_name
.8939		a9 05		lda #$05	                lda #err_noname
.893b		4c 85 d8	jmp $d885	                jmp error
.893e						_got_name:
.893e		74 01		stz $01,x	                stz 1,x
.8940		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( addr u addr u )
.8943		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
.8946		b5 00		lda $00,x	                lda 0,x
.8948		15 01		ora $01,x	                ora 1,x
.894a		f0 1e		beq $896a	                beq _new_name           ; We haven't seen this one before.
.894c		e8		inx		                inx                     ; Drop flag (nt) from find-name.
.894d		e8		inx		                inx
.894e		24 20		bit $20		                bit status
.8950		10 08		bpl $895a	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8952		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8954		05 20		ora $20		                ora status
.8956		85 20		sta $20		                sta status
.8958		80 18		bra $8972	                bra _process_name
.895a						_redefined_name:
.895a		a9 02		lda #$02	                lda #str_redefined
.895c		20 ab d8	jsr $d8ab	                jsr print_string_no_lf
.895f		20 5c a3	jsr $a35c	                jsr xt_two_dup           ; ( addr u addr u )
.8962		20 a7 a4	jsr $a4a7	                jsr xt_type
.8965		20 cc a0	jsr $a0cc	                jsr xt_space
.8968		80 08		bra $8972	                bra _process_name
.896a						_new_name:
.896a		e8		inx		                inx                     ; Drop flag (0) from find-name.
.896b		e8		inx		                inx
.896c		a9 7f		lda #$7f	                lda #$7F                ; Clear bit 0 of status to indicate new word.
.896e		25 20		and $20		                and status
.8970		85 20		sta $20		                sta status
.8972						_process_name:
.8972		b5 00		lda $00,x	                lda 0,x
.8974		85 26		sta $26		                sta tmp2                ; store length of string in tmp2
.8976		a5 00		lda $00		                lda cp
.8978		85 24		sta $24		                sta tmp1
.897a		a5 01		lda $01		                lda cp+1
.897c		85 25		sta $25		                sta tmp1+1
.897e		b5 00		lda $00,x	                lda 0,x
.8980		18		clc		                clc
.8981		69 08		adc #$08	                adc #8
.8983		85 28		sta $28		                sta tmp3                ; total header length
.8985		18		clc		                clc
.8986		69 03		adc #$03	                adc #3
.8988		95 00		sta $00,x	                sta 0,x
.898a		74 01		stz $01,x	                stz 1,x         ; max header size is 255 chars
.898c		20 3f 82	jsr $823f	                jsr xt_allot    ; ( addr )
.898f		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.8992		a0 00		ldy #$00	                ldy #0
.8994		a5 26		lda $26		                lda tmp2
.8996		91 24		sta ($24),y	                sta (tmp1),y
.8998		a9 08		lda #$08	                lda #NN
.899a		09 20		ora #$20	                ora #HC
.899c		c8		iny		                iny
.899d		91 24		sta ($24),y	                sta (tmp1),y
.899f		c8		iny		                iny
.89a0		a5 02		lda $02		                lda dp
.89a2		91 24		sta ($24),y	                sta (tmp1),y
.89a4		c8		iny		                iny
.89a5		a5 03		lda $03		                lda dp+1
.89a7		91 24		sta ($24),y	                sta (tmp1),y
.89a9		c8		iny		                iny
.89aa		a5 25		lda $25		                lda tmp1+1
.89ac		85 03		sta $03		                sta dp+1
.89ae		a5 24		lda $24		                lda tmp1
.89b0		85 02		sta $02		                sta dp
.89b2		18		clc		                clc
.89b3		65 28		adc $28		                adc tmp3        ; add total header length
.89b5		91 24		sta ($24),y	                sta (tmp1),y
.89b7		48		pha		                pha             ; we need this in the next step
.89b8		c8		iny		                iny
.89b9		a5 25		lda $25		                lda tmp1+1
.89bb		69 00		adc #$00	                adc #0          ; only need the carry
.89bd		91 24		sta ($24),y	                sta (tmp1),y
.89bf		c8		iny		                iny
.89c0		68		pla		                pla             ; LSB of "z_" address
.89c1		18		clc		                clc
.89c2		69 03		adc #$03	                adc #3
.89c4		91 24		sta ($24),y	                sta (tmp1),y
.89c6		88		dey		                dey             ; get the MSB of xt back
.89c7		b1 24		lda ($24),y	                lda (tmp1),y
.89c9		69 00		adc #$00	                adc #0          ; only need the carry
.89cb		c8		iny		                iny
.89cc		c8		iny		                iny
.89cd		91 24		sta ($24),y	                sta (tmp1),y
.89cf		c8		iny		                iny
.89d0		b5 00		lda $00,x	                lda 0,x
.89d2		38		sec		                sec
.89d3		e9 08		sbc #$08	                sbc #8
.89d5		85 2c		sta $2c		                sta tmptos
.89d7		b5 01		lda $01,x	                lda 1,x
.89d9		e9 00		sbc #$00	                sbc #0          ; only need carry
.89db		85 2d		sta $2d		                sta tmptos+1
.89dd						_name_loop:
.89dd		b1 2c		lda ($2c),y	                lda (tmptos),y
.89df		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.89e1		b0 07		bcs $89ea	                bcs _store_name
.89e3		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.89e5		90 03		bcc $89ea	                bcc _store_name
.89e7		18		clc		                clc
.89e8		69 20		adc #$20	                adc #$20
.89ea						_store_name:
.89ea		91 24		sta ($24),y	                sta (tmp1),y
.89ec		c8		iny		                iny
.89ed		c6 26		dec $26		                dec tmp2
.89ef		d0 ec		bne $89dd	                bne _name_loop
.89f1		a9 20		lda #$20	                lda #$20        ; opcode of JSR
.89f3		91 24		sta ($24),y	                sta (tmp1),y
.89f5		c8		iny		                iny
.89f6		a9 71		lda #$71	                lda #<dovar
.89f8		91 24		sta ($24),y	                sta (tmp1),y
.89fa		c8		iny		                iny
.89fb		a9 d7		lda #$d7	                lda #>dovar
.89fd		91 24		sta ($24),y	                sta (tmp1),y
.89ff		20 c4 d7	jsr $d7c4	                jsr dp_to_current
.8a02		e8		inx		                inx
.8a03		e8		inx		                inx
.8a04		60		rts		z_create:       rts
.8a05						xt_d_minus:
.8a05		20 7e d8	jsr $d87e	                jsr underflow_4 ; two double numbers
.8a08		38		sec		                sec
.8a09		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.8a0b		f5 02		sbc $02,x	                sbc 2,x
.8a0d		95 06		sta $06,x	                sta 6,x
.8a0f		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.8a11		f5 03		sbc $03,x	                sbc 3,x
.8a13		95 07		sta $07,x	                sta 7,x
.8a15		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.8a17		f5 00		sbc $00,x	                sbc 0,x
.8a19		95 04		sta $04,x	                sta 4,x
.8a1b		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.8a1d		f5 01		sbc $01,x	                sbc 1,x
.8a1f		95 05		sta $05,x	                sta 5,x
.8a21		e8		inx		                inx
.8a22		e8		inx		                inx
.8a23		e8		inx		                inx
.8a24		e8		inx		                inx
.8a25		60		rts		z_d_minus:      rts
.8a26						xt_d_plus:
.8a26		20 7e d8	jsr $d87e	                jsr underflow_4 ; two double numbers
.8a29		18		clc		                clc
.8a2a		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.8a2c		75 06		adc $06,x	                adc 6,x
.8a2e		95 06		sta $06,x	                sta 6,x
.8a30		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.8a32		75 07		adc $07,x	                adc 7,x
.8a34		95 07		sta $07,x	                sta 7,x
.8a36		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.8a38		75 04		adc $04,x	                adc 4,x
.8a3a		95 04		sta $04,x	                sta 4,x
.8a3c		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.8a3e		75 05		adc $05,x	                adc 5,x
.8a40		95 05		sta $05,x	                sta 5,x
.8a42		e8		inx		                inx
.8a43		e8		inx		                inx
.8a44		e8		inx		                inx
.8a45		e8		inx		                inx
.8a46		60		rts		z_d_plus:       rts
.8a47						xt_d_to_s:
.8a47		20 74 d8	jsr $d874	                jsr underflow_2
.8a4a		e8		inx		                inx
.8a4b		e8		inx		                inx
.8a4c		60		rts		z_d_to_s:       rts
.8a4d						xt_dabs:
.8a4d		20 74 d8	jsr $d874	                jsr underflow_2 ; double number
.8a50		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.8a52		10 17		bpl $8a6b	                bpl _done       ; positive, we get off light
.8a54		a0 00		ldy #$00	                ldy #0
.8a56		38		sec		                sec
.8a57		98		tya		                tya
.8a58		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8a5a		95 02		sta $02,x	                sta 2,x
.8a5c		98		tya		                tya
.8a5d		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8a5f		95 03		sta $03,x	                sta 3,x
.8a61		98		tya		                tya
.8a62		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8a64		95 00		sta $00,x	                sta 0,x
.8a66		98		tya		                tya
.8a67		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8a69		95 01		sta $01,x	                sta 1,x
.8a6b						_done:
.8a6b		60		rts		z_dabs:         rts
.8a6c						xt_decimal:
.8a6c		a9 0a		lda #$0a	                lda #10
.8a6e		85 18		sta $18		                sta base
.8a70		64 19		stz $19		                stz base+1              ; paranoid
.8a72		60		rts		z_decimal:      rts
.8a73						xt_defer:
.8a73		20 30 89	jsr $8930	                jsr xt_create
.8a76		a5 00		lda $00		                lda cp          ; LSB
.8a78		38		sec		                sec
.8a79		e9 02		sbc #$02	                sbc #2
.8a7b		85 24		sta $24		                sta tmp1
.8a7d		a5 01		lda $01		                lda cp+1        ; MSB
.8a7f		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.8a81		85 25		sta $25		                sta tmp1+1
.8a83		a0 00		ldy #$00	                ldy #0
.8a85		a9 3f		lda #$3f	                lda #<dodefer   ; LSB
.8a87		91 24		sta ($24),y	                sta (tmp1),y
.8a89		c8		iny		                iny
.8a8a		a9 d7		lda #$d7	                lda #>dodefer   ; MSB
.8a8c		91 24		sta ($24),y	                sta (tmp1),y
.8a8e		a9 53		lda #$53	                lda #<defer_error
.8a90		92 00		sta ($00)	                sta (cp)
.8a92		e6 00		inc $00		                inc cp
.8a94		d0 02		bne $8a98	                bne +
.8a96		e6 01		inc $01		                inc cp+1
.8a98						+
.8a98		a9 d7		lda #$d7	                lda #>defer_error
.8a9a		92 00		sta ($00)	                sta (cp)
.8a9c		e6 00		inc $00		                inc cp
.8a9e		d0 02		bne $8aa2	                bne +
.8aa0		e6 01		inc $01		                inc cp+1
.8aa2						+
.8aa2		20 f8 88	jsr $88f8	                jsr adjust_z    ; adjust header to correct length
.8aa5		60		rts		z_defer:        rts
.8aa6						xt_defer_fetch:
.8aa6		20 31 a2	jsr $a231	                jsr xt_to_body
.8aa9		20 65 8f	jsr $8f65	                jsr xt_fetch
.8aac		60		rts		z_defer_fetch:  rts
.8aad						xt_defer_store:
.8aad		20 31 a2	jsr $a231	                jsr xt_to_body
.8ab0		20 3b a1	jsr $a13b	                jsr xt_store
.8ab3		60		rts		z_defer_store:  rts
.8ab4						xt_definitions:
.8ab4		a0 1f		ldy #$1f	                ldy #search_order_offset    ; Transfer byte variable
.8ab6		b1 1e		lda ($1e),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.8ab8		a0 04		ldy #$04	                ldy #current_offset         ; byte variable CURRENT.
.8aba		91 1e		sta ($1e),y	                sta (up),y
.8abc		60		rts		z_definitions:  rts
.8abd						xt_depth:
.8abd		a9 78		lda #$78	                lda #dsp0
.8abf		86 2a		stx $2a		                stx tmpdsp
.8ac1		38		sec		                sec
.8ac2		e5 2a		sbc $2a		                sbc tmpdsp
.8ac4		4a		lsr a		                lsr
.8ac5		ca		dex		                dex
.8ac6		ca		dex		                dex
.8ac7		95 00		sta $00,x	                sta 0,x
.8ac9		74 01		stz $01,x	                stz 1,x
.8acb		60		rts		z_depth:        rts
.8acc						xt_digit_question:
.8acc		20 6f d8	jsr $d86f	                jsr underflow_1
.8acf		ca		dex		                dex
.8ad0		ca		dex		                dex
.8ad1		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.8ad3		74 01		stz $01,x	                stz 1,x
.8ad5		74 03		stz $03,x	                stz 3,x                 ; paranoid
.8ad7		b5 02		lda $02,x	                lda 2,x
.8ad9		c9 30		cmp #$30	                cmp #'0'
.8adb		90 23		bcc $8b00	                bcc _done               ; failure flag already set
.8add		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.8adf		90 12		bcc $8af3	                bcc _checkbase
.8ae1		c9 41		cmp #$41	                cmp #'A'
.8ae3		90 1b		bcc $8b00	                bcc _done               ; failure flag is already set
.8ae5		c9 61		cmp #$61	                cmp #'a'
.8ae7		90 07		bcc $8af0	                bcc _case_done          ; not lower case, too low
.8ae9		c9 7b		cmp #$7b	                cmp #'z'+1
.8aeb		b0 03		bcs $8af0	                bcs _case_done          ; not lower case, too high
.8aed		18		clc		                clc                     ; just right
.8aee		69 e0		adc #$e0	                adc #$e0                ; offset to upper case (wraps)
.8af0						_case_done:
.8af0		38		sec		                sec
.8af1		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.8af3						_checkbase:
.8af3		38		sec		                sec
.8af4		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.8af6		c5 18		cmp $18		                cmp base
.8af8		b0 06		bcs $8b00	                bcs _done               ; already have false flag
.8afa		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.8afc		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.8afe		d6 01		dec $01,x	                dec 1,x
.8b00						_done:
.8b00						z_digit_question:
.8b00		60		rts		                rts
.8b01						xt_disasm:
.8b01		20 74 d8	jsr $d874	                jsr underflow_2
.8b04		20 d5 ac	jsr $acd5	                jsr disassembler
.8b07		60		rts		z_disasm:       rts
.8b08						xt_dnegate:
.8b08		20 74 d8	jsr $d874	                jsr underflow_2 ; double number
.8b0b		a0 00		ldy #$00	     		ldy #0
.8b0d		38		sec		                sec
.8b0e		98		tya		                tya
.8b0f		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.8b11		95 02		sta $02,x	                sta 2,x
.8b13		98		tya		                tya
.8b14		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.8b16		95 03		sta $03,x	                sta 3,x
.8b18		98		tya		                tya
.8b19		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.8b1b		95 00		sta $00,x	                sta 0,x
.8b1d		98		tya		                tya
.8b1e		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.8b20		95 01		sta $01,x	                sta 1,x
.8b22		60		rts		z_dnegate:      rts
.8b23						xt_question_do:
.8b23		a9 ff		lda #$ff	                lda #$ff                ; -1 is ?DO, jump to common code
.8b25		85 24		sta $24		                sta tmp1
.8b27		80 02		bra $8b2b	                bra do_common           ; skip flag for DO
.8b29						xt_do:
.8b29		64 24		stz $24		                stz tmp1                ; 0 is DO, drop through to DO_COMMON
.8b2b						do_common:
.8b2b		ca		dex		                dex
.8b2c		ca		dex		                dex
.8b2d		a5 01		lda $01		                lda cp+1
.8b2f		95 01		sta $01,x	                sta 1,x                 ; MSB   ( limit start here )
.8b31		a5 00		lda $00		                lda cp
.8b33		95 00		sta $00,x	                sta 0,x                 ; LSB
.8b35		18		clc		                clc
.8b36		69 06		adc #$06	                adc #6
.8b38		85 00		sta $00		                sta cp
.8b3a		90 02		bcc $8b3e	                bcc +
.8b3c		e6 01		inc $01		                inc cp+1
.8b3e						+
.8b3e		a5 24		lda $24		                lda tmp1
.8b40		f0 0f		beq $8b51	                beq _compile_do
.8b42		ca		dex		                dex
.8b43		ca		dex		                dex
.8b44		a9 94		lda #$94	                lda #<question_do_runtime
.8b46		95 00		sta $00,x	                sta 0,x
.8b48		a9 8b		lda #$8b	                lda #>question_do_runtime
.8b4a		95 01		sta $01,x	                sta 1,x
.8b4c		a0 14		ldy #$14	                ldy #question_do_runtime_end-question_do_runtime
.8b4e		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.8b51						_compile_do:
.8b51		a0 8b		ldy #$8b	                ldy #>do_runtime
.8b53		a9 63		lda #$63	                lda #<do_runtime
.8b55		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.8b58		ca		dex		                dex
.8b59		ca		dex		                dex
.8b5a		a5 00		lda $00		                lda CP          ; LSB
.8b5c		95 00		sta $00,x	                sta 0,x
.8b5e		a5 01		lda $01		                lda CP+1        ; MSB
.8b60		95 01		sta $01,x	                sta 1,x
.8b62						z_question_do:
.8b62		60		rts		z_do:           rts
.8b63						do_runtime:
.8b63		68		pla		                pla
.8b64		85 24		sta $24		                sta tmp1
.8b66		68		pla		                pla
.8b67		85 25		sta $25		                sta tmp1+1
.8b69		38		sec		                sec
.8b6a		a9 00		lda #$00	                lda #0
.8b6c		f5 02		sbc $02,x	                sbc 2,x         ; LSB of limit
.8b6e		95 02		sta $02,x	                sta 2,x         ; save FUFA for later use
.8b70		a9 80		lda #$80	                lda #$80
.8b72		f5 03		sbc $03,x	                sbc 3,x         ; MSB of limit
.8b74		95 03		sta $03,x	                sta 3,x         ; save FUFA for later use
.8b76		48		pha		                pha             ; FUFA replaces limit on R stack
.8b77		b5 02		lda $02,x	                lda 2,x         ; LSB of limit
.8b79		48		pha		                pha
.8b7a		18		clc		                clc
.8b7b		b5 00		lda $00,x	                lda 0,x         ; LSB of original index
.8b7d		75 02		adc $02,x	                adc 2,x         ; add LSB of FUFA
.8b7f		95 00		sta $00,x	                sta 0,x
.8b81		b5 01		lda $01,x	                lda 1,x         ; MSB of orginal index
.8b83		75 03		adc $03,x	                adc 3,x         ; add MSB of FUFA
.8b85		48		pha		                pha
.8b86		b5 00		lda $00,x	                lda 0,x         ; LSB of index
.8b88		48		pha		                pha
.8b89		e8		inx		                inx
.8b8a		e8		inx		                inx
.8b8b		e8		inx		                inx
.8b8c		e8		inx		                inx
.8b8d		a5 25		lda $25		                lda tmp1+1
.8b8f		48		pha		                pha
.8b90		a5 24		lda $24		                lda tmp1
.8b92		48		pha		                pha
.8b93		60		rts		                rts
.8b94						question_do_runtime:
.8b94		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( n1 n2 n1 n2 )
.8b97		20 b3 8e	jsr $8eb3	                jsr xt_equal            ; ( -- n1 n2 f )
.8b9a		b5 00		lda $00,x	                lda 0,x
.8b9c		15 01		ora $01,x	                ora 1,x
.8b9e		f0 06		beq $8ba6	                beq _do_do
.8ba0		8a		txa		                txa
.8ba1		18		clc		                clc
.8ba2		69 06		adc #$06	                adc #6
.8ba4		aa		tax		                tax
.8ba5		60		rts		                rts
.8ba6						_do_do:
.8ba6		e8		inx		                inx             ; clear flag from EQUAL off stack
.8ba7		e8		inx		                inx             ; no RTS because this is copied into code
.8ba8						question_do_runtime_end:
.8ba8						xt_does:
.8ba8		a0 8b		ldy #$8b	                ldy #>does_runtime
.8baa		a9 b7		lda #$b7	                lda #<does_runtime
.8bac		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.8baf		a0 d7		ldy #$d7	                ldy #>dodoes
.8bb1		a9 58		lda #$58	                lda #<dodoes
.8bb3		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.8bb6		60		rts		z_does:         rts
.8bb7						does_runtime:
.8bb7		7a		ply		                ply             ; LSB
.8bb8		68		pla		                pla             ; MSB
.8bb9		c8		iny		                iny
.8bba		d0 01		bne $8bbd	                bne +
.8bbc		1a		inc a		                ina
.8bbd						+
.8bbd		84 24		sty $24		                sty tmp1
.8bbf		85 25		sta $25		                sta tmp1+1
.8bc1		20 b1 d7	jsr $d7b1	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.8bc4		a5 02		lda $02		                lda dp
.8bc6		18		clc		                clc
.8bc7		69 04		adc #$04	                adc #4
.8bc9		85 26		sta $26		                sta tmp2
.8bcb		a5 03		lda $03		                lda dp+1
.8bcd		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bcf		85 27		sta $27		                sta tmp2+1
.8bd1		b2 26		lda ($26)	                lda (tmp2)
.8bd3		18		clc		                clc
.8bd4		69 01		adc #$01	                adc #1
.8bd6		85 28		sta $28		                sta tmp3
.8bd8		a0 01		ldy #$01	                ldy #1
.8bda		b1 26		lda ($26),y	                lda (tmp2),y
.8bdc		69 00		adc #$00	                adc #0          ; we only care about the carry
.8bde		85 29		sta $29		                sta tmp3+1
.8be0		a5 24		lda $24		                lda tmp1        ; LSB
.8be2		92 28		sta ($28)	                sta (tmp3)
.8be4		a5 25		lda $25		                lda tmp1+1
.8be6		91 28		sta ($28),y	                sta (tmp3),y    ; Y is still 1
.8be8		60		rts		                rts
.8be9						xt_dot:
.8be9		20 6f d8	jsr $d86f	                jsr underflow_1
.8bec		20 62 8d	jsr $8d62	                jsr xt_dup                      ; ( n n )
.8bef		20 cd 80	jsr $80cd	                jsr xt_abs                      ; ( n u )
.8bf2		20 56 a7	jsr $a756	                jsr xt_zero                     ; ( n u 0 )
.8bf5		20 3b 93	jsr $933b	                jsr xt_less_number_sign         ; ( n u 0 )
.8bf8		20 c2 97	jsr $97c2	                jsr xt_number_sign_s            ; ( n ud )
.8bfb		20 34 9b	jsr $9b34	                jsr xt_rot                      ; ( ud n )
.8bfe		20 95 9f	jsr $9f95	                jsr xt_sign                     ; ( ud )
.8c01		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater      ; ( addr u )
.8c04		20 a7 a4	jsr $a4a7	                jsr xt_type
.8c07		20 cc a0	jsr $a0cc	                jsr xt_space
.8c0a		60		rts		z_dot:          rts
.8c0b						xt_dot_paren:
.8c0b		ca		dex		                dex
.8c0c		ca		dex		                dex
.8c0d		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8c0f		95 00		sta $00,x	                sta 0,x
.8c11		74 01		stz $01,x	                stz 1,x
.8c13		20 1e 99	jsr $991e	                jsr xt_parse
.8c16		20 a7 a4	jsr $a4a7	                jsr xt_type
.8c19		60		rts		z_dot_paren:    rts
.8c1a						xt_dot_quote:
.8c1a		20 2c 9d	jsr $9d2c	                jsr xt_s_quote
.8c1d		a0 a4		ldy #$a4	                ldy #>xt_type
.8c1f		a9 a7		lda #$a7	                lda #<xt_type
.8c21		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.8c24		60		rts		z_dot_quote:    rts
.8c25						xt_dot_r:
.8c25		20 74 d8	jsr $d874	                jsr underflow_2
.8c28		20 14 a3	jsr $a314	                jsr xt_to_r
.8c2b		20 62 8d	jsr $8d62	                jsr xt_dup
.8c2e		20 cd 80	jsr $80cd	                jsr xt_abs
.8c31		20 56 a7	jsr $a756	                jsr xt_zero
.8c34		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8c37		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.8c3a		20 34 9b	jsr $9b34	                jsr xt_rot
.8c3d		20 95 9f	jsr $9f95	                jsr xt_sign
.8c40		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.8c43		20 76 9a	jsr $9a76	                jsr xt_r_from
.8c46		20 77 98	jsr $9877	                jsr xt_over
.8c49		20 34 95	jsr $9534	                jsr xt_minus
.8c4c		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.8c4f		20 a7 a4	jsr $a4a7	                jsr xt_type
.8c52		60		rts		z_dot_r:        rts
.8c53						xt_dot_s:
.8c53		20 bd 8a	jsr $8abd	                jsr xt_depth    ; ( -- u )
.8c56		a9 3c		lda #$3c	                lda #$3c        ; ASCII for "<"
.8c58		20 db 8d	jsr $8ddb	                jsr emit_a
.8c5b		b5 00		lda $00,x	                lda 0,x
.8c5d		48		pha		                pha
.8c5e		ca		dex		                dex             ; DUP
.8c5f		ca		dex		                dex
.8c60		95 00		sta $00,x	                sta 0,x
.8c62		74 01		stz $01,x	                stz 1,x
.8c64		20 dc d8	jsr $d8dc	                jsr print_u
.8c67		a9 3e		lda #$3e	                lda #$3e        ; ASCII for ">"
.8c69		20 db 8d	jsr $8ddb	                jsr emit_a
.8c6c		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.8c6e		20 db 8d	jsr $8ddb	                jsr emit_a
.8c71		e8		inx		                inx
.8c72		e8		inx		                inx
.8c73		e0 78		cpx #$78	                cpx #dsp0
.8c75		f0 1e		beq $8c95	                beq _done
.8c77						_have_stack:
.8c77		7a		ply		                ply
.8c78		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.8c7a		85 28		sta $28		                sta tmp3
.8c7c		64 29		stz $29		                stz tmp3+1      ; must be zero page on the 65c02
.8c7e						_loop:
.8c7e		ca		dex		                dex
.8c7f		ca		dex		                dex
.8c80		b2 28		lda ($28)	                lda (tmp3)
.8c82		95 01		sta $01,x	                sta 1,x
.8c84		c6 28		dec $28		                dec tmp3
.8c86		b2 28		lda ($28)	                lda (tmp3)
.8c88		95 00		sta $00,x	                sta 0,x
.8c8a		c6 28		dec $28		                dec tmp3
.8c8c		5a		phy		                phy
.8c8d		20 e9 8b	jsr $8be9	                jsr xt_dot
.8c90		7a		ply		                ply
.8c91		88		dey		                dey
.8c92		d0 ea		bne $8c7e	                bne _loop
.8c94		48		pha		                pha             ; dummy to balance stack
.8c95						_done:
.8c95		68		pla		                pla
.8c96		60		rts		z_dot_s:        rts
.8c97						xt_d_dot:
.8c97		20 74 d8	jsr $d874	                jsr underflow_2
.8c9a		20 31 a3	jsr $a331	                jsr xt_tuck
.8c9d		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.8ca0		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8ca3		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.8ca6		20 34 9b	jsr $9b34	                jsr xt_rot
.8ca9		20 95 9f	jsr $9f95	                jsr xt_sign
.8cac		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.8caf		20 a7 a4	jsr $a4a7	                jsr xt_type
.8cb2		20 cc a0	jsr $a0cc	                jsr xt_space
.8cb5		60		rts		z_d_dot:        rts
.8cb6						xt_d_dot_r:
.8cb6		20 79 d8	jsr $d879	                jsr underflow_3
.8cb9		20 14 a3	jsr $a314	                jsr xt_to_r
.8cbc		20 31 a3	jsr $a331	                jsr xt_tuck
.8cbf		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.8cc2		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.8cc5		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.8cc8		20 34 9b	jsr $9b34	                jsr xt_rot
.8ccb		20 95 9f	jsr $9f95	                jsr xt_sign
.8cce		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.8cd1		20 76 9a	jsr $9a76	                jsr xt_r_from
.8cd4		20 77 98	jsr $9877	                jsr xt_over
.8cd7		20 34 95	jsr $9534	                jsr xt_minus
.8cda		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.8cdd		20 a7 a4	jsr $a4a7	                jsr xt_type
.8ce0		60		rts		z_d_dot_r:      rts
.8ce1						xt_drop:
.8ce1		20 6f d8	jsr $d86f	                jsr underflow_1
.8ce4		e8		inx		                inx
.8ce5		e8		inx		                inx
.8ce6		60		rts		z_drop:         rts
.8ce7						xt_dump:
.8ce7		20 74 d8	jsr $d874	                jsr underflow_2
.8cea						_row:
.8cea		a0 10		ldy #$10	                ldy #16
.8cec		64 26		stz $26		                stz tmp2
.8cee		20 2a 89	jsr $892a	                jsr xt_cr
.8cf1		b5 03		lda $03,x	                lda 3,x
.8cf3		20 7f d7	jsr $d77f	                jsr byte_to_ascii
.8cf6		b5 02		lda $02,x	                lda 2,x
.8cf8		20 7f d7	jsr $d77f	                jsr byte_to_ascii
.8cfb		20 cc a0	jsr $a0cc	                jsr xt_space
.8cfe		20 cc a0	jsr $a0cc	                jsr xt_space
.8d01						_loop:
.8d01		b5 00		lda $00,x	                lda 0,x
.8d03		15 01		ora $01,x	                ora 1,x
.8d05		f0 39		beq $8d40	                beq _all_printed
.8d07		a1 02		lda ($02,x)	                lda (2,x)
.8d09		48		pha		                pha                     ; byte_to_ascii destroys A
.8d0a		20 7f d7	jsr $d77f	                jsr byte_to_ascii
.8d0d		20 cc a0	jsr $a0cc	                jsr xt_space
.8d10		68		pla		                pla
.8d11		20 55 d8	jsr $d855	                jsr is_printable
.8d14		b0 02		bcs $8d18	                bcs _printable
.8d16		a9 2e		lda #$2e	                lda #'.'                 ; Print dot if not printable
.8d18						_printable:
.8d18		5a		phy		                phy                     ; save counter
.8d19		a4 26		ldy $26		                ldy tmp2
.8d1b		91 00		sta ($00),y	                sta (cp),y
.8d1d		e6 26		inc $26		                inc tmp2
.8d1f		7a		ply		                ply
.8d20		c0 09		cpy #$09	                cpy #9
.8d22		d0 03		bne $8d27	                bne _next_char
.8d24		20 cc a0	jsr $a0cc	                jsr xt_space
.8d27						_next_char:
.8d27		f6 02		inc $02,x	                inc 2,x
.8d29		d0 02		bne $8d2d	                bne _counter
.8d2b		f6 03		inc $03,x	                inc 3,x
.8d2d						_counter:
.8d2d		b5 00		lda $00,x	                lda 0,x
.8d2f		d0 02		bne $8d33	                bne +
.8d31		d6 01		dec $01,x	                dec 1,x
.8d33						+
.8d33		d6 00		dec $00,x	                dec 0,x
.8d35		88		dey		                dey
.8d36		d0 c9		bne $8d01	                bne _loop               ; next byte
.8d38		20 cc a0	jsr $a0cc	                jsr xt_space
.8d3b		20 4e 8d	jsr $8d4e	                jsr dump_print_ascii
.8d3e		80 aa		bra $8cea	                bra _row                ; new row
.8d40						_all_printed:
.8d40		a5 26		lda $26		                lda tmp2
.8d42		f0 06		beq $8d4a	                beq _done
.8d44		20 cc a0	jsr $a0cc	                jsr xt_space
.8d47		20 4e 8d	jsr $8d4e	                jsr dump_print_ascii
.8d4a						_done:
.8d4a		20 54 a3	jsr $a354	                jsr xt_two_drop         ; one byte less than 4x INX
.8d4d		60		rts		z_dump:         rts
.8d4e						dump_print_ascii:
.8d4e		a0 00		ldy #$00	                ldy #0
.8d50						_ascii_loop:
.8d50		b1 00		lda ($00),y	                lda (cp),y
.8d52		20 db 8d	jsr $8ddb	                jsr emit_a
.8d55		c8		iny		                iny
.8d56		c0 08		cpy #$08	                cpy #8
.8d58		d0 03		bne $8d5d	                bne +
.8d5a		20 cc a0	jsr $a0cc	                jsr xt_space
.8d5d						+
.8d5d		c6 26		dec $26		                dec tmp2
.8d5f		d0 ef		bne $8d50	                bne _ascii_loop
.8d61		60		rts		                rts
.8d62						xt_dup:
.8d62		20 6f d8	jsr $d86f	                jsr underflow_1
.8d65		ca		dex		                dex
.8d66		ca		dex		                dex
.8d67		b5 02		lda $02,x	                lda 2,x         ; LSB
.8d69		95 00		sta $00,x	                sta 0,x
.8d6b		b5 03		lda $03,x	                lda 3,x         ; MSB
.8d6d		95 01		sta $01,x	                sta 1,x
.8d6f		60		rts		z_dup:          rts
.8d70						xt_ed:
.8d70		20 c1 b5	jsr $b5c1	                jsr ed6502      ; kept in separate file
.8d73		60		rts		z_ed:           rts
.8d74						xt_else:
.8d74						xt_endof:
.8d74		a9 4c		lda #$4c	                lda #$4c        ; jmp opcode
.8d76		20 22 d7	jsr $d722	                jsr cmpl_a
.8d79		20 57 91	jsr $9157	                jsr xt_here
.8d7c		20 56 a7	jsr $a756	                jsr xt_zero
.8d7f		20 24 87	jsr $8724	                jsr xt_comma
.8d82		20 5c a1	jsr $a15c	                jsr xt_swap         ; ( target orig )
.8d85						xt_then:
.8d85		20 57 91	jsr $9157	                jsr xt_here
.8d88		a1 02		lda ($02,x)	                lda (2,x)           ; get LSB at orig
.8d8a		1a		inc a		                ina                 ; was LSB $ff?  (only check for $xxff)
.8d8b		d0 3b		bne $8dc8	                bne _no_opt
.8d8d		20 5c a3	jsr $a35c	                jsr xt_two_dup
.8d90		20 5c a1	jsr $a15c	                jsr xt_swap
.8d93		20 34 95	jsr $9534	                jsr xt_minus        ; ( C: orig here offset )
.8d96		b5 01		lda $01,x	                lda 1,x
.8d98		d0 2c		bne $8dc6	                bne _too_far        ; MSB must be zero
.8d9a		b5 00		lda $00,x	                lda 0,x
.8d9c		3a		dec a		                dea                 ; we want here - orig - 2
.8d9d		3a		dec a		                dea                 ; don't care about carry
.8d9e		30 26		bmi $8dc6	                bmi _too_far        ; up to 127 is ok
.8da0		95 00		sta $00,x	                sta 0,x             ; stash offset - 2
.8da2		38		sec		                sec                 ; put orig - 2 in tmp1
.8da3		b5 04		lda $04,x	                lda 4,x
.8da5		e9 02		sbc #$02	                sbc #2
.8da7		85 24		sta $24		                sta tmp1
.8da9		b5 05		lda $05,x	                lda 5,x
.8dab		e9 00		sbc #$00	                sbc #0
.8dad		85 25		sta $25		                sta tmp1+1
.8daf		a0 00		ldy #$00	                ldy #0
.8db1						-
.8db1		b9 d0 8d	lda $8dd0,y	                lda beq_opt+1,y               ; skip the jsr
.8db4		91 24		sta ($24),y	                sta (tmp1),y
.8db6		c8		iny		                iny
.8db7		c0 03		cpy #$03	                cpy #(beq_opt_end-beq_opt-2)  ; three bytes, skip jsr and offset
.8db9		d0 f6		bne $8db1	                bne -
.8dbb		b5 00		lda $00,x	                lda 0,x             ; write the offset
.8dbd		91 24		sta ($24),y	                sta (tmp1),y
.8dbf		e8		inx		                inx                 ; clear the stack
.8dc0		e8		inx		                inx
.8dc1		e8		inx		                inx
.8dc2		e8		inx		                inx
.8dc3		e8		inx		                inx
.8dc4		e8		inx		                inx
.8dc5		60		rts		                rts                 ; all done
.8dc6						_too_far:
.8dc6		e8		inx		                inx                 ; discard the offset we calculated
.8dc7		e8		inx		                inx
.8dc8						_no_opt:
.8dc8		20 5c a1	jsr $a15c	                jsr xt_swap
.8dcb		20 3b a1	jsr $a13b	                jsr xt_store
.8dce						z_else:
.8dce						z_endof:
.8dce		60		rts		z_then:         rts
.8dcf						beq_opt:
.8dcf		20 f7 91	jsr $91f7	                jsr zero_test_runtime       ; replaces jsr zero_branch_runtime
.8dd2		f0 00		beq $8dd4	                beq beq_opt_end             ; the beq overwrites the placeholder
.8dd4						beq_opt_end:
.8dd4						xt_emit:
.8dd4		20 6f d8	jsr $d86f	                jsr underflow_1
.8dd7		b5 00		lda $00,x	                lda 0,x
.8dd9		e8		inx		                inx
.8dda		e8		inx		                inx
.8ddb						emit_a:
.8ddb		6c 10 00	jmp ($0010)	                jmp (output)            ; JSR/RTS
.8dde						z_emit:
.8dde						xt_empty_buffers:
.8dde		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.8de0		a9 00		lda #$00	                lda #0
.8de2		91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.8de4						z_empty_buffers:
.8de4		60		rts		                rts
.8de5						xt_endcase:
.8de5		a0 8c		ldy #$8c	                ldy #>xt_drop
.8de7		a9 e1		lda #$e1	                lda #<xt_drop
.8de9		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.8dec						_endcase_loop:
.8dec		b5 00		lda $00,x	                lda 0,x
.8dee		15 01		ora $01,x	                ora 1,x
.8df0		f0 05		beq $8df7	                beq _done
.8df2		20 85 8d	jsr $8d85	                jsr xt_then
.8df5		80 f5		bra $8dec	                bra _endcase_loop
.8df7						_done:
.8df7		e8		inx		                inx
.8df8		e8		inx		                inx
.8df9		60		rts		z_endcase:      rts
.8dfa						xt_environment_q:
.8dfa		20 6f d8	jsr $d86f	                jsr underflow_1
.8dfd		a0 00		ldy #$00	                ldy #00                 ; counter for table
.8dff		5a		phy		                phy
.8e00						_table_loop:
.8e00		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.8e03		ca		dex		                dex
.8e04		ca		dex		                dex                     ; ( addr u addr u ? )
.8e05		b9 77 8e	lda $8e77,y	                lda env_table_single,y
.8e08		95 00		sta $00,x	                sta 0,x
.8e0a		c8		iny		                iny
.8e0b		b9 77 8e	lda $8e77,y	                lda env_table_single,y
.8e0e		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.8e10		c8		iny		                iny
.8e11		15 00		ora $00,x	                ora 0,x
.8e13		f0 4d		beq $8e62	                beq _table_done
.8e15		5a		phy		                phy                     ; save Y, which is used by COUNT
.8e16		20 16 89	jsr $8916	                jsr xt_count            ; ( addr u addr u addr-s u-s )
.8e19		20 3e 87	jsr $873e	                jsr xt_compare          ; ( addr u f )
.8e1c		7a		ply		                ply
.8e1d		b5 00		lda $00,x	                lda 0,x
.8e1f		15 01		ora $01,x	                ora 1,x
.8e21		f0 04		beq $8e27	                beq _got_result
.8e23		e8		inx		                inx                     ; DROP, now ( addr u )
.8e24		e8		inx		                inx
.8e25		80 d9		bra $8e00	                bra _table_loop
.8e27						_got_result:
.8e27		e8		inx		                inx                     ; drop flag, now ( addr u )
.8e28		e8		inx		                inx
.8e29		88		dey		                dey                     ; go back to index we had
.8e2a		88		dey		                dey
.8e2b		68		pla		                pla
.8e2c		d0 0d		bne $8e3b	                bne _double_result
.8e2e		b9 95 8e	lda $8e95,y	                lda env_results_single,y
.8e31		95 02		sta $02,x	                sta 2,x
.8e33		c8		iny		                iny
.8e34		b9 95 8e	lda $8e95,y	                lda env_results_single,y
.8e37		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.8e39		80 1f		bra $8e5a	                bra _set_flag
.8e3b						_double_result:
.8e3b		ca		dex		                dex                     ; ( addr u ? )
.8e3c		ca		dex		                dex
.8e3d		98		tya		                tya
.8e3e		38		sec		                sec
.8e3f		e9 18		sbc #$18	                sbc #24
.8e41		0a		asl a		                asl
.8e42		a8		tay		                tay
.8e43		b9 ab 8e	lda $8eab,y	                lda env_results_double,y
.8e46		95 02		sta $02,x	                sta 2,x
.8e48		c8		iny		                iny
.8e49		b9 ab 8e	lda $8eab,y	                lda env_results_double,y
.8e4c		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.8e4e		c8		iny		                iny
.8e4f		b9 ab 8e	lda $8eab,y	                lda env_results_double,y
.8e52		95 04		sta $04,x	                sta 4,x
.8e54		c8		iny		                iny
.8e55		b9 ab 8e	lda $8eab,y	                lda env_results_double,y
.8e58		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8e5a						_set_flag:
.8e5a		a9 ff		lda #$ff	                lda #$ff
.8e5c		95 00		sta $00,x	                sta 0,x
.8e5e		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8e60		80 14		bra $8e76	                bra _done
.8e62						_table_done:
.8e62		68		pla		                pla
.8e63		d0 09		bne $8e6e	                bne _no_match
.8e65		1a		inc a		                ina
.8e66		48		pha		                pha
.8e67		8a		txa		                txa
.8e68		18		clc		                clc
.8e69		69 06		adc #$06	                adc #6                  ; skip six bytes
.8e6b		aa		tax		                tax                     ; ( addr u )
.8e6c		80 92		bra $8e00	                bra _table_loop
.8e6e						_no_match:
.8e6e		8a		txa		                txa
.8e6f		18		clc		                clc
.8e70		69 0a		adc #$0a	                adc #10
.8e72		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.8e73		20 5e 8f	jsr $8f5e	                jsr xt_false
.8e76						_done:
.8e76						z_environment_q:
.8e76		60		rts		                rts
.8e77						env_table_single:
>8e77		92 d6 a2 d6 a8 d6 ad d6		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8e7f		bf d6
>8e81		c7 d6 d0 d6 d6 d6 dc d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8e89		ef d6 fb d6 00 00		        .word envs_sc, envs_wl, 0000
.8e8f						env_table_double:
>8e8f		05 d7 0b d7 00 00		        .word envs_max_d, envs_max_ud, 0000
.8e95						env_results_single:
>8e95		ff 00				        .word $00FF     ; /COUNTED-STRING
>8e97		ff 00				        .word $00FF     ; /HOLD
>8e99		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8e9b		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8e9d		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8e9f		ff 00				        .word $00FF     ; MAX-CHAR
>8ea1		ff 7f				        .word $7FFF     ; MAX-N
>8ea3		ff ff				        .word $FFFF     ; MAX-U
>8ea5		80 00				        .word $0080     ; RETURN-STACK-CELLS
>8ea7		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8ea9		09 00				        .word $0009     ; WORDLISTS
.8eab						env_results_double:
>8eab		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8eaf		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.8eb3						xt_equal:
.8eb3		20 74 d8	jsr $d874	                jsr underflow_2
.8eb6		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8eb8		d5 02		cmp $02,x	                cmp 2,x
.8eba		d0 0a		bne $8ec6	                bne _false
.8ebc		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8ebe		d5 03		cmp $03,x	                cmp 3,x
.8ec0		d0 04		bne $8ec6	                bne _false
.8ec2		a9 ff		lda #$ff	                lda #$ff
.8ec4		80 02		bra $8ec8	                bra _done
.8ec6		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.8ec8		95 02		sta $02,x	_done:          sta 2,x
.8eca		95 03		sta $03,x	                sta 3,x
.8ecc		e8		inx		                inx
.8ecd		e8		inx		                inx
.8ece		60		rts		z_equal:        rts
.8ecf						xt_blank:
.8ecf		ca		dex		                dex
.8ed0		ca		dex		                dex
.8ed1		a9 20		lda #$20	                lda #AscSP
.8ed3		95 00		sta $00,x	                sta 0,x
.8ed5		74 01		stz $01,x	                stz 1,x
.8ed7		80 06		bra $8edf	                bra xt_fill     ; skip over code for ERASE
.8ed9						xt_erase:
.8ed9		ca		dex		                dex
.8eda		ca		dex		                dex
.8edb		74 00		stz $00,x	                stz 0,x
.8edd		74 01		stz $01,x	                stz 1,x
.8edf						xt_fill:
.8edf		20 79 d8	jsr $d879	                jsr underflow_3
.8ee2		b5 04		lda $04,x	                lda 4,x         ; LSB
.8ee4		85 24		sta $24		                sta tmp1
.8ee6		b5 05		lda $05,x	                lda 5,x
.8ee8		85 25		sta $25		                sta tmp1+1
.8eea		b5 02		lda $02,x	                lda 2,x
.8eec		85 26		sta $26		                sta tmp2
.8eee		b5 03		lda $03,x	                lda 3,x
.8ef0		85 27		sta $27		                sta tmp2+1
.8ef2		b5 00		lda $00,x	                lda 0,x
.8ef4		a8		tay		                tay
.8ef5						_loop:
.8ef5		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.8ef7		c5 25		cmp $25		                cmp tmp1+1
.8ef9		90 21		bcc $8f1c	                bcc _done               ; RAM_END < TMP1, so leave
.8efb		d0 06		bne $8f03	                bne _check_counter      ; RAM_END is not smaller and not equal
.8efd		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.8eff		c5 24		cmp $24		                cmp tmp1
.8f01		90 19		bcc $8f1c	                bcc _done               ; RAM_END < TMP1, so leave
.8f03						_check_counter:
.8f03		a5 26		lda $26		                lda tmp2
.8f05		05 27		ora $27		                ora tmp2+1
.8f07		f0 13		beq $8f1c	                beq _done
.8f09		98		tya		                tya
.8f0a		92 24		sta ($24)	                sta (tmp1)
.8f0c		a5 26		lda $26		                lda tmp2
.8f0e		d0 02		bne $8f12	                bne +
.8f10		c6 27		dec $27		                dec tmp2+1
.8f12		c6 26		dec $26		+               dec tmp2
.8f14		e6 24		inc $24		                inc tmp1
.8f16		d0 dd		bne $8ef5	                bne _loop
.8f18		e6 25		inc $25		                inc tmp1+1
.8f1a		80 d9		bra $8ef5	                bra _loop
.8f1c						_done:
.8f1c		8a		txa		                txa
.8f1d		18		clc		                clc
.8f1e		69 06		adc #$06	                adc #6
.8f20		aa		tax		                tax
.8f21						z_blank:
.8f21						z_erase:
.8f21		60		rts		z_fill:         rts
.8f22						xt_execute:
.8f22		20 6f d8	jsr $d86f	                jsr underflow_1
.8f25		20 29 8f	jsr $8f29	                jsr doexecute   ; do not combine to JMP (native coding)
.8f28		60		rts		z_execute:      rts
.8f29						doexecute:
.8f29		b5 00		lda $00,x	                lda 0,x
.8f2b		85 0e		sta $0e		                sta ip
.8f2d		b5 01		lda $01,x	                lda 1,x
.8f2f		85 0f		sta $0f		                sta ip+1
.8f31		e8		inx		                inx
.8f32		e8		inx		                inx
.8f33		6c 0e 00	jmp ($000e)	                jmp (ip)
.8f36						xt_execute_parsing:
.8f36		20 79 d8	jsr $d879	                jsr underflow_3
.8f39		20 43 92	jsr $9243	                jsr xt_input_to_r       ; save normal input for later
.8f3c		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( xt addr u )
.8f3f		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.8f41		85 0a		sta $0a		                sta ciblen
.8f43		b5 01		lda $01,x	                lda 1,x
.8f45		85 0b		sta $0b		                sta ciblen+1
.8f47		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.8f49		85 08		sta $08		                sta cib
.8f4b		b5 03		lda $03,x	                lda 3,x
.8f4d		85 09		sta $09		                sta cib+1
.8f4f		64 0c		stz $0c		                stz toin                ; Set >IN to zero
.8f51		64 0d		stz $0d		                stz toin+1
.8f53		20 54 a3	jsr $a354	                jsr xt_two_drop         ; 2DROP ( xt )
.8f56		20 22 8f	jsr $8f22	                jsr xt_execute
.8f59		20 87 9a	jsr $9a87	                jsr xt_r_to_input
.8f5c						z_execute_parsing:
.8f5c		60		rts		                rts
.8f5d						xt_exit:
.8f5d		60		rts		                rts             ; keep before z_exit
.8f5e						z_exit:
.8f5e						xt_false:
.8f5e		ca		dex		                dex
.8f5f		ca		dex		                dex
.8f60		74 00		stz $00,x	                stz 0,x
.8f62		74 01		stz $01,x	                stz 1,x
.8f64		60		rts		z_false:        rts
.8f65						xt_fetch:
.8f65		20 6f d8	jsr $d86f	                jsr underflow_1
.8f68		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.8f6a		a8		tay		                tay
.8f6b		f6 00		inc $00,x	                inc 0,x
.8f6d		d0 02		bne $8f71	                bne +
.8f6f		f6 01		inc $01,x	                inc 1,x
.8f71						+
.8f71		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.8f73		95 01		sta $01,x	                sta 1,x
.8f75		94 00		sty $00,x	                sty 0,x
.8f77		60		rts		z_fetch:        rts
.8f78						xt_find:
.8f78		20 6f d8	jsr $d86f	                jsr underflow_1
.8f7b		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8f7d		48		pha		                pha
.8f7e		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8f80		48		pha		                pha
.8f81		20 16 89	jsr $8916	                jsr xt_count            ; ( caddr -- addr u )
.8f84		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( addr u -- nt | 0 )
.8f87		b5 00		lda $00,x	                lda 0,x
.8f89		15 01		ora $01,x	                ora 1,x
.8f8b		d0 0b		bne $8f98	                bne _found_word
.8f8d		20 5e 8f	jsr $8f5e	                jsr xt_false            ; ( 0 0 )
.8f90		68		pla		                pla                     ; LSB of address
.8f91		95 02		sta $02,x	                sta 2,x
.8f93		68		pla		                pla
.8f94		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8f96		80 27		bra $8fbf	                bra _done               ; ( addr 0 )
.8f98						_found_word:
.8f98		68		pla		                pla
.8f99		68		pla		                pla
.8f9a		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.8f9d		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt xt )
.8fa0		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( xt nt )
.8fa3		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8fa5		f6 00		inc $00,x	                inc 0,x
.8fa7		d0 02		bne $8fab	                bne +
.8fa9		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.8fab						+
.8fab		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.8fad		29 04		and #$04	                and #IM
.8faf		d0 08		bne $8fb9	                bne _immediate          ; bit set, we're immediate
.8fb1		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8fb3		95 00		sta $00,x	                sta 0,x
.8fb5		95 01		sta $01,x	                sta 1,x
.8fb7		80 06		bra $8fbf	                bra _done
.8fb9						_immediate:
.8fb9		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.8fbb		95 00		sta $00,x	                sta 0,x
.8fbd		74 01		stz $01,x	                stz 1,x
.8fbf						_done:
.8fbf		60		rts		z_find:         rts
.8fc0						xt_find_name:
.8fc0		20 74 d8	jsr $d874	                jsr underflow_2
.8fc3		b5 00		lda $00,x	                lda 0,x
.8fc5		15 01		ora $01,x	                ora 1,x
.8fc7		d0 03		bne $8fcc	                bne _nonempty
.8fc9		4c 65 90	jmp $9065	                jmp _fail_done
.8fcc						_nonempty:
.8fcc		64 28		stz $28		                stz tmp3                ; Start at the beginning
.8fce						_wordlist_loop:
.8fce		a0 1e		ldy #$1e	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.8fd0		a5 28		lda $28		                lda tmp3
.8fd2		d1 1e		cmp ($1e),y	                cmp (up),y              ; Check to see if we are done
.8fd4		d0 03		bne $8fd9	                bne _have_string
.8fd6		4c 65 90	jmp $9065	                jmp _fail_done
.8fd9						_have_string:
.8fd9		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.8fda		69 1f		adc #$1f	                adc #search_order_offset
.8fdc		a8		tay		                tay
.8fdd		b1 1e		lda ($1e),y	                lda (up),y      ; Get the id byte, which is the offset
.8fdf		0a		asl a		                asl                     ; Turn offset into cells offset.
.8fe0		18		clc		                clc
.8fe1		69 06		adc #$06	                adc #wordlists_offset
.8fe3		a8		tay		                tay
.8fe4		b1 1e		lda ($1e),y	                lda (up),y
.8fe6		85 24		sta $24		                sta tmp1
.8fe8		c8		iny		                iny
.8fe9		b1 1e		lda ($1e),y	                lda (up),y
.8feb		85 25		sta $25		                sta tmp1+1
.8fed		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.8fef		85 26		sta $26		                sta tmp2
.8ff1		b5 03		lda $03,x	                lda 3,x
.8ff3		85 27		sta $27		                sta tmp2+1
.8ff5						_loop:
.8ff5		b2 24		lda ($24)	                lda (tmp1)
.8ff7		d5 00		cmp $00,x	                cmp 0,x
.8ff9		d0 54		bne $904f	                bne _next_entry
.8ffb						_compare_string:
.8ffb		b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.8ffd		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.8fff		b0 07		bcs $9008	                bcs _compare_first
.9001		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9003		90 03		bcc $9008	                bcc _compare_first
.9005		18		clc		                clc
.9006		69 20		adc #$20	                adc #$20
.9008						_compare_first:
.9008		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.900a		d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.900c		d0 41		bne $904f	                bne _next_entry
.900e		b5 00		lda $00,x	                lda 0,x
.9010		3a		dec a		                dea
.9011		f0 2c		beq $903f	                beq _success
.9013		a5 24		lda $24		                lda tmp1
.9015		48		pha		                pha             ; Preserve tmp1 on the return stack.
.9016		18		clc		                clc
.9017		69 08		adc #$08	                adc #8
.9019		85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.901b		a5 25		lda $25		                lda tmp1+1
.901d		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.901e		69 00		adc #$00	                adc #0          ; we only need the carry
.9020		85 25		sta $25		                sta tmp1+1
.9022		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9024		88		dey		                dey
.9025						_string_loop:
.9025		b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9027		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9029		b0 07		bcs $9032	                bcs _check_char
.902b		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.902d		90 03		bcc $9032	                bcc _check_char
.902f		18		clc		                clc
.9030		69 20		adc #$20	                adc #$20
.9032						_check_char:
.9032		d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9034		d0 13		bne $9049	                bne _next_entry_tmp1
.9036		88		dey		                dey
.9037		d0 ec		bne $9025	                bne _string_loop
.9039						_success_tmp1:
.9039		68		pla		                pla             ; Restore tmp1 from the return stack.
.903a		85 25		sta $25		                sta tmp1+1
.903c		68		pla		                pla
.903d		85 24		sta $24		                sta tmp1
.903f						_success:
.903f		a5 24		lda $24		                lda tmp1
.9041		95 02		sta $02,x	                sta 2,x
.9043		a5 25		lda $25		                lda tmp1+1
.9045		95 03		sta $03,x	                sta 3,x
.9047		80 20		bra $9069	                bra _done
.9049						_next_entry_tmp1:
.9049		68		pla		                pla             ; Restore tmp1 from the return stack.
.904a		85 25		sta $25		                sta tmp1+1
.904c		68		pla		                pla
.904d		85 24		sta $24		                sta tmp1
.904f						_next_entry:
.904f		a0 02		ldy #$02	                ldy #2
.9051		b1 24		lda ($24),y	                lda (tmp1),y
.9053		48		pha		                pha
.9054		c8		iny		                iny
.9055		b1 24		lda ($24),y	                lda (tmp1),y
.9057		85 25		sta $25		                sta tmp1+1
.9059		68		pla		                pla
.905a		85 24		sta $24		                sta tmp1
.905c		05 25		ora $25		                ora tmp1+1
.905e		d0 95		bne $8ff5	                bne _loop
.9060		e6 28		inc $28		                inc tmp3
.9062		4c ce 8f	jmp $8fce	                jmp _wordlist_loop
.9065						_fail_done:
.9065		74 02		stz $02,x	                stz 2,x         ; failure flag
.9067		74 03		stz $03,x	                stz 3,x
.9069						_done:
.9069		e8		inx		                inx
.906a		e8		inx		                inx
.906b		60		rts		z_find_name:    rts
.906c						xt_flush:
.906c		20 6c 9e	jsr $9e6c	                jsr xt_save_buffers
.906f		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9071		a9 00		lda #$00	                lda #0
.9073		91 1e		sta ($1e),y	                sta (up),y      ; Only LSB is used.
.9075						z_flush:
.9075		60		rts		                rts
.9076						xt_fm_slash_mod:
.9076		20 79 d8	jsr $d879	                jsr underflow_3
.9079		64 26		stz $26		                stz tmp2        ; default: n is positive
.907b		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.907d		10 0e		bpl $908d	                bpl _check_d
.907f		e6 26		inc $26		                inc tmp2        ; set flag to negative for n1
.9081		20 07 96	jsr $9607	                jsr xt_negate   ; NEGATE
.9084		20 14 a3	jsr $a314	                jsr xt_to_r     ; >R
.9087		20 08 8b	jsr $8b08	                jsr xt_dnegate  ; DNEGATE
.908a		20 76 9a	jsr $9a76	                jsr xt_r_from   ; R>
.908d						_check_d:
.908d		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.908f		10 0d		bpl $909e	                bpl _multiply
.9091		18		clc		                clc
.9092		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.9094		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.9096		95 02		sta $02,x	                sta 2,x
.9098		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.909a		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.909c		95 03		sta $03,x	                sta 3,x
.909e						_multiply:
.909e		20 5e a5	jsr $a55e	                jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
.90a1		a5 26		lda $26		                lda tmp2
.90a3		f0 07		beq $90ac	                beq _done
.90a5		e8		inx		                inx             ; pretend that we SWAP
.90a6		e8		inx		                inx
.90a7		20 07 96	jsr $9607	                jsr xt_negate
.90aa		ca		dex		                dex
.90ab		ca		dex		                dex
.90ac						_done:
.90ac		60		rts		z_fm_slash_mod: rts
.90ad						xt_forth:
.90ad		a0 1f		ldy #$1f	                ldy #search_order_offset
.90af		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.90b1		91 1e		sta ($1e),y	                sta (up),y
.90b3						z_forth:
.90b3		60		rts		                rts
.90b4						load_evaluate:
.90b4		a9 ff		lda #$ff	                lda #$FF
.90b6		85 24		sta $24		                sta tmp1
.90b8		80 11		bra $90cb	                bra load_evaluate_start
.90ba						xt_evaluate:
.90ba		20 74 d8	jsr $d874	                jsr underflow_2
.90bd		64 24		stz $24		                stz tmp1
.90bf		b5 00		lda $00,x	                lda 0,x
.90c1		15 01		ora $01,x	                ora 1,x
.90c3		d0 06		bne $90cb	                bne evaluate_got_work
.90c5		e8		inx		                inx
.90c6		e8		inx		                inx
.90c7		e8		inx		                inx
.90c8		e8		inx		                inx
.90c9		80 42		bra $910d	                bra evaluate_done
.90cb						load_evaluate_start:
.90cb						evaluate_got_work:
.90cb		a0 01		ldy #$01	                ldy #blk_offset+1
.90cd		b1 1e		lda ($1e),y	                lda (up),y
.90cf		48		pha		                pha
.90d0		88		dey		                dey
.90d1		b1 1e		lda ($1e),y	                lda (up),y
.90d3		48		pha		                pha
.90d4		a5 24		lda $24		                lda tmp1
.90d6		d0 05		bne $90dd	                bne _nozero
.90d8		91 1e		sta ($1e),y	                sta (up),y
.90da		c8		iny		                iny
.90db		91 1e		sta ($1e),y	                sta (up),y
.90dd						_nozero:
.90dd		20 43 92	jsr $9243	                jsr xt_input_to_r
.90e0		a9 ff		lda #$ff	                lda #$ff
.90e2		85 06		sta $06		                sta insrc
.90e4		85 07		sta $07		                sta insrc+1
.90e6		64 0c		stz $0c		                stz toin
.90e8		64 0d		stz $0d		                stz toin+1
.90ea		b5 00		lda $00,x	                lda 0,x
.90ec		85 0a		sta $0a		                sta ciblen
.90ee		b5 01		lda $01,x	                lda 1,x
.90f0		85 0b		sta $0b		                sta ciblen+1
.90f2		b5 02		lda $02,x	                lda 2,x
.90f4		85 08		sta $08		                sta cib
.90f6		b5 03		lda $03,x	                lda 3,x
.90f8		85 09		sta $09		                sta cib+1
.90fa		e8		inx		                inx             ; A clean stack is a clean mind
.90fb		e8		inx		                inx
.90fc		e8		inx		                inx
.90fd		e8		inx		                inx
.90fe		20 d7 d7	jsr $d7d7	                jsr interpret   ; ( -- )
.9101		20 87 9a	jsr $9a87	                jsr xt_r_to_input
.9104		a0 00		ldy #$00	                ldy #blk_offset
.9106		68		pla		                pla
.9107		91 1e		sta ($1e),y	                sta (up),y
.9109		c8		iny		                iny
.910a		68		pla		                pla
.910b		91 1e		sta ($1e),y	                sta (up),y
.910d						evaluate_done:
.910d		60		rts		z_evaluate:     rts
.910e						xt_get_current:
.910e		ca		dex		                dex
.910f		ca		dex		                dex
.9110		a0 04		ldy #$04	                ldy #current_offset
.9112		b1 1e		lda ($1e),y	                lda (up),y
.9114		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.9116		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.9118		60		rts		z_get_current:  rts
.9119						xt_get_order:
.9119		a0 1e		ldy #$1e	                ldy #num_order_offset
.911b		b1 1e		lda ($1e),y	                lda (up),y
.911d		85 24		sta $24		                sta tmp1
.911f		f0 16		beq $9137	                beq _done       ; If zero, there are no wordlists.
.9121						_loop:
.9121		c6 24		dec $24		                dec tmp1        ; Count down by bytes.
.9123		a9 1f		lda #$1f	                lda #search_order_offset
.9125		18		clc		                clc
.9126		65 24		adc $24		                adc tmp1
.9128		a8		tay		                tay
.9129		ca		dex		                dex
.912a		ca		dex		                dex
.912b		b1 1e		lda ($1e),y	                lda (up),y
.912d		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.912f		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.9131		a9 00		lda #$00	                lda #0
.9133		c5 24		cmp $24		                cmp tmp1
.9135		d0 ea		bne $9121	                bne _loop
.9137						_done:
.9137		ca		dex		                dex
.9138		ca		dex		                dex
.9139		a0 1e		ldy #$1e	                ldy #num_order_offset
.913b		b1 1e		lda ($1e),y	                lda (up),y
.913d		95 00		sta $00,x	                sta 0,x
.913f		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.9141		60		rts		z_get_order:    rts
.9142						xt_greater_than:
.9142		20 74 d8	jsr $d874	                jsr underflow_2
.9145		a0 00		ldy #$00	                ldy #0          ; default false
.9147		20 96 d7	jsr $d796	                jsr compare_16bit
.914a		f0 03		beq $914f	                beq _false
.914c		10 01		bpl $914f	                bpl _false
.914e		88		dey		                dey
.914f						_false:
.914f		98		tya		                tya
.9150		e8		inx		                inx
.9151		e8		inx		                inx
.9152		95 00		sta $00,x	                sta 0,x
.9154		95 01		sta $01,x	                sta 1,x
.9156		60		rts		z_greater_than: rts
.9157						xt_here:
.9157						xt_asm_arrow:
.9157		ca		dex		                dex
.9158		ca		dex		                dex
.9159		a5 00		lda $00		                lda cp
.915b		95 00		sta $00,x	                sta 0,x
.915d		a5 01		lda $01		                lda cp+1
.915f		95 01		sta $01,x	                sta 1,x
.9161						z_asm_arrow:
.9161		60		rts		z_here:         rts
.9162						xt_hex:
.9162		a9 10		lda #$10	                lda #16
.9164		85 18		sta $18		                sta base
.9166		64 19		stz $19		                stz base+1              ; paranoid
.9168		60		rts		z_hex:          rts
.9169						xt_hexstore:
.9169		20 79 d8	jsr $d879	                jsr underflow_3
.916c		20 62 8d	jsr $8d62	                jsr xt_dup              ; Save copy of original address
.916f		20 46 a4	jsr $a446	                jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9172						_loop:
.9172		b5 00		lda $00,x	                lda 0,x
.9174		15 01		ora $01,x	                ora 1,x
.9176		f0 36		beq $91ae	                beq _done
.9178		20 02 86	jsr $8602	                jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.917b		20 46 a4	jsr $a446	                jsr xt_two_to_r
.917e		20 56 a7	jsr $a756	                jsr xt_zero
.9181		20 56 a7	jsr $a756	                jsr xt_zero
.9184		20 cc a3	jsr $a3cc	                jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9187		20 61 a2	jsr $a261	                jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.918a		b5 00		lda $00,x	                lda 0,x
.918c		15 01		ora $01,x	                ora 1,x
.918e		d0 17		bne $91a7	                bne _have_chars_left
.9190		20 54 a3	jsr $a354	                jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9193		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9196		20 61 9a	jsr $9a61	                jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9199		20 cb 85	jsr $85cb	                jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.919c		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R>
.919f		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+
.91a2		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.91a5		80 cb		bra $9172	                bra _loop
.91a7						_have_chars_left:
.91a7		8a		txa		                txa
.91a8		18		clc		                clc
.91a9		69 08		adc #$08	                adc #8
.91ab		aa		tax		                tax
.91ac		80 c4		bra $9172	                bra _loop
.91ae						_done:
.91ae		e8		inx		                inx
.91af		e8		inx		                inx
.91b0		e8		inx		                inx
.91b1		e8		inx		                inx                     ; 2DROP
.91b2		20 cc a3	jsr $a3cc	                jsr xt_two_r_from       ; ( addr2+n addr2 )
.91b5		20 5c a1	jsr $a15c	                jsr xt_swap
.91b8		20 34 95	jsr $9534	                jsr xt_minus            ; ( n )
.91bb		60		rts		z_hexstore:     rts
.91bc						xt_hold:
.91bc		20 6f d8	jsr $d86f	                jsr underflow_1
.91bf		a5 34		lda $34		                lda tohold
.91c1		d0 02		bne $91c5	                bne +
.91c3		c6 35		dec $35		                dec tohold+1
.91c5						+
.91c5		c6 34		dec $34		                dec tohold
.91c7		b5 00		lda $00,x	                lda 0,x
.91c9		92 34		sta ($34)	                sta (tohold)
.91cb		e8		inx		                inx
.91cc		e8		inx		                inx
.91cd		60		rts		z_hold:         rts
.91ce						xt_i:
.91ce		ca		dex		                dex
.91cf		ca		dex		                dex
.91d0		da		phx		                phx
.91d1		ba		tsx		                tsx
.91d2		38		sec		                sec
.91d3		bd 02 01	lda $0102,x	                lda $0102,x     ; LSB
.91d6		fd 04 01	sbc $0104,x	                sbc $0104,x
.91d9		a8		tay		                tay
.91da		bd 03 01	lda $0103,x	                lda $0103,x     ; MSB
.91dd		fd 05 01	sbc $0105,x	                sbc $0105,x
.91e0		fa		plx		                plx
.91e1		95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.91e3		94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.91e5		60		rts		z_i:            rts
.91e6						xt_if:
.91e6		a0 92		ldy #$92	                ldy #>zero_branch_runtime
.91e8		a9 01		lda #$01	                lda #<zero_branch_runtime
.91ea		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.91ed		20 57 91	jsr $9157	                jsr xt_here
.91f0		20 28 a3	jsr $a328	                jsr xt_true
.91f3		20 24 87	jsr $8724	                jsr xt_comma
.91f6		60		rts		z_if:           rts
.91f7						zero_test_runtime:
.91f7		e8		inx		                inx
.91f8		e8		inx		                inx
.91f9		b5 fe		lda $fe,x	                lda $fe,x           ; wraparound so inx doesn't wreck Z status
.91fb		15 ff		ora $ff,x	                ora $ff,x
.91fd		60		rts		                rts
.91fe		d0 03		bne $9203	                bne zero_test_footer_end+2  ; branch fwd if non-zero
>9200		4c				                .byte $4c                   ; else JMP back
.9201						zero_test_footer_end:
.9201						zero_branch_runtime:
.9201		68		pla		                pla
.9202		85 22		sta $22		                sta tmpbranch
.9204		68		pla		                pla
.9205		85 23		sta $23		                sta tmpbranch+1
.9207		b5 00		lda $00,x	                lda 0,x
.9209		15 01		ora $01,x	                ora 1,x
.920b		f0 0f		beq $921c	                beq _zero
.920d		a5 22		lda $22		                lda tmpbranch   ; LSB
.920f		18		clc		                clc
.9210		69 03		adc #$03	                adc #3          ; add one to RTS address plus two address bytes
.9212		85 24		sta $24		                sta tmp1
.9214		a5 23		lda $23		                lda tmpbranch+1 ; MSB
.9216		69 00		adc #$00	                adc #0          ; For carry
.9218		85 25		sta $25		                sta tmp1+1
.921a		80 0b		bra $9227	                bra _done
.921c						_zero:
.921c		a0 01		ldy #$01	                ldy #1
.921e		b1 22		lda ($22),y	                lda (tmpbranch),y
.9220		85 24		sta $24		                sta tmp1
.9222		c8		iny		                iny
.9223		b1 22		lda ($22),y	                lda (tmpbranch),y
.9225		85 25		sta $25		                sta tmp1+1
.9227						_done:
.9227		e8		inx		                inx
.9228		e8		inx		                inx
.9229		6c 24 00	jmp ($0024)	                jmp (tmp1)
.922c						xt_immediate:
.922c		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.922f		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.9231		b1 02		lda ($02),y	                lda (dp),y
.9233		09 04		ora #$04	                ora #IM        ; make sure bit 7 is set
.9235		91 02		sta ($02),y	                sta (dp),y
.9237		60		rts		z_immediate:    rts
.9238						xt_input:
.9238		ca		dex		                dex
.9239		ca		dex		                dex
.923a		a9 12		lda #$12	                lda #<input
.923c		95 00		sta $00,x	                sta 0,x
.923e		a9 00		lda #$00	                lda #>input
.9240		95 01		sta $01,x	                sta 1,x
.9242		60		rts		z_input:        rts
.9243						xt_input_to_r:
.9243		68		pla		                pla
.9244		85 24		sta $24		                sta tmp1
.9246		68		pla		                pla
.9247		85 25		sta $25		                sta tmp1+1
.9249		a0 07		ldy #$07	                ldy #7
.924b						_loop:
.924b		b9 06 00	lda $0006,y	                lda insrc,y     ; insrc+7 is toin+1
.924e		48		pha		                pha
.924f		88		dey		                dey
.9250		10 f9		bpl $924b	                bpl _loop
.9252		a5 25		lda $25		                lda tmp1+1
.9254		48		pha		                pha
.9255		a5 24		lda $24		                lda tmp1
.9257		48		pha		                pha
.9258		60		rts		z_input_to_r: 	rts
.9259						xt_int_to_name:
.9259		20 6f d8	jsr $d86f	                jsr underflow_1
.925c		ca		dex		                dex
.925d		ca		dex		                dex
.925e		74 00		stz $00,x	                stz 0,x
.9260		74 01		stz $01,x	                stz 1,x
.9262						_wordlist_loop:
.9262		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9264		0a		asl a		                asl                     ; Turn offset into cells offset.
.9265		18		clc		                clc
.9266		69 06		adc #$06	                adc #wordlists_offset
.9268		a8		tay		                tay
.9269		b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.926b		85 26		sta $26		                sta tmp2                ; into tmp2
.926d		c8		iny		                iny
.926e		b1 1e		lda ($1e),y	                lda (up),y
.9270		85 27		sta $27		                sta tmp2+1
.9272		a5 26		lda $26		                lda tmp2
.9274		05 27		ora $27		                ora tmp2+1
.9276		f0 38		beq $92b0	                beq _next_wordlist
.9278		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.927a		85 28		sta $28		                sta tmp3        ; Save target xt in tmp3
.927c		b5 03		lda $03,x	                lda 3,x
.927e		85 29		sta $29		                sta tmp3+1
.9280						_loop:
.9280		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9282		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB of xt of current nt
.9284		c5 28		cmp $28		                cmp tmp3
.9286		d0 07		bne $928f	                bne _no_match
.9288		c8		iny		                iny
.9289		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB of xt of current nt
.928b		c5 29		cmp $29		                cmp tmp3+1
.928d		f0 32		beq $92c1	                beq _match
.928f						_no_match:
.928f		18		clc		                clc
.9290		a5 26		lda $26		                lda tmp2
.9292		69 02		adc #$02	                adc #2
.9294		85 26		sta $26		                sta tmp2
.9296		a5 27		lda $27		                lda tmp2+1
.9298		69 00		adc #$00	                adc #0          ; only care about carry
.929a		85 27		sta $27		                sta tmp2+1
.929c		a0 00		ldy #$00	                ldy #0
.929e		b1 26		lda ($26),y	                lda (tmp2),y
.92a0		48		pha		                pha
.92a1		c8		iny		                iny
.92a2		11 26		ora ($26),y	                ora (tmp2),y
.92a4		f0 09		beq $92af	                beq _zero
.92a6		b1 26		lda ($26),y	                lda (tmp2),y
.92a8		85 27		sta $27		                sta tmp2+1
.92aa		68		pla		                pla
.92ab		85 26		sta $26		                sta tmp2
.92ad		80 d1		bra $9280	                bra _loop
.92af						_zero:
.92af		68		pla		                pla             ; Leftover from above loop
.92b0						_next_wordlist:
.92b0		b5 00		lda $00,x	                lda 0,x
.92b2		1a		inc a		                ina
.92b3		95 00		sta $00,x	                sta 0,x
.92b5		c9 0c		cmp #$0c	                cmp #max_wordlists
.92b7		d0 a9		bne $9262	                bne _wordlist_loop
.92b9		e8		inx		                inx
.92ba		e8		inx		                inx
.92bb		74 00		stz $00,x	                stz 0,x
.92bd		74 01		stz $01,x	                stz 1,x
.92bf		80 0a		bra $92cb	                bra z_int_to_name
.92c1						_match:
.92c1		e8		inx		                inx
.92c2		e8		inx		                inx
.92c3		a5 26		lda $26		                lda tmp2
.92c5		95 00		sta $00,x	                sta 0,x
.92c7		a5 27		lda $27		                lda tmp2+1
.92c9		95 01		sta $01,x	                sta 1,x
.92cb		60		rts		z_int_to_name:  rts
.92cc						xt_invert:
.92cc		20 6f d8	jsr $d86f	                jsr underflow_1
.92cf		a9 ff		lda #$ff	                lda #$FF
.92d1		55 00		eor $00,x	                eor 0,x         ; LSB
.92d3		95 00		sta $00,x	                sta 0,x
.92d5		a9 ff		lda #$ff	                lda #$FF
.92d7		55 01		eor $01,x	                eor 1,x         ; MSB
.92d9		95 01		sta $01,x	                sta 1,x
.92db		60		rts		z_invert:       rts
.92dc						xt_is:
.92dc		a5 16		lda $16		                lda state
.92de		05 17		ora $17		                ora state+1
.92e0		f0 0c		beq $92ee	                beq _interpreting
.92e2						_compiling:
.92e2		20 54 85	jsr $8554	                jsr xt_bracket_tick
.92e5		a0 8a		ldy #$8a	                ldy #>xt_defer_store
.92e7		a9 ad		lda #$ad	                lda #<xt_defer_store
.92e9		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.92ec		80 06		bra $92f4	                bra _done
.92ee						_interpreting:
.92ee		20 b5 a1	jsr $a1b5	                jsr xt_tick
.92f1		20 ad 8a	jsr $8aad	                jsr xt_defer_store
.92f4						_done:
.92f4		60		rts		z_is:           rts
.92f5						xt_j:
.92f5		ca		dex		                dex
.92f6		ca		dex		                dex
.92f7		86 2a		stx $2a		                stx tmpdsp
.92f9		ba		tsx		                tsx
.92fa		38		sec		                sec
.92fb		bd 07 01	lda $0107,x	                lda $0107,x     ; LSB
.92fe		fd 09 01	sbc $0109,x	                sbc $0109,x
.9301		a8		tay		                tay
.9302		bd 08 01	lda $0108,x	                lda $0108,x     ; MSB
.9305		fd 0a 01	sbc $010a,x	                sbc $010A,x
.9308		a6 2a		ldx $2a		                ldx tmpdsp
.930a		95 01		sta $01,x	                sta 1,x         ; MSB of de-fudged index
.930c		94 00		sty $00,x	                sty 0,x         ; LSB of de-fudged index
.930e		60		rts		z_j:            rts
.930f						xt_key:
.930f		20 19 93	jsr $9319	                jsr key_a               ; returns char in A
.9312		ca		dex		                dex
.9313		ca		dex		                dex
.9314		95 00		sta $00,x	                sta 0,x
.9316		74 01		stz $01,x	                stz 1,x
.9318		60		rts		z_key:          rts
.9319						key_a:
.9319		6c 12 00	jmp ($0012)	                jmp (input)             ; JSR/RTS
.931c						xt_latestnt:
.931c		ca		dex		                dex
.931d		ca		dex		                dex
.931e		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.9321		a5 02		lda $02		                lda dp
.9323		95 00		sta $00,x	                sta 0,x
.9325		a5 03		lda $03		                lda dp+1
.9327		95 01		sta $01,x	                sta 1,x
.9329		60		rts		z_latestnt:     rts
.932a						xt_latestxt:
.932a		20 1c 93	jsr $931c	                jsr xt_latestnt         ; ( nt )
.932d		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( xt )
.9330		60		rts		z_latestxt:     rts
.9331						xt_leave:
.9331		68		pla		                pla
.9332		68		pla		                pla
.9333		68		pla		                pla
.9334		68		pla		                pla
.9335		60		rts		                rts             ; this must be compiled, so keep before z_leave
.9336						z_leave:
.9336						xt_left_bracket:
.9336		64 16		stz $16		                stz state
.9338		64 17		stz $17		                stz state+1
.933a		60		rts		z_left_bracket: rts
.933b						xt_less_number_sign:
.933b		20 85 98	jsr $9885	                jsr xt_pad      ; ( addr )
.933e		b5 00		lda $00,x	                lda 0,x
.9340		85 34		sta $34		                sta tohold
.9342		b5 01		lda $01,x	                lda 1,x
.9344		85 35		sta $35		                sta tohold+1
.9346		e8		inx		                inx
.9347		e8		inx		                inx
.9348						z_less_number_sign:
.9348		60		rts		                rts
.9349						xt_less_than:
.9349		20 74 d8	jsr $d874	                jsr underflow_2
.934c		a0 00		ldy #$00	                ldy #0          ; default false
.934e		20 96 d7	jsr $d796	                jsr compare_16bit
.9351		f0 03		beq $9356	                beq _false
.9353		30 01		bmi $9356	                bmi _false
.9355		88		dey		                dey
.9356						_false:
.9356		98		tya		                tya
.9357		e8		inx		                inx
.9358		e8		inx		                inx
.9359		95 00		sta $00,x	                sta 0,x
.935b		95 01		sta $01,x	                sta 1,x
.935d		60		rts		z_less_than:    rts
.935e						xt_list:
.935e		20 6f d8	jsr $d86f	                jsr underflow_1
.9361		20 87 9e	jsr $9e87	                jsr xt_scr
.9364		20 3b a1	jsr $a13b	                jsr xt_store
.9367		20 f0 a7	jsr $a7f0	                jsr xt_editor_l
.936a		60		rts		z_list:         rts
.936b						xt_literal:
.936b		20 6f d8	jsr $d86f	                jsr underflow_1
.936e		a0 93		ldy #$93	                ldy #>literal_runtime
.9370		a9 79		lda #$79	                lda #<literal_runtime
.9372		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.9375		20 24 87	jsr $8724	                jsr xt_comma
.9378		60		rts		z_literal:      rts
.9379						literal_runtime:
.9379		ca		dex		                dex
.937a		ca		dex		                dex
.937b		68		pla		                pla             ; LSB
.937c		85 24		sta $24		                sta tmp1
.937e		68		pla		                pla             ; MSB
.937f		85 25		sta $25		                sta tmp1+1
.9381		a0 01		ldy #$01	                ldy #1
.9383		b1 24		lda ($24),y	                lda (tmp1),y    ; LSB
.9385		95 00		sta $00,x	                sta 0,x
.9387		c8		iny		                iny
.9388		b1 24		lda ($24),y	                lda (tmp1),y    ; MSB
.938a		95 01		sta $01,x	                sta 1,x
.938c		98		tya		                tya
.938d		18		clc		                clc
.938e		65 24		adc $24		                adc tmp1
.9390		a8		tay		                tay
.9391		a5 25		lda $25		                lda tmp1+1
.9393		69 00		adc #$00	                adc #0
.9395		48		pha		                pha
.9396		5a		phy		                phy
.9397		60		rts		                rts
.9398						xt_load:
.9398		20 6f d8	jsr $d86f	                jsr underflow_1
.939b		a0 01		ldy #$01	                ldy #blk_offset+1
.939d		b1 1e		lda ($1e),y	                lda (up),y
.939f		48		pha		                pha
.93a0		88		dey		                dey
.93a1		b1 1e		lda ($1e),y	                lda (up),y
.93a3		48		pha		                pha
.93a4		b5 00		lda $00,x	                lda 0,x
.93a6		91 1e		sta ($1e),y	                sta (up),y
.93a8		c8		iny		                iny
.93a9		b5 01		lda $01,x	                lda 1,x
.93ab		91 1e		sta ($1e),y	                sta (up),y
.93ad		20 77 83	jsr $8377	                jsr xt_block
.93b0		ca		dex		                dex
.93b1		ca		dex		                dex
.93b2		a9 04		lda #$04	                lda #4
.93b4		95 01		sta $01,x	                sta 1,x
.93b6		74 00		stz $00,x	                stz 0,x
.93b8		20 b4 90	jsr $90b4	                jsr load_evaluate
.93bb		a0 00		ldy #$00	                ldy #blk_offset
.93bd		68		pla		                pla
.93be		91 1e		sta ($1e),y	                sta (up),y
.93c0		c8		iny		                iny
.93c1		68		pla		                pla
.93c2		91 1e		sta ($1e),y	                sta (up),y
.93c4		88		dey		                dey
.93c5		11 1e		ora ($1e),y	                ora (up),y
.93c7		f0 12		beq $93db	                beq _done
.93c9		ca		dex		                dex
.93ca		ca		dex		                dex
.93cb		a0 00		ldy #$00	                ldy #blk_offset
.93cd		b1 1e		lda ($1e),y	                lda (up),y
.93cf		95 00		sta $00,x	                sta 0,x
.93d1		c8		iny		                iny
.93d2		b1 1e		lda ($1e),y	                lda (up),y
.93d4		95 01		sta $01,x	                sta 1,x
.93d6		20 77 83	jsr $8377	                jsr xt_block
.93d9		e8		inx		                inx
.93da		e8		inx		                inx
.93db						_done:
.93db		60		rts		z_load:         rts
.93dc						xt_loop:
.93dc		ca		dex		                dex
.93dd		ca		dex		                dex
.93de		a0 0e		ldy #$0e	                ldy #loop_runtime_end-loop_runtime
.93e0		a9 50		lda #$50	                lda #<loop_runtime
.93e2		95 00		sta $00,x	                sta 0,x
.93e4		a9 94		lda #$94	                lda #>loop_runtime
.93e6		95 01		sta $01,x	                sta 1,x
.93e8		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.93eb		80 0f		bra $93fc	                bra xt_loop_common
.93ed						xt_plus_loop:
.93ed		ca		dex		                dex
.93ee		ca		dex		                dex
.93ef		a0 10		ldy #$10	                ldy #plus_loop_runtime_end-plus_loop_runtime
.93f1		a9 40		lda #$40	                lda #<plus_loop_runtime
.93f3		95 00		sta $00,x	                sta 0,x
.93f5		a9 94		lda #$94	                lda #>plus_loop_runtime
.93f7		95 01		sta $01,x	                sta 1,x
.93f9		20 8d 88	jsr $888d	                jsr cmpl_inline_y
.93fc						xt_loop_common:
.93fc		20 24 87	jsr $8724	                jsr xt_comma
.93ff		a9 68		lda #$68	                lda #$68                ; opcode for PLA
.9401		a0 06		ldy #$06	                ldy #6
.9403						-
.9403		91 00		sta ($00),y	                sta (cp),y
.9405		88		dey		                dey
.9406		10 fb		bpl $9403	                bpl -
.9408		a9 06		lda #$06	                lda #6
.940a		18		clc		                clc
.940b		65 00		adc $00		                adc cp
.940d		85 00		sta $00		                sta cp
.940f		a5 01		lda $01		                lda cp+1
.9411		69 00		adc #$00	                adc #0                  ; only need carry
.9413		85 01		sta $01		                sta cp+1
.9415		b5 00		lda $00,x	                lda 0,x
.9417		85 24		sta $24		                sta tmp1
.9419		b5 01		lda $01,x	                lda 1,x
.941b		85 25		sta $25		                sta tmp1+1
.941d		e8		inx		                inx
.941e		e8		inx		                inx
.941f		a5 00		lda $00		                lda cp
.9421		38		sec		                sec
.9422		e9 01		sbc #$01	                sbc #1
.9424		48		pha		                pha             ; lsb
.9425		a5 01		lda $01		                lda cp+1
.9427		e9 00		sbc #$00	                sbc #0
.9429		48		pha		                pha             ; msb
.942a		a0 00		ldy #$00	                ldy #0
.942c						-
.942c		b9 3a 94	lda $943a,y	                lda loop_epilogue,y
.942f		d0 01		bne $9432	                bne +
.9431		68		pla		                pla
.9432						+
.9432		91 24		sta ($24),y	                sta (tmp1),y
.9434		c8		iny		                iny
.9435		c0 06		cpy #$06	                cpy #(loop_epilogue_end-loop_epilogue)
.9437		d0 f3		bne $942c	                bne -
.9439						z_loop:
.9439		60		rts		z_plus_loop:    rts
.943a						loop_epilogue:
.943a		a9 00		lda #$00	                lda #0
.943c		48		pha		                pha
.943d		a9 00		lda #$00	                lda #0
.943f		48		pha		                pha
.9440						loop_epilogue_end:
.9440						plus_loop_runtime:
.9440		18		clc		                clc
.9441		68		pla		                pla             ; LSB of index
.9442		75 00		adc $00,x	                adc 0,x         ; LSB of step
.9444		a8		tay		                tay             ; temporary storage of LSB
.9445		b8		clv		                clv
.9446		68		pla		                pla             ; MSB of index
.9447		75 01		adc $01,x	                adc 1,x         ; MSB of step
.9449		48		pha		                pha             ; put MSB of index back on stack
.944a		5a		phy		                phy             ; put LSB of index back on stack
.944b		e8		inx		                inx             ; dump step from TOS
.944c		e8		inx		                inx
.944d		70 03		bvs $9452	                bvs _hack+3     ; skip over JMP instruction
.944f						_hack:
>944f		4c				                .byte $4C
.9450						plus_loop_runtime_end:
.9450						loop_runtime:
.9450		b8		clv		                clv             ; note inc doesn't affect V
.9451		7a		ply		                ply             ; LSB of index
.9452		c8		iny		                iny             ; add one
.9453		d0 05		bne $945a	                bne _skip_msb   ; definitely not done
.9455		68		pla		                pla             ; MSB of index
.9456		18		clc		                clc
.9457		69 01		adc #$01	                adc #1          ; use adc to get V flag
.9459		48		pha		                pha             ; put MSB of index back on stack
.945a		5a		phy		_skip_msb:      phy             ; put LSB of index back on stack
.945b		70 03		bvs $9460	                bvs _hack+3     ; skip over JMP instruction
.945d						_hack:
>945d		4c				                .byte $4C
.945e						loop_runtime_end:
.945e						xt_lshift:
.945e		20 74 d8	jsr $d874	                jsr underflow_2
.9461		b5 00		lda $00,x	                lda 0,x
.9463		29 0f		and #$0f	                and #%00001111
.9465		f0 08		beq $946f	                beq _done
.9467		a8		tay		                tay
.9468						_loop:
.9468		16 02		asl $02,x	                asl 2,x
.946a		36 03		rol $03,x	                rol 3,x
.946c		88		dey		                dey
.946d		d0 f9		bne $9468	                bne _loop
.946f						_done:
.946f		e8		inx		                inx
.9470		e8		inx		                inx
.9471		60		rts		z_lshift:       rts
.9472						xt_m_star:
.9472		20 74 d8	jsr $d874	                jsr underflow_2
.9475		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.9477		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.9479		48		pha		                pha
.947a		20 cd 80	jsr $80cd	                jsr xt_abs
.947d		20 5c a1	jsr $a15c	                jsr xt_swap
.9480		20 cd 80	jsr $80cd	                jsr xt_abs
.9483		20 a0 a5	jsr $a5a0	                jsr xt_um_star          ; ( d )
.9486		68		pla		                pla
.9487		10 03		bpl $948c	                bpl _done
.9489		20 08 8b	jsr $8b08	                jsr xt_dnegate
.948c						_done:
.948c		60		rts		z_m_star:       rts
.948d						xt_marker:
.948d		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.9490		a5 02		lda $02		                lda dp
.9492		48		pha		                pha
.9493		a5 03		lda $03		                lda dp+1
.9495		48		pha		                pha
.9496		a5 00		lda $00		                lda cp
.9498		48		pha		                pha
.9499		a5 01		lda $01		                lda cp+1
.949b		48		pha		                pha
.949c		20 30 89	jsr $8930	                jsr xt_create
.949f		a5 00		lda $00		                lda cp          ; LSB
.94a1		38		sec		                sec
.94a2		e9 02		sbc #$02	                sbc #2
.94a4		85 00		sta $00		                sta cp
.94a6		a5 01		lda $01		                lda cp+1        ; MSB
.94a8		e9 00		sbc #$00	                sbc #0          ; we only care about the borrow
.94aa		85 01		sta $01		                sta cp+1
.94ac		a0 94		ldy #$94	                ldy #>marker_runtime
.94ae		a9 cb		lda #$cb	                lda #<marker_runtime
.94b0		20 1e d7	jsr $d71e	                jsr cmpl_word
.94b3		7a		ply		                ply                     ; MSB
.94b4		68		pla		                pla                     ; LSB
.94b5		20 1e d7	jsr $d71e	                jsr cmpl_word
.94b8		7a		ply		                ply                     ; MSB
.94b9		68		pla		                pla                     ; LSB
.94ba		20 1e d7	jsr $d71e	                jsr cmpl_word
.94bd		a0 04		ldy #$04	                ldy #4                  ; Start at CURRENT
.94bf						_marker_loop:
.94bf		b1 1e		lda ($1e),y	                lda (up),y
.94c1		20 22 d7	jsr $d722	                jsr cmpl_a
.94c4		c8		iny		                iny
.94c5		98		tya		                tya
.94c6		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94c8		d0 f5		bne $94bf	                bne _marker_loop
.94ca		60		rts		z_marker:       rts
.94cb						marker_runtime:
.94cb		68		pla		                pla
.94cc		85 24		sta $24		                sta tmp1        ; LSB of address
.94ce		68		pla		                pla
.94cf		85 25		sta $25		                sta tmp1+1      ; MSB of address
.94d1		e6 24		inc $24		                inc tmp1
.94d3		d0 02		bne $94d7	                bne +
.94d5		e6 25		inc $25		                inc tmp1+1
.94d7						+
.94d7		a0 00		ldy #$00	                ldy #0
.94d9		b1 24		lda ($24),y	                lda (tmp1),y
.94db		85 00		sta $00		                sta cp
.94dd		c8		iny		                iny
.94de		b1 24		lda ($24),y	                lda (tmp1),y
.94e0		85 01		sta $01		                sta cp+1
.94e2		c8		iny		                iny
.94e3		b1 24		lda ($24),y	                lda (tmp1),y
.94e5		85 02		sta $02		                sta dp
.94e7		c8		iny		                iny
.94e8		b1 24		lda ($24),y	                lda (tmp1),y
.94ea		85 03		sta $03		                sta dp+1
.94ec		a0 04		ldy #$04	                ldy #4
.94ee						_marker_restore_loop:
.94ee		b1 24		lda ($24),y	                lda (tmp1), y
.94f0		91 1e		sta ($1e),y	                sta (up), y
.94f2		c8		iny		                iny
.94f3		98		tya		                tya
.94f4		c9 28		cmp #$28	                cmp #40                 ; One past the end of the search order.
.94f6		d0 f6		bne $94ee	                bne _marker_restore_loop
.94f8		20 c4 d7	jsr $d7c4	                jsr dp_to_current       ; Move the CURRENT DP back.
.94fb		60		rts		                rts
.94fc						xt_max:
.94fc		20 74 d8	jsr $d874	                jsr underflow_2
.94ff		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.9501		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.9503		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9505		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9507		50 02		bvc $950b	                bvc _no_overflow
.9509		49 80		eor #$80	                eor #$80        ; complement negative flag
.950b						_no_overflow:
.950b		30 08		bmi $9515	                bmi _keep_nos
.950d		b5 00		lda $00,x	                lda 0,x
.950f		95 02		sta $02,x	                sta 2,x
.9511		b5 01		lda $01,x	                lda 1,x
.9513		95 03		sta $03,x	                sta 3,x
.9515						_keep_nos:
.9515		e8		inx		                inx
.9516		e8		inx		                inx
.9517		60		rts		z_max:          rts
.9518						xt_min:
.9518		20 74 d8	jsr $d874	                jsr underflow_2
.951b		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.951d		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.951f		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.9521		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.9523		50 02		bvc $9527	                bvc _no_overflow
.9525		49 80		eor #$80	                eor #$80
.9527						_no_overflow:
.9527		10 08		bpl $9531	                bpl _keep_nos
.9529		b5 00		lda $00,x	                lda 0,x
.952b		95 02		sta $02,x	                sta 2,x
.952d		b5 01		lda $01,x	                lda 1,x
.952f		95 03		sta $03,x	                sta 3,x
.9531						_keep_nos:
.9531		e8		inx		                inx
.9532		e8		inx		                inx
.9533		60		rts		z_min:          rts
.9534						xt_minus:
.9534		20 74 d8	jsr $d874	                jsr underflow_2
.9537		38		sec		                sec
.9538		b5 02		lda $02,x	                lda 2,x         ; LSB
.953a		f5 00		sbc $00,x	                sbc 0,x
.953c		95 02		sta $02,x	                sta 2,x
.953e		b5 03		lda $03,x	                lda 3,x         ; MSB
.9540		f5 01		sbc $01,x	                sbc 1,x
.9542		95 03		sta $03,x	                sta 3,x
.9544		e8		inx		                inx
.9545		e8		inx		                inx
.9546		60		rts		z_minus:        rts
.9547						xt_minus_leading:
.9547		20 74 d8	jsr $d874	                jsr underflow_2
.954a						_loop:
.954a		b5 00		lda $00,x	                lda 0,x
.954c		15 01		ora $01,x	                ora 1,x
.954e		f0 0f		beq $955f	                beq _done
.9550		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.9552		20 62 d8	jsr $d862	                jsr is_whitespace
.9555		90 08		bcc $955f	                bcc _done
.9557		20 ec 97	jsr $97ec	                jsr xt_one              ; ( addr u 1 )
.955a		20 c7 9f	jsr $9fc7	                jsr xt_slash_string     ; ( addr+ u-1 )
.955d		80 eb		bra $954a	                bra _loop
.955f						_done:
.955f						z_minus_leading:
.955f		60		rts		                rts
.9560						xt_minus_trailing:
.9560		20 74 d8	jsr $d874	                jsr underflow_2
.9563		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.9565		15 01		ora $01,x	                ora 1,x         ; MSB of n
.9567		f0 33		beq $959c	                beq _done
.9569		18		clc		                clc
.956a		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.956c		75 00		adc $00,x	                adc 0,x
.956e		85 24		sta $24		                sta tmp1
.9570		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.9572		75 01		adc $01,x	                adc 1,x
.9574		85 25		sta $25		                sta tmp1+1
.9576		a5 24		lda $24		                lda tmp1
.9578		d0 02		bne $957c	                bne +
.957a		c6 25		dec $25		                dec tmp1+1
.957c						+
.957c		c6 24		dec $24		                dec tmp1
.957e						_loop:
.957e		b2 24		lda ($24)	                lda (tmp1)
.9580		c9 20		cmp #$20	                cmp #AscSP
.9582		d0 18		bne $959c	                bne _done
.9584		a5 24		lda $24		                lda tmp1
.9586		d0 02		bne $958a	                bne +
.9588		c6 25		dec $25		                dec tmp1+1
.958a						+
.958a		c6 24		dec $24		                dec tmp1
.958c		b5 00		lda $00,x	                lda 0,x
.958e		d0 02		bne $9592	                bne +
.9590		d6 01		dec $01,x	                dec 1,x
.9592						+
.9592		d6 00		dec $00,x	                dec 0,x
.9594		b5 00		lda $00,x	                lda 0,x
.9596		15 01		ora $01,x	                ora 1,x
.9598		f0 02		beq $959c	                beq _done       ; Count has reached zero - we're done!
.959a		80 e2		bra $957e	                bra _loop
.959c						_done:
.959c						z_minus_trailing:
.959c		60		rts		                rts
.959d						xt_mod:
.959d		20 74 d8	jsr $d874	                jsr underflow_2
.95a0		20 af 9f	jsr $9faf	                jsr xt_slash_mod
.95a3		e8		inx		                inx             ; DROP
.95a4		e8		inx		                inx
.95a5						z_mod:
.95a5		60		rts		                rts
.95a6						xt_move:
.95a6		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.95a8		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.95aa		f0 05		beq $95b1	                beq _lsb                ; wasn't helpful, move to LSB
.95ac		b0 0e		bcs $95bc	                bcs _to_move_up         ; we want CMOVE>
.95ae		4c 4f 86	jmp $864f	                jmp xt_cmove            ; JSR/RTS
.95b1						_lsb:
.95b1		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.95b3		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.95b5		f0 08		beq $95bf	                beq _equal              ; LSB is equal as well
.95b7		b0 03		bcs $95bc	                bcs _to_move_up         ; we want CMOVE>
.95b9		4c 4f 86	jmp $864f	                jmp xt_cmove            ; JSR/RTS
.95bc						_to_move_up:
.95bc		4c 8a 86	jmp $868a	                jmp xt_cmove_up         ; JSR/RTS
.95bf						_equal:
.95bf		8a		txa		                txa
.95c0		18		clc		                clc
.95c1		69 06		adc #$06	                adc #6
.95c3		aa		tax		                tax
.95c4		60		rts		z_move:         rts
.95c5						xt_name_to_int:
.95c5		20 6f d8	jsr $d86f	                jsr underflow_1
.95c8		b5 00		lda $00,x	                lda 0,x
.95ca		18		clc		                clc
.95cb		69 04		adc #$04	                adc #4
.95cd		85 28		sta $28		                sta tmp3
.95cf		b5 01		lda $01,x	                lda 1,x
.95d1		90 01		bcc $95d4	                bcc _done
.95d3		1a		inc a		                ina
.95d4						_done:
.95d4		85 29		sta $29		                sta tmp3+1
.95d6		a0 00		ldy #$00	                ldy #0
.95d8		b1 28		lda ($28),y	                lda (tmp3),y
.95da		95 00		sta $00,x	                sta 0,x
.95dc		c8		iny		                iny
.95dd		b1 28		lda ($28),y	                lda (tmp3),y
.95df		95 01		sta $01,x	                sta 1,x
.95e1		60		rts		z_name_to_int:  rts
.95e2						xt_name_to_string:
.95e2		20 6f d8	jsr $d86f	                jsr underflow_1
.95e5		ca		dex		                dex
.95e6		ca		dex		                dex
.95e7		a1 02		lda ($02,x)	                lda (2,x)
.95e9		95 00		sta $00,x	                sta 0,x
.95eb		74 01		stz $01,x	                stz 1,x
.95ed		b5 02		lda $02,x	                lda 2,x         ; LSB
.95ef		18		clc		                clc
.95f0		69 08		adc #$08	                adc #8
.95f2		a8		tay		                tay
.95f3		b5 03		lda $03,x	                lda 3,x         ; MSB
.95f5		69 00		adc #$00	                adc #0          ; just need carry
.95f7		95 03		sta $03,x	                sta 3,x
.95f9		94 02		sty $02,x	                sty 2,x
.95fb						z_name_to_string:
.95fb		60		rts		                rts
.95fc						xt_nc_limit:
.95fc		ca		dex		                dex
.95fd		ca		dex		                dex
.95fe		a9 1a		lda #$1a	                lda #<nc_limit
.9600		95 00		sta $00,x	                sta 0,x
.9602		a9 00		lda #$00	                lda #>nc_limit
.9604		95 01		sta $01,x	                sta 1,x
.9606		60		rts		z_nc_limit:     rts
.9607						xt_negate:
.9607		20 6f d8	jsr $d86f	                jsr underflow_1
.960a		a9 00		lda #$00	        	lda #0
.960c		38		sec		                sec
.960d		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.960f		95 00		sta $00,x	                sta 0,x
.9611		a9 00		lda #$00	                lda #0
.9613		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.9615		95 01		sta $01,x	                sta 1,x
.9617		60		rts		z_negate:       rts
.9618						xt_never_native:
.9618		20 b1 d7	jsr $d7b1	                jsr current_to_dp
.961b		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.961d		b1 02		lda ($02),y	                lda (dp),y
.961f		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9621		29 fd		and #$fd	                and #$ff-AN     ; and AN flag is clear.
.9623		91 02		sta ($02),y	                sta (dp),y
.9625						z_never_native:
.9625		60		rts		                rts
.9626						xt_nip:
.9626		20 74 d8	jsr $d874	                jsr underflow_2
.9629		b5 00		lda $00,x	                lda 0,x         ; LSB
.962b		95 02		sta $02,x	                sta 2,x
.962d		b5 01		lda $01,x	                lda 1,x         ; MSB
.962f		95 03		sta $03,x	                sta 3,x
.9631		e8		inx		                inx
.9632		e8		inx		                inx
.9633		60		rts		z_nip:          rts
.9634						xt_not_equals:
.9634		20 74 d8	jsr $d874	                jsr underflow_2
.9637		a0 00		ldy #$00	                ldy #0                  ; default is true
.9639		b5 00		lda $00,x	                lda 0,x                 ; LSB
.963b		d5 02		cmp $02,x	                cmp 2,x
.963d		d0 0a		bne $9649	                bne _not_equal
.963f		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9641		d5 03		cmp $03,x	                cmp 3,x
.9643		d0 04		bne $9649	                bne _not_equal
.9645		a9 ff		lda #$ff	                lda #$FF
.9647		80 01		bra $964a	                bra _done
.9649						_not_equal:
.9649		88		dey		                dey                     ; drop thru to done
.964a						_done:
.964a		98		tya		                tya
.964b		e8		inx		                inx
.964c		e8		inx		                inx
.964d		95 00		sta $00,x	                sta 0,x
.964f		95 01		sta $01,x	                sta 1,x
.9651		60		rts		z_not_equals:   rts
.9652						xt_not_rote:
.9652		20 79 d8	jsr $d879	                jsr underflow_3
.9655		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9657		b5 03		lda $03,x	                lda 3,x
.9659		95 01		sta $01,x	                sta 1,x
.965b		b5 05		lda $05,x	                lda 5,x
.965d		95 03		sta $03,x	                sta 3,x
.965f		94 05		sty $05,x	                sty 5,x
.9661		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9663		b5 02		lda $02,x	                lda 2,x
.9665		95 00		sta $00,x	                sta 0,x
.9667		b5 04		lda $04,x	                lda 4,x
.9669		95 02		sta $02,x	                sta 2,x
.966b		94 04		sty $04,x	                sty 4,x
.966d		60		rts		z_not_rote:     rts
.966e						xt_number:
.966e		20 74 d8	jsr $d874	                jsr underflow_2
.9671		64 2a		stz $2a		                stz tmpdsp      ; flag for double
.9673		64 2b		stz $2b		                stz tmpdsp+1    ; flag for minus
.9675		a5 18		lda $18		                lda base
.9677		48		pha		                pha
.9678		20 5c a3	jsr $a35c	                jsr xt_two_dup
.967b		a1 02		lda ($02,x)	                lda (2,x)
.967d						_check_dec:
.967d		c9 23		cmp #$23	                cmp #$23        ; ASCII for "#"
.967f		d0 04		bne $9685	                bne _check_hex
.9681		a9 0a		lda #$0a	                lda #$0A
.9683		80 42		bra $96c7	                bra _base_changed
.9685						_check_hex:
.9685		c9 24		cmp #$24	                cmp #$24        ; ASCII for "$"
.9687		d0 04		bne $968d	                bne _check_binary
.9689		a9 10		lda #$10	                lda #$10
.968b		80 3a		bra $96c7	                bra _base_changed
.968d						_check_binary:
.968d		c9 25		cmp #$25	                cmp #$25        ; ASCII for "%"
.968f		d0 04		bne $9695	                bne _check_char
.9691		a9 02		lda #$02	                lda #$02
.9693		80 32		bra $96c7	                bra _base_changed
.9695						_check_char:
.9695		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.9697		d0 3a		bne $96d3	                bne _check_minus
.9699		b5 00		lda $00,x	                lda 0,x         ; Get the length
.969b		c9 03		cmp #$03	                cmp #$03
.969d		d0 26		bne $96c5	                bne _not_a_char
.969f		b5 01		lda $01,x	                lda 1,x
.96a1		d0 22		bne $96c5	                bne _not_a_char ; No compare needed to check for non-zero.
.96a3		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96a5		18		clc		                clc
.96a6		69 02		adc #$02	                adc #2          ; length of string
.96a8		85 2c		sta $2c		                sta tmptos
.96aa		b5 03		lda $03,x	                lda 3,x
.96ac		69 00		adc #$00	                adc #0          ; only need carry
.96ae		85 2d		sta $2d		                sta tmptos+1
.96b0		b2 2c		lda ($2c)	                lda (tmptos)
.96b2		c9 27		cmp #$27	                cmp #$27        ; ASCII for "'"
.96b4		d0 0f		bne $96c5	                bne _not_a_char
.96b6		f6 02		inc $02,x	                inc 2,x
.96b8		d0 02		bne $96bc	                bne +
.96ba		f6 03		inc $03,x	                inc 3,x
.96bc						+
.96bc		a1 02		lda ($02,x)	                lda (2,x)
.96be		95 02		sta $02,x	                sta 2,x
.96c0		74 03		stz $03,x	                stz 3,x
.96c2		4c 43 97	jmp $9743	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.96c5						_not_a_char:
.96c5		80 5a		bra $9721	                bra _number_error
.96c7						_base_changed:
.96c7		85 18		sta $18		                sta base        ; Switch to the new base
.96c9		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96cb		d0 02		bne $96cf	                bne +
.96cd		f6 03		inc $03,x	                inc 3,x
.96cf						+
.96cf		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96d1		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.96d3						_check_minus:
.96d3		c9 2d		cmp #$2d	                cmp #$2D        ; ASCII for "-"
.96d5		d0 0a		bne $96e1	                bne _check_dot
.96d7		c6 2b		dec $2b		                dec tmpdsp+1
.96d9		f6 02		inc $02,x	                inc 2,x         ; start one character later
.96db		d0 02		bne $96df	                bne +
.96dd		f6 03		inc $03,x	                inc 3,x
.96df						+
.96df		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.96e1						_check_dot:
.96e1		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.96e3		18		clc		                clc
.96e4		75 00		adc $00,x	                adc 0,x         ; length of string
.96e6		85 2c		sta $2c		                sta tmptos
.96e8		b5 03		lda $03,x	                lda 3,x
.96ea		69 00		adc #$00	                adc #0          ; only need carry
.96ec		85 2d		sta $2d		                sta tmptos+1
.96ee		a5 2c		lda $2c		                lda tmptos
.96f0		d0 02		bne $96f4	                bne +
.96f2		c6 2d		dec $2d		                dec tmptos+1
.96f4						+
.96f4		c6 2c		dec $2c		                dec tmptos
.96f6		b2 2c		lda ($2c)	                lda (tmptos)
.96f8		c9 2e		cmp #$2e	                cmp #'.'
.96fa		d0 04		bne $9700	                bne _main
.96fc		c6 2a		dec $2a		                dec tmpdsp
.96fe		d6 00		dec $00,x	                dec 0,x
.9700						_main:
.9700		ca		dex		                dex
.9701		ca		dex		                dex
.9702		ca		dex		                dex
.9703		ca		dex		                dex
.9704		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9706		95 00		sta $00,x	                sta 0,x
.9708		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.970a		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.970c		95 02		sta $02,x	                sta 2,x
.970e		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9710		95 03		sta $03,x	                sta 3,x
.9712		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9714		74 05		stz $05,x	                stz 5,x
.9716		74 06		stz $06,x	                stz 6,x
.9718		74 07		stz $07,x	                stz 7,x
.971a		20 61 a2	jsr $a261	                jsr xt_to_number        ; (ud addr u -- ud addr u )
.971d		b5 00		lda $00,x	                lda 0,x
.971f		f0 1e		beq $973f	                beq _all_converted
.9721						_number_error:
.9721		20 54 a3	jsr $a354	                jsr xt_two_drop ; >NUMBER modified addr u
.9724		20 54 a3	jsr $a354	                jsr xt_two_drop ; ud   (partially converted number)
.9727		a9 3e		lda #$3e	                lda #$3E        ; ASCII for ">"
.9729		20 db 8d	jsr $8ddb	                jsr emit_a
.972c		20 a7 a4	jsr $a4a7	                jsr xt_type
.972f		a9 3c		lda #$3c	                lda #$3C        ; ASCII for "<"
.9731		20 db 8d	jsr $8ddb	                jsr emit_a
.9734		20 cc a0	jsr $a0cc	                jsr xt_space
.9737		68		pla		                pla
.9738		85 18		sta $18		                sta base
.973a		a9 08		lda #$08	                lda #err_syntax
.973c		4c 85 d8	jmp $d885	                jmp error
.973f						_all_converted:
.973f		e8		inx		                inx ; Drop the current addr u
.9740		e8		inx		                inx
.9741		e8		inx		                inx
.9742		e8		inx		                inx
.9743						_drop_original_string:
.9743		20 22 a4	jsr $a422	                jsr xt_two_swap  ; Drop the original addr u
.9746		20 54 a3	jsr $a354	                jsr xt_two_drop  ; (was saved for unknown word error message)
.9749		a5 2a		lda $2a		                lda tmpdsp      ; flag for double
.974b		f0 0d		beq $975a	                beq _single
.974d		a9 20		lda #$20	                lda #%00100000
.974f		04 20		tsb $20		                tsb status
.9751		a5 2b		lda $2b		                lda tmpdsp+1
.9753		f0 12		beq $9767	                beq _done       ; no minus, all done
.9755		20 08 8b	jsr $8b08	                jsr xt_dnegate
.9758		80 0d		bra $9767	                bra _done
.975a						_single:
.975a		e8		inx		                inx
.975b		e8		inx		                inx
.975c		a9 20		lda #$20	                lda #%00100000
.975e		14 20		trb $20		                trb status
.9760		a5 2b		lda $2b		                lda tmpdsp+1
.9762		f0 03		beq $9767	                beq _done       ; no minus, all done
.9764		20 07 96	jsr $9607	                jsr xt_negate
.9767						_done:
.9767		68		pla		                pla
.9768		85 18		sta $18		                sta base
.976a		60		rts		z_number:       rts
.976b						xt_number_sign:
.976b		20 74 d8	jsr $d874	                jsr underflow_2         ; double number
.976e		20 3d 83	jsr $833d	                jsr xt_base
.9771		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( ud1 base )
.9774		20 14 a3	jsr $a314	                jsr xt_to_r             ; >r
.9777		20 56 a7	jsr $a756	                jsr xt_zero             ; 0
.977a		20 61 9a	jsr $9a61	                jsr xt_r_fetch          ; r@
.977d		20 5e a5	jsr $a55e	                jsr xt_um_slash_mod     ; um/mod
.9780		20 34 9b	jsr $9b34	                jsr xt_rot              ; rot
.9783		20 34 9b	jsr $9b34	                jsr xt_rot              ; rot
.9786		20 76 9a	jsr $9a76	                jsr xt_r_from           ; r>
.9789		20 5e a5	jsr $a55e	                jsr xt_um_slash_mod     ; um/mod
.978c		20 34 9b	jsr $9b34	                jsr xt_rot              ; rot
.978f		20 34 9b	jsr $9b34	                jsr xt_rot              ; ( ud rem )
.9792		b5 00		lda $00,x	                lda 0,x
.9794		a8		tay		                tay
.9795		b9 3c d4	lda $d43c,y	                lda s_abc_upper,y
.9798		95 00		sta $00,x	                sta 0,x
.979a		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.979c		20 bc 91	jsr $91bc	                jsr xt_hold
.979f						z_number_sign:
.979f		60		rts		                rts
.97a0						xt_number_sign_greater:
.97a0		20 74 d8	jsr $d874	                jsr underflow_2         ; double number
.97a3		a5 34		lda $34		                lda tohold
.97a5		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.97a7		95 02		sta $02,x	                sta 2,x
.97a9		a5 35		lda $35		                lda tohold+1
.97ab		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.97ad		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.97af		20 85 98	jsr $9885	                jsr xt_pad      ; ( addr addr pad )
.97b2		38		sec		                sec
.97b3		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.97b5		f5 02		sbc $02,x	                sbc 2,x
.97b7		95 02		sta $02,x	                sta 2,x
.97b9		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.97bb		f5 03		sbc $03,x	                sbc 3,x
.97bd		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.97bf		e8		inx		                inx
.97c0		e8		inx		                inx
.97c1						z_number_sign_greater:
.97c1		60		rts		                rts
.97c2						xt_number_sign_s:
.97c2		20 74 d8	jsr $d874	                jsr underflow_2
.97c5						_loop:
.97c5		20 6b 97	jsr $976b	                jsr xt_number_sign
.97c8		b5 00		lda $00,x	                lda 0,x
.97ca		15 01		ora $01,x	                ora 1,x
.97cc		15 02		ora $02,x	                ora 2,x
.97ce		15 03		ora $03,x	                ora 3,x
.97d0		d0 f3		bne $97c5	                bne _loop
.97d2						z_number_sign_s:
.97d2		60		rts		                rts
.97d3						xt_of:
.97d3		a0 98		ldy #$98	                ldy #>xt_over
.97d5		a9 77		lda #$77	                lda #<xt_over
.97d7		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.97da		a0 8e		ldy #$8e	                ldy #>xt_equal
.97dc		a9 b3		lda #$b3	                lda #<xt_equal
.97de		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.97e1		20 e6 91	jsr $91e6	                jsr xt_if
.97e4		a0 8c		ldy #$8c	                ldy #>xt_drop
.97e6		a9 e1		lda #$e1	                lda #<xt_drop
.97e8		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.97eb		60		rts		z_of:           rts
.97ec						xt_editor_wordlist:
.97ec						xt_one:
.97ec		ca		dex		                dex
.97ed		ca		dex		                dex
.97ee		a9 01		lda #$01	                lda #1
.97f0		95 00		sta $00,x	                sta 0,x
.97f2		74 01		stz $01,x	                stz 1,x
.97f4						z_editor_wordlist:
.97f4						z_one:
.97f4		60		rts		                rts
.97f5						xt_one_minus:
.97f5		20 6f d8	jsr $d86f	                jsr underflow_1
.97f8		b5 00		lda $00,x	                lda 0,x
.97fa		d0 02		bne $97fe	                bne +
.97fc		d6 01		dec $01,x	                dec 1,x
.97fe						+
.97fe		d6 00		dec $00,x	                dec 0,x
.9800		60		rts		z_one_minus:    rts
.9801						xt_char_plus:
.9801						xt_one_plus:
.9801		20 6f d8	jsr $d86f	                jsr underflow_1
.9804		f6 00		inc $00,x	                inc 0,x
.9806		d0 02		bne $980a	                bne _done
.9808		f6 01		inc $01,x	                inc 1,x
.980a						_done:
.980a						z_char_plus:
.980a		60		rts		z_one_plus:     rts
.980b						xt_only:
.980b		ca		dex		                dex
.980c		ca		dex		                dex
.980d		a9 ff		lda #$ff	                lda #$FF
.980f		95 00		sta $00,x	                sta 0,x
.9811		95 01		sta $01,x	                sta 1,x
.9813		20 f8 9c	jsr $9cf8	                jsr xt_set_order
.9816		60		rts		z_only:         rts
.9817						xt_or:
.9817		20 74 d8	jsr $d874	                jsr underflow_2
.981a		b5 00		lda $00,x	                lda 0,x
.981c		15 02		ora $02,x	                ora 2,x
.981e		95 02		sta $02,x	                sta 2,x
.9820		b5 01		lda $01,x	                lda 1,x
.9822		15 03		ora $03,x	                ora 3,x
.9824		95 03		sta $03,x	                sta 3,x
.9826		e8		inx		                inx
.9827		e8		inx		                inx
.9828		60		rts		z_or:           rts
.9829						xt_order:
.9829		20 2a 89	jsr $892a	                jsr xt_cr
.982c		20 19 91	jsr $9119	                jsr xt_get_order        ; ( wid_n ... wid_1 n )
.982f		b5 00		lda $00,x	                lda 0,x                 ; assumes no more than 255 wordlists
.9831		f0 1e		beq $9851	                beq _drop_done
.9833						_have_wordlists:
.9833		a8		tay		                tay
.9834						_loop:
.9834		e8		inx		                inx
.9835		e8		inx		                inx                     ; DROP, now ( wid_n ... wid_1 )
.9836		b5 00		lda $00,x	                lda 0,x
.9838		5a		phy		                phy
.9839		20 54 98	jsr $9854	                jsr order_print_wid_string   ; internal helper function
.983c		7a		ply		                ply
.983d		88		dey		                dey
.983e		d0 f4		bne $9834	                bne _loop
.9840		20 cc a0	jsr $a0cc	                jsr xt_space
.9843		20 cc a0	jsr $a0cc	                jsr xt_space
.9846		20 0e 91	jsr $910e	                jsr xt_get_current      ; ( wid )
.9849		b5 00		lda $00,x	                lda 0,x
.984b		20 54 98	jsr $9854	                jsr order_print_wid_string
.984e		20 2a 89	jsr $892a	                jsr xt_cr
.9851						_drop_done:
.9851		e8		inx		                inx
.9852		e8		inx		                inx
.9853						z_order:
.9853		60		rts		                rts
.9854						order_print_wid_string:
.9854		c9 04		cmp #$04	                cmp #4
.9856		90 09		bcc $9861	                bcc _output_string      ; less than 4, print a real string
.9858		ca		dex		                dex
.9859		ca		dex		                dex
.985a		95 00		sta $00,x	                sta 0,x
.985c		74 01		stz $01,x	                stz 1,x
.985e		4c d2 a4	jmp $a4d2	                jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
.9861						_output_string:
.9861		a8		tay		                tay
.9862		b9 68 98	lda $9868,y	                lda _wid_data,y
.9865		4c ab d8	jmp $d8ab	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.9868						_wid_data:
>9868		04				        .byte str_wid_forth            ; WID 0: "Forth"
>9869		05				        .byte str_wid_editor           ; WID 1: "Editor"
>986a		06				        .byte str_wid_assembler        ; WID 2: "Assembler"
>986b		07				        .byte str_wid_root             ; WID 3: "Root"
.986c						xt_output:
.986c		ca		dex		                dex
.986d		ca		dex		                dex
.986e		a9 10		lda #$10	                lda #<output
.9870		95 00		sta $00,x	                sta 0,x
.9872		a9 00		lda #$00	                lda #>output
.9874		95 01		sta $01,x	                sta 1,x
.9876		60		rts		z_output:       rts
.9877						xt_over:
.9877		20 74 d8	jsr $d874	                jsr underflow_2
.987a		ca		dex		                dex
.987b		ca		dex		                dex
.987c		b5 04		lda $04,x	                lda 4,x         ; LSB
.987e		95 00		sta $00,x	                sta 0,x
.9880		b5 05		lda $05,x	                lda 5,x         ; MSB
.9882		95 01		sta $01,x	                sta 1,x
.9884		60		rts		z_over:         rts
.9885						xt_pad:
.9885		ca		dex		                dex
.9886		ca		dex		                dex
.9887		a5 00		lda $00		                lda cp
.9889		18		clc		                clc
.988a		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.988c		95 00		sta $00,x	                sta 0,x
.988e		a5 01		lda $01		                lda cp+1
.9890		69 00		adc #$00	                adc #0          ; only need carry
.9892		95 01		sta $01,x	                sta 1,x
.9894		60		rts		z_pad:          rts
.9895						xt_page:
.9895		a9 1b		lda #$1b	                lda #AscESC
.9897		20 db 8d	jsr $8ddb	                jsr emit_a
.989a		a9 5b		lda #$5b	                lda #$5B        ; ASCII for "["
.989c		20 db 8d	jsr $8ddb	                jsr emit_a
.989f		a9 32		lda #$32	                lda #'2'
.98a1		20 db 8d	jsr $8ddb	                jsr emit_a
.98a4		a9 4a		lda #$4a	                lda #'J'
.98a6		20 db 8d	jsr $8ddb	                jsr emit_a
.98a9		20 56 a7	jsr $a756	                jsr xt_zero
.98ac		20 56 a7	jsr $a756	                jsr xt_zero
.98af		20 e4 82	jsr $82e4	                jsr xt_at_xy
.98b2		60		rts		z_page:         rts
.98b3						xt_paren:
.98b3		ca		dex		                dex
.98b4		ca		dex		                dex
.98b5		a9 29		lda #$29	                lda #41     ; Right parenthesis
.98b7		95 00		sta $00,x	                sta 0,x
.98b9		74 01		stz $01,x	                stz 1,x
.98bb		20 1e 99	jsr $991e	                jsr xt_parse
.98be		e8		inx		                inx
.98bf		e8		inx		                inx
.98c0		e8		inx		                inx
.98c1		e8		inx		                inx
.98c2		60		rts		z_paren:        rts
.98c3						xt_parse_name:
.98c3		a5 0a		lda $0a		                lda ciblen              ; LSB of counter
.98c5		38		sec		                sec
.98c6		e5 0c		sbc $0c		                sbc toin
.98c8		85 24		sta $24		                sta tmp1
.98ca		a5 0b		lda $0b		                lda ciblen+1            ; MSB
.98cc		e5 0d		sbc $0d		                sbc toin+1
.98ce		85 25		sta $25		                sta tmp1+1
.98d0		a5 24		lda $24		                lda tmp1
.98d2		05 25		ora $25		                ora tmp1+1
.98d4		f0 28		beq $98fe	                beq _empty_line
.98d6		a5 08		lda $08		                lda cib
.98d8		18		clc		                clc
.98d9		65 0c		adc $0c		                adc toin
.98db		85 26		sta $26		                sta tmp2                ; LSB of first character
.98dd		a5 09		lda $09		                lda cib+1
.98df		65 0d		adc $0d		                adc toin+1
.98e1		85 27		sta $27		                sta tmp2+1              ; MSB
.98e3						_skip_loop:
.98e3		b2 26		lda ($26)	                lda (tmp2)              ; work copy of cib
.98e5		20 62 d8	jsr $d862	                jsr is_whitespace
.98e8		90 1f		bcc $9909	                bcc _char_found
.98ea		e6 26		inc $26		                inc tmp2
.98ec		d0 02		bne $98f0	                bne +
.98ee		e6 27		inc $27		                inc tmp2+1
.98f0						+
.98f0		a5 24		lda $24		                lda tmp1
.98f2		d0 02		bne $98f6	                bne +
.98f4		c6 25		dec $25		                dec tmp1+1
.98f6		c6 24		dec $24		+               dec tmp1
.98f8		a5 24		lda $24		                lda tmp1
.98fa		05 25		ora $25		                ora tmp1+1
.98fc		d0 e5		bne $98e3	                bne _skip_loop          ; fall through if empty line
.98fe						_empty_line:
.98fe		ca		dex		                dex
.98ff		ca		dex		                dex
.9900		ca		dex		                dex
.9901		ca		dex		                dex
.9902		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.9904		74 01		stz $01,x	                stz 1,x
.9906		4c b5 99	jmp $99b5	                jmp z_parse_name        ; skip over PARSE
.9909						_char_found:
.9909		a5 26		lda $26		                lda tmp2
.990b		38		sec		                sec
.990c		e5 08		sbc $08		                sbc cib
.990e		85 0c		sta $0c		                sta toin
.9910		a5 27		lda $27		                lda tmp2+1
.9912		e5 09		sbc $09		                sbc cib+1
.9914		85 0d		sta $0d		                sta toin+1
.9916		ca		dex		                dex
.9917		ca		dex		                dex
.9918		a9 20		lda #$20	                lda #AscSP
.991a		95 00		sta $00,x	                sta 0,x
.991c		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.991e						xt_parse:
.991e		20 6f d8	jsr $d86f	                jsr underflow_1
.9921		a5 0a		lda $0a		                lda ciblen
.9923		05 0b		ora $0b		                ora ciblen+1
.9925		f0 0c		beq $9933	                beq _abort_parse
.9927		a5 0d		lda $0d		                lda toin+1              ; MSB
.9929		c5 0b		cmp $0b		                cmp ciblen+1
.992b		90 0e		bcc $993b	                bcc _go_parse           ; unsigned comparison
.992d		a5 0c		lda $0c		                lda toin                ; LSB
.992f		c5 0a		cmp $0a		                cmp ciblen
.9931		90 08		bcc $993b	                bcc _go_parse
.9933						_abort_parse:
.9933		ca		dex		                dex
.9934		ca		dex		                dex
.9935		74 00		stz $00,x	                stz 0,x
.9937		74 01		stz $01,x	                stz 1,x
.9939		80 7a		bra $99b5	                bra _done
.993b						_go_parse:
.993b		b5 00		lda $00,x	                lda 0,x
.993d		85 2c		sta $2c		                sta tmptos
.993f		ca		dex		                dex
.9940		ca		dex		                dex
.9941		a5 08		lda $08		                lda cib
.9943		18		clc		                clc
.9944		65 0c		adc $0c		                adc toin        ; LSB
.9946		85 24		sta $24		                sta tmp1
.9948		85 26		sta $26		                sta tmp2
.994a		95 02		sta $02,x	                sta 2,x
.994c		a5 09		lda $09		                lda cib+1
.994e		65 0d		adc $0d		                adc toin+1      ; MSB
.9950		85 25		sta $25		                sta tmp1+1
.9952		85 27		sta $27		                sta tmp2+1
.9954		95 03		sta $03,x	                sta 3,x
.9956		a5 08		lda $08		                lda cib
.9958		18		clc		                clc
.9959		65 0a		adc $0a		                adc ciblen
.995b		85 28		sta $28		                sta tmp3
.995d		a5 09		lda $09		                lda cib+1
.995f		65 0b		adc $0b		                adc ciblen+1
.9961		85 29		sta $29		                sta tmp3+1
.9963		64 2d		stz $2d		                stz tmptos+1
.9965						_loop:
.9965		a5 26		lda $26		                lda tmp2
.9967		c5 28		cmp $28		                cmp tmp3
.9969		d0 06		bne $9971	                bne _not_empty
.996b		a5 27		lda $27		                lda tmp2+1
.996d		c5 29		cmp $29		                cmp tmp3+1
.996f		f0 1d		beq $998e	                beq _eol
.9971						_not_empty:
.9971		b2 26		lda ($26)	                lda (tmp2)
.9973		a4 2c		ldy $2c		                ldy tmptos
.9975		c0 20		cpy #$20	                cpy #AscSP
.9977		d0 07		bne $9980	                bne _not_whitespace
.9979		20 62 d8	jsr $d862	                jsr is_whitespace
.997c		90 02		bcc $9980	                bcc _not_whitespace
.997e		80 0c		bra $998c	                bra _found_delimiter
.9980						_not_whitespace:
.9980		c5 2c		cmp $2c		                cmp tmptos
.9982		f0 08		beq $998c	                beq _found_delimiter
.9984		e6 26		inc $26		                inc tmp2
.9986		d0 dd		bne $9965	                bne _loop
.9988		e6 27		inc $27		                inc tmp2+1
.998a		80 d9		bra $9965	                bra _loop
.998c						_found_delimiter:
.998c		e6 2d		inc $2d		                inc tmptos+1
.998e						_eol:
.998e		a5 26		lda $26		                lda tmp2
.9990		38		sec		                sec
.9991		e5 24		sbc $24		                sbc tmp1
.9993		95 00		sta $00,x	                sta 0,x
.9995		a5 27		lda $27		                lda tmp2+1
.9997		e5 25		sbc $25		                sbc tmp1+1
.9999		95 01		sta $01,x	                sta 1,x
.999b		a5 26		lda $26		                lda tmp2
.999d		38		sec		                sec
.999e		e5 08		sbc $08		                sbc cib
.99a0		85 0c		sta $0c		                sta toin
.99a2		a5 27		lda $27		                lda tmp2+1
.99a4		e5 09		sbc $09		                sbc cib+1
.99a6		85 0d		sta $0d		                sta toin+1
.99a8		a5 0c		lda $0c		                lda toin
.99aa		18		clc		                clc
.99ab		65 2d		adc $2d		                adc tmptos+1
.99ad		85 0c		sta $0c		                sta toin
.99af		a5 0d		lda $0d		                lda toin+1
.99b1		69 00		adc #$00	                adc #0          ; we only need the carry
.99b3		85 0d		sta $0d		                sta toin+1
.99b5						_done:
.99b5						z_parse_name:
.99b5		60		rts		z_parse:        rts
.99b6						xt_pick:
.99b6		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.99b8		8a		txa		                txa
.99b9		75 00		adc $00,x	                adc 0,x
.99bb		a8		tay		                tay
.99bc		b9 02 00	lda $0002,y	                lda 0002,y
.99bf		95 00		sta $00,x	                sta 0,x
.99c1		b9 03 00	lda $0003,y	                lda 0003,y
.99c4		95 01		sta $01,x	                sta 1,x
.99c6		60		rts		z_pick:         rts
.99c7						xt_plus:
.99c7		20 74 d8	jsr $d874	                jsr underflow_2
.99ca		18		clc		                clc
.99cb		b5 00		lda $00,x	                lda 0,x         ; LSB
.99cd		75 02		adc $02,x	                adc 2,x
.99cf		95 02		sta $02,x	                sta 2,x
.99d1		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.99d3		75 03		adc $03,x	                adc 3,x
.99d5		95 03		sta $03,x	                sta 3,x
.99d7		e8		inx		                inx
.99d8		e8		inx		                inx
.99d9		60		rts		z_plus:         rts
.99da						xt_plus_store:
.99da		20 74 d8	jsr $d874	                jsr underflow_2
.99dd		b5 00		lda $00,x	                lda 0,x
.99df		85 24		sta $24		                sta tmp1
.99e1		b5 01		lda $01,x	                lda 1,x
.99e3		85 25		sta $25		                sta tmp1+1
.99e5		a0 00		ldy #$00	                ldy #0          ; LSB
.99e7		b1 24		lda ($24),y	                lda (tmp1),y
.99e9		18		clc		                clc
.99ea		75 02		adc $02,x	                adc 2,x
.99ec		91 24		sta ($24),y	                sta (tmp1),y
.99ee		c8		iny		                iny             ; MSB
.99ef		b1 24		lda ($24),y	                lda (tmp1),y
.99f1		75 03		adc $03,x	                adc 3,x
.99f3		91 24		sta ($24),y	                sta (tmp1),y
.99f5		e8		inx		                inx
.99f6		e8		inx		                inx
.99f7		e8		inx		                inx
.99f8		e8		inx		                inx
.99f9		60		rts		z_plus_store:   rts
.99fa						xt_postpone:
.99fa		20 c3 98	jsr $98c3	                jsr xt_parse_name               ; ( -- addr n )
.99fd		b5 00		lda $00,x	                lda 0,x
.99ff		15 01		ora $01,x	                ora 1,x
.9a01		d0 05		bne $9a08	                bne +
.9a03		a9 05		lda #$05	                lda #err_noname
.9a05		4c 85 d8	jmp $d885	                jmp error
.9a08						+
.9a08		20 c0 8f	jsr $8fc0	                jsr xt_find_name                ; ( -- nt | 0 )
.9a0b		d0 05		bne $9a12	                bne +
.9a0d		a9 05		lda #$05	                lda #err_noname
.9a0f		4c 85 d8	jmp $d885	                jmp error
.9a12						+
.9a12		b5 00		lda $00,x	                lda 0,x
.9a14		85 24		sta $24		                sta tmp1
.9a16		b5 01		lda $01,x	                lda 1,x
.9a18		85 25		sta $25		                sta tmp1+1
.9a1a		20 c5 95	jsr $95c5	                jsr xt_name_to_int              ; ( nt -- xt )
.9a1d		e6 24		inc $24		                inc tmp1
.9a1f		d0 02		bne $9a23	                bne +
.9a21		e6 25		inc $25		                inc tmp1+1
.9a23						+
.9a23		b2 24		lda ($24)	                lda (tmp1)
.9a25		29 04		and #$04	                and #IM         ; mask all but Intermediate flag
.9a27		f0 05		beq $9a2e	                beq _not_immediate
.9a29		20 a3 87	jsr $87a3	                jsr xt_compile_comma
.9a2c		80 0a		bra $9a38	                bra _done
.9a2e						_not_immediate:
.9a2e		20 6b 93	jsr $936b	                jsr xt_literal
.9a31		a0 87		ldy #$87	                ldy #>xt_compile_comma
.9a33		a9 a3		lda #$a3	                lda #<xt_compile_comma
.9a35		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.9a38						_done:
.9a38		60		rts		z_postpone:     rts
.9a39						xt_previous:
.9a39		20 19 91	jsr $9119	                jsr xt_get_order
.9a3c		20 26 96	jsr $9626	                jsr xt_nip
.9a3f		20 f5 97	jsr $97f5	                jsr xt_one_minus
.9a42		20 f8 9c	jsr $9cf8	                jsr xt_set_order
.9a45		60		rts		z_previous:     rts
.9a46						xt_question:
.9a46		20 65 8f	jsr $8f65	                jsr xt_fetch
.9a49		20 e9 8b	jsr $8be9	                jsr xt_dot
.9a4c		60		rts		z_question:     rts
.9a4d						xt_question_dup:
.9a4d		20 6f d8	jsr $d86f	                jsr underflow_1
.9a50		b5 00		lda $00,x	                lda 0,x
.9a52		15 01		ora $01,x	                ora 1,x
.9a54		f0 0a		beq $9a60	                beq _done
.9a56		ca		dex		                dex
.9a57		ca		dex		                dex
.9a58		b5 02		lda $02,x	                lda 2,x
.9a5a		95 00		sta $00,x	                sta 0,x
.9a5c		b5 03		lda $03,x	                lda 3,x
.9a5e		95 01		sta $01,x	                sta 1,x
.9a60						_done:
.9a60		60		rts		z_question_dup: rts
.9a61						xt_r_fetch:
.9a61		7a		ply		                ply             ; LSB
.9a62		84 24		sty $24		                sty tmp1
.9a64		7a		ply		                ply             ; MSB
.9a65		ca		dex		                dex
.9a66		ca		dex		                dex
.9a67		68		pla		                pla             ; LSB
.9a68		95 00		sta $00,x	                sta 0,x
.9a6a		68		pla		                pla             ; MSB
.9a6b		95 01		sta $01,x	                sta 1,x
.9a6d		48		pha		                pha
.9a6e		b5 00		lda $00,x	                lda 0,x
.9a70		48		pha		                pha
.9a71		5a		phy		                phy             ; MSB
.9a72		a4 24		ldy $24		                ldy tmp1
.9a74		5a		phy		                phy             ; LSB
.9a75		60		rts		z_r_fetch:      rts
.9a76						xt_r_from:
.9a76		68		pla		                pla             ; LSB
.9a77		85 2c		sta $2c		                sta tmptos
.9a79		7a		ply		                ply             ; MSB
.9a7a		ca		dex		                dex
.9a7b		ca		dex		                dex
.9a7c		68		pla		                pla             ; LSB
.9a7d		95 00		sta $00,x	                sta 0,x
.9a7f		68		pla		                pla             ; MSB
.9a80		95 01		sta $01,x	                sta 1,x
.9a82		5a		phy		                phy             ; MSB
.9a83		a5 2c		lda $2c		                lda tmptos
.9a85		48		pha		                pha             ; LSB
.9a86		60		rts		z_r_from:       rts
.9a87						xt_r_to_input:
.9a87		68		pla		                pla
.9a88		85 24		sta $24		                sta tmp1
.9a8a		68		pla		                pla
.9a8b		85 25		sta $25		                sta tmp1+1
.9a8d		a0 00		ldy #$00	                ldy #0
.9a8f						_loop:
.9a8f		68		pla		                pla
.9a90		99 06 00	sta $0006,y	                sta insrc,y
.9a93		c8		iny		                iny
.9a94		c0 08		cpy #$08	                cpy #8
.9a96		d0 f7		bne $9a8f	                bne _loop
.9a98		a5 25		lda $25		                lda tmp1+1
.9a9a		48		pha		                pha
.9a9b		a5 24		lda $24		                lda tmp1
.9a9d		48		pha		                pha
.9a9e		60		rts		z_r_to_input: 	rts
.9a9f						xt_recurse:
.9a9f		a0 00		ldy #$00	                ldy #0
.9aa1		a9 20		lda #$20	                lda #$20        ; opcode for JSR
.9aa3		91 00		sta ($00),y	                sta (cp),y
.9aa5		c8		iny		                iny
.9aa6		24 20		bit $20		                bit status
.9aa8		70 0c		bvs $9ab6	                bvs _nt_in_workword
.9aaa		a5 04		lda $04		                lda workword
.9aac		91 00		sta ($00),y	                sta (cp),y
.9aae		c8		iny		                iny
.9aaf		a5 05		lda $05		                lda workword+1
.9ab1		91 00		sta ($00),y	                sta (cp),y
.9ab3		c8		iny		                iny
.9ab4		80 1b		bra $9ad1	                bra _update_cp
.9ab6						_nt_in_workword:
.9ab6		a5 04		lda $04		                lda workword            ; LSB
.9ab8		18		clc		                clc
.9ab9		69 04		adc #$04	                adc #4
.9abb		85 24		sta $24		                sta tmp1
.9abd		a5 05		lda $05		                lda workword+1          ; MSB
.9abf		69 00		adc #$00	                adc #0
.9ac1		85 25		sta $25		                sta tmp1+1
.9ac3		b2 24		lda ($24)	                lda (tmp1)
.9ac5		91 00		sta ($00),y	                sta (cp),y
.9ac7		5a		phy		                phy
.9ac8		a0 01		ldy #$01	                ldy #1
.9aca		b1 24		lda ($24),y	                lda (tmp1),y
.9acc		7a		ply		                ply
.9acd		c8		iny		                iny
.9ace		91 00		sta ($00),y	                sta (cp),y
.9ad0		c8		iny		                iny
.9ad1						_update_cp:
.9ad1		98		tya		                tya
.9ad2		18		clc		                clc
.9ad3		65 00		adc $00		                adc cp
.9ad5		85 00		sta $00		                sta cp
.9ad7		90 02		bcc $9adb	                bcc _done
.9ad9		e6 01		inc $01		                inc cp+1
.9adb						_done:
.9adb		60		rts		z_recurse:      rts
.9adc						xt_refill:
.9adc		a5 06		lda $06		                lda insrc               ; cheat: We only check LSB
.9ade		d0 2d		bne $9b0d	                bne _src_not_kbd
.9ae0		ca		dex		                dex
.9ae1		ca		dex		                dex
.9ae2		ca		dex		                dex
.9ae3		ca		dex		                dex
.9ae4		a5 08		lda $08		                lda cib                 ; address of CIB is NOS
.9ae6		95 02		sta $02,x	                sta 2,x
.9ae8		a5 09		lda $09		                lda cib+1
.9aea		95 03		sta $03,x	                sta 3,x
.9aec		64 0a		stz $0a		                stz ciblen              ; go in with empty buffer
.9aee		64 0b		stz $0b		                stz ciblen+1
.9af0		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.9af2		95 00		sta $00,x	                sta 0,x
.9af4		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.9af6		20 e2 80	jsr $80e2	                jsr xt_accept           ; ( addr n1 -- n2)
.9af9		b5 00		lda $00,x	                lda 0,x
.9afb		85 0a		sta $0a		                sta ciblen
.9afd		b5 01		lda $01,x	                lda 1,x
.9aff		85 0b		sta $0b		                sta ciblen+1            ; though we only accept 255 chars
.9b01		64 0c		stz $0c		                stz toin
.9b03		64 0d		stz $0d		                stz toin+1
.9b05		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.9b07		95 00		sta $00,x	                sta 0,x
.9b09		95 01		sta $01,x	                sta 1,x
.9b0b		80 10		bra $9b1d	                bra _done
.9b0d						_src_not_kbd:
.9b0d		1a		inc a		                ina
.9b0e		d0 08		bne $9b18	                bne _src_not_string
.9b10		ca		dex		                dex
.9b11		ca		dex		                dex
.9b12		74 00		stz $00,x	                stz 0,x
.9b14		74 01		stz $01,x	                stz 1,x
.9b16		80 05		bra $9b1d	                bra z_refill
.9b18						_src_not_string:
.9b18		a9 01		lda #$01	                lda #err_badsource
.9b1a		4c 85 d8	jmp $d885	                jmp error
.9b1d						_done:
.9b1d		60		rts		z_refill:       rts
.9b1e						xt_repeat:
.9b1e		20 1d 82	jsr $821d	                jsr xt_again
.9b21		4c 85 8d	jmp $8d85	                jmp xt_then
.9b24						z_repeat:
.9b24						xt_right_bracket:
.9b24		a9 ff		lda #$ff	                lda #$FF
.9b26		85 16		sta $16		                sta state
.9b28		85 17		sta $17		                sta state+1
.9b2a						z_right_bracket:
.9b2a		60		rts		                rts
.9b2b						xt_root_wordlist:
.9b2b		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.9b2c		ca		dex		                dex
.9b2d		a9 03		lda #$03	                lda #3
.9b2f		95 00		sta $00,x	                sta 0,x
.9b31		74 01		stz $01,x	                stz 1,x
.9b33						z_root_wordlist:
.9b33		60		rts		                rts
.9b34						xt_rot:
.9b34		20 79 d8	jsr $d879	                jsr underflow_3
.9b37		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.9b39		b5 03		lda $03,x	                lda 3,x
.9b3b		95 05		sta $05,x	                sta 5,x
.9b3d		b5 01		lda $01,x	                lda 1,x
.9b3f		95 03		sta $03,x	                sta 3,x
.9b41		94 01		sty $01,x	                sty 1,x
.9b43		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.9b45		b5 02		lda $02,x	                lda 2,x
.9b47		95 04		sta $04,x	                sta 4,x
.9b49		b5 00		lda $00,x	                lda 0,x
.9b4b		95 02		sta $02,x	                sta 2,x
.9b4d		94 00		sty $00,x	                sty 0,x
.9b4f		60		rts		z_rot:          rts
.9b50						xt_rshift:
.9b50		20 74 d8	jsr $d874	                jsr underflow_2
.9b53		b5 00		lda $00,x	                lda 0,x
.9b55		29 0f		and #$0f	                and #%00001111
.9b57		f0 08		beq $9b61	                beq _done               ; if 0 shifts, quit
.9b59		a8		tay		                tay
.9b5a						_loop:
.9b5a		56 03		lsr $03,x	                lsr 3,x
.9b5c		76 02		ror $02,x	                ror 2,x
.9b5e		88		dey		                dey
.9b5f		d0 f9		bne $9b5a	                bne _loop
.9b61						_done:
.9b61		e8		inx		                inx
.9b62		e8		inx		                inx
.9b63		60		rts		z_rshift:       rts
.9b64						xt_s_backslash_quote:
.9b64		a9 ff		lda #$ff	                lda #$FF
.9b66		85 26		sta $26		                sta tmp2
.9b68		64 27		stz $27		                stz tmp2+1
.9b6a		20 30 9d	jsr $9d30	                jsr s_quote_start
.9b6d						_done:
.9b6d						z_s_backslash_quote:
.9b6d		60		rts		                rts
.9b6e						convert_hex_value:
.9b6e		c9 41		cmp #$41	        cmp #'A'
.9b70		90 07		bcc $9b79	        bcc _digit
.9b72		29 df		and #$df	        and #$DF                ; Make it uppercase.
.9b74		38		sec		        sec
.9b75		e9 37		sbc #$37	        sbc #'7'                 ; gives value 10 for 'A'
.9b77		80 03		bra $9b7c	        bra _done
.9b79						_digit:
.9b79		38		sec		        sec
.9b7a		e9 30		sbc #$30	        sbc #'0'
.9b7c						_done:
.9b7c		60		rts		        rts
.9b7d						xt_search_wordlist:
.9b7d		20 79 d8	jsr $d879	                jsr underflow_3
.9b80		a5 1e		lda $1e		                lda up
.9b82		18		clc		                clc
.9b83		69 06		adc #$06	                adc #wordlists_offset
.9b85		85 26		sta $26		                sta tmp2
.9b87		a5 1f		lda $1f		                lda up+1
.9b89		69 00		adc #$00	                adc #0          ; Adding carry
.9b8b		85 27		sta $27		                sta tmp2+1
.9b8d		b5 00		lda $00,x	                lda 0,x
.9b8f		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.9b90		65 26		adc $26		                adc tmp2
.9b92		85 26		sta $26		                sta tmp2
.9b94		90 02		bcc $9b98	                bcc +
.9b96		e6 27		inc $27		                inc tmp2+1      ; Propagate carry if needed.
.9b98						+
.9b98		e8		inx		                inx
.9b99		e8		inx		                inx
.9b9a		b5 00		lda $00,x	                lda 0,x
.9b9c		15 01		ora $01,x	                ora 1,x
.9b9e		d0 03		bne $9ba3	                bne _check_wordlist
.9ba0		4c 5b 9c	jmp $9c5b	                jmp _done
.9ba3						_check_wordlist:
.9ba3		a5 26		lda $26		                lda tmp2
.9ba5		05 27		ora $27		                ora tmp2+1
.9ba7		d0 03		bne $9bac	                bne _have_string
.9ba9		4c 5b 9c	jmp $9c5b	                jmp _done
.9bac						_have_string:
.9bac		b2 26		lda ($26)	                lda (tmp2)              ; nt of first word in Dictionary
.9bae		85 24		sta $24		                sta tmp1
.9bb0		e6 26		inc $26		                inc tmp2                ; Move to the upper byte
.9bb2		d0 02		bne $9bb6	                bne +
.9bb4		e6 27		inc $27		                inc tmp2+1
.9bb6						+
.9bb6		b2 26		lda ($26)	                lda (tmp2)
.9bb8		85 25		sta $25		                sta tmp1+1
.9bba		b5 02		lda $02,x	                lda 2,x                 ; Address of mystery string
.9bbc		85 26		sta $26		                sta tmp2
.9bbe		b5 03		lda $03,x	                lda 3,x
.9bc0		85 27		sta $27		                sta tmp2+1
.9bc2						_loop:
.9bc2		b2 24		lda ($24)	                lda (tmp1)
.9bc4		d5 00		cmp $00,x	                cmp 0,x
.9bc6		d0 7b		bne $9c43	                bne _next_entry
.9bc8						_compare_string:
.9bc8		b2 26		lda ($26)	                lda (tmp2)      ; first character of mystery string
.9bca		c9 5b		cmp #$5b	                cmp #$5B        ; ASCII '[' (one past Z)
.9bcc		b0 07		bcs $9bd5	                bcs _compare_first
.9bce		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bd0		90 03		bcc $9bd5	                bcc _compare_first
.9bd2		18		clc		                clc
.9bd3		69 20		adc #$20	                adc #$20
.9bd5						_compare_first:
.9bd5		a0 08		ldy #$08	                ldy #8          ; Offset in nt to name
.9bd7		d1 24		cmp ($24),y	                cmp (tmp1),y    ; first character of current word
.9bd9		d0 68		bne $9c43	                bne _next_entry
.9bdb		b5 00		lda $00,x	                lda 0,x
.9bdd		3a		dec a		                dea
.9bde		f0 2c		beq $9c0c	                beq _success
.9be0		a5 24		lda $24		                lda tmp1
.9be2		48		pha		                pha             ; Preserve tmp1 on the return stack.
.9be3		18		clc		                clc
.9be4		69 08		adc #$08	                adc #8
.9be6		85 24		sta $24		                sta tmp1        ; Reusing tmp1 temporarily for string check.
.9be8		a5 25		lda $25		                lda tmp1+1
.9bea		48		pha		                pha             ; Preserve tmp1+1 on the return stack.
.9beb		69 00		adc #$00	                adc #0          ; we only need the carry
.9bed		85 25		sta $25		                sta tmp1+1
.9bef		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.9bf1		88		dey		                dey
.9bf2						_string_loop:
.9bf2		b1 26		lda ($26),y	                lda (tmp2),y    ; last char of mystery string
.9bf4		c9 5b		cmp #$5b	                cmp #$5B         ; ASCII '[' (one past Z)
.9bf6		b0 07		bcs $9bff	                bcs _check_char
.9bf8		c9 41		cmp #$41	                cmp #$41        ; ASCII 'A'
.9bfa		90 03		bcc $9bff	                bcc _check_char
.9bfc		18		clc		                clc
.9bfd		69 20		adc #$20	                adc #$20
.9bff						_check_char:
.9bff		d1 24		cmp ($24),y	                cmp (tmp1),y    ; last char of word we're testing against
.9c01		d0 3a		bne $9c3d	                bne _next_entry_tmp1
.9c03		88		dey		                dey
.9c04		d0 ec		bne $9bf2	                bne _string_loop
.9c06						_success_tmp1:
.9c06		68		pla		                pla             ; Restore tmp1 from the return stack.
.9c07		85 25		sta $25		                sta tmp1+1
.9c09		68		pla		                pla
.9c0a		85 24		sta $24		                sta tmp1
.9c0c						_success:
.9c0c		e8		inx		                inx
.9c0d		e8		inx		                inx
.9c0e		a5 24		lda $24		                lda tmp1
.9c10		95 00		sta $00,x	                sta 0,x
.9c12		a5 25		lda $25		                lda tmp1+1
.9c14		95 01		sta $01,x	                sta 1,x
.9c16		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9c19		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt xt )
.9c1c		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( xt nt )
.9c1f		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.9c21		f6 00		inc $00,x	                inc 0,x
.9c23		d0 02		bne $9c27	                bne +
.9c25		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.9c27						+
.9c27		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.9c29		29 04		and #$04	                and #IM
.9c2b		d0 08		bne $9c35	                bne _immediate          ; bit set, we're immediate
.9c2d		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.9c2f		95 00		sta $00,x	                sta 0,x
.9c31		95 01		sta $01,x	                sta 1,x
.9c33		80 28		bra $9c5d	                bra _done_nodrop
.9c35						_immediate:
.9c35		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.9c37		95 00		sta $00,x	                sta 0,x
.9c39		74 01		stz $01,x	                stz 1,x
.9c3b		80 20		bra $9c5d	                bra _done_nodrop
.9c3d						_next_entry_tmp1:
.9c3d		68		pla		                pla             ; Restore tmp1 from the return stack.
.9c3e		85 25		sta $25		                sta tmp1+1
.9c40		68		pla		                pla
.9c41		85 24		sta $24		                sta tmp1
.9c43						_next_entry:
.9c43		a0 02		ldy #$02	                ldy #2
.9c45		b1 24		lda ($24),y	                lda (tmp1),y
.9c47		48		pha		                pha
.9c48		c8		iny		                iny
.9c49		b1 24		lda ($24),y	                lda (tmp1),y
.9c4b		85 25		sta $25		                sta tmp1+1
.9c4d		68		pla		                pla
.9c4e		85 24		sta $24		                sta tmp1
.9c50		05 25		ora $25		                ora tmp1+1
.9c52		f0 03		beq $9c57	                beq _fail_done
.9c54		4c c2 9b	jmp $9bc2	                jmp _loop
.9c57						_fail_done:
.9c57		74 02		stz $02,x	                stz 2,x         ; failure flag
.9c59		74 03		stz $03,x	                stz 3,x
.9c5b						_done:
.9c5b		e8		inx		                inx
.9c5c		e8		inx		                inx
.9c5d						_done_nodrop:
.9c5d						z_search_wordlist:
.9c5d		60		rts		                rts
.9c5e						xt_see:
.9c5e		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( addr u )
.9c61		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( nt | 0 )
.9c64		b5 00		lda $00,x	                lda 0,x
.9c66		15 01		ora $01,x	                ora 1,x
.9c68		d0 05		bne $9c6f	                bne +
.9c6a		a9 05		lda #$05	                lda #err_noname
.9c6c		4c 85 d8	jmp $d885	                jmp error
.9c6f						+
.9c6f		20 2a 89	jsr $892a	                jsr xt_cr
.9c72		a5 18		lda $18		                lda base
.9c74		48		pha		                pha
.9c75		20 62 91	jsr $9162	                jsr xt_hex
.9c78		a9 09		lda #$09	                lda #str_see_nt
.9c7a		20 ab d8	jsr $d8ab	                jsr print_string_no_lf
.9c7d		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9c80		20 d2 a4	jsr $a4d2	                jsr xt_u_dot
.9c83		20 cc a0	jsr $a0cc	                jsr xt_space            ; ( nt )
.9c86		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.9c89		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt xt )
.9c8c		a9 0a		lda #$0a	                lda #str_see_xt
.9c8e		20 ab d8	jsr $d8ab	                jsr print_string_no_lf
.9c91		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt xt xt )
.9c94		20 d2 a4	jsr $a4d2	                jsr xt_u_dot
.9c97		20 2a 89	jsr $892a	                jsr xt_cr               ; ( nt xt )
.9c9a		a9 08		lda #$08	                lda #str_see_flags
.9c9c		20 ab d8	jsr $d8ab	                jsr print_string_no_lf
.9c9f		20 77 98	jsr $9877	                jsr xt_over             ; ( nt xt nt )
.9ca2		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( nt xt nt+1 )
.9ca5		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( nt xt flags )
.9ca8		b5 00		lda $00,x	                lda 0,x
.9caa		a0 06		ldy #$06	                ldy #6                  ; Not all bits are used
.9cac						_flag_loop:
.9cac		48		pha		                pha
.9cad		29 01		and #$01	                and #%00000001
.9caf		18		clc		                clc
.9cb0		69 30		adc #$30	                adc #$30                ; ASCII "0"
.9cb2		20 db 8d	jsr $8ddb	                jsr emit_a
.9cb5		20 cc a0	jsr $a0cc	                jsr xt_space
.9cb8		68		pla		                pla
.9cb9		6a		ror a		                ror                     ; Next flag
.9cba		88		dey		                dey
.9cbb		d0 ef		bne $9cac	                bne _flag_loop
.9cbd		20 2a 89	jsr $892a	                jsr xt_cr
.9cc0		e8		inx		                inx
.9cc1		e8		inx		                inx                     ; ( nt xt )
.9cc2		a9 0b		lda #$0b	                lda #str_see_size
.9cc4		20 ab d8	jsr $d8ab	                jsr print_string_no_lf
.9cc7		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( xt nt )
.9cca		20 23 a7	jsr $a723	                jsr xt_wordsize         ; ( xt u )
.9ccd		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
.9cd0		20 6c 8a	jsr $8a6c	                jsr xt_decimal
.9cd3		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; ( xt u )
.9cd6		20 62 91	jsr $9162	                jsr xt_hex
.9cd9		20 2a 89	jsr $892a	                jsr xt_cr
.9cdc		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( xt u xt u )
.9cdf		20 e7 8c	jsr $8ce7	                jsr xt_dump
.9ce2		20 2a 89	jsr $892a	                jsr xt_cr
.9ce5		20 01 8b	jsr $8b01	                jsr xt_disasm
.9ce8		68		pla		                pla
.9ce9		85 18		sta $18		                sta base
.9ceb		60		rts		z_see:          rts
.9cec						xt_set_current:
.9cec		20 6f d8	jsr $d86f	                jsr underflow_1
.9cef		a0 04		ldy #$04	                ldy #current_offset
.9cf1		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.9cf3		91 1e		sta ($1e),y	                sta (up),y      ; so only the LSB is used.
.9cf5		e8		inx		                inx
.9cf6		e8		inx		                inx
.9cf7		60		rts		z_set_current:  rts
.9cf8						xt_set_order:
.9cf8		a9 ff		lda #$ff	                lda #$FF
.9cfa		d5 01		cmp $01,x	                cmp 1,x
.9cfc		d0 12		bne $9d10	                bne _start
.9cfe		d5 00		cmp $00,x	                cmp 0,x
.9d00		d0 0e		bne $9d10	                bne _start
.9d02		ca		dex		                dex             ; Make room for the count.
.9d03		ca		dex		                dex
.9d04		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.9d06		a9 03		lda #$03	                lda #3
.9d08		95 02		sta $02,x	                sta 2,x
.9d0a		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.9d0c		a9 01		lda #$01	                lda #1
.9d0e		95 00		sta $00,x	                sta 0,x
.9d10						_start:
.9d10		a0 1e		ldy #$1e	                ldy #num_order_offset
.9d12		b5 00		lda $00,x	                lda 0,x
.9d14		91 1e		sta ($1e),y	                sta (up),y      ; #ORDER is a byte variable.
.9d16		85 24		sta $24		                sta tmp1        ; Save a copy for zero check and looping.
.9d18		e8		inx		                inx             ; Drop the count off the data stack.
.9d19		e8		inx		                inx
.9d1a		a5 24		lda $24		                lda tmp1
.9d1c		f0 0d		beq $9d2b	                beq _done       ; If zero, there are no wordlists.
.9d1e		a0 1f		ldy #$1f	                ldy #search_order_offset
.9d20						_loop:
.9d20		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.9d22		91 1e		sta ($1e),y	                sta (up),y      ; so only save the LSB
.9d24		c8		iny		                iny
.9d25		e8		inx		                inx
.9d26		e8		inx		                inx
.9d27		c6 24		dec $24		                dec tmp1
.9d29		d0 f5		bne $9d20	                bne _loop
.9d2b						_done:
.9d2b		60		rts		z_set_order:    rts
.9d2c						xt_s_quote:
.9d2c		64 26		stz $26		                stz tmp2
.9d2e		64 27		stz $27		                stz tmp2+1
.9d30						s_quote_start:
.9d30		ca		dex		                dex
.9d31		ca		dex		                dex
.9d32		ca		dex		                dex
.9d33		ca		dex		                dex
.9d34		a9 4c		lda #$4c	                lda #$4C
.9d36		20 22 d7	jsr $d722	                jsr cmpl_a
.9d39		20 22 d7	jsr $d722	                jsr cmpl_a
.9d3c		20 22 d7	jsr $d722	                jsr cmpl_a
.9d3f		a5 00		lda $00		                lda cp
.9d41		95 02		sta $02,x	                sta 2,x
.9d43		a5 01		lda $01		                lda cp+1
.9d45		95 03		sta $03,x	                sta 3,x
.9d47						_savechars_loop:
.9d47		a5 0d		lda $0d		                lda toin+1              ; MSB
.9d49		c5 0b		cmp $0b		                cmp ciblen+1
.9d4b		90 2a		bcc $9d77	                bcc _input_fine         ; unsigned comparison
.9d4d		a5 0c		lda $0c		                lda toin                ; LSB
.9d4f		c5 0a		cmp $0a		                cmp ciblen
.9d51		90 24		bcc $9d77	                bcc _input_fine
.9d53		a5 26		lda $26		                lda tmp2
.9d55		48		pha		                pha
.9d56		a5 27		lda $27		                lda tmp2+1
.9d58		48		pha		                pha
.9d59		a5 28		lda $28		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.9d5b		48		pha		                pha
.9d5c		20 dc 9a	jsr $9adc	                jsr xt_refill           ; ( -- f )
.9d5f		68		pla		                pla
.9d60		85 28		sta $28		                sta tmp3
.9d62		68		pla		                pla
.9d63		85 27		sta $27		                sta tmp2+1
.9d65		68		pla		                pla
.9d66		85 26		sta $26		                sta tmp2
.9d68		b5 00		lda $00,x	                lda 0,x
.9d6a		15 01		ora $01,x	                ora 1,x
.9d6c		d0 05		bne $9d73	                bne _refill_ok
.9d6e		a9 06		lda #$06	                lda #err_refill
.9d70		4c 85 d8	jmp $d885	                jmp error
.9d73						_refill_ok:
.9d73		e8		inx		                inx
.9d74		e8		inx		                inx
.9d75		80 d0		bra $9d47	                bra _savechars_loop
.9d77						_input_fine:
.9d77		a5 08		lda $08		                lda cib
.9d79		18		clc		                clc
.9d7a		65 0c		adc $0c		                adc toin        ; LSB
.9d7c		85 24		sta $24		                sta tmp1
.9d7e		a5 09		lda $09		                lda cib+1
.9d80		65 0d		adc $0d		                adc toin+1      ; MSB
.9d82		85 25		sta $25		                sta tmp1+1
.9d84		b2 24		lda ($24)	                lda (tmp1)
.9d86		24 26		bit $26		                bit tmp2
.9d88		30 03		bmi $9d8d	                bmi _handle_escapes    ; Only checking bit 7
.9d8a		4c 16 9e	jmp $9e16	                jmp _regular_char
.9d8d						_handle_escapes:
.9d8d		24 27		bit $27		                bit tmp2+1
.9d8f		30 03		bmi $9d94	                bmi _escaped
.9d91		4c 0c 9e	jmp $9e0c	                jmp _not_escaped
.9d94						_escaped:
.9d94		70 3c		bvs $9dd2	                bvs _check_esc_chars
.9d96		a9 01		lda #$01	                lda #1
.9d98		24 27		bit $27		                bit tmp2+1
.9d9a		d0 10		bne $9dac	                bne _esc_x_second_digit
.9d9c		e6 27		inc $27		                inc tmp2+1  ; Adjust flag for second digit next time.
.9d9e		b2 24		lda ($24)	                lda (tmp1)  ; Get the char again.
.9da0		20 6e 9b	jsr $9b6e	                jsr convert_hex_value
.9da3		0a		asl a		                asl
.9da4		0a		asl a		                asl
.9da5		0a		asl a		                asl
.9da6		0a		asl a		                asl
.9da7		85 28		sta $28		                sta tmp3    ; Save it for later.
.9da9		4c 1d 9e	jmp $9e1d	                jmp _next_character
.9dac						_esc_x_second_digit:
.9dac		64 27		stz $27		                stz tmp2+1
.9dae		b2 24		lda ($24)	                lda (tmp1)
.9db0		20 6e 9b	jsr $9b6e	                jsr convert_hex_value
.9db3		05 28		ora $28		                ora tmp3
.9db5		4c 1a 9e	jmp $9e1a	                jmp _save_character
.9db8						_esc_tr_table:
>9db8		07				    .byte   7               ; a -> BEL (ASCII value 7)
>9db9		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>9dba		00 00				    .byte   0,0             ; c, d no escape
>9dbc		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>9dbd		0c				    .byte   12              ; f -> FF (ASCII value 12)
>9dbe		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>9dc3		0a				    .byte   10              ; l -> LF (ASCII value 10)
>9dc4		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>9dc5		0a				    .byte   10              ; n behaves like l --> lf
>9dc6		00 00				    .byte   0,0             ; o,p
>9dc8		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>9dc9		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>9dca		00				    .byte   0               ; s
>9dcb		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>9dcc		00				    .byte   0               ; u
>9dcd		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>9dce		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>9dd1		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.9dd2						_check_esc_chars:
.9dd2		64 27		stz $27		                stz tmp2+1
.9dd4		c9 61		cmp #$61	                cmp #'a'
.9dd6		30 1a		bmi $9df2	                bmi _check_esc_quote
.9dd8		c9 7b		cmp #$7b	                cmp #'z'+1
.9dda		10 16		bpl $9df2	                bpl _check_esc_quote
.9ddc		a8		tay		                tay
.9ddd		b9 57 9d	lda $9d57,y	                lda _esc_tr_table - 'a',y   ; fake base address to index with a-z directly
.9de0		d0 03		bne $9de5	                bne _esc_replace
.9de2		98		tya		                tya                     ; revert if no translation
.9de3		80 0d		bra $9df2	                bra _check_esc_quote
.9de5		10 33		bpl $9e1a	_esc_replace:   bpl _save_character     ; simple replacement
.9de7		29 7f		and #$7f	                and #$7f                ; clear hi bit
.9de9		f0 2f		beq $9e1a	                beq _save_character     ; NUL we can just output
.9deb		20 22 d7	jsr $d722	                jsr cmpl_a              ; else output first char (CR)
.9dee		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9df0		80 28		bra $9e1a	                bra _save_character
.9df2						_check_esc_quote:
.9df2		c9 22		cmp #$22	                cmp #$22
.9df4		d0 04		bne $9dfa	                bne _check_esc_x
.9df6		a9 22		lda #$22	                lda #34
.9df8		80 20		bra $9e1a	                bra _save_character
.9dfa						_check_esc_x:
.9dfa		c9 78		cmp #$78	                cmp #'x'
.9dfc		d0 06		bne $9e04	                bne _check_esc_backslash
.9dfe		a9 be		lda #$be	                lda #$BE        ; Clear bits 6 and 0
.9e00		85 27		sta $27		                sta tmp2+1
.9e02		80 19		bra $9e1d	                bra _next_character
.9e04						_check_esc_backslash:
.9e04		c9 5c		cmp #$5c	                cmp #$5C
.9e06		d0 04		bne $9e0c	                bne _not_escaped
.9e08		a9 5c		lda #$5c	                lda #92
.9e0a		80 0e		bra $9e1a	                bra _save_character
.9e0c						_not_escaped:
.9e0c		c9 5c		cmp #$5c	                cmp #$5C        ; The backslash char
.9e0e		d0 06		bne $9e16	                bne _regular_char
.9e10		a9 ff		lda #$ff	                lda #$FF
.9e12		85 27		sta $27		                sta tmp2+1
.9e14		80 07		bra $9e1d	                bra _next_character
.9e16						_regular_char:
.9e16		c9 22		cmp #$22	                cmp #$22        ; ASCII for "
.9e18		f0 0c		beq $9e26	                beq _found_string_end
.9e1a						_save_character:
.9e1a		20 22 d7	jsr $d722	                jsr cmpl_a
.9e1d						_next_character:
.9e1d		e6 0c		inc $0c		                inc toin
.9e1f		d0 02		bne $9e23	                bne _savechars_loop_longjump
.9e21		e6 0d		inc $0d		                inc toin+1
.9e23						_savechars_loop_longjump:
.9e23		4c 47 9d	jmp $9d47	                jmp _savechars_loop
.9e26						_found_string_end:
.9e26		e6 0c		inc $0c		                inc toin
.9e28		d0 02		bne $9e2c	                bne +
.9e2a		e6 0d		inc $0d		                inc toin+1
.9e2c						+
.9e2c		a5 00		lda $00		                lda cp
.9e2e		38		sec		                sec
.9e2f		f5 02		sbc $02,x	                sbc 2,x
.9e31		95 00		sta $00,x	                sta 0,x         ; LSB
.9e33		a5 01		lda $01		                lda cp+1
.9e35		f5 03		sbc $03,x	                sbc 3,x
.9e37		95 01		sta $01,x	                sta 1,x         ; MSB
.9e39		b5 02		lda $02,x	                lda 2,x
.9e3b		38		sec		                sec
.9e3c		e9 02		sbc #$02	                sbc #2
.9e3e		85 24		sta $24		                sta tmp1
.9e40		b5 03		lda $03,x	                lda 3,x
.9e42		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.9e44		85 25		sta $25		                sta tmp1+1
.9e46		a5 00		lda $00		                lda cp
.9e48		92 24		sta ($24)	                sta (tmp1)
.9e4a		a0 01		ldy #$01	                ldy #1
.9e4c		a5 01		lda $01		                lda cp+1
.9e4e		91 24		sta ($24),y	                sta (tmp1),y
.9e50		a5 16		lda $16		                lda state
.9e52		05 17		ora $17		                ora state+1             ; paranoid
.9e54		f0 03		beq $9e59	                beq _done
.9e56		20 3d a0	jsr $a03d	                jsr sliteral_const_str         ; ( addr u -- )
.9e59						_done:
.9e59		60		rts		z_s_quote:      rts
.9e5a						xt_s_to_d:
.9e5a		20 6f d8	jsr $d86f	                jsr underflow_1
.9e5d		ca		dex		                dex
.9e5e		ca		dex		                dex
.9e5f		74 00		stz $00,x	                stz 0,x
.9e61		74 01		stz $01,x	                stz 1,x
.9e63		b5 03		lda $03,x	                lda 3,x
.9e65		10 04		bpl $9e6b	                bpl _done
.9e67		d6 00		dec $00,x	                dec 0,x
.9e69		d6 01		dec $01,x	                dec 1,x
.9e6b						_done:
.9e6b		60		rts		z_s_to_d:       rts
.9e6c						xt_save_buffers:
.9e6c		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e6e		b1 1e		lda ($1e),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.9e70		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.9e72		d0 12		bne $9e86	                bne _done       ; Either not used or not dirty = done!
.9e74		20 69 83	jsr $8369	                jsr xt_blkbuffer
.9e77		20 5b 85	jsr $855b	                jsr xt_buffblocknum
.9e7a		20 65 8f	jsr $8f65	                jsr xt_fetch
.9e7d		20 16 85	jsr $8516	                jsr xt_block_write
.9e80		a9 01		lda #$01	                lda #1
.9e82		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.9e84		91 1e		sta ($1e),y	                sta (up),y
.9e86						_done:
.9e86		60		rts		z_save_buffers: rts
.9e87						xt_scr:
.9e87		ca		dex		                dex
.9e88		ca		dex		                dex
.9e89		18		clc		                clc
.9e8a		a5 1e		lda $1e		                lda up
.9e8c		69 02		adc #$02	                adc #scr_offset ; Add offset
.9e8e		95 00		sta $00,x	                sta 0,x
.9e90		a5 1f		lda $1f		                lda up+1
.9e92		69 00		adc #$00	                adc #0          ; Adding carry
.9e94		95 01		sta $01,x	                sta 1,x
.9e96		60		rts		z_scr:          rts
.9e97						xt_search:
.9e97		20 7e d8	jsr $d87e	                jsr underflow_4
.9e9a		b5 00		lda $00,x	                lda 0,x
.9e9c		15 01		ora $01,x	                ora 1,x
.9e9e		d0 0b		bne $9eab	                bne _start_search
.9ea0		e8		inx		                inx             ; Remove u2
.9ea1		e8		inx		                inx
.9ea2		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.9ea4		95 00		sta $00,x	                sta 0,x
.9ea6		95 01		sta $01,x	                sta 1,x
.9ea8		4c 35 9f	jmp $9f35	                jmp z_search
.9eab						_start_search:
.9eab		20 56 a7	jsr $a756	                jsr xt_zero
.9eae						_search_loop:
.9eae		18		clc		                clc
.9eaf		b5 00		lda $00,x	                lda 0,x
.9eb1		75 02		adc $02,x	                adc 2,x
.9eb3		85 24		sta $24		                sta tmp1
.9eb5		b5 01		lda $01,x	                lda 1,x
.9eb7		75 03		adc $03,x	                adc 3,x
.9eb9		d5 07		cmp $07,x	                cmp 7,x
.9ebb		90 12		bcc $9ecf	                bcc _init_comparison ; Obviously less
.9ebd		d0 06		bne $9ec5	                bne _not_found
.9ebf		b5 06		lda $06,x	                lda 6,x
.9ec1		c5 24		cmp $24		                cmp tmp1
.9ec3		b0 0a		bcs $9ecf	                bcs _init_comparison
.9ec5						_not_found:
.9ec5		e8		inx		                inx             ; Remove offset
.9ec6		e8		inx		                inx
.9ec7		e8		inx		                inx             ; Remove u2
.9ec8		e8		inx		                inx
.9ec9		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.9ecb		74 01		stz $01,x	                stz 1,x
.9ecd		80 66		bra $9f35	                bra z_search
.9ecf						_init_comparison:
.9ecf		18		clc		                clc
.9ed0		b5 08		lda $08,x	                lda 8,x
.9ed2		75 00		adc $00,x	                adc 0,x
.9ed4		85 24		sta $24		                sta tmp1
.9ed6		b5 09		lda $09,x	                lda 9,x
.9ed8		75 01		adc $01,x	                adc 1,x
.9eda		85 25		sta $25		                sta tmp1+1
.9edc		b5 04		lda $04,x	                lda 4,x
.9ede		85 26		sta $26		                sta tmp2
.9ee0		b5 05		lda $05,x	                lda 5,x
.9ee2		85 27		sta $27		                sta tmp2+1
.9ee4		b5 02		lda $02,x	                lda 2,x
.9ee6		85 28		sta $28		                sta tmp3
.9ee8		b5 03		lda $03,x	                lda 3,x
.9eea		85 29		sta $29		                sta tmp3+1
.9eec						_comparison_loop:
.9eec		b2 24		lda ($24)	                lda (tmp1)
.9eee		d2 26		cmp ($26)	                cmp (tmp2)
.9ef0		f0 05		beq $9ef7	                beq _letters_match
.9ef2		20 01 98	jsr $9801	                jsr xt_one_plus
.9ef5		80 b7		bra $9eae	                bra _search_loop
.9ef7						_letters_match:
.9ef7		e6 24		inc $24		                inc tmp1
.9ef9		d0 02		bne $9efd	                bne +
.9efb		e6 25		inc $25		                inc tmp1+1
.9efd						+
.9efd		e6 26		inc $26		                inc tmp2
.9eff		d0 02		bne $9f03	                bne +
.9f01		e6 27		inc $27		                inc tmp2+1
.9f03						+
.9f03		a5 28		lda $28		                lda tmp3
.9f05		d0 02		bne $9f09	                bne +
.9f07		c6 29		dec $29		                dec tmp3+1
.9f09						+
.9f09		c6 28		dec $28		                dec tmp3
.9f0b		a5 28		lda $28		                lda tmp3
.9f0d		05 29		ora $29		                ora tmp3+1
.9f0f		d0 db		bne $9eec	                bne _comparison_loop ; Check the next letter
.9f11		18		clc		                clc
.9f12		b5 00		lda $00,x	                lda 0,x
.9f14		75 08		adc $08,x	                adc 8,x
.9f16		95 08		sta $08,x	                sta 8,x
.9f18		b5 01		lda $01,x	                lda 1,x
.9f1a		75 09		adc $09,x	                adc 9,x
.9f1c		95 09		sta $09,x	                sta 9,x
.9f1e		38		sec		                sec
.9f1f		b5 06		lda $06,x	                lda 6,x
.9f21		f5 00		sbc $00,x	                sbc 0,x
.9f23		95 06		sta $06,x	                sta 6,x
.9f25		b5 07		lda $07,x	                lda 7,x
.9f27		f5 01		sbc $01,x	                sbc 1,x
.9f29		95 07		sta $07,x	                sta 7,x
.9f2b		e8		inx		                inx             ; drop offset
.9f2c		e8		inx		                inx
.9f2d		e8		inx		                inx             ; drop u2
.9f2e		e8		inx		                inx
.9f2f		a9 ff		lda #$ff	                lda #$FF
.9f31		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.9f33		95 01		sta $01,x	                sta 1,x
.9f35		60		rts		z_search:       rts
.9f36						xt_semicolon:
.9f36		24 20		bit $20		                bit status
.9f38		70 11		bvs $9f4b	                bvs _colonword
.9f3a		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f3c		20 22 d7	jsr $d722	                jsr cmpl_a
.9f3f		ca		dex		                dex
.9f40		ca		dex		                dex
.9f41		a5 04		lda $04		                lda workword
.9f43		95 00		sta $00,x	                sta 0,x
.9f45		a5 05		lda $05		                lda workword+1
.9f47		95 01		sta $01,x	                sta 1,x
.9f49		80 45		bra $9f90	                bra _semicolon_done
.9f4b						_colonword:
.9f4b		a0 06		ldy #$06	                ldy #6
.9f4d		a5 00		lda $00		                lda cp
.9f4f		91 04		sta ($04),y	                sta (workword),y
.9f51		c8		iny		                iny
.9f52		a5 01		lda $01		                lda cp+1
.9f54		91 04		sta ($04),y	                sta (workword),y
.9f56		a9 60		lda #$60	                lda #$60                ; opcode for RTS
.9f58		20 22 d7	jsr $d722	                jsr cmpl_a
.9f5b		24 20		bit $20		                bit status
.9f5d		10 26		bpl $9f85	                bpl _new_word   ; Bit 7 is clear = new word
.9f5f		ca		dex		                dex
.9f60		ca		dex		                dex
.9f61		ca		dex		                dex
.9f62		ca		dex		                dex
.9f63		b2 04		lda ($04)	                lda (workword)
.9f65		95 00		sta $00,x	                sta 0,x
.9f67		74 01		stz $01,x	                stz 1,x
.9f69		a5 04		lda $04		                lda workword
.9f6b		18		clc		                clc
.9f6c		69 08		adc #$08	                adc #8
.9f6e		95 02		sta $02,x	                sta 2,x
.9f70		a5 05		lda $05		                lda workword+1
.9f72		69 00		adc #$00	                adc #0                  ; only want carry
.9f74		95 03		sta $03,x	                sta 3,x
.9f76		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9f78		20 ab d8	jsr $d8ab	                jsr print_string_no_lf
.9f7b		20 a7 a4	jsr $a4a7	                jsr xt_type
.9f7e		20 cc a0	jsr $a0cc	                jsr xt_space
.9f81		a9 80		lda #$80	                lda #%10000000
.9f83		14 20		trb $20		                trb status
.9f85						_new_word:
.9f85		a5 04		lda $04		                lda workword
.9f87		85 02		sta $02		                sta dp
.9f89		a5 05		lda $05		                lda workword+1
.9f8b		85 03		sta $03		                sta dp+1
.9f8d		20 c4 d7	jsr $d7c4	                jsr dp_to_current       ; Save the updated DP to the
.9f90						_semicolon_done:
.9f90		64 16		stz $16		                stz state
.9f92		64 17		stz $17		                stz state+1
.9f94		60		rts		z_semicolon:    rts
.9f95						xt_sign:
.9f95		20 6f d8	jsr $d86f	                jsr underflow_1
.9f98		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.9f9a		30 04		bmi $9fa0	                bmi _minus
.9f9c		e8		inx		                inx
.9f9d		e8		inx		                inx
.9f9e		80 09		bra $9fa9	                bra _done
.9fa0						_minus:
.9fa0		a9 2d		lda #$2d	                lda #$2D        ; ASCII for "-"
.9fa2		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9fa4		74 01		stz $01,x	                stz 1,x         ; paranoid
.9fa6		20 bc 91	jsr $91bc	                jsr xt_hold
.9fa9						_done:
.9fa9		60		rts		z_sign:         rts
.9faa						xt_slash:
.9faa		a9 00		lda #$00	                lda #0
.9fac		48		pha		                pha
.9fad		80 03		bra $9fb2	                bra slashmod_common
.9faf						xt_slash_mod:
.9faf		a9 ff		lda #$ff	                lda #$FF
.9fb1		48		pha		                pha             ; falls through to _common
.9fb2						slashmod_common:
.9fb2		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R
.9fb5		20 5a 9e	jsr $9e5a	                jsr xt_s_to_d           ; S>D
.9fb8		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R>
.9fbb		20 83 a0	jsr $a083	                jsr xt_sm_slash_rem     ; SM/REM
.9fbe		68		pla		                pla
.9fbf		d0 05		bne $9fc6	                bne _done
.9fc1		20 5c a1	jsr $a15c	                jsr xt_swap
.9fc4		e8		inx		                inx             ; DROP
.9fc5		e8		inx		                inx
.9fc6						_done:
.9fc6						z_slash_mod:
.9fc6		60		rts		z_slash:        rts
.9fc7						xt_slash_string:
.9fc7		20 79 d8	jsr $d879	                jsr underflow_3
.9fca		18		clc		                clc             ; 3OS+TOS
.9fcb		b5 00		lda $00,x	                lda 0,x
.9fcd		75 04		adc $04,x	                adc 4,x
.9fcf		95 04		sta $04,x	                sta 4,x
.9fd1		b5 01		lda $01,x	                lda 1,x
.9fd3		75 05		adc $05,x	                adc 5,x
.9fd5		95 05		sta $05,x	                sta 5,x
.9fd7		38		sec		                sec             ; NOS-TOS
.9fd8		b5 02		lda $02,x	                lda 2,x
.9fda		f5 00		sbc $00,x	                sbc 0,x
.9fdc		95 02		sta $02,x	                sta 2,x
.9fde		b5 03		lda $03,x	                lda 3,x
.9fe0		f5 01		sbc $01,x	                sbc 1,x
.9fe2		95 03		sta $03,x	                sta 3,x
.9fe4		e8		inx		                inx
.9fe5		e8		inx		                inx
.9fe6		60		rts		z_slash_string: rts
.9fe7						xt_sliteral:
.9fe7		20 74 d8	jsr $d874	                jsr underflow_2
.9fea		a9 4c		lda #$4c	                lda #$4C
.9fec		20 22 d7	jsr $d722	                jsr cmpl_a
.9fef		20 22 d7	jsr $d722	                jsr cmpl_a
.9ff2		20 22 d7	jsr $d722	                jsr cmpl_a
.9ff5		8a		txa		                txa
.9ff6		38		sec		                sec
.9ff7		e9 06		sbc #$06	                sbc #6
.9ff9		aa		tax		                tax
.9ffa		b5 08		lda $08,x	                lda 8,x
.9ffc		95 04		sta $04,x	                sta 4,x
.9ffe		b5 09		lda $09,x	                lda 9,x
.a000		95 05		sta $05,x	                sta 5,x
.a002		b5 06		lda $06,x	                lda 6,x
.a004		95 00		sta $00,x	                sta 0,x
.a006		b5 07		lda $07,x	                lda 7,x
.a008		95 01		sta $01,x	                sta 1,x
.a00a		a5 00		lda $00		                lda cp
.a00c		95 08		sta $08,x	                sta 8,x
.a00e		95 02		sta $02,x	                sta 2,x
.a010		a5 01		lda $01		                lda cp+1
.a012		95 09		sta $09,x	                sta 9,x
.a014		95 03		sta $03,x	                sta 3,x
.a016		20 a6 95	jsr $95a6	                jsr xt_move
.a019		18		clc		                clc
.a01a		a5 00		lda $00		                lda cp
.a01c		75 00		adc $00,x	                adc 0,x
.a01e		85 00		sta $00		                sta cp
.a020		a5 01		lda $01		                lda cp+1
.a022		75 01		adc $01,x	                adc 1,x
.a024		85 01		sta $01		                sta cp+1
.a026		b5 02		lda $02,x	                lda 2,x
.a028		38		sec		                sec
.a029		e9 02		sbc #$02	                sbc #2
.a02b		85 24		sta $24		                sta tmp1
.a02d		b5 03		lda $03,x	                lda 3,x
.a02f		e9 00		sbc #$00	                sbc #0          ; Propagate borrow
.a031		85 25		sta $25		                sta tmp1+1
.a033		a5 00		lda $00		                lda cp
.a035		92 24		sta ($24)	                sta (tmp1)
.a037		a0 01		ldy #$01	                ldy #1
.a039		a5 01		lda $01		                lda cp+1
.a03b		91 24		sta ($24),y	                sta (tmp1),y
.a03d						sliteral_const_str:
.a03d		a0 a0		ldy #$a0	                ldy #>sliteral_runtime
.a03f		a9 57		lda #$57	                lda #<sliteral_runtime
.a041		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.a044		b4 03		ldy $03,x	                ldy 3,x                ; address MSB
.a046		b5 02		lda $02,x	                lda 2,x                ; address LSB
.a048		20 1e d7	jsr $d71e	                jsr cmpl_word
.a04b		b4 01		ldy $01,x	                ldy 1,x                ; length MSB
.a04d		b5 00		lda $00,x	                lda 0,x                ; length LSB
.a04f		20 1e d7	jsr $d71e	                jsr cmpl_word
.a052		e8		inx		                inx
.a053		e8		inx		                inx
.a054		e8		inx		                inx
.a055		e8		inx		                inx
.a056		60		rts		z_sliteral:     rts
.a057						sliteral_runtime:
.a057		ca		dex		                dex
.a058		ca		dex		                dex
.a059		ca		dex		                dex
.a05a		ca		dex		                dex
.a05b		68		pla		                pla
.a05c		85 24		sta $24		                sta tmp1        ; LSB of address
.a05e		68		pla		                pla
.a05f		85 25		sta $25		                sta tmp1+1      ; MSB of address
.a061		a0 01		ldy #$01	                ldy #1          ; adjust for JSR/RTS mechanics on 65c02
.a063		b1 24		lda ($24),y	                lda (tmp1),y
.a065		95 02		sta $02,x	                sta 2,x         ; LSB of address
.a067		c8		iny		                iny
.a068		b1 24		lda ($24),y	                lda (tmp1),y
.a06a		95 03		sta $03,x	                sta 3,x         ; MSB of address
.a06c		c8		iny		                iny
.a06d		b1 24		lda ($24),y	                lda (tmp1),y
.a06f		95 00		sta $00,x	                sta 0,x         ; LSB of length
.a071		c8		iny		                iny
.a072		b1 24		lda ($24),y	                lda (tmp1),y
.a074		95 01		sta $01,x	                sta 1,x         ; MSB of length
.a076		18		clc		                clc
.a077		a5 24		lda $24		                lda tmp1
.a079		69 04		adc #$04	                adc #4
.a07b		a8		tay		                tay             ; LSB
.a07c		a5 25		lda $25		                lda tmp1+1
.a07e		69 00		adc #$00	                adc #0          ; we only need carry
.a080		48		pha		                pha             ; MSB
.a081		5a		phy		                phy
.a082		60		rts		                rts
.a083						xt_sm_slash_rem:
.a083		20 79 d8	jsr $d879	                jsr underflow_3 ; contains double number
.a086		b5 03		lda $03,x	                lda 3,x
.a088		48		pha		                pha
.a089		b5 01		lda $01,x	                lda 1,x
.a08b		55 03		eor $03,x	                eor 3,x
.a08d		48		pha		                pha
.a08e		20 cd 80	jsr $80cd	                jsr xt_abs
.a091		e8		inx		                inx             ; pretend we pushed n1 to R
.a092		e8		inx		                inx
.a093		20 4d 8a	jsr $8a4d	                jsr xt_dabs
.a096		ca		dex		                dex
.a097		ca		dex		                dex
.a098		20 5e a5	jsr $a55e	                jsr xt_um_slash_mod     ; UM/MOD
.a09b		68		pla		                pla
.a09c		10 03		bpl $a0a1	                bpl +
.a09e		20 07 96	jsr $9607	                jsr xt_negate
.a0a1						+
.a0a1		68		pla		                pla
.a0a2		10 07		bpl $a0ab	                bpl _done
.a0a4		e8		inx		                inx             ; pretend we pushed quotient to R
.a0a5		e8		inx		                inx
.a0a6		20 07 96	jsr $9607	                jsr xt_negate
.a0a9		ca		dex		                dex
.a0aa		ca		dex		                dex
.a0ab						_done:
.a0ab		60		rts		z_sm_slash_rem: rts
.a0ac						xt_source:
.a0ac		ca		dex		                dex
.a0ad		ca		dex		                dex
.a0ae		a5 08		lda $08		                lda cib
.a0b0		95 00		sta $00,x	                sta 0,x
.a0b2		a5 09		lda $09		                lda cib+1
.a0b4		95 01		sta $01,x	                sta 1,x
.a0b6		ca		dex		                dex
.a0b7		ca		dex		                dex
.a0b8		a5 0a		lda $0a		                lda ciblen
.a0ba		95 00		sta $00,x	                sta 0,x
.a0bc		a5 0b		lda $0b		                lda ciblen+1
.a0be		95 01		sta $01,x	                sta 1,x
.a0c0		60		rts		z_source:       rts
.a0c1						xt_source_id:
.a0c1		ca		dex		                dex
.a0c2		ca		dex		                dex
.a0c3		a5 06		lda $06		                lda insrc
.a0c5		95 00		sta $00,x	                sta 0,x
.a0c7		a5 07		lda $07		                lda insrc+1
.a0c9		95 01		sta $01,x	                sta 1,x
.a0cb		60		rts		z_source_id:    rts
.a0cc						xt_space:
.a0cc		a9 20		lda #$20	                lda #AscSP
.a0ce		20 db 8d	jsr $8ddb	                jsr emit_a
.a0d1		60		rts		z_space:        rts
.a0d2						xt_spaces:
.a0d2		20 6f d8	jsr $d86f	                jsr underflow_1
.a0d5		20 56 a7	jsr $a756	                jsr xt_zero
.a0d8		20 fc 94	jsr $94fc	                jsr xt_max
.a0db		b5 00		lda $00,x	                lda 0,x
.a0dd		15 01		ora $01,x	                ora 1,x
.a0df		f0 2a		beq $a10b	                beq _done
.a0e1		b4 01		ldy $01,x	                ldy 1,x
.a0e3		d0 0c		bne $a0f1	                bne _lots_of_spaces
.a0e5		b4 00		ldy $00,x	                ldy 0,x
.a0e7						_quick_loop:
.a0e7		a9 20		lda #$20	                lda #AscSP
.a0e9		20 db 8d	jsr $8ddb	                jsr emit_a
.a0ec		88		dey		                dey
.a0ed		f0 1c		beq $a10b	                beq _done
.a0ef		80 f6		bra $a0e7	                bra _quick_loop
.a0f1						_lots_of_spaces:
.a0f1		b4 00		ldy $00,x	                ldy 0,x
.a0f3						_first_slow_loop:
.a0f3		f0 08		beq $a0fd	                beq _slow_outer_loop
.a0f5		a9 20		lda #$20	                lda #AscSP
.a0f7		20 db 8d	jsr $8ddb	                jsr emit_a
.a0fa		88		dey		                dey
.a0fb		80 f6		bra $a0f3	                bra _first_slow_loop
.a0fd						_slow_outer_loop:
.a0fd		a0 00		ldy #$00	                ldy #00
.a0ff						_slow_inner_loop:
.a0ff		a9 20		lda #$20	                lda #AscSP
.a101		20 db 8d	jsr $8ddb	                jsr emit_a
.a104		88		dey		                dey
.a105		d0 f8		bne $a0ff	                bne _slow_inner_loop
.a107		d6 01		dec $01,x	                dec 1,x
.a109		d0 f2		bne $a0fd	                bne _slow_outer_loop
.a10b						_done:
.a10b		e8		inx		                inx             ; drop
.a10c		e8		inx		                inx
.a10d		60		rts		z_spaces:       rts
.a10e						xt_star:
.a10e		20 74 d8	jsr $d874	                jsr underflow_2
.a111		20 a0 a5	jsr $a5a0	                jsr xt_um_star
.a114		e8		inx		                inx
.a115		e8		inx		                inx
.a116		60		rts		z_star:         rts
.a117						xt_star_slash:
.a117		20 20 a1	jsr $a120	                jsr xt_star_slash_mod
.a11a		20 5c a1	jsr $a15c	                jsr xt_swap
.a11d		e8		inx		                inx
.a11e		e8		inx		                inx
.a11f						z_star_slash:
.a11f		60		rts		                rts
.a120						xt_star_slash_mod:
.a120		20 79 d8	jsr $d879	                jsr underflow_3
.a123		20 14 a3	jsr $a314	                jsr xt_to_r
.a126		20 72 94	jsr $9472	                jsr xt_m_star
.a129		20 76 9a	jsr $9a76	                jsr xt_r_from
.a12c		20 83 a0	jsr $a083	                jsr xt_sm_slash_rem
.a12f						z_star_slash_mod:
.a12f		60		rts		                rts
.a130						xt_state:
.a130		ca		dex		                dex
.a131		ca		dex		                dex
.a132		a9 16		lda #$16	                lda #<state
.a134		95 00		sta $00,x	                sta 0,x
.a136		a9 00		lda #$00	                lda #>state
.a138		95 01		sta $01,x	                sta 1,x
.a13a		60		rts		z_state:        rts
.a13b						xt_store:
.a13b		20 74 d8	jsr $d874	                jsr underflow_2
.a13e		b5 02		lda $02,x	                lda 2,x         ; LSB
.a140		81 00		sta ($00,x)	                sta (0,x)
.a142		f6 00		inc $00,x	                inc 0,x
.a144		d0 02		bne $a148	                bne +
.a146		f6 01		inc $01,x	                inc 1,x
.a148						+
.a148		b5 03		lda $03,x	                lda 3,x         ; MSB
.a14a		81 00		sta ($00,x)	                sta (0,x)
.a14c		e8		inx		                inx             ; 2DROP
.a14d		e8		inx		                inx
.a14e		e8		inx		                inx
.a14f		e8		inx		                inx
.a150		60		rts		z_store:        rts
.a151						xt_strip_underflow:
.a151		ca		dex		                dex
.a152		ca		dex		                dex
.a153		a9 1c		lda #$1c	                lda #<uf_strip
.a155		95 00		sta $00,x	                sta 0,x
.a157		a9 00		lda #$00	                lda #>uf_strip
.a159		95 01		sta $01,x	                sta 1,x
.a15b						z_strip_underflow:
.a15b		60		rts		                rts
.a15c						xt_swap:
.a15c		20 74 d8	jsr $d874	                jsr underflow_2
.a15f		b5 00		lda $00,x	                lda 0,x         ; LSB
.a161		b4 02		ldy $02,x	                ldy 2,x
.a163		95 02		sta $02,x	                sta 2,x
.a165		94 00		sty $00,x	                sty 0,x
.a167		b5 01		lda $01,x	                lda 1,x         ; MSB
.a169		b4 03		ldy $03,x	                ldy 3,x
.a16b		95 03		sta $03,x	                sta 3,x
.a16d		94 01		sty $01,x	                sty 1,x
.a16f		60		rts		z_swap:         rts
.a170						xt_thru:
.a170		20 74 d8	jsr $d874	                jsr underflow_2
.a173		b5 01		lda $01,x	                lda 1,x
.a175		48		pha		                pha
.a176		b5 00		lda $00,x	                lda 0,x
.a178		48		pha		                pha
.a179		e8		inx		                inx
.a17a		e8		inx		                inx
.a17b						_thru_loop:
.a17b		b5 01		lda $01,x	                lda 1,x
.a17d		48		pha		                pha
.a17e		b5 00		lda $00,x	                lda 0,x
.a180		48		pha		                pha
.a181		20 98 93	jsr $9398	                jsr xt_load
.a184		68		pla		                pla
.a185		85 24		sta $24		                sta tmp1
.a187		68		pla		                pla
.a188		85 25		sta $25		                sta tmp1+1
.a18a		68		pla		                pla
.a18b		85 26		sta $26		                sta tmp2
.a18d		68		pla		                pla
.a18e		85 27		sta $27		                sta tmp2+1
.a190		c5 25		cmp $25		                cmp tmp1+1
.a192		d0 08		bne $a19c	                bne _next_screen
.a194		a5 26		lda $26		                lda tmp2        ; Compare the LSB
.a196		c5 24		cmp $24		                cmp tmp1
.a198		d0 02		bne $a19c	                bne _next_screen
.a19a		80 18		bra $a1b4	                bra _done       ; We just did the last screen.
.a19c						_next_screen:
.a19c		a5 27		lda $27		                lda tmp2+1
.a19e		48		pha		                pha
.a19f		a5 26		lda $26		                lda tmp2
.a1a1		48		pha		                pha
.a1a2		e6 24		inc $24		                inc tmp1
.a1a4		d0 02		bne $a1a8	                bne +
.a1a6		e6 25		inc $25		                inc tmp1+1
.a1a8						+
.a1a8		ca		dex		                dex
.a1a9		ca		dex		                dex
.a1aa		a5 24		lda $24		                lda tmp1
.a1ac		95 00		sta $00,x	                sta 0,x
.a1ae		a5 25		lda $25		                lda tmp1+1
.a1b0		95 01		sta $01,x	                sta 1,x
.a1b2		80 c7		bra $a17b	                bra _thru_loop
.a1b4						_done:
.a1b4		60		rts		z_thru:         rts
.a1b5						xt_tick:
.a1b5		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( -- addr u )
.a1b8		b5 00		lda $00,x	                lda 0,x
.a1ba		15 01		ora $01,x	                ora 1,x
.a1bc		d0 05		bne $a1c3	                bne +
.a1be		a9 05		lda #$05	                lda #err_noname
.a1c0		4c 85 d8	jmp $d885	                jmp error
.a1c3						+
.a1c3		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( addr u -- nt )
.a1c6		b5 00		lda $00,x	                lda 0,x
.a1c8		15 01		ora $01,x	                ora 1,x
.a1ca		d0 05		bne $a1d1	                bne +
.a1cc		a9 08		lda #$08	                lda #err_syntax
.a1ce		4c 85 d8	jmp $d885	                jmp error
.a1d1						+
.a1d1		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt -- xt )
.a1d4		60		rts		z_tick:         rts
.a1d5						xt_to:
.a1d5		20 b5 a1	jsr $a1b5	                jsr xt_tick             ; ( [n] xt )
.a1d8		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a1da		18		clc		                clc
.a1db		69 03		adc #$03	                adc #3
.a1dd		85 24		sta $24		                sta tmp1
.a1df		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a1e1		69 00		adc #$00	                adc #0                  ; we just want the carry
.a1e3		85 25		sta $25		                sta tmp1+1
.a1e5		e8		inx		                inx
.a1e6		e8		inx		                inx                     ; ( [n] )
.a1e7		a5 16		lda $16		                lda state
.a1e9		05 17		ora $17		                ora state+1
.a1eb		f0 34		beq $a221	                beq _interpret
.a1ed		a0 00		ldy #$00	                ldy #$00                ; Code for LDA 0,X
.a1ef		a9 b5		lda #$b5	                lda #$B5
.a1f1		20 1e d7	jsr $d71e	                jsr cmpl_word
.a1f4		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a1f6		20 22 d7	jsr $d722	                jsr cmpl_a
.a1f9		a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a1fb		a5 24		lda $24		                lda tmp1
.a1fd		20 1e d7	jsr $d71e	                jsr cmpl_word
.a200		a0 01		ldy #$01	                ldy #$01                ; Code for LDA 1,X
.a202		a9 b5		lda #$b5	                lda #$B5
.a204		20 1e d7	jsr $d71e	                jsr cmpl_word
.a207		a9 8d		lda #$8d	                lda #$8D                ; Code for STA abs
.a209		20 22 d7	jsr $d722	                jsr cmpl_a
.a20c		e6 24		inc $24		                inc tmp1                ; Calculate MSB
.a20e		d0 02		bne $a212	                bne +
.a210		e6 25		inc $25		                inc tmp1+1
.a212						+
.a212		a4 25		ldy $25		                ldy tmp1+1              ; MSB goes in Y
.a214		a5 24		lda $24		                lda tmp1
.a216		20 1e d7	jsr $d71e	                jsr cmpl_word
.a219		a0 e8		ldy #$e8	                ldy #$E8                ; Code for INX
.a21b		98		tya		                tya
.a21c		20 1e d7	jsr $d71e	                jsr cmpl_word
.a21f		80 0f		bra $a230	                bra _done
.a221						_interpret:
.a221		20 6f d8	jsr $d86f	                jsr underflow_1
.a224		b5 00		lda $00,x	                lda 0,x
.a226		92 24		sta ($24)	                sta (tmp1)              ; LSB
.a228		a0 01		ldy #$01	                ldy #1
.a22a		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a22c		91 24		sta ($24),y	                sta (tmp1),y            ; fall through to common
.a22e		e8		inx		                inx                     ; DROP
.a22f		e8		inx		                inx
.a230						_done:
.a230		60		rts		z_to:           rts
.a231						xt_to_body:
.a231		20 6f d8	jsr $d86f	                jsr underflow_1
.a234		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( xt xt )
.a237		20 59 92	jsr $9259	                jsr xt_int_to_name      ; ( xt nt )
.a23a		f6 00		inc $00,x	                inc 0,x
.a23c		d0 02		bne $a240	                bne +
.a23e		f6 01		inc $01,x	                inc 1,x
.a240						+
.a240		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.a242		29 20		and #$20	                and #HC
.a244		f0 0d		beq $a253	                beq _no_cfa
.a246		18		clc		                clc
.a247		b5 02		lda $02,x	                lda 2,x         ; LSB
.a249		69 03		adc #$03	                adc #3
.a24b		95 02		sta $02,x	                sta 2,x
.a24d		b5 03		lda $03,x	                lda 3,x         ; MSB
.a24f		69 00		adc #$00	                adc #0          ; we conly care about the carry
.a251		95 03		sta $03,x	                sta 3,x         ; Fall through to _no_cfa
.a253						_no_cfa:
.a253		e8		inx		                inx             ; get rid of the nt
.a254		e8		inx		                inx
.a255						_done:
.a255		60		rts		z_to_body:      rts
.a256						xt_to_in:
.a256		ca		dex		                dex
.a257		ca		dex		                dex
.a258		a9 0c		lda #$0c	                lda #<toin
.a25a		95 00		sta $00,x	                sta 0,x
.a25c		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.a25e		95 01		sta $01,x	                sta 1,x
.a260		60		rts		z_to_in:        rts
.a261						xt_to_number:
.a261		20 7e d8	jsr $d87e	                jsr underflow_4
.a264		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.a266		85 36		sta $36		                sta scratch
.a268		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.a26a		85 37		sta $37		                sta scratch+1
.a26c		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.a26e		85 38		sta $38		                sta scratch+2
.a270		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.a272		85 39		sta $39		                sta scratch+3
.a274		ca		dex		                dex
.a275		ca		dex		                dex
.a276						_loop:
.a276		a1 04		lda ($04,x)	                lda (4,x)
.a278		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.a27a		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a27c		20 cc 8a	jsr $8acc	                jsr xt_digit_question   ; ( char -- n -1 | char 0 )
.a27f		b5 00		lda $00,x	                lda 0,x
.a281		d0 04		bne $a287	                bne _digit_ok
.a283		e8		inx		                inx
.a284		e8		inx		                inx
.a285		80 67		bra $a2ee	                bra _done       ; ( ud-lo ud-hi addr u char )
.a287						_digit_ok:
.a287		b5 02		lda $02,x	                lda 2,x
.a289		85 3a		sta $3a		                sta scratch+4
.a28b		b5 03		lda $03,x	                lda 3,x
.a28d		85 3b		sta $3b		                sta scratch+5
.a28f		a5 38		lda $38		                lda scratch+2
.a291		95 02		sta $02,x	                sta 2,x         ; NOS
.a293		a5 39		lda $39		                lda scratch+3
.a295		95 03		sta $03,x	                sta 3,x
.a297		a5 18		lda $18		                lda base
.a299		95 00		sta $00,x	                sta 0,x         ; TOS
.a29b		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.a29d		20 a0 a5	jsr $a5a0	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.a2a0		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.a2a2		85 3c		sta $3c		                sta scratch+6
.a2a4		b5 03		lda $03,x	                lda 3,x
.a2a6		85 3d		sta $3d		                sta scratch+7
.a2a8		a5 36		lda $36		                lda scratch
.a2aa		95 02		sta $02,x	                sta 2,x
.a2ac		a5 37		lda $37		                lda scratch+1
.a2ae		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.a2b0		a5 18		lda $18		                lda base
.a2b2		95 00		sta $00,x	                sta 0,x
.a2b4		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.a2b6		20 a0 a5	jsr $a5a0	                jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.a2b9		b5 00		lda $00,x	                lda 0,x
.a2bb		85 38		sta $38		                sta scratch+2
.a2bd		b5 01		lda $01,x	                lda 1,x
.a2bf		85 39		sta $39		                sta scratch+3
.a2c1		b5 02		lda $02,x	                lda 2,x
.a2c3		85 36		sta $36		                sta scratch
.a2c5		b5 03		lda $03,x	                lda 3,x
.a2c7		85 37		sta $37		                sta scratch+1
.a2c9		18		clc		                clc
.a2ca		a5 36		lda $36		                lda scratch     ; ud-lo LSB
.a2cc		65 3a		adc $3a		                adc scratch+4   ; n LSB
.a2ce		85 36		sta $36		                sta scratch     ; this is the new ud-lo
.a2d0		a5 37		lda $37		                lda scratch+1   ; ud-lo MSB
.a2d2		65 3b		adc $3b		                adc scratch+5   ; n MSB
.a2d4		85 37		sta $37		                sta scratch+1
.a2d6		a5 38		lda $38		                lda scratch+2   ; LSB
.a2d8		65 3c		adc $3c		                adc scratch+6
.a2da		85 38		sta $38		                sta scratch+2   ; this is the new ud-hi
.a2dc		a5 39		lda $39		                lda scratch+3   ; MSB
.a2de		65 3d		adc $3d		                adc scratch+7
.a2e0		85 39		sta $39		                sta scratch+3
.a2e2		e8		inx		                inx
.a2e3		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.a2e4		f6 04		inc $04,x	                inc 4,x
.a2e6		d0 02		bne $a2ea	                bne +
.a2e8		f6 05		inc $05,x	                inc 5,x
.a2ea						+
.a2ea		d6 02		dec $02,x	                dec 2,x
.a2ec		d0 88		bne $a276	                bne _loop
.a2ee						_done:
.a2ee		e8		inx		                inx
.a2ef		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.a2f0		a5 36		lda $36		                lda scratch     ; new ud-lo
.a2f2		95 06		sta $06,x	                sta 6,x
.a2f4		a5 37		lda $37		                lda scratch+1
.a2f6		95 07		sta $07,x	                sta 7,x
.a2f8		a5 38		lda $38		                lda scratch+2
.a2fa		95 04		sta $04,x	                sta 4,x
.a2fc		a5 39		lda $39		                lda scratch+3
.a2fe		95 05		sta $05,x	                sta 5,x
.a300		60		rts		z_to_number:    rts
.a301						xt_to_order:
.a301		20 14 a3	jsr $a314	                jsr xt_to_r
.a304		20 19 91	jsr $9119	                jsr xt_get_order
.a307		20 76 9a	jsr $9a76	                jsr xt_r_from
.a30a		20 5c a1	jsr $a15c	                jsr xt_swap
.a30d		20 01 98	jsr $9801	                jsr xt_one_plus
.a310		20 f8 9c	jsr $9cf8	                jsr xt_set_order
.a313		60		rts		z_to_order:     rts
.a314						xt_to_r:
.a314		68		pla		                pla             ; LSB
.a315		85 2c		sta $2c		                sta tmptos
.a317		7a		ply		                ply             ; MSB
.a318		20 6f d8	jsr $d86f	                jsr underflow_1
.a31b		b5 01		lda $01,x	                lda 1,x         ; MSB
.a31d		48		pha		                pha
.a31e		b5 00		lda $00,x	                lda 0,x         ; LSB
.a320		48		pha		                pha
.a321		e8		inx		                inx
.a322		e8		inx		                inx
.a323		5a		phy		                phy             ; MSB
.a324		a5 2c		lda $2c		                lda tmptos
.a326		48		pha		                pha             ; LSB
.a327		60		rts		z_to_r:         rts
.a328						xt_true:
.a328		ca		dex		                dex
.a329		ca		dex		                dex
.a32a		a9 ff		lda #$ff	                lda #$FF
.a32c		95 00		sta $00,x	                sta 0,x
.a32e		95 01		sta $01,x	                sta 1,x
.a330		60		rts		z_true:         rts
.a331						xt_tuck:
.a331		20 74 d8	jsr $d874	                jsr underflow_2
.a334		ca		dex		                dex
.a335		ca		dex		                dex
.a336		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.a338		b5 02		lda $02,x	                lda 2,x
.a33a		95 04		sta $04,x	                sta 4,x
.a33c		94 02		sty $02,x	                sty 2,x
.a33e		95 00		sta $00,x	                sta 0,x
.a340		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.a342		b5 03		lda $03,x	                lda 3,x
.a344		95 05		sta $05,x	                sta 5,x
.a346		94 03		sty $03,x	                sty 3,x         ; bba
.a348		95 01		sta $01,x	                sta 1,x         ; baa
.a34a		60		rts		z_tuck:         rts
.a34b						xt_assembler_wordlist:
.a34b						xt_two:
.a34b		ca		dex		                dex
.a34c		ca		dex		                dex
.a34d		a9 02		lda #$02	                lda #2
.a34f		95 00		sta $00,x	                sta 0,x
.a351		74 01		stz $01,x	                stz 1,x
.a353						z_assembler_wordlist:
.a353		60		rts		z_two:          rts
.a354						xt_two_drop:
.a354		20 74 d8	jsr $d874	                jsr underflow_2
.a357		e8		inx		                inx
.a358		e8		inx		                inx
.a359		e8		inx		                inx
.a35a		e8		inx		                inx
.a35b		60		rts		z_two_drop:     rts
.a35c						xt_two_dup:
.a35c		20 74 d8	jsr $d874	                jsr underflow_2
.a35f		ca		dex		                dex
.a360		ca		dex		                dex
.a361		ca		dex		                dex
.a362		ca		dex		                dex
.a363		b5 04		lda $04,x	                lda 4,x         ; TOS
.a365		95 00		sta $00,x	                sta 0,x
.a367		b5 05		lda $05,x	                lda 5,x
.a369		95 01		sta $01,x	                sta 1,x
.a36b		b5 06		lda $06,x	                lda 6,x         ; NOS
.a36d		95 02		sta $02,x	                sta 2,x
.a36f		b5 07		lda $07,x	                lda 7,x
.a371		95 03		sta $03,x	                sta 3,x
.a373		60		rts		z_two_dup:      rts
.a374						xt_two_fetch:
.a374		20 6f d8	jsr $d86f	                jsr underflow_1
.a377		b5 00		lda $00,x	                lda 0,x
.a379		85 24		sta $24		                sta tmp1
.a37b		b4 01		ldy $01,x	                ldy 1,x
.a37d		84 25		sty $25		                sty tmp1+1
.a37f		ca		dex		                dex             ; reuse one stack element
.a380		ca		dex		                dex
.a381		b2 24		lda ($24)	                lda (tmp1)      ; copy LSB
.a383		95 00		sta $00,x	                sta 0,x
.a385		a0 01		ldy #$01	                ldy #1          ; copy next
.a387		b1 24		lda ($24),y	                lda (tmp1),y
.a389		95 01		sta $01,x	                sta 1,x
.a38b		c8		iny		                iny             ; copy next
.a38c		b1 24		lda ($24),y	                lda (tmp1),y
.a38e		95 02		sta $02,x	                sta 2,x
.a390		c8		iny		                iny             ; copy next
.a391		b1 24		lda ($24),y	                lda (tmp1),y
.a393		95 03		sta $03,x	                sta 3,x
.a395		60		rts		z_two_fetch:    rts
.a396						xt_two_over:
.a396		20 7e d8	jsr $d87e	                jsr underflow_4
.a399		ca		dex		                dex
.a39a		ca		dex		                dex
.a39b		ca		dex		                dex
.a39c		ca		dex		                dex
.a39d		b5 08		lda $08,x	                lda 8,x
.a39f		95 00		sta $00,x	                sta 0,x
.a3a1		b5 09		lda $09,x	                lda 9,x
.a3a3		95 01		sta $01,x	                sta 1,x
.a3a5		b5 0a		lda $0a,x	                lda 10,x
.a3a7		95 02		sta $02,x	                sta 2,x
.a3a9		b5 0b		lda $0b,x	                lda 11,x
.a3ab		95 03		sta $03,x	                sta 3,x
.a3ad		60		rts		z_two_over:     rts
.a3ae						xt_two_r_fetch:
.a3ae		ca		dex		                dex
.a3af		ca		dex		                dex
.a3b0		ca		dex		                dex
.a3b1		ca		dex		                dex
.a3b2		8a		txa		                txa
.a3b3		ba		tsx		                tsx
.a3b4		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.a3b5		7a		ply		                ply
.a3b6		aa		tax		                tax
.a3b7		b9 03 01	lda $0103,y	                lda $0103,y     ; LSB of top entry
.a3ba		95 00		sta $00,x	                sta 0,x
.a3bc		b9 04 01	lda $0104,y	                lda $0104,y     ; MSB of top entry
.a3bf		95 01		sta $01,x	                sta 1,x
.a3c1		b9 05 01	lda $0105,y	                lda $0105,y     ; LSB of bottom entry
.a3c4		95 02		sta $02,x	                sta 2,x
.a3c6		b9 06 01	lda $0106,y	                lda $0106,y     ; MSB of top entry
.a3c9		95 03		sta $03,x	                sta 3,x
.a3cb		60		rts		z_two_r_fetch:  rts
.a3cc						xt_two_r_from:
.a3cc		68		pla		                pla                     ; LSB
.a3cd		85 24		sta $24		                sta tmp1
.a3cf		68		pla		                pla                     ; MSB
.a3d0		85 25		sta $25		                sta tmp1+1
.a3d2		ca		dex		                dex
.a3d3		ca		dex		                dex
.a3d4		ca		dex		                dex
.a3d5		ca		dex		                dex
.a3d6		68		pla		                pla                     ; LSB
.a3d7		95 00		sta $00,x	                sta 0,x
.a3d9		68		pla		                pla                     ; MSB
.a3da		95 01		sta $01,x	                sta 1,x
.a3dc		68		pla		                pla                     ; LSB
.a3dd		95 02		sta $02,x	                sta 2,x
.a3df		68		pla		                pla                     ; MSB
.a3e0		95 03		sta $03,x	                sta 3,x
.a3e2		a5 25		lda $25		                lda tmp1+1              ; MSB
.a3e4		48		pha		                pha
.a3e5		a5 24		lda $24		                lda tmp1                ; LSB
.a3e7		48		pha		                pha
.a3e8		60		rts		z_two_r_from:   rts
.a3e9						xt_two_slash:
.a3e9		20 6f d8	jsr $d86f	                jsr underflow_1
.a3ec		b5 01		lda $01,x	                lda 1,x
.a3ee		0a		asl a		                asl                     ; save the sign
.a3ef		76 01		ror $01,x	                ror 1,x
.a3f1		76 00		ror $00,x	                ror 0,x
.a3f3		60		rts		z_two_slash:    rts
.a3f4						xt_two_star:
.a3f4						xt_cells:
.a3f4		20 6f d8	jsr $d86f	                jsr underflow_1
.a3f7		16 00		asl $00,x	                asl 0,x
.a3f9		36 01		rol $01,x	                rol 1,x
.a3fb						z_cells:
.a3fb		60		rts		z_two_star:     rts
.a3fc						xt_two_store:
.a3fc		20 79 d8	jsr $d879	                jsr underflow_3
.a3ff		b5 00		lda $00,x	                lda 0,x
.a401		85 24		sta $24		                sta tmp1
.a403		b4 01		ldy $01,x	                ldy 1,x
.a405		84 25		sty $25		                sty tmp1+1
.a407		e8		inx		                inx
.a408		e8		inx		                inx
.a409		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.a40b		92 24		sta ($24)	                sta (tmp1)
.a40d		b5 01		lda $01,x	                lda 1,x         ; copy next
.a40f		a0 01		ldy #$01	                ldy #1
.a411		91 24		sta ($24),y	                sta (tmp1),y
.a413		b5 02		lda $02,x	                lda 2,x         ; copy next
.a415		c8		iny		                iny
.a416		91 24		sta ($24),y	                sta (tmp1),y
.a418		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.a41a		c8		iny		                iny
.a41b		91 24		sta ($24),y	                sta (tmp1),y
.a41d		e8		inx		                inx             ; 2DROP
.a41e		e8		inx		                inx
.a41f		e8		inx		                inx
.a420		e8		inx		                inx
.a421		60		rts		z_two_store:    rts
.a422						xt_two_swap:
.a422		20 7e d8	jsr $d87e	                jsr underflow_4
.a425		b5 00		lda $00,x	                lda 0,x
.a427		b4 04		ldy $04,x	                ldy 4,x
.a429		95 04		sta $04,x	                sta 4,x
.a42b		94 00		sty $00,x	                sty 0,x
.a42d		b5 01		lda $01,x	                lda 1,x
.a42f		b4 05		ldy $05,x	                ldy 5,x
.a431		95 05		sta $05,x	                sta 5,x
.a433		94 01		sty $01,x	                sty 1,x
.a435		b5 02		lda $02,x	                lda 2,x
.a437		b4 06		ldy $06,x	                ldy 6,x
.a439		95 06		sta $06,x	                sta 6,x
.a43b		94 02		sty $02,x	                sty 2,x
.a43d		b5 03		lda $03,x	                lda 3,x
.a43f		b4 07		ldy $07,x	                ldy 7,x
.a441		95 07		sta $07,x	                sta 7,x
.a443		94 03		sty $03,x	                sty 3,x
.a445		60		rts		z_two_swap:     rts
.a446						xt_two_to_r:
.a446		68		pla		                pla             ; LSB
.a447		85 24		sta $24		                sta tmp1
.a449		68		pla		                pla             ; MSB
.a44a		85 25		sta $25		                sta tmp1+1
.a44c		20 74 d8	jsr $d874	                jsr underflow_2
.a44f		b5 03		lda $03,x	                lda 3,x         ; MSB
.a451		48		pha		                pha
.a452		b5 02		lda $02,x	                lda 2,x         ; LSB
.a454		48		pha		                pha
.a455		b5 01		lda $01,x	                lda 1,x         ; MSB
.a457		48		pha		                pha
.a458		b5 00		lda $00,x	                lda 0,x         ; LSB
.a45a		48		pha		                pha
.a45b		e8		inx		                inx
.a45c		e8		inx		                inx
.a45d		e8		inx		                inx
.a45e		e8		inx		                inx
.a45f		a5 25		lda $25		                lda tmp1+1      ; MSB
.a461		48		pha		                pha
.a462		a5 24		lda $24		                lda tmp1        ; LSB
.a464		48		pha		                pha
.a465		60		rts		z_two_to_r:     rts
.a466						xt_two_constant:
.a466		20 74 d8	jsr $d874	                jsr underflow_2
.a469		20 30 89	jsr $8930	                jsr xt_create
.a46c		20 5c a1	jsr $a15c	                jsr xt_swap
.a46f		20 24 87	jsr $8724	                jsr xt_comma
.a472		20 24 87	jsr $8724	                jsr xt_comma
.a475		20 b7 8b	jsr $8bb7	                jsr does_runtime    ; does> turns into these two routines.
.a478		20 58 d7	jsr $d758	                jsr dodoes
.a47b		20 62 8d	jsr $8d62	                jsr xt_dup
.a47e		20 65 8f	jsr $8f65	                jsr xt_fetch
.a481		20 5c a1	jsr $a15c	                jsr xt_swap
.a484		20 d7 85	jsr $85d7	                jsr xt_cell_plus
.a487		20 65 8f	jsr $8f65	                jsr xt_fetch
.a48a		60		rts		z_two_constant: rts
.a48b						xt_two_literal:
.a48b		20 74 d8	jsr $d874	                jsr underflow_2 ; double number
.a48e		20 5c a1	jsr $a15c	                jsr xt_swap
.a491		20 6b 93	jsr $936b	                jsr xt_literal
.a494		20 6b 93	jsr $936b	                jsr xt_literal
.a497		60		rts		z_two_literal:  rts
.a498						xt_two_variable:
.a498		20 30 89	jsr $8930	                jsr xt_create
.a49b		ca		dex		                dex
.a49c		ca		dex		                dex
.a49d		a9 04		lda #$04	                lda #4
.a49f		95 00		sta $00,x	                sta 0,x
.a4a1		74 01		stz $01,x	                stz 1,x
.a4a3		20 3f 82	jsr $823f	                jsr xt_allot
.a4a6		60		rts		z_two_variable: rts
.a4a7						xt_type:
.a4a7		20 74 d8	jsr $d874	                jsr underflow_2
.a4aa		b5 02		lda $02,x	                lda 2,x
.a4ac		85 24		sta $24		                sta tmp1
.a4ae		b5 03		lda $03,x	                lda 3,x
.a4b0		85 25		sta $25		                sta tmp1+1
.a4b2						_loop:
.a4b2		b5 00		lda $00,x	                lda 0,x
.a4b4		15 01		ora $01,x	                ora 1,x
.a4b6		f0 15		beq $a4cd	                beq _done
.a4b8		b2 24		lda ($24)	                lda (tmp1)
.a4ba		20 db 8d	jsr $8ddb	                jsr emit_a      ; avoids stack foolery
.a4bd		e6 24		inc $24		                inc tmp1
.a4bf		d0 02		bne $a4c3	                bne +
.a4c1		e6 25		inc $25		                inc tmp1+1
.a4c3						+
.a4c3		b5 00		lda $00,x	                lda 0,x
.a4c5		d0 02		bne $a4c9	                bne +
.a4c7		d6 01		dec $01,x	                dec 1,x
.a4c9						+
.a4c9		d6 00		dec $00,x	                dec 0,x
.a4cb		80 e5		bra $a4b2	                bra _loop
.a4cd						_done:
.a4cd		e8		inx		                inx
.a4ce		e8		inx		                inx
.a4cf		e8		inx		                inx
.a4d0		e8		inx		                inx
.a4d1		60		rts		z_type:         rts
.a4d2						xt_u_dot:
.a4d2		20 6f d8	jsr $d86f	                jsr underflow_1
.a4d5		20 dc d8	jsr $d8dc	                jsr print_u
.a4d8		a9 20		lda #$20	                lda #AscSP
.a4da		20 db 8d	jsr $8ddb	                jsr emit_a
.a4dd		60		rts		z_u_dot:        rts
.a4de						xt_u_dot_r:
.a4de		20 74 d8	jsr $d874	                jsr underflow_2
.a4e1		20 14 a3	jsr $a314	                jsr xt_to_r
.a4e4		20 56 a7	jsr $a756	                jsr xt_zero
.a4e7		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a4ea		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.a4ed		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.a4f0		20 76 9a	jsr $9a76	                jsr xt_r_from
.a4f3		20 77 98	jsr $9877	                jsr xt_over
.a4f6		20 34 95	jsr $9534	                jsr xt_minus
.a4f9		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.a4fc		20 a7 a4	jsr $a4a7	                jsr xt_type
.a4ff		60		rts		z_u_dot_r:      rts
.a500						xt_u_greater_than:
.a500		20 74 d8	jsr $d874	                jsr underflow_2
.a503		b5 00		lda $00,x	                lda 0,x
.a505		d5 02		cmp $02,x	                cmp 2,x
.a507		b5 01		lda $01,x	                lda 1,x
.a509		f5 03		sbc $03,x	                sbc 3,x
.a50b		e8		inx		                inx
.a50c		e8		inx		                inx
.a50d		a9 00		lda #$00	                lda #0
.a50f		69 ff		adc #$ff	                adc #$ff
.a511		95 00		sta $00,x	                sta 0,x         ; store flag
.a513		95 01		sta $01,x	                sta 1,x
.a515		60		rts		z_u_greater_than:    rts
.a516						xt_u_less_than:
.a516		20 74 d8	jsr $d874	                jsr underflow_2
.a519		b5 02		lda $02,x	                lda 2,x
.a51b		d5 00		cmp $00,x	                cmp 0,x
.a51d		b5 03		lda $03,x	                lda 3,x
.a51f		f5 01		sbc $01,x	                sbc 1,x
.a521		e8		inx		                inx
.a522		e8		inx		                inx
.a523		a9 00		lda #$00	                lda #0
.a525		69 ff		adc #$ff	                adc #$ff
.a527		95 00		sta $00,x	                sta 0,x         ; store flag
.a529		95 01		sta $01,x	                sta 1,x
.a52b		60		rts		z_u_less_than:    rts
.a52c						xt_ud_dot:
.a52c		20 74 d8	jsr $d874	                jsr underflow_2 ; double number
.a52f		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a532		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.a535		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.a538		20 a7 a4	jsr $a4a7	                jsr xt_type
.a53b		20 cc a0	jsr $a0cc	                jsr xt_space
.a53e		60		rts		z_ud_dot:        rts
.a53f						xt_ud_dot_r:
.a53f		20 79 d8	jsr $d879	                jsr underflow_3
.a542		20 14 a3	jsr $a314	                jsr xt_to_r
.a545		20 3b 93	jsr $933b	                jsr xt_less_number_sign
.a548		20 c2 97	jsr $97c2	                jsr xt_number_sign_s
.a54b		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater
.a54e		20 76 9a	jsr $9a76	                jsr xt_r_from
.a551		20 77 98	jsr $9877	                jsr xt_over
.a554		20 34 95	jsr $9534	                jsr xt_minus
.a557		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.a55a		20 a7 a4	jsr $a4a7	                jsr xt_type
.a55d		60		rts		z_ud_dot_r:      rts
.a55e						xt_um_slash_mod:
.a55e		20 79 d8	jsr $d879	                jsr underflow_3
.a561		b5 00		lda $00,x	                lda 0,x
.a563		15 01		ora $01,x	                ora 1,x
.a565		d0 05		bne $a56c	                bne _not_zero
.a567		a9 04		lda #$04	                lda #err_divzero
.a569		4c 85 d8	jmp $d885	                jmp error
.a56c						_not_zero:
.a56c		a9 11		lda #$11	                lda #17
.a56e		85 2c		sta $2c		                sta tmptos
.a570						_loop:
.a570		36 04		rol $04,x	                rol 4,x
.a572		36 05		rol $05,x	                rol 5,x
.a574		c6 2c		dec $2c		                dec tmptos
.a576		f0 22		beq $a59a	                beq _done
.a578		36 02		rol $02,x	                rol 2,x
.a57a		36 03		rol $03,x	                rol 3,x
.a57c		64 24		stz $24		                stz tmp1        ; store the bit we got from hi cell (MSB)
.a57e		26 24		rol $24		                rol tmp1
.a580		38		sec		                sec
.a581		b5 02		lda $02,x	                lda 2,x
.a583		f5 00		sbc $00,x	                sbc 0,x
.a585		85 25		sta $25		                sta tmp1+1
.a587		b5 03		lda $03,x	                lda 3,x
.a589		f5 01		sbc $01,x	                sbc 1,x
.a58b		a8		tay		                tay
.a58c		a5 24		lda $24		                lda tmp1
.a58e		e9 00		sbc #$00	                sbc #0
.a590		90 de		bcc $a570	                bcc _loop
.a592		a5 25		lda $25		                lda tmp1+1
.a594		95 02		sta $02,x	                sta 2,x
.a596		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.a598		80 d6		bra $a570	                bra _loop
.a59a						_done:
.a59a		e8		inx		                inx
.a59b		e8		inx		                inx
.a59c		20 5c a1	jsr $a15c	                jsr xt_swap
.a59f		60		rts		z_um_slash_mod: rts
.a5a0						xt_um_star:
.a5a0		20 74 d8	jsr $d874	                jsr underflow_2
.a5a3		18		clc		                clc
.a5a4		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.a5a6		e9 00		sbc #$00	                sbc #0
.a5a8		85 26		sta $26		                sta tmp2
.a5aa		b5 01		lda $01,x	                lda 1,x
.a5ac		e9 00		sbc #$00	                sbc #0
.a5ae		90 31		bcc $a5e1	                bcc _zero       ; is TOS zero?
.a5b0		85 27		sta $27		                sta tmp2+1
.a5b2		a9 00		lda #$00	                lda #0
.a5b4		85 24		sta $24		                sta tmp1
.a5b6		86 28		stx $28		                stx tmp3        ; tested for exit from outer loop
.a5b8		ca		dex		                dex
.a5b9		ca		dex		                dex
.a5ba						_outer_loop:
.a5ba		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.a5bc		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.a5be						_inner_loop:
.a5be		90 0c		bcc $a5cc	                bcc _no_add
.a5c0		85 25		sta $25		                sta tmp1+1      ; save time, don't CLC
.a5c2		a5 24		lda $24		                lda tmp1
.a5c4		65 26		adc $26		                adc tmp2
.a5c6		85 24		sta $24		                sta tmp1
.a5c8		a5 25		lda $25		                lda tmp1+1
.a5ca		65 27		adc $27		                adc tmp2+1
.a5cc						_no_add:
.a5cc		6a		ror a		                ror
.a5cd		66 24		ror $24		                ror tmp1
.a5cf		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.a5d1		88		dey		                dey
.a5d2		d0 ea		bne $a5be	                bne _inner_loop ; go back for one more shift?
.a5d4		e8		inx		                inx
.a5d5		e4 28		cpx $28		                cpx tmp3
.a5d7		d0 e1		bne $a5ba	                bne _outer_loop ; go back for eight more shifts?
.a5d9		95 01		sta $01,x	                sta 1,x
.a5db		a5 24		lda $24		                lda tmp1
.a5dd		95 00		sta $00,x	                sta 0,x
.a5df		80 04		bra $a5e5	                bra _done
.a5e1						_zero:
.a5e1		74 02		stz $02,x	                stz 2,x
.a5e3		74 03		stz $03,x	                stz 3,x
.a5e5						_done:
.a5e5		60		rts		z_um_star:      rts
.a5e6						xt_unloop:
.a5e6		68		pla		                pla
.a5e7		68		pla		                pla
.a5e8		68		pla		                pla
.a5e9		68		pla		                pla
.a5ea		68		pla		                pla
.a5eb		68		pla		                pla
.a5ec		60		rts		z_unloop:       rts
.a5ed						xt_until:
.a5ed		a0 00		ldy #$00	                ldy #0
.a5ef						-
.a5ef		b9 f7 91	lda $91f7,y	                lda zero_test_runtime,y
.a5f2		c9 60		cmp #$60	                cmp #$60            ; skip RTS
.a5f4		f0 03		beq $a5f9	                beq +
.a5f6		20 22 d7	jsr $d722	                jsr cmpl_a
.a5f9						+
.a5f9		c8		iny		                iny
.a5fa		c0 0a		cpy #$0a	                cpy #(zero_test_footer_end - zero_test_runtime)
.a5fc		d0 f1		bne $a5ef	                bne -
.a5fe		20 24 87	jsr $8724	                jsr xt_comma
.a601		60		rts		z_until:        rts
.a602						xt_unused:
.a602		ca		dex		                dex
.a603		ca		dex		                dex
.a604		a9 00		lda #$00	                lda #<cp_end
.a606		38		sec		                sec
.a607		e5 00		sbc $00		                sbc cp
.a609		95 00		sta $00,x	                sta 0,x
.a60b		a9 7c		lda #$7c	                lda #>cp_end
.a60d		e5 01		sbc $01		                sbc cp+1
.a60f		95 01		sta $01,x	                sta 1,x
.a611		60		rts		z_unused:       rts
.a612						xt_update:
.a612		a0 2c		ldy #$2c	                ldy #buffstatus_offset
.a614		b1 1e		lda ($1e),y	                lda (up),y
.a616		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.a618		91 1e		sta ($1e),y	                sta (up),y
.a61a		60		rts		z_update:       rts
.a61b						xt_useraddr:
.a61b		ca		dex		                dex
.a61c		ca		dex		                dex
.a61d		a9 1e		lda #$1e	                lda #<up
.a61f		95 00		sta $00,x	                sta 0,x
.a621		a9 00		lda #$00	                lda #>up
.a623		95 01		sta $01,x	                sta 1,x
.a625		60		rts		z_useraddr:     rts
.a626						xt_variable:
.a626		20 30 89	jsr $8930	                jsr xt_create
.a629		a9 00		lda #$00	                lda #0
.a62b		92 00		sta ($00)	                sta (cp)
.a62d		e6 00		inc $00		                inc cp
.a62f		d0 02		bne $a633	                bne +
.a631		e6 01		inc $01		                inc cp+1
.a633						+
.a633		92 00		sta ($00)	                sta (cp)
.a635		e6 00		inc $00		                inc cp
.a637		d0 02		bne $a63b	                bne +
.a639		e6 01		inc $01		                inc cp+1
.a63b						+
.a63b		20 f8 88	jsr $88f8	                jsr adjust_z
.a63e		60		rts		z_variable:     rts
.a63f						xt_while:
.a63f		a0 92		ldy #$92	                ldy #>zero_branch_runtime
.a641		a9 01		lda #$01	                lda #<zero_branch_runtime
.a643		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.a646		20 57 91	jsr $9157	                jsr xt_here
.a649		20 28 a3	jsr $a328	                jsr xt_true
.a64c		20 24 87	jsr $8724	                jsr xt_comma
.a64f		20 5c a1	jsr $a15c	                jsr xt_swap
.a652		60		rts		z_while:        rts
.a653						xt_within:
.a653		20 79 d8	jsr $d879	                jsr underflow_3
.a656		20 77 98	jsr $9877	                jsr xt_over
.a659		20 34 95	jsr $9534	                jsr xt_minus
.a65c		20 14 a3	jsr $a314	                jsr xt_to_r
.a65f		20 34 95	jsr $9534	                jsr xt_minus
.a662		20 76 9a	jsr $9a76	                jsr xt_r_from
.a665		20 16 a5	jsr $a516	                jsr xt_u_less_than
.a668		60		rts		z_within:       rts
.a669						xt_word:
.a669		20 6f d8	jsr $d86f	                jsr underflow_1
.a66c		a4 0c		ldy $0c		                ldy toin                ; >IN
.a66e						_loop:
.a66e		c4 0a		cpy $0a		                cpy ciblen              ; quit if end of input
.a670		f0 09		beq $a67b	                beq _found_char
.a672		b1 08		lda ($08),y	                lda (cib),y
.a674		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.a676		d0 03		bne $a67b	                bne _found_char
.a678		c8		iny		                iny
.a679		80 f3		bra $a66e	                bra _loop
.a67b						_found_char:
.a67b		84 0c		sty $0c		                sty toin
.a67d		20 1e 99	jsr $991e	                jsr xt_parse            ; Returns ( addr u )
.a680		b5 00		lda $00,x	                lda 0,x
.a682		92 00		sta ($00)	                sta (cp)                ; Save length of string
.a684		48		pha		                pha                     ; Keep copy of length for later
.a685		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr u u )
.a688		a5 00		lda $00		                lda cp
.a68a		18		clc		                clc
.a68b		69 01		adc #$01	                adc #1
.a68d		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.a68f		a5 01		lda $01		                lda cp+1
.a691		69 00		adc #$00	                adc #0
.a693		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.a695		20 a6 95	jsr $95a6	                jsr xt_move
.a698		ca		dex		                dex
.a699		ca		dex		                dex
.a69a		a5 00		lda $00		                lda cp
.a69c		95 00		sta $00,x	                sta 0,x
.a69e		a5 01		lda $01		                lda cp+1
.a6a0		95 01		sta $01,x	                sta 1,x
.a6a2		68		pla		                pla                     ; length of string
.a6a3		18		clc		                clc
.a6a4		65 00		adc $00		                adc cp
.a6a6		85 00		sta $00		                sta cp
.a6a8		a5 01		lda $01		                lda cp+1
.a6aa		69 00		adc #$00	                adc #0                  ; we only need the carry
.a6ac		85 01		sta $01		                sta cp+1
.a6ae		60		rts		z_word:         rts
.a6af						xt_wordlist:
.a6af		a0 05		ldy #$05	                ldy #num_wordlists_offset
.a6b1		b1 1e		lda ($1e),y	                lda (up),y      ; This is a byte variable, so only
.a6b3		c9 0c		cmp #$0c	                cmp #max_wordlists
.a6b5		d0 05		bne $a6bc	                bne _ok
.a6b7		a9 0b		lda #$0b	                lda #err_wordlist
.a6b9		4c 85 d8	jmp $d885	                jmp error
.a6bc						_ok:
.a6bc		1a		inc a		                ina             ; Increment the wordlist#
.a6bd		91 1e		sta ($1e),y	                sta (up),y      ; Save it into byte variable #wordlists
.a6bf		ca		dex		                dex             ; and put it on the stack.
.a6c0		ca		dex		                dex
.a6c1		95 00		sta $00,x	                sta 0,x
.a6c3		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.a6c5		60		rts		z_wordlist:     rts
.a6c6						xt_words:
.a6c6		20 2a 89	jsr $892a	                jsr xt_cr
.a6c9		a9 00		lda #$00	                lda #0
.a6cb		48		pha		                pha
.a6cc		ca		dex		                dex                     ; Make room on the stack for
.a6cd		ca		dex		                dex                     ; a dictionary pointer.
.a6ce		64 28		stz $28		                stz tmp3                ; Start at the beginning of
.a6d0						_wordlist_loop:
.a6d0		a0 1e		ldy #$1e	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.a6d2		a5 28		lda $28		                lda tmp3
.a6d4		d1 1e		cmp ($1e),y	                cmp (up),y              ; See if we are done.
.a6d6		d0 02		bne $a6da	                bne _have_wordlist
.a6d8		80 45		bra $a71f	                bra _words_done
.a6da						_have_wordlist:
.a6da		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.a6db		69 1f		adc #$1f	                adc #search_order_offset
.a6dd		a8		tay		                tay
.a6de		b1 1e		lda ($1e),y	                lda (up),y              ; Get the index into array WORDLISTS
.a6e0		0a		asl a		                asl                     ; Turn offset into cells offset.
.a6e1		18		clc		                clc
.a6e2		69 06		adc #$06	                adc #wordlists_offset
.a6e4		a8		tay		                tay
.a6e5		b1 1e		lda ($1e),y	                lda (up),y              ; Save the DP for this wordlist
.a6e7		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.a6e9		c8		iny		                iny
.a6ea		b1 1e		lda ($1e),y	                lda (up),y
.a6ec		95 01		sta $01,x	                sta 1,x
.a6ee						_loop:
.a6ee		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( nt nt )
.a6f1		20 e2 95	jsr $95e2	                jsr xt_name_to_string   ; ( nt addr u )
.a6f4		68		pla		                pla
.a6f5		18		clc		                clc
.a6f6		75 00		adc $00,x	                adc 0,x
.a6f8		1a		inc a		                ina                     ; don't forget the space between words
.a6f9		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.a6fb		90 06		bcc $a703	                bcc +
.a6fd		20 2a 89	jsr $892a	                jsr xt_cr
.a700		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.a702		1a		inc a		                ina                     ; with length of this word.
.a703						+
.a703		48		pha		                pha
.a704		20 a7 a4	jsr $a4a7	                jsr xt_type             ; ( nt )
.a707		a9 20		lda #$20	                lda #AscSP
.a709		20 db 8d	jsr $8ddb	                jsr emit_a
.a70c		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+
.a70f		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+
.a712		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( nt+1 )
.a715		b5 00		lda $00,x	                lda 0,x
.a717		15 01		ora $01,x	                ora 1,x
.a719		d0 d3		bne $a6ee	                bne _loop
.a71b		e6 28		inc $28		                inc tmp3
.a71d		80 b1		bra $a6d0	                bra _wordlist_loop
.a71f						_words_done:
.a71f		68		pla		                pla                     ; dump counter
.a720		e8		inx		                inx
.a721		e8		inx		                inx
.a722		60		rts		z_words:        rts
.a723						xt_wordsize:
.a723		20 6f d8	jsr $d86f	                jsr underflow_1
.a726		b5 00		lda $00,x	                lda 0,x
.a728		85 24		sta $24		                sta tmp1
.a72a		b5 01		lda $01,x	                lda 1,x
.a72c		85 25		sta $25		                sta tmp1+1
.a72e		a0 06		ldy #$06	                ldy #6
.a730		b1 24		lda ($24),y	                lda (tmp1),y    ; LSB of z
.a732		88		dey		                dey
.a733		88		dey		                dey
.a734		38		sec		                sec
.a735		f1 24		sbc ($24),y	                sbc (tmp1),y    ; LSB of xt
.a737		95 00		sta $00,x	                sta 0,x
.a739		a0 07		ldy #$07	                ldy #7
.a73b		b1 24		lda ($24),y	                lda (tmp1),y    ; MSB of z
.a73d		88		dey		                dey
.a73e		88		dey		                dey
.a73f		f1 24		sbc ($24),y	                sbc (tmp1),y    ; MSB of xt
.a741		95 01		sta $01,x	                sta 1,x
.a743		60		rts		z_wordsize:     rts
.a744						xt_xor:
.a744		20 74 d8	jsr $d874	                jsr underflow_2
.a747		b5 00		lda $00,x	                lda 0,x
.a749		55 02		eor $02,x	                eor 2,x
.a74b		95 02		sta $02,x	                sta 2,x
.a74d		b5 01		lda $01,x	                lda 1,x
.a74f		55 03		eor $03,x	                eor 3,x
.a751		95 03		sta $03,x	                sta 3,x
.a753		e8		inx		                inx
.a754		e8		inx		                inx
.a755		60		rts		z_xor:          rts
.a756						xt_case:
.a756						xt_forth_wordlist:
.a756						xt_zero:
.a756		ca		dex		                dex             ; push
.a757		ca		dex		                dex
.a758		74 00		stz $00,x	                stz 0,x
.a75a		74 01		stz $01,x	                stz 1,x
.a75c						z_case:
.a75c						z_forth_wordlist:
.a75c						z_zero:
.a75c		60		rts		                rts
.a75d						xt_zero_equal:
.a75d		20 6f d8	jsr $d86f	                jsr underflow_1
.a760		b5 00		lda $00,x	                lda 0,x
.a762		15 01		ora $01,x	                ora 1,x
.a764		f0 02		beq $a768	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.a766		a9 ff		lda #$ff	                lda #$ff        ; else set A inverse of the FALSE (0) we want
.a768						_zero:
.a768		49 ff		eor #$ff	                eor #$ff        ; now just invert
.a76a						_store:
.a76a		95 00		sta $00,x	                sta 0,x
.a76c		95 01		sta $01,x	                sta 1,x
.a76e		60		rts		z_zero_equal:   rts
.a76f						xt_zero_greater:
.a76f		20 6f d8	jsr $d86f	                jsr underflow_1
.a772		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.a774		b5 01		lda $01,x	                lda 1,x         ; MSB
.a776		30 05		bmi $a77d	                bmi _done       ; TOS is negative, keep FLASE
.a778		15 00		ora $00,x	                ora 0,x
.a77a		f0 01		beq $a77d	                beq _done       ; TOS is zero, keep FALSE
.a77c		88		dey		                dey             ; TOS is postive, make true
.a77d						_done:
.a77d		98		tya		                tya
.a77e		95 00		sta $00,x	                sta 0,x
.a780		95 01		sta $01,x	                sta 1,x
.a782		60		rts		z_zero_greater: rts
.a783						xt_zero_less:
.a783		20 6f d8	jsr $d86f	                jsr underflow_1
.a786		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.a788		b5 01		lda $01,x	                lda 1,x         ; MSB
.a78a		10 01		bpl $a78d	                bpl _done       ; TOS is positive, so keep FALSE
.a78c		88		dey		                dey             ; TOS is negative, make TRUE
.a78d						_done:
.a78d		98		tya		                tya
.a78e		95 00		sta $00,x	                sta 0,x
.a790		95 01		sta $01,x	                sta 1,x
.a792		60		rts		z_zero_less:    rts
.a793						xt_zero_unequal:
.a793		20 6f d8	jsr $d86f	                jsr underflow_1
.a796		b5 00		lda $00,x	                lda 0,x
.a798		15 01		ora $01,x	                ora 1,x
.a79a		f0 02		beq $a79e	                beq _zero
.a79c		a9 ff		lda #$ff	                lda #$ff
.a79e						_zero:
.a79e		95 00		sta $00,x	                sta 0,x
.a7a0		95 01		sta $01,x	                sta 1,x
.a7a2		60		rts		z_zero_unequal: rts
.a7a3						xt_editor_screen_helper:
.a7a3		20 62 8d	jsr $8d62	                jsr xt_dup
.a7a6		20 87 9e	jsr $9e87	                jsr xt_scr
.a7a9		20 3b a1	jsr $a13b	                jsr xt_store
.a7ac		20 6b 85	jsr $856b	                jsr xt_buffer
.a7af						z_editor_screen_helper:
.a7af		60		rts		                rts
.a7b0						xt_editor_enter_screen:
.a7b0		20 a3 a7	jsr $a7a3	                jsr xt_editor_screen_helper
.a7b3		20 e1 8c	jsr $8ce1	                jsr xt_drop
.a7b6		64 2e		stz $2e		                stz editor1
.a7b8						_prompt_loop:
.a7b8		ca		dex		                dex
.a7b9		ca		dex		                dex
.a7ba		a5 2e		lda $2e		                lda editor1
.a7bc		95 00		sta $00,x	                sta 0,x
.a7be		74 01		stz $01,x	                stz 1,x
.a7c0		20 85 a8	jsr $a885	                jsr xt_editor_o
.a7c3		e6 2e		inc $2e		                inc editor1
.a7c5		a9 10		lda #$10	                lda #16
.a7c7		c5 2e		cmp $2e		                cmp editor1
.a7c9		d0 ed		bne $a7b8	                bne _prompt_loop
.a7cb						z_editor_enter_screen:
.a7cb		60		rts		                rts
.a7cc						xt_editor_erase_screen:
.a7cc		20 a3 a7	jsr $a7a3	                jsr xt_editor_screen_helper
.a7cf		ca		dex		                dex
.a7d0		ca		dex		                dex
.a7d1		74 00		stz $00,x	                stz 0,x
.a7d3		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.a7d5		95 01		sta $01,x	                sta 1,x
.a7d7		20 cf 8e	jsr $8ecf	                jsr xt_blank
.a7da		20 12 a6	jsr $a612	                jsr xt_update
.a7dd						z_editor_erase_screen:
.a7dd		60		rts		                rts
.a7de						xt_editor_el:
.a7de		20 6c a8	jsr $a86c	                jsr xt_editor_line
.a7e1		ca		dex		                dex
.a7e2		ca		dex		                dex
.a7e3		a9 40		lda #$40	                lda #64
.a7e5		95 00		sta $00,x	                sta 0,x
.a7e7		74 01		stz $01,x	                stz 1,x
.a7e9		20 cf 8e	jsr $8ecf	                jsr xt_blank
.a7ec		20 12 a6	jsr $a612	                jsr xt_update
.a7ef		60		rts		z_editor_el:    rts
.a7f0						xt_editor_l:
.a7f0		ca		dex		                dex             ; Put SCR on the stack.
.a7f1		ca		dex		                dex
.a7f2		a0 02		ldy #$02	                ldy #scr_offset
.a7f4		b1 1e		lda ($1e),y	                lda (up),y
.a7f6		95 00		sta $00,x	                sta 0,x
.a7f8		c8		iny		                iny
.a7f9		b1 1e		lda ($1e),y	                lda (up),y
.a7fb		95 01		sta $01,x	                sta 1,x
.a7fd		20 77 83	jsr $8377	                jsr xt_block    ; Get the current screen.
.a800		20 2a 89	jsr $892a	                jsr xt_cr
.a803		80 08		bra $a80d	                bra _after_screen_msg
.a805						_screen_msg:
>a805		53 63 72 65 65 6e 20 23		                .text "Screen #"
.a80d						_after_screen_msg:
.a80d		20 57 a0	jsr $a057	                jsr sliteral_runtime
>a810		05 a8 08 00			                .word _screen_msg, _after_screen_msg-_screen_msg
.a814		20 a7 a4	jsr $a4a7	                jsr xt_type
.a817		20 87 9e	jsr $9e87	                jsr xt_scr
.a81a		20 65 8f	jsr $8f65	                jsr xt_fetch
.a81d		ca		dex		                dex
.a81e		ca		dex		                dex
.a81f		a9 04		lda #$04	                lda #4          ; four spaces
.a821		95 00		sta $00,x	                sta 0,x
.a823		74 01		stz $01,x	                stz 1,x
.a825		20 de a4	jsr $a4de	                jsr xt_u_dot_r
.a828		64 28		stz $28		                stz tmp3
.a82a						_line_loop:
.a82a		20 2a 89	jsr $892a	                jsr xt_cr
.a82d		ca		dex		                dex
.a82e		ca		dex		                dex
.a82f		ca		dex		                dex
.a830		ca		dex		                dex
.a831		74 03		stz $03,x	                stz 3,x
.a833		a5 28		lda $28		                lda tmp3
.a835		95 02		sta $02,x	                sta 2,x
.a837		74 01		stz $01,x	                stz 1,x
.a839		a9 02		lda #$02	                lda #2
.a83b		95 00		sta $00,x	                sta 0,x
.a83d		20 de a4	jsr $a4de	                jsr xt_u_dot_r
.a840		20 cc a0	jsr $a0cc	                jsr xt_space
.a843		20 62 8d	jsr $8d62	                jsr xt_dup
.a846		ca		dex		                dex
.a847		ca		dex		                dex
.a848		a9 40		lda #$40	                lda #64
.a84a		95 00		sta $00,x	                sta 0,x
.a84c		74 01		stz $01,x	                stz 1,x
.a84e		20 a7 a4	jsr $a4a7	                jsr xt_type
.a851		18		clc		                clc
.a852		a9 40		lda #$40	                lda #64
.a854		75 00		adc $00,x	                adc 0,x
.a856		95 00		sta $00,x	                sta 0,x
.a858		b5 01		lda $01,x	                lda 1,x
.a85a		69 00		adc #$00	                adc #0      ; Add carry
.a85c		95 01		sta $01,x	                sta 1,x
.a85e		e6 28		inc $28		                inc tmp3
.a860		a5 28		lda $28		                lda tmp3
.a862		c9 10		cmp #$10	                cmp #16
.a864		d0 c4		bne $a82a	                bne _line_loop
.a866		20 2a 89	jsr $892a	                jsr xt_cr
.a869		e8		inx		                inx
.a86a		e8		inx		                inx
.a86b		60		rts		z_editor_l:            rts
.a86c						xt_editor_line:
.a86c		20 6f d8	jsr $d86f	                jsr underflow_1
.a86f		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.a871						_shift_tos_left:
.a871		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.a873		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.a875		88		dey		                dey
.a876		d0 f9		bne $a871	                bne _shift_tos_left
.a878		20 87 9e	jsr $9e87	                jsr xt_scr
.a87b		20 65 8f	jsr $8f65	                jsr xt_fetch
.a87e		20 77 83	jsr $8377	                jsr xt_block
.a881		20 c7 99	jsr $99c7	                jsr xt_plus
.a884		60		rts		z_editor_line:  rts
.a885						xt_editor_o:
.a885		20 2a 89	jsr $892a	                jsr xt_cr
.a888		20 62 8d	jsr $8d62	                jsr xt_dup
.a88b		20 4b a3	jsr $a34b	                jsr xt_two
.a88e		20 de a4	jsr $a4de	                jsr xt_u_dot_r
.a891		20 cc a0	jsr $a0cc	                jsr xt_space
.a894		a9 2a		lda #$2a	                lda #42         ; ASCII for *
.a896		20 db 8d	jsr $8ddb	                jsr emit_a
.a899		20 cc a0	jsr $a0cc	                jsr xt_space
.a89c		20 6c a8	jsr $a86c	                jsr xt_editor_line
.a89f		20 62 8d	jsr $8d62	                jsr xt_dup      ; Save a copy of the line address for later.
.a8a2		ca		dex		                dex
.a8a3		ca		dex		                dex
.a8a4		a9 40		lda #$40	                lda #64         ; chars/line
.a8a6		95 00		sta $00,x	                sta 0,x
.a8a8		74 01		stz $01,x	                stz 1,x
.a8aa		20 e2 80	jsr $80e2	                jsr xt_accept
.a8ad		20 62 8d	jsr $8d62	                jsr xt_dup
.a8b0		20 52 96	jsr $9652	                jsr xt_not_rote ; -rot
.a8b3		20 c7 99	jsr $99c7	                jsr xt_plus
.a8b6		ca		dex		                dex
.a8b7		ca		dex		                dex
.a8b8		a9 40		lda #$40	                lda #64         ; chars/line
.a8ba		95 00		sta $00,x	                sta 0,x
.a8bc		74 01		stz $01,x	                stz 1,x
.a8be		20 34 9b	jsr $9b34	                jsr xt_rot
.a8c1		20 34 95	jsr $9534	                jsr xt_minus
.a8c4		20 cf 8e	jsr $8ecf	                jsr xt_blank
.a8c7		20 12 a6	jsr $a612	                jsr xt_update
.a8ca		60		rts		z_editor_o:     rts

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.a8cb						cold_zp_table:
>a8cb	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>a8cd	0002	83 bc				dp:         .word dictionary_start  ; Dictionary Pointer
>a8cf	0004	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>a8d1	0006	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>a8d3	0008	00 02				cib:        .word buffer0           ; address of current input buffer
>a8d5	000a	00 00				ciblen:     .word 0                 ; length of current input buffer
>a8d7	000c	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>a8d9	000e	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>a8db	0010	27 f0				output:     .word kernel_putc       ; vector for EMIT
>a8dd	0012	21 f0				input:      .word kernel_getc       ; vector for KEY
>a8df	0014	00 00				havekey:    .word 0                 ; vector for KEY?
>a8e1	0016	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>a8e3	0018	0a 00				base:       .word 10                ; number radix, default decimal
>a8e5	001a	14 00				nc_limit:   .word 20                ; byte limit for Native Compile size
>a8e7	001c	00 00				uf_strip:   .word 0                 ; flag to strip underflow detection code (0 off)
>a8e9	001e	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>a8eb	0020	00 00				status:     .word 0                 ; internal status used by : :NONAME ; ACCEPT
>a8ed	0022					tmpbranch:  .word ?         ; temporary storage for 0BRANCH, BRANCH only
>a8ef	0024					tmp1:       .word ?         ; temporary storage
>a8f1	0026					tmp2:       .word ?         ; temporary storage
>a8f3	0028					tmp3:       .word ?         ; temporary storage (especially for print)
>a8f5	002a					tmpdsp:     .word ?         ; temporary DSP (X) storage (two bytes)
>a8f7	002c					tmptos:     .word ?         ; temporary TOS storage
>a8f9	002e					editor1:    .word ?         ; temporary for editors
>a8fb	0030					editor2:    .word ?         ; temporary for editors
>a8fd	0032					editor3:    .word ?         ; temporary for editors
>a8ff	0034					tohold:     .word ?         ; pointer for formatted output
>a901	0036					scratch:    .word ?         ; 8 byte scratchpad (see UM/MOD)
.a8ed						cold_zp_table_end:
.a8ed						cold_user_table:
>a8ed	0000	00 00				blk_offset:             .word 0         ; BLK
>a8ef	0002	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
>a8f1	0004	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>a8f2	0005	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.a8f3	0006					wordlists_offset:
>a8f3	0006	83 bc				    .word dictionary_start              ; FORTH-WORDLIST
>a8f5	0008	cb ca				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>a8f7	000a	1b cb				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>a8f9	000c	8a ca				    .word root_dictionary_start         ; ROOT-WORDLIST
>a8fb	000e	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>a903	0016	00 00 00 00 00 00 00 00
>a90b	001e	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.a90c	001f					search_order_offset:
>a90c	001f	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>a914	0027	00
>a915	0028	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>a917	002a	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>a919	002c	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>a91b	002e	11 85				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>a91d	0030	11 85				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.a91f						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0a  ; line feed
=$0d						AscCR   = $0d  ; carriage return
=$1b						AscESC  = $1b  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7f  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0e  ; CTRL-n (used to recall next input history)
=1						CO = 1  ; Compile Only
=2						AN = 2  ; Always Native Compile
=4						IM = 4  ; Immediate Word
=8						NN = 8  ; Never Native Compile
=16						UF = 16 ; Includes Underflow Check (RESERVED)
=32						HC = 32 ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../assembler.asm

.a91f						assembler:
.a91f						xt_asm_adc_h:
.a91f		a9 69		lda #$69	                lda #$69
.a921		4c 7a ac	jmp $ac7a	                jmp asm_common
.a924						z_asm_adc_h:
.a924						xt_asm_adc_x:
.a924		a9 7d		lda #$7d	                lda #$7D
.a926		4c 7a ac	jmp $ac7a	                jmp asm_common
.a929						z_asm_adc_x:
.a929						xt_asm_adc_y:
.a929		a9 79		lda #$79	                lda #$79
.a92b		4c 7a ac	jmp $ac7a	                jmp asm_common
.a92e						z_asm_adc_y:
.a92e						xt_asm_adc_z:
.a92e		a9 65		lda #$65	                lda #$65
.a930		4c 7a ac	jmp $ac7a	                jmp asm_common
.a933						z_asm_adc_z:
.a933						xt_asm_adc_zi:
.a933		a9 72		lda #$72	                lda #$72
.a935		4c 7a ac	jmp $ac7a	                jmp asm_common
.a938						z_asm_adc_zi:
.a938						xt_asm_adc_ziy:
.a938		a9 71		lda #$71	                lda #$71
.a93a		4c 7a ac	jmp $ac7a	                jmp asm_common
.a93d						z_asm_adc_ziy:
.a93d						xt_asm_adc_zx:
.a93d		a9 75		lda #$75	                lda #$75
.a93f		4c 7a ac	jmp $ac7a	                jmp asm_common
.a942						z_asm_adc_zx:
.a942						xt_asm_adc_zxi:
.a942		a9 61		lda #$61	                lda #$61
.a944		4c 7a ac	jmp $ac7a	                jmp asm_common
.a947						z_asm_adc_zxi:
.a947						xt_asm_and:
.a947		a9 2d		lda #$2d	                lda #$2D
.a949		4c 7a ac	jmp $ac7a	                jmp asm_common
.a94c						z_asm_and:
.a94c						xt_asm_and_h:
.a94c		a9 29		lda #$29	                lda #$29
.a94e		4c 7a ac	jmp $ac7a	                jmp asm_common
.a951						z_asm_and_h:
.a951						xt_asm_and_x:
.a951		a9 3d		lda #$3d	                lda #$3D
.a953		4c 7a ac	jmp $ac7a	                jmp asm_common
.a956						z_asm_and_x:
.a956						xt_asm_and_y:
.a956		a9 39		lda #$39	                lda #$39
.a958		4c 7a ac	jmp $ac7a	                jmp asm_common
.a95b						z_asm_and_y:
.a95b						xt_asm_and_z:
.a95b		a9 25		lda #$25	                lda #$25
.a95d		4c 7a ac	jmp $ac7a	                jmp asm_common
.a960						z_asm_and_z:
.a960						xt_asm_and_zi:
.a960		a9 32		lda #$32	                lda #$32
.a962		4c 7a ac	jmp $ac7a	                jmp asm_common
.a965						z_asm_and_zi:
.a965						xt_asm_and_ziy:
.a965		a9 31		lda #$31	                lda #$31
.a967		4c 7a ac	jmp $ac7a	                jmp asm_common
.a96a						z_asm_and_ziy:
.a96a						xt_asm_and_zx:
.a96a		a9 35		lda #$35	                lda #$35
.a96c		4c 7a ac	jmp $ac7a	                jmp asm_common
.a96f						z_asm_and_zx:
.a96f						xt_asm_and_zxi:
.a96f		a9 21		lda #$21	                lda #$21
.a971		4c 7a ac	jmp $ac7a	                jmp asm_common
.a974						z_asm_and_zxi:
.a974						xt_asm_asl:
.a974		a9 0e		lda #$0e	                lda #$0E
.a976		4c 7a ac	jmp $ac7a	                jmp asm_common
.a979						z_asm_asl:
.a979						xt_asm_asl_a:
.a979		a9 0a		lda #$0a	                lda #$0A
.a97b		4c 7a ac	jmp $ac7a	                jmp asm_common
.a97e						z_asm_asl_a:
.a97e						xt_asm_asl_x:
.a97e		a9 1e		lda #$1e	                lda #$1E
.a980		4c 7a ac	jmp $ac7a	                jmp asm_common
.a983						z_asm_asl_x:
.a983						xt_asm_asl_z:
.a983		a9 06		lda #$06	                lda #$06
.a985		4c 7a ac	jmp $ac7a	                jmp asm_common
.a988						z_asm_asl_z:
.a988						xt_asm_asl_zx:
.a988		a9 16		lda #$16	                lda #$16
.a98a		4c 7a ac	jmp $ac7a	                jmp asm_common
.a98d						z_asm_asl_zx:
.a98d						xt_asm_bcc:
.a98d		a9 90		lda #$90	                lda #$90
.a98f		4c 7a ac	jmp $ac7a	                jmp asm_common
.a992						z_asm_bcc:
.a992						xt_asm_bcs:
.a992		a9 b0		lda #$b0	                lda #$B0
.a994		a0 02		ldy #$02	                ldy #2
.a996		4c 7a ac	jmp $ac7a	                jmp asm_common
.a999						z_asm_bcs:
.a999						xt_asm_beq:
.a999		a9 f0		lda #$f0	                lda #$F0
.a99b		4c 7a ac	jmp $ac7a	                jmp asm_common
.a99e						z_asm_beq:
.a99e						xt_asm_bit:
.a99e		a9 2c		lda #$2c	                lda #$2C
.a9a0		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9a3						z_asm_bit:
.a9a3						xt_asm_bit_h:
.a9a3		a9 89		lda #$89	                lda #$89
.a9a5		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9a8						z_asm_bit_h:
.a9a8						xt_asm_bit_x:
.a9a8		a9 3c		lda #$3c	                lda #$3C
.a9aa		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9ad						z_asm_bit_x:
.a9ad						xt_asm_bit_z:
.a9ad		a9 24		lda #$24	                lda #$24
.a9af		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9b2						z_asm_bit_z:
.a9b2						xt_asm_bit_zx:
.a9b2		a9 34		lda #$34	                lda #$34
.a9b4		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9b7						z_asm_bit_zx:
.a9b7						xt_asm_bmi:
.a9b7		a9 30		lda #$30	                lda #$30
.a9b9		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9bc						z_asm_bmi:
.a9bc						xt_asm_bne:
.a9bc		a9 d0		lda #$d0	                lda #$D0
.a9be		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9c1						z_asm_bne:
.a9c1						xt_asm_bpl:
.a9c1		a9 10		lda #$10	                lda #$10
.a9c3		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9c6						z_asm_bpl:
.a9c6						xt_asm_bra:
.a9c6		a9 80		lda #$80	                lda #$80
.a9c8		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9cb						z_asm_bra:
.a9cb						xt_asm_brk:
.a9cb		a9 00		lda #$00	                lda #$00
.a9cd		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9d0						z_asm_brk:
.a9d0						xt_asm_bvc:
.a9d0		a9 50		lda #$50	                lda #$50
.a9d2		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9d5						z_asm_bvc:
.a9d5						xt_asm_bvs:
.a9d5		a9 70		lda #$70	                lda #$70
.a9d7		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9da						z_asm_bvs:
.a9da						xt_asm_clc:
.a9da		a9 18		lda #$18	                lda #$18
.a9dc		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9df						z_asm_clc:
.a9df						xt_asm_cld:
.a9df		a9 d8		lda #$d8	                lda #$D8
.a9e1		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9e4						z_asm_cld:
.a9e4						xt_asm_cli:
.a9e4		a9 58		lda #$58	                lda #$58
.a9e6		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9e9						z_asm_cli:
.a9e9						xt_asm_clv:
.a9e9		a9 b8		lda #$b8	                lda #$B8
.a9eb		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9ee						z_asm_clv:
.a9ee						xt_asm_cmp:
.a9ee		a9 cd		lda #$cd	                lda #$CD
.a9f0		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9f3						z_asm_cmp:
.a9f3						xt_asm_cmp_h:
.a9f3		a9 c9		lda #$c9	                lda #$C9
.a9f5		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9f8						z_asm_cmp_h:
.a9f8						xt_asm_cmp_x:
.a9f8		a9 dd		lda #$dd	                lda #$DD
.a9fa		4c 7a ac	jmp $ac7a	                jmp asm_common
.a9fd						z_asm_cmp_x:
.a9fd						xt_asm_cmp_y:
.a9fd		a9 d9		lda #$d9	                lda #$D9
.a9ff		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa02						z_asm_cmp_y:
.aa02						xt_asm_cmp_z:
.aa02		a9 c5		lda #$c5	                lda #$C5
.aa04		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa07						z_asm_cmp_z:
.aa07						xt_asm_cmp_zi:
.aa07		a9 d2		lda #$d2	                lda #$D2
.aa09		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa0c						z_asm_cmp_zi:
.aa0c						xt_asm_cmp_ziy:
.aa0c		a9 d1		lda #$d1	                lda #$D1
.aa0e		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa11						z_asm_cmp_ziy:
.aa11						xt_asm_cmp_zx:
.aa11		a9 d5		lda #$d5	                lda #$D5
.aa13		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa16						z_asm_cmp_zx:
.aa16						xt_asm_cmp_zxi:
.aa16		a9 c1		lda #$c1	                lda #$C1
.aa18		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa1b						z_asm_cmp_zxi:
.aa1b						xt_asm_cpx:
.aa1b		a9 ec		lda #$ec	                lda #$EC
.aa1d		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa20						z_asm_cpx:
.aa20						xt_asm_cpx_h:
.aa20		a9 e0		lda #$e0	                lda #$E0
.aa22		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa25						z_asm_cpx_h:
.aa25						xt_asm_cpx_z:
.aa25		a9 e4		lda #$e4	                lda #$E4
.aa27		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa2a						z_asm_cpx_z:
.aa2a						xt_asm_cpy:
.aa2a		a9 cc		lda #$cc	                lda #$CC
.aa2c		a0 03		ldy #$03	                ldy #3
.aa2e		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa31						z_asm_cpy:
.aa31						xt_asm_cpy_h:
.aa31		a9 c0		lda #$c0	                lda #$C0
.aa33		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa36						z_asm_cpy_h:
.aa36						xt_asm_cpy_z:
.aa36		a9 c4		lda #$c4	                lda #$C4
.aa38		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa3b						z_asm_cpy_z:
.aa3b						xt_asm_dec:
.aa3b		a9 ce		lda #$ce	                lda #$CE
.aa3d		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa40						z_asm_dec:
.aa40						xt_asm_dec_a:
.aa40		a9 3a		lda #$3a	                lda #$3A
.aa42		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa45						z_asm_dec_a:
.aa45						xt_asm_dec_x:
.aa45		a9 de		lda #$de	                lda #$DE
.aa47		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa4a						z_asm_dec_x:
.aa4a						xt_asm_dec_z:
.aa4a		a9 c6		lda #$c6	                lda #$C6
.aa4c		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa4f						z_asm_dec_z:
.aa4f						xt_asm_dec_zx:
.aa4f		a9 d6		lda #$d6	                lda #$D6
.aa51		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa54						z_asm_dec_zx:
.aa54						xt_asm_dex:
.aa54		a9 ca		lda #$ca	                lda #$CA
.aa56		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa59						z_asm_dex:
.aa59						xt_asm_dey:
.aa59		a9 88		lda #$88	                lda #$88
.aa5b		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa5e						z_asm_dey:
.aa5e						xt_asm_eor:
.aa5e		a9 4d		lda #$4d	                lda #$4D
.aa60		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa63						z_asm_eor:
.aa63						xt_asm_eor_h:
.aa63		a9 49		lda #$49	                lda #$49
.aa65		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa68						z_asm_eor_h:
.aa68						xt_asm_eor_x:
.aa68		a9 5d		lda #$5d	                lda #$5D
.aa6a		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa6d						z_asm_eor_x:
.aa6d						xt_asm_eor_y:
.aa6d		a9 59		lda #$59	                lda #$59
.aa6f		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa72						z_asm_eor_y:
.aa72						xt_asm_eor_z:
.aa72		a9 45		lda #$45	                lda #$45
.aa74		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa77						z_asm_eor_z:
.aa77						xt_asm_eor_zi:
.aa77		a9 52		lda #$52	                lda #$52
.aa79		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa7c						z_asm_eor_zi:
.aa7c						xt_asm_eor_ziy:
.aa7c		a9 51		lda #$51	                lda #$51
.aa7e		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa81						z_asm_eor_ziy:
.aa81						xt_asm_eor_zx:
.aa81		a9 55		lda #$55	                lda #$55
.aa83		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa86						z_asm_eor_zx:
.aa86						xt_asm_eor_zxi:
.aa86		a9 41		lda #$41	                lda #$41
.aa88		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa8b						z_asm_eor_zxi:
.aa8b						xt_asm_inc:
.aa8b		a9 ee		lda #$ee	                lda #$EE
.aa8d		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa90						z_asm_inc:
.aa90						xt_asm_inc_a:
.aa90		a9 1a		lda #$1a	                lda #$1A
.aa92		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa95						z_asm_inc_a:
.aa95						xt_asm_inc_x:
.aa95		a9 fe		lda #$fe	                lda #$FE
.aa97		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa9a						z_asm_inc_x:
.aa9a						xt_asm_inc_z:
.aa9a		a9 e6		lda #$e6	                lda #$E6
.aa9c		4c 7a ac	jmp $ac7a	                jmp asm_common
.aa9f						z_asm_inc_z:
.aa9f						xt_asm_inc_zx:
.aa9f		a9 f6		lda #$f6	                lda #$F6
.aaa1		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaa4						z_asm_inc_zx:
.aaa4						xt_asm_inx:
.aaa4		a9 e8		lda #$e8	                lda #$E8
.aaa6		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaa9						z_asm_inx:
.aaa9						xt_asm_iny:
.aaa9		a9 c8		lda #$c8	                lda #$C8
.aaab		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaae						z_asm_iny:
.aaae						xt_asm_jmp:
.aaae		a9 4c		lda #$4c	                lda #$4C
.aab0		4c 7a ac	jmp $ac7a	                jmp asm_common
.aab3						z_asm_jmp:
.aab3						xt_asm_jmp_i:
.aab3		a9 6c		lda #$6c	                lda #$6C
.aab5		4c 7a ac	jmp $ac7a	                jmp asm_common
.aab8						z_asm_jmp_i:
.aab8						xt_asm_jmp_xi:
.aab8		a9 7c		lda #$7c	                lda #$7C
.aaba		4c 7a ac	jmp $ac7a	                jmp asm_common
.aabd						z_asm_jmp_xi:
.aabd						xt_asm_jsr:
.aabd		a9 20		lda #$20	                lda #$20
.aabf		4c 7a ac	jmp $ac7a	                jmp asm_common
.aac2						z_asm_jsr:
.aac2						xt_asm_lda:
.aac2		a9 ad		lda #$ad	                lda #$AD
.aac4		4c 7a ac	jmp $ac7a	                jmp asm_common
.aac7						z_asm_lda:
.aac7						xt_asm_lda_h:
.aac7		a9 a9		lda #$a9	                lda #$A9
.aac9		4c 7a ac	jmp $ac7a	                jmp asm_common
.aacc						z_asm_lda_h:
.aacc						xt_asm_lda_x:
.aacc		a9 bd		lda #$bd	                lda #$BD
.aace		4c 7a ac	jmp $ac7a	                jmp asm_common
.aad1						z_asm_lda_x:
.aad1						xt_asm_lda_y:
.aad1		a9 b9		lda #$b9	                lda #$B9
.aad3		4c 7a ac	jmp $ac7a	                jmp asm_common
.aad6						z_asm_lda_y:
.aad6						xt_asm_lda_z:
.aad6		a9 a5		lda #$a5	                lda #$A5
.aad8		4c 7a ac	jmp $ac7a	                jmp asm_common
.aadb						z_asm_lda_z:
.aadb						xt_asm_lda_zi:
.aadb		a9 b2		lda #$b2	                lda #$B2
.aadd		4c 7a ac	jmp $ac7a	                jmp asm_common
.aae0						z_asm_lda_zi:
.aae0						xt_asm_lda_ziy:
.aae0		a9 b1		lda #$b1	                lda #$B1
.aae2		4c 7a ac	jmp $ac7a	                jmp asm_common
.aae5						z_asm_lda_ziy:
.aae5						xt_asm_lda_zx:
.aae5		a9 b5		lda #$b5	                lda #$B5
.aae7		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaea						z_asm_lda_zx:
.aaea						xt_asm_lda_zxi:
.aaea		a9 a1		lda #$a1	                lda #$A1
.aaec		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaef						z_asm_lda_zxi:
.aaef						xt_asm_ldx:
.aaef		a9 ae		lda #$ae	                lda #$AE
.aaf1		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaf4						z_asm_ldx:
.aaf4						xt_asm_ldx_h:
.aaf4		a9 a2		lda #$a2	                lda #$A2
.aaf6		4c 7a ac	jmp $ac7a	                jmp asm_common
.aaf9						z_asm_ldx_h:
.aaf9						xt_asm_ldx_y:
.aaf9		a9 be		lda #$be	                lda #$BE
.aafb		4c 7a ac	jmp $ac7a	                jmp asm_common
.aafe						z_asm_ldx_y:
.aafe						xt_asm_ldx_z:
.aafe		a9 a6		lda #$a6	                lda #$A6
.ab00		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab03						z_asm_ldx_z:
.ab03						xt_asm_ldx_zy:
.ab03		a9 b6		lda #$b6	                lda #$B6
.ab05		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab08						z_asm_ldx_zy:
.ab08						xt_asm_ldy:
.ab08		a9 ac		lda #$ac	                lda #$AC
.ab0a		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab0d						z_asm_ldy:
.ab0d						xt_asm_ldy_h:
.ab0d		a9 a0		lda #$a0	                lda #$A0
.ab0f		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab12						z_asm_ldy_h:
.ab12						xt_asm_ldy_x:
.ab12		a9 bc		lda #$bc	                lda #$BC
.ab14		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab17						z_asm_ldy_x:
.ab17						xt_asm_ldy_z:
.ab17		a9 a4		lda #$a4	                lda #$A4
.ab19		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab1c						z_asm_ldy_z:
.ab1c						xt_asm_ldy_zx:
.ab1c		a9 b4		lda #$b4	                lda #$B4
.ab1e		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab21						z_asm_ldy_zx:
.ab21						xt_asm_lsr:
.ab21		a9 4e		lda #$4e	                lda #$4E
.ab23		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab26						z_asm_lsr:
.ab26						xt_asm_lsr_a:
.ab26		a9 4a		lda #$4a	                lda #$4A
.ab28		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab2b						z_asm_lsr_a:
.ab2b						xt_asm_lsr_x:
.ab2b		a9 5e		lda #$5e	                lda #$5E
.ab2d		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab30						z_asm_lsr_x:
.ab30						xt_asm_lsr_z:
.ab30		a9 46		lda #$46	                lda #$46
.ab32		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab35						z_asm_lsr_z:
.ab35						xt_asm_lsr_zx:
.ab35		a9 56		lda #$56	                lda #$56
.ab37		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab3a						z_asm_lsr_zx:
.ab3a						xt_asm_nop:
.ab3a		a9 ea		lda #$ea	                lda #$EA
.ab3c		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab3f						z_asm_nop:
.ab3f						xt_asm_ora:
.ab3f		a9 0d		lda #$0d	                lda #$0D
.ab41		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab44						z_asm_ora:
.ab44						xt_asm_ora_h:
.ab44		a9 09		lda #$09	                lda #$09
.ab46		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab49						z_asm_ora_h:
.ab49						xt_asm_ora_x:
.ab49		a9 1d		lda #$1d	                lda #$1D
.ab4b		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab4e						z_asm_ora_x:
.ab4e						xt_asm_ora_y:
.ab4e		a9 19		lda #$19	                lda #$19
.ab50		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab53						z_asm_ora_y:
.ab53						xt_asm_ora_z:
.ab53		a9 05		lda #$05	                lda #$05
.ab55		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab58						z_asm_ora_z:
.ab58						xt_asm_ora_zi:
.ab58		a9 12		lda #$12	                lda #$12
.ab5a		a0 02		ldy #$02	                ldy #2
.ab5c		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab5f						z_asm_ora_zi:
.ab5f						xt_asm_ora_ziy:
.ab5f		a9 11		lda #$11	                lda #$11
.ab61		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab64						z_asm_ora_ziy:
.ab64						xt_asm_ora_zx:
.ab64		a9 15		lda #$15	                lda #$15
.ab66		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab69						z_asm_ora_zx:
.ab69						xt_asm_ora_zxi:
.ab69		a9 01		lda #$01	                lda #$01
.ab6b		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab6e						z_asm_ora_zxi:
.ab6e						xt_asm_pha:
.ab6e		a9 48		lda #$48	                lda #$48
.ab70		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab73						z_asm_pha:
.ab73						xt_asm_php:
.ab73		a9 08		lda #$08	                lda #$08
.ab75		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab78						z_asm_php:
.ab78						xt_asm_phx:
.ab78		a9 da		lda #$da	                lda #$DA
.ab7a		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab7d						z_asm_phx:
.ab7d						xt_asm_phy:
.ab7d		a9 5a		lda #$5a	                lda #$5A
.ab7f		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab82						z_asm_phy:
.ab82						xt_asm_pla:
.ab82		a9 68		lda #$68	                lda #$68
.ab84		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab87						z_asm_pla:
.ab87						xt_asm_plp:
.ab87		a9 28		lda #$28	                lda #$28
.ab89		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab8c						z_asm_plp:
.ab8c						xt_asm_plx:
.ab8c		a9 fa		lda #$fa	                lda #$FA
.ab8e		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab91						z_asm_plx:
.ab91						xt_asm_ply:
.ab91		a9 7a		lda #$7a	                lda #$7A
.ab93		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab96						z_asm_ply:
.ab96						xt_asm_rol:
.ab96		a9 2e		lda #$2e	                lda #$2E
.ab98		4c 7a ac	jmp $ac7a	                jmp asm_common
.ab9b						z_asm_rol:
.ab9b						xt_asm_rol_a:
.ab9b		a9 2a		lda #$2a	                lda #$2A
.ab9d		4c 7a ac	jmp $ac7a	                jmp asm_common
.aba0						z_asm_rol_a:
.aba0						xt_asm_rol_x:
.aba0		a9 3e		lda #$3e	                lda #$3E
.aba2		4c 7a ac	jmp $ac7a	                jmp asm_common
.aba5						z_asm_rol_x:
.aba5						xt_asm_rol_z:
.aba5		a9 26		lda #$26	                lda #$26
.aba7		4c 7a ac	jmp $ac7a	                jmp asm_common
.abaa						z_asm_rol_z:
.abaa						xt_asm_rol_zx:
.abaa		a9 36		lda #$36	                lda #$36
.abac		4c 7a ac	jmp $ac7a	                jmp asm_common
.abaf						z_asm_rol_zx:
.abaf						xt_asm_ror:
.abaf		a9 6e		lda #$6e	                lda #$6E
.abb1		4c 7a ac	jmp $ac7a	                jmp asm_common
.abb4						z_asm_ror:
.abb4						xt_asm_ror_a:
.abb4		a9 6a		lda #$6a	                lda #$6A
.abb6		4c 7a ac	jmp $ac7a	                jmp asm_common
.abb9						z_asm_ror_a:
.abb9						xt_asm_ror_x:
.abb9		a9 7e		lda #$7e	                lda #$7E
.abbb		4c 7a ac	jmp $ac7a	                jmp asm_common
.abbe						z_asm_ror_x:
.abbe						xt_asm_ror_z:
.abbe		a9 66		lda #$66	                lda #$66
.abc0		4c 7a ac	jmp $ac7a	                jmp asm_common
.abc3						z_asm_ror_z:
.abc3						xt_asm_ror_zx:
.abc3		a9 76		lda #$76	                lda #$76
.abc5		4c 7a ac	jmp $ac7a	                jmp asm_common
.abc8						z_asm_ror_zx:
.abc8						xt_asm_rti:
.abc8		a9 40		lda #$40	                lda #$40
.abca		4c 7a ac	jmp $ac7a	                jmp asm_common
.abcd						z_asm_rti:
.abcd						xt_asm_rts:
.abcd		a9 60		lda #$60	                lda #$60
.abcf		4c 7a ac	jmp $ac7a	                jmp asm_common
.abd2						z_asm_rts:
.abd2						xt_asm_sbc:
.abd2		a9 ed		lda #$ed	                lda #$ED
.abd4		4c 7a ac	jmp $ac7a	                jmp asm_common
.abd7						z_asm_sbc:
.abd7						xt_asm_sbc_h:
.abd7		a9 e9		lda #$e9	                lda #$E9
.abd9		4c 7a ac	jmp $ac7a	                jmp asm_common
.abdc						z_asm_sbc_h:
.abdc						xt_asm_sbc_x:
.abdc		a9 fd		lda #$fd	                lda #$FD
.abde		4c 7a ac	jmp $ac7a	                jmp asm_common
.abe1						z_asm_sbc_x:
.abe1						xt_asm_sbc_y:
.abe1		a9 f9		lda #$f9	                lda #$F9
.abe3		4c 7a ac	jmp $ac7a	                jmp asm_common
.abe6						z_asm_sbc_y:
.abe6						xt_asm_sbc_z:
.abe6		a9 e5		lda #$e5	                lda #$E5
.abe8		4c 7a ac	jmp $ac7a	                jmp asm_common
.abeb						z_asm_sbc_z:
.abeb						xt_asm_sbc_zi:
.abeb		a9 f2		lda #$f2	                lda #$F2
.abed		4c 7a ac	jmp $ac7a	                jmp asm_common
.abf0						z_asm_sbc_zi:
.abf0						xt_asm_sbc_ziy:
.abf0		a9 f1		lda #$f1	                lda #$F1
.abf2		4c 7a ac	jmp $ac7a	                jmp asm_common
.abf5						z_asm_sbc_ziy:
.abf5						xt_asm_sbc_zx:
.abf5		a9 f5		lda #$f5	                lda #$F5
.abf7		4c 7a ac	jmp $ac7a	                jmp asm_common
.abfa						z_asm_sbc_zx:
.abfa						xt_asm_sbc_zxi:
.abfa		a9 e1		lda #$e1	                lda #$E1
.abfc		80 7c		bra $ac7a	                bra asm_common  ; <-- limit for BRA instead of JMP
.abfe						z_asm_sbc_zxi:
.abfe						xt_asm_sec:
.abfe		a9 38		lda #$38	                lda #$38
.ac00		80 78		bra $ac7a	                bra asm_common
.ac02						z_asm_sec:
.ac02						xt_asm_sed:
.ac02		a9 f8		lda #$f8	                lda #$F8
.ac04		80 74		bra $ac7a	                bra asm_common
.ac06						z_asm_sed:
.ac06						xt_asm_sei:
.ac06		a9 78		lda #$78	                lda #$78
.ac08		80 70		bra $ac7a	                bra asm_common
.ac0a						z_asm_sei:
.ac0a						xt_asm_sta:
.ac0a		a9 8d		lda #$8d	                lda #$8D
.ac0c		80 6c		bra $ac7a	                bra asm_common
.ac0e						z_asm_sta:
.ac0e						xt_asm_sta_x:
.ac0e		a9 9d		lda #$9d	                lda #$9D
.ac10		80 68		bra $ac7a	                bra asm_common
.ac12						z_asm_sta_x:
.ac12						xt_asm_sta_y:
.ac12		a9 99		lda #$99	                lda #$99
.ac14		80 64		bra $ac7a	                bra asm_common
.ac16						z_asm_sta_y:
.ac16						xt_asm_sta_z:
.ac16		a9 85		lda #$85	                lda #$85
.ac18		80 60		bra $ac7a	                bra asm_common
.ac1a						z_asm_sta_z:
.ac1a						xt_asm_sta_zi:
.ac1a		a9 92		lda #$92	                lda #$92
.ac1c		80 5c		bra $ac7a	                bra asm_common
.ac1e						z_asm_sta_zi:
.ac1e						xt_asm_sta_ziy:
.ac1e		a9 91		lda #$91	                lda #$91
.ac20		80 58		bra $ac7a	                bra asm_common
.ac22						z_asm_sta_ziy:
.ac22						xt_asm_sta_zx:
.ac22		a9 95		lda #$95	                lda #$95
.ac24		80 54		bra $ac7a	                bra asm_common
.ac26						z_asm_sta_zx:
.ac26						xt_asm_sta_zxi:
.ac26		a9 81		lda #$81	                lda #$81
.ac28		80 50		bra $ac7a	                bra asm_common
.ac2a						z_asm_sta_zxi:
.ac2a						xt_asm_stx:
.ac2a		a9 8e		lda #$8e	                lda #$8E
.ac2c		80 4c		bra $ac7a	                bra asm_common
.ac2e						z_asm_stx:
.ac2e						xt_asm_stx_z:
.ac2e		a9 86		lda #$86	                lda #$86
.ac30		80 48		bra $ac7a	                bra asm_common
.ac32						z_asm_stx_z:
.ac32						xt_asm_stx_zy:
.ac32		a9 96		lda #$96	                lda #$96
.ac34		80 44		bra $ac7a	                bra asm_common
.ac36						z_asm_stx_zy:
.ac36						xt_asm_sty:
.ac36		a9 8c		lda #$8c	                lda #$8C
.ac38		80 40		bra $ac7a	                bra asm_common
.ac3a						z_asm_sty:
.ac3a						xt_asm_sty_z:
.ac3a		a9 84		lda #$84	                lda #$84
.ac3c		80 3c		bra $ac7a	                bra asm_common
.ac3e						z_asm_sty_z:
.ac3e						xt_asm_sty_zx:
.ac3e		a9 94		lda #$94	                lda #$94
.ac40		80 38		bra $ac7a	                bra asm_common
.ac42						z_asm_sty_zx:
.ac42						xt_asm_stz:
.ac42		a9 9c		lda #$9c	                lda #$9C
.ac44		80 34		bra $ac7a	                bra asm_common
.ac46						z_asm_stz:
.ac46						xt_asm_stz_x:
.ac46		a9 9e		lda #$9e	                lda #$9E
.ac48		80 30		bra $ac7a	                bra asm_common
.ac4a						z_asm_stz_x:
.ac4a						xt_asm_stz_z:
.ac4a		a9 64		lda #$64	                lda #$64
.ac4c		80 2c		bra $ac7a	                bra asm_common
.ac4e						z_asm_stz_z:
.ac4e						xt_asm_stz_zx:
.ac4e		a9 74		lda #$74	                lda #$74
.ac50		80 28		bra $ac7a	                bra asm_common
.ac52						z_asm_stz_zx:
.ac52						xt_asm_tax:
.ac52		a9 aa		lda #$aa	                lda #$AA
.ac54		80 24		bra $ac7a	                bra asm_common
.ac56						z_asm_tax:
.ac56						xt_asm_tay:
.ac56		a9 a8		lda #$a8	                lda #$A8
.ac58		80 20		bra $ac7a	                bra asm_common
.ac5a						z_asm_tay:
.ac5a						xt_asm_trb:
.ac5a		a9 1c		lda #$1c	                lda #$1C
.ac5c		80 1c		bra $ac7a	                bra asm_common
.ac5e						z_asm_trb:
.ac5e						xt_asm_trb_z:
.ac5e		a9 14		lda #$14	                lda #$14
.ac60		80 18		bra $ac7a	                bra asm_common
.ac62						z_asm_trb_z:
.ac62						xt_asm_tsb:
.ac62		a9 0c		lda #$0c	                lda #$0C
.ac64		80 14		bra $ac7a	                bra asm_common
.ac66						z_asm_tsb:
.ac66						xt_asm_tsb_z:
.ac66		a9 04		lda #$04	                lda #$04
.ac68		80 10		bra $ac7a	                bra asm_common
.ac6a						z_asm_tsb_z:
.ac6a						xt_asm_tsx:
.ac6a		a9 ba		lda #$ba	                lda #$BA
.ac6c		80 0c		bra $ac7a	                bra asm_common
.ac6e						z_asm_tsx:
.ac6e						xt_asm_txa:
.ac6e		a9 8a		lda #$8a	                lda #$8A
.ac70		80 08		bra $ac7a	                bra asm_common
.ac72						z_asm_txa:
.ac72						xt_asm_txs:
.ac72		a9 9a		lda #$9a	                lda #$9A
.ac74		80 04		bra $ac7a	                bra asm_common
.ac76						z_asm_txs:
.ac76						xt_asm_tya:
.ac76		a9 98		lda #$98	                lda #$98
.ac78		80 00		bra $ac7a	                bra asm_common
.ac7a						z_asm_tya:
.ac7a						asm_common:
.ac7a		a8		tay		                tay
.ac7b		20 22 d7	jsr $d722	                jsr cmpl_a
.ac7e		a9 27		lda #$27	                lda #<oc_index_table
.ac80		85 26		sta $26		                sta tmp2
.ac82		a9 af		lda #$af	                lda #>oc_index_table
.ac84		85 27		sta $27		                sta tmp2+1
.ac86		98		tya		                tya             ; retrieve opcode
.ac87		0a		asl a		                asl             ; times two for offset
.ac88		90 02		bcc $ac8c	                bcc +
.ac8a		e6 27		inc $27		                inc tmp2+1
.ac8c						+
.ac8c		a8		tay		                tay             ; use Y as the index
.ac8d		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.ac8f		85 28		sta $28		                sta tmp3
.ac91		c8		iny		                iny
.ac92		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.ac94		85 29		sta $29		                sta tmp3+1
.ac96		b2 28		lda ($28)	                lda (tmp3)      ; get "lengths byte"
.ac98		2a		rol a		                rol
.ac99		2a		rol a		                rol
.ac9a		2a		rol a		                rol             ; Three times because we go through Carry
.ac9b		29 03		and #$03	                and #%00000011
.ac9d		a8		tay		                tay
.ac9e		88		dey		                dey
.ac9f		f0 12		beq $acb3	                beq _done
.aca1		20 6f d8	jsr $d86f	                jsr underflow_1
.aca4		b5 00		lda $00,x	                lda 0,x
.aca6		20 22 d7	jsr $d722	                jsr cmpl_a      ; does not use Y
.aca9		88		dey		                dey
.acaa		f0 05		beq $acb1	                beq _done_drop
.acac		b5 01		lda $01,x	                lda 1,x
.acae		20 22 d7	jsr $d722	                jsr cmpl_a      ; Fall through to _done_drop
.acb1						_done_drop:
.acb1		e8		inx		                inx
.acb2		e8		inx		                inx             ; Fall through to _done
.acb3						_done:
.acb3		60		rts		                rts             ; Returns to original caller
.acb4						xt_asm_push_a:
.acb4		a0 00		ldy #$00	                ldy #0
.acb6						_loop:
.acb6		b9 c4 ac	lda $acc4,y	                lda asm_push_a_data,y
.acb9		c9 ff		cmp #$ff	                cmp #$FF
.acbb		f0 06		beq $acc3	                beq _done
.acbd		20 22 d7	jsr $d722	                jsr cmpl_a      ; does not change Y
.acc0		c8		iny		                iny
.acc1		80 f3		bra $acb6	                bra _loop
.acc3						_done:
.acc3						z_asm_push_a:
.acc3		60		rts		                rts
.acc4						asm_push_a_data:
>acc4		ca ca 95 00 74 01		        .byte $CA, $CA, $95, 00, $74, $01
>acca		ff				        .byte $FF               ; terminator
.accb						xt_asm_back_jump:
.accb						z_asm_back_jump:
.accb		60		rts		                rts
.accc						xt_asm_back_branch:
.accc		20 57 91	jsr $9157	                jsr xt_here             ; ( addr-l addr-h )
.accf		20 34 95	jsr $9534	                jsr xt_minus            ; ( offset )
.acd2		3a		dec a		                dea
.acd3		3a		dec a		                dea
.acd4						z_asm_back_branch:
.acd4		60		rts		                rts
.acd5						assembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../disassembler.asm

.acd5						disassembler:
.acd5		20 2a 89	jsr $892a	                jsr xt_cr       ; ( addr u )
.acd8						_byte_loop:
.acd8		20 77 98	jsr $9877	                jsr xt_over     ; ( addr u addr )
.acdb		20 d2 a4	jsr $a4d2	                jsr xt_u_dot    ; ( addr u )
.acde		20 cc a0	jsr $a0cc	                jsr xt_space
.ace1		a9 27		lda #$27	                lda #<oc_index_table
.ace3		85 26		sta $26		                sta tmp2
.ace5		a9 af		lda #$af	                lda #>oc_index_table
.ace7		85 27		sta $27		                sta tmp2+1
.ace9		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.aceb		85 36		sta $36		                sta scratch     ; Save opcode
.aced		0a		asl a		                asl             ; multiply by two for offset
.acee		90 02		bcc $acf2	                bcc +
.acf0		e6 27		inc $27		                inc tmp2+1      ; we're on second page
.acf2						+
.acf2		a8		tay		                tay             ; use Y as the index
.acf3		b1 26		lda ($26),y	                lda (tmp2),y    ; LSB
.acf5		85 28		sta $28		                sta tmp3
.acf7		48		pha		                pha
.acf8		c8		iny		                iny
.acf9		b1 26		lda ($26),y	                lda (tmp2),y    ; MSB
.acfb		85 29		sta $29		                sta tmp3+1
.acfd		48		pha		                pha
.acfe		b2 28		lda ($28)	                lda (tmp3)
.ad00		a8		tay		                tay                     ; save copy of lengths byte
.ad01		10 3c		bpl $ad3f	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.ad03		20 56 a7	jsr $a756	                jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
.ad06		f6 04		inc $04,x	                inc 4,x
.ad08		d0 02		bne $ad0c	                bne +
.ad0a		f6 05		inc $05,x	                inc 5,x                 ; ( addr+1 u 0 )
.ad0c						+
.ad0c		b5 02		lda $02,x	                lda 2,x
.ad0e		d0 02		bne $ad12	                bne +
.ad10		d6 03		dec $03,x	                dec 3,x
.ad12						+
.ad12		d6 02		dec $02,x	                dec 2,x                 ; ( addr+1 u-1 0 )
.ad14		a1 04		lda ($04,x)	                lda (4,x)
.ad16		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.ad18		85 37		sta $37		                sta scratch+1           ; Save a copy in the scratch buffer
.ad1a		98		tya		                tya                     ; retrieve copy of lengths byte
.ad1b		2a		rol a		                rol                     ; shift bit 6 to bit 7
.ad1c		10 14		bpl $ad32	                bpl _print_operand
.ad1e		f6 04		inc $04,x	                inc 4,x
.ad20		d0 02		bne $ad24	                bne +
.ad22		f6 05		inc $05,x	                inc 5,x                 ; ( addr+2 u-1 LSB )
.ad24						+
.ad24		b5 02		lda $02,x	                lda 2,x
.ad26		d0 02		bne $ad2a	                bne +
.ad28		d6 03		dec $03,x	                dec 3,x
.ad2a						+
.ad2a		d6 02		dec $02,x	                dec 2,x                 ; ( addr+2 u-2 LSB )
.ad2c		a1 04		lda ($04,x)	                lda (4,x)
.ad2e		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.ad30		85 38		sta $38		                sta scratch+2           ; Save a copy in the scratch buffer
.ad32						_print_operand:
.ad32		ca		dex		                dex
.ad33		ca		dex		                dex
.ad34		a9 05		lda #$05	                lda #5
.ad36		95 00		sta $00,x	                sta 0,x
.ad38		74 01		stz $01,x	                stz 1,x                 ; ( addr+n u-n opr 5 )
.ad3a		20 de a4	jsr $a4de	                jsr xt_u_dot_r          ; U.R ( addr+n u-n )
.ad3d		80 0b		bra $ad4a	                bra _print_mnemonic
.ad3f						_no_operand:
.ad3f		ca		dex		                dex
.ad40		ca		dex		                dex
.ad41		a9 05		lda #$05	                lda #5
.ad43		95 00		sta $00,x	                sta 0,x
.ad45		74 01		stz $01,x	                stz 1,x                 ; ( addr u 5 )
.ad47		20 d2 a0	jsr $a0d2	                jsr xt_spaces           ; ( addr u )
.ad4a						_print_mnemonic:
.ad4a		20 cc a0	jsr $a0cc	                jsr xt_space
.ad4d		ca		dex		                dex
.ad4e		ca		dex		                dex                     ; ( addr u ? )
.ad4f		68		pla		                pla                     ; MSB
.ad50		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.ad52		68		pla		                pla                     ; LSB
.ad53		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.ad55		20 16 89	jsr $8916	                jsr xt_count            ; ( addr u addr-o u-o )
.ad58		74 01		stz $01,x	                stz 1,x                 ; paranoid
.ad5a		b5 00		lda $00,x	                lda 0,x
.ad5c		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.ad5e		95 00		sta $00,x	                sta 0,x
.ad60		20 a7 a4	jsr $a4a7	                jsr xt_type             ; ( addr u )
.ad63		a5 36		lda $36		                lda scratch
.ad65		c9 20		cmp #$20	                cmp #$20
.ad67		d0 4e		bne $adb7	                bne _not_jsr
.ad69		ca		dex		                dex
.ad6a		ca		dex		                dex
.ad6b		a9 05		lda #$05	                lda #5
.ad6d		95 00		sta $00,x	                sta 0,x
.ad6f		74 01		stz $01,x	                stz 1,x
.ad71		20 d2 a0	jsr $a0d2	                jsr xt_spaces
.ad74		a0 10		ldy #$10	                ldy #(_end_handlers - _special_handlers - 4)
.ad76		b9 a3 ad	lda $ada3,y	_check_handler: lda _special_handlers,y
.ad79		c5 37		cmp $37		                cmp scratch+1
.ad7b		d0 07		bne $ad84	                bne _next_handler
.ad7d		b9 a4 ad	lda $ada4,y	                lda _special_handlers+1,y
.ad80		c5 38		cmp $38		                cmp scratch+2
.ad82		f0 0c		beq $ad90	                beq _run_handler
.ad84		88		dey		_next_handler:  dey
.ad85		88		dey		                dey
.ad86		88		dey		                dey
.ad87		88		dey		                dey
.ad88		10 ec		bpl $ad76	                bpl _check_handler
.ad8a						_not_special:
.ad8a		20 d7 ae	jsr $aed7	                jsr disasm_jsr
.ad8d		4c 21 ae	jmp $ae21	                jmp _printing_done
.ad90						_run_handler:
.ad90		b9 a5 ad	lda $ada5,y	                lda _special_handlers+2,y
.ad93		85 39		sta $39		                sta scratch+3
.ad95		b9 a6 ad	lda $ada6,y	                lda _special_handlers+3,y
.ad98		85 3a		sta $3a		                sta scratch+4
.ad9a		20 a0 ad	jsr $ada0	                jsr _dispatch_handler
.ad9d		4c 21 ae	jmp $ae21	                jmp _printing_done
.ada0						_dispatch_handler:
.ada0		6c 39 00	jmp ($0039)	                jmp (scratch+3)
.ada3						_special_handlers:
>ada3		79 93 b9 ae			    .word literal_runtime,      disasm_literal
>ada7		57 a0 67 ae			    .word sliteral_runtime,     disasm_sliteral
>adab		01 92 9e ae			    .word zero_branch_runtime,  disasm_0branch
>adaf		f7 91 aa ae			    .word zero_test_runtime,    disasm_0test
>adb3		63 8b af ae			    .word do_runtime,           disasm_do
.adb7						_end_handlers:
.adb7						_not_jsr:
.adb7		c9 4c		cmp #$4c	                cmp #$4C
.adb9		d0 2c		bne $ade7	                bne _not_jmp
.adbb		a5 37		lda $37		                lda scratch+1   ; Copy the pointer.
.adbd		85 39		sta $39		                sta scratch+3
.adbf		a5 38		lda $38		                lda scratch+2
.adc1		85 3a		sta $3a		                sta scratch+4
.adc3		b2 39		lda ($39)	                lda (scratch+3)
.adc5		c9 20		cmp #$20	                cmp #$20 ; check for JSR
.adc7		d0 58		bne $ae21	                bne _printing_done
.adc9		e6 39		inc $39		                inc scratch+3
.adcb		d0 02		bne $adcf	                bne +
.adcd		e6 3a		inc $3a		                inc scratch+4
.adcf						+
.adcf		b2 39		lda ($39)	                lda (scratch+3)
.add1		c9 57		cmp #$57	                cmp #<sliteral_runtime
.add3		d0 4c		bne $ae21	                bne _printing_done
.add5		e6 39		inc $39		                inc scratch+3
.add7		d0 02		bne $addb	                bne +
.add9		e6 3a		inc $3a		                inc scratch+4
.addb						+
.addb		b2 39		lda ($39)	                lda (scratch+3)
.addd		c9 a0		cmp #$a0	                cmp #>sliteral_runtime
.addf		d0 40		bne $ae21	                bne _printing_done
.ade1		20 3d ae	jsr $ae3d	                jsr disasm_sliteral_jump
.ade4		4c 21 ae	jmp $ae21	                jmp _printing_done
.ade7						_not_jmp:
.ade7		c9 80		cmp #$80	                cmp #$80            ; is it bra?
.ade9		f0 06		beq $adf1	                beq _is_rel
.adeb		29 1f		and #$1f	                and #$1f
.aded		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.adef		d0 30		bne $ae21	                bne _printing_done
.adf1						_is_rel:
.adf1		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.adf3		ca		dex		                dex
.adf4		ca		dex		                dex
.adf5		74 01		stz $01,x	                stz 1,x
.adf7		a5 37		lda $37		                lda scratch+1
.adf9		95 00		sta $00,x	                sta 0,x
.adfb		10 04		bpl $ae01	                bpl +
.adfd		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.adff		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.ae01		38		sec		+               sec                 ; start counting from address after opcode
.ae02		75 04		adc $04,x	                adc 4,x
.ae04		95 00		sta $00,x	                sta 0,x
.ae06		b5 01		lda $01,x	                lda 1,x
.ae08		75 05		adc $05,x	                adc 5,x
.ae0a		95 01		sta $01,x	                sta 1,x
.ae0c		5a		phy		                phy                 ; save the direction indicator
.ae0d		ca		dex		                dex
.ae0e		ca		dex		                dex
.ae0f		a9 09		lda #$09	                lda #9
.ae11		95 00		sta $00,x	                sta 0,x
.ae13		74 01		stz $01,x	                stz 1,x
.ae15		20 de a4	jsr $a4de	                jsr xt_u_dot_r      ; print the destination with 5 leading spaces
.ae18		a9 20		lda #$20	                lda #AscSp          ; print space and branch direction indicator
.ae1a		20 db 8d	jsr $8ddb	                jsr emit_a
.ae1d		68		pla		                pla
.ae1e		20 db 8d	jsr $8ddb	                jsr emit_a
.ae21						_printing_done:
.ae21		20 2a 89	jsr $892a	                jsr xt_cr
.ae24		f6 02		inc $02,x	                inc 2,x
.ae26		d0 02		bne $ae2a	                bne +
.ae28		f6 03		inc $03,x	                inc 3,x                 ; ( addr+1 u )
.ae2a						+
.ae2a		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; ( addr+1 u-1 )
.ae2d		b5 00		lda $00,x	                lda 0,x                 ; All done?
.ae2f		15 01		ora $01,x	                ora 1,x
.ae31		f0 07		beq $ae3a	                beq _done
.ae33		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.ae35		30 03		bmi $ae3a	                bmi _done
.ae37		4c d8 ac	jmp $acd8	                jmp _byte_loop          ; out of range for BRA
.ae3a						_done:
.ae3a		4c 54 a3	jmp $a354	                jmp xt_two_drop         ; JSR/RTS
.ae3d						disasm_sliteral_jump:
.ae3d		20 5c a1	jsr $a15c	                jsr xt_swap
.ae40		ca		dex		                dex
.ae41		ca		dex		                dex
.ae42		a5 37		lda $37		                lda scratch+1
.ae44		95 00		sta $00,x	                sta 0,x
.ae46		a5 38		lda $38		                lda scratch+2
.ae48		95 01		sta $01,x	                sta 1,x
.ae4a		20 5c a1	jsr $a15c	                jsr xt_swap
.ae4d		20 34 95	jsr $9534	                jsr xt_minus
.ae50		20 f5 97	jsr $97f5	                jsr xt_one_minus
.ae53		20 34 95	jsr $9534	                jsr xt_minus
.ae56		ca		dex		                dex
.ae57		ca		dex		                dex
.ae58		a5 37		lda $37		                lda scratch+1
.ae5a		95 00		sta $00,x	                sta 0,x
.ae5c		a5 38		lda $38		                lda scratch+2
.ae5e		95 01		sta $01,x	                sta 1,x
.ae60		20 f5 97	jsr $97f5	                jsr xt_one_minus
.ae63		20 5c a1	jsr $a15c	                jsr xt_swap ; ( new_addr new_n )
.ae66		60		rts		                rts
.ae67						disasm_sliteral:
.ae67		a9 53		lda #$53	                lda #'S'
.ae69		20 db 8d	jsr $8ddb	                jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
.ae6c		a9 0c		lda #$0c	                lda #str_disasm_lit     ; "LITERAL "
.ae6e		20 ab d8	jsr $d8ab	                jsr print_string_no_lf
.ae71		20 5c a1	jsr $a15c	                jsr xt_swap             ; switch to (u addr)
.ae74		20 01 98	jsr $9801	                jsr xt_one_plus
.ae77		20 62 8d	jsr $8d62	                jsr xt_dup
.ae7a		20 65 8f	jsr $8f65	                jsr xt_fetch
.ae7d		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; Print the address of the string
.ae80		20 4b a3	jsr $a34b	                jsr xt_two
.ae83		20 c7 99	jsr $99c7	                jsr xt_plus
.ae86		20 62 8d	jsr $8d62	                jsr xt_dup
.ae89		20 46 9a	jsr $9a46	                jsr xt_question         ; Print the length of the string
.ae8c		20 01 98	jsr $9801	                jsr xt_one_plus
.ae8f		20 5c a1	jsr $a15c	                jsr xt_swap            ; ( addr+4 u )
.ae92		ca		dex		                dex
.ae93		ca		dex		                dex
.ae94		a9 04		lda #$04	                lda #4
.ae96		95 00		sta $00,x	                sta 0,x
.ae98		74 01		stz $01,x	                stz 1,x
.ae9a		20 34 95	jsr $9534	                jsr xt_minus            ; ( addr+4 u-4 )
.ae9d		60		rts		                rts
.ae9e						disasm_0branch:
.ae9e		a9 30		lda #$30	                lda #'0'
.aea0		20 db 8d	jsr $8ddb	                jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
.aea3						disasm_branch:
.aea3		a9 0e		lda #$0e	                lda #str_disasm_bra
.aea5		20 ab d8	jsr $d8ab	                jsr print_string_no_lf ; "BRANCH "
.aea8		80 14		bra $aebe	                bra disasm_print_literal
.aeaa						disasm_0test:
.aeaa		a9 5a		lda #$5a	                lda #'Z'
.aeac		4c db 8d	jmp $8ddb	                jmp emit_a
.aeaf						disasm_do:
.aeaf		a9 44		lda #$44	                lda #'D'
.aeb1		20 db 8d	jsr $8ddb	                jsr emit_a
.aeb4		a9 4f		lda #$4f	                lda #'O'
.aeb6		4c db 8d	jmp $8ddb	                jmp emit_a
.aeb9						disasm_literal:
.aeb9		a9 0c		lda #$0c	                lda #str_disasm_lit
.aebb		20 ab d8	jsr $d8ab	                jsr print_string_no_lf ; "LITERAL "
.aebe						disasm_print_literal:
.aebe		20 5c a1	jsr $a15c	                jsr xt_swap ; switch to (u addr)
.aec1		20 01 98	jsr $9801	                jsr xt_one_plus
.aec4		20 62 8d	jsr $8d62	                jsr xt_dup
.aec7		20 46 9a	jsr $9a46	                jsr xt_question ; Print the value at the address
.aeca		20 01 98	jsr $9801	                jsr xt_one_plus
.aecd		20 5c a1	jsr $a15c	                jsr xt_swap ; (addr+2 u)
.aed0		20 f5 97	jsr $97f5	                jsr xt_one_minus
.aed3		20 f5 97	jsr $97f5	                jsr xt_one_minus ; (addr+2 u-2)
.aed6		60		rts		                rts
.aed7						disasm_jsr:
.aed7		ca		dex		                dex
.aed8		ca		dex		                dex
.aed9		a5 37		lda $37		                lda scratch+1
.aedb		95 00		sta $00,x	                sta 0,x
.aedd		a5 38		lda $38		                lda scratch+2
.aedf		95 01		sta $01,x	                sta 1,x
.aee1		20 59 92	jsr $9259	                jsr xt_int_to_name
.aee4		b5 00		lda $00,x	                lda 0,x
.aee6		15 01		ora $01,x	                ora 1,x
.aee8		f0 07		beq $aef1	                beq _disasm_no_nt
.aeea		20 e2 95	jsr $95e2	                jsr xt_name_to_string
.aeed		20 a7 a4	jsr $a4a7	                jsr xt_type
.aef0		60		rts		                rts
.aef1						_disasm_no_nt:
.aef1		20 e1 8c	jsr $8ce1	                jsr xt_drop ; the 0 indicating no name token
.aef4		ca		dex		                dex
.aef5		ca		dex		                dex
.aef6		a5 37		lda $37		                lda scratch+1
.aef8		95 00		sta $00,x	                sta 0,x
.aefa		a5 38		lda $38		                lda scratch+2
.aefc		95 01		sta $01,x	                sta 1,x
.aefe		ca		dex		                dex
.aeff		ca		dex		                dex
.af00		a9 6f		lda #$6f	                lda #<underflow_1
.af02		95 00		sta $00,x	                sta 0,x
.af04		a9 d8		lda #$d8	                lda #>underflow_1
.af06		95 01		sta $01,x	                sta 1,x
.af08		20 96 d7	jsr $d796	                jsr compare_16bit
.af0b		f0 02		beq $af0f	                beq _disasm_jsr_uflow_check_upper
.af0d		b0 14		bcs $af23	                bcs _disasm_jsr_unknown
.af0f						_disasm_jsr_uflow_check_upper:
.af0f		a9 7e		lda #$7e	                lda #<underflow_4
.af11		95 00		sta $00,x	                sta 0,x
.af13		a9 d8		lda #$d8	                lda #>underflow_4
.af15		95 01		sta $01,x	                sta 1,x
.af17		20 96 d7	jsr $d796	                jsr compare_16bit
.af1a		f0 02		beq $af1e	                beq _disasm_jsr_soc
.af1c		90 05		bcc $af23	                bcc _disasm_jsr_unknown
.af1e						_disasm_jsr_soc:
.af1e		a9 0d		lda #$0d	                lda #str_disasm_sdc
.af20		20 ab d8	jsr $d8ab	                jsr print_string_no_lf  ; "STACK DEPTH CHECK"
.af23						_disasm_jsr_unknown:
.af23		20 54 a3	jsr $a354	                jsr xt_two_drop
.af26		60		rts		                rts
.af27						oc_index_table:
>af27		27 b1 2b b1 bf b5 bf b5		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
>af2f		33 b1 39 b1 3f b1 bf b5
>af37		45 b1 49 b1 4f b1 bf b5		        .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
>af3f		55 b1 59 b1 5d b1 61 b1
>af47		66 b1 6a b1 72 b1 bf b5		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>af4f		79 b1 7f b1 86 b1 8d b1
>af57		94 b1 98 b1 9e b1 bf b5		        .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
>af5f		a4 b1 a8 b1 bf b5 ae b1
>af67		b4 b1 b8 b1 bf b5 bf b5		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>af6f		c0 b1 c6 b1 cc b1 d2 b1
>af77		d9 b1 dd b1 e3 b1 bf b5		        .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
>af7f		e9 b1 ed b1 f2 b1 f6 b1
>af87		fb b1 ff b1 07 b2 bf b5		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>af8f		0e b2 16 b2 1d b2 24 b2
>af97		2b b2 2f b2 35 b2 bf b5		        .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
>af9f		3b b2 41 b2 47 b2 61 b1
>afa7		52 b2 56 b2 bf b5 bf b5		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>afaf		bf b5 5e b2 64 b2 6a b2
>afb7		71 b2 75 b2 7b b2 bf b5		        .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
>afbf		81 b2 85 b2 89 b2 8d b2
>afc7		92 b2 96 b2 9e b2 bf b5		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>afcf		bf b5 a5 b2 ac b2 b3 b2
>afd7		ba b2 be b2 c4 b2 bf b5		        .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
>afdf		bf b5 bf b5 ce b2 d4 b2
>afe7		d9 b2 dd b2 bf b5 bf b5		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>afef		e5 b2 eb b2 f1 b2 f7 b2
>aff7		fe b2 02 b3 08 b3 bf b5		        .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
>afff		0e b3 14 b3 18 b3 1c b3
>b007		21 b3 25 b3 2d b3 bf b5		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b00f		34 b3 3b b3 42 b3 49 b3
>b017		50 b3 54 b3 5a b3 bf b5		        .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
>b01f		5e b3 65 b3 6b b3 71 b3
>b027		76 b3 7a b3 bf b5 bf b5		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
>b02f		82 b3 88 b3 8e b3 bf b5
>b037		94 b3 98 b3 9e b3 bf b5		        .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
>b03f		a2 b3 a6 b3 aa b3 ae b3
>b047		b3 b3 b7 b3 bf b3 bf b5		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b04f		c6 b3 cd b3 d4 b3 db b3
>b057		e2 b3 e6 b3 ec b3 bf b5		        .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
>b05f		f0 b3 f4 b3 fa b3 00 b4
>b067		05 b4 0b b4 13 b4 bf b5		        .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
>b06f		19 b4 1f b4 25 b4 2b b4
>b077		32 b4 36 b4 3c b4 bf b5		        .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
>b07f		40 b4 44 b4 48 b4 4c b4
>b087		51 b4 55 b4 5d b4 bf b5		        .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
>b08f		64 b4 6b b4 72 b4 79 b4
>b097		80 b4 84 b4 8a b4 bf b5		        .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
>b09f		8e b4 94 b4 9a b4 a0 b4
>b0a7		a5 b4 ab b4 bf b5 bf b5		        .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
>b0af		b3 b4 b9 b4 bf b4 c5 b4
>b0b7		cc b4 d0 b4 d6 b4 bf b5		        .word occ8, occ9, occa, oc__, occc, occd, occe, occf
>b0bf		da b4 de b4 e2 b4 e6 b4
>b0c7		eb b4 ef b4 f7 b4 bf b5		        .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
>b0cf		bf b5 fe b4 05 b5 0c b5
>b0d7		13 b5 17 b5 1d b5 bf b5		        .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
>b0df		bf b5 21 b5 27 b5 2d b5
>b0e7		32 b5 38 b5 bf b5 bf b5		        .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
>b0ef		40 b5 46 b5 4c b5 52 b5
>b0f7		59 b5 5d b5 63 b5 bf b5		        .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
>b0ff		67 b5 6b b5 6f b5 73 b5
>b107		78 b5 7c b5 84 b5 bf b5		        .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
>b10f		bf b5 8b b5 92 b5 99 b5
>b117		a0 b5 a4 b5 aa b5 bf b5		        .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
>b11f		bf b5 ae b5 b4 b5 ba b5
.b127						oc_table:
>b127		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b12b		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b133		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b139		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b13f		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b145		43 70 68 70				oc08:	.text 1*64+3, "php"
>b149		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b14f		45 61 73 6c 2e 61			oc0a:	.text 1*64+5, "asl.a"
>b155		c3 74 73 62				oc0c:	.text 3*64+3, "tsb"
>b159		c3 6f 72 61				oc0d:	.text 3*64+3, "ora"
>b15d		c3 61 73 6c				oc0e:	.text 3*64+3, "asl"
>b161		c4 62 62 72 30				oc0f:	.text 3*64+4, "bbr0"
>b166		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b16a		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b172		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b179		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b17f		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b186		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b18d		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b194		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b198		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b19e		45 69 6e 63 2e 61			oc1a:	.text 1*64+5, "inc.a"
>b1a4		c3 74 72 62				oc1c:	.text 3*64+3, "trb"
>b1a8		c5 6f 72 61 2e 78			oc1d:	.text 3*64+5, "ora.x"
>b1ae		c5 61 73 6c 2e 78			oc1f:	.text 3*64+5, "asl.x"
>b1b4		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b1b8		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b1c0		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b1c6		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b1cc		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b1d2		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b1d9		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b1dd		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b1e3		45 72 6f 6c 2e 61			oc2a:	.text 1*64+5, "rol.a"
>b1e9		c3 62 69 74				oc2c:	.text 3*64+3, "bit"
>b1ed		c4 61 6e 64 2e				oc2d:	.text 3*64+4, "and."
>b1f2		c3 72 6f 6c				oc2e:	.text 3*64+3, "rol"
>b1f6		c4 62 62 72 32				oc2f:	.text 3*64+4, "bbr2"
>b1fb		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b1ff		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b207		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b20e		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b216		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b21d		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b224		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b22b		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b22f		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b235		45 64 65 63 2e 61			oc3a:	.text 1*64+5, "dec.a"
>b23b		c5 62 69 74 2e 78			oc3c:	.text 3*64+5, "bit.x"
>b241		c5 61 6e 64 2e 78			oc3d:	.text 3*64+5, "and.x"
>b247		c5 72 6f 6c 2e 78			oc3e:	.text 3*64+5, "rol.x"
>b24d		c4 62 62 72 33				oc3f:	.text 3*64+4, "bbr3"
>b252		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b256		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b25e		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b264		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b26a		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b271		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b275		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b27b		45 6c 73 72 2e 61			oc4a:	.text 1*64+5, "lsr.a"
>b281		c3 6a 6d 70				oc4c:	.text 3*64+3, "jmp"
>b285		c3 65 6f 72				oc4d:	.text 3*64+3, "eor"
>b289		c3 6c 73 72				oc4e:	.text 3*64+3, "lsr"
>b28d		c4 62 62 72 34				oc4f:	.text 3*64+4, "bbr4"
>b292		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b296		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b29e		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b2a5		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b2ac		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b2b3		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b2ba		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b2be		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b2c4		43 70 68 79				oc5a:	.text 1*64+3, "phy"
>b2c8		c5 65 6f 72 2e 78			oc5d:	.text 3*64+5, "eor.x"
>b2ce		c5 6c 73 72 2e 78			oc5e:	.text 3*64+5, "lsr.x"
>b2d4		c4 62 62 72 35				oc5f:	.text 3*64+4, "bbr5"
>b2d9		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b2dd		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b2e5		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b2eb		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b2f1		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b2f7		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b2fe		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b302		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b308		45 72 6f 72 2e 61			oc6a:	.text 1*64+5, "ror.a"
>b30e		c5 6a 6d 70 2e 69			oc6c:	.text 3*64+5, "jmp.i"
>b314		c3 61 64 63				oc6d:	.text 3*64+3, "adc"
>b318		c3 72 6f 72				oc6e:	.text 3*64+3, "ror"
>b31c		c4 62 62 72 36				oc6f:	.text 3*64+4, "bbr6"
>b321		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b325		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b32d		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b334		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b33b		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b342		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b349		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b350		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b354		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b35a		43 70 6c 79				oc7a:	.text 1*64+3, "ply"
>b35e		c6 6a 6d 70 2e 78 69			oc7c:	.text 3*64+6, "jmp.xi"
>b365		c5 61 64 63 2e 78			oc7d:	.text 3*64+5, "adc.x"
>b36b		c5 72 6f 72 2e 78			oc7e:	.text 3*64+5, "ror.x"
>b371		c4 62 62 72 37				oc7f:	.text 3*64+4, "bbr7"
>b376		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b37a		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b382		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b388		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b38e		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b394		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b398		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b39e		43 74 78 61				oc8a:	.text 1*64+3, "txa"
>b3a2		c3 73 74 79				oc8c:	.text 3*64+3, "sty"
>b3a6		c3 73 74 61				oc8d:	.text 3*64+3, "sta"
>b3aa		c3 73 74 78				oc8e:	.text 3*64+3, "stx"
>b3ae		c4 62 62 73 30				oc8f:	.text 3*64+4, "bbs0"
>b3b3		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b3b7		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b3bf		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b3c6		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b3cd		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b3d4		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b3db		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b3e2		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b3e6		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b3ec		43 74 78 73				oc9a:	.text 1*64+3, "txs"
>b3f0		c3 73 74 7a				oc9c:	.text 3*64+3, "stz"
>b3f4		c5 73 74 61 2e 78			oc9d:	.text 3*64+5, "sta.x"
>b3fa		c5 73 74 7a 2e 78			oc9e:	.text 3*64+5, "stz.x"
>b400		c4 62 62 73 31				oc9f:	.text 3*64+4, "bbs1"
>b405		85 6c 64 79 2e 23			oca0:	.text 2*64+5, "ldy.#"
>b40b		87 6c 64 61 2e 7a 78 69			oca1:	.text 2*64+7, "lda.zxi"
>b413		85 6c 64 78 2e 23			oca2:	.text 2*64+5, "ldx.#"
>b419		85 6c 64 79 2e 7a			oca4:	.text 2*64+5, "ldy.z"
>b41f		85 6c 64 61 2e 7a			oca5:	.text 2*64+5, "lda.z"
>b425		85 6c 64 78 2e 7a			oca6:	.text 2*64+5, "ldx.z"
>b42b		86 73 6d 62 32 2e 7a			oca7:	.text 2*64+6, "smb2.z"
>b432		43 74 61 79				oca8:	.text 1*64+3, "tay"
>b436		85 6c 64 61 2e 23			oca9:	.text 2*64+5, "lda.#"
>b43c		43 74 61 78				ocaa:	.text 1*64+3, "tax"
>b440		c3 6c 64 79				ocac:	.text 3*64+3, "ldy"
>b444		c3 6c 64 61				ocad:	.text 3*64+3, "lda"
>b448		c3 6c 64 78				ocae:	.text 3*64+3, "ldx"
>b44c		c4 62 62 73 32				ocaf:	.text 3*64+4, "bbs2"
>b451		83 62 63 73				ocb0:	.text 2*64+3, "bcs"
>b455		87 6c 64 61 2e 7a 69 79			ocb1:	.text 2*64+7, "lda.ziy"
>b45d		86 6c 64 61 2e 7a 69			ocb2:	.text 2*64+6, "lda.zi"
>b464		86 6c 64 79 2e 7a 78			ocb4:	.text 2*64+6, "ldy.zx"
>b46b		86 6c 64 61 2e 7a 78			ocb5:	.text 2*64+6, "lda.zx"
>b472		86 6c 64 78 2e 7a 79			ocb6:	.text 2*64+6, "ldx.zy"
>b479		86 73 6d 62 33 2e 7a			ocb7:	.text 2*64+6, "smb3.z"
>b480		43 63 6c 76				ocb8:	.text 1*64+3, "clv"
>b484		c5 6c 64 61 2e 79			ocb9:	.text 3*64+5, "lda.y"
>b48a		43 74 73 78				ocba:	.text 1*64+3, "tsx"
>b48e		c5 6c 64 79 2e 78			ocbc:	.text 3*64+5, "ldy.x"
>b494		c5 6c 64 61 2e 78			ocbd:	.text 3*64+5, "lda.x"
>b49a		c5 6c 64 78 2e 79			ocbe:	.text 3*64+5, "ldx.y"
>b4a0		c4 62 62 73 34				ocbf:	.text 3*64+4, "bbs4"
>b4a5		85 63 70 79 2e 23			occ0:	.text 2*64+5, "cpy.#"
>b4ab		87 63 6d 70 2e 7a 78 69			occ1:	.text 2*64+7, "cmp.zxi"
>b4b3		85 63 70 79 2e 7a			occ4:	.text 2*64+5, "cpy.z"
>b4b9		85 63 6d 70 2e 7a			occ5:	.text 2*64+5, "cmp.z"
>b4bf		85 64 65 63 2e 7a			occ6:	.text 2*64+5, "dec.z"
>b4c5		86 73 6d 62 34 2e 7a			occ7:	.text 2*64+6, "smb4.z"
>b4cc		43 69 6e 79				occ8:	.text 1*64+3, "iny"
>b4d0		85 63 6d 70 2e 23			occ9:	.text 2*64+5, "cmp.#"
>b4d6		43 64 65 78				occa:	.text 1*64+3, "dex"
>b4da		c3 63 70 79				occc:	.text 3*64+3, "cpy"
>b4de		c3 63 6d 70				occd:	.text 3*64+3, "cmp"
>b4e2		c3 64 65 63				occe:	.text 3*64+3, "dec"
>b4e6		c4 62 62 73 34				occf:	.text 3*64+4, "bbs4"
>b4eb		83 62 6e 65				ocd0:	.text 2*64+3, "bne"
>b4ef		87 63 6d 70 2e 7a 69 79			ocd1:	.text 2*64+7, "cmp.ziy"
>b4f7		86 63 6d 70 2e 7a 69			ocd2:	.text 2*64+6, "cmp.zi"
>b4fe		86 63 6d 70 2e 7a 78			ocd5:	.text 2*64+6, "cmp.zx"
>b505		86 64 65 63 2e 7a 78			ocd6:	.text 2*64+6, "dec.zx"
>b50c		86 73 6d 62 35 2e 7a			ocd7:	.text 2*64+6, "smb5.z"
>b513		43 63 6c 64				ocd8:	.text 1*64+3, "cld"
>b517		c5 63 6d 70 2e 79			ocd9:	.text 3*64+5, "cmp.y"
>b51d		43 70 68 78				ocda:	.text 1*64+3, "phx"
>b521		c5 63 6d 70 2e 78			ocdd:	.text 3*64+5, "cmp.x"
>b527		c5 64 65 63 2e 78			ocde:	.text 3*64+5, "dec.x"
>b52d		c4 62 62 73 35				ocdf:	.text 3*64+4, "bbs5"
>b532		85 63 70 78 2e 23			oce0:	.text 2*64+5, "cpx.#"
>b538		87 73 62 63 2e 7a 78 69			oce1:	.text 2*64+7, "sbc.zxi"
>b540		85 63 70 78 2e 7a			oce4:	.text 2*64+5, "cpx.z"
>b546		85 73 62 63 2e 7a			oce5:	.text 2*64+5, "sbc.z"
>b54c		85 69 6e 63 2e 7a			oce6:	.text 2*64+5, "inc.z"
>b552		86 73 6d 62 36 2e 7a			oce7:	.text 2*64+6, "smb6.z"
>b559		43 69 6e 78				oce8:	.text 1*64+3, "inx"
>b55d		85 73 62 63 2e 23			oce9:	.text 2*64+5, "sbc.#"
>b563		43 6e 6f 70				ocea:	.text 1*64+3, "nop"
>b567		c3 63 70 78				ocec:	.text 3*64+3, "cpx"
>b56b		c3 73 62 63				oced:	.text 3*64+3, "sbc"
>b56f		c3 69 6e 63				ocee:	.text 3*64+3, "inc"
>b573		c4 62 62 73 36				ocef:	.text 3*64+4, "bbs6"
>b578		83 62 65 71				ocf0:	.text 2*64+3, "beq"
>b57c		87 73 62 63 2e 7a 69 79			ocf1:	.text 2*64+7, "sbc.ziy"
>b584		86 73 62 63 2e 7a 69			ocf2:	.text 2*64+6, "sbc.zi"
>b58b		86 73 62 63 2e 7a 78			ocf5:	.text 2*64+6, "sbc.zx"
>b592		86 69 6e 63 2e 7a 78			ocf6:	.text 2*64+6, "inc.zx"
>b599		86 73 6d 62 37 2e 7a			ocf7:	.text 2*64+6, "smb7.z"
>b5a0		43 73 65 64				ocf8:	.text 1*64+3, "sed"
>b5a4		c5 73 62 63 2e 79			ocf9:	.text 3*64+5, "sbc.y"
>b5aa		43 70 6c 78				ocfa:	.text 1*64+3, "plx"
>b5ae		c5 73 62 63 2e 78			ocfd:	.text 3*64+5, "sbc.x"
>b5b4		c5 69 6e 63 2e 78			ocfe:	.text 3*64+5, "inc.x"
>b5ba		c4 62 62 73 37				ocff:	.text 3*64+4, "bbs7"
>b5bf		01 3f					oc__:	.text 1, "?"
.b5c1						disassembler_end:

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../ed.asm

=$002e						ed_head  = editor1  ; pointer to first list element (addr) (2 bytes)
=$0030						ed_cur   = editor2  ; current line number (1 is first line) (2 bytes)
=$0032						ed_flags = editor3  ; Flags used by ed, where
.b5c1						ed6502:
.b5c1		a5 18		lda $18		                lda base
.b5c3		85 33		sta $33		                sta editor3+1
.b5c5		a9 0a		lda #$0a	                lda #10
.b5c7		85 18		sta $18		                sta base
.b5c9		64 2e		stz $2e		                stz ed_head
.b5cb		64 2f		stz $2f		                stz ed_head+1
.b5cd		64 30		stz $30		                stz ed_cur
.b5cf		64 31		stz $31		                stz ed_cur+1
.b5d1		64 32		stz $32		                stz ed_flags
.b5d3		20 56 a7	jsr $a756	                jsr xt_zero
.b5d6		20 56 a7	jsr $a756	                jsr xt_zero             ; ( addr-t u-t )
.b5d9		20 2a 89	jsr $892a	                jsr xt_cr
.b5dc						ed_input_loop:
.b5dc		a9 81		lda #$81	                lda #%10000001
.b5de		14 32		trb $32		                trb ed_flags
.b5e0		20 bb ba	jsr $babb	                jsr ed_get_input
.b5e3		a5 0a		lda $0a		                lda ciblen
.b5e5		d0 1f		bne $b606	                bne _command_mode
.b5e7		ca		dex		                dex
.b5e8		ca		dex		                dex                     ; ( addr-t u-t ? )
.b5e9		a5 30		lda $30		                lda ed_cur
.b5eb		95 00		sta $00,x	                sta 0,x
.b5ed		a5 31		lda $31		                lda ed_cur+1
.b5ef		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.b5f1		a9 80		lda #$80	                lda #%10000000
.b5f3		04 32		tsb $32		                tsb ed_flags
.b5f5		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( addr-t u-t u+1 )
.b5f8		20 d7 ba	jsr $bad7	                jsr ed_is_valid_line
.b5fb		b0 03		bcs $b600	                bcs +
.b5fd		4c ab ba	jmp $baab	                jmp ed_error_1drop
.b600						+
.b600		20 56 a7	jsr $a756	                jsr xt_zero             ; ( addr-t u-t u+1 0 )
.b603		4c d1 b6	jmp $b6d1	                jmp _line_number_only_from_external
.b606						_command_mode:
.b606		20 56 a7	jsr $a756	                jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.b609		20 56 a7	jsr $a756	                jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.b60c						_prefix_dot:
.b60c		b2 08		lda ($08)	                lda (cib)
.b60e		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII '.'
.b610		d0 3a		bne $b64c	                bne _prefix_dollar
.b612		20 cc ba	jsr $bacc	                jsr ed_have_text
.b615		a5 30		lda $30		                lda ed_cur
.b617		95 02		sta $02,x	                sta 2,x
.b619		a5 31		lda $31		                lda ed_cur+1
.b61b		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b61d		a9 80		lda #$80	                lda #%10000000
.b61f		04 32		tsb $32		                tsb ed_flags
.b621		a5 0a		lda $0a		                lda ciblen
.b623		3a		dec a		                dea                     ; sets Z if A was 1
.b624		d0 03		bne $b629	                bne +
.b626		4c d1 b6	jmp $b6d1	                jmp _line_number_only_from_external
.b629						+
.b629		ca		dex		                dex
.b62a		ca		dex		                dex
.b62b		ca		dex		                dex
.b62c		ca		dex		                dex
.b62d		a5 08		lda $08		                lda cib
.b62f		95 02		sta $02,x	                sta 2,x
.b631		a5 09		lda $09		                lda cib+1
.b633		95 03		sta $03,x	                sta 3,x
.b635		a5 0a		lda $0a		                lda ciblen
.b637		95 00		sta $00,x	                sta 0,x
.b639		a5 0b		lda $0b		                lda ciblen+1
.b63b		95 01		sta $01,x	                sta 1,x
.b63d		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.b640		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
.b643		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.b646		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.b649		4c 29 b7	jmp $b729	                jmp _check_for_para2
.b64c						_prefix_dollar:
.b64c		b2 08		lda ($08)	                lda (cib)
.b64e		c9 24		cmp #$24	                cmp #'$'
.b650		d0 1c		bne $b66e	                bne _prefix_percent
.b652		20 cc ba	jsr $bacc	                jsr ed_have_text
.b655		e8		inx		                inx
.b656		e8		inx		                inx                     ; ( addr-t u-t 0 )
.b657		20 f9 ba	jsr $baf9	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.b65a		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
.b65d		a9 80		lda #$80	                lda #%10000000
.b65f		04 32		tsb $32		                tsb ed_flags
.b661		a5 0a		lda $0a		                lda ciblen
.b663		3a		dec a		                dea                     ; sets Z if A was 1
.b664		d0 03		bne $b669	                bne +
.b666		4c d1 b6	jmp $b6d1	                jmp _line_number_only_from_external
.b669						+
.b669		a0 01		ldy #$01	                ldy #01
.b66b		4c a5 b7	jmp $b7a5	                jmp _check_command
.b66e						_prefix_percent:
.b66e		b2 08		lda ($08)	                lda (cib)
.b670		c9 25		cmp #$25	                cmp #$25                ; ASCII '%'
.b672		f0 04		beq $b678	                beq _whole_text
.b674		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII ','
.b676		d0 17		bne $b68f	                bne _prefix_semicolon
.b678						_whole_text:
.b678		20 cc ba	jsr $bacc	                jsr ed_have_text
.b67b		a9 01		lda #$01	                lda #01
.b67d		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.b67f		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.b681						_semicolon_entry:
.b681		e8		inx		                inx
.b682		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.b683		20 f9 ba	jsr $baf9	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b686		a9 80		lda #$80	                lda #%10000000
.b688		04 32		tsb $32		                tsb ed_flags
.b68a		a0 01		ldy #$01	                ldy #01
.b68c		4c a5 b7	jmp $b7a5	                jmp _check_command
.b68f						_prefix_semicolon:
.b68f		b2 08		lda ($08)	                lda (cib)
.b691		c9 3b		cmp #$3b	                cmp #$3b                ; ASCII ';'
.b693		d0 0d		bne $b6a2	                bne _prefix_number
.b695		20 cc ba	jsr $bacc	                jsr ed_have_text
.b698		a5 30		lda $30		                lda ed_cur
.b69a		95 02		sta $02,x	                sta 2,x
.b69c		a5 31		lda $31		                lda ed_cur+1
.b69e		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.b6a0		80 df		bra $b681	                bra _semicolon_entry
.b6a2						_prefix_number:
.b6a2		20 56 a7	jsr $a756	                jsr xt_zero
.b6a5		20 56 a7	jsr $a756	                jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
.b6a8		ca		dex		                dex
.b6a9		ca		dex		                dex
.b6aa		ca		dex		                dex
.b6ab		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.b6ac		a5 08		lda $08		                lda cib
.b6ae		95 02		sta $02,x	                sta 2,x
.b6b0		a5 09		lda $09		                lda cib+1
.b6b2		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.b6b4		a5 0a		lda $0a		                lda ciblen
.b6b6		95 00		sta $00,x	                sta 0,x
.b6b8		a5 0b		lda $0b		                lda ciblen+1
.b6ba		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.b6bc		20 61 a2	jsr $a261	                jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.b6bf		b5 00		lda $00,x	                lda 0,x
.b6c1		15 01		ora $01,x	                ora 1,x
.b6c3		d0 24		bne $b6e9	                bne _have_unconverted_chars
.b6c5		e8		inx		                inx
.b6c6		e8		inx		                inx
.b6c7		e8		inx		                inx
.b6c8		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.b6c9		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.b6cc		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
.b6cf		e8		inx		                inx
.b6d0		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.b6d1						_line_number_only_from_external:
.b6d1		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-t u-t 0 u )
.b6d4		20 d7 ba	jsr $bad7	                jsr ed_is_valid_line
.b6d7		b0 03		bcs $b6dc	                bcs +
.b6d9		4c a9 ba	jmp $baa9	                jmp ed_error_2drop
.b6dc						+
.b6dc		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-t u-t u 0 )
.b6df		20 66 bb	jsr $bb66	                jsr ed_para1_to_cur
.b6e2		a9 80		lda #$80	                lda #%10000000
.b6e4		04 32		tsb $32		                tsb ed_flags
.b6e6		4c 84 b9	jmp $b984	                jmp ed_cmd_p_from_external
.b6e9						_have_unconverted_chars:
.b6e9		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.b6ec		ca		dex		                dex
.b6ed		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.b6ee		a5 0a		lda $0a		                lda ciblen
.b6f0		95 00		sta $00,x	                sta 0,x
.b6f2		a5 0b		lda $0b		                lda ciblen+1
.b6f4		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.b6f6		20 b3 8e	jsr $8eb3	                jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.b6f9		b5 00		lda $00,x	                lda 0,x
.b6fb		15 01		ora $01,x	                ora 1,x
.b6fd		f0 0e		beq $b70d	                beq _no_command_yet
.b6ff		8a		txa		                txa
.b700		18		clc		                clc
.b701		69 0a		adc #$0a	                adc #10
.b703		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.b704		a9 80		lda #$80	                lda #%10000000
.b706		14 32		trb $32		                trb ed_flags
.b708		a0 00		ldy #$00	                ldy #00
.b70a		4c a5 b7	jmp $b7a5	                jmp _check_command
.b70d						_no_command_yet:
.b70d		e8		inx		                inx
.b70e		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.b70f		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.b712		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.b715		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.b718		b5 00		lda $00,x	                lda 0,x                 ; LSB
.b71a		95 06		sta $06,x	                sta 6,x
.b71c		b5 01		lda $01,x	                lda 1,x                 ; MSB
.b71e		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.b720		e8		inx		                inx
.b721		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.b722		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.b725		a9 80		lda #$80	                lda #%10000000
.b727		04 32		tsb $32		                tsb ed_flags
.b729						_check_for_para2:
.b729		a1 02		lda ($02,x)	                lda (2,x)
.b72b		c9 2c		cmp #$2c	                cmp #$2c                ; ASCII code for ',' (comma)
.b72d		f0 0d		beq $b73c	                beq _got_comma
.b72f		38		sec		                sec
.b730		a5 0a		lda $0a		                lda ciblen
.b732		f5 00		sbc $00,x	                sbc 0,x
.b734		a8		tay		                tay
.b735		e8		inx		                inx
.b736		e8		inx		                inx
.b737		e8		inx		                inx
.b738		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.b739		4c a5 b7	jmp $b7a5	                jmp _check_command
.b73c						_got_comma:
.b73c		f6 02		inc $02,x	                inc 2,x
.b73e		d0 02		bne $b742	                bne +
.b740		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.b742						+
.b742		b5 01		lda $01,x	                lda 1,x
.b744		f0 02		beq $b748	                beq +
.b746		d6 01		dec $01,x	                dec 1,x
.b748						+
.b748		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.b74a		a1 02		lda ($02,x)	                lda (2,x)
.b74c		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.b74e		d0 14		bne $b764	                bne _para2_not_dollar
.b750		38		sec		                sec
.b751		a5 0a		lda $0a		                lda ciblen
.b753		f5 02		sbc $02,x	                sbc 2,x
.b755		a8		tay		                tay
.b756		c8		iny		                iny
.b757		5a		phy		                phy
.b758		8a		txa		                txa
.b759		18		clc		                clc
.b75a		69 06		adc #$06	                adc #06
.b75c		aa		tax		                tax                     ; ( addr-t u-t para1 )
.b75d		20 f9 ba	jsr $baf9	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.b760		7a		ply		                ply
.b761		4c a5 b7	jmp $b7a5	                jmp _check_command
.b764						_para2_not_dollar:
.b764		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.b767		20 56 a7	jsr $a756	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.b76a		20 56 a7	jsr $a756	                jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.b76d		20 34 9b	jsr $9b34	                jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.b770		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.b773		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.b776		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.b779		20 61 a2	jsr $a261	                jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.b77c		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.b77f		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.b782		20 b3 8e	jsr $8eb3	                jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
.b785		b5 00		lda $00,x	                lda 0,x
.b787		15 01		ora $01,x	                ora 1,x
.b789		f0 08		beq $b793	                beq _second_number
.b78b		8a		txa		                txa
.b78c		18		clc		                clc
.b78d		69 0c		adc #$0c	                adc #12
.b78f		aa		tax		                tax                     ; back to ( addr-t u-t )
.b790		4c ad ba	jmp $baad	                jmp ed_error
.b793						_second_number:
.b793		e8		inx		                inx
.b794		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.b795		38		sec		                sec
.b796		a5 0a		lda $0a		                lda ciblen
.b798		f5 00		sbc $00,x	                sbc 0,x
.b79a		48		pha		                pha
.b79b		20 54 a3	jsr $a354	                jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.b79e		20 47 8a	jsr $8a47	                jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.b7a1		20 26 96	jsr $9626	                jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
.b7a4		7a		ply		                ply
.b7a5						_check_command:
.b7a5		24 32		bit $32		                bit ed_flags
.b7a7		30 08		bmi $b7b1	                bmi _check_command_have_arg
.b7a9		a5 30		lda $30		                lda ed_cur
.b7ab		95 02		sta $02,x	                sta 2,x
.b7ad		a5 31		lda $31		                lda ed_cur+1
.b7af		95 03		sta $03,x	                sta 3,x
.b7b1						_check_command_have_arg:
.b7b1		b1 08		lda ($08),y	                lda (cib),y             ; get mystery char from input
.b7b3		85 24		sta $24		                sta tmp1
.b7b5		da		phx		                phx
.b7b6		a2 00		ldx #$00	                ldx #00
.b7b8						_cmd_loop:
.b7b8		bd 91 bb	lda $bb91,x	                lda ed_cmd_list,x
.b7bb		f0 07		beq $b7c4	                beq _illegal_command    ; zero marks end of list
.b7bd		c5 24		cmp $24		                cmp tmp1
.b7bf		f0 07		beq $b7c8	                beq _found_cmd
.b7c1		e8		inx		                inx
.b7c2		80 f4		bra $b7b8	                bra _cmd_loop
.b7c4						_illegal_command:
.b7c4		fa		plx		                plx
.b7c5		4c a9 ba	jmp $baa9	                jmp ed_error_2drop
.b7c8						_found_cmd:
.b7c8		8a		txa		                txa
.b7c9		0a		asl a		                asl
.b7ca		aa		tax		                tax                     ; X * 2 for table
.b7cb		7c 9c bb	jmp ($bb9c,x)	                jmp (ed_cmd_table,x)
.b7ce						ed_next_command:
.b7ce		e8		inx		                inx
.b7cf		e8		inx		                inx
.b7d0		e8		inx		                inx
.b7d1		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.b7d2						_next_command_empty:
.b7d2		4c dc b5	jmp $b5dc	                jmp ed_input_loop
.b7d5						ed_all_done:
.b7d5		64 0a		stz $0a		                stz ciblen
.b7d7		64 0b		stz $0b		                stz ciblen+1
.b7d9		20 54 a3	jsr $a354	                jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
.b7dc		a5 33		lda $33		                lda editor3+1
.b7de		85 18		sta $18		                sta base
.b7e0		60		rts		                rts
.b7e1						ed_cmd_a:
.b7e1		fa		plx		                plx
.b7e2		e8		inx		                inx
.b7e3		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b7e4						ed_entry_cmd_i:
.b7e4						ed_cmd_a_have_para:
.b7e4		20 2f bb	jsr $bb2f	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.b7e7		20 2a 89	jsr $892a	                jsr xt_cr
.b7ea						_next_string_loop:
.b7ea		20 bb ba	jsr $babb	                jsr ed_get_input
.b7ed		b2 08		lda ($08)	                lda (cib)
.b7ef		c9 2e		cmp #$2e	                cmp #$2e                ; ASCII for '.'
.b7f1		d0 16		bne $b809	                bne _add_line
.b7f3		a4 0a		ldy $0a		                ldy ciblen
.b7f5		c0 01		cpy #$01	                cpy #01
.b7f7		d0 10		bne $b809	                bne _add_line
.b7f9		a4 0b		ldy $0b		                ldy ciblen+1
.b7fb		d0 0c		bne $b809	                bne _add_line
.b7fd		e8		inx		                inx
.b7fe		e8		inx		                inx
.b7ff		a9 40		lda #$40	                lda #%01000000
.b801		04 32		tsb $32		                tsb ed_flags
.b803		20 2a 89	jsr $892a	                jsr xt_cr
.b806		4c dc b5	jmp $b5dc	                jmp ed_input_loop
.b809						_add_line:
.b809		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
.b80c		20 57 91	jsr $9157	                jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
.b80f		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.b812		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.b815		20 24 87	jsr $8724	                jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
.b818		20 31 a3	jsr $a331	                jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
.b81b		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
.b81e		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-t u-t here )
.b821		20 57 91	jsr $9157	                jsr xt_here             ; HERE ( addr-t u-t here here2)
.b824		a5 00		lda $00		                lda cp
.b826		18		clc		                clc
.b827		69 04		adc #$04	                adc #04
.b829		85 00		sta $00		                sta cp
.b82b		90 02		bcc $b82f	                bcc +
.b82d		e6 01		inc $01		                inc cp+1
.b82f						+
.b82f		e6 30		inc $30		                inc ed_cur
.b831		d0 02		bne $b835	                bne +
.b833		e6 31		inc $31		                inc ed_cur+1
.b835						+
.b835		20 57 91	jsr $9157	                jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
.b838		20 62 8d	jsr $8d62	                jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.b83b		ca		dex		                dex
.b83c		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.b83d		a5 08		lda $08		                lda cib
.b83f		95 00		sta $00,x	                sta 0,x
.b841		a5 09		lda $09		                lda cib+1
.b843		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.b845		20 5c a1	jsr $a15c	                jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.b848		ca		dex		                dex
.b849		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.b84a		a5 0a		lda $0a		                lda ciblen
.b84c		95 00		sta $00,x	                sta 0,x
.b84e		a5 0b		lda $0b		                lda ciblen+1
.b850		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.b852		20 a6 95	jsr $95a6	                jsr xt_move     ; ( addr-t u-t here here2 here3 )
.b855		18		clc		                clc
.b856		a5 00		lda $00		                lda cp
.b858		65 0a		adc $0a		                adc ciblen
.b85a		85 00		sta $00		                sta cp
.b85c		90 06		bcc $b864	                bcc +
.b85e		a5 01		lda $01		                lda cp+1
.b860		65 0b		adc $0b		                adc ciblen+1
.b862		85 01		sta $01		                sta cp+1
.b864						+
.b864		20 77 98	jsr $9877	                jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.b867		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-t u-t here here2 )
.b86a		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+
.b86d		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.b870		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.b873		a5 0a		lda $0a		                lda ciblen
.b875		95 02		sta $02,x	                sta 2,x
.b877		a5 0b		lda $0b		                lda ciblen+1
.b879		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.b87b		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-t u-t here )
.b87e		20 2a 89	jsr $892a	                jsr xt_cr
.b881		4c ea b7	jmp $b7ea	                jmp _next_string_loop
.b884						ed_cmd_d:
.b884		fa		plx		                plx
.b885		20 cc ba	jsr $bacc	                jsr ed_have_text
.b888		20 21 bb	jsr $bb21	                jsr ed_no_line_zero
.b88b		b5 00		lda $00,x	                lda 0,x
.b88d		15 01		ora $01,x	                ora 1,x
.b88f		d0 08		bne $b899	                bne +
.b891		20 77 98	jsr $9877	                jsr xt_over             ; ( addr-t u-t para1 0 para1 )
.b894		20 d6 b8	jsr $b8d6	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.b897		80 33		bra $b8cc	                bra _cmd_d_done
.b899						+
.b899		20 d7 ba	jsr $bad7	                jsr ed_is_valid_line      ; result is in C flag
.b89c		b0 03		bcs $b8a1	                bcs _cmd_d_loop
.b89e		4c a9 ba	jmp $baa9	                jmp ed_error_2drop
.b8a1						_cmd_d_loop:
.b8a1		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b8a4		20 42 91	jsr $9142	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b8a7		b5 00		lda $00,x	                lda 0,x
.b8a9		15 01		ora $01,x	                ora 1,x
.b8ab		d0 0d		bne $b8ba	                bne _cmd_d_done_with_flag
.b8ad		e8		inx		                inx
.b8ae		e8		inx		                inx                     ; Get rid of the flag from >
.b8af		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.b8b2		20 d6 b8	jsr $b8d6	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.b8b5		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.b8b8		80 e7		bra $b8a1	                bra _cmd_d_loop
.b8ba						_cmd_d_done_with_flag:
.b8ba		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.b8bb		e8		inx		                inx
.b8bc		b5 02		lda $02,x	                lda 2,x
.b8be		d0 02		bne $b8c2	                bne +
.b8c0		d6 03		dec $03,x	                dec 3,x
.b8c2						+
.b8c2		d6 02		dec $02,x	                dec 2,x
.b8c4		b5 02		lda $02,x	                lda 2,x
.b8c6		85 30		sta $30		                sta ed_cur
.b8c8		b5 03		lda $03,x	                lda 3,x
.b8ca		85 31		sta $31		                sta ed_cur+1            ; drop through to _cmd_d_done
.b8cc						_cmd_d_done:
.b8cc		a9 40		lda #$40	                lda #%01000000
.b8ce		04 32		tsb $32		                tsb ed_flags
.b8d0		20 2a 89	jsr $892a	                jsr xt_cr
.b8d3		4c ce b7	jmp $b7ce	                jmp ed_next_command
.b8d6						_cmd_d_common:
.b8d6		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t u u )
.b8d9		20 2f bb	jsr $bb2f	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.b8dc		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
.b8df		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
.b8e2		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.b8e5		20 2f bb	jsr $bb2f	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.b8e8		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-t u-t )
.b8eb		60		rts		                rts
.b8ec						ed_cmd_equ:
.b8ec		fa		plx		                plx
.b8ed		a5 2e		lda $2e		                lda ed_head
.b8ef		05 2f		ora $2f		                ora ed_head+1
.b8f1		d0 08		bne $b8fb	                bne _cmd_equ_have_text
.b8f3		ca		dex		                dex
.b8f4		ca		dex		                dex
.b8f5		74 00		stz $00,x	                stz 0,x
.b8f7		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.b8f9		80 21		bra $b91c	                bra _cmd_equ_done
.b8fb						_cmd_equ_have_text:
.b8fb		20 21 bb	jsr $bb21	                jsr ed_no_line_zero
.b8fe		24 32		bit $32		                bit ed_flags
.b900		30 0c		bmi $b90e	                bmi _cmd_equ_have_para
.b902		ca		dex		                dex
.b903		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.b904		a5 30		lda $30		                lda ed_cur
.b906		95 00		sta $00,x	                sta 0,x
.b908		a5 31		lda $31		                lda ed_cur+1
.b90a		95 01		sta $01,x	                sta 1,x
.b90c		80 0e		bra $b91c	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.b90e						_cmd_equ_have_para:
.b90e		b5 00		lda $00,x	                lda 0,x
.b910		15 01		ora $01,x	                ora 1,x
.b912		d0 05		bne $b919	                bne _cmd_equ_two_paras
.b914		20 77 98	jsr $9877	                jsr xt_over             ; ( addr-t u-t para1 para2 para1)
.b917		80 03		bra $b91c	                bra _cmd_equ_done
.b919						_cmd_equ_two_paras:
.b919		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
.b91c						_cmd_equ_done:
.b91c		20 2a 89	jsr $892a	                jsr xt_cr               ; number goes on new line
.b91f		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
.b922		20 2a 89	jsr $892a	                jsr xt_cr
.b925		4c ce b7	jmp $b7ce	                jmp ed_next_command
.b928						ed_cmd_f:
.b928		fa		plx		                plx
.b929		24 32		bit $32		                bit ed_flags
.b92b		30 17		bmi $b944	                bmi _cmd_f_have_para
.b92d		20 2a 89	jsr $892a	                jsr xt_cr
.b930		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.b933		20 34 9b	jsr $9b34	                jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.b936		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.b939		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.b93c		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.b93f		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
.b942		80 11		bra $b955	                bra _cmd_f_done
.b944						_cmd_f_have_para:
.b944		20 77 98	jsr $9877	                jsr xt_over
.b947		20 2a 89	jsr $892a	                jsr xt_cr
.b94a		20 d2 a4	jsr $a4d2	                jsr xt_u_dot
.b94d		b5 02		lda $02,x	                lda 2,x
.b94f		95 06		sta $06,x	                sta 6,x
.b951		b5 03		lda $03,x	                lda 3,x
.b953		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.b955						_cmd_f_done:
.b955		20 2a 89	jsr $892a	                jsr xt_cr
.b958		4c ce b7	jmp $b7ce	                jmp ed_next_command
.b95b						ed_cmd_i:
.b95b		fa		plx		                plx
.b95c		e8		inx		                inx
.b95d		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.b95e		24 32		bit $32		                bit ed_flags
.b960		30 08		bmi $b96a	                bmi _cmd_i_have_para
.b962		a5 30		lda $30		                lda ed_cur
.b964		95 00		sta $00,x	                sta 0,x
.b966		a5 31		lda $31		                lda ed_cur+1
.b968		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.b96a						_cmd_i_have_para:
.b96a		b5 00		lda $00,x	                lda 0,x
.b96c		15 01		ora $01,x	                ora 1,x
.b96e		f0 09		beq $b979	                beq _cmd_i_done
.b970		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
.b973		20 56 a7	jsr $a756	                jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
.b976		20 fc 94	jsr $94fc	                jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
.b979						_cmd_i_done:
.b979		4c e4 b7	jmp $b7e4	                jmp ed_entry_cmd_i
.b97c						ed_cmd_n:
.b97c		fa		plx		                plx
.b97d		a9 01		lda #$01	                lda #%00000001
.b97f		04 32		tsb $32		                tsb ed_flags
.b981		80 05		bra $b988	                bra ed_cmd_p_entry_for_cmd_n
.b983						ed_cmd_p:
.b983		fa		plx		                plx
.b984						ed_cmd_p_from_external:
.b984		a9 01		lda #$01	                lda #%00000001
.b986		14 32		trb $32		                trb ed_flags
.b988						ed_cmd_p_entry_for_cmd_n:
.b988		20 cc ba	jsr $bacc	                jsr ed_have_text
.b98b		20 21 bb	jsr $bb21	                jsr ed_no_line_zero
.b98e		20 2a 89	jsr $892a	                jsr xt_cr
.b991		b5 00		lda $00,x	                lda 0,x
.b993		15 01		ora $01,x	                ora 1,x
.b995		d0 10		bne $b9a7	                bne _cmd_p_loop
.b997		b5 02		lda $02,x	                lda 2,x
.b999		85 30		sta $30		                sta ed_cur
.b99b		b5 03		lda $03,x	                lda 3,x
.b99d		85 31		sta $31		                sta ed_cur+1
.b99f		20 77 98	jsr $9877	                jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
.b9a2		20 d0 b9	jsr $b9d0	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9a5		80 26		bra $b9cd	                bra _cmd_p_all_done
.b9a7						_cmd_p_loop:
.b9a7		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.b9aa		20 42 91	jsr $9142	                jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
.b9ad		b5 00		lda $00,x	                lda 0,x
.b9af		15 01		ora $01,x	                ora 1,x
.b9b1		d0 10		bne $b9c3	                bne _cmd_p_done
.b9b3		e8		inx		                inx
.b9b4		e8		inx		                inx                     ; Get rid of the flag from >
.b9b5		20 77 98	jsr $9877	                jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
.b9b8		20 d0 b9	jsr $b9d0	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.b9bb		f6 02		inc $02,x	                inc 2,x
.b9bd		d0 02		bne $b9c1	                bne +
.b9bf		f6 03		inc $03,x	                inc 3,x
.b9c1						+
.b9c1		80 e4		bra $b9a7	                bra _cmd_p_loop
.b9c3						_cmd_p_done:
.b9c3		e8		inx		                inx
.b9c4		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.b9c5		b5 00		lda $00,x	                lda 0,x
.b9c7		85 30		sta $30		                sta ed_cur
.b9c9		b5 01		lda $01,x	                lda 1,x
.b9cb		85 31		sta $31		                sta ed_cur+1
.b9cd						_cmd_p_all_done:
.b9cd		4c ce b7	jmp $b7ce	                jmp ed_next_command
.b9d0						_cmd_p_common:
.b9d0		a5 32		lda $32		                lda ed_flags
.b9d2		4a		lsr a		                lsr                     ; bit 0 now in carry
.b9d3		90 0b		bcc $b9e0	                bcc _cmd_p_common_no_num
.b9d5		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
.b9d8		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; U. ( addr-t u-t para1 )
.b9db		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.b9dd		20 db 8d	jsr $8ddb	                jsr emit_a
.b9e0						_cmd_p_common_no_num:
.b9e0		20 2f bb	jsr $bb2f	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.b9e3		20 6f bb	jsr $bb6f	                jsr ed_print_addr
.b9e6		60		rts		                rts
.b9e7						ed_cmd_q:
.b9e7		fa		plx		                plx
.b9e8		24 32		bit $32		                bit ed_flags            ; bit 6 is change flag
.b9ea		50 03		bvc $b9ef	                bvc +
.b9ec		4c a9 ba	jmp $baa9	                jmp ed_error_2drop
.b9ef						+
.b9ef		4c d5 b7	jmp $b7d5	                jmp ed_all_done            ; can't fall thru because of PLX
.b9f2						ed_cmd_qq:
.b9f2		fa		plx		                plx
.b9f3		4c d5 b7	jmp $b7d5	                jmp ed_all_done
.b9f6						ed_cmd_w:
.b9f6		fa		plx		                plx
.b9f7		20 cc ba	jsr $bacc	                jsr ed_have_text
.b9fa		24 32		bit $32		                bit ed_flags
.b9fc		30 13		bmi $ba11	                bmi _cmd_w_have_para
.b9fe		b5 06		lda $06,x	                lda 6,x
.ba00		15 07		ora $07,x	                ora 7,x
.ba02		d0 03		bne $ba07	                bne +
.ba04		4c a9 ba	jmp $baa9	                jmp ed_error_2drop
.ba07						+
.ba07		b5 06		lda $06,x	                lda 6,x
.ba09		95 02		sta $02,x	                sta 2,x
.ba0b		b5 07		lda $07,x	                lda 7,x
.ba0d		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.ba0f		80 08		bra $ba19	                bra _cmd_w_para_ready
.ba11						_cmd_w_have_para:
.ba11		b5 02		lda $02,x	                lda 2,x
.ba13		95 06		sta $06,x	                sta 6,x
.ba15		b5 03		lda $03,x	                lda 3,x
.ba17		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ba19						_cmd_w_para_ready:
.ba19		a9 2e		lda #$2e	                lda #<ed_head
.ba1b		95 00		sta $00,x	                sta 0,x
.ba1d		a9 00		lda #$00	                lda #>ed_head
.ba1f		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ba21		20 77 98	jsr $9877	                jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ba24		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ba27						_cmd_w_loop:
.ba27		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ba2a		b5 00		lda $00,x	                lda 0,x
.ba2c		15 01		ora $01,x	                ora 1,x
.ba2e		f0 55		beq $ba85	                beq _cmd_w_eol
.ba30		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ba33		20 46 a4	jsr $a446	                jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ba36		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.ba39		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.ba3c		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.ba3f		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.ba42		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.ba45		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.ba48		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.ba4b		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.ba4e		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.ba51		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.ba54		20 34 9b	jsr $9b34	                jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.ba57		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.ba5a		20 14 a3	jsr $a314	                jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.ba5d		20 a6 95	jsr $95a6	                jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.ba60		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.ba63		20 cc a3	jsr $a3cc	                jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.ba66		20 52 96	jsr $9652	                jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.ba69		20 c7 99	jsr $99c7	                jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.ba6c		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ba6f		ca		dex		                dex
.ba70		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.ba71		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.ba73		95 00		sta $00,x	                sta 0,x
.ba75		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ba77		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ba7a		20 3b a1	jsr $a13b	                jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ba7d		20 01 98	jsr $9801	                jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ba80		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.ba83		80 a2		bra $ba27	                bra _cmd_w_loop
.ba85						_cmd_w_eol:
.ba85		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ba88		20 76 9a	jsr $9a76	                jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.ba8b		20 34 95	jsr $9534	                jsr xt_minus            ; - ( addr-t u-t addr-n u )
.ba8e		b5 00		lda $00,x	                lda 0,x
.ba90		95 04		sta $04,x	                sta 4,x
.ba92		b5 01		lda $01,x	                lda 1,x
.ba94		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.ba96		20 2a 89	jsr $892a	                jsr xt_cr
.ba99		20 62 8d	jsr $8d62	                jsr xt_dup              ; DUP ( addr-t u addr-n u u )
.ba9c		20 d2 a4	jsr $a4d2	                jsr xt_u_dot            ; U. ( addr-t u addr-n u )
.ba9f		20 2a 89	jsr $892a	                jsr xt_cr
.baa2		a9 40		lda #$40	                lda #%01000000
.baa4		14 32		trb $32		                trb ed_flags
.baa6		4c ce b7	jmp $b7ce	                jmp ed_next_command
.baa9						ed_error_2drop:
.baa9		e8		inx		                inx
.baaa		e8		inx		                inx                     ; drop through to _error_1drop
.baab						ed_error_1drop:
.baab		e8		inx		                inx
.baac		e8		inx		                inx                     ; drop through to _error
.baad						ed_error:
.baad		20 2a 89	jsr $892a	                jsr xt_cr
.bab0		a9 3f		lda #$3f	                lda #'?'
.bab2		20 db 8d	jsr $8ddb	                jsr emit_a
.bab5		20 2a 89	jsr $892a	                jsr xt_cr
.bab8		4c dc b5	jmp $b5dc	                jmp ed_input_loop
.babb						ed_get_input:
.babb		20 dc 9a	jsr $9adc	                jsr xt_refill           ;  ( addr-t u-t f )
.babe		b5 00		lda $00,x	                lda 0,x
.bac0		15 01		ora $01,x	                ora 1,x
.bac2		d0 05		bne $bac9	                bne +
.bac4		7a		ply		                ply
.bac5		7a		ply		                ply
.bac6		4c ab ba	jmp $baab	                jmp ed_error_1drop
.bac9						+
.bac9		e8		inx		                inx
.baca		e8		inx		                inx
.bacb		60		rts		                rts
.bacc						ed_have_text:
.bacc		a5 2e		lda $2e		                lda ed_head
.bace		05 2f		ora $2f		                ora ed_head+1
.bad0		d0 04		bne $bad6	                bne +
.bad2		7a		ply		                ply
.bad3		7a		ply		                ply
.bad4		80 d7		bra $baad	                bra ed_error
.bad6						+
.bad6		60		rts		                rts
.bad7						ed_is_valid_line:
.bad7		38		sec		                sec                             ; default is legal line number
.bad8		b5 00		lda $00,x	                lda 0,x
.bada		15 01		ora $01,x	                ora 1,x
.badc		f0 19		beq $baf7	                beq _is_valid_line_nope_zero    ; ( n )
.bade		20 62 8d	jsr $8d62	                jsr xt_dup                      ; DUP ( n n )
.bae1		20 f9 ba	jsr $baf9	                jsr ed_last_line                  ; ( n n last )
.bae4		20 5c a1	jsr $a15c	                jsr xt_swap                     ; SWAP ( n last n )
.bae7		20 49 93	jsr $9349	                jsr xt_less_than                ; < ( n f )
.baea		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.baec		15 01		ora $01,x	                ora 1,x
.baee		d0 05		bne $baf5	                bne _is_valid_line_too_small
.baf0		e8		inx		                inx
.baf1		e8		inx		                inx                     ; DROP flag ( n )
.baf2		38		sec		                sec                     ; Who knows what's happened to C by now
.baf3		80 03		bra $baf8	                bra _is_valid_line_done ; only one exit from this routine
.baf5						_is_valid_line_too_small:
.baf5		e8		inx		                inx
.baf6		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.baf7						_is_valid_line_nope_zero:
.baf7		18		clc		                clc                     ; drop through to _is_valid_line_done
.baf8						_is_valid_line_done:
.baf8		60		rts		                rts
.baf9						ed_last_line:
.baf9		64 24		stz $24		                stz tmp1
.bafb		64 25		stz $25		                stz tmp1+1
.bafd		ca		dex		                dex
.bafe		ca		dex		                dex                     ; ( ? )
.baff		a9 2e		lda #$2e	                lda #<ed_head
.bb01		95 00		sta $00,x	                sta 0,x
.bb03		a9 00		lda #$00	                lda #>ed_head
.bb05		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.bb07						_last_line_loop:
.bb07		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( addr | 0 )
.bb0a		b5 00		lda $00,x	                lda 0,x
.bb0c		15 01		ora $01,x	                ora 1,x
.bb0e		f0 08		beq $bb18	                beq _last_line_done
.bb10		e6 24		inc $24		                inc tmp1
.bb12		d0 02		bne $bb16	                bne +
.bb14		e6 25		inc $25		                inc tmp1+1
.bb16						+
.bb16		80 ef		bra $bb07	                bra _last_line_loop
.bb18						_last_line_done:
.bb18		a5 24		lda $24		                lda tmp1
.bb1a		95 00		sta $00,x	                sta 0,x
.bb1c		a5 25		lda $25		                lda tmp1+1
.bb1e		95 01		sta $01,x	                sta 1,x                 ; ( u )
.bb20		60		rts		                rts
.bb21						ed_no_line_zero:
.bb21		b5 02		lda $02,x	                lda 2,x
.bb23		15 03		ora $03,x	                ora 3,x
.bb25		d0 07		bne $bb2e	                bne _no_line_zero_done
.bb27		24 32		bit $32		                bit ed_flags
.bb29		10 03		bpl $bb2e	                bpl _no_line_zero_done
.bb2b		4c a9 ba	jmp $baa9	                jmp ed_error_2drop
.bb2e						_no_line_zero_done:
.bb2e		60		rts		                rts
.bb2f						ed_num_to_addr:
.bb2f		ca		dex		                dex
.bb30		ca		dex		                dex                     ; ( u ? )
.bb31		a9 2e		lda #$2e	                lda #<ed_head
.bb33		95 00		sta $00,x	                sta 0,x
.bb35		a9 00		lda #$00	                lda #>ed_head
.bb37		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.bb39		b5 02		lda $02,x	                lda 2,x
.bb3b		15 03		ora $03,x	                ora 3,x
.bb3d		d0 05		bne $bb44	                bne _num_to_addr_loop
.bb3f		20 26 96	jsr $9626	                jsr xt_nip              ; ( addr-h )
.bb42		80 21		bra $bb65	                bra _num_to_addr_done
.bb44						_num_to_addr_loop:
.bb44		20 65 8f	jsr $8f65	                jsr xt_fetch            ; @ ( u addr1 )
.bb47		b5 00		lda $00,x	                lda 0,x
.bb49		15 01		ora $01,x	                ora 1,x
.bb4b		d0 05		bne $bb52	                bne +
.bb4d		20 26 96	jsr $9626	                jsr xt_nip              ; NIP ( addr1 )
.bb50		80 13		bra $bb65	                bra _num_to_addr_done
.bb52						+
.bb52		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( addr1 u )
.bb55		20 f5 97	jsr $97f5	                jsr xt_one_minus        ; 1- ( addr1 u-1 )
.bb58		b5 00		lda $00,x	                lda 0,x
.bb5a		15 01		ora $01,x	                ora 1,x
.bb5c		f0 05		beq $bb63	                beq _num_to_addr_finished
.bb5e		20 5c a1	jsr $a15c	                jsr xt_swap             ; SWAP ( u-1 addr1 )
.bb61		80 e1		bra $bb44	                bra _num_to_addr_loop
.bb63						_num_to_addr_finished:
.bb63		e8		inx		                inx
.bb64		e8		inx		                inx                     ; ( addr )
.bb65						_num_to_addr_done:
.bb65		60		rts		                rts
.bb66						ed_para1_to_cur:
.bb66		b5 02		lda $02,x	                lda 2,x
.bb68		85 30		sta $30		                sta ed_cur
.bb6a		b5 03		lda $03,x	                lda 3,x
.bb6c		85 31		sta $31		                sta ed_cur+1
.bb6e		60		rts		                rts
.bb6f						ed_print_addr:
.bb6f		20 01 98	jsr $9801	                jsr xt_one_plus
.bb72		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( addr+2 )
.bb75		20 62 8d	jsr $8d62	                jsr xt_dup              ; ( addr+2 addr+2 )
.bb78		20 01 98	jsr $9801	                jsr xt_one_plus
.bb7b		20 01 98	jsr $9801	                jsr xt_one_plus         ; ( addr+2 addr+4 )
.bb7e		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( addr+2 u-s )
.bb81		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( u-s addr+2 )
.bb84		20 65 8f	jsr $8f65	                jsr xt_fetch            ; ( u-s addr-s )
.bb87		20 5c a1	jsr $a15c	                jsr xt_swap             ; ( addr-s u-s )
.bb8a		20 a7 a4	jsr $a4a7	                jsr xt_type
.bb8d		20 2a 89	jsr $892a	                jsr xt_cr
.bb90		60		rts		                rts
>bb91		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>bb99		71 51 00
.bb9c						ed_cmd_table:
>bb9c		e1 b7 28 b9 5b b9 84 b8		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>bba4		83 b9 7c b9
>bba8		ec b8 f6 b9 e7 b9 f2 b9		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.bbb0						ed6502_end:

;******  Return to file: platform/../taliforth.asm

.bbb0						forth_words_start:
>bbb0		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>bbb8		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>bbc8		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bbd8		20 56 65 72 73 69 6f 6e 20 31 2e 30 20 30 34 2e
>bbe8		20 44 65 63 20 32 30 32 32 20 29 20 63 72 20 2e
>bbf8		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bc08		2d 32 30 32 32 20 53 63 6f 74 20 57 2e 20 53 74
>bc18		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bc28		77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>bc38		20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>bc48		69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>bc58		4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>bc68		28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>bc78		65 78 69 74 29 20 63 72 20
.bc81						forth_words_end:
.bc81						user_words_start:
>bc81		20 20				.binary "user_words.asc"
.bc83						user_words_end:

;******  Processing file: platform/../headers.asm

.bc83						dictionary_start:
.bc83						nt_drop:
>bc83		04 10				        .byte 4, UF
>bc85		8f bc e1 8c e6 8c		        .word nt_dup, xt_drop, z_drop
>bc8b		64 72 6f 70			        .text "drop"
.bc8f						nt_dup:
>bc8f		03 10				        .byte 3, UF
>bc91		9a bc 62 8d 6f 8d		        .word nt_swap, xt_dup, z_dup
>bc97		64 75 70			        .text "dup"
.bc9a						nt_swap:
>bc9a		04 10				        .byte 4, UF
>bc9c		a6 bc 5c a1 6f a1		        .word nt_store, xt_swap, z_swap
>bca2		73 77 61 70			        .text "swap"
.bca6						nt_store:
>bca6		01 10				        .byte 1, UF
>bca8		af bc 3b a1 50 a1		        .word nt_fetch, xt_store, z_store
>bcae		21				        .text "!"
.bcaf						nt_fetch:
>bcaf		01 10				        .byte 1, UF
>bcb1		b8 bc 65 8f 77 8f		        .word nt_over, xt_fetch, z_fetch
>bcb7		40				        .text "@"
.bcb8						nt_over:
>bcb8		04 10				        .byte 4, UF
>bcba		c4 bc 77 98 84 98		        .word nt_to_r, xt_over, z_over
>bcc0		6f 76 65 72			        .text "over"
.bcc4						nt_to_r:
>bcc4		02 11				        .byte 2, CO+UF ; native is special case
>bcc6		ce bc 14 a3 27 a3		        .word nt_r_from, xt_to_r, z_to_r
>bccc		3e 72				        .text ">r"
.bcce						nt_r_from:
>bcce		02 01				        .byte 2, CO    ; native is special case
>bcd0		d8 bc 76 9a 86 9a		        .word nt_r_fetch, xt_r_from, z_r_from
>bcd6		72 3e				        .text "r>"
.bcd8						nt_r_fetch:
>bcd8		02 01				        .byte 2, CO    ; native is special case
>bcda		e2 bc 61 9a 75 9a		        .word nt_nip, xt_r_fetch, z_r_fetch
>bce0		72 40				        .text "r@"
.bce2						nt_nip:
>bce2		03 10				        .byte 3, UF
>bce4		ed bc 26 96 33 96		        .word nt_rot, xt_nip, z_nip
>bcea		6e 69 70			        .text "nip"
.bced						nt_rot:
>bced		03 10				        .byte 3, UF
>bcef		f8 bc 34 9b 4f 9b		        .word nt_not_rote, xt_rot, z_rot
>bcf5		72 6f 74			        .text "rot"
.bcf8						nt_not_rote:
>bcf8		04 10				        .byte 4, UF
>bcfa		04 bd 52 96 6d 96		        .word nt_tuck, xt_not_rote, z_not_rote
>bd00		2d 72 6f 74			        .text "-rot"
.bd04						nt_tuck:
>bd04		04 10				        .byte 4, UF
>bd06		10 bd 31 a3 4a a3		        .word nt_comma, xt_tuck, z_tuck
>bd0c		74 75 63 6b			        .text "tuck"
.bd10						nt_comma:
>bd10		01 10				        .byte 1, UF
>bd12		19 bd 24 87 3d 87		        .word nt_c_fetch, xt_comma, z_comma
>bd18		2c				        .text ","
.bd19						nt_c_fetch:
>bd19		02 10				        .byte 2, UF
>bd1b		23 bd c1 85 ca 85		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bd21		63 40				        .text "c@"
.bd23						nt_c_store:
>bd23		02 10				        .byte 2, UF
>bd25		2d bd cb 85 d6 85		        .word nt_plus_store, xt_c_store, z_c_store
>bd2b		63 21				        .text "c!"
.bd2d						nt_plus_store:
>bd2d		02 10				        .byte 2, UF
>bd2f		37 bd da 99 f9 99		        .word nt_execute, xt_plus_store, z_plus_store
>bd35		2b 21				        .text "+!"
.bd37						nt_execute:
>bd37		07 10				        .byte 7, UF
>bd39		46 bd 22 8f 28 8f		        .word nt_emit, xt_execute, z_execute
>bd3f		65 78 65 63 75 74 65		        .text "execute"
.bd46						nt_emit:
>bd46		04 18				        .byte 4, NN+UF
>bd48		52 bd d4 8d de 8d		        .word nt_type, xt_emit, z_emit
>bd4e		65 6d 69 74			        .text "emit"
.bd52						nt_type:
>bd52		04 10				        .byte 4, UF
>bd54		5e bd a7 a4 d1 a4		        .word nt_dot, xt_type, z_type
>bd5a		74 79 70 65			        .text "type"
.bd5e						nt_dot:
>bd5e		01 10				        .byte 1, UF
>bd60		67 bd e9 8b 0a 8c		        .word nt_u_dot, xt_dot, z_dot
>bd66		2e				        .text "."
.bd67						nt_u_dot:
>bd67		02 10				        .byte 2, UF
>bd69		71 bd d2 a4 dd a4		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bd6f		75 2e				        .text "u."
.bd71						nt_u_dot_r:
>bd71		03 10				        .byte 3, UF
>bd73		7c bd de a4 ff a4		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bd79		75 2e 72			        .text "u.r"
.bd7c						nt_dot_r:
>bd7c		02 10				        .byte 2, UF
>bd7e		86 bd 25 8c 52 8c		        .word nt_d_dot, xt_dot_r, z_dot_r
>bd84		2e 72				        .text ".r"
.bd86						nt_d_dot:
>bd86		02 10				        .byte 2, UF
>bd88		90 bd 97 8c b5 8c		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bd8e		64 2e				        .text "d."
.bd90						nt_d_dot_r:
>bd90		03 10				        .byte 3, UF
>bd92		9b bd b6 8c e0 8c		        .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
>bd98		64 2e 72			        .text "d.r"
.bd9b						nt_ud_dot:
>bd9b		03 10				        .byte 3, UF
>bd9d		a6 bd 2c a5 3e a5		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bda3		75 64 2e			        .text "ud."
.bda6						nt_ud_dot_r:
>bda6		04 10				        .byte 4, UF
>bda8		b2 bd 3f a5 5d a5		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bdae		75 64 2e 72			        .text "ud.r"
.bdb2						nt_question:
>bdb2		01 00				        .byte 1, 0
>bdb4		bb bd 46 9a 4c 9a		        .word nt_false, xt_question, z_question
>bdba		3f				        .text "?"
.bdbb						nt_false:
>bdbb		05 00				        .byte 5, 0
>bdbd		c8 bd 5e 8f 64 8f		        .word nt_true, xt_false, z_false
>bdc3		66 61 6c 73 65			        .text "false"
.bdc8						nt_true:
>bdc8		04 00				        .byte 4, 0
>bdca		d4 bd 28 a3 30 a3		        .word nt_space, xt_true, z_true
>bdd0		74 72 75 65			        .text "true"
.bdd4						nt_space:
>bdd4		05 00				        .byte 5, 0
>bdd6		e1 bd cc a0 d1 a0		        .word nt_zero, xt_space, z_space
>bddc		73 70 61 63 65			        .text "space"
.bde1						nt_zero:
>bde1		01 00				        .byte 1, 0
>bde3		ea bd 56 a7 5c a7		        .word nt_one, xt_zero, z_zero
>bde9		30				        .text "0"
.bdea						nt_one:
>bdea		01 00				        .byte 1, 0
>bdec		f3 bd ec 97 f4 97		        .word nt_two, xt_one, z_one
>bdf2		31				        .text "1"
.bdf3						nt_two:
>bdf3		01 00				        .byte 1, 0
>bdf5		fc bd 4b a3 53 a3		        .word nt_two_dup, xt_two, z_two
>bdfb		32				        .text "2"
.bdfc						nt_two_dup:
>bdfc		04 10				        .byte 4, UF
>bdfe		08 be 5c a3 73 a3		        .word nt_question_dup, xt_two_dup, z_two_dup
>be04		32 64 75 70			        .text "2dup"
.be08						nt_question_dup:
>be08		04 10				        .byte 4, UF
>be0a		14 be 4d 9a 60 9a		        .word nt_plus, xt_question_dup, z_question_dup
>be10		3f 64 75 70			        .text "?dup"
.be14						nt_plus:
>be14		01 10				        .byte 1, UF
>be16		1d be c7 99 d9 99		        .word nt_minus, xt_plus, z_plus
>be1c		2b				        .text "+"
.be1d						nt_minus:
>be1d		01 10				        .byte 1, UF
>be1f		26 be 34 95 46 95		        .word nt_one_minus, xt_minus, z_minus
>be25		2d				        .text "-"
.be26						nt_one_minus:
>be26		02 10				        .byte 2, UF
>be28		30 be f5 97 00 98		        .word nt_one_plus, xt_one_minus, z_one_minus
>be2e		31 2d				        .text "1-"
.be30						nt_one_plus:
>be30		02 10				        .byte 2, UF
>be32		3a be 01 98 0a 98		        .word nt_two_star, xt_one_plus, z_one_plus
>be38		31 2b				        .text "1+"
.be3a						nt_two_star:
>be3a		02 10				        .byte 2, UF
>be3c		44 be f4 a3 fb a3		        .word nt_two_slash, xt_two_star, z_two_star
>be42		32 2a				        .text "2*"
.be44						nt_two_slash:
>be44		02 10				        .byte 2, UF
>be46		4e be e9 a3 f3 a3		        .word nt_abs, xt_two_slash, z_two_slash
>be4c		32 2f				        .text "2/"
.be4e						nt_abs:
>be4e		03 10				        .byte 3, UF
>be50		59 be cd 80 e1 80		        .word nt_dabs, xt_abs, z_abs
>be56		61 62 73			        .text "abs"
.be59						nt_dabs:
>be59		04 10				        .byte 4, UF
>be5b		65 be 4d 8a 6b 8a		        .word nt_and, xt_dabs, z_dabs
>be61		64 61 62 73			        .text "dabs"
.be65						nt_and:
>be65		03 10				        .byte 3, UF
>be67		70 be d2 82 e3 82		        .word nt_or, xt_and, z_and
>be6d		61 6e 64			        .text "and"
.be70						nt_or:
>be70		02 10				        .byte 2, UF
>be72		7a be 17 98 28 98		        .word nt_xor, xt_or, z_or
>be78		6f 72				        .text "or"
.be7a						nt_xor:
>be7a		03 10				        .byte 3, UF
>be7c		85 be 44 a7 55 a7		        .word nt_rshift, xt_xor, z_xor
>be82		78 6f 72			        .text "xor"
.be85						nt_rshift:
>be85		06 10				        .byte 6, UF
>be87		93 be 50 9b 63 9b		        .word nt_lshift, xt_rshift, z_rshift
>be8d		72 73 68 69 66 74		        .text "rshift"
.be93						nt_lshift:
>be93		06 10				        .byte 6, UF
>be95		a1 be 5e 94 71 94		        .word nt_pick, xt_lshift, z_lshift
>be9b		6c 73 68 69 66 74		        .text "lshift"
.bea1						nt_pick:
>bea1		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bea3		ad be b6 99 c6 99		        .word nt_char, xt_pick, z_pick
>bea9		70 69 63 6b			        .text "pick"
.bead						nt_char:
>bead		04 00				        .byte 4, 0
>beaf		b9 be e7 85 fd 85		        .word nt_bracket_char, xt_char, z_char
>beb5		63 68 61 72			        .text "char"
.beb9						nt_bracket_char:
>beb9		06 05				        .byte 6, CO+IM
>bebb		c7 be 4d 85 53 85		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bec1		5b 63 68 61 72 5d		        .text "[char]"
.bec7						nt_char_plus:
>bec7		05 00				        .byte 5, 0
>bec9		d4 be 01 98 0a 98		        .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
>becf		63 68 61 72 2b			        .text "char+"
.bed4						nt_chars:
>bed4		05 12				        .byte 5, AN+UF   ; deleted during compile
>bed6		e1 be fe 85 01 86		        .word nt_cells, xt_chars, z_chars
>bedc		63 68 61 72 73			        .text "chars"
.bee1						nt_cells:
>bee1		05 00				        .byte 5, 0
>bee3		ee be f4 a3 fb a3		        .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
>bee9		63 65 6c 6c 73			        .text "cells"
.beee						nt_cell_plus:
>beee		05 10				        .byte 5, UF
>bef0		fb be d7 85 e6 85		        .word nt_here, xt_cell_plus, z_cell_plus
>bef6		63 65 6c 6c 2b			        .text "cell+"
.befb						nt_here:
>befb		04 00				        .byte 4, 0
>befd		07 bf 57 91 61 91		        .word nt_equal, xt_here, z_here
>bf03		68 65 72 65			        .text "here"
.bf07						nt_equal:
>bf07		01 10				        .byte 1, UF
>bf09		10 bf b3 8e ce 8e		        .word nt_not_equals, xt_equal, z_equal
>bf0f		3d				        .text "="
.bf10						nt_not_equals:
>bf10		02 10				        .byte 2, UF
>bf12		1a bf 34 96 51 96		        .word nt_less_than, xt_not_equals, z_not_equals
>bf18		3c 3e				        .text "<>"
.bf1a						nt_less_than:
>bf1a		01 10				        .byte 1, UF
>bf1c		23 bf 49 93 5d 93		        .word nt_u_less_than, xt_less_than, z_less_than
>bf22		3c				        .text "<"
.bf23						nt_u_less_than:
>bf23		02 10				        .byte 2, UF
>bf25		2d bf 16 a5 2b a5		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>bf2b		75 3c				        .text "u<"
.bf2d						nt_u_greater_than:
>bf2d		02 10				        .byte 2, UF
>bf2f		37 bf 00 a5 15 a5		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>bf35		75 3e				        .text "u>"
.bf37						nt_greater_than:
>bf37		01 10				        .byte 1, UF
>bf39		40 bf 42 91 56 91		        .word nt_zero_equal, xt_greater_than, z_greater_than
>bf3f		3e				        .text ">"
.bf40						nt_zero_equal:
>bf40		02 10				        .byte 2, UF
>bf42		4a bf 5d a7 6e a7		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>bf48		30 3d				        .text "0="
.bf4a						nt_zero_unequal:
>bf4a		03 10				        .byte 3, UF
>bf4c		55 bf 93 a7 a2 a7		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>bf52		30 3c 3e			        .text "0<>"
.bf55						nt_zero_greater:
>bf55		02 10				        .byte 2, UF
>bf57		5f bf 6f a7 82 a7		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>bf5d		30 3e				        .text "0>"
.bf5f						nt_zero_less:
>bf5f		02 10				        .byte 2, UF
>bf61		69 bf 83 a7 92 a7		        .word nt_min, xt_zero_less, z_zero_less
>bf67		30 3c				        .text "0<"
.bf69						nt_min:
>bf69		03 10				        .byte 3, UF
>bf6b		74 bf 18 95 33 95		        .word nt_max, xt_min, z_min
>bf71		6d 69 6e			        .text "min"
.bf74						nt_max:
>bf74		03 10				        .byte 3, UF
>bf76		7f bf fc 94 17 95		        .word nt_two_drop, xt_max, z_max
>bf7c		6d 61 78			        .text "max"
.bf7f						nt_two_drop:
>bf7f		05 10				        .byte 5, UF
>bf81		8c bf 54 a3 5b a3		        .word nt_two_swap, xt_two_drop, z_two_drop
>bf87		32 64 72 6f 70			        .text "2drop"
.bf8c						nt_two_swap:
>bf8c		05 10				        .byte 5, UF
>bf8e		99 bf 22 a4 45 a4		        .word nt_two_over, xt_two_swap, z_two_swap
>bf94		32 73 77 61 70			        .text "2swap"
.bf99						nt_two_over:
>bf99		05 10				        .byte 5, UF
>bf9b		a6 bf 96 a3 ad a3		        .word nt_two_store, xt_two_over, z_two_over
>bfa1		32 6f 76 65 72			        .text "2over"
.bfa6						nt_two_store:
>bfa6		02 10				        .byte 2, UF
>bfa8		b0 bf fc a3 21 a4		        .word nt_two_fetch, xt_two_store, z_two_store
>bfae		32 21				        .text "2!"
.bfb0						nt_two_fetch:
>bfb0		02 10				        .byte 2, UF
>bfb2		ba bf 74 a3 95 a3		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>bfb8		32 40				        .text "2@"
.bfba						nt_two_variable:
>bfba		09 00				        .byte 9, 0
>bfbc		cb bf 98 a4 a6 a4		        .word nt_two_constant, xt_two_variable, z_two_variable
>bfc2		32 76 61 72 69 61 62 6c		        .text "2variable"
>bfca		65
.bfcb						nt_two_constant:
>bfcb		09 10				        .byte 9, UF
>bfcd		dc bf 66 a4 8a a4		        .word nt_two_literal, xt_two_constant, z_two_constant
>bfd3		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bfdb		74
.bfdc						nt_two_literal:
>bfdc		08 14				        .byte 8, UF+IM
>bfde		ec bf 8b a4 97 a4		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bfe4		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bfec						nt_two_r_fetch:
>bfec		03 09				        .byte 3, CO+NN          ; native is special case, leave NN for now
>bfee		f7 bf ae a3 cb a3		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>bff4		32 72 40			        .text "2r@"
.bff7						nt_two_r_from:
>bff7		03 01				        .byte 3, CO             ; native is special case
>bff9		02 c0 cc a3 e8 a3		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bfff		32 72 3e			        .text "2r>"
.c002						nt_two_to_r:
>c002		03 11				        .byte 3, CO+UF          ; native is special case
>c004		0d c0 46 a4 65 a4		        .word nt_invert, xt_two_to_r, z_two_to_r
>c00a		32 3e 72			        .text "2>r"
.c00d						nt_invert:
>c00d		06 10				        .byte 6, UF
>c00f		1b c0 cc 92 db 92		        .word nt_negate, xt_invert, z_invert
>c015		69 6e 76 65 72 74		        .text "invert"
.c01b						nt_negate:
>c01b		06 10				        .byte 6, UF
>c01d		29 c0 07 96 17 96		        .word nt_dnegate, xt_negate, z_negate
>c023		6e 65 67 61 74 65		        .text "negate"
.c029						nt_dnegate:
>c029		07 10				        .byte 7, UF
>c02b		38 c0 08 8b 22 8b		        .word nt_c_comma, xt_dnegate, z_dnegate
>c031		64 6e 65 67 61 74 65		        .text "dnegate"
.c038						nt_c_comma:
>c038		02 10				        .byte 2, UF
>c03a		42 c0 b6 85 c0 85		        .word nt_bounds, xt_c_comma, z_c_comma
>c040		63 2c				        .text "c,"
.c042						nt_bounds:
>c042		06 10				        .byte 6, UF
>c044		50 c0 34 85 4c 85		        .word nt_spaces, xt_bounds, z_bounds
>c04a		62 6f 75 6e 64 73		        .text "bounds"
.c050						nt_spaces:
>c050		06 10				        .byte 6, UF
>c052		5e c0 d2 a0 0d a1		        .word nt_bl, xt_spaces, z_spaces
>c058		73 70 61 63 65 73		        .text "spaces"
.c05e						nt_bl:
>c05e		02 00				        .byte 2, 0
>c060		68 c0 50 83 58 83		        .word nt_minus_trailing, xt_bl, z_bl
>c066		62 6c				        .text "bl"
.c068						nt_minus_trailing:
>c068		09 10				        .byte 9, UF
>c06a		79 c0 60 95 9c 95		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>c070		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>c078		67
.c079						nt_minus_leading:
>c079		08 10				        .byte 8, UF
>c07b		89 c0 47 95 5f 95		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>c081		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.c089						nt_slash_string:
>c089		07 10				        .byte 7, UF
>c08b		98 c0 c7 9f e6 9f		        .word nt_refill, xt_slash_string, z_slash_string
>c091		2f 73 74 72 69 6e 67		        .text "/string"
.c098						nt_refill:
>c098		06 00				        .byte 6, 0
>c09a		a6 c0 dc 9a 1d 9b		        .word nt_accept, xt_refill, z_refill
>c0a0		72 65 66 69 6c 6c		        .text "refill"
.c0a6						nt_accept:
>c0a6		06 18				        .byte 6, UF+NN
>c0a8		b4 c0 e2 80 da 81		        .word nt_input_to_r, xt_accept, z_accept
>c0ae		61 63 63 65 70 74		        .text "accept"
.c0b4						nt_input_to_r:
>c0b4		07 08				        .byte 7, NN
>c0b6		c3 c0 43 92 58 92		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>c0bc		69 6e 70 75 74 3e 72		        .text "input>r"
.c0c3						nt_r_to_input:
>c0c3		07 08				        .byte 7, NN
>c0c5		d2 c0 87 9a 9e 9a		        .word nt_unused, xt_r_to_input, z_r_to_input
>c0cb		72 3e 69 6e 70 75 74		        .text "r>input"
.c0d2						nt_unused:
>c0d2		06 00				        .byte 6, 0
>c0d4		e0 c0 02 a6 11 a6		        .word nt_depth, xt_unused, z_unused
>c0da		75 6e 75 73 65 64		        .text "unused"
.c0e0						nt_depth:
>c0e0		05 00				        .byte 5, 0
>c0e2		ed c0 bd 8a cb 8a		        .word nt_key, xt_depth, z_depth
>c0e8		64 65 70 74 68			        .text "depth"
.c0ed						nt_key:
>c0ed		03 00				        .byte 3, 0
>c0ef		f8 c0 0f 93 18 93		        .word nt_allot, xt_key, z_key
>c0f5		6b 65 79			        .text "key"
.c0f8						nt_allot:
>c0f8		05 10				        .byte 5, UF
>c0fa		05 c1 3f 82 a7 82		        .word nt_create, xt_allot, z_allot
>c100		61 6c 6c 6f 74			        .text "allot"
.c105						nt_create:
>c105		06 00				        .byte 6, 0
>c107		13 c1 30 89 04 8a		        .word nt_does, xt_create, z_create
>c10d		63 72 65 61 74 65		        .text "create"
.c113						nt_does:
>c113		05 05				        .byte 5, CO+IM
>c115		20 c1 a8 8b b6 8b		        .word nt_variable, xt_does, z_does
>c11b		64 6f 65 73 3e			        .text "does>"
.c120						nt_variable:
>c120		08 00				        .byte 8, 0
>c122		30 c1 26 a6 3e a6		        .word nt_constant, xt_variable, z_variable
>c128		76 61 72 69 61 62 6c 65		        .text "variable"
.c130						nt_constant:
>c130		08 10				        .byte 8, UF
>c132		40 c1 d8 88 15 89		        .word nt_value, xt_constant, z_constant
>c138		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c140						nt_value:
>c140		05 10				        .byte 5, UF
>c142		4d c1 d8 88 15 89		        .word nt_to, xt_constant, z_constant
>c148		76 61 6c 75 65			        .text "value"
.c14d						nt_to:
>c14d		02 0c				        .byte 2, NN+IM
>c14f		57 c1 d5 a1 30 a2		        .word nt_s_to_d, xt_to, z_to
>c155		74 6f				        .text "to"
.c157						nt_s_to_d:
>c157		03 10				        .byte 3, UF
>c159		62 c1 5a 9e 6b 9e		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c15f		73 3e 64			        .text "s>d"
.c162						nt_d_to_s:
>c162		03 10				        .byte 3, UF
>c164		6d c1 47 8a 4c 8a		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c16a		64 3e 73			        .text "d>s"
.c16d						nt_d_minus:
>c16d		02 10				        .byte 2, UF
>c16f		77 c1 05 8a 25 8a		        .word nt_d_plus, xt_d_minus, z_d_minus
>c175		64 2d				        .text "d-"
.c177						nt_d_plus:
>c177		02 10				        .byte 2, UF
>c179		81 c1 26 8a 46 8a		        .word nt_erase, xt_d_plus, z_d_plus
>c17f		64 2b				        .text "d+"
.c181						nt_erase:
>c181		05 00				        .byte 5, 0      ; underflow checked by FILL
>c183		8e c1 d9 8e 21 8f		        .word nt_blank, xt_erase, z_erase
>c189		65 72 61 73 65			        .text "erase"
.c18e						nt_blank:
>c18e		05 00				        .byte 5, 0     ; underflow checked by FILL
>c190		9b c1 cf 8e 21 8f		        .word nt_fill, xt_blank, z_blank
>c196		62 6c 61 6e 6b			        .text "blank"
.c19b						nt_fill:
>c19b		04 10				        .byte 4, UF
>c19d		a7 c1 df 8e 21 8f		        .word nt_find_name, xt_fill, z_fill
>c1a3		66 69 6c 6c			        .text "fill"
.c1a7						nt_find_name:
>c1a7		09 10				        .byte 9, UF
>c1a9		b8 c1 c0 8f 6b 90		        .word nt_tick, xt_find_name, z_find_name
>c1af		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c1b7		65
.c1b8						nt_tick:
>c1b8		01 00				        .byte 1, 0
>c1ba		c1 c1 b5 a1 d4 a1		        .word nt_bracket_tick, xt_tick, z_tick
>c1c0		27				        .text "'"
.c1c1						nt_bracket_tick:
>c1c1		03 05				        .byte 3, CO+IM
>c1c3		cc c1 54 85 5a 85		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c1c9		5b 27 5d			        .text "[']"
.c1cc						nt_name_to_int:
>c1cc		08 10				        .byte 8, UF
>c1ce		dc c1 c5 95 e1 95		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c1d4		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c1dc						nt_int_to_name:
>c1dc		08 10				        .byte 8, UF
>c1de		ec c1 59 92 cb 92		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c1e4		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c1ec						nt_name_to_string:
>c1ec		0b 10				        .byte 11, UF
>c1ee		ff c1 e2 95 fb 95		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c1f4		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c1fc		69 6e 67
.c1ff						nt_to_body:
>c1ff		05 10				        .byte 5, UF
>c201		0c c2 31 a2 55 a2		        .word nt_defer, xt_to_body, z_to_body
>c207		3e 62 6f 64 79			        .text ">body"
.c20c						nt_defer:
>c20c		05 00				        .byte 5, 0
>c20e		19 c2 73 8a a5 8a		        .word nt_latestxt, xt_defer, z_defer
>c214		64 65 66 65 72			        .text "defer"
.c219						nt_latestxt:
>c219		08 00				        .byte 8, 0
>c21b		29 c2 2a 93 30 93		        .word nt_latestnt, xt_latestxt, z_latestxt
>c221		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c229						nt_latestnt:
>c229		08 00				        .byte 8, 0
>c22b		39 c2 1c 93 29 93		        .word nt_parse_name, xt_latestnt, z_latestnt
>c231		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c239						nt_parse_name:
>c239		0a 08				        .byte 10, NN
>c23b		4b c2 c3 98 b5 99		        .word nt_parse, xt_parse_name, z_parse_name
>c241		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c249		6d 65
.c24b						nt_parse:
>c24b		05 10				        .byte 5, UF
>c24d		58 c2 1e 99 b5 99		        .word nt_execute_parsing, xt_parse, z_parse
>c253		70 61 72 73 65			        .text "parse"
.c258						nt_execute_parsing:
>c258		0f 10				        .byte 15, UF
>c25a		6f c2 36 8f 5c 8f		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c260		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c268		70 61 72 73 69 6e 67
.c26f						nt_source:
>c26f		06 00				        .byte 6, 0
>c271		7d c2 ac a0 c0 a0		        .word nt_source_id, xt_source, z_source
>c277		73 6f 75 72 63 65		        .text "source"
.c27d						nt_source_id:
>c27d		09 00				        .byte 9, 0
>c27f		8e c2 c1 a0 cb a0		        .word nt_colon, xt_source_id, z_source_id
>c285		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c28d		64
.c28e						nt_colon:
>c28e		01 00				        .byte 1, 0
>c290		97 c2 c5 86 07 87		        .word nt_semicolon, xt_colon, z_colon
>c296		3a				        .text ":"
.c297						nt_semicolon:
>c297		01 05				        .byte 1, CO+IM
>c299		a0 c2 36 9f 94 9f		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c29f		3b				        .text ";"
.c2a0						nt_colon_noname:
>c2a0		07 00				        .byte 7, 0
>c2a2		af c2 08 87 23 87		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c2a8		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c2af						nt_compile_comma:
>c2af		08 18				        .byte 8, UF+NN
>c2b1		bf c2 a3 87 cb 88		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c2b7		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c2bf						nt_left_bracket:
>c2bf		01 05				        .byte 1, IM+CO
>c2c1		c8 c2 36 93 3a 93		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c2c7		5b				        .text "["
.c2c8						nt_right_bracket:
>c2c8		01 04				        .byte 1, IM
>c2ca		d1 c2 24 9b 2a 9b		        .word nt_literal, xt_right_bracket, z_right_bracket
>c2d0		5d				        .text "]"
.c2d1						nt_literal:
>c2d1		07 15				        .byte 7, IM+CO+UF
>c2d3		e0 c2 6b 93 78 93		        .word nt_sliteral, xt_literal, z_literal
>c2d9		6c 69 74 65 72 61 6c		        .text "literal"
.c2e0						nt_sliteral:
>c2e0		08 15				        .byte 8, CO+IM+UF
>c2e2		f0 c2 e7 9f 56 a0		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c2e8		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c2f0						nt_dot_quote:
>c2f0		02 05				        .byte 2, CO+IM
>c2f2		fa c2 1a 8c 24 8c		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c2f8		2e 22				        .text ".", $22
.c2fa						nt_s_quote:
>c2fa		02 0c				        .byte 2, IM+NN
>c2fc		04 c3 2c 9d 59 9e		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c302		73 22				        .text "s", $22
.c304						nt_s_backslash_quote:
>c304		03 04				        .byte 3, IM
>c306		0f c3 64 9b 6d 9b		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c30c		73 5c 22			        .text "s", $5C, $22
.c30f						nt_postpone:
>c30f		08 05				        .byte 8, IM+CO
>c311		1f c3 fa 99 38 9a		        .word nt_immediate, xt_postpone, z_postpone
>c317		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c31f						nt_immediate:
>c31f		09 00				        .byte 9, 0
>c321		30 c3 2c 92 37 92		        .word nt_compile_only, xt_immediate, z_immediate
>c327		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c32f		65
.c330						nt_compile_only:
>c330		0c 00				        .byte 12, 0
>c332		44 c3 cc 88 d7 88		        .word nt_never_native, xt_compile_only, z_compile_only
>c338		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c340		6f 6e 6c 79
.c344						nt_never_native:
>c344		0c 00				        .byte 12, 0
>c346		58 c3 18 96 25 96		        .word nt_always_native, xt_never_native, z_never_native
>c34c		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c354		74 69 76 65
.c358						nt_always_native:
>c358		0d 00				        .byte 13, 0
>c35a		6d c3 c4 82 d1 82		        .word nt_allow_native, xt_always_native, z_always_native
>c360		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c368		61 74 69 76 65
.c36d						nt_allow_native:
>c36d		0c 00				        .byte 12, 0
>c36f		81 c3 a8 82 b3 82		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c375		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c37d		74 69 76 65
.c381						nt_nc_limit:
>c381		08 00				        .byte 8, 0
>c383		91 c3 fc 95 06 96		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c389		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c391						nt_strip_underflow:
>c391		0f 00				        .byte 15, 0
>c393		a8 c3 51 a1 5b a1		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c399		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c3a1		64 65 72 66 6c 6f 77
.c3a8						nt_abort:
>c3a8		05 00				        .byte 5, 0
>c3aa		b5 c3 60 80 ad 80		        .word nt_abort_quote, xt_abort, z_abort
>c3b0		61 62 6f 72 74			        .text "abort"
.c3b5						nt_abort_quote:
>c3b5		06 0d				        .byte 6, CO+IM+NN
>c3b7		c3 c3 ad 80 b7 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c3bd		61 62 6f 72 74 22		        .text "abort", $22
.c3c3						nt_do:
>c3c3		02 0d				        .byte 2, CO+IM+NN
>c3c5		cd c3 29 8b 62 8b		        .word nt_question_do, xt_do, z_do
>c3cb		64 6f				        .text "do"
.c3cd						nt_question_do:
>c3cd		03 0d				        .byte 3, CO+IM+NN
>c3cf		d8 c3 23 8b 62 8b		        .word nt_i, xt_question_do, z_question_do
>c3d5		3f 64 6f			        .text "?do"
.c3d8						nt_i:
>c3d8		01 03				        .byte 1, AN+CO
>c3da		e1 c3 ce 91 e5 91		        .word nt_j, xt_i, z_i
>c3e0		69				        .text "i"
.c3e1						nt_j:
>c3e1		01 03				        .byte 1, AN+CO
>c3e3		ea c3 f5 92 0e 93		        .word nt_loop, xt_j, z_j
>c3e9		6a				        .text "j"
.c3ea						nt_loop:
>c3ea		04 05				        .byte 4, CO+IM
>c3ec		f6 c3 dc 93 39 94		        .word nt_plus_loop, xt_loop, z_loop
>c3f2		6c 6f 6f 70			        .text "loop"
.c3f6						nt_plus_loop:
>c3f6		05 05				        .byte 5, CO+IM
>c3f8		03 c4 ed 93 39 94		        .word nt_exit, xt_plus_loop, z_plus_loop
>c3fe		2b 6c 6f 6f 70			        .text "+loop"
.c403						nt_exit:
>c403		04 03				        .byte 4, AN+CO
>c405		0f c4 5d 8f 5e 8f		        .word nt_unloop, xt_exit, z_exit
>c40b		65 78 69 74			        .text "exit"
.c40f						nt_unloop:
>c40f		06 03				        .byte 6, AN+CO
>c411		1d c4 e6 a5 ec a5		        .word nt_leave, xt_unloop, z_unloop
>c417		75 6e 6c 6f 6f 70		        .text "unloop"
.c41d						nt_leave:
>c41d		05 03				        .byte 5, AN+CO
>c41f		2a c4 31 93 36 93		        .word nt_recurse, xt_leave, z_leave
>c425		6c 65 61 76 65			        .text "leave"
.c42a						nt_recurse:
>c42a		07 0d				        .byte 7, CO+IM+NN
>c42c		39 c4 9f 9a db 9a		        .word nt_quit, xt_recurse, z_recurse
>c432		72 65 63 75 72 73 65		        .text "recurse"
.c439						nt_quit:
>c439		04 00				        .byte 4, 0
>c43b		45 c4 62 80 ad 80		        .word nt_begin, xt_quit, z_quit
>c441		71 75 69 74			        .text "quit"
.c445						nt_begin:
>c445		05 07				        .byte 5, AN+CO+IM
>c447		52 c4 46 83 49 83		        .word nt_again, xt_begin, z_begin
>c44d		62 65 67 69 6e			        .text "begin"
.c452						nt_again:
>c452		05 17				        .byte 5, AN+CO+IM+UF
>c454		5f c4 1d 82 3d 82		        .word nt_state, xt_again, z_again
>c45a		61 67 61 69 6e			        .text "again"
.c45f						nt_state:
>c45f		05 00				        .byte 5, 0
>c461		6c c4 30 a1 3a a1		        .word nt_evaluate, xt_state, z_state
>c467		73 74 61 74 65			        .text "state"
.c46c						nt_evaluate:
>c46c		08 10				        .byte 8, UF
>c46e		7c c4 ba 90 0d 91		        .word nt_base, xt_evaluate, z_evaluate
>c474		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c47c						nt_base:
>c47c		04 00				        .byte 4, 0
>c47e		88 c4 3d 83 45 83		        .word nt_digit_question, xt_base, z_base
>c484		62 61 73 65			        .text "base"
.c488						nt_digit_question:
>c488		06 10				        .byte 6, UF
>c48a		96 c4 cc 8a 00 8b		        .word nt_number, xt_digit_question, z_digit_question
>c490		64 69 67 69 74 3f		        .text "digit?"
.c496						nt_number:
>c496		06 10				        .byte 6, UF
>c498		a4 c4 6e 96 6a 97		        .word nt_to_number, xt_number, z_number
>c49e		6e 75 6d 62 65 72		        .text "number"
.c4a4						nt_to_number:
>c4a4		07 10				        .byte 7, UF
>c4a6		b3 c4 61 a2 00 a3		        .word nt_hex, xt_to_number, z_to_number
>c4ac		3e 6e 75 6d 62 65 72		        .text ">number"
.c4b3						nt_hex:
>c4b3		03 00				        .byte 3, 0
>c4b5		be c4 62 91 68 91		        .word nt_decimal, xt_hex, z_hex
>c4bb		68 65 78			        .text "hex"
.c4be						nt_decimal:
>c4be		07 00				        .byte 7, 0
>c4c0		cd c4 6c 8a 72 8a		        .word nt_count, xt_decimal, z_decimal
>c4c6		64 65 63 69 6d 61 6c		        .text "decimal"
.c4cd						nt_count:
>c4cd		05 10				        .byte 5, UF
>c4cf		da c4 16 89 29 89		        .word nt_m_star, xt_count, z_count
>c4d5		63 6f 75 6e 74			        .text "count"
.c4da						nt_m_star:
>c4da		02 10				        .byte 2, UF
>c4dc		e4 c4 72 94 8c 94		        .word nt_um_star, xt_m_star, z_m_star
>c4e2		6d 2a				        .text "m*"
.c4e4						nt_um_star:
>c4e4		03 10				        .byte 3, UF
>c4e6		ef c4 a0 a5 e5 a5		        .word nt_star, xt_um_star, z_um_star
>c4ec		75 6d 2a			        .text "um*"
.c4ef						nt_star:
>c4ef		01 10				        .byte 1, UF
>c4f1		f8 c4 0e a1 16 a1		        .word nt_um_slash_mod, xt_star, z_star
>c4f7		2a				        .text "*"
.c4f8						nt_um_slash_mod:
>c4f8		06 10				        .byte 6, UF
>c4fa		06 c5 5e a5 9f a5		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c500		75 6d 2f 6d 6f 64		        .text "um/mod"
.c506						nt_sm_slash_rem:
>c506		06 10				        .byte 6, UF
>c508		14 c5 83 a0 ab a0		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c50e		73 6d 2f 72 65 6d		        .text "sm/rem"
.c514						nt_fm_slash_mod:
>c514		06 10				        .byte 6, UF
>c516		22 c5 76 90 ac 90		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c51c		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c522						nt_slash:
>c522		01 10				        .byte 1, UF
>c524		2b c5 aa 9f c6 9f		        .word nt_slash_mod, xt_slash, z_slash
>c52a		2f				        .text "/"
.c52b						nt_slash_mod:
>c52b		04 10				        .byte 4, UF
>c52d		37 c5 af 9f c6 9f		        .word nt_mod, xt_slash_mod, z_slash_mod
>c533		2f 6d 6f 64			        .text "/mod"
.c537						nt_mod:
>c537		03 10				        .byte 3, UF
>c539		42 c5 9d 95 a5 95		        .word nt_star_slash_mod, xt_mod, z_mod
>c53f		6d 6f 64			        .text "mod"
.c542						nt_star_slash_mod:
>c542		05 10				        .byte 5, UF
>c544		4f c5 20 a1 2f a1		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c54a		2a 2f 6d 6f 64			        .text "*/mod"
.c54f						nt_star_slash:
>c54f		02 10				        .byte 2, UF
>c551		59 c5 17 a1 1f a1		        .word nt_backslash, xt_star_slash, z_star_slash
>c557		2a 2f				        .text "*/"
.c559						nt_backslash:
>c559		01 04				        .byte 1, IM
>c55b		62 c5 12 83 3c 83		        .word nt_move, xt_backslash, z_backslash
>c561		5c				        .byte $5c
.c562						nt_move:
>c562		04 18				        .byte 4, NN+UF
>c564		6e c5 a6 95 c4 95		        .word nt_cmove_up, xt_move, z_move
>c56a		6d 6f 76 65			        .text "move"
.c56e						nt_cmove_up:
>c56e		06 10				        .byte 6, UF
>c570		7c c5 8a 86 c4 86		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c576		63 6d 6f 76 65 3e		        .text "cmove>"
.c57c						nt_cmove:
>c57c		05 10				        .byte 5, UF
>c57e		89 c5 4f 86 89 86		        .word nt_pad, xt_cmove, z_cmove
>c584		63 6d 6f 76 65			        .text "cmove"
.c589						nt_pad:
>c589		03 00				        .byte 3, 0
>c58b		94 c5 85 98 94 98		        .word nt_cleave, xt_pad, z_pad
>c591		70 61 64			        .text "pad"
.c594						nt_cleave:
>c594		06 10				        .byte 6, UF
>c596		a2 c5 02 86 4e 86		        .word nt_hexstore, xt_cleave, z_cleave
>c59c		63 6c 65 61 76 65		        .text "cleave"
.c5a2						nt_hexstore:
>c5a2		08 10				        .byte 8, UF
>c5a4		b2 c5 69 91 bb 91		        .word nt_within, xt_hexstore, z_hexstore
>c5aa		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c5b2						nt_within:
>c5b2		06 10				        .byte 6, UF
>c5b4		c0 c5 53 a6 68 a6		        .word nt_to_in, xt_within, z_within
>c5ba		77 69 74 68 69 6e		        .text "within"
.c5c0						nt_to_in:
>c5c0		03 00				        .byte 3, 0
>c5c2		cb c5 56 a2 60 a2		        .word nt_less_number_sign, xt_to_in, z_to_in
>c5c8		3e 69 6e			        .text ">in"
.c5cb						nt_less_number_sign:
>c5cb		02 00				        .byte 2, 0
>c5cd		d5 c5 3b 93 48 93		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c5d3		3c 23				        .text "<#"
.c5d5						nt_number_sign:
>c5d5		01 10				        .byte 1, UF
>c5d7		de c5 6b 97 9f 97		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c5dd		23				        .text "#"
.c5de						nt_number_sign_s:
>c5de		02 10				        .byte 2, UF
>c5e0		e8 c5 c2 97 d2 97		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c5e6		23 73				        .text "#s"
.c5e8						nt_number_sign_greater:
>c5e8		02 10				        .byte 2, UF
>c5ea		f2 c5 a0 97 c1 97		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c5f0		23 3e				        .text "#>"
.c5f2						nt_hold:
>c5f2		04 10				        .byte 4, UF
>c5f4		fe c5 bc 91 cd 91		        .word nt_sign, xt_hold, z_hold
>c5fa		68 6f 6c 64			        .text "hold"
.c5fe						nt_sign:
>c5fe		04 10				        .byte 4, UF
>c600		0a c6 95 9f a9 9f		        .word nt_output, xt_sign, z_sign
>c606		73 69 67 6e			        .text "sign"
.c60a						nt_output:
>c60a		06 00				        .byte 6, 0
>c60c		18 c6 6c 98 76 98		        .word nt_input, xt_output, z_output
>c612		6f 75 74 70 75 74		        .text "output"
.c618						nt_input:
>c618		05 00				        .byte 5, 0
>c61a		25 c6 38 92 42 92		        .word nt_cr, xt_input, z_input
>c620		69 6e 70 75 74			        .text "input"
.c625						nt_cr:
>c625		02 00				        .byte 2, 0
>c627		2f c6 2a 89 2f 89		        .word nt_page, xt_cr, z_cr
>c62d		63 72				        .text "cr"
.c62f						nt_page:
>c62f		04 00				        .byte 4, 0
>c631		3b c6 95 98 b2 98		        .word nt_at_xy, xt_page, z_page
>c637		70 61 67 65			        .text "page"
.c63b						nt_at_xy:
>c63b		05 10				        .byte 5, UF
>c63d		48 c6 e4 82 11 83		        .word nt_marker, xt_at_xy, z_at_xy
>c643		61 74 2d 78 79			        .text "at-xy"
.c648						nt_marker:
>c648		06 04				        .byte 6, IM
>c64a		56 c6 8d 94 ca 94		        .word nt_words, xt_marker, z_marker
>c650		6d 61 72 6b 65 72		        .text "marker"
.c656						nt_words:
>c656		05 00				        .byte 5, 0
>c658		63 c6 c6 a6 22 a7		        .word nt_wordsize, xt_words, z_words
>c65e		77 6f 72 64 73			        .text "words"
.c663						nt_wordsize:
>c663		08 10				        .byte 8, UF
>c665		73 c6 23 a7 43 a7		        .word nt_aligned, xt_wordsize, z_wordsize
>c66b		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c673						nt_aligned:
>c673		07 00				        .byte 7, 0
>c675		82 c6 3e 82 3e 82		        .word nt_align, xt_align, z_align
>c67b		61 6c 69 67 6e 65 64		        .text "aligned"
.c682						nt_align:
>c682		05 00				        .byte 5, 0
>c684		8f c6 3e 82 3e 82		        .word nt_bell, xt_align, z_align
>c68a		61 6c 69 67 6e			        .text "align"
.c68f						nt_bell:
>c68f		04 00				        .byte 4, 0
>c691		9b c6 4a 83 4f 83		        .word nt_dump, xt_bell, z_bell
>c697		62 65 6c 6c			        .text "bell"
.c69b						nt_dump:
>c69b		04 10				        .byte 4, UF
>c69d		a7 c6 e7 8c 4d 8d		        .word nt_dot_s, xt_dump, z_dump
>c6a3		64 75 6d 70			        .text "dump"
.c6a7						nt_dot_s:
>c6a7		02 00				        .byte 2, 0
>c6a9		b1 c6 53 8c 96 8c		        .word +, xt_dot_s, z_dot_s
>c6af		2e 73				        .text ".s"
.c6b1						+
.c6b1						nt_disasm:
>c6b1		06 10				        .byte 6, UF
>c6b3		bf c6 01 8b 07 8b		        .word +, xt_disasm, z_disasm
>c6b9		64 69 73 61 73 6d		        .text "disasm"
.c6bf						+
.c6bf						nt_compare:
>c6bf		07 10				        .byte 7, UF
>c6c1		ce c6 3e 87 a2 87		        .word nt_search, xt_compare, z_compare
>c6c7		63 6f 6d 70 61 72 65		        .text "compare"
.c6ce						nt_search:
>c6ce		06 18				        .byte 6, UF+NN
>c6d0		dc c6 97 9e 35 9f		        .word +, xt_search, z_search
>c6d6		73 65 61 72 63 68		        .text "search"
.c6dc						+
.c6dc						nt_environment_q:
>c6dc		0c 10				        .byte 12, UF
>c6de		f0 c6 fa 8d 76 8e		        .word +, xt_environment_q, z_environment_q
>c6e4		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c6ec		65 6e 74 3f
.c6f0						+
.c6f0						nt_find:
>c6f0		04 10				        .byte 4, UF
>c6f2		fc c6 78 8f bf 8f		        .word nt_word, xt_find, z_find
>c6f8		66 69 6e 64			        .text "find"
.c6fc						nt_word:
>c6fc		04 10				        .byte 4, UF
>c6fe		08 c7 69 a6 ae a6		        .word nt_paren, xt_word, z_word
>c704		77 6f 72 64			        .text "word"
.c708						nt_paren:
>c708		01 04				        .byte 1, IM
>c70a		11 c7 b3 98 c2 98		        .word nt_dot_paren, xt_paren, z_paren
>c710		28				        .text "("
.c711						nt_dot_paren:
>c711		02 04				        .byte 2, IM
>c713		1b c7 0b 8c 19 8c		        .word nt_if, xt_dot_paren, z_dot_paren
>c719		2e 28				        .text ".("
.c71b						nt_if:
>c71b		02 0d				        .byte 2, IM+CO+NN
>c71d		25 c7 e6 91 f6 91		        .word nt_then, xt_if, z_if
>c723		69 66				        .text "if"
.c725						nt_then:
>c725		04 0d				        .byte 4, IM+CO+NN
>c727		31 c7 85 8d ce 8d		        .word nt_else, xt_then, z_then
>c72d		74 68 65 6e			        .text "then"
.c731						nt_else:
>c731		04 0d				        .byte 4, IM+CO+NN
>c733		3d c7 74 8d ce 8d		        .word nt_repeat, xt_else, z_else
>c739		65 6c 73 65			        .text "else"
.c73d						nt_repeat:
>c73d		06 0d				        .byte 6, IM+CO+NN
>c73f		4b c7 1e 9b 24 9b		        .word nt_until, xt_repeat, z_repeat
>c745		72 65 70 65 61 74		        .text "repeat"
.c74b						nt_until:
>c74b		05 0d				        .byte 5, IM+CO+NN
>c74d		58 c7 ed a5 01 a6		        .word nt_while, xt_until, z_until
>c753		75 6e 74 69 6c			        .text "until"
.c758						nt_while:
>c758		05 0d				        .byte 5, IM+CO+NN
>c75a		65 c7 3f a6 52 a6		        .word nt_case, xt_while, z_while
>c760		77 68 69 6c 65			        .text "while"
.c765						nt_case:
>c765		04 0d				        .byte 4, IM+CO+NN
>c767		71 c7 56 a7 5c a7		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c76d		63 61 73 65			        .text "case"
.c771						nt_of:
>c771		02 0d				        .byte 2, IM+CO+NN
>c773		7b c7 d3 97 eb 97		        .word nt_endof, xt_of, z_of
>c779		6f 66				        .text "of"
.c77b						nt_endof:
>c77b		05 0d				        .byte 5, IM+CO+NN
>c77d		88 c7 74 8d ce 8d		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c783		65 6e 64 6f 66			        .text "endof"
.c788						nt_endcase:
>c788		07 0d				        .byte 7, IM+CO+NN
>c78a		97 c7 e5 8d f9 8d		        .word nt_defer_fetch, xt_endcase, z_endcase
>c790		65 6e 64 63 61 73 65		        .text "endcase"
.c797						nt_defer_fetch:
>c797		06 00				        .byte 6, 0
>c799		a5 c7 a6 8a ac 8a		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c79f		64 65 66 65 72 40		        .text "defer@"
.c7a5						nt_defer_store:
>c7a5		06 00				        .byte 6, 0
>c7a7		b3 c7 ad 8a b3 8a		        .word nt_is, xt_defer_store, z_defer_store
>c7ad		64 65 66 65 72 21		        .text "defer!"
.c7b3						nt_is:
>c7b3		02 04				        .byte 2, IM
>c7b5		bd c7 dc 92 f4 92		        .word nt_action_of, xt_is, z_is
>c7bb		69 73				        .text "is"
.c7bd						nt_action_of:
>c7bd		09 04				        .byte 9, IM
>c7bf		ce c7 04 82 1c 82		        .word nt_useraddr, xt_action_of, z_action_of
>c7c5		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c7cd		66
.c7ce						nt_useraddr:
>c7ce		08 00				        .byte 8, 0
>c7d0		de c7 1b a6 25 a6		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c7d6		75 73 65 72 61 64 64 72		        .text "useraddr"
.c7de						nt_buffer_colon:
>c7de		07 00				        .byte 7, 0
>c7e0		ed c7 9c 85 a2 85		        .word +, xt_buffer_colon, z_buffer_colon
>c7e6		62 75 66 66 65 72 3a		        .text "buffer:"
.c7ed						+
.c7ed						nt_buffstatus:
>c7ed		0a 00				        .byte 10, 0
>c7ef		ff c7 a3 85 b2 85		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c7f5		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c7fd		75 73
.c7ff						nt_buffblocknum:
>c7ff		0c 00				        .byte 12, 0
>c801		13 c8 5b 85 6a 85		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c807		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c80f		6b 6e 75 6d
.c813						nt_blkbuffer:
>c813		09 00				        .byte 9, 0
>c815		24 c8 69 83 76 83		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c81b		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c823		72
.c824						nt_scr:
>c824		03 00				        .byte 3, 0
>c826		2f c8 87 9e 96 9e		        .word nt_blk, xt_scr, z_scr
>c82c		73 63 72			        .text "scr"
.c82f						nt_blk:
>c82f		03 00				        .byte 3, 0
>c831		3a c8 59 83 68 83		        .word nt_block_write, xt_blk, z_blk
>c837		62 6c 6b			        .text "blk"
.c83a						nt_block_write:
>c83a		0b 08				        .byte 11, NN ; Deferred words need the HC (Code Field) flag.
>c83c		4d c8 16 85 24 85		        .word nt_block_write_vector, xt_block_write, z_block_write
>c842		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c84a		69 74 65
.c84d						nt_block_write_vector:
>c84d		12 08				        .byte 18, NN ; Deferred words need the HC (Code Field) flag.
>c84f		67 c8 24 85 33 85		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c855		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c85d		69 74 65 2d 76 65 63 74 6f 72
.c867						nt_block_read:
>c867		0a 28				        .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
>c869		79 c8 f3 84 01 85		        .word nt_block_read_vector, xt_block_read, z_block_read
>c86f		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c877		61 64
.c879						nt_block_read_vector:
>c879		11 28				        .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
>c87b		92 c8 01 85 10 85		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c881		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c889		61 64 2d 76 65 63 74 6f 72
.c892						nt_save_buffers:
>c892		0c 00				        .byte 12, 0
>c894		a6 c8 6c 9e 86 9e		        .word nt_block, xt_save_buffers, z_save_buffers
>c89a		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c8a2		66 65 72 73
.c8a6						nt_block:
>c8a6		05 00				        .byte 5, 0
>c8a8		b3 c8 77 83 c9 83		        .word nt_update, xt_block, z_block
>c8ae		62 6c 6f 63 6b			        .text "block"
.c8b3						nt_update:
>c8b3		06 00				        .byte 6, 0
>c8b5		c1 c8 12 a6 1a a6		        .word nt_buffer, xt_update, z_update
>c8bb		75 70 64 61 74 65		        .text "update"
.c8c1						nt_buffer:
>c8c1		06 00				        .byte 6, 0
>c8c3		cf c8 6b 85 9b 85		        .word nt_empty_buffers, xt_buffer, z_buffer
>c8c9		62 75 66 66 65 72		        .text "buffer"
.c8cf						nt_empty_buffers:
>c8cf		0d 00				        .byte 13, 0
>c8d1		e4 c8 de 8d e4 8d		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c8d7		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c8df		66 66 65 72 73
.c8e4						nt_flush:
>c8e4		05 00				        .byte 5, 0
>c8e6		f1 c8 6c 90 75 90		        .word nt_load, xt_flush, z_flush
>c8ec		66 6c 75 73 68			        .text "flush"
.c8f1						nt_load:
>c8f1		04 10				        .byte 4, UF
>c8f3		fd c8 98 93 db 93		        .word nt_thru, xt_load, z_load
>c8f9		6c 6f 61 64			        .text "load"
.c8fd						nt_thru:
>c8fd		04 10				        .byte 4, UF
>c8ff		09 c9 70 a1 b4 a1		        .word nt_list, xt_thru, z_thru
>c905		74 68 72 75			        .text "thru"
.c909						nt_list:
>c909		04 10				        .byte 4, UF
>c90b		15 c9 5e 93 6a 93		        .word +, xt_list, z_list
>c911		6c 69 73 74			        .text "list"
.c915						+
.c915						nt_block_ramdrive_init:
>c915		13 10				        .byte 19, UF
>c917		30 c9 ca 83 f2 84		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c91d		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c925		6d 64 72 69 76 65 2d 69 6e 69 74
.c930						+
.c930						nt_definitions:
>c930		0b 00				        .byte 11, 0
>c932		43 c9 b4 8a bc 8a		        .word nt_wordlist, xt_definitions, z_definitions
>c938		64 65 66 69 6e 69 74 69		        .text "definitions"
>c940		6f 6e 73
.c943						nt_wordlist:
>c943		08 00				        .byte 8, 0
>c945		53 c9 af a6 c5 a6		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c94b		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c953						nt_search_wordlist:
>c953		0f 10				        .byte 15, UF
>c955		6a c9 7d 9b 5d 9c		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c95b		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c963		6f 72 64 6c 69 73 74
.c96a						nt_set_current:
>c96a		0b 10				        .byte 11, UF
>c96c		7d c9 ec 9c f7 9c		        .word nt_get_current, xt_set_current, z_set_current
>c972		73 65 74 2d 63 75 72 72		        .text "set-current"
>c97a		65 6e 74
.c97d						nt_get_current:
>c97d		0b 00				        .byte 11, 0
>c97f		90 c9 0e 91 18 91		        .word nt_set_order, xt_get_current, z_get_current
>c985		67 65 74 2d 63 75 72 72		        .text "get-current"
>c98d		65 6e 74
.c990						nt_set_order:
>c990		09 00				        .byte 9, 0
>c992		a1 c9 f8 9c 2b 9d		        .word nt_get_order, xt_set_order, z_set_order
>c998		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c9a0		72
.c9a1						nt_get_order:
>c9a1		09 00				        .byte 9, 0
>c9a3		b2 c9 19 91 41 91		        .word nt_root_wordlist, xt_get_order, z_get_order
>c9a9		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c9b1		72
.c9b2						nt_root_wordlist:
>c9b2		0d 00				        .byte 13, 0
>c9b4		c7 c9 2b 9b 33 9b		        .word +, xt_root_wordlist, z_root_wordlist
>c9ba		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c9c2		64 6c 69 73 74
.c9c7						+
.c9c7						nt_assembler_wordlist:
>c9c7		12 00				        .byte 18, 0
>c9c9		e1 c9 4b a3 53 a3		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c9cf		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c9d7		72 2d 77 6f 72 64 6c 69 73 74
.c9e1						+
.c9e1						nt_editor_wordlist:
>c9e1		0f 00				        .byte 15, 0
>c9e3		f8 c9 ec 97 f4 97		        .word +, xt_editor_wordlist, z_editor_wordlist
>c9e9		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c9f1		6f 72 64 6c 69 73 74
.c9f8						+
.c9f8						nt_forth_wordlist:
>c9f8		0e 00				        .byte 14, 0
>c9fa		0e ca 56 a7 5c a7		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>ca00		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>ca08		72 64 6c 69 73 74
.ca0e						nt_only:
>ca0e		04 00				        .byte 4, 0
>ca10		1a ca 0b 98 16 98		        .word nt_also, xt_only, z_only
>ca16		6f 6e 6c 79			        .text "only"
.ca1a						nt_also:
>ca1a		04 00				        .byte 4, 0
>ca1c		26 ca b4 82 c3 82		        .word nt_previous, xt_also, z_also
>ca22		61 6c 73 6f			        .text "also"
.ca26						nt_previous:
>ca26		08 00				        .byte 8, 0
>ca28		36 ca 39 9a 45 9a		        .word nt_to_order, xt_previous, z_previous
>ca2e		70 72 65 76 69 6f 75 73		        .text "previous"
.ca36						nt_to_order:
>ca36		06 00				        .byte 6, 0
>ca38		44 ca 01 a3 13 a3		        .word nt_order, xt_to_order, z_to_order
>ca3e		3e 6f 72 64 65 72		        .text ">order"
.ca44						nt_order:
>ca44		05 00				        .byte 5, 0
>ca46		51 ca 29 98 53 98		        .word nt_forth, xt_order, z_order
>ca4c		6f 72 64 65 72			        .text "order"
.ca51						nt_forth:
>ca51		05 00				        .byte 5, 0
>ca53		5e ca ad 90 b3 90		        .word +, xt_forth, z_forth
>ca59		66 6f 72 74 68			        .text "forth"
.ca5e						+
>ca5e		03 08				nt_see: .byte 3, NN
>ca60		69 ca 5e 9c eb 9c		        .word +, xt_see, z_see
>ca66		73 65 65			        .text "see"
.ca69						+
.ca69						nt_ed:
>ca69		02 08				        .byte 2, NN
>ca6b		73 ca 70 8d 73 8d		        .word +, xt_ed, z_ed
>ca71		65 64				        .text "ed"
.ca73						+
.ca73						nt_cold:
>ca73		04 00				        .byte 4, 0
>ca75		7f ca 00 80 ad 80		        .word nt_bye, xt_cold, z_cold
>ca7b		63 6f 6c 64			        .text "cold"
.ca7f						nt_bye:
>ca7f		03				        .byte 3         ; length of word strings
>ca80		00				        .byte 0         ; status byte
>ca81		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>ca83		b3 85				        .word xt_bye    ; start of code block (xt of this word)
>ca85		b6 85				        .word z_bye     ; end of code (RTS)
>ca87		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.ca8a						root_dictionary_start:
.ca8a						nt_root_set_order:
>ca8a		09 00				        .byte 9, 0
>ca8c		9b ca f8 9c 2b 9d		        .word nt_root_forth, xt_set_order, z_set_order
>ca92		73 65 74 2d 6f 72 64 65		        .text "set-order"
>ca9a		72
.ca9b						nt_root_forth:
>ca9b		05 00				        .byte 5, 0
>ca9d		a8 ca ad 90 b3 90		        .word nt_root_forth_wordlist, xt_forth, z_forth
>caa3		66 6f 72 74 68			        .text "forth"
.caa8						nt_root_forth_wordlist:
>caa8		0e 00				        .byte 14, 0
>caaa		be ca 56 a7 5c a7		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>cab0		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>cab8		72 64 6c 69 73 74
.cabe						nt_root_words:
>cabe		05 00				        .byte 5, 0
>cac0		00 00 c6 a6 22 a7		        .word 0000, xt_words, z_words
>cac6		77 6f 72 64 73			        .text "words"
.cacb						editor_dictionary_start:
.cacb						nt_editor_o:
>cacb		01 00				        .byte 1, 0
>cacd		d4 ca 85 a8 ca a8		        .word nt_editor_line, xt_editor_o, z_editor_o
>cad3		6f				        .text "o"
.cad4						nt_editor_line:
>cad4		04 10				        .byte 4, UF
>cad6		e0 ca 6c a8 84 a8		        .word nt_editor_l, xt_editor_line, z_editor_line
>cadc		6c 69 6e 65			        .text "line"
.cae0						nt_editor_l:
>cae0		01 00				        .byte 1, 0
>cae2		e9 ca f0 a7 6b a8		        .word nt_editor_el, xt_editor_l, z_editor_l
>cae8		6c				        .text "l"
.cae9						nt_editor_el:
>cae9		02 00				        .byte 2, 0
>caeb		f3 ca de a7 ef a7		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>caf1		65 6c				        .text "el"
.caf3						nt_editor_erase_screen:
>caf3		0c 00				        .byte 12, 0
>caf5		07 cb cc a7 dd a7		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>cafb		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>cb03		72 65 65 6e
.cb07						nt_editor_enter_screen:
>cb07		0c 00				        .byte 12, 0
>cb09		00 00 b0 a7 cb a7		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>cb0f		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>cb17		72 65 65 6e
.cb1b						assembler_dictionary_start:
.cb1b						nt_asm_adc_h:
>cb1b		05 0c						.byte 5, IM+NN
>cb1d		28 cb				                .word nt_asm_adc_x
>cb1f		1f a9 24 a9					.word xt_asm_adc_h, z_asm_adc_h
>cb23		61 64 63 2e 23					.text "adc.#"
.cb28						nt_asm_adc_x:
>cb28		05 0c						.byte 5, IM+NN
>cb2a		35 cb				                .word nt_asm_adc_y
>cb2c		24 a9 29 a9					.word xt_asm_adc_x, z_asm_adc_x
>cb30		61 64 63 2e 78					.text "adc.x"
.cb35						nt_asm_adc_y:
>cb35		05 0c						.byte 5, IM+NN
>cb37		42 cb				                .word nt_asm_adc_z
>cb39		29 a9 2e a9					.word xt_asm_adc_y, z_asm_adc_y
>cb3d		61 64 63 2e 79					.text "adc.y"
.cb42						nt_asm_adc_z:
>cb42		05 0c						.byte 5, IM+NN
>cb44		4f cb				                .word nt_asm_adc_zi
>cb46		2e a9 33 a9					.word xt_asm_adc_z, z_asm_adc_z
>cb4a		61 64 63 2e 7a					.text "adc.z"
.cb4f						nt_asm_adc_zi:
>cb4f		06 0c						.byte 6, IM+NN
>cb51		5d cb				                .word nt_asm_adc_ziy
>cb53		33 a9 38 a9					.word xt_asm_adc_zi, z_asm_adc_zi
>cb57		61 64 63 2e 7a 69				.text "adc.zi"
.cb5d						nt_asm_adc_ziy:
>cb5d		07 0c						.byte 7, IM+NN
>cb5f		6c cb				                .word nt_asm_adc_zx
>cb61		38 a9 3d a9					.word xt_asm_adc_ziy, z_asm_adc_ziy
>cb65		61 64 63 2e 7a 69 79				.text "adc.ziy"
.cb6c						nt_asm_adc_zx:
>cb6c		06 0c						.byte 6, IM+NN
>cb6e		7a cb				                .word nt_asm_adc_zxi
>cb70		3d a9 42 a9					.word xt_asm_adc_zx, z_asm_adc_zx
>cb74		61 64 63 2e 7a 78				.text "adc.zx"
.cb7a						nt_asm_adc_zxi:
>cb7a		07 0c						.byte 7, IM+NN
>cb7c		89 cb				                .word nt_asm_and
>cb7e		42 a9 47 a9					.word xt_asm_adc_zxi, z_asm_adc_zxi
>cb82		61 64 63 2e 7a 78 69				.text "adc.zxi"
.cb89						nt_asm_and:
>cb89		04 0c						.byte 4, IM+NN
>cb8b		95 cb				                .word nt_asm_and_h
>cb8d		47 a9 4c a9					.word xt_asm_and, z_asm_and
>cb91		61 6e 64 2e					.text "and."
.cb95						nt_asm_and_h:
>cb95		05 0c						.byte 5, IM+NN
>cb97		a2 cb				                .word nt_asm_and_x
>cb99		4c a9 51 a9					.word xt_asm_and_h, z_asm_and_h
>cb9d		61 6e 64 2e 23					.text "and.#"
.cba2						nt_asm_and_x:
>cba2		05 0c						.byte 5, IM+NN
>cba4		af cb				                .word nt_asm_and_y
>cba6		51 a9 56 a9					.word xt_asm_and_x, z_asm_and_x
>cbaa		61 6e 64 2e 78					.text "and.x"
.cbaf						nt_asm_and_y:
>cbaf		05 0c						.byte 5, IM+NN
>cbb1		bc cb				                .word nt_asm_and_z
>cbb3		56 a9 5b a9					.word xt_asm_and_y, z_asm_and_y
>cbb7		61 6e 64 2e 79					.text "and.y"
.cbbc						nt_asm_and_z:
>cbbc		05 0c						.byte 5, IM+NN
>cbbe		c9 cb				                .word nt_asm_and_zi
>cbc0		5b a9 60 a9					.word xt_asm_and_z, z_asm_and_z
>cbc4		61 6e 64 2e 7a					.text "and.z"
.cbc9						nt_asm_and_zi:
>cbc9		06 0c						.byte 6, IM+NN
>cbcb		d7 cb				                .word nt_asm_and_ziy
>cbcd		60 a9 65 a9					.word xt_asm_and_zi, z_asm_and_zi
>cbd1		61 6e 64 2e 7a 69				.text "and.zi"
.cbd7						nt_asm_and_ziy:
>cbd7		07 0c						.byte 7, IM+NN
>cbd9		e6 cb				                .word nt_asm_and_zx
>cbdb		65 a9 6a a9					.word xt_asm_and_ziy, z_asm_and_ziy
>cbdf		61 6e 64 2e 7a 69 79				.text "and.ziy"
.cbe6						nt_asm_and_zx:
>cbe6		06 0c						.byte 6, IM+NN
>cbe8		f4 cb				                .word nt_asm_and_zxi
>cbea		6a a9 6f a9					.word xt_asm_and_zx, z_asm_and_zx
>cbee		61 6e 64 2e 7a 78				.text "and.zx"
.cbf4						nt_asm_and_zxi:
>cbf4		07 0c						.byte 7, IM+NN
>cbf6		03 cc				                .word nt_asm_asl
>cbf8		6f a9 74 a9					.word xt_asm_and_zxi, z_asm_and_zxi
>cbfc		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cc03						nt_asm_asl:
>cc03		03 0c						.byte 3, IM+NN
>cc05		0e cc				                .word nt_asm_asl_a
>cc07		74 a9 79 a9					.word xt_asm_asl, z_asm_asl
>cc0b		61 73 6c					.text "asl"
.cc0e						nt_asm_asl_a:
>cc0e		05 0c						.byte 5, IM+NN
>cc10		1b cc				                .word nt_asm_asl_x
>cc12		79 a9 7e a9					.word xt_asm_asl_a, z_asm_asl_a
>cc16		61 73 6c 2e 61					.text "asl.a"
.cc1b						nt_asm_asl_x:
>cc1b		05 0c						.byte 5, IM+NN
>cc1d		28 cc				                .word nt_asm_asl_z
>cc1f		7e a9 83 a9					.word xt_asm_asl_x, z_asm_asl_x
>cc23		61 73 6c 2e 78					.text "asl.x"
.cc28						nt_asm_asl_z:
>cc28		05 0c						.byte 5, IM+NN
>cc2a		35 cc				                .word nt_asm_asl_zx
>cc2c		83 a9 88 a9					.word xt_asm_asl_z, z_asm_asl_z
>cc30		61 73 6c 2e 7a					.text "asl.z"
.cc35						nt_asm_asl_zx:
>cc35		06 0c						.byte 6, IM+NN
>cc37		43 cc				                .word nt_asm_bcc
>cc39		88 a9 8d a9					.word xt_asm_asl_zx, z_asm_asl_zx
>cc3d		61 73 6c 2e 7a 78				.text "asl.zx"
.cc43						nt_asm_bcc:
>cc43		03 0c						.byte 3, IM+NN
>cc45		4e cc				                .word nt_asm_bcs
>cc47		8d a9 92 a9					.word xt_asm_bcc, z_asm_bcc
>cc4b		62 63 63					.text "bcc"
.cc4e						nt_asm_bcs:
>cc4e		03 0c						.byte 3, IM+NN
>cc50		59 cc				                .word nt_asm_beq
>cc52		92 a9 99 a9					.word xt_asm_bcs, z_asm_bcs
>cc56		62 63 73					.text "bcs"
.cc59						nt_asm_beq:
>cc59		03 0c						.byte 3, IM+NN
>cc5b		64 cc				                .word nt_asm_bit
>cc5d		99 a9 9e a9					.word xt_asm_beq, z_asm_beq
>cc61		62 65 71					.text "beq"
.cc64						nt_asm_bit:
>cc64		03 0c						.byte 3, IM+NN
>cc66		6f cc				                .word nt_asm_bit_h
>cc68		9e a9 a3 a9					.word xt_asm_bit, z_asm_bit
>cc6c		62 69 74					.text "bit"
.cc6f						nt_asm_bit_h:
>cc6f		05 0c						.byte 5, IM+NN
>cc71		7c cc				                .word nt_asm_bit_x
>cc73		a3 a9 a8 a9					.word xt_asm_bit_h, z_asm_bit_h
>cc77		62 69 74 2e 23					.text "bit.#"
.cc7c						nt_asm_bit_x:
>cc7c		05 0c						.byte 5, IM+NN
>cc7e		89 cc				                .word nt_asm_bit_z
>cc80		a8 a9 ad a9					.word xt_asm_bit_x, z_asm_bit_x
>cc84		62 69 74 2e 78					.text "bit.x"
.cc89						nt_asm_bit_z:
>cc89		05 0c						.byte 5, IM+NN
>cc8b		96 cc				                .word nt_asm_bit_zx
>cc8d		ad a9 b2 a9					.word xt_asm_bit_z, z_asm_bit_z
>cc91		62 69 74 2e 7a					.text "bit.z"
.cc96						nt_asm_bit_zx:
>cc96		06 0c						.byte 6, IM+NN
>cc98		a4 cc				                .word nt_asm_bmi
>cc9a		b2 a9 b7 a9					.word xt_asm_bit_zx, z_asm_bit_zx
>cc9e		62 69 74 2e 7a 78				.text "bit.zx"
.cca4						nt_asm_bmi:
>cca4		03 0c						.byte 3, IM+NN
>cca6		af cc				                .word nt_asm_bne
>cca8		b7 a9 bc a9					.word xt_asm_bmi, z_asm_bmi
>ccac		62 6d 69					.text "bmi"
.ccaf						nt_asm_bne:
>ccaf		03 0c						.byte 3, IM+NN
>ccb1		ba cc				                .word nt_asm_bpl
>ccb3		bc a9 c1 a9					.word xt_asm_bne, z_asm_bne
>ccb7		62 6e 65					.text "bne"
.ccba						nt_asm_bpl:
>ccba		03 0c						.byte 3, IM+NN
>ccbc		c5 cc				                .word nt_asm_bra
>ccbe		c1 a9 c6 a9					.word xt_asm_bpl, z_asm_bpl
>ccc2		62 70 6c					.text "bpl"
.ccc5						nt_asm_bra:
>ccc5		03 0c						.byte 3, IM+NN
>ccc7		d0 cc				                .word nt_asm_brk
>ccc9		c6 a9 cb a9					.word xt_asm_bra, z_asm_bra
>cccd		62 72 61					.text "bra"
.ccd0						nt_asm_brk:
>ccd0		03 0c						.byte 3, IM+NN
>ccd2		db cc				                .word nt_asm_bvc
>ccd4		cb a9 d0 a9					.word xt_asm_brk, z_asm_brk
>ccd8		62 72 6b					.text "brk"
.ccdb						nt_asm_bvc:
>ccdb		03 0c						.byte 3, IM+NN
>ccdd		e6 cc				                .word nt_asm_bvs
>ccdf		d0 a9 d5 a9					.word xt_asm_bvc, z_asm_bvc
>cce3		62 76 63					.text "bvc"
.cce6						nt_asm_bvs:
>cce6		03 0c						.byte 3, IM+NN
>cce8		f1 cc				                .word nt_asm_clc
>ccea		d5 a9 da a9					.word xt_asm_bvs, z_asm_bvs
>ccee		62 76 73					.text "bvs"
.ccf1						nt_asm_clc:
>ccf1		03 0c						.byte 3, IM+NN
>ccf3		fc cc				                .word nt_asm_cld
>ccf5		da a9 df a9					.word xt_asm_clc, z_asm_clc
>ccf9		63 6c 63					.text "clc"
.ccfc						nt_asm_cld:
>ccfc		03 0c						.byte 3, IM+NN
>ccfe		07 cd				                .word nt_asm_cli
>cd00		df a9 e4 a9					.word xt_asm_cld, z_asm_cld
>cd04		63 6c 64					.text "cld"
.cd07						nt_asm_cli:
>cd07		03 0c						.byte 3, IM+NN
>cd09		12 cd				                .word nt_asm_clv
>cd0b		e4 a9 e9 a9					.word xt_asm_cli, z_asm_cli
>cd0f		63 6c 69					.text "cli"
.cd12						nt_asm_clv:
>cd12		03 0c						.byte 3, IM+NN
>cd14		1d cd				                .word nt_asm_cmp
>cd16		e9 a9 ee a9					.word xt_asm_clv, z_asm_clv
>cd1a		63 6c 76					.text "clv"
.cd1d						nt_asm_cmp:
>cd1d		03 0c						.byte 3, IM+NN
>cd1f		28 cd				                .word nt_asm_cmp_h
>cd21		ee a9 f3 a9					.word xt_asm_cmp, z_asm_cmp
>cd25		63 6d 70					.text "cmp"
.cd28						nt_asm_cmp_h:
>cd28		05 0c						.byte 5, IM+NN
>cd2a		35 cd				                .word nt_asm_cmp_x
>cd2c		f3 a9 f8 a9					.word xt_asm_cmp_h, z_asm_cmp_h
>cd30		63 6d 70 2e 23					.text "cmp.#"
.cd35						nt_asm_cmp_x:
>cd35		05 0c						.byte 5, IM+NN
>cd37		42 cd				                .word nt_asm_cmp_y
>cd39		f8 a9 fd a9					.word xt_asm_cmp_x, z_asm_cmp_x
>cd3d		63 6d 70 2e 78					.text "cmp.x"
.cd42						nt_asm_cmp_y:
>cd42		05 0c						.byte 5, IM+NN
>cd44		4f cd				                .word nt_asm_cmp_z
>cd46		fd a9 02 aa					.word xt_asm_cmp_y, z_asm_cmp_y
>cd4a		63 6d 70 2e 79					.text "cmp.y"
.cd4f						nt_asm_cmp_z:
>cd4f		05 0c						.byte 5, IM+NN
>cd51		5c cd				                .word nt_asm_cmp_zi
>cd53		02 aa 07 aa					.word xt_asm_cmp_z, z_asm_cmp_z
>cd57		63 6d 70 2e 7a					.text "cmp.z"
.cd5c						nt_asm_cmp_zi:
>cd5c		06 0c						.byte 6, IM+NN
>cd5e		6a cd				                .word nt_asm_cmp_ziy
>cd60		07 aa 0c aa					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cd64		63 6d 70 2e 7a 69				.text "cmp.zi"
.cd6a						nt_asm_cmp_ziy:
>cd6a		07 0c						.byte 7, IM+NN
>cd6c		79 cd				                .word nt_asm_cmp_zx
>cd6e		0c aa 11 aa					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cd72		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cd79						nt_asm_cmp_zx:
>cd79		06 0c						.byte 6, IM+NN
>cd7b		87 cd				                .word nt_asm_cmp_zxi
>cd7d		11 aa 16 aa					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cd81		63 6d 70 2e 7a 78				.text "cmp.zx"
.cd87						nt_asm_cmp_zxi:
>cd87		07 0c						.byte 7, IM+NN
>cd89		96 cd				                .word nt_asm_cpx
>cd8b		16 aa 1b aa					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cd8f		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cd96						nt_asm_cpx:
>cd96		03 0c						.byte 3, IM+NN
>cd98		a1 cd				                .word nt_asm_cpx_h
>cd9a		1b aa 20 aa					.word xt_asm_cpx, z_asm_cpx
>cd9e		63 70 78					.text "cpx"
.cda1						nt_asm_cpx_h:
>cda1		05 0c						.byte 5, IM+NN
>cda3		ae cd				                .word nt_asm_cpx_z
>cda5		20 aa 25 aa					.word xt_asm_cpx_h, z_asm_cpx_h
>cda9		63 70 78 2e 23					.text "cpx.#"
.cdae						nt_asm_cpx_z:
>cdae		05 0c						.byte 5, IM+NN
>cdb0		bb cd				                .word nt_asm_cpy
>cdb2		25 aa 2a aa					.word xt_asm_cpx_z, z_asm_cpx_z
>cdb6		63 70 78 2e 7a					.text "cpx.z"
.cdbb						nt_asm_cpy:
>cdbb		03 0c						.byte 3, IM+NN
>cdbd		c6 cd				                .word nt_asm_cpy_h
>cdbf		2a aa 31 aa					.word xt_asm_cpy, z_asm_cpy
>cdc3		63 70 79					.text "cpy"
.cdc6						nt_asm_cpy_h:
>cdc6		05 0c						.byte 5, IM+NN
>cdc8		d3 cd				                .word nt_asm_cpy_z
>cdca		31 aa 36 aa					.word xt_asm_cpy_h, z_asm_cpy_h
>cdce		63 70 79 2e 23					.text "cpy.#"
.cdd3						nt_asm_cpy_z:
>cdd3		05 0c						.byte 5, IM+NN
>cdd5		e0 cd				                .word nt_asm_dec
>cdd7		36 aa 3b aa					.word xt_asm_cpy_z, z_asm_cpy_z
>cddb		63 70 79 2e 7a					.text "cpy.z"
.cde0						nt_asm_dec:
>cde0		03 0c						.byte 3, IM+NN
>cde2		eb cd				                .word nt_asm_dec_a
>cde4		3b aa 40 aa					.word xt_asm_dec, z_asm_dec
>cde8		64 65 63					.text "dec"
.cdeb						nt_asm_dec_a:
>cdeb		05 0c						.byte 5, IM+NN
>cded		f8 cd				                .word nt_asm_dec_x
>cdef		40 aa 45 aa					.word xt_asm_dec_a, z_asm_dec_a
>cdf3		64 65 63 2e 61					.text "dec.a"
.cdf8						nt_asm_dec_x:
>cdf8		05 0c						.byte 5, IM+NN
>cdfa		05 ce				                .word nt_asm_dec_z
>cdfc		45 aa 4a aa					.word xt_asm_dec_x, z_asm_dec_x
>ce00		64 65 63 2e 78					.text "dec.x"
.ce05						nt_asm_dec_z:
>ce05		05 0c						.byte 5, IM+NN
>ce07		12 ce				                .word nt_asm_dec_zx
>ce09		4a aa 4f aa					.word xt_asm_dec_z, z_asm_dec_z
>ce0d		64 65 63 2e 7a					.text "dec.z"
.ce12						nt_asm_dec_zx:
>ce12		06 0c						.byte 6, IM+NN
>ce14		20 ce				                .word nt_asm_dex
>ce16		4f aa 54 aa					.word xt_asm_dec_zx, z_asm_dec_zx
>ce1a		64 65 63 2e 7a 78				.text "dec.zx"
.ce20						nt_asm_dex:
>ce20		03 0c						.byte 3, IM+NN
>ce22		2b ce				                .word nt_asm_dey
>ce24		54 aa 59 aa					.word xt_asm_dex, z_asm_dex
>ce28		64 65 78					.text "dex"
.ce2b						nt_asm_dey:
>ce2b		03 0c						.byte 3, IM+NN
>ce2d		36 ce				                .word nt_asm_eor
>ce2f		59 aa 5e aa					.word xt_asm_dey, z_asm_dey
>ce33		64 65 79					.text "dey"
.ce36						nt_asm_eor:
>ce36		03 0c						.byte 3, IM+NN
>ce38		41 ce				                .word nt_asm_eor_h
>ce3a		5e aa 63 aa					.word xt_asm_eor, z_asm_eor
>ce3e		65 6f 72					.text "eor"
.ce41						nt_asm_eor_h:
>ce41		05 0c						.byte 5, IM+NN
>ce43		4e ce				                .word nt_asm_eor_x
>ce45		63 aa 68 aa					.word xt_asm_eor_h, z_asm_eor_h
>ce49		65 6f 72 2e 23					.text "eor.#"
.ce4e						nt_asm_eor_x:
>ce4e		05 0c						.byte 5, IM+NN
>ce50		5b ce				                .word nt_asm_eor_y
>ce52		68 aa 6d aa					.word xt_asm_eor_x, z_asm_eor_x
>ce56		65 6f 72 2e 78					.text "eor.x"
.ce5b						nt_asm_eor_y:
>ce5b		05 0c						.byte 5, IM+NN
>ce5d		68 ce				                .word nt_asm_eor_z
>ce5f		6d aa 72 aa					.word xt_asm_eor_y, z_asm_eor_y
>ce63		65 6f 72 2e 79					.text "eor.y"
.ce68						nt_asm_eor_z:
>ce68		05 0c						.byte 5, IM+NN
>ce6a		75 ce				                .word nt_asm_eor_zi
>ce6c		72 aa 77 aa					.word xt_asm_eor_z, z_asm_eor_z
>ce70		65 6f 72 2e 7a					.text "eor.z"
.ce75						nt_asm_eor_zi:
>ce75		06 0c						.byte 6, IM+NN
>ce77		83 ce				                .word nt_asm_eor_ziy
>ce79		77 aa 7c aa					.word xt_asm_eor_zi, z_asm_eor_zi
>ce7d		65 6f 72 2e 7a 69				.text "eor.zi"
.ce83						nt_asm_eor_ziy:
>ce83		07 0c						.byte 7, IM+NN
>ce85		92 ce				                .word nt_asm_eor_zx
>ce87		7c aa 81 aa					.word xt_asm_eor_ziy, z_asm_eor_ziy
>ce8b		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.ce92						nt_asm_eor_zx:
>ce92		06 0c						.byte 6, IM+NN
>ce94		a0 ce				                .word nt_asm_eor_zxi
>ce96		81 aa 86 aa					.word xt_asm_eor_zx, z_asm_eor_zx
>ce9a		65 6f 72 2e 7a 78				.text "eor.zx"
.cea0						nt_asm_eor_zxi:
>cea0		07 0c						.byte 7, IM+NN
>cea2		af ce				                .word nt_asm_inc
>cea4		86 aa 8b aa					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cea8		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.ceaf						nt_asm_inc:
>ceaf		03 0c						.byte 3, IM+NN
>ceb1		ba ce				                .word nt_asm_inc_a
>ceb3		8b aa 90 aa					.word xt_asm_inc, z_asm_inc
>ceb7		69 6e 63					.text "inc"
.ceba						nt_asm_inc_a:
>ceba		05 0c						.byte 5, IM+NN
>cebc		c7 ce				                .word nt_asm_inc_x
>cebe		90 aa 95 aa					.word xt_asm_inc_a, z_asm_inc_a
>cec2		69 6e 63 2e 61					.text "inc.a"
.cec7						nt_asm_inc_x:
>cec7		05 0c						.byte 5, IM+NN
>cec9		d4 ce				                .word nt_asm_inc_z
>cecb		95 aa 9a aa					.word xt_asm_inc_x, z_asm_inc_x
>cecf		69 6e 63 2e 78					.text "inc.x"
.ced4						nt_asm_inc_z:
>ced4		05 0c						.byte 5, IM+NN
>ced6		e1 ce				                .word nt_asm_inc_zx
>ced8		9a aa 9f aa					.word xt_asm_inc_z, z_asm_inc_z
>cedc		69 6e 63 2e 7a					.text "inc.z"
.cee1						nt_asm_inc_zx:
>cee1		06 0c						.byte 6, IM+NN
>cee3		ef ce				                .word nt_asm_inx
>cee5		9f aa a4 aa					.word xt_asm_inc_zx, z_asm_inc_zx
>cee9		69 6e 63 2e 7a 78				.text "inc.zx"
.ceef						nt_asm_inx:
>ceef		03 0c						.byte 3, IM+NN
>cef1		fa ce				                .word nt_asm_iny
>cef3		a4 aa a9 aa					.word xt_asm_inx, z_asm_inx
>cef7		69 6e 78					.text "inx"
.cefa						nt_asm_iny:
>cefa		03 0c						.byte 3, IM+NN
>cefc		05 cf				                .word nt_asm_jmp
>cefe		a9 aa ae aa					.word xt_asm_iny, z_asm_iny
>cf02		69 6e 79					.text "iny"
.cf05						nt_asm_jmp:
>cf05		03 0c						.byte 3, IM+NN
>cf07		10 cf				                .word nt_asm_jmp_i
>cf09		ae aa b3 aa					.word xt_asm_jmp, z_asm_jmp
>cf0d		6a 6d 70					.text "jmp"
.cf10						nt_asm_jmp_i:
>cf10		05 0c						.byte 5, IM+NN
>cf12		1d cf				                .word nt_asm_jmp_xi
>cf14		b3 aa b8 aa					.word xt_asm_jmp_i, z_asm_jmp_i
>cf18		6a 6d 70 2e 69					.text "jmp.i"
.cf1d						nt_asm_jmp_xi:
>cf1d		06 0c						.byte 6, IM+NN
>cf1f		2b cf				                .word nt_asm_jsr
>cf21		b8 aa bd aa					.word xt_asm_jmp_xi, z_asm_jmp_xi
>cf25		6a 6d 70 2e 78 69				.text "jmp.xi"
.cf2b						nt_asm_jsr:
>cf2b		03 0c						.byte 3, IM+NN
>cf2d		36 cf				                .word nt_asm_lda
>cf2f		bd aa c2 aa					.word xt_asm_jsr, z_asm_jsr
>cf33		6a 73 72					.text "jsr"
.cf36						nt_asm_lda:
>cf36		03 0c						.byte 3, IM+NN
>cf38		41 cf				                .word nt_asm_lda_h
>cf3a		c2 aa c7 aa					.word xt_asm_lda, z_asm_lda
>cf3e		6c 64 61					.text "lda"
.cf41						nt_asm_lda_h:
>cf41		05 0c						.byte 5, IM+NN
>cf43		4e cf				                .word nt_asm_lda_x
>cf45		c7 aa cc aa					.word xt_asm_lda_h, z_asm_lda_h
>cf49		6c 64 61 2e 23					.text "lda.#"
.cf4e						nt_asm_lda_x:
>cf4e		05 0c						.byte 5, IM+NN
>cf50		5b cf				                .word nt_asm_lda_y
>cf52		cc aa d1 aa					.word xt_asm_lda_x, z_asm_lda_x
>cf56		6c 64 61 2e 78					.text "lda.x"
.cf5b						nt_asm_lda_y:
>cf5b		05 0c						.byte 5, IM+NN
>cf5d		68 cf				                .word nt_asm_lda_z
>cf5f		d1 aa d6 aa					.word xt_asm_lda_y, z_asm_lda_y
>cf63		6c 64 61 2e 79					.text "lda.y"
.cf68						nt_asm_lda_z:
>cf68		05 0c						.byte 5, IM+NN
>cf6a		75 cf				                .word nt_asm_lda_zi
>cf6c		d6 aa db aa					.word xt_asm_lda_z, z_asm_lda_z
>cf70		6c 64 61 2e 7a					.text "lda.z"
.cf75						nt_asm_lda_zi:
>cf75		06 0c						.byte 6, IM+NN
>cf77		83 cf				                .word nt_asm_lda_ziy
>cf79		db aa e0 aa					.word xt_asm_lda_zi, z_asm_lda_zi
>cf7d		6c 64 61 2e 7a 69				.text "lda.zi"
.cf83						nt_asm_lda_ziy:
>cf83		07 0c						.byte 7, IM+NN
>cf85		92 cf				                .word nt_asm_lda_zx
>cf87		e0 aa e5 aa					.word xt_asm_lda_ziy, z_asm_lda_ziy
>cf8b		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cf92						nt_asm_lda_zx:
>cf92		06 0c						.byte 6, IM+NN
>cf94		a0 cf				                .word nt_asm_lda_zxi
>cf96		e5 aa ea aa					.word xt_asm_lda_zx, z_asm_lda_zx
>cf9a		6c 64 61 2e 7a 78				.text "lda.zx"
.cfa0						nt_asm_lda_zxi:
>cfa0		07 0c						.byte 7, IM+NN
>cfa2		af cf				                .word nt_asm_ldx
>cfa4		ea aa ef aa					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cfa8		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cfaf						nt_asm_ldx:
>cfaf		03 0c						.byte 3, IM+NN
>cfb1		ba cf				                .word nt_asm_ldx_h
>cfb3		ef aa f4 aa					.word xt_asm_ldx, z_asm_ldx
>cfb7		6c 64 78					.text "ldx"
.cfba						nt_asm_ldx_h:
>cfba		05 0c						.byte 5, IM+NN
>cfbc		c7 cf				                .word nt_asm_ldx_y
>cfbe		f4 aa f9 aa					.word xt_asm_ldx_h, z_asm_ldx_h
>cfc2		6c 64 78 2e 23					.text "ldx.#"
.cfc7						nt_asm_ldx_y:
>cfc7		05 0c						.byte 5, IM+NN
>cfc9		d4 cf				                .word nt_asm_ldx_z
>cfcb		f9 aa fe aa					.word xt_asm_ldx_y, z_asm_ldx_y
>cfcf		6c 64 78 2e 79					.text "ldx.y"
.cfd4						nt_asm_ldx_z:
>cfd4		05 0c						.byte 5, IM+NN
>cfd6		e1 cf				                .word nt_asm_ldx_zy
>cfd8		fe aa 03 ab					.word xt_asm_ldx_z, z_asm_ldx_z
>cfdc		6c 64 78 2e 7a					.text "ldx.z"
.cfe1						nt_asm_ldx_zy:
>cfe1		06 0c						.byte 6, IM+NN
>cfe3		ef cf				                .word nt_asm_ldy
>cfe5		03 ab 08 ab					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cfe9		6c 64 78 2e 7a 79				.text "ldx.zy"
.cfef						nt_asm_ldy:
>cfef		03 0c						.byte 3, IM+NN
>cff1		fa cf				                .word nt_asm_ldy_h
>cff3		08 ab 0d ab					.word xt_asm_ldy, z_asm_ldy
>cff7		6c 64 79					.text "ldy"
.cffa						nt_asm_ldy_h:
>cffa		05 0c						.byte 5, IM+NN
>cffc		07 d0				                .word nt_asm_ldy_x
>cffe		0d ab 12 ab					.word xt_asm_ldy_h, z_asm_ldy_h
>d002		6c 64 79 2e 23					.text "ldy.#"
.d007						nt_asm_ldy_x:
>d007		05 0c						.byte 5, IM+NN
>d009		14 d0				                .word nt_asm_ldy_z
>d00b		12 ab 17 ab					.word xt_asm_ldy_x, z_asm_ldy_x
>d00f		6c 64 79 2e 78					.text "ldy.x"
.d014						nt_asm_ldy_z:
>d014		05 0c						.byte 5, IM+NN
>d016		21 d0				                .word nt_asm_ldy_zx
>d018		17 ab 1c ab					.word xt_asm_ldy_z, z_asm_ldy_z
>d01c		6c 64 79 2e 7a					.text "ldy.z"
.d021						nt_asm_ldy_zx:
>d021		06 0c						.byte 6, IM+NN
>d023		2f d0				                .word nt_asm_lsr
>d025		1c ab 21 ab					.word xt_asm_ldy_zx, z_asm_ldy_zx
>d029		6c 64 79 2e 7a 78				.text "ldy.zx"
.d02f						nt_asm_lsr:
>d02f		03 0c						.byte 3, IM+NN
>d031		3a d0				                .word nt_asm_lsr_a
>d033		21 ab 26 ab					.word xt_asm_lsr, z_asm_lsr
>d037		6c 73 72					.text "lsr"
.d03a						nt_asm_lsr_a:
>d03a		05 0c						.byte 5, IM+NN
>d03c		47 d0				                .word nt_asm_lsr_x
>d03e		26 ab 2b ab					.word xt_asm_lsr_a, z_asm_lsr_a
>d042		6c 73 72 2e 61					.text "lsr.a"
.d047						nt_asm_lsr_x:
>d047		05 0c						.byte 5, IM+NN
>d049		54 d0				                .word nt_asm_lsr_z
>d04b		2b ab 30 ab					.word xt_asm_lsr_x, z_asm_lsr_x
>d04f		6c 73 72 2e 78					.text "lsr.x"
.d054						nt_asm_lsr_z:
>d054		05 0c						.byte 5, IM+NN
>d056		61 d0				                .word nt_asm_lsr_zx
>d058		30 ab 35 ab					.word xt_asm_lsr_z, z_asm_lsr_z
>d05c		6c 73 72 2e 7a					.text "lsr.z"
.d061						nt_asm_lsr_zx:
>d061		06 0c						.byte 6, IM+NN
>d063		6f d0				                .word nt_asm_nop
>d065		35 ab 3a ab					.word xt_asm_lsr_zx, z_asm_lsr_zx
>d069		6c 73 72 2e 7a 78				.text "lsr.zx"
.d06f						nt_asm_nop:
>d06f		03 0c						.byte 3, IM+NN
>d071		7a d0				                .word nt_asm_ora
>d073		3a ab 3f ab					.word xt_asm_nop, z_asm_nop
>d077		6e 6f 70					.text "nop"
.d07a						nt_asm_ora:
>d07a		03 0c						.byte 3, IM+NN
>d07c		85 d0				                .word nt_asm_ora_h
>d07e		3f ab 44 ab					.word xt_asm_ora, z_asm_ora
>d082		6f 72 61					.text "ora"
.d085						nt_asm_ora_h:
>d085		05 0c						.byte 5, IM+NN
>d087		92 d0				                .word nt_asm_ora_x
>d089		44 ab 49 ab					.word xt_asm_ora_h, z_asm_ora_h
>d08d		6f 72 61 2e 23					.text "ora.#"
.d092						nt_asm_ora_x:
>d092		05 0c						.byte 5, IM+NN
>d094		9f d0				                .word nt_asm_ora_y
>d096		49 ab 4e ab					.word xt_asm_ora_x, z_asm_ora_x
>d09a		6f 72 61 2e 78					.text "ora.x"
.d09f						nt_asm_ora_y:
>d09f		05 0c						.byte 5, IM+NN
>d0a1		ac d0				                .word nt_asm_ora_z
>d0a3		4e ab 53 ab					.word xt_asm_ora_y, z_asm_ora_y
>d0a7		6f 72 61 2e 79					.text "ora.y"
.d0ac						nt_asm_ora_z:
>d0ac		05 0c						.byte 5, IM+NN
>d0ae		b9 d0				                .word nt_asm_ora_zi
>d0b0		53 ab 58 ab					.word xt_asm_ora_z, z_asm_ora_z
>d0b4		6f 72 61 2e 7a					.text "ora.z"
.d0b9						nt_asm_ora_zi:
>d0b9		06 0c						.byte 6, IM+NN
>d0bb		c7 d0				                .word nt_asm_ora_ziy
>d0bd		58 ab 5f ab					.word xt_asm_ora_zi, z_asm_ora_zi
>d0c1		6f 72 61 2e 7a 69				.text "ora.zi"
.d0c7						nt_asm_ora_ziy:
>d0c7		07 0c						.byte 7, IM+NN
>d0c9		d6 d0				                .word nt_asm_ora_zx
>d0cb		5f ab 64 ab					.word xt_asm_ora_ziy, z_asm_ora_ziy
>d0cf		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.d0d6						nt_asm_ora_zx:
>d0d6		06 0c						.byte 6, IM+NN
>d0d8		e4 d0				                .word nt_asm_ora_zxi
>d0da		64 ab 69 ab					.word xt_asm_ora_zx, z_asm_ora_zx
>d0de		6f 72 61 2e 7a 78				.text "ora.zx"
.d0e4						nt_asm_ora_zxi:
>d0e4		07 0c						.byte 7, IM+NN
>d0e6		f3 d0				                .word nt_asm_pha
>d0e8		69 ab 6e ab					.word xt_asm_ora_zxi, z_asm_ora_zxi
>d0ec		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d0f3						nt_asm_pha:
>d0f3		03 0c						.byte 3, IM+NN
>d0f5		fe d0				                .word nt_asm_php
>d0f7		6e ab 73 ab					.word xt_asm_pha, z_asm_pha
>d0fb		70 68 61					.text "pha"
.d0fe						nt_asm_php:
>d0fe		03 0c						.byte 3, IM+NN
>d100		09 d1				                .word nt_asm_phx
>d102		73 ab 78 ab					.word xt_asm_php, z_asm_php
>d106		70 68 70					.text "php"
.d109						nt_asm_phx:
>d109		03 0c						.byte 3, IM+NN
>d10b		14 d1				                .word nt_asm_phy
>d10d		78 ab 7d ab					.word xt_asm_phx, z_asm_phx
>d111		70 68 78					.text "phx"
.d114						nt_asm_phy:
>d114		03 0c						.byte 3, IM+NN
>d116		1f d1				                .word nt_asm_pla
>d118		7d ab 82 ab					.word xt_asm_phy, z_asm_phy
>d11c		70 68 79					.text "phy"
.d11f						nt_asm_pla:
>d11f		03 0c						.byte 3, IM+NN
>d121		2a d1				                .word nt_asm_plp
>d123		82 ab 87 ab					.word xt_asm_pla, z_asm_pla
>d127		70 6c 61					.text "pla"
.d12a						nt_asm_plp:
>d12a		03 0c						.byte 3, IM+NN
>d12c		35 d1				                .word nt_asm_plx
>d12e		87 ab 8c ab					.word xt_asm_plp, z_asm_plp
>d132		70 6c 70					.text "plp"
.d135						nt_asm_plx:
>d135		03 0c						.byte 3, IM+NN
>d137		40 d1				                .word nt_asm_ply
>d139		8c ab 91 ab					.word xt_asm_plx, z_asm_plx
>d13d		70 6c 78					.text "plx"
.d140						nt_asm_ply:
>d140		03 0c						.byte 3, IM+NN
>d142		4b d1				                .word nt_asm_rol
>d144		91 ab 96 ab					.word xt_asm_ply, z_asm_ply
>d148		70 6c 79					.text "ply"
.d14b						nt_asm_rol:
>d14b		03 0c						.byte 3, IM+NN
>d14d		56 d1				                .word nt_asm_rol_a
>d14f		96 ab 9b ab					.word xt_asm_rol, z_asm_rol
>d153		72 6f 6c					.text "rol"
.d156						nt_asm_rol_a:
>d156		05 0c						.byte 5, IM+NN
>d158		63 d1				                .word nt_asm_rol_x
>d15a		9b ab a0 ab					.word xt_asm_rol_a, z_asm_rol_a
>d15e		72 6f 6c 2e 61					.text "rol.a"
.d163						nt_asm_rol_x:
>d163		05 0c						.byte 5, IM+NN
>d165		70 d1				                .word nt_asm_rol_z
>d167		a0 ab a5 ab					.word xt_asm_rol_x, z_asm_rol_x
>d16b		72 6f 6c 2e 78					.text "rol.x"
.d170						nt_asm_rol_z:
>d170		05 0c						.byte 5, IM+NN
>d172		7d d1				                .word nt_asm_rol_zx
>d174		a5 ab aa ab					.word xt_asm_rol_z, z_asm_rol_z
>d178		72 6f 6c 2e 7a					.text "rol.z"
.d17d						nt_asm_rol_zx:
>d17d		06 0c						.byte 6, IM+NN
>d17f		8b d1				                .word nt_asm_ror
>d181		aa ab af ab					.word xt_asm_rol_zx, z_asm_rol_zx
>d185		72 6f 6c 2e 7a 78				.text "rol.zx"
.d18b						nt_asm_ror:
>d18b		03 0c						.byte 3, IM+NN
>d18d		96 d1				                .word nt_asm_ror_a
>d18f		af ab b4 ab					.word xt_asm_ror, z_asm_ror
>d193		72 6f 72					.text "ror"
.d196						nt_asm_ror_a:
>d196		05 0c						.byte 5, IM+NN
>d198		a3 d1				                .word nt_asm_ror_x
>d19a		b4 ab b9 ab					.word xt_asm_ror_a, z_asm_ror_a
>d19e		72 6f 72 2e 61					.text "ror.a"
.d1a3						nt_asm_ror_x:
>d1a3		05 0c						.byte 5, IM+NN
>d1a5		b0 d1				                .word nt_asm_ror_z
>d1a7		b9 ab be ab					.word xt_asm_ror_x, z_asm_ror_x
>d1ab		72 6f 72 2e 78					.text "ror.x"
.d1b0						nt_asm_ror_z:
>d1b0		05 0c						.byte 5, IM+NN
>d1b2		bd d1				                .word nt_asm_ror_zx
>d1b4		be ab c3 ab					.word xt_asm_ror_z, z_asm_ror_z
>d1b8		72 6f 72 2e 7a					.text "ror.z"
.d1bd						nt_asm_ror_zx:
>d1bd		06 0c						.byte 6, IM+NN
>d1bf		cb d1				                .word nt_asm_rti
>d1c1		c3 ab c8 ab					.word xt_asm_ror_zx, z_asm_ror_zx
>d1c5		72 6f 72 2e 7a 78				.text "ror.zx"
.d1cb						nt_asm_rti:
>d1cb		03 0c						.byte 3, IM+NN
>d1cd		d6 d1				                .word nt_asm_rts
>d1cf		c8 ab cd ab					.word xt_asm_rti, z_asm_rti
>d1d3		72 74 69					.text "rti"
.d1d6						nt_asm_rts:
>d1d6		03 0c						.byte 3, IM+NN
>d1d8		e1 d1				                .word nt_asm_sbc
>d1da		cd ab d2 ab					.word xt_asm_rts, z_asm_rts
>d1de		72 74 73					.text "rts"
.d1e1						nt_asm_sbc:
>d1e1		03 0c						.byte 3, IM+NN
>d1e3		ec d1				                .word nt_asm_sbc_h
>d1e5		d2 ab d7 ab					.word xt_asm_sbc, z_asm_sbc
>d1e9		73 62 63					.text "sbc"
.d1ec						nt_asm_sbc_h:
>d1ec		05 0c						.byte 5, IM+NN
>d1ee		f9 d1				                .word nt_asm_sbc_x
>d1f0		d7 ab dc ab					.word xt_asm_sbc_h, z_asm_sbc_h
>d1f4		73 62 63 2e 23					.text "sbc.#"
.d1f9						nt_asm_sbc_x:
>d1f9		05 0c						.byte 5, IM+NN
>d1fb		06 d2				                .word nt_asm_sbc_y
>d1fd		dc ab e1 ab					.word xt_asm_sbc_x, z_asm_sbc_x
>d201		73 62 63 2e 78					.text "sbc.x"
.d206						nt_asm_sbc_y:
>d206		05 0c						.byte 5, IM+NN
>d208		13 d2				                .word nt_asm_sbc_z
>d20a		e1 ab e6 ab					.word xt_asm_sbc_y, z_asm_sbc_y
>d20e		73 62 63 2e 79					.text "sbc.y"
.d213						nt_asm_sbc_z:
>d213		05 0c						.byte 5, IM+NN
>d215		20 d2				                .word nt_asm_sbc_zi
>d217		e6 ab eb ab					.word xt_asm_sbc_z, z_asm_sbc_z
>d21b		73 62 63 2e 7a					.text "sbc.z"
.d220						nt_asm_sbc_zi:
>d220		06 0c						.byte 6, IM+NN
>d222		2e d2				                .word nt_asm_sbc_ziy
>d224		eb ab f0 ab					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d228		73 62 63 2e 7a 69				.text "sbc.zi"
.d22e						nt_asm_sbc_ziy:
>d22e		07 0c						.byte 7, IM+NN
>d230		3d d2				                .word nt_asm_sbc_zx
>d232		f0 ab f5 ab					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d236		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d23d						nt_asm_sbc_zx:
>d23d		06 0c						.byte 6, IM+NN
>d23f		4b d2				                .word nt_asm_sbc_zxi
>d241		f5 ab fa ab					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d245		73 62 63 2e 7a 78				.text "sbc.zx"
.d24b						nt_asm_sbc_zxi:
>d24b		07 0c						.byte 7, IM+NN
>d24d		5a d2				                .word nt_asm_sec
>d24f		fa ab fe ab					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d253		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d25a						nt_asm_sec:
>d25a		03 0c						.byte 3, IM+NN
>d25c		65 d2				                .word nt_asm_sed
>d25e		fe ab 02 ac					.word xt_asm_sec, z_asm_sec
>d262		73 65 63					.text "sec"
.d265						nt_asm_sed:
>d265		03 0c						.byte 3, IM+NN
>d267		70 d2				                .word nt_asm_sei
>d269		02 ac 06 ac					.word xt_asm_sed, z_asm_sed
>d26d		73 65 64					.text "sed"
.d270						nt_asm_sei:
>d270		03 0c						.byte 3, IM+NN
>d272		7b d2				                .word nt_asm_sta
>d274		06 ac 0a ac					.word xt_asm_sei, z_asm_sei
>d278		73 65 69					.text "sei"
.d27b						nt_asm_sta:
>d27b		03 0c						.byte 3, IM+NN
>d27d		86 d2				                .word nt_asm_sta_x
>d27f		0a ac 0e ac					.word xt_asm_sta, z_asm_sta
>d283		73 74 61					.text "sta"
.d286						nt_asm_sta_x:
>d286		05 0c						.byte 5, IM+NN
>d288		93 d2				                .word nt_asm_sta_y
>d28a		0e ac 12 ac					.word xt_asm_sta_x, z_asm_sta_x
>d28e		73 74 61 2e 78					.text "sta.x"
.d293						nt_asm_sta_y:
>d293		05 0c						.byte 5, IM+NN
>d295		a0 d2				                .word nt_asm_sta_z
>d297		12 ac 16 ac					.word xt_asm_sta_y, z_asm_sta_y
>d29b		73 74 61 2e 79					.text "sta.y"
.d2a0						nt_asm_sta_z:
>d2a0		05 0c						.byte 5, IM+NN
>d2a2		ad d2				                .word nt_asm_sta_zi
>d2a4		16 ac 1a ac					.word xt_asm_sta_z, z_asm_sta_z
>d2a8		73 74 61 2e 7a					.text "sta.z"
.d2ad						nt_asm_sta_zi:
>d2ad		06 0c						.byte 6, IM+NN
>d2af		bb d2				                .word nt_asm_sta_ziy
>d2b1		1a ac 1e ac					.word xt_asm_sta_zi, z_asm_sta_zi
>d2b5		73 74 61 2e 7a 69				.text "sta.zi"
.d2bb						nt_asm_sta_ziy:
>d2bb		07 0c						.byte 7, IM+NN
>d2bd		ca d2				                .word nt_asm_sta_zx
>d2bf		1e ac 22 ac					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d2c3		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d2ca						nt_asm_sta_zx:
>d2ca		06 0c						.byte 6, IM+NN
>d2cc		d8 d2				                .word nt_asm_sta_zxi
>d2ce		22 ac 26 ac					.word xt_asm_sta_zx, z_asm_sta_zx
>d2d2		73 74 61 2e 7a 78				.text "sta.zx"
.d2d8						nt_asm_sta_zxi:
>d2d8		07 0c						.byte 7, IM+NN
>d2da		e7 d2				                .word nt_asm_stx
>d2dc		26 ac 2a ac					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d2e0		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d2e7						nt_asm_stx:
>d2e7		03 0c						.byte 3, IM+NN
>d2e9		f2 d2				                .word nt_asm_stx_z
>d2eb		2a ac 2e ac					.word xt_asm_stx, z_asm_stx
>d2ef		73 74 78					.text "stx"
.d2f2						nt_asm_stx_z:
>d2f2		05 0c						.byte 5, IM+NN
>d2f4		ff d2				                .word nt_asm_stx_zy
>d2f6		2e ac 32 ac					.word xt_asm_stx_z, z_asm_stx_z
>d2fa		73 74 78 2e 7a					.text "stx.z"
.d2ff						nt_asm_stx_zy:
>d2ff		06 0c						.byte 6, IM+NN
>d301		0d d3				                .word nt_asm_sty
>d303		32 ac 36 ac					.word xt_asm_stx_zy, z_asm_stx_zy
>d307		73 74 78 2e 7a 79				.text "stx.zy"
.d30d						nt_asm_sty:
>d30d		03 0c						.byte 3, IM+NN
>d30f		18 d3				                .word nt_asm_sty_z
>d311		36 ac 3a ac					.word xt_asm_sty, z_asm_sty
>d315		73 74 79					.text "sty"
.d318						nt_asm_sty_z:
>d318		05 0c						.byte 5, IM+NN
>d31a		25 d3				                .word nt_asm_sty_zx
>d31c		3a ac 3e ac					.word xt_asm_sty_z, z_asm_sty_z
>d320		73 74 79 2e 7a					.text "sty.z"
.d325						nt_asm_sty_zx:
>d325		06 0c						.byte 6, IM+NN
>d327		33 d3				                .word nt_asm_stz
>d329		3e ac 42 ac					.word xt_asm_sty_zx, z_asm_sty_zx
>d32d		73 74 79 2e 7a 78				.text "sty.zx"
.d333						nt_asm_stz:
>d333		03 0c						.byte 3, IM+NN
>d335		3e d3				                .word nt_asm_stz_x
>d337		42 ac 46 ac					.word xt_asm_stz, z_asm_stz
>d33b		73 74 7a					.text "stz"
.d33e						nt_asm_stz_x:
>d33e		05 0c						.byte 5, IM+NN
>d340		4b d3				                .word nt_asm_stz_z
>d342		46 ac 4a ac					.word xt_asm_stz_x, z_asm_stz_x
>d346		73 74 7a 2e 78					.text "stz.x"
.d34b						nt_asm_stz_z:
>d34b		05 0c						.byte 5, IM+NN
>d34d		58 d3				                .word nt_asm_stz_zx
>d34f		4a ac 4e ac					.word xt_asm_stz_z, z_asm_stz_z
>d353		73 74 7a 2e 7a					.text "stz.z"
.d358						nt_asm_stz_zx:
>d358		06 0c						.byte 6, IM+NN
>d35a		66 d3				                .word nt_asm_tax
>d35c		4e ac 52 ac					.word xt_asm_stz_zx, z_asm_stz_zx
>d360		73 74 7a 2e 7a 78				.text "stz.zx"
.d366						nt_asm_tax:
>d366		03 0c						.byte 3, IM+NN
>d368		71 d3				                .word nt_asm_tay
>d36a		52 ac 56 ac					.word xt_asm_tax, z_asm_tax
>d36e		74 61 78					.text "tax"
.d371						nt_asm_tay:
>d371		03 0c						.byte 3, IM+NN
>d373		7c d3				                .word nt_asm_trb
>d375		56 ac 5a ac					.word xt_asm_tay, z_asm_tay
>d379		74 61 79					.text "tay"
.d37c						nt_asm_trb:
>d37c		03 0c						.byte 3, IM+NN
>d37e		87 d3				                .word nt_asm_trb_z
>d380		5a ac 5e ac					.word xt_asm_trb, z_asm_trb
>d384		74 72 62					.text "trb"
.d387						nt_asm_trb_z:
>d387		05 0c						.byte 5, IM+NN
>d389		94 d3				                .word nt_asm_tsb
>d38b		5e ac 62 ac					.word xt_asm_trb_z, z_asm_trb_z
>d38f		74 72 62 2e 7a					.text "trb.z"
.d394						nt_asm_tsb:
>d394		03 0c						.byte 3, IM+NN
>d396		9f d3				                .word nt_asm_tsb_z
>d398		62 ac 66 ac					.word xt_asm_tsb, z_asm_tsb
>d39c		74 73 62					.text "tsb"
.d39f						nt_asm_tsb_z:
>d39f		05 0c						.byte 5, IM+NN
>d3a1		ac d3				                .word nt_asm_tsx
>d3a3		66 ac 6a ac					.word xt_asm_tsb_z, z_asm_tsb_z
>d3a7		74 73 62 2e 7a					.text "tsb.z"
.d3ac						nt_asm_tsx:
>d3ac		03 0c						.byte 3, IM+NN
>d3ae		b7 d3				                .word nt_asm_txa
>d3b0		6a ac 6e ac					.word xt_asm_tsx, z_asm_tsx
>d3b4		74 73 78					.text "tsx"
.d3b7						nt_asm_txa:
>d3b7		03 0c						.byte 3, IM+NN
>d3b9		c2 d3				                .word nt_asm_txs
>d3bb		6e ac 72 ac					.word xt_asm_txa, z_asm_txa
>d3bf		74 78 61					.text "txa"
.d3c2						nt_asm_txs:
>d3c2		03 0c						.byte 3, IM+NN
>d3c4		cd d3				                .word nt_asm_tya
>d3c6		72 ac 76 ac					.word xt_asm_txs, z_asm_txs
>d3ca		74 78 73					.text "txs"
.d3cd						nt_asm_tya:
>d3cd		03 0c						.byte 3, IM+NN
>d3cf		d8 d3				                .word nt_asm_arrow
>d3d1		76 ac 7a ac					.word xt_asm_tya, z_asm_tya
>d3d5		74 79 61					.text "tya"
.d3d8						nt_asm_arrow:
>d3d8		03 04				                .byte 3, IM
>d3da		e3 d3				                .word nt_asm_back_jump
>d3dc		57 91 61 91			                .word xt_asm_arrow, z_asm_arrow
>d3e0		2d 2d 3e			                .text "-->"
.d3e3						nt_asm_back_jump:
>d3e3		02 04				                .byte 2, IM
>d3e5		ed d3				                .word nt_asm_back_branch
>d3e7		cb ac cb ac			                .word xt_asm_back_jump, z_asm_back_jump
>d3eb		3c 6a				                .text "<j"
.d3ed						nt_asm_back_branch:
>d3ed		02 04				                .byte 2, IM
>d3ef		f7 d3				                .word nt_asm_push_a
>d3f1		cc ac d4 ac			                .word xt_asm_back_branch, z_asm_back_branch
>d3f5		3c 62				                .text "<b"
.d3f7						nt_asm_push_a:
>d3f7		06 0c				                .byte 6, IM+NN
>d3f9		00 00				                .word 0000
>d3fb		b4 ac c3 ac			                .word xt_asm_push_a, z_asm_push_a
>d3ff		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix
=1						ix += 1
=1						str_compile        = ix
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_flags      = ix
=9						ix += 1
=9						str_see_nt         = ix
=10						ix += 1
=10						str_see_xt         = ix
=11						ix += 1
=11						str_see_size       = ix
=12						ix += 1
=12						str_disasm_lit     = ix
=13						ix += 1
=13						str_disasm_sdc     = ix
=14						ix += 1
=14						str_disasm_bra     = ix
=15						ix += 1
.d405						string_table:
>d405		23 d4 27 d4 31 d4 3c d4		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d40d		73 d4 6b d4 60 d4 7a d4		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d415		80 d4 9c d4 a1 d4 a6 d4		        .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 8-11
>d41d		b7 d4 c0 d4 d2 d4		        .word s_disasm_lit, s_disasm_sdc, s_disasm_bra                ; 12-14
>d423		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d427		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d42f		64 00
>d431		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d439		64 20 00
>d43c		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d444		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d454		4f 50 51 52 53 54 55 56 57 58 59 5a
>d460		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d468		72 20 00
>d46b		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d473		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d47a		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d480		66 6c 61 67 73 20 28 43		s_see_flags:  .text "flags (CO AN IM NN UF HC): ", 0
>d488		4f 20 41 4e 20 49 4d 20 4e 4e 20 55 46 20 48 43
>d498		29 3a 20 00
>d49c		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d4a1		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d4a6		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d4ae		63 69 6d 61 6c 29 3a 20 00
>d4b7		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d4bf		00
>d4c0		53 54 41 43 4b 20 44 45		s_disasm_sdc: .text "STACK DEPTH CHECK", 0
>d4c8		50 54 48 20 43 48 45 43 4b 00
>d4d2		42 52 41 4e 43 48 20 00		s_disasm_bra: .text "BRANCH ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d4da						error_table:
>d4da		f6 d4 17 d5 37 d5 58 d5		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d4e2		75 d5 86 d5 96 d5 c4 d5		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d4ea		dc d5 fd d5 12 d6 2e d6		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d4f2		45 d6 84 d6			        .word es_blockwords, es_returnstack                     ; 12-13
>d4f6		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d4fe		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d50e		65 20 6d 65 6d 6f 72 79 00
>d517		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d51f		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d52f		20 52 45 46 49 4c 4c 00
>d537		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d53f		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d54f		6e 6c 79 20 77 6f 72 64 00
>d558		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d560		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d570		20 79 65 74 00
>d575		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d57d		20 62 79 20 7a 65 72 6f 00
>d586		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d58e		66 61 69 6c 75 72 65 00
>d596		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d59e		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d5ae		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d5be		64 20 2d 31 29 00
>d5c4		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d5cc		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d5dc		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d5e4		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d5f4		64 20 6e 75 6d 62 65 72 00
>d5fd		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d605		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d612		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d61a		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d62a		4c 4f 54 00
>d62e		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d636		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d645		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d64d		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d65d		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d66d		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d67d		56 45 43 54 4f 52 00
>d684		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d68c		74 61 63 6b 3a 00
>d692		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d69a		44 2d 53 54 52 49 4e 47
>d6a2		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d6a8		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d6ad		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d6b5		2d 55 4e 49 54 2d 42 49 54 53
>d6bf		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d6c7		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d6cf		52
>d6d0		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d6d6		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d6dc		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d6e4		53 54 41 43 4b 2d 43 45 4c 4c 53
>d6ef		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d6f7		45 4c 4c 53
>d6fb		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d703		54 53
>d705		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d70b		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d712						cmpl_subroutine:
.d712		48		pha		                pha             ; save LSB of address
.d713		a9 20		lda #$20	                lda #$20        ; load opcode for JSR
.d715		80 03		bra $d71a	                bra cmpl_common
.d717						cmpl_jump:
.d717		48		pha		                pha             ; save LSB of address
.d718		a9 4c		lda #$4c	                lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
.d71a						cmpl_common:
.d71a		20 22 d7	jsr $d722	                jsr cmpl_a      ; compile opcode
.d71d		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.d71e						cmpl_word:
.d71e		20 22 d7	jsr $d722	                jsr cmpl_a      ; compile LSB of address
.d721		98		tya		                tya             ; fall thru for MSB
.d722						cmpl_a:
.d722		92 00		sta ($00)	                sta (cp)
.d724		e6 00		inc $00		                inc cp
.d726		d0 02		bne $d72a	                bne _done
.d728		e6 01		inc $01		                inc cp+1
.d72a						_done:
.d72a		60		rts		                rts
.d72b						doconst:
.d72b		ca		dex		                dex             ; make room for constant
.d72c		ca		dex		                dex
.d72d		68		pla		                pla             ; LSB of return address
.d72e		85 24		sta $24		                sta tmp1
.d730		68		pla		                pla             ; MSB of return address
.d731		85 25		sta $25		                sta tmp1+1
.d733		a0 01		ldy #$01	                ldy #1
.d735		b1 24		lda ($24),y	                lda (tmp1),y
.d737		95 00		sta $00,x	                sta 0,x
.d739		c8		iny		                iny
.d73a		b1 24		lda ($24),y	                lda (tmp1),y
.d73c		95 01		sta $01,x	                sta 1,x
.d73e		60		rts		                rts
.d73f						dodefer:
.d73f		68		pla		                pla             ; LSB
.d740		85 24		sta $24		                sta tmp1
.d742		68		pla		                pla             ; MSB
.d743		85 25		sta $25		                sta tmp1+1
.d745		a0 01		ldy #$01	                ldy #1
.d747		b1 24		lda ($24),y	                lda (tmp1),y
.d749		85 26		sta $26		                sta tmp2
.d74b		c8		iny		                iny
.d74c		b1 24		lda ($24),y	                lda (tmp1),y
.d74e		85 27		sta $27		                sta tmp2+1
.d750		6c 26 00	jmp ($0026)	                jmp (tmp2)      ; This is actually a jump to the new target
.d753						defer_error:
.d753		a9 03		lda #$03	                lda #err_defer
.d755		4c 85 d8	jmp $d885	                jmp error
.d758						dodoes:
.d758		7a		ply		                ply             ; LSB
.d759		68		pla		                pla             ; MSB
.d75a		c8		iny		                iny
.d75b		d0 01		bne $d75e	                bne +
.d75d		1a		inc a		                ina
.d75e						+
.d75e		84 26		sty $26		                sty tmp2
.d760		85 27		sta $27		                sta tmp2+1
.d762		ca		dex		                dex
.d763		ca		dex		                dex
.d764		7a		ply		                ply
.d765		68		pla		                pla
.d766		c8		iny		                iny
.d767		d0 01		bne $d76a	                bne +
.d769		1a		inc a		                ina
.d76a						+
.d76a		94 00		sty $00,x	                sty 0,x         ; LSB
.d76c		95 01		sta $01,x	                sta 1,x         ; MSB
.d76e		6c 26 00	jmp ($0026)	                jmp (tmp2)
.d771						dovar:
.d771		7a		ply		                ply             ; LSB
.d772		68		pla		                pla             ; MSB
.d773		c8		iny		                iny
.d774		d0 01		bne $d777	                bne +
.d776		1a		inc a		                ina
.d777						+
.d777		ca		dex		                dex
.d778		ca		dex		                dex
.d779		95 01		sta $01,x	                sta 1,x
.d77b		98		tya		                tya
.d77c		95 00		sta $00,x	                sta 0,x
.d77e		60		rts		                rts
.d77f						byte_to_ascii:
.d77f		48		pha		                pha
.d780		4a		lsr a		                lsr             ; convert high nibble first
.d781		4a		lsr a		                lsr
.d782		4a		lsr a		                lsr
.d783		4a		lsr a		                lsr
.d784		20 88 d7	jsr $d788	                jsr _nibble_to_ascii
.d787		68		pla		                pla
.d788						_nibble_to_ascii:
.d788		29 0f		and #$0f	                and #$0F
.d78a		09 30		ora #$30	                ora #'0'
.d78c		c9 3a		cmp #$3a	                cmp #$3A        ; '9+1
.d78e		90 02		bcc $d792	                bcc +
.d790		69 06		adc #$06	                adc #$06
.d792		4c db 8d	jmp $8ddb	+               jmp emit_a
.d795		60		rts		                rts
.d796						compare_16bit:
.d796		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d798		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d79a		f0 0a		beq $d7a6	                beq _equal
.d79c		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d79e		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7a0		09 01		ora #$01	                ora #1                  ; Make zero flag 0 because not equal
.d7a2		70 08		bvs $d7ac	                bvs _overflow
.d7a4		80 08		bra $d7ae	                bra _not_equal
.d7a6						_equal:
.d7a6		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d7a8		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d7aa		50 04		bvc $d7b0	                bvc _done
.d7ac						_overflow:
.d7ac		49 80		eor #$80	                eor #$80                ; complement negative flag
.d7ae						_not_equal:
.d7ae		09 01		ora #$01	                ora #1                  ; if overflow, we can't be equal
.d7b0						_done:
.d7b0		60		rts		                rts
.d7b1						current_to_dp:
.d7b1		a0 04		ldy #$04	                ldy #current_offset
.d7b3		b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d7b5		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7b6		18		clc		                clc
.d7b7		69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7b9		a8		tay		                tay
.d7ba		b1 1e		lda ($1e),y	                lda (up),y              ; get the dp for that wordlist.
.d7bc		85 02		sta $02		                sta dp
.d7be		c8		iny		                iny
.d7bf		b1 1e		lda ($1e),y	                lda (up),y
.d7c1		85 03		sta $03		                sta dp+1
.d7c3		60		rts		                rts
.d7c4						dp_to_current:
.d7c4		a0 04		ldy #$04	                ldy #current_offset
.d7c6		b1 1e		lda ($1e),y	                lda (up),y      ; current is a byte variable
.d7c8		0a		asl a		                asl             ; turn it into an offset (in cells)
.d7c9		18		clc		                clc
.d7ca		69 06		adc #$06	                adc #wordlists_offset   ; add offset to wordlists base.
.d7cc		a8		tay		                tay
.d7cd		a5 02		lda $02		                lda dp
.d7cf		91 1e		sta ($1e),y	                sta (up),y              ; get the dp for that wordlist.
.d7d1		c8		iny		                iny
.d7d2		a5 03		lda $03		                lda dp+1
.d7d4		91 1e		sta ($1e),y	                sta (up),y
.d7d6		60		rts		                rts
.d7d7						interpret:
.d7d7						_loop:
.d7d7		20 c3 98	jsr $98c3	                jsr xt_parse_name       ; ( "string" -- addr u )
.d7da		b5 00		lda $00,x	                lda 0,x
.d7dc		15 01		ora $01,x	                ora 1,x
.d7de		f0 70		beq $d850	                beq _line_done
.d7e0		20 5c a3	jsr $a35c	                jsr xt_two_dup          ; ( addr u -- addr u addr u )
.d7e3		20 c0 8f	jsr $8fc0	                jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
.d7e6		b5 00		lda $00,x	                lda 0,x
.d7e8		15 01		ora $01,x	                ora 1,x
.d7ea		d0 28		bne $d814	                bne _got_name_token
.d7ec		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d7ed		e8		inx		                inx
.d7ee		20 6e 96	jsr $966e	                jsr xt_number           ; ( addr u -- u|d )
.d7f1		a5 16		lda $16		                lda state
.d7f3		f0 e2		beq $d7d7	                beq _loop
.d7f5		a9 20		lda #$20	                lda #$20
.d7f7		24 20		bit $20		                bit status
.d7f9		f0 0d		beq $d808	                beq _single_number
.d7fb		20 5c a1	jsr $a15c	                jsr xt_swap
.d7fe		a0 93		ldy #$93	                ldy #>literal_runtime
.d800		a9 79		lda #$79	                lda #<literal_runtime
.d802		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.d805		20 24 87	jsr $8724	                jsr xt_comma
.d808						_single_number:
.d808		a0 93		ldy #$93	                ldy #>literal_runtime
.d80a		a9 79		lda #$79	                lda #<literal_runtime
.d80c		20 12 d7	jsr $d712	                jsr cmpl_subroutine
.d80f		20 24 87	jsr $8724	                jsr xt_comma
.d812		80 c3		bra $d7d7	                bra _loop
.d814						_got_name_token:
.d814		b5 00		lda $00,x	                lda 0,x
.d816		95 04		sta $04,x	                sta 4,x
.d818		b5 01		lda $01,x	                lda 1,x
.d81a		95 05		sta $05,x	                sta 5,x
.d81c		e8		inx		                inx
.d81d		e8		inx		                inx
.d81e		e8		inx		                inx
.d81f		e8		inx		                inx                     ; ( nt )
.d820		b5 00		lda $00,x	                lda 0,x
.d822		85 22		sta $22		                sta tmpbranch
.d824		b5 01		lda $01,x	                lda 1,x
.d826		85 23		sta $23		                sta tmpbranch+1
.d828		20 c5 95	jsr $95c5	                jsr xt_name_to_int      ; ( nt - xt )
.d82b		a5 16		lda $16		                lda state
.d82d		d0 13		bne $d842	                bne _compile
.d82f		a0 01		ldy #$01	                ldy #1
.d831		b1 22		lda ($22),y	                lda (tmpbranch),y
.d833		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d835		f0 05		beq $d83c	                beq _interpret
.d837		a9 02		lda #$02	                lda #err_compileonly
.d839		4c 85 d8	jmp $d885	                jmp error
.d83c						_interpret:
.d83c		20 22 8f	jsr $8f22	                jsr xt_execute
.d83f		4c d7 d7	jmp $d7d7	                jmp _loop
.d842						_compile:
.d842		a0 01		ldy #$01	                ldy #1
.d844		b1 22		lda ($22),y	                lda (tmpbranch),y
.d846		29 04		and #$04	                and #IM                 ; Mask all but IM bit
.d848		d0 f2		bne $d83c	                bne _interpret          ; IMMEDIATE word, execute right now
.d84a		20 a3 87	jsr $87a3	                jsr xt_compile_comma
.d84d		4c d7 d7	jmp $d7d7	                jmp _loop
.d850						_line_done:
.d850		e8		inx		                inx
.d851		e8		inx		                inx
.d852		e8		inx		                inx
.d853		e8		inx		                inx
.d854		60		rts		                rts
.d855						is_printable:
.d855		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d857		90 08		bcc $d861	                bcc _done
.d859		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d85b		b0 03		bcs $d860	                bcs _failed
.d85d		38		sec		                sec
.d85e		80 01		bra $d861	                bra _done
.d860						_failed:
.d860		18		clc		                clc
.d861						_done:
.d861		60		rts		                rts
.d862						is_whitespace:
.d862		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d864		90 08		bcc $d86e	                bcc _done
.d866		c9 21		cmp #$21	                cmp #AscSP+1
.d868		b0 03		bcs $d86d	                bcs _failed
.d86a		38		sec		                sec
.d86b		80 01		bra $d86e	                bra _done
.d86d						_failed:
.d86d		18		clc		                clc
.d86e						_done:
.d86e		60		rts		                rts
.d86f						underflow_1:
.d86f		e0 77		cpx #$77	                cpx #dsp0-1
.d871		10 10		bpl $d883	                bpl underflow_error
.d873		60		rts		                rts
.d874						underflow_2:
.d874		e0 75		cpx #$75	                cpx #dsp0-3
.d876		10 0b		bpl $d883	                bpl underflow_error
.d878		60		rts		                rts
.d879						underflow_3:
.d879		e0 73		cpx #$73	                cpx #dsp0-5
.d87b		10 06		bpl $d883	                bpl underflow_error
.d87d		60		rts		                rts
.d87e						underflow_4:
.d87e		e0 71		cpx #$71	                cpx #dsp0-7
.d880		10 01		bpl $d883	                bpl underflow_error
.d882		60		rts		                rts
.d883						underflow_error:
.d883		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d885						error:
.d885		48		pha		                pha                     ; save error
.d886		20 c5 d8	jsr $d8c5	                jsr print_error
.d889		20 2a 89	jsr $892a	                jsr xt_cr
.d88c		68		pla		                pla
.d88d		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d88f		d0 17		bne $d8a8	                bne _no_underflow
.d891		a9 0d		lda #$0d	                lda #err_returnstack
.d893		20 c5 d8	jsr $d8c5	                jsr print_error
.d896		ba		tsx		                tsx
.d897						-
.d897		e8		inx		                inx
.d898		f0 0b		beq $d8a5	                beq +
.d89a		20 cc a0	jsr $a0cc	                jsr xt_space
.d89d		bd 00 01	lda $0100,x	                lda $100,x
.d8a0		20 7f d7	jsr $d77f	                jsr byte_to_ascii
.d8a3		80 f2		bra $d897	                bra -
.d8a5						+
.d8a5		20 2a 89	jsr $892a	                jsr xt_cr
.d8a8						_no_underflow:
.d8a8		4c 60 80	jmp $8060	                jmp xt_abort            ; no jsr, as we clobber return stack
.d8ab						print_string_no_lf:
.d8ab		0a		asl a		                asl
.d8ac		a8		tay		                tay
.d8ad		b9 05 d4	lda $d405,y	                lda string_table,y
.d8b0		85 28		sta $28		                sta tmp3                ; LSB
.d8b2		c8		iny		                iny
.d8b3		b9 05 d4	lda $d405,y	                lda string_table,y
.d8b6		85 29		sta $29		                sta tmp3+1              ; MSB
.d8b8						print_common:
.d8b8		a0 00		ldy #$00	                ldy #0
.d8ba						_loop:
.d8ba		b1 28		lda ($28),y	                lda (tmp3),y
.d8bc		f0 06		beq $d8c4	                beq _done               ; strings are zero-terminated
.d8be		20 db 8d	jsr $8ddb	                jsr emit_a              ; allows vectoring via output
.d8c1		c8		iny		                iny
.d8c2		80 f6		bra $d8ba	                bra _loop
.d8c4						_done:
.d8c4		60		rts		                rts
.d8c5						print_error:
.d8c5		0a		asl a		                asl
.d8c6		a8		tay		                tay
.d8c7		b9 da d4	lda $d4da,y	                lda error_table,y
.d8ca		85 28		sta $28		                sta tmp3                ; LSB
.d8cc		c8		iny		                iny
.d8cd		b9 da d4	lda $d4da,y	                lda error_table,y
.d8d0		85 29		sta $29		                sta tmp3+1              ; MSB
.d8d2		20 b8 d8	jsr $d8b8	                jsr print_common
.d8d5		60		rts		                rts
.d8d6						print_string:
.d8d6		20 ab d8	jsr $d8ab	                jsr print_string_no_lf
.d8d9		4c 2a 89	jmp $892a	                jmp xt_cr               ; JSR/RTS because never compiled
.d8dc						print_u:
.d8dc		20 56 a7	jsr $a756	                jsr xt_zero                     ; 0
.d8df		20 3b 93	jsr $933b	                jsr xt_less_number_sign         ; <#
.d8e2		20 c2 97	jsr $97c2	                jsr xt_number_sign_s            ; #S
.d8e5		20 a0 97	jsr $97a0	                jsr xt_number_sign_greater      ; #>
.d8e8		4c a7 a4	jmp $a4a7	                jmp xt_type                     ; JSR/RTS because never compiled

;******  Return to file: platform/platform-py65mon.asm

.f010						v_nmi:
.f010						v_reset:
.f010						v_irq:
.f010						kernel_init:
.f010		78		sei		                sei             ; Disable interrupts
.f011		a2 00		ldx #$00	                ldx #0
.f013		bd 2c f0	lda $f02c,x	-               lda s_kernel_id,x
.f016		f0 06		beq $f01e	                beq _done
.f018		20 27 f0	jsr $f027	                jsr kernel_putc
.f01b		e8		inx		                inx
.f01c		80 f5		bra $f013	                bra -
.f01e						_done:
.f01e		4c 00 80	jmp $8000	                jmp forth
.f021						kernel_getc:
.f021						_loop:
.f021		ad 04 f0	lda $f004	                lda $f004
.f024		f0 fb		beq $f021	                beq _loop
.f026		60		rts		                rts
.f027						kernel_putc:
.f027		8d 01 f0	sta $f001	                sta $f001
.f02a		60		rts		                rts
.f02b						platform_bye:
.f02b		00		brk #		                brk
.f02c						s_kernel_id:
>f02c		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f034		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f044		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f054		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		10 f0				.word v_nmi
>fffc		10 f0				.word v_reset
>fffe		10 f0				.word v_irq

;******  End of listing
