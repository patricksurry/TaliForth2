
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output taliforth-py65mon.bin platform/platform-py65mon.asm
; Fri Aug  9 13:33:21 2024

;Offset	;PC	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

="py65mon"					TALI_ARCH := "py65mon"
=$7fff						ram_end = $7fff
=						TALI_OPTIONAL_WORDS := [ "ed", "editor", "ramdrive", "block", "environment?", "assembler", "disassembler", "wordlist" ]
=["lf"]						TALI_OPTION_CR_EOL := [ "lf" ]
=1						TALI_OPTION_HISTORY := 1
=0						TALI_OPTION_TERSE := 0

;******  Processing file: platform/simulator.asm


;******  Processing file: platform/../taliforth.asm

.8000						code0:
.8000						forth:

;******  Processing file: platform/../words/all.asm

.8000						xt_cold:
.8000						w_cold:
.8000		d8		cld		                cld
.8001		a9 22		lda #$22	                lda #<kernel_putc
.8003		85 12		sta $12		                sta output
.8005		a9 f0		lda #$f0	                lda #>kernel_putc
.8007		85 13		sta $13		                sta output+1
.8009		a2 1d		ldx #$1d	                ldx #cold_zp_table_end-cold_zp_table-1
.800b						_load_zp_loop:
.800b		bd 8c b3	lda $b38c,x	                lda cold_zp_table,x
.800e		95 00		sta $00,x	                sta zpage,x
.8010		ca		dex		                dex
.8011		d0 f8		bne $800b	                bne _load_zp_loop
.8013		ad 8c b3	lda $b38c	                lda cold_zp_table
.8016		85 00		sta $00		                sta zpage
.8018		a2 ff		ldx #$ff	                ldx #rsp0
.801a		9a		txs		                txs
.801b		a2 78		ldx #$78	                ldx #dsp0
.801d		a0 35		ldy #$35	                ldy #cold_user_table_end-cold_user_table-1
.801f						_load_user_vars_loop:
.801f		b9 aa b3	lda $b3aa,y	                lda cold_user_table,y
.8022		91 08		sta ($08),y	                sta (up),y
.8024		88		dey		                dey
.8025		d0 f8		bne $801f	                bne _load_user_vars_loop
.8027		ad aa b3	lda $b3aa	                lda cold_user_table
.802a		92 08		sta ($08)	                sta (up)
.802c		20 ec 83	jsr $83ec	                jsr w_cr
.802f		ca		dex		                dex
.8030		ca		dex		                dex
.8031		ca		dex		                dex
.8032		ca		dex		                dex
.8033		a9 8d		lda #$8d	                lda #<forth_words_start
.8035		95 02		sta $02,x	                sta 2,x
.8037		a9 ba		lda #$ba	                lda #>forth_words_start
.8039		95 03		sta $03,x	                sta 3,x
.803b		a9 e2		lda #$e2	                lda #<(user_words_end-forth_words_start)
.803d		95 00		sta $00,x	                sta 0,x
.803f		a9 00		lda #$00	                lda #>(user_words_end-forth_words_start)
.8041		95 01		sta $01,x	                sta 1,x
.8043		20 81 88	jsr $8881	                jsr w_evaluate
.8046		9c 00 7c	stz $7c00	                stz hist_buff
.8049		9c 80 7c	stz $7c80	                stz hist_buff+$80
.804c		9c 00 7d	stz $7d00	                stz hist_buff+$100
.804f		9c 80 7d	stz $7d80	                stz hist_buff+$180
.8052		9c 00 7e	stz $7e00	                stz hist_buff+$200
.8055		9c 80 7e	stz $7e80	                stz hist_buff+$280
.8058		9c 00 7f	stz $7f00	                stz hist_buff+$300
.805b		9c 80 7f	stz $7f80	                stz hist_buff+$380
.805e						xt_abort:
.805e						w_abort:
.805e		a2 78		ldx #$78	                ldx #dsp0
.8060						xt_quit:
.8060						w_quit:
.8060		8a		txa		                txa             ; Save the DSP that we just defined
.8061		a2 ff		ldx #$ff	                ldx #rsp0
.8063		9a		txs		                txs
.8064		aa		tax		                tax             ; Restore the DSP. Dude, seriously.
.8065		64 04		stz $04		                stz ip
.8067		64 05		stz $05		                stz ip+1
.8069		64 0a		stz $0a		                stz insrc
.806b		64 0b		stz $0b		                stz insrc+1
.806d		a9 00		lda #$00	                lda #0
.806f		a0 04		ldy #$04	                ldy #blk_offset
.8071		91 08		sta ($08),y	                sta (up),y
.8073		c8		iny		                iny
.8074		91 08		sta ($08),y	                sta (up),y
.8076		a9 fc		lda #$fc	                lda #(256-4)
.8078		85 1f		sta $1f		                sta loopctrl
.807a		64 1a		stz $1a		                stz state
.807c		64 1b		stz $1b		                stz state+1
.807e						_get_line:
.807e		a9 00		lda #$00	                lda #<buffer0   ; input buffer, this is paranoid
.8080		85 0c		sta $0c		                sta cib
.8082		a9 02		lda #$02	                lda #>buffer0
.8084		85 0d		sta $0d		                sta cib+1
.8086		64 0e		stz $0e		                stz ciblen
.8088		64 0f		stz $0f		                stz ciblen+1
.808a		20 07 8f	jsr $8f07	                jsr w_refill           ; ( -- f )
.808d		b5 00		lda $00,x	                lda 0,x
.808f		d0 05		bne $8096	                bne _success
.8091		a9 06		lda #$06	                lda #err_refill
.8093		4c ea d7	jmp $d7ea	                jmp error
.8096						_success:
.8096		e8		inx		                inx                     ; drop
.8097		e8		inx		                inx
.8098		20 53 d7	jsr $d753	                jsr interpret
.809b		e0 78		cpx #$78	                cpx #dsp0
.809d		f0 05		beq $80a4	                beq _stack_ok
.809f		90 03		bcc $80a4	                bcc _stack_ok           ; DSP must always be smaller than DSP0
.80a1		4c e8 d7	jmp $d7e8	                jmp underflow_error
.80a4						_stack_ok:
.80a4		a5 1a		lda $1a		                lda state
.80a6		f0 02		beq $80aa	                beq _print
.80a8		a9 01		lda #$01	                lda #1                  ; number for "compile" string
.80aa						_print:
.80aa		20 3a d8	jsr $d83a	                jsr print_string
.80ad		80 cf		bra $807e	                bra _get_line
.80af						z_cold:
.80af						z_abort:
.80af						z_quit:

;******  Processing file: platform/../words/core.asm

.80af						xt_abort_quote:
.80af						w_abort_quote:
.80af		20 a2 8f	jsr $8fa2	                jsr w_s_quote          ; S"
.80b2		a0 80		ldy #$80	                ldy #>abort_quote_runtime
.80b4		a9 ba		lda #$ba	                lda #<abort_quote_runtime
.80b6		20 b1 97	jsr $97b1	                jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
.80b9		60		rts		z_abort_quote:  rts
.80ba						abort_quote_runtime:
.80ba		b5 04		lda $04,x	                lda 4,x
.80bc		15 05		ora $05,x	                ora 5,x
.80be		f0 09		beq $80c9	                beq _done       ; if FALSE, we're done
.80c0		20 b4 94	jsr $94b4	                jsr w_type
.80c3		20 ec 83	jsr $83ec	                jsr w_cr
.80c6		4c 5e 80	jmp $805e	                jmp w_abort    ; not JSR, so never come back
.80c9						_done:
.80c9		8a		txa		                txa
.80ca		18		clc		                clc
.80cb		69 06		adc #$06	                adc #6
.80cd		aa		tax		                tax
.80ce		60		rts		                rts
.80cf						xt_abs:
.80cf		20 d4 d7	jsr $d7d4	                jsr underflow_1
.80d2						w_abs:
.80d2		b5 01		lda $01,x	                lda 1,x
.80d4		10 0d		bpl $80e3	                bpl _done       ; positive number, easy money!
.80d6		38		sec		                sec
.80d7		a9 00		lda #$00	                lda #0
.80d9		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.80db		95 00		sta $00,x	                sta 0,x
.80dd		a9 00		lda #$00	                lda #0          ; MSB
.80df		f5 01		sbc $01,x	                sbc 1,x
.80e1		95 01		sta $01,x	                sta 1,x
.80e3						_done:
.80e3		60		rts		z_abs:          rts
.80e4						xt_accept:
.80e4		20 d9 d7	jsr $d7d9	                jsr underflow_2
.80e7						w_accept:
.80e7		b5 00		lda $00,x	                lda 0,x
.80e9		15 01		ora $01,x	                ora 1,x
.80eb		d0 09		bne $80f6	                bne _not_zero
.80ed		e8		inx		                inx
.80ee		e8		inx		                inx
.80ef		74 00		stz $00,x	                stz 0,x
.80f1		74 01		stz $01,x	                stz 1,x
.80f3		4c c2 81	jmp $81c2	                jmp accept_done
.80f6						_not_zero:
.80f6		b5 00		lda $00,x	                lda 0,x         ; number of chars to get in tmp2 ...
.80f8		85 27		sta $27		                sta tmp2
.80fa		64 28		stz $28		                stz tmp2+1      ; ... but we only accept max 255 chars
.80fc		b5 02		lda $02,x	                lda 2,x         ; address of buffer is NOS, to tmp1
.80fe		85 25		sta $25		                sta tmp1
.8100		b5 03		lda $03,x	                lda 3,x
.8102		85 26		sta $26		                sta tmp1+1
.8104		e8		inx		                inx
.8105		e8		inx		                inx
.8106		a0 00		ldy #$00	                ldy #0
.8108		a5 1c		lda $1c		                lda status
.810a		29 f7		and #$f7	                and #$F7
.810c		1a		inc a		                ina
.810d		09 08		ora #$08	                ora #%00001000
.810f		85 1c		sta $1c		                sta status
.8111						accept_loop:
.8111		20 7d 89	jsr $897d	                jsr key_a
.8114		c9 0a		cmp #$0a	                cmp #AscLF
.8116		f0 20		beq $8138	                beq _eol
.8118		c9 0d		cmp #$0d	                cmp #AscCR
.811a		f0 1c		beq $8138	                beq _eol
.811c		c9 08		cmp #$08	                cmp #AscBS
.811e		f0 22		beq $8142	                beq _backspace
.8120		c9 7f		cmp #$7f	                cmp #AscDEL     ; (CTRL-h)
.8122		f0 1e		beq $8142	                beq _backspace
.8124		c9 10		cmp #$10	                cmp #AscCP
.8126		f0 36		beq $815e	                beq _ctrl_p
.8128		c9 0e		cmp #$0e	                cmp #AscCN
.812a		f0 44		beq $8170	                beq _ctrl_n
.812c		91 25		sta ($25),y	                sta (tmp1),y
.812e		c8		iny		                iny
.812f		20 86 86	jsr $8686	                jsr emit_a
.8132		c4 27		cpy $27		                cpy tmp2        ; reached character limit?
.8134		d0 db		bne $8111	                bne accept_loop       ; fall through if buffer limit reached
.8136		80 03		bra $813b	                bra _buffer_full
.8138						_eol:
.8138		20 b5 91	jsr $91b5	                jsr w_space    ; print final space
.813b						_buffer_full:
.813b		94 00		sty $00,x	                sty 0,x         ; Y contains number of chars accepted already
.813d		74 01		stz $01,x	                stz 1,x         ; we only accept 256 chars
.813f		4c c2 81	jmp $81c2	                jmp accept_done
.8142						_backspace:
.8142		c0 00		cpy #$00	                cpy #0          ; buffer empty?
.8144		d0 06		bne $814c	                bne +
.8146		a9 07		lda #$07	                lda #AscBELL    ; complain and don't delete beyond the start of line
.8148		20 86 86	jsr $8686	                jsr emit_a
.814b		c8		iny		                iny
.814c						+
.814c		88		dey		                dey
.814d		a9 08		lda #$08	                lda #AscBS      ; move back one
.814f		20 86 86	jsr $8686	                jsr emit_a
.8152		a9 20		lda #$20	                lda #AscSP      ; print a space (rubout)
.8154		20 86 86	jsr $8686	                jsr emit_a
.8157		a9 08		lda #$08	                lda #AscBS      ; move back over space
.8159		20 86 86	jsr $8686	                jsr emit_a
.815c		80 b3		bra $8111	                bra accept_loop
.815e						_ctrl_p:
.815e		a5 1c		lda $1c		                lda status
.8160		29 07		and #$07	                and #7
.8162		d0 08		bne $816c	                bne _ctrl_p_dec
.8164		a5 1c		lda $1c		                lda status
.8166		09 07		ora #$07	                ora #7
.8168		85 1c		sta $1c		                sta status
.816a		80 11		bra $817d	                bra _recall_history
.816c						_ctrl_p_dec:
.816c		c6 1c		dec $1c		                dec status
.816e		80 0d		bra $817d	                bra _recall_history
.8170						_ctrl_n:
.8170		a9 08		lda #$08	                lda #$8
.8172		24 1c		bit $1c		                bit status
.8174		d0 07		bne $817d	                bne _recall_history
.8176		a5 1c		lda $1c		                lda status
.8178		29 f7		and #$f7	                and #$F7
.817a		1a		inc a		               ina
.817b		85 1c		sta $1c		                sta status
.817d						_recall_history:
.817d		a9 08		lda #$08	                lda #%00001000
.817f		14 1c		trb $1c		                trb status
.8181		20 dd 81	jsr $81dd	                jsr accept_total_recall
.8184		a9 0d		lda #$0d	                lda #AscCR
.8186		20 86 86	jsr $8686	                jsr emit_a
.8189						input_clear:
.8189		c0 00		cpy #$00	                cpy #0
.818b		f0 08		beq $8195	                beq input_cleared
.818d		a9 20		lda #$20	                lda #AscSP
.818f		20 86 86	jsr $8686	                jsr emit_a
.8192		88		dey		                dey
.8193		80 f4		bra $8189	                bra input_clear
.8195						input_cleared:
.8195		a9 0d		lda #$0d	                lda #AscCR
.8197		20 86 86	jsr $8686	                jsr emit_a
.819a		b1 29		lda ($29),y	                lda (tmp3),y
.819c		85 1d		sta $1d		                sta status+1
.819e		e6 29		inc $29		                inc tmp3
.81a0		d0 02		bne $81a4	                bne +           ; Increment the upper byte on carry.
.81a2		e6 2a		inc $2a		                inc tmp3+1
.81a4						+
.81a4		a9 0d		lda #$0d	                lda #AscCR
.81a6		20 86 86	jsr $8686	                jsr emit_a
.81a9						_history_loop:
.81a9		c4 1d		cpy $1d		                cpy status+1
.81ab		d0 03		bne $81b0	                bne +
.81ad		4c 11 81	jmp $8111	                jmp accept_loop       ; Needs a long jump
.81b0						+
.81b0		c4 27		cpy $27		                cpy tmp2
.81b2		f0 0a		beq $81be	                beq _hist_filled_buffer
.81b4		b1 29		lda ($29),y	                lda (tmp3),y
.81b6		91 25		sta ($25),y	                sta (tmp1),y
.81b8		20 86 86	jsr $8686	                jsr emit_a
.81bb		c8		iny		                iny
.81bc		80 eb		bra $81a9	                bra _history_loop
.81be						_hist_filled_buffer:
.81be		88		dey		                dey
.81bf		4c 11 81	jmp $8111	                jmp accept_loop
.81c2						accept_done:
.81c2		20 dd 81	jsr $81dd	                jsr accept_total_recall
.81c5		85 1d		sta $1d		                sta status+1
.81c7		a0 00		ldy #$00	                ldy #0
.81c9		91 29		sta ($29),y	                sta (tmp3),y
.81cb		e6 29		inc $29		                inc tmp3
.81cd		d0 02		bne $81d1	                bne +           ; Increment the upper byte on carry.
.81cf		e6 2a		inc $2a		                inc tmp3+1
.81d1						+
.81d1						_save_history_loop:
.81d1		c4 1d		cpy $1d		                cpy status+1
.81d3		f0 07		beq $81dc	                beq _save_history_done
.81d5		b1 25		lda ($25),y	                lda (tmp1),y
.81d7		91 29		sta ($29),y	                sta (tmp3),y
.81d9		c8		iny		                iny
.81da		80 f5		bra $81d1	                bra _save_history_loop
.81dc						_save_history_done:
.81dc						z_accept:
.81dc		60		rts		                rts
.81dd						accept_total_recall:
.81dd		a9 00		lda #$00	                lda #<hist_buff
.81df		85 29		sta $29		                sta tmp3
.81e1		a9 7c		lda #$7c	                lda #>hist_buff
.81e3		85 2a		sta $2a		                sta tmp3+1
.81e5		a5 1c		lda $1c		                lda status
.81e7		6a		ror a		                ror
.81e8		29 03		and #$03	                and #3
.81ea		18		clc		                clc
.81eb		65 2a		adc $2a		                adc tmp3+1
.81ed		85 2a		sta $2a		                sta tmp3+1
.81ef		a5 1c		lda $1c		                lda status
.81f1		6a		ror a		                ror             ; Rotate through carry into msb.
.81f2		6a		ror a		                ror
.81f3		29 80		and #$80	                and #$80
.81f5		18		clc		                clc
.81f6		65 29		adc $29		                adc tmp3
.81f8		85 29		sta $29		                sta tmp3
.81fa		90 02		bcc $81fe	                bcc +           ; Increment the upper byte on carry.
.81fc		e6 2a		inc $2a		                inc tmp3+1
.81fe						+
.81fe		98		tya		                tya
.81ff		c9 80		cmp #$80	                cmp #$80
.8201		90 02		bcc $8205	                bcc +
.8203		a9 7f		lda #$7f	                lda #$7F
.8205						+
.8205		60		rts		                rts
.8206						xt_action_of:
.8206						w_action_of:
.8206		a5 1a		lda $1a		                lda state
.8208		05 1b		ora $1b		                ora state+1
.820a		f0 0c		beq $8218	                beq _interpreting
.820c		20 14 83	jsr $8314	                jsr w_bracket_tick
.820f		a0 84		ldy #$84	                ldy #>w_defer_fetch
.8211		a9 fa		lda #$fa	                lda #<w_defer_fetch
.8213		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.8216		80 06		bra $821e	                bra _done
.8218						_interpreting:
.8218		20 2f 92	jsr $922f	                jsr w_tick
.821b		20 fa 84	jsr $84fa	                jsr w_defer_fetch
.821e						_done:
.821e		60		rts		z_action_of:           rts
.821f						xt_again:
.821f		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8222						w_again:
.8222		20 a2 97	jsr $97a2	                jsr cmpl_jump_tos
.8225		60		rts		z_again:        rts
.8226						xt_align:
.8226						xt_aligned:
.8226						w_align:
.8226						w_aligned:
.8226						z_align:
.8226						z_aligned:
.8226		60		rts		                rts             ; stripped out during native compile
.8227						xt_allot:
.8227		20 d4 d7	jsr $d7d4	                jsr underflow_1
.822a						w_allot:
.822a		b5 01		lda $01,x	                lda 1,x
.822c		30 22		bmi $8250	                bmi _release
.822e		18		clc		                clc
.822f		a5 00		lda $00		                lda cp
.8231		75 00		adc $00,x	                adc 0,x
.8233		85 00		sta $00		                sta cp
.8235		a5 01		lda $01		                lda cp+1
.8237		75 01		adc $01,x	                adc 1,x
.8239		85 01		sta $01		                sta cp+1
.823b		a0 00		ldy #$00	                ldy #<cp_end
.823d		c4 00		cpy $00		                cpy cp
.823f		a9 7c		lda #$7c	                lda #>cp_end
.8241		e5 01		sbc $01		                sbc cp+1
.8243		b0 48		bcs $828d	                bcs _done               ; we're fine.
.8245		84 00		sty $00		                sty cp                  ; still #<cp_end
.8247		a9 7c		lda #$7c	                lda #>cp_end
.8249		85 01		sta $01		                sta cp+1
.824b		a9 00		lda #$00	                lda #err_allot
.824d		4c ea d7	jmp $d7ea	                jmp error
.8250						_release:
.8250		ca		dex		                dex
.8251		ca		dex		                dex
.8252		a5 00		lda $00		                lda cp
.8254		95 00		sta $00,x	                sta 0,x
.8256		a5 01		lda $01		                lda cp+1
.8258		95 01		sta $01,x	                sta 1,x
.825a		20 29 8e	jsr $8e29	                jsr w_plus                     ; new CP is now TOS
.825d		ca		dex		                dex
.825e		ca		dex		                dex                             ; new CP now NOS
.825f		a9 00		lda #$00	                lda #<cp0
.8261		95 00		sta $00,x	                sta 0,x
.8263		a9 03		lda #$03	                lda #>cp0
.8265		95 01		sta $01,x	                sta 1,x                         ; CP0 is TOS
.8267		20 14 d7	jsr $d714	                jsr compare_16bit               ; still ( CP CP0 )
.826a		f0 17		beq $8283	                beq _nega_done
.826c		30 15		bmi $8283	                bmi _nega_done
.826e		a9 00		lda #$00	                lda #<cp0
.8270		85 00		sta $00		                sta cp
.8272		a9 03		lda #$03	                lda #>cp0
.8274		85 01		sta $01		                sta cp+1
.8276		a9 6f		lda #$6f	                lda #<dictionary_start
.8278		85 02		sta $02		                sta dp
.827a		a9 bb		lda #$bb	                lda #>dictionary_start
.827c		85 03		sta $03		                sta dp+1
.827e		a9 0a		lda #$0a	                lda #err_negallot
.8280		4c ea d7	jmp $d7ea	                jmp error
.8283						_nega_done:
.8283		b5 02		lda $02,x	                lda 2,x
.8285		85 00		sta $00		                sta cp
.8287		b5 03		lda $03,x	                lda 3,x
.8289		85 01		sta $01		                sta cp+1
.828b		e8		inx		                inx
.828c		e8		inx		                inx                     ; drop through to _done
.828d						_done:
.828d		e8		inx		                inx
.828e		e8		inx		                inx
.828f						z_allot:
.828f		60		rts		                rts
.8290						xt_and:
.8290		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8293						w_and:
.8293		b5 00		lda $00,x	                lda 0,x
.8295		35 02		and $02,x	                and 2,x
.8297		95 02		sta $02,x	                sta 2,x
.8299		b5 01		lda $01,x	                lda 1,x
.829b		35 03		and $03,x	                and 3,x
.829d		95 03		sta $03,x	                sta 3,x
.829f		e8		inx		                inx
.82a0		e8		inx		                inx
.82a1		60		rts		z_and:          rts
.82a2						xt_at_xy:
.82a2		20 d9 d7	jsr $d7d9	                jsr underflow_2
.82a5						w_at_xy:
.82a5		a5 18		lda $18		                lda base
.82a7		48		pha		                pha
.82a8		a9 0a		lda #$0a	                lda #10
.82aa		85 18		sta $18		                sta base
.82ac		a9 1b		lda #$1b	                lda #AscESC
.82ae		20 86 86	jsr $8686	                jsr emit_a
.82b1		a9 5b		lda #$5b	                lda #'['
.82b3		20 86 86	jsr $8686	                jsr emit_a
.82b6		20 bf 8c	jsr $8cbf	                jsr w_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82b9		20 40 d8	jsr $d840	                jsr print_u
.82bc		a9 3b		lda #$3b	                lda #';'
.82be		20 86 86	jsr $8686	                jsr emit_a
.82c1		20 bf 8c	jsr $8cbf	                jsr w_one_plus ; AT-XY is zero based, but ANSI is 1 based
.82c4		20 40 d8	jsr $d840	                jsr print_u
.82c7		a9 48		lda #$48	                lda #'H'
.82c9		20 86 86	jsr $8686	                jsr emit_a
.82cc		68		pla		                pla
.82cd		85 18		sta $18		                sta base
.82cf		60		rts		z_at_xy:        rts
.82d0						xt_backslash:
.82d0						w_backslash:
.82d0		a0 04		ldy #$04	                ldy #blk_offset
.82d2		b1 08		lda ($08),y	                lda (up),y
.82d4		c8		iny		                iny
.82d5		11 08		ora ($08),y	                ora (up),y
.82d7		f0 19		beq $82f2	                beq backslash_not_block
.82d9		a5 10		lda $10		                lda toin
.82db		29 3f		and #$3f	                and #$3F
.82dd		f0 1b		beq $82fa	                beq z_backslash
.82df		c9 01		cmp #$01	                cmp #$1
.82e1		f0 17		beq $82fa	                beq z_backslash
.82e3		a5 10		lda $10		                lda toin
.82e5		29 c0		and #$c0	                and #$C0        ; Clear lower bits to move to beginning of line.
.82e7		18		clc		                clc             ; Add $40 (64 decimal) to move to next line.
.82e8		69 40		adc #$40	                adc #$40
.82ea		85 10		sta $10		                sta toin
.82ec		90 0c		bcc $82fa	                bcc z_backslash
.82ee		e6 11		inc $11		                inc toin+1
.82f0		80 08		bra $82fa	                bra z_backslash
.82f2						backslash_not_block:
.82f2		a5 0e		lda $0e		                lda ciblen
.82f4		85 10		sta $10		                sta toin
.82f6		a5 0f		lda $0f		                lda ciblen+1
.82f8		85 11		sta $11		                sta toin+1
.82fa		60		rts		z_backslash:    rts
.82fb						xt_base:
.82fb						w_base:
.82fb		ca		dex		                dex
.82fc		ca		dex		                dex
.82fd		a9 18		lda #$18	                lda #<base
.82ff		95 00		sta $00,x	                sta 0,x         ; LSB
.8301		74 01		stz $01,x	                stz 1,x         ; MSB is always 0
.8303		60		rts		z_base:         rts
.8304						xt_bl:
.8304						w_bl:
.8304		ca		dex		                dex
.8305		ca		dex		                dex
.8306		a9 20		lda #$20	                lda #AscSP
.8308		95 00		sta $00,x	                sta 0,x
.830a		74 01		stz $01,x	                stz 1,x
.830c		60		rts		z_bl:           rts
.830d						xt_bracket_char:
.830d						w_bracket_char:
.830d		20 53 83	jsr $8353	                jsr w_char
.8310		20 d3 89	jsr $89d3	                jsr w_literal
.8313		60		rts		z_bracket_char: rts
.8314						xt_bracket_tick:
.8314						w_bracket_tick:
.8314		20 2f 92	jsr $922f	                jsr w_tick
.8317		20 d3 89	jsr $89d3	                jsr w_literal
.831a		60		rts		z_bracket_tick: rts
.831b						xt_buffer_colon:
.831b						w_buffer_colon:
.831b		20 f2 83	jsr $83f2	                jsr w_create            ; will report default PFA size of 2 in SEE
.831e		20 2a 82	jsr $822a	                jsr w_allot
.8321		60		rts		z_buffer_colon: rts
.8322						xt_c_comma:
.8322		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8325						w_c_comma:
.8325		b5 00		lda $00,x	                lda 0,x
.8327		20 bc 97	jsr $97bc	                jsr cmpl_a
.832a		e8		inx		                inx
.832b		e8		inx		                inx
.832c		60		rts		z_c_comma:      rts
.832d						xt_c_fetch:
.832d		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8330						w_c_fetch:
.8330		a1 00		lda ($00,x)	                lda (0,x)
.8332		95 00		sta $00,x	                sta 0,x
.8334		74 01		stz $01,x	                stz 1,x         ; Ignore LSB
.8336		60		rts		z_c_fetch:      rts
.8337						xt_c_store:
.8337		20 d9 d7	jsr $d7d9	                jsr underflow_2
.833a						w_c_store:
.833a		b5 02		lda $02,x	                lda 2,x
.833c		81 00		sta ($00,x)	                sta (0,x)
.833e		e8		inx		                inx
.833f		e8		inx		                inx
.8340		e8		inx		                inx
.8341		e8		inx		                inx
.8342		60		rts		z_c_store:      rts
.8343						xt_cell_plus:
.8343		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8346						w_cell_plus:
.8346		f6 00		inc $00,x	                inc 0,x
.8348		d0 02		bne $834c	                bne +
.834a		f6 01		inc $01,x	                inc 1,x
.834c						+
.834c		f6 00		inc $00,x	                inc 0,x
.834e		d0 02		bne $8352	                bne _done
.8350		f6 01		inc $01,x	                inc 1,x
.8352						_done:
.8352		60		rts		z_cell_plus:    rts
.8353						xt_char:
.8353						w_char:
.8353		20 24 8d	jsr $8d24	                jsr w_parse_name
.8356		b5 00		lda $00,x	                lda 0,x
.8358		15 01		ora $01,x	                ora 1,x
.835a		d0 05		bne $8361	                bne _not_empty
.835c		a9 05		lda #$05	                lda #err_noname
.835e		4c ea d7	jmp $d7ea	                jmp error
.8361						_not_empty:
.8361		e8		inx		                inx             ; drop number of characters, leave addr
.8362		e8		inx		                inx
.8363		a1 00		lda ($00,x)	                lda (0,x)       ; get character (equivalent to C@)
.8365		95 00		sta $00,x	                sta 0,x
.8367		74 01		stz $01,x	                stz 1,x         ; MSB is always zero
.8369		60		rts		z_char:         rts
.836a						xt_chars:
.836a		20 d4 d7	jsr $d7d4	                jsr underflow_1
.836d						w_chars:
.836d		60		rts		z_chars:        rts
.836e						xt_colon:
.836e						w_colon:
.836e		a5 1a		lda $1a		                lda state
.8370		05 1b		ora $1b		                ora state+1
.8372		f0 05		beq $8379	                beq +
.8374		a9 07		lda #$07	                lda #err_state
.8376		4c ea d7	jmp $d7ea	                jmp error
.8379						+
.8379		c6 1a		dec $1a		                dec state
.837b		c6 1b		dec $1b		                dec state+1
.837d		a9 d0		lda #$d0	                lda #%11010000
.837f		04 1c		tsb $1c		                tsb status
.8381		a5 00		lda $00		                lda cp
.8383		85 06		sta $06		                sta workword
.8385		a5 01		lda $01		                lda cp+1
.8387		85 07		sta $07		                sta workword+1
.8389		a0 00		ldy #$00	                ldy #0                  ; Tell CREATE we want neither CFA nor dictionary update
.838b		20 fa 83	jsr $83fa	                jsr create_common
.838e		60		rts		z_colon:        rts
.838f						xt_colon_noname:
.838f						w_colon_noname:
.838f		a5 1a		lda $1a		                lda state
.8391		05 1b		ora $1b		                ora state+1
.8393		f0 05		beq $839a	                beq +
.8395		a9 07		lda #$07	                lda #err_state
.8397		4c ea d7	jmp $d7ea	                jmp error
.839a						+
.839a		c6 1a		dec $1a		                dec state
.839c		c6 1b		dec $1b		                dec state+1
.839e		a9 40		lda #$40	                lda #%01000000
.83a0		14 1c		trb $1c		                trb status
.83a2		a5 00		lda $00		                lda cp
.83a4		85 06		sta $06		                sta workword
.83a6		a5 01		lda $01		                lda cp+1
.83a8		85 07		sta $07		                sta workword+1
.83aa		60		rts		z_colon_noname:        rts
.83ab						xt_comma:
.83ab		20 d4 d7	jsr $d7d4	                jsr underflow_1
.83ae						w_comma:
.83ae		a0 02		ldy #$02	                ldy #2
.83b0		b5 00		lda $00,x	_twice:         lda 0,x
.83b2		20 bc 97	jsr $97bc	                jsr cmpl_a
.83b5		e8		inx		                inx
.83b6		88		dey		                dey
.83b7		d0 f7		bne $83b0	                bne _twice
.83b9		60		rts		z_comma:        rts
.83ba						xt_compile_only:
.83ba						w_compile_only:
.83ba		20 2d d7	jsr $d72d	                jsr current_to_dp
.83bd		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.83bf		b1 02		lda ($02),y	                lda (dp),y
.83c1		09 01		ora #$01	                ora #CO        ; make sure bit 7 is set
.83c3		91 02		sta ($02),y	                sta (dp),y
.83c5		60		rts		z_compile_only: rts
.83c6						xt_value:
.83c6						xt_constant:
.83c6		20 d4 d7	jsr $d7d4	                jsr underflow_1
.83c9						w_value:
.83c9						w_constant:
.83c9		a9 02		lda #$02	                lda #2
.83cb		85 1e		sta $1e		                sta tmpdsp              ; 2 byte PFA
.83cd		a9 43		lda #$43	                lda #<doconst           ; LSB of DOCONST
.83cf		a0 d6		ldy #$d6	                ldy #>doconst           ; MSB of DOCONST
.83d1		20 fa 83	jsr $83fa	                jsr create_common
.83d4		20 ae 83	jsr $83ae	                jsr w_comma
.83d7						z_value:
.83d7		60		rts		z_constant:     rts
.83d8						xt_count:
.83d8		20 d4 d7	jsr $d7d4	                jsr underflow_1
.83db						w_count:
.83db		a1 00		lda ($00,x)	                lda (0,x)       ; Get number of characters (255 max)
.83dd		a8		tay		                tay
.83de		f6 00		inc $00,x	                inc 0,x         ; LSB
.83e0		d0 02		bne $83e4	                bne +
.83e2		f6 01		inc $01,x	                inc 1,x         ; MSB
.83e4		98		tya		+               tya
.83e5		ca		dex		                dex
.83e6		ca		dex		                dex
.83e7		95 00		sta $00,x	                sta 0,x         ; LSB
.83e9		74 01		stz $01,x	                stz 1,x         ; MSB, always zero
.83eb		60		rts		z_count:        rts
.83ec						xt_cr:
.83ec						w_cr:
.83ec		a9 0a		lda #$0a	                lda #AscLF
.83ee		20 86 86	jsr $8686	                jsr emit_a
.83f1		60		rts		z_cr:           rts
.83f2						xt_create:
.83f2						w_create:
.83f2		a9 02		lda #$02	                lda #2                  ; 2 byte PFA for variable
.83f4		85 1e		sta $1e		                sta tmpdsp
.83f6						create_dovar:
.83f6		a0 d6		ldy #$d6	                ldy #>dovar
.83f8		a9 84		lda #$84	                lda #<dovar
.83fa						create_common:
.83fa		ca		dex		                dex
.83fb		ca		dex		                dex
.83fc		95 00		sta $00,x	                sta 0,x
.83fe		94 01		sty $01,x	                sty 1,x
.8400		20 24 8d	jsr $8d24	                jsr w_parse_name        ; ( cfa addr u )
.8403		b5 00		lda $00,x	                lda 0,x
.8405		15 01		ora $01,x	                ora 1,x
.8407		d0 05		bne $840e	                bne _got_name
.8409		a9 05		lda #$05	                lda #err_noname
.840b		4c ea d7	jmp $d7ea	                jmp error
.840e						_got_name:
.840e		74 01		stz $01,x	                stz 1,x
.8410		20 9f 93	jsr $939f	                jsr w_two_dup           ; ( cfa addr u addr u )
.8413		20 5d 9b	jsr $9b5d	                jsr w_find_name         ; ( cfa addr u flag ) (non-zero nt as flag)
.8416		e8		inx		                inx                     ; pre-drop flag (nt) from find-name.
.8417		e8		inx		                inx
.8418		b5 fe		lda $fe,x	                lda $fe,x
.841a		15 ff		ora $ff,x	                ora $ff,x
.841c		f0 1a		beq $8438	                beq _new_name           ; We haven't seen this one before.
.841e		24 1c		bit $1c		                bit status
.8420		10 06		bpl $8428	                bpl _redefined_name     ; Bit 7 is zero, so print the message.
.8422		a9 80		lda #$80	                lda #$80                ; Set bit 7 to indicate dup
.8424		04 1c		tsb $1c		                tsb status
.8426		80 14		bra $843c	                bra _process_name
.8428						_redefined_name:
.8428		a9 02		lda #$02	                lda #str_redefined
.842a		20 10 d8	jsr $d810	                jsr print_string_no_lf
.842d		20 9f 93	jsr $939f	                jsr w_two_dup           ; ( cfa addr u addr u )
.8430		20 b4 94	jsr $94b4	                jsr w_type
.8433		20 b5 91	jsr $91b5	                jsr w_space
.8436		80 04		bra $843c	                bra _process_name
.8438						_new_name:
.8438		a9 80		lda #$80	                lda #$80                ; Clear status bit 7 to indicate new word.
.843a		14 1c		trb $1c		                trb status
.843c						_process_name:
.843c		a5 00		lda $00		                lda cp
.843e		85 25		sta $25		                sta tmp1
.8440		a5 01		lda $01		                lda cp+1
.8442		85 26		sta $26		                sta tmp1+1
.8444		b5 00		lda $00,x	                lda 0,x
.8446		85 27		sta $27		                sta tmp2                ; store length of string in tmp2
.8448		18		clc		                clc
.8449		69 08		adc #$08	                adc #8
.844b		85 28		sta $28		                sta tmp2+1               ; total header length
.844d		95 00		sta $00,x	                sta 0,x
.844f		74 01		stz $01,x	                stz 1,x                 ; max header size is 255 chars
.8451		20 2a 82	jsr $822a	                jsr w_allot
.8454		20 2d d7	jsr $d72d	                jsr current_to_dp
.8457		a0 00		ldy #$00	                ldy #0
.8459		a5 27		lda $27		                lda tmp2
.845b		91 25		sta ($25),y	                sta (tmp1),y
.845d		c8		iny		                iny
.845e		b5 03		lda $03,x	                lda 3,x                 ; check MSB of CFA
.8460		f0 02		beq $8464	                beq +                   ; 0 means no CFA, leave A=0
.8462		a9 10		lda #$10	                lda #HC                 ; otherwise set the HC bit
.8464						+
.8464		09 08		ora #$08	                ora #NN
.8466		91 25		sta ($25),y	                sta (tmp1),y
.8468		c8		iny		                iny
.8469		a5 02		lda $02		                lda dp
.846b		91 25		sta ($25),y	                sta (tmp1),y
.846d		c8		iny		                iny
.846e		a5 03		lda $03		                lda dp+1
.8470		91 25		sta ($25),y	                sta (tmp1),y
.8472		c8		iny		                iny
.8473		b5 03		lda $03,x	                lda 3,x
.8475		f0 08		beq $847f	                beq +
.8477		a5 26		lda $26		                lda tmp1+1
.8479		85 03		sta $03		                sta dp+1
.847b		a5 25		lda $25		                lda tmp1
.847d		85 02		sta $02		                sta dp
.847f						+
.847f		18		clc		                clc
.8480		a5 25		lda $25		                lda tmp1                ; redundant unless we skipped interlude
.8482		65 28		adc $28		                adc tmp2+1              ; add total header length
.8484		91 25		sta ($25),y	                sta (tmp1),y
.8486		85 23		sta $23		                sta tmptos              ; save result for next step
.8488		c8		iny		                iny
.8489		a5 26		lda $26		                lda tmp1+1
.848b		69 00		adc #$00	                adc #0                  ; only need the carry
.848d		91 25		sta ($25),y	                sta (tmp1),y
.848f		85 24		sta $24		                sta tmptos+1
.8491		c8		iny		                iny
.8492		18		clc		                clc
.8493		b5 03		lda $03,x	                lda 3,x
.8495		f0 04		beq $849b	                beq +                   ; leave A=0
.8497		a9 03		lda #$03	                lda #3
.8499		65 1e		adc $1e		                adc tmpdsp              ; add PFA size, assume no carry
.849b						+
.849b		65 23		adc $23		                adc tmptos              ; add LSB of xt_
.849d		91 25		sta ($25),y	                sta (tmp1),y
.849f		c8		iny		                iny
.84a0		a5 24		lda $24		                lda tmptos+1            ; recall MSB of xt_
.84a2		69 00		adc #$00	                adc #0                  ; only need the carry
.84a4		91 25		sta ($25),y	                sta (tmp1),y
.84a6		c8		iny		                iny
.84a7		b5 00		lda $00,x	                lda 0,x
.84a9		38		sec		                sec
.84aa		e9 08		sbc #$08	                sbc #8
.84ac		85 23		sta $23		                sta tmptos
.84ae		b5 01		lda $01,x	                lda 1,x
.84b0		e9 00		sbc #$00	                sbc #0          ; only need carry
.84b2		85 24		sta $24		                sta tmptos+1
.84b4						_name_loop:
.84b4		b1 23		lda ($23),y	                lda (tmptos),y
.84b6		c9 5b		cmp #$5b	                cmp #'Z'+1
.84b8		b0 06		bcs $84c0	                bcs _store_name
.84ba		c9 41		cmp #$41	                cmp #'A'
.84bc		90 02		bcc $84c0	                bcc _store_name
.84be		09 20		ora #$20	                ora #$20
.84c0						_store_name:
.84c0		91 25		sta ($25),y	                sta (tmp1),y
.84c2		c8		iny		                iny
.84c3		c6 27		dec $27		                dec tmp2
.84c5		d0 ed		bne $84b4	                bne _name_loop
.84c7		b4 03		ldy $03,x	                ldy 3,x
.84c9		f0 08		beq $84d3	                beq +
.84cb		b5 02		lda $02,x	                lda 2,x
.84cd		20 b1 97	jsr $97b1	                jsr cmpl_subroutine             ; Add the CFA jsr
.84d0		20 40 d7	jsr $d740	                jsr dp_to_current
.84d3						+
.84d3		e8		inx		                inx
.84d4		e8		inx		                inx
.84d5		e8		inx		                inx
.84d6		e8		inx		                inx
.84d7		60		rts		z_create:       rts
.84d8						xt_decimal:
.84d8						w_decimal:
.84d8		a9 0a		lda #$0a	                lda #10
.84da		85 18		sta $18		                sta base
.84dc		64 19		stz $19		                stz base+1              ; paranoid
.84de		60		rts		z_decimal:      rts
.84df						xt_defer:
.84df						w_defer:
.84df		a9 02		lda #$02	                lda #2
.84e1		85 1e		sta $1e		                sta tmpdsp      ; 2 byte PFA
.84e3		a9 57		lda #$57	                lda #<dodefer   ; LSB
.84e5		a0 d6		ldy #$d6	                ldy #>dodefer   ; MSB
.84e7		20 fa 83	jsr $83fa	                jsr create_common
.84ea		a9 f2		lda #$f2	                lda #<defer_error
.84ec		a0 84		ldy #$84	                ldy #>defer_error
.84ee		20 b8 97	jsr $97b8	                jsr cmpl_word
.84f1		60		rts		z_defer:        rts
.84f2						defer_error:
.84f2		a9 03		lda #$03	                lda #err_defer
.84f4		4c ea d7	jmp $d7ea	                jmp error
.84f7						xt_defer_fetch:
.84f7		20 d4 d7	jsr $d7d4	                jsr underflow_1
.84fa						w_defer_fetch:
.84fa		20 8e 92	jsr $928e	                jsr w_to_body
.84fd		20 e9 87	jsr $87e9	                jsr w_fetch
.8500		60		rts		z_defer_fetch:  rts
.8501						xt_defer_store:
.8501		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8504						w_defer_store:
.8504		20 8e 92	jsr $928e	                jsr w_to_body
.8507		20 08 92	jsr $9208	                jsr w_store
.850a		60		rts		z_defer_store:  rts
.850b						xt_depth:
.850b						w_depth:
.850b		a9 78		lda #$78	                lda #dsp0
.850d		86 1e		stx $1e		                stx tmpdsp
.850f		38		sec		                sec
.8510		e5 1e		sbc $1e		                sbc tmpdsp
.8512		4a		lsr a		                lsr
.8513		ca		dex		                dex
.8514		ca		dex		                dex
.8515		95 00		sta $00,x	                sta 0,x
.8517		74 01		stz $01,x	                stz 1,x
.8519		60		rts		z_depth:        rts
.851a						xt_question_do:
.851a						w_question_do:
.851a		ca		dex		                dex
.851b		ca		dex		                dex
.851c		a9 5d		lda #$5d	                lda #<question_do_runtime
.851e		95 00		sta $00,x	                sta 0,x
.8520		a9 85		lda #$85	                lda #>question_do_runtime
.8522		95 01		sta $01,x	                sta 1,x
.8524		20 5c 86	jsr $865c	                jsr w_dup              ; xt and xt' are the same
.8527		ca		dex		                dex
.8528		ca		dex		                dex
.8529		a9 10		lda #$10	                lda #question_do_runtime_size
.852b		95 00		sta $00,x	                sta 0,x
.852d		74 01		stz $01,x	                stz 1,x
.852f		20 2f 97	jsr $972f	                jsr cmpl_by_limit
.8532		90 0b		bcc $853f	                bcc _native
.8534		20 e7 88	jsr $88e7	                jsr w_here
.8537		20 66 9e	jsr $9e66	                jsr w_zero
.853a		20 ae 83	jsr $83ae	                jsr w_comma
.853d		80 08		bra $8547	                bra do_common
.853f						_native:
.853f		20 91 97	jsr $9791	                jsr cmpl_jump_later
.8542		80 03		bra $8547	                bra do_common
.8544						xt_do:
.8544						w_do:
.8544		20 66 9e	jsr $9e66	                jsr w_zero             ; push 0 TOS
.8547						do_common:
.8547		ca		dex		                dex
.8548		ca		dex		                dex
.8549		a5 21		lda $21		                lda loopleave
.854b		95 00		sta $00,x	                sta 0,x
.854d		a5 22		lda $22		                lda loopleave+1
.854f		95 01		sta $01,x	                sta 1,x
.8551		64 22		stz $22		                stz loopleave+1
.8553		a0 85		ldy #$85	                ldy #>do_runtime
.8555		a9 75		lda #$75	                lda #<do_runtime
.8557		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.855a		4c e7 88	jmp $88e7	                jmp w_here
.855d						z_question_do:
.855d						z_do:
.855d						question_do_runtime:
.855d		b5 00		lda $00,x	                lda 0,x
.855f		d5 02		cmp $02,x	                cmp 2,x
.8561		d0 0d		bne $8570	                bne _begin
.8563		b5 01		lda $01,x	                lda 1,x
.8565		d5 03		cmp $03,x	                cmp 3,x
.8567		d0 07		bne $8570	                bne _begin
.8569		e8		inx		                inx                     ; drop loop limits and skip
.856a		e8		inx		                inx
.856b		e8		inx		                inx
.856c		e8		inx		                inx
=16						question_do_runtime_size = * - question_do_runtime
.856d		a9 00		lda #$00	                lda #0
>856f		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8570		a9 01		lda #$01	_begin:         lda #1
.8572		4c 54 98	jmp $9854	                jmp zbranch_runtime
.8575						do_runtime:
.8575		a4 1f		ldy $1f		                ldy loopctrl
.8577		30 05		bmi $857e	                bmi +                   ; is this the first LCB?
.8579		a5 20		lda $20		                lda loopidx0            ; no, write cached LSB
.857b		99 00 01	sta $0100,y	                sta loopindex,y         ; back to loopindex in the LCB
.857e						+
.857e		c8		iny		                iny                     ; Reserve 4 bytes for next LCB
.857f		c8		iny		                iny
.8580		c8		iny		                iny
.8581		c8		iny		                iny
.8582		84 1f		sty $1f		                sty loopctrl            ; Udpate LCB stack pointer
.8584		38		sec		                sec
.8585		a9 00		lda #$00	                lda #0
.8587		f5 02		sbc $02,x	                sbc 2,x             ; LSB of limit
.8589		99 02 01	sta $0102,y	                sta loopfufa,y      ; write to loop control block
.858c		a9 80		lda #$80	                lda #$80
.858e		f5 03		sbc $03,x	                sbc 3,x             ; MSB of limit
.8590		99 03 01	sta $0103,y	                sta loopfufa+1,y
.8593		18		clc		                clc
.8594		b5 00		lda $00,x	                lda 0,x             ; LSB of original index
.8596		79 02 01	adc $0102,y	                adc loopfufa,y
.8599		85 20		sta $20		                sta loopidx0        ; write LSB to cache not LCB
.859b		b5 01		lda $01,x	                lda 1,x             ; MSB of orginal index
.859d		79 03 01	adc $0103,y	                adc loopfufa+1,y
.85a0		99 01 01	sta $0101,y	                sta loopindex+1,y
.85a3		e8		inx		                inx                 ; clean up the stack
.85a4		e8		inx		                inx
.85a5		e8		inx		                inx
.85a6		e8		inx		                inx
.85a7		60		rts		                rts
.85a8						xt_does:
.85a8						w_does:
.85a8		a0 85		ldy #$85	                ldy #>does_runtime
.85aa		a9 b7		lda #$b7	                lda #<does_runtime
.85ac		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.85af		a0 d6		ldy #$d6	                ldy #>dodoes
.85b1		a9 6b		lda #$6b	                lda #<dodoes
.85b3		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.85b6		60		rts		z_does:         rts
.85b7						does_runtime:
.85b7		7a		ply		                ply             ; LSB
.85b8		68		pla		                pla             ; MSB
.85b9		c8		iny		                iny
.85ba		d0 01		bne $85bd	                bne +
.85bc		1a		inc a		                ina
.85bd						+
.85bd		84 25		sty $25		                sty tmp1
.85bf		85 26		sta $26		                sta tmp1+1
.85c1		20 2d d7	jsr $d72d	                jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
.85c4		a5 02		lda $02		                lda dp
.85c6		18		clc		                clc
.85c7		69 04		adc #$04	                adc #4
.85c9		85 27		sta $27		                sta tmp2
.85cb		a5 03		lda $03		                lda dp+1
.85cd		69 00		adc #$00	                adc #0          ; we only care about the carry
.85cf		85 28		sta $28		                sta tmp2+1
.85d1		b2 27		lda ($27)	                lda (tmp2)
.85d3		18		clc		                clc
.85d4		69 01		adc #$01	                adc #1
.85d6		85 29		sta $29		                sta tmp3
.85d8		a0 01		ldy #$01	                ldy #1
.85da		b1 27		lda ($27),y	                lda (tmp2),y
.85dc		69 00		adc #$00	                adc #0          ; we only care about the carry
.85de		85 2a		sta $2a		                sta tmp3+1
.85e0		a5 25		lda $25		                lda tmp1        ; LSB
.85e2		92 29		sta ($29)	                sta (tmp3)
.85e4		a5 26		lda $26		                lda tmp1+1
.85e6		91 29		sta ($29),y	                sta (tmp3),y    ; Y is still 1
.85e8		60		rts		                rts
.85e9						xt_dot:
.85e9		20 d4 d7	jsr $d7d4	                jsr underflow_1
.85ec						w_dot:
.85ec		20 5c 86	jsr $865c	                jsr w_dup                      ; ( n n )
.85ef		20 d2 80	jsr $80d2	                jsr w_abs                      ; ( n u )
.85f2		20 66 9e	jsr $9e66	                jsr w_zero                     ; ( n u 0 )
.85f5		20 ad 89	jsr $89ad	                jsr w_less_number_sign         ; ( n u 0 )
.85f8		20 89 8c	jsr $8c89	                jsr w_number_sign_s            ; ( n ud )
.85fb		20 5c 8f	jsr $8f5c	                jsr w_rot                      ; ( ud n )
.85fe		20 38 91	jsr $9138	                jsr w_sign                     ; ( ud )
.8601		20 67 8c	jsr $8c67	                jsr w_number_sign_greater      ; ( addr u )
.8604		20 b4 94	jsr $94b4	                jsr w_type
.8607		20 b5 91	jsr $91b5	                jsr w_space
.860a		60		rts		z_dot:          rts
.860b						xt_dot_paren:
.860b						w_dot_paren:
.860b		ca		dex		                dex
.860c		ca		dex		                dex
.860d		a9 29		lda #$29	                lda #41     ; Right parenthesis
.860f		95 00		sta $00,x	                sta 0,x
.8611		74 01		stz $01,x	                stz 1,x
.8613		20 82 8d	jsr $8d82	                jsr w_parse
.8616		20 b4 94	jsr $94b4	                jsr w_type
.8619		60		rts		z_dot_paren:    rts
.861a						xt_dot_quote:
.861a						w_dot_quote:
.861a		20 a2 8f	jsr $8fa2	                jsr w_s_quote
.861d		a0 94		ldy #$94	                ldy #>w_type
.861f		a9 b4		lda #$b4	                lda #<w_type
.8621		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.8624		60		rts		z_dot_quote:    rts
.8625						xt_dot_r:
.8625		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8628						w_dot_r:
.8628		20 59 93	jsr $9359	                jsr w_to_r
.862b		20 5c 86	jsr $865c	                jsr w_dup
.862e		20 d2 80	jsr $80d2	                jsr w_abs
.8631		20 66 9e	jsr $9e66	                jsr w_zero
.8634		20 ad 89	jsr $89ad	                jsr w_less_number_sign
.8637		20 89 8c	jsr $8c89	                jsr w_number_sign_s
.863a		20 5c 8f	jsr $8f5c	                jsr w_rot
.863d		20 38 91	jsr $9138	                jsr w_sign
.8640		20 67 8c	jsr $8c67	                jsr w_number_sign_greater
.8643		20 b5 8e	jsr $8eb5	                jsr w_r_from
.8646		20 db 8c	jsr $8cdb	                jsr w_over
.8649		20 bb 8b	jsr $8bbb	                jsr w_minus
.864c		20 be 91	jsr $91be	                jsr w_spaces
.864f		20 b4 94	jsr $94b4	                jsr w_type
.8652		60		rts		z_dot_r:        rts
.8653						xt_drop:
.8653		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8656						w_drop:
.8656		e8		inx		                inx
.8657		e8		inx		                inx
.8658		60		rts		z_drop:         rts
.8659						xt_dup:
.8659		20 d4 d7	jsr $d7d4	                jsr underflow_1
.865c						w_dup:
.865c		ca		dex		                dex
.865d		ca		dex		                dex
.865e		b5 02		lda $02,x	                lda 2,x         ; LSB
.8660		95 00		sta $00,x	                sta 0,x
.8662		b5 03		lda $03,x	                lda 3,x         ; MSB
.8664		95 01		sta $01,x	                sta 1,x
.8666		60		rts		z_dup:          rts
.8667						xt_else:
.8667						xt_endof:
.8667		20 d4 d7	jsr $d7d4	                jsr underflow_1
.866a						w_else:
.866a						w_endof:
.866a		20 91 97	jsr $9791	                jsr cmpl_jump_later
.866d		20 1e 92	jsr $921e	                jsr w_swap              ; ( target orig )
.8670		80 03		bra $8675	                bra w_then              ; fall through to then
.8672						xt_then:
.8672		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8675						w_then:
.8675		20 e7 88	jsr $88e7	                jsr w_here
.8678		20 1e 92	jsr $921e	                jsr w_swap
.867b		20 08 92	jsr $9208	                jsr w_store
.867e						z_else:
.867e						z_endof:
.867e		60		rts		z_then:         rts
.867f						xt_emit:
.867f		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8682						w_emit:
.8682		b5 00		lda $00,x	                lda 0,x
.8684		e8		inx		                inx
.8685		e8		inx		                inx
.8686						emit_a:
.8686		6c 12 00	jmp ($0012)	                jmp (output)            ; JSR/RTS
.8689						z_emit:
.8689						xt_endcase:
.8689		20 d4 d7	jsr $d7d4	                jsr underflow_1
.868c						w_endcase:
.868c		a0 86		ldy #$86	                ldy #>w_drop
.868e		a9 56		lda #$56	                lda #<w_drop
.8690		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.8693						_endcase_loop:
.8693		b5 00		lda $00,x	                lda 0,x
.8695		15 01		ora $01,x	                ora 1,x
.8697		f0 05		beq $869e	                beq _done
.8699		20 75 86	jsr $8675	                jsr w_then
.869c		80 f5		bra $8693	                bra _endcase_loop
.869e						_done:
.869e		e8		inx		                inx
.869f		e8		inx		                inx
.86a0		60		rts		z_endcase:      rts
.86a1						xt_environment_q:
.86a1		20 d4 d7	jsr $d7d4	                jsr underflow_1
.86a4						w_environment_q:
.86a4		a0 00		ldy #$00	                ldy #00                 ; counter for table
.86a6		5a		phy		                phy
.86a7						_table_loop:
.86a7		20 9f 93	jsr $939f	                jsr w_two_dup          ; ( addr u addr u ) 2DUP does not use Y
.86aa		ca		dex		                dex
.86ab		ca		dex		                dex                     ; ( addr u addr u ? )
.86ac		b9 1e 87	lda $871e,y	                lda env_table_single,y
.86af		95 00		sta $00,x	                sta 0,x
.86b1		c8		iny		                iny
.86b2		b9 1e 87	lda $871e,y	                lda env_table_single,y
.86b5		95 01		sta $01,x	                sta 1,x                 ; ( addr u addr u addr-t )
.86b7		c8		iny		                iny
.86b8		15 00		ora $00,x	                ora 0,x
.86ba		f0 4d		beq $8709	                beq _table_done
.86bc		5a		phy		                phy                     ; save Y, which is used by COUNT
.86bd		20 db 83	jsr $83db	                jsr w_count            ; ( addr u addr u addr-s u-s )
.86c0		20 b5 a0	jsr $a0b5	                jsr w_compare          ; ( addr u f )
.86c3		7a		ply		                ply
.86c4		b5 00		lda $00,x	                lda 0,x
.86c6		15 01		ora $01,x	                ora 1,x
.86c8		f0 04		beq $86ce	                beq _got_result
.86ca		e8		inx		                inx                     ; DROP, now ( addr u )
.86cb		e8		inx		                inx
.86cc		80 d9		bra $86a7	                bra _table_loop
.86ce						_got_result:
.86ce		e8		inx		                inx                     ; drop flag, now ( addr u )
.86cf		e8		inx		                inx
.86d0		88		dey		                dey                     ; go back to index we had
.86d1		88		dey		                dey
.86d2		68		pla		                pla
.86d3		d0 0d		bne $86e2	                bne _double_result
.86d5		b9 3c 87	lda $873c,y	                lda env_results_single,y
.86d8		95 02		sta $02,x	                sta 2,x
.86da		c8		iny		                iny
.86db		b9 3c 87	lda $873c,y	                lda env_results_single,y
.86de		95 03		sta $03,x	                sta 3,x                 ; ( res u )
.86e0		80 1f		bra $8701	                bra _set_flag
.86e2						_double_result:
.86e2		ca		dex		                dex                     ; ( addr u ? )
.86e3		ca		dex		                dex
.86e4		98		tya		                tya
.86e5		38		sec		                sec
.86e6		e9 18		sbc #$18	                sbc #24
.86e8		0a		asl a		                asl
.86e9		a8		tay		                tay
.86ea		b9 52 87	lda $8752,y	                lda env_results_double,y
.86ed		95 02		sta $02,x	                sta 2,x
.86ef		c8		iny		                iny
.86f0		b9 52 87	lda $8752,y	                lda env_results_double,y
.86f3		95 03		sta $03,x	                sta 3,x                 ; ( res u ? )
.86f5		c8		iny		                iny
.86f6		b9 52 87	lda $8752,y	                lda env_results_double,y
.86f9		95 04		sta $04,x	                sta 4,x
.86fb		c8		iny		                iny
.86fc		b9 52 87	lda $8752,y	                lda env_results_double,y
.86ff		95 05		sta $05,x	                sta 5,x                 ; ( res res ? )
.8701						_set_flag:
.8701		a9 ff		lda #$ff	                lda #$FF
.8703		95 00		sta $00,x	                sta 0,x
.8705		95 01		sta $01,x	                sta 1,x                 ; ( res f )
.8707		80 14		bra $871d	                bra _done
.8709						_table_done:
.8709		68		pla		                pla
.870a		d0 09		bne $8715	                bne _no_match
.870c		1a		inc a		                ina
.870d		48		pha		                pha
.870e		8a		txa		                txa
.870f		18		clc		                clc
.8710		69 06		adc #$06	                adc #6                  ; skip six bytes
.8712		aa		tax		                tax                     ; ( addr u )
.8713		80 92		bra $86a7	                bra _table_loop
.8715						_no_match:
.8715		8a		txa		                txa
.8716		18		clc		                clc
.8717		69 0a		adc #$0a	                adc #10
.8719		aa		tax		                tax                     ; ( addr ) - not ( 0 ) !
.871a		20 66 9e	jsr $9e66	                jsr w_false
.871d						_done:
.871d						z_environment_q:
.871d		60		rts		                rts
.871e						env_table_single:
>871e		c3 d5 d3 d5 d9 d5 de d5		        .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
>8726		f0 d5
>8728		f8 d5 01 d6 07 d6 0d d6		        .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
>8730		20 d6 2c d6 00 00		        .word envs_sc, envs_wl, 0000
.8736						env_table_double:
>8736		36 d6 3c d6 00 00		        .word envs_max_d, envs_max_ud, 0000
.873c						env_results_single:
>873c		ff 00				        .word $00FF     ; /COUNTED-STRING
>873e		ff 00				        .word $00FF     ; /HOLD
>8740		54 00				        .word $0054     ; /PAD (this is 84 decimal)
>8742		08 00				        .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
>8744		00 00				        .word 0000      ; FLOORED ("FALSE", we have symmetric)
>8746		ff 00				        .word $00FF     ; MAX-CHAR
>8748		ff 7f				        .word $7FFF     ; MAX-N
>874a		ff ff				        .word $FFFF     ; MAX-U
>874c		80 00				        .word $0080     ; RETURN-STACK-CELLS
>874e		20 00				        .word $0020     ; STACK-CELLS (from definitions.asm)
>8750		09 00				        .word $0009     ; WORDLISTS
.8752						env_results_double:
>8752		ff 7f ff ff			        .word $7FFF, $FFFF      ; MAX-D
>8756		ff ff ff ff			        .word $FFFF, $FFFF      ; MAX-UD
.875a						xt_equal:
.875a		20 d9 d7	jsr $d7d9	                jsr underflow_2
.875d						w_equal:
.875d		b5 00		lda $00,x	                lda 0,x                 ; LSB
.875f		d5 02		cmp $02,x	                cmp 2,x
.8761		d0 0a		bne $876d	                bne _false
.8763		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8765		d5 03		cmp $03,x	                cmp 3,x
.8767		d0 04		bne $876d	                bne _false
.8769		a9 ff		lda #$ff	                lda #$FF
.876b		80 02		bra $876f	                bra _done
.876d		a9 00		lda #$00	_false:         lda #0                  ; drop thru to done
.876f		95 02		sta $02,x	_done:          sta 2,x
.8771		95 03		sta $03,x	                sta 3,x
.8773		e8		inx		                inx
.8774		e8		inx		                inx
.8775		60		rts		z_equal:        rts
.8776						xt_blank:
.8776		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8779						w_blank:
.8779		ca		dex		                dex
.877a		ca		dex		                dex
.877b		a9 20		lda #$20	                lda #AscSP
.877d		95 00		sta $00,x	                sta 0,x
.877f		74 01		stz $01,x	                stz 1,x
.8781		80 0e		bra $8791	                bra w_fill     ; skip over code for ERASE
.8783						xt_erase:
.8783		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8786						w_erase:
.8786		ca		dex		                dex
.8787		ca		dex		                dex
.8788		74 00		stz $00,x	                stz 0,x
.878a		74 01		stz $01,x	                stz 1,x
.878c		80 03		bra $8791	                bra w_fill
.878e						xt_fill:
.878e		20 de d7	jsr $d7de	                jsr underflow_3
.8791						w_fill:
.8791		b5 04		lda $04,x	                lda 4,x         ; LSB
.8793		85 25		sta $25		                sta tmp1
.8795		b5 05		lda $05,x	                lda 5,x
.8797		85 26		sta $26		                sta tmp1+1
.8799		b5 02		lda $02,x	                lda 2,x
.879b		85 27		sta $27		                sta tmp2
.879d		b5 03		lda $03,x	                lda 3,x
.879f		85 28		sta $28		                sta tmp2+1
.87a1		b5 00		lda $00,x	                lda 0,x
.87a3		a8		tay		                tay
.87a4						_loop:
.87a4		a9 7f		lda #$7f	                lda #>ram_end           ; MSB
.87a6		c5 26		cmp $26		                cmp tmp1+1
.87a8		90 21		bcc $87cb	                bcc _done               ; RAM_END < TMP1, so leave
.87aa		d0 06		bne $87b2	                bne _check_counter      ; RAM_END is not smaller and not equal
.87ac		a9 ff		lda #$ff	                lda #<ram_end           ; LSB, because MSBs were equal
.87ae		c5 25		cmp $25		                cmp tmp1
.87b0		90 19		bcc $87cb	                bcc _done               ; RAM_END < TMP1, so leave
.87b2						_check_counter:
.87b2		a5 27		lda $27		                lda tmp2
.87b4		05 28		ora $28		                ora tmp2+1
.87b6		f0 13		beq $87cb	                beq _done
.87b8		98		tya		                tya
.87b9		92 25		sta ($25)	                sta (tmp1)
.87bb		a5 27		lda $27		                lda tmp2
.87bd		d0 02		bne $87c1	                bne +
.87bf		c6 28		dec $28		                dec tmp2+1
.87c1		c6 27		dec $27		+               dec tmp2
.87c3		e6 25		inc $25		                inc tmp1
.87c5		d0 dd		bne $87a4	                bne _loop
.87c7		e6 26		inc $26		                inc tmp1+1
.87c9		80 d9		bra $87a4	                bra _loop
.87cb						_done:
.87cb		8a		txa		                txa
.87cc		18		clc		                clc
.87cd		69 06		adc #$06	                adc #6
.87cf		aa		tax		                tax
.87d0						z_blank:
.87d0						z_erase:
.87d0		60		rts		z_fill:         rts
.87d1						xt_execute:
.87d1		20 d4 d7	jsr $d7d4	                jsr underflow_1
.87d4						w_execute:
.87d4		20 d8 87	jsr $87d8	                jsr doexecute   ; do not combine to JMP (native coding)
.87d7		60		rts		z_execute:      rts
.87d8						doexecute:
.87d8		b5 00		lda $00,x	                lda 0,x
.87da		85 04		sta $04		                sta ip
.87dc		b5 01		lda $01,x	                lda 1,x
.87de		85 05		sta $05		                sta ip+1
.87e0		e8		inx		                inx
.87e1		e8		inx		                inx
.87e2		6c 04 00	jmp ($0004)	                jmp (ip)
.87e5						xt_exit:
.87e5						w_exit:
.87e5		60		rts		                rts             ; keep before z_exit
.87e6						z_exit:
.87e6						xt_fetch:
.87e6		20 d4 d7	jsr $d7d4	                jsr underflow_1
.87e9						w_fetch:
.87e9		a1 00		lda ($00,x)	                lda (0,x)               ; LSB
.87eb		a8		tay		                tay
.87ec		f6 00		inc $00,x	                inc 0,x
.87ee		d0 02		bne $87f2	                bne +
.87f0		f6 01		inc $01,x	                inc 1,x
.87f2						+
.87f2		a1 00		lda ($00,x)	                lda (0,x)               ; MSB
.87f4		95 01		sta $01,x	                sta 1,x
.87f6		94 00		sty $00,x	                sty 0,x
.87f8		60		rts		z_fetch:        rts
.87f9						xt_find:
.87f9		20 d4 d7	jsr $d7d4	                jsr underflow_1
.87fc						w_find:
.87fc		b5 01		lda $01,x	                lda 1,x                 ; MSB
.87fe		48		pha		                pha
.87ff		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8801		48		pha		                pha
.8802		20 db 83	jsr $83db	                jsr w_count            ; ( caddr -- addr u )
.8805		20 5d 9b	jsr $9b5d	                jsr w_find_name        ; ( addr u -- nt | 0 )
.8808		b5 00		lda $00,x	                lda 0,x
.880a		15 01		ora $01,x	                ora 1,x
.880c		d0 0b		bne $8819	                bne _found_word
.880e		20 66 9e	jsr $9e66	                jsr w_false            ; ( 0 0 )
.8811		68		pla		                pla                     ; LSB of address
.8812		95 02		sta $02,x	                sta 2,x
.8814		68		pla		                pla
.8815		95 03		sta $03,x	                sta 3,x                 ; MSB of address
.8817		80 27		bra $8840	                bra _done               ; ( addr 0 )
.8819						_found_word:
.8819		68		pla		                pla
.881a		68		pla		                pla
.881b		20 5c 86	jsr $865c	                jsr w_dup              ; ( nt nt )
.881e		20 a6 9c	jsr $9ca6	                jsr w_name_to_int      ; ( nt xt )
.8821		20 1e 92	jsr $921e	                jsr w_swap             ; ( xt nt )
.8824		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.8826		f6 00		inc $00,x	                inc 0,x
.8828		d0 02		bne $882c	                bne +
.882a		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.882c						+
.882c		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.882e		29 02		and #$02	                and #IM
.8830		d0 08		bne $883a	                bne _immediate          ; bit set, we're immediate
.8832		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.8834		95 00		sta $00,x	                sta 0,x
.8836		95 01		sta $01,x	                sta 1,x
.8838		80 06		bra $8840	                bra _done
.883a						_immediate:
.883a		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.883c		95 00		sta $00,x	                sta 0,x
.883e		74 01		stz $01,x	                stz 1,x
.8840						_done:
.8840		60		rts		z_find:         rts
.8841						xt_fm_slash_mod:
.8841		20 de d7	jsr $d7de	                jsr underflow_3
.8844						w_fm_slash_mod:
.8844		64 27		stz $27		                stz tmp2        ; default: n is positive
.8846		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8848		10 0e		bpl $8858	                bpl _check_d
.884a		e6 27		inc $27		                inc tmp2        ; set flag to negative for n1
.884c		20 f9 8b	jsr $8bf9	                jsr w_negate   ; NEGATE
.884f		20 59 93	jsr $9359	                jsr w_to_r     ; >R
.8852		20 d7 9e	jsr $9ed7	                jsr w_dnegate  ; DNEGATE
.8855		20 b5 8e	jsr $8eb5	                jsr w_r_from   ; R>
.8858						_check_d:
.8858		b5 03		lda $03,x	                lda 3,x         ; MSB of high word of d
.885a		10 0d		bpl $8869	                bpl _multiply
.885c		18		clc		                clc
.885d		b5 00		lda $00,x	                lda 0,x         ; LSB of n1
.885f		75 02		adc $02,x	                adc 2,x         ; LSB of dh
.8861		95 02		sta $02,x	                sta 2,x
.8863		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8865		75 03		adc $03,x	                adc 3,x         ; MSB of dh
.8867		95 03		sta $03,x	                sta 3,x
.8869						_multiply:
.8869		20 39 95	jsr $9539	                jsr w_um_slash_mod     ; ( d n1 -- rem n2 )
.886c		a5 27		lda $27		                lda tmp2
.886e		f0 07		beq $8877	                beq _done
.8870		e8		inx		                inx             ; pretend that we SWAP
.8871		e8		inx		                inx
.8872		20 f9 8b	jsr $8bf9	                jsr w_negate
.8875		ca		dex		                dex
.8876		ca		dex		                dex
.8877						_done:
.8877		60		rts		z_fm_slash_mod: rts
.8878						load_evaluate:
.8878		a9 ff		lda #$ff	                lda #$FF
.887a		85 25		sta $25		                sta tmp1
.887c		80 11		bra $888f	                bra load_evaluate_start
.887e						xt_evaluate:
.887e		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8881						w_evaluate:
.8881		64 25		stz $25		                stz tmp1
.8883		b5 00		lda $00,x	                lda 0,x
.8885		15 01		ora $01,x	                ora 1,x
.8887		d0 06		bne $888f	                bne evaluate_got_work
.8889		e8		inx		                inx
.888a		e8		inx		                inx
.888b		e8		inx		                inx
.888c		e8		inx		                inx
.888d		80 42		bra $88d1	                bra evaluate_done
.888f						load_evaluate_start:
.888f						evaluate_got_work:
.888f		a0 05		ldy #$05	                ldy #blk_offset+1
.8891		b1 08		lda ($08),y	                lda (up),y
.8893		48		pha		                pha
.8894		88		dey		                dey
.8895		b1 08		lda ($08),y	                lda (up),y
.8897		48		pha		                pha
.8898		a5 25		lda $25		                lda tmp1
.889a		d0 05		bne $88a1	                bne _nozero
.889c		91 08		sta ($08),y	                sta (up),y
.889e		c8		iny		                iny
.889f		91 08		sta ($08),y	                sta (up),y
.88a1						_nozero:
.88a1		20 07 9c	jsr $9c07	                jsr w_input_to_r
.88a4		a9 ff		lda #$ff	                lda #$FF
.88a6		85 0a		sta $0a		                sta insrc
.88a8		85 0b		sta $0b		                sta insrc+1
.88aa		64 10		stz $10		                stz toin
.88ac		64 11		stz $11		                stz toin+1
.88ae		b5 00		lda $00,x	                lda 0,x
.88b0		85 0e		sta $0e		                sta ciblen
.88b2		b5 01		lda $01,x	                lda 1,x
.88b4		85 0f		sta $0f		                sta ciblen+1
.88b6		b5 02		lda $02,x	                lda 2,x
.88b8		85 0c		sta $0c		                sta cib
.88ba		b5 03		lda $03,x	                lda 3,x
.88bc		85 0d		sta $0d		                sta cib+1
.88be		e8		inx		                inx             ; A clean stack is a clean mind
.88bf		e8		inx		                inx
.88c0		e8		inx		                inx
.88c1		e8		inx		                inx
.88c2		20 53 d7	jsr $d753	                jsr interpret   ; ( -- )
.88c5		20 14 9e	jsr $9e14	                jsr w_r_to_input
.88c8		a0 04		ldy #$04	                ldy #blk_offset
.88ca		68		pla		                pla
.88cb		91 08		sta ($08),y	                sta (up),y
.88cd		c8		iny		                iny
.88ce		68		pla		                pla
.88cf		91 08		sta ($08),y	                sta (up),y
.88d1						evaluate_done:
.88d1		60		rts		z_evaluate:     rts
.88d2						xt_greater_than:
.88d2		20 d9 d7	jsr $d7d9	                jsr underflow_2
.88d5						w_greater_than:
.88d5		a0 00		ldy #$00	                ldy #0          ; default false
.88d7		20 14 d7	jsr $d714	                jsr compare_16bit
.88da		f0 03		beq $88df	                beq _false
.88dc		10 01		bpl $88df	                bpl _false
.88de		88		dey		                dey
.88df						_false:
.88df		98		tya		                tya
.88e0		e8		inx		                inx
.88e1		e8		inx		                inx
.88e2		95 00		sta $00,x	                sta 0,x
.88e4		95 01		sta $01,x	                sta 1,x
.88e6		60		rts		z_greater_than: rts
.88e7						xt_here:
.88e7						xt_begin:
.88e7						xt_asm_arrow:
.88e7						w_here:
.88e7						w_begin:
.88e7						w_asm_arrow:
.88e7		ca		dex		                dex
.88e8		ca		dex		                dex
.88e9		a5 00		lda $00		                lda cp
.88eb		95 00		sta $00,x	                sta 0,x
.88ed		a5 01		lda $01		                lda cp+1
.88ef		95 01		sta $01,x	                sta 1,x
.88f1						z_here:
.88f1						z_begin:
.88f1						z_asm_arrow:
.88f1		60		rts		                rts
.88f2						xt_hex:
.88f2						w_hex:
.88f2		a9 10		lda #$10	                lda #16
.88f4		85 18		sta $18		                sta base
.88f6		64 19		stz $19		                stz base+1              ; paranoid
.88f8		60		rts		z_hex:          rts
.88f9						xt_hold:
.88f9		20 d4 d7	jsr $d7d4	                jsr underflow_1
.88fc						w_hold:
.88fc		a5 2b		lda $2b		                lda tohold
.88fe		d0 02		bne $8902	                bne +
.8900		c6 2c		dec $2c		                dec tohold+1
.8902						+
.8902		c6 2b		dec $2b		                dec tohold
.8904		b5 00		lda $00,x	                lda 0,x
.8906		92 2b		sta ($2b)	                sta (tohold)
.8908		e8		inx		                inx
.8909		e8		inx		                inx
.890a		60		rts		z_hold:         rts
.890b						xt_i:
.890b						w_i:
.890b		ca		dex		                dex
.890c		ca		dex		                dex
.890d		a4 1f		ldy $1f		                ldy loopctrl
.890f		38		sec		                sec
.8910		a5 20		lda $20		                lda loopidx0        ; cached LSB of loopindex
.8912		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8915		95 00		sta $00,x	                sta 0,x
.8917		b9 01 01	lda $0101,y	                lda loopindex+1,y
.891a		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.891d		95 01		sta $01,x	                sta 1,x
.891f		60		rts		z_i:            rts
.8920						xt_if:
.8920						w_if:
.8920		20 d7 97	jsr $97d7	                jsr cmpl_0branch_later
.8923		60		rts		z_if:           rts
.8924						xt_immediate:
.8924						w_immediate:
.8924		20 2d d7	jsr $d72d	                jsr current_to_dp
.8927		a0 01		ldy #$01	                ldy #1          ; offset for status byte
.8929		b1 02		lda ($02),y	                lda (dp),y
.892b		09 02		ora #$02	                ora #IM        ; make sure bit 7 is set
.892d		91 02		sta ($02),y	                sta (dp),y
.892f		60		rts		z_immediate:    rts
.8930						xt_invert:
.8930		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8933						w_invert:
.8933		a9 ff		lda #$ff	                lda #$FF
.8935		55 00		eor $00,x	                eor 0,x         ; LSB
.8937		95 00		sta $00,x	                sta 0,x
.8939		a9 ff		lda #$ff	                lda #$FF
.893b		55 01		eor $01,x	                eor 1,x         ; MSB
.893d		95 01		sta $01,x	                sta 1,x
.893f		60		rts		z_invert:       rts
.8940						xt_is:
.8940						w_is:
.8940		a5 1a		lda $1a		                lda state
.8942		05 1b		ora $1b		                ora state+1
.8944		f0 0c		beq $8952	                beq _interpreting
.8946		20 14 83	jsr $8314	                jsr w_bracket_tick
.8949		a0 85		ldy #$85	                ldy #>w_defer_store
.894b		a9 04		lda #$04	                lda #<w_defer_store
.894d		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.8950		80 06		bra $8958	                bra _done
.8952						_interpreting:
.8952		20 2f 92	jsr $922f	                jsr w_tick
.8955		20 04 85	jsr $8504	                jsr w_defer_store
.8958						_done:
.8958		60		rts		z_is:           rts
.8959						xt_j:
.8959						w_j:
.8959		ca		dex		                dex                 ; make space on the stack
.895a		ca		dex		                dex
.895b		a5 1f		lda $1f		                lda loopctrl
.895d		38		sec		                sec
.895e		e9 04		sbc #$04	                sbc #4
.8960		a8		tay		                tay
.8961		38		sec		                sec
.8962		b9 00 01	lda $0100,y	                lda loopindex,y
.8965		f9 02 01	sbc $0102,y	                sbc loopfufa,y
.8968		95 00		sta $00,x	                sta 0,x
.896a		b9 01 01	lda $0101,y	                lda loopindex+1,y
.896d		f9 03 01	sbc $0103,y	                sbc loopfufa+1,y
.8970		95 01		sta $01,x	                sta 1,x
.8972		60		rts		z_j:            rts
.8973						xt_key:
.8973						w_key:
.8973		20 7d 89	jsr $897d	                jsr key_a               ; returns char in A
.8976		ca		dex		                dex
.8977		ca		dex		                dex
.8978		95 00		sta $00,x	                sta 0,x
.897a		74 01		stz $01,x	                stz 1,x
.897c		60		rts		z_key:          rts
.897d						key_a:
.897d		6c 14 00	jmp ($0014)	                jmp (input)             ; JSR/RTS
.8980						xt_keyq:
.8980						w_keyq:
.8980		a0 00		ldy #$00	                ldy #0
.8982		20 8f 89	jsr $898f	                jsr keyq_a
.8985		f0 01		beq $8988	                beq +           ; A=0 => Y=0
.8987		88		dey		                dey             ; A<>0 => Y=#$ff
.8988						+
.8988		ca		dex		                dex
.8989		ca		dex		                dex
.898a		94 00		sty $00,x	                sty 0,x         ; store either $0000 or $ffff
.898c		94 01		sty $01,x	                sty 1,x
.898e		60		rts		z_keyq:         rts
.898f		6c 16 00	jmp ($0016)	keyq_a:         jmp (havekey)
.8992						xt_leave:
.8992						w_leave:
.8992		a5 21		lda $21		                lda loopleave
.8994		a4 22		ldy $22		                ldy loopleave+1
.8996		20 a8 97	jsr $97a8	                jsr cmpl_jump   ; emit the JMP chaining prior leave address
.8999		38		sec		                sec
.899a		a5 00		lda $00		                lda cp
.899c		e9 02		sbc #$02	                sbc #2
.899e		85 21		sta $21		                sta loopleave
.89a0		a5 01		lda $01		                lda cp+1
.89a2		b0 01		bcs $89a5	                bcs +
.89a4		3a		dec a		                dea
.89a5		85 22		sta $22		+               sta loopleave+1
.89a7						z_leave:
.89a7		60		rts		                rts
.89a8						xt_left_bracket:
.89a8						w_left_bracket:
.89a8		64 1a		stz $1a		                stz state
.89aa		64 1b		stz $1b		                stz state+1
.89ac		60		rts		z_left_bracket: rts
.89ad						xt_less_number_sign:
.89ad						w_less_number_sign:
.89ad		20 e6 8c	jsr $8ce6	                jsr w_pad      ; ( addr )
.89b0		b5 00		lda $00,x	                lda 0,x
.89b2		85 2b		sta $2b		                sta tohold
.89b4		b5 01		lda $01,x	                lda 1,x
.89b6		85 2c		sta $2c		                sta tohold+1
.89b8		e8		inx		                inx
.89b9		e8		inx		                inx
.89ba						z_less_number_sign:
.89ba		60		rts		                rts
.89bb						xt_less_than:
.89bb		20 d9 d7	jsr $d7d9	                jsr underflow_2
.89be						w_less_than:
.89be		a0 00		ldy #$00	                ldy #0          ; default false
.89c0		20 14 d7	jsr $d714	                jsr compare_16bit
.89c3		f0 03		beq $89c8	                beq _false
.89c5		30 01		bmi $89c8	                bmi _false
.89c7		88		dey		                dey
.89c8						_false:
.89c8		98		tya		                tya
.89c9		e8		inx		                inx
.89ca		e8		inx		                inx
.89cb		95 00		sta $00,x	                sta 0,x
.89cd		95 01		sta $01,x	                sta 1,x
.89cf		60		rts		z_less_than:    rts
.89d0						xt_literal:
.89d0		20 d4 d7	jsr $d7d4	                jsr underflow_1
.89d3						w_literal:
.89d3		a9 0a		lda #$0a	                lda #template_push_tos_size
.89d5		20 c5 97	jsr $97c5	                jsr check_nc_limit
.89d8		90 0c		bcc $89e6	                bcc _inline
.89da		a0 8a		ldy #$8a	                ldy #>literal_runtime
.89dc		a9 18		lda #$18	                lda #<literal_runtime
.89de		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.89e1		20 ae 83	jsr $83ae	                jsr w_comma
.89e4		80 27		bra $8a0d	                bra z_literal
.89e6						_inline:
.89e6		a0 94		ldy #$94	                ldy #$94        ; STY opcode
.89e8		b5 01		lda $01,x	                lda 1,x         ; MSB
.89ea		d0 02		bne $89ee	                bne +
.89ec		a0 74		ldy #$74	                ldy #$74        ; STZ opcode
.89ee		5a		phy		+               phy
.89ef		b5 00		lda $00,x	                lda 0,x         ; LSB
.89f1		48		pha		                pha
.89f2		a0 02		ldy #$02	                ldy #2
.89f4		b5 01		lda $01,x	                lda 1,x         ; MSB
.89f6		f0 03		beq $89fb	                beq _copy
.89f8		a0 00		ldy #$00	                ldy #0
.89fa		48		pha		                pha
.89fb		b9 0e 8a	lda $8a0e,y	_copy:          lda template_push_tos,y
.89fe		c9 ff		cmp #$ff	                cmp #$ff        ; is it a placeholder?
.8a00		d0 01		bne $8a03	                bne +
.8a02		68		pla		                pla
.8a03		20 bc 97	jsr $97bc	+               jsr cmpl_a
.8a06		c8		iny		                iny
.8a07		c0 0a		cpy #$0a	                cpy #template_push_tos_size
.8a09		d0 f0		bne $89fb	                bne _copy
.8a0b		e8		inx		                inx             ; drop the literal
.8a0c		e8		inx		                inx
.8a0d		60		rts		z_literal:      rts
.8a0e						template_push_tos:
.8a0e		a0 ff		ldy #$ff	                ldy #$ff        ; we'll omit this if MSB is zero
.8a10		a9 ff		lda #$ff	                lda #$ff
.8a12		ca		dex		                dex
.8a13		ca		dex		                dex
.8a14		95 00		sta $00,x	                sta 0,x
>8a16		ff 01				                .byte $ff, 1    ; this will become either sty 1,x or stz 1,x
=10						template_push_tos_size = * - template_push_tos
.8a18						literal_runtime:
.8a18		ca		dex		                dex
.8a19		ca		dex		                dex
.8a1a		68		pla		                pla             ; LSB
.8a1b		85 25		sta $25		                sta tmp1
.8a1d		68		pla		                pla             ; MSB
.8a1e		85 26		sta $26		                sta tmp1+1
.8a20		a0 01		ldy #$01	                ldy #1
.8a22		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB
.8a24		95 00		sta $00,x	                sta 0,x
.8a26		c8		iny		                iny
.8a27		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB
.8a29		95 01		sta $01,x	                sta 1,x
.8a2b		98		tya		                tya
.8a2c		18		clc		                clc
.8a2d		65 25		adc $25		                adc tmp1
.8a2f		a8		tay		                tay
.8a30		a5 26		lda $26		                lda tmp1+1
.8a32		69 00		adc #$00	                adc #0
.8a34		48		pha		                pha
.8a35		5a		phy		                phy
.8a36		60		rts		                rts
.8a37						xt_loop:
.8a37						w_loop:
.8a37		ca		dex		                dex
.8a38		ca		dex		                dex
.8a39		ca		dex		                dex
.8a3a		ca		dex		                dex
.8a3b		a9 b0		lda #$b0	                lda #<loop_runtime
.8a3d		95 02		sta $02,x	                sta 2,x
.8a3f		a9 8a		lda #$8a	                lda #>loop_runtime
.8a41		95 03		sta $03,x	                sta 3,x
.8a43		a9 11		lda #$11	                lda #loop_runtime_size
.8a45		95 00		sta $00,x	                sta 0,x
.8a47		74 01		stz $01,x	                stz 1,x
.8a49		80 12		bra $8a5d	                bra loop_common
.8a4b						xt_plus_loop:
.8a4b						w_plus_loop:
.8a4b		ca		dex		                dex
.8a4c		ca		dex		                dex
.8a4d		ca		dex		                dex
.8a4e		ca		dex		                dex
.8a4f		a9 c9		lda #$c9	                lda #<plus_loop_runtime
.8a51		95 02		sta $02,x	                sta 2,x
.8a53		a9 8a		lda #$8a	                lda #>plus_loop_runtime
.8a55		95 03		sta $03,x	                sta 3,x
.8a57		a9 1a		lda #$1a	                lda #plus_loop_runtime_size
.8a59		95 00		sta $00,x	                sta 0,x
.8a5b		74 01		stz $01,x	                stz 1,x
.8a5d						loop_common:
.8a5d		20 db 8c	jsr $8cdb	                jsr w_over
.8a60		20 1e 92	jsr $921e	                jsr w_swap             ; xt and xt' are the same
.8a63		20 2f 97	jsr $972f	                jsr cmpl_by_limit
.8a66		90 05		bcc $8a6d	                bcc _native
.8a68		20 ae 83	jsr $83ae	                jsr w_comma
.8a6b		80 03		bra $8a70	                bra +
.8a6d						_native:
.8a6d		20 a2 97	jsr $97a2	                jsr cmpl_jump_tos
.8a70						+
.8a70		a5 22		lda $22		                lda loopleave+1         ; MSB=0 means we're done
.8a72		f0 19		beq $8a8d	                beq _noleave
.8a74						_next:
.8a74		a0 01		ldy #$01	                ldy #1
.8a76		b1 21		lda ($21),y	                lda (loopleave),y
.8a78		48		pha		                pha
.8a79		a5 01		lda $01		                lda cp+1
.8a7b		91 21		sta ($21),y	                sta (loopleave),y
.8a7d		88		dey		                dey
.8a7e		b1 21		lda ($21),y	                lda (loopleave),y
.8a80		48		pha		                pha
.8a81		a5 00		lda $00		                lda cp
.8a83		91 21		sta ($21),y	                sta (loopleave),y
.8a85		68		pla		                pla
.8a86		85 21		sta $21		                sta loopleave
.8a88		68		pla		                pla
.8a89		85 22		sta $22		                sta loopleave+1
.8a8b		d0 e7		bne $8a74	                bne _next
.8a8d						_noleave:
.8a8d		b5 00		lda $00,x	                lda 0,x
.8a8f		85 21		sta $21		                sta loopleave
.8a91		b5 01		lda $01,x	                lda 1,x
.8a93		85 22		sta $22		                sta loopleave+1
.8a95		a9 12		lda #$12	                lda #<nt_unloop
.8a97		95 00		sta $00,x	                sta 0,x
.8a99		a9 c3		lda #$c3	                lda #>nt_unloop
.8a9b		95 01		sta $01,x	                sta 1,x
.8a9d		20 ad 96	jsr $96ad	                jsr compile_nt_comma    ; use the faster entry with the NT
.8aa0		b5 01		lda $01,x	                lda 1,x                 ; MSB=0 means DO so nothing to do
.8aa2		f0 09		beq $8aad	                beq +
.8aa4		20 e7 88	jsr $88e7	                jsr w_here
.8aa7		20 1e 92	jsr $921e	                jsr w_swap
.8aaa		4c 08 92	jmp $9208	                jmp w_store             ; write here as ?DO jmp target and return
.8aad		e8		inx		+               inx                     ; drop the ignored word for DO
.8aae		e8		inx		                inx
.8aaf						z_loop:
.8aaf		60		rts		z_plus_loop:    rts
.8ab0						loop_runtime:
.8ab0		e6 20		inc $20		                inc loopidx0            ; increment the LSB of loopindex
.8ab2		d0 0d		bne $8ac1	                bne _repeat             ; avoid expensive test most of the time
.8ab4		a4 1f		ldy $1f		                ldy loopctrl
.8ab6		b9 01 01	lda $0101,y	                lda loopindex+1,y
.8ab9		1a		inc a		                ina
.8aba		c9 80		cmp #$80	                cmp #$80
.8abc		f0 06		beq $8ac4	                beq _done
.8abe		99 01 01	sta $0101,y	                sta loopindex+1,y
=17						loop_runtime_size = * - loop_runtime
.8ac1						_repeat:
.8ac1		a9 00		lda #$00	                lda #0
>8ac3		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8ac4		a9 01		lda #$01	_done:          lda #1
.8ac6		4c 54 98	jmp $9854	                jmp zbranch_runtime
.8ac9						plus_loop_runtime:
.8ac9		18		clc		                clc
.8aca		b5 00		lda $00,x	                lda 0,x                 ; LSB of step
.8acc		65 20		adc $20		                adc loopidx0
.8ace		85 20		sta $20		                sta loopidx0
.8ad0		e8		inx		                inx                     ; dump step from TOS before MSB test
.8ad1		e8		inx		                inx                     ; since we might skip it
.8ad2		b5 ff		lda $ff,x	                lda $FF,x               ; MSB of step since 1,x == -1,x+2
.8ad4		d0 02		bne $8ad8	                bne _chkv               ; if it's non-zero we have to check
.8ad6		90 0b		bcc $8ae3	                bcc _repeat             ; but if 0 and no carry, we're good
.8ad8		b8		clv		_chkv:          clv
.8ad9		a4 1f		ldy $1f		                ldy loopctrl            ; get LCB offset
.8adb		79 01 01	adc $0101,y	                adc loopindex+1,y       ; MSB of index
.8ade		99 01 01	sta $0101,y	                sta loopindex+1,y       ; put MSB of index back on stack
.8ae1		70 03		bvs $8ae6	                bvs _done               ; skip over JMP instruction
=26						plus_loop_runtime_size = * - plus_loop_runtime
.8ae3						_repeat:
.8ae3		a9 00		lda #$00	                lda #0
>8ae5		2c				                .byte $2c               ; BIT llhh to hide the lda #1
.8ae6		a9 01		lda #$01	_done:          lda #1
.8ae8		4c 54 98	jmp $9854	                jmp zbranch_runtime
.8aeb						xt_lshift:
.8aeb		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8aee						w_lshift:
.8aee		b5 00		lda $00,x	                lda 0,x
.8af0		29 0f		and #$0f	                and #%00001111
.8af2		f0 08		beq $8afc	                beq _done
.8af4		a8		tay		                tay
.8af5						_loop:
.8af5		16 02		asl $02,x	                asl 2,x
.8af7		36 03		rol $03,x	                rol 3,x
.8af9		88		dey		                dey
.8afa		d0 f9		bne $8af5	                bne _loop
.8afc						_done:
.8afc		e8		inx		                inx
.8afd		e8		inx		                inx
.8afe		60		rts		z_lshift:       rts
.8aff						xt_m_star:
.8aff		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8b02						w_m_star:
.8b02		b5 01		lda $01,x	                lda 1,x         ; MSB of n1
.8b04		55 03		eor $03,x	                eor 3,x         ; MSB of n2
.8b06		48		pha		                pha
.8b07		20 d2 80	jsr $80d2	                jsr w_abs
.8b0a		20 1e 92	jsr $921e	                jsr w_swap
.8b0d		20 d2 80	jsr $80d2	                jsr w_abs
.8b10		20 7b 95	jsr $957b	                jsr w_um_star          ; ( d )
.8b13		68		pla		                pla
.8b14		10 03		bpl $8b19	                bpl _done
.8b16		20 d7 9e	jsr $9ed7	                jsr w_dnegate
.8b19						_done:
.8b19		60		rts		z_m_star:       rts
.8b1a						xt_marker:
.8b1a						w_marker:
.8b1a		20 2d d7	jsr $d72d	                jsr current_to_dp
.8b1d		a5 02		lda $02		                lda dp
.8b1f		48		pha		                pha
.8b20		a5 03		lda $03		                lda dp+1
.8b22		48		pha		                pha
.8b23		a5 00		lda $00		                lda cp
.8b25		48		pha		                pha
.8b26		a5 01		lda $01		                lda cp+1
.8b28		48		pha		                pha
.8b29		a9 28		lda #$28	                lda #4 + marker_end_offset - marker_start_offset
.8b2b		85 1e		sta $1e		                sta tmpdsp              ; PFA size in bytes
.8b2d		a9 4b		lda #$4b	                lda #<marker_runtime
.8b2f		a0 8b		ldy #$8b	                ldy #>marker_runtime
.8b31		20 fa 83	jsr $83fa	                jsr create_common
.8b34		7a		ply		                ply                     ; MSB
.8b35		68		pla		                pla                     ; LSB
.8b36		20 b8 97	jsr $97b8	                jsr cmpl_word
.8b39		7a		ply		                ply                     ; MSB
.8b3a		68		pla		                pla                     ; LSB
.8b3b		20 b8 97	jsr $97b8	                jsr cmpl_word
.8b3e		a0 08		ldy #$08	                ldy #marker_start_offset
.8b40						-
.8b40		b1 08		lda ($08),y	                lda (up),y
.8b42		20 bc 97	jsr $97bc	                jsr cmpl_a
.8b45		c8		iny		                iny
.8b46		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b48		d0 f6		bne $8b40	                bne -
.8b4a		60		rts		z_marker:       rts
.8b4b						marker_runtime:
.8b4b		68		pla		                pla
.8b4c		85 25		sta $25		                sta tmp1        ; LSB of address
.8b4e		68		pla		                pla
.8b4f		85 26		sta $26		                sta tmp1+1      ; MSB of address
.8b51		a0 01		ldy #$01	                ldy #1          ; start at 1 due to RTS mechanics
.8b53		b1 25		lda ($25),y	                lda (tmp1),y
.8b55		85 00		sta $00		                sta cp
.8b57		c8		iny		                iny
.8b58		b1 25		lda ($25),y	                lda (tmp1),y
.8b5a		85 01		sta $01		                sta cp+1
.8b5c		c8		iny		                iny
.8b5d		b1 25		lda ($25),y	                lda (tmp1),y
.8b5f		85 02		sta $02		                sta dp
.8b61		c8		iny		                iny
.8b62		b1 25		lda ($25),y	                lda (tmp1),y
.8b64		85 03		sta $03		                sta dp+1
.8b66		38		sec		                sec
.8b67		a5 25		lda $25		                lda tmp1
.8b69		e9 03		sbc #$03	                sbc #marker_start_offset - 5
.8b6b		85 25		sta $25		                sta tmp1
.8b6d		b0 02		bcs $8b71	                bcs +
.8b6f		c6 26		dec $26		                dec tmp1+1
.8b71						+
.8b71		a0 08		ldy #$08	                ldy #marker_start_offset
.8b73						-
.8b73		b1 25		lda ($25),y	                lda (tmp1),y
.8b75		91 08		sta ($08),y	                sta (up),y
.8b77		c8		iny		                iny
.8b78		c0 2c		cpy #$2c	                cpy #marker_end_offset
.8b7a		d0 f7		bne $8b73	                bne -
.8b7c		20 40 d7	jsr $d740	                jsr dp_to_current       ; Move the CURRENT DP back.
.8b7f		60		rts		                rts
.8b80						xt_max:
.8b80		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8b83						w_max:
.8b83		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8b85		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets the carry
.8b87		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8b89		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8b8b		50 02		bvc $8b8f	                bvc _no_overflow
.8b8d		49 80		eor #$80	                eor #$80        ; complement negative flag
.8b8f						_no_overflow:
.8b8f		30 08		bmi $8b99	                bmi _keep_nos
.8b91		b5 00		lda $00,x	                lda 0,x
.8b93		95 02		sta $02,x	                sta 2,x
.8b95		b5 01		lda $01,x	                lda 1,x
.8b97		95 03		sta $03,x	                sta 3,x
.8b99						_keep_nos:
.8b99		e8		inx		                inx
.8b9a		e8		inx		                inx
.8b9b		60		rts		z_max:          rts
.8b9c						xt_min:
.8b9c		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8b9f						w_min:
.8b9f		b5 00		lda $00,x	                lda 0,x         ; LSB of TOS
.8ba1		d5 02		cmp $02,x	                cmp 2,x         ; LSB of NOS, this sets carry
.8ba3		b5 01		lda $01,x	                lda 1,x         ; MSB of TOS
.8ba5		f5 03		sbc $03,x	                sbc 3,x         ; MSB of NOS
.8ba7		50 02		bvc $8bab	                bvc _no_overflow
.8ba9		49 80		eor #$80	                eor #$80
.8bab						_no_overflow:
.8bab		10 08		bpl $8bb5	                bpl _keep_nos
.8bad		b5 00		lda $00,x	                lda 0,x
.8baf		95 02		sta $02,x	                sta 2,x
.8bb1		b5 01		lda $01,x	                lda 1,x
.8bb3		95 03		sta $03,x	                sta 3,x
.8bb5						_keep_nos:
.8bb5		e8		inx		                inx
.8bb6		e8		inx		                inx
.8bb7		60		rts		z_min:          rts
.8bb8						xt_minus:
.8bb8		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8bbb						w_minus:
.8bbb		38		sec		                sec
.8bbc		b5 02		lda $02,x	                lda 2,x         ; LSB
.8bbe		f5 00		sbc $00,x	                sbc 0,x
.8bc0		95 02		sta $02,x	                sta 2,x
.8bc2		b5 03		lda $03,x	                lda 3,x         ; MSB
.8bc4		f5 01		sbc $01,x	                sbc 1,x
.8bc6		95 03		sta $03,x	                sta 3,x
.8bc8		e8		inx		                inx
.8bc9		e8		inx		                inx
.8bca		60		rts		z_minus:        rts
.8bcb						xt_mod:
.8bcb		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8bce						w_mod:
.8bce		20 54 91	jsr $9154	                jsr w_slash_mod
.8bd1		e8		inx		                inx             ; DROP
.8bd2		e8		inx		                inx
.8bd3						z_mod:
.8bd3		60		rts		                rts
.8bd4						xt_move:
.8bd4		20 de d7	jsr $d7de	                jsr underflow_3
.8bd7						w_move:
.8bd7		b5 03		lda $03,x	                lda 3,x                 ; MSB of addr2
.8bd9		d5 05		cmp $05,x	                cmp 5,x                 ; MSB of addr1
.8bdb		f0 05		beq $8be2	                beq _lsb                ; wasn't helpful, move to LSB
.8bdd		b0 0e		bcs $8bed	                bcs _to_move_up         ; we want CMOVE>
.8bdf		4c 3f a0	jmp $a03f	                jmp w_cmove            ; JSR/RTS
.8be2						_lsb:
.8be2		b5 02		lda $02,x	                lda 2,x                 ; LSB of addr2
.8be4		d5 04		cmp $04,x	                cmp 4,x                 ; LSB of addr1
.8be6		f0 08		beq $8bf0	                beq _equal              ; LSB is equal as well
.8be8		b0 03		bcs $8bed	                bcs _to_move_up         ; we want CMOVE>
.8bea		4c 3f a0	jmp $a03f	                jmp w_cmove            ; JSR/RTS
.8bed						_to_move_up:
.8bed		4c 7a a0	jmp $a07a	                jmp w_cmove_up         ; JSR/RTS
.8bf0						_equal:
.8bf0		8a		txa		                txa
.8bf1		18		clc		                clc
.8bf2		69 06		adc #$06	                adc #6
.8bf4		aa		tax		                tax
.8bf5		60		rts		z_move:         rts
.8bf6						xt_negate:
.8bf6		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8bf9						w_negate:
.8bf9		a9 00		lda #$00	        	lda #0
.8bfb		38		sec		                sec
.8bfc		f5 00		sbc $00,x	                sbc 0,x         ; LSB
.8bfe		95 00		sta $00,x	                sta 0,x
.8c00		a9 00		lda #$00	                lda #0
.8c02		f5 01		sbc $01,x	                sbc 1,x         ; MSB
.8c04		95 01		sta $01,x	                sta 1,x
.8c06		60		rts		z_negate:       rts
.8c07						xt_nip:
.8c07		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8c0a						w_nip:
.8c0a		b5 00		lda $00,x	                lda 0,x         ; LSB
.8c0c		95 02		sta $02,x	                sta 2,x
.8c0e		b5 01		lda $01,x	                lda 1,x         ; MSB
.8c10		95 03		sta $03,x	                sta 3,x
.8c12		e8		inx		                inx
.8c13		e8		inx		                inx
.8c14		60		rts		z_nip:          rts
.8c15						xt_not_equals:
.8c15		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8c18						w_not_equals:
.8c18		a0 00		ldy #$00	                ldy #0                  ; default is true
.8c1a		b5 00		lda $00,x	                lda 0,x                 ; LSB
.8c1c		d5 02		cmp $02,x	                cmp 2,x
.8c1e		d0 0a		bne $8c2a	                bne _not_equal
.8c20		b5 01		lda $01,x	                lda 1,x                 ; MSB
.8c22		d5 03		cmp $03,x	                cmp 3,x
.8c24		d0 04		bne $8c2a	                bne _not_equal
.8c26		a9 ff		lda #$ff	                lda #$FF
.8c28		80 01		bra $8c2b	                bra _done
.8c2a						_not_equal:
.8c2a		88		dey		                dey                     ; drop thru to done
.8c2b						_done:
.8c2b		98		tya		                tya
.8c2c		e8		inx		                inx
.8c2d		e8		inx		                inx
.8c2e		95 00		sta $00,x	                sta 0,x
.8c30		95 01		sta $01,x	                sta 1,x
.8c32		60		rts		z_not_equals:   rts
.8c33						xt_number_sign:
.8c33		20 d9 d7	jsr $d7d9	                jsr underflow_2         ; double number
.8c36						w_number_sign:
.8c36		ca		dex		                dex                     ; inline w_zero
.8c37		ca		dex		                dex
.8c38		74 00		stz $00,x	                stz 0,x
.8c3a		74 01		stz $01,x	                stz 1,x
.8c3c		e6 19		inc $19		                inc base+1
.8c3e		b5 02		lda $02,x	                lda 2,x                 ; if msw is 0 we can skip the first pass
.8c40		15 03		ora $03,x	                ora 3,x
.8c42		f0 0b		beq $8c4f	                beq _skip               ; enter with ( v 0 0 -rot -- 0 v 0 )
.8c44						_loop:
.8c44		ca		dex		                dex                     ; inline `base @`
.8c45		ca		dex		                dex
.8c46		a5 18		lda $18		                lda base                ; base <= 36
.8c48		95 00		sta $00,x	                sta 0,x
.8c4a		74 01		stz $01,x	                stz 1,x
.8c4c		20 39 95	jsr $9539	                jsr w_um_slash_mod      ; ( v u 0 base -- v ru qu )
.8c4f		20 ed 9c	jsr $9ced	_skip:          jsr w_not_rot           ; ( qu v ru )
.8c52		46 19		lsr $19		                lsr base+1              ; 1 => 0 + C=1 => 0 + C=0
.8c54		b0 ee		bcs $8c44	                bcs _loop               ; run two passes
.8c56		b5 00		lda $00,x	                lda 0,x
.8c58		a8		tay		                tay
.8c59		b9 53 d3	lda $d353,y	                lda s_abc_upper,y       ; upper case 0-9A-Z
.8c5c		95 00		sta $00,x	                sta 0,x
.8c5e		74 01		stz $01,x	                stz 1,x                 ; paranoid; now ( ud char )
.8c60		20 fc 88	jsr $88fc	                jsr w_hold
.8c63						z_number_sign:
.8c63		60		rts		                rts
.8c64						xt_number_sign_greater:
.8c64		20 d9 d7	jsr $d7d9	                jsr underflow_2         ; double number
.8c67						w_number_sign_greater:
.8c67		a5 2b		lda $2b		                lda tohold
.8c69		95 00		sta $00,x	                sta 0,x         ; LSB of tohold
.8c6b		95 02		sta $02,x	                sta 2,x
.8c6d		a5 2c		lda $2c		                lda tohold+1
.8c6f		95 01		sta $01,x	                sta 1,x         ; MSB of addr
.8c71		95 03		sta $03,x	                sta 3,x         ; ( addr addr )
.8c73		20 e6 8c	jsr $8ce6	                jsr w_pad      ; ( addr addr pad )
.8c76		38		sec		                sec
.8c77		b5 00		lda $00,x	                lda 0,x         ; LSB of pad address
.8c79		f5 02		sbc $02,x	                sbc 2,x
.8c7b		95 02		sta $02,x	                sta 2,x
.8c7d		b5 01		lda $01,x	                lda 1,x         ; MSB, which should always be zero
.8c7f		f5 03		sbc $03,x	                sbc 3,x
.8c81		95 03		sta $03,x	                sta 3,x         ; ( addr u pad )
.8c83		e8		inx		                inx
.8c84		e8		inx		                inx
.8c85						z_number_sign_greater:
.8c85		60		rts		                rts
.8c86						xt_number_sign_s:
.8c86		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8c89						w_number_sign_s:
.8c89						_loop:
.8c89		20 36 8c	jsr $8c36	                jsr w_number_sign
.8c8c		b5 00		lda $00,x	                lda 0,x
.8c8e		15 01		ora $01,x	                ora 1,x
.8c90		15 02		ora $02,x	                ora 2,x
.8c92		15 03		ora $03,x	                ora 3,x
.8c94		d0 f3		bne $8c89	                bne _loop
.8c96						z_number_sign_s:
.8c96		60		rts		                rts
.8c97						xt_of:
.8c97						w_of:
.8c97		a0 8c		ldy #$8c	                ldy #>w_over
.8c99		a9 db		lda #$db	                lda #<w_over
.8c9b		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.8c9e		a0 87		ldy #$87	                ldy #>w_equal
.8ca0		a9 5d		lda #$5d	                lda #<w_equal
.8ca2		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.8ca5		20 20 89	jsr $8920	                jsr w_if
.8ca8		a0 86		ldy #$86	                ldy #>w_drop
.8caa		a9 56		lda #$56	                lda #<w_drop
.8cac		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.8caf		60		rts		z_of:           rts
.8cb0						xt_one_minus:
.8cb0		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8cb3						w_one_minus:
.8cb3		b5 00		lda $00,x	                lda 0,x
.8cb5		d0 02		bne $8cb9	                bne +
.8cb7		d6 01		dec $01,x	                dec 1,x
.8cb9						+
.8cb9		d6 00		dec $00,x	                dec 0,x
.8cbb		60		rts		z_one_minus:    rts
.8cbc						xt_char_plus:
.8cbc						xt_one_plus:
.8cbc		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8cbf						w_char_plus:
.8cbf						w_one_plus:
.8cbf		f6 00		inc $00,x	                inc 0,x
.8cc1		d0 02		bne $8cc5	                bne _done
.8cc3		f6 01		inc $01,x	                inc 1,x
.8cc5						_done:
.8cc5						z_char_plus:
.8cc5		60		rts		z_one_plus:     rts
.8cc6						xt_or:
.8cc6		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8cc9						w_or:
.8cc9		b5 00		lda $00,x	                lda 0,x
.8ccb		15 02		ora $02,x	                ora 2,x
.8ccd		95 02		sta $02,x	                sta 2,x
.8ccf		b5 01		lda $01,x	                lda 1,x
.8cd1		15 03		ora $03,x	                ora 3,x
.8cd3		95 03		sta $03,x	                sta 3,x
.8cd5		e8		inx		                inx
.8cd6		e8		inx		                inx
.8cd7		60		rts		z_or:           rts
.8cd8						xt_over:
.8cd8		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8cdb						w_over:
.8cdb		ca		dex		                dex
.8cdc		ca		dex		                dex
.8cdd		b5 04		lda $04,x	                lda 4,x         ; LSB
.8cdf		95 00		sta $00,x	                sta 0,x
.8ce1		b5 05		lda $05,x	                lda 5,x         ; MSB
.8ce3		95 01		sta $01,x	                sta 1,x
.8ce5		60		rts		z_over:         rts
.8ce6						xt_pad:
.8ce6						w_pad:
.8ce6		ca		dex		                dex
.8ce7		ca		dex		                dex
.8ce8		a5 00		lda $00		                lda cp
.8cea		18		clc		                clc
.8ceb		69 ff		adc #$ff	                adc #padoffset  ; assumes padoffset one byte in size
.8ced		95 00		sta $00,x	                sta 0,x
.8cef		a5 01		lda $01		                lda cp+1
.8cf1		69 00		adc #$00	                adc #0          ; only need carry
.8cf3		95 01		sta $01,x	                sta 1,x
.8cf5		60		rts		z_pad:          rts
.8cf6						xt_page:
.8cf6						w_page:
.8cf6		a9 1b		lda #$1b	                lda #AscESC
.8cf8		20 86 86	jsr $8686	                jsr emit_a
.8cfb		a9 5b		lda #$5b	                lda #'['
.8cfd		20 86 86	jsr $8686	                jsr emit_a
.8d00		a9 32		lda #$32	                lda #'2'
.8d02		20 86 86	jsr $8686	                jsr emit_a
.8d05		a9 4a		lda #$4a	                lda #'J'
.8d07		20 86 86	jsr $8686	                jsr emit_a
.8d0a		20 66 9e	jsr $9e66	                jsr w_zero
.8d0d		20 66 9e	jsr $9e66	                jsr w_zero
.8d10		20 a5 82	jsr $82a5	                jsr w_at_xy
.8d13		60		rts		z_page:         rts
.8d14						xt_paren:
.8d14						w_paren:
.8d14		ca		dex		                dex
.8d15		ca		dex		                dex
.8d16		a9 29		lda #$29	                lda #41     ; Right parenthesis
.8d18		95 00		sta $00,x	                sta 0,x
.8d1a		74 01		stz $01,x	                stz 1,x
.8d1c		20 82 8d	jsr $8d82	                jsr w_parse
.8d1f		e8		inx		                inx
.8d20		e8		inx		                inx
.8d21		e8		inx		                inx
.8d22		e8		inx		                inx
.8d23		60		rts		z_paren:        rts
.8d24						xt_parse_name:
.8d24						w_parse_name:
.8d24		a5 0e		lda $0e		                lda ciblen              ; LSB of counter
.8d26		38		sec		                sec
.8d27		e5 10		sbc $10		                sbc toin
.8d29		85 25		sta $25		                sta tmp1
.8d2b		a5 0f		lda $0f		                lda ciblen+1            ; MSB
.8d2d		e5 11		sbc $11		                sbc toin+1
.8d2f		85 26		sta $26		                sta tmp1+1
.8d31		a5 25		lda $25		                lda tmp1
.8d33		05 26		ora $26		                ora tmp1+1
.8d35		f0 28		beq $8d5f	                beq _empty_line
.8d37		a5 0c		lda $0c		                lda cib
.8d39		18		clc		                clc
.8d3a		65 10		adc $10		                adc toin
.8d3c		85 27		sta $27		                sta tmp2                ; LSB of first character
.8d3e		a5 0d		lda $0d		                lda cib+1
.8d40		65 11		adc $11		                adc toin+1
.8d42		85 28		sta $28		                sta tmp2+1              ; MSB
.8d44						_skip_loop:
.8d44		b2 27		lda ($27)	                lda (tmp2)              ; work copy of cib
.8d46		20 c7 d7	jsr $d7c7	                jsr is_whitespace
.8d49		90 1f		bcc $8d6a	                bcc _char_found
.8d4b		e6 27		inc $27		                inc tmp2
.8d4d		d0 02		bne $8d51	                bne +
.8d4f		e6 28		inc $28		                inc tmp2+1
.8d51						+
.8d51		a5 25		lda $25		                lda tmp1
.8d53		d0 02		bne $8d57	                bne +
.8d55		c6 26		dec $26		                dec tmp1+1
.8d57		c6 25		dec $25		+               dec tmp1
.8d59		a5 25		lda $25		                lda tmp1
.8d5b		05 26		ora $26		                ora tmp1+1
.8d5d		d0 e5		bne $8d44	                bne _skip_loop          ; fall through if empty line
.8d5f						_empty_line:
.8d5f		ca		dex		                dex
.8d60		ca		dex		                dex
.8d61		ca		dex		                dex
.8d62		ca		dex		                dex
.8d63		74 00		stz $00,x	                stz 0,x                 ; TOS is zero
.8d65		74 01		stz $01,x	                stz 1,x
.8d67		4c 14 8e	jmp $8e14	                jmp z_parse_name        ; skip over PARSE
.8d6a						_char_found:
.8d6a		a5 27		lda $27		                lda tmp2
.8d6c		38		sec		                sec
.8d6d		e5 0c		sbc $0c		                sbc cib
.8d6f		85 10		sta $10		                sta toin
.8d71		a5 28		lda $28		                lda tmp2+1
.8d73		e5 0d		sbc $0d		                sbc cib+1
.8d75		85 11		sta $11		                sta toin+1
.8d77		ca		dex		                dex
.8d78		ca		dex		                dex
.8d79		a9 20		lda #$20	                lda #AscSP
.8d7b		95 00		sta $00,x	                sta 0,x
.8d7d		74 01		stz $01,x	                stz 1,x                 ; paranoid, now ( "name" c )
.8d7f						xt_parse:
.8d7f		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8d82						w_parse:
.8d82		a5 0e		lda $0e		                lda ciblen
.8d84		05 0f		ora $0f		                ora ciblen+1
.8d86		f0 0c		beq $8d94	                beq _abort_parse
.8d88		a5 11		lda $11		                lda toin+1              ; MSB
.8d8a		c5 0f		cmp $0f		                cmp ciblen+1
.8d8c		90 0e		bcc $8d9c	                bcc _go_parse           ; unsigned comparison
.8d8e		a5 10		lda $10		                lda toin                ; LSB
.8d90		c5 0e		cmp $0e		                cmp ciblen
.8d92		90 08		bcc $8d9c	                bcc _go_parse
.8d94						_abort_parse:
.8d94		ca		dex		                dex
.8d95		ca		dex		                dex
.8d96		74 00		stz $00,x	                stz 0,x
.8d98		74 01		stz $01,x	                stz 1,x
.8d9a		80 78		bra $8e14	                bra _done
.8d9c						_go_parse:
.8d9c		b5 00		lda $00,x	                lda 0,x
.8d9e		85 23		sta $23		                sta tmptos
.8da0		ca		dex		                dex
.8da1		ca		dex		                dex
.8da2		a5 0c		lda $0c		                lda cib
.8da4		18		clc		                clc
.8da5		65 10		adc $10		                adc toin        ; LSB
.8da7		85 25		sta $25		                sta tmp1
.8da9		85 27		sta $27		                sta tmp2
.8dab		95 02		sta $02,x	                sta 2,x
.8dad		a5 0d		lda $0d		                lda cib+1
.8daf		65 11		adc $11		                adc toin+1      ; MSB
.8db1		85 26		sta $26		                sta tmp1+1
.8db3		85 28		sta $28		                sta tmp2+1
.8db5		95 03		sta $03,x	                sta 3,x
.8db7		a5 0c		lda $0c		                lda cib
.8db9		18		clc		                clc
.8dba		65 0e		adc $0e		                adc ciblen
.8dbc		85 29		sta $29		                sta tmp3
.8dbe		a5 0d		lda $0d		                lda cib+1
.8dc0		65 0f		adc $0f		                adc ciblen+1
.8dc2		85 2a		sta $2a		                sta tmp3+1
.8dc4		64 24		stz $24		                stz tmptos+1
.8dc6						_loop:
.8dc6		a5 27		lda $27		                lda tmp2
.8dc8		c5 29		cmp $29		                cmp tmp3
.8dca		d0 06		bne $8dd2	                bne _not_empty
.8dcc		a5 28		lda $28		                lda tmp2+1
.8dce		c5 2a		cmp $2a		                cmp tmp3+1
.8dd0		f0 1d		beq $8def	                beq _eol
.8dd2						_not_empty:
.8dd2		b2 27		lda ($27)	                lda (tmp2)
.8dd4		a4 23		ldy $23		                ldy tmptos
.8dd6		c0 20		cpy #$20	                cpy #AscSP
.8dd8		d0 07		bne $8de1	                bne _not_whitespace
.8dda		20 c7 d7	jsr $d7c7	                jsr is_whitespace
.8ddd		90 02		bcc $8de1	                bcc _not_whitespace
.8ddf		80 0c		bra $8ded	                bra _found_delimiter
.8de1						_not_whitespace:
.8de1		c5 23		cmp $23		                cmp tmptos
.8de3		f0 08		beq $8ded	                beq _found_delimiter
.8de5		e6 27		inc $27		                inc tmp2
.8de7		d0 dd		bne $8dc6	                bne _loop
.8de9		e6 28		inc $28		                inc tmp2+1
.8deb		80 d9		bra $8dc6	                bra _loop
.8ded						_found_delimiter:
.8ded		e6 24		inc $24		                inc tmptos+1
.8def						_eol:
.8def		a5 27		lda $27		                lda tmp2
.8df1		38		sec		                sec
.8df2		e5 25		sbc $25		                sbc tmp1
.8df4		95 00		sta $00,x	                sta 0,x
.8df6		a5 28		lda $28		                lda tmp2+1
.8df8		e5 26		sbc $26		                sbc tmp1+1
.8dfa		95 01		sta $01,x	                sta 1,x
.8dfc		a5 27		lda $27		                lda tmp2
.8dfe		38		sec		                sec
.8dff		e5 0c		sbc $0c		                sbc cib
.8e01		85 10		sta $10		                sta toin
.8e03		a5 28		lda $28		                lda tmp2+1
.8e05		e5 0d		sbc $0d		                sbc cib+1
.8e07		85 11		sta $11		                sta toin+1
.8e09		a5 10		lda $10		                lda toin
.8e0b		18		clc		                clc
.8e0c		65 24		adc $24		                adc tmptos+1
.8e0e		85 10		sta $10		                sta toin
.8e10		90 02		bcc $8e14	                bcc +
.8e12		e6 11		inc $11		                inc toin+1
.8e14						+
.8e14						_done:
.8e14						z_parse_name:
.8e14		60		rts		z_parse:        rts
.8e15						xt_pick:
.8e15						w_pick:
.8e15		16 00		asl $00,x	                asl 0,x         ; we assume u < 128 (stack is small)
.8e17		8a		txa		                txa
.8e18		75 00		adc $00,x	                adc 0,x
.8e1a		a8		tay		                tay
.8e1b		b9 02 00	lda $0002,y	                lda 0002,y
.8e1e		95 00		sta $00,x	                sta 0,x
.8e20		b9 03 00	lda $0003,y	                lda 0003,y
.8e23		95 01		sta $01,x	                sta 1,x
.8e25		60		rts		z_pick:         rts
.8e26						xt_plus:
.8e26		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8e29						w_plus:
.8e29		18		clc		                clc
.8e2a		b5 00		lda $00,x	                lda 0,x         ; LSB
.8e2c		75 02		adc $02,x	                adc 2,x
.8e2e		95 02		sta $02,x	                sta 2,x
.8e30		b5 01		lda $01,x	                lda 1,x         ; MSB. No CLC, conserve carry bit
.8e32		75 03		adc $03,x	                adc 3,x
.8e34		95 03		sta $03,x	                sta 3,x
.8e36		e8		inx		                inx
.8e37		e8		inx		                inx
.8e38		60		rts		z_plus:         rts
.8e39						xt_plus_store:
.8e39		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8e3c						w_plus_store:
.8e3c		18		clc		                clc
.8e3d		a1 00		lda ($00,x)	                lda (0,x)       ; fetch LSB at addr
.8e3f		75 02		adc $02,x	                adc 2,x
.8e41		81 00		sta ($00,x)	                sta (0,x)
.8e43		f6 00		inc $00,x	                inc 0,x         ; addr++
.8e45		d0 02		bne $8e49	                bne +
.8e47		f6 01		inc $01,x	                inc 1,x
.8e49						+
.8e49		a1 00		lda ($00,x)	                lda (0,x)       ; fetch MSB
.8e4b		75 03		adc $03,x	                adc 3,x
.8e4d		81 00		sta ($00,x)	                sta (0,x)
.8e4f		e8		inx		                inx
.8e50		e8		inx		                inx
.8e51		e8		inx		                inx
.8e52		e8		inx		                inx
.8e53		60		rts		z_plus_store:   rts
.8e54						xt_postpone:
.8e54						w_postpone:
.8e54		20 24 8d	jsr $8d24	                jsr w_parse_name               ; ( -- addr n )
.8e57		b5 00		lda $00,x	                lda 0,x
.8e59		15 01		ora $01,x	                ora 1,x
.8e5b		d0 05		bne $8e62	                bne +
.8e5d		a9 05		lda #$05	                lda #err_noname
.8e5f		4c ea d7	jmp $d7ea	                jmp error
.8e62						+
.8e62		20 5d 9b	jsr $9b5d	                jsr w_find_name                ; ( -- nt | 0 )
.8e65		d0 05		bne $8e6c	                bne +
.8e67		a9 05		lda #$05	                lda #err_noname
.8e69		4c ea d7	jmp $d7ea	                jmp error
.8e6c						+
.8e6c		20 5c 86	jsr $865c	                jsr w_dup
.8e6f		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.8e72		a1 00		lda ($00,x)	                lda (0,x)
.8e74		e8		inx		                inx
.8e75		e8		inx		                inx
.8e76		29 02		and #$02	                and #IM         ; mask all but Intermediate flag
.8e78		f0 05		beq $8e7f	                beq _not_immediate
.8e7a		20 ad 96	jsr $96ad	                jsr compile_nt_comma
.8e7d		80 0a		bra $8e89	                bra _done
.8e7f						_not_immediate:
.8e7f		20 d3 89	jsr $89d3	                jsr w_literal                   ; ( nt -- )
.8e82		a0 96		ldy #$96	                ldy #>compile_nt_comma
.8e84		a9 ad		lda #$ad	                lda #<compile_nt_comma
.8e86		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.8e89						_done:
.8e89		60		rts		z_postpone:     rts
.8e8a						xt_question_dup:
.8e8a		20 d4 d7	jsr $d7d4	                jsr underflow_1
.8e8d						w_question_dup:
.8e8d		b5 00		lda $00,x	                lda 0,x
.8e8f		15 01		ora $01,x	                ora 1,x
.8e91		f0 0a		beq $8e9d	                beq _done
.8e93		ca		dex		                dex
.8e94		ca		dex		                dex
.8e95		b5 02		lda $02,x	                lda 2,x
.8e97		95 00		sta $00,x	                sta 0,x
.8e99		b5 03		lda $03,x	                lda 3,x
.8e9b		95 01		sta $01,x	                sta 1,x
.8e9d						_done:
.8e9d		60		rts		z_question_dup: rts
.8e9e						xt_r_fetch:
.8e9e						w_r_fetch:
.8e9e		68		pla		                pla                     ; LSB
.8e9f		7a		ply		                ply                     ; MSB
.8ea0		1a		inc a		                inc a
.8ea1		85 25		sta $25		                sta tmp1                ; LSB
.8ea3		d0 01		bne $8ea6	                bne +
.8ea5		c8		iny		                iny
.8ea6						+
.8ea6		84 26		sty $26		                sty tmp1+1              ; MSB
.8ea8		ca		dex		                dex
.8ea9		ca		dex		                dex
.8eaa		7a		ply		                ply             ; LSB
.8eab		94 00		sty $00,x	                sty 0,x
.8ead		68		pla		                pla             ; MSB
.8eae		95 01		sta $01,x	                sta 1,x
.8eb0		48		pha		                pha
.8eb1		5a		phy		                phy
.8eb2		6c 25 00	jmp ($0025)	z_r_fetch:      jmp (tmp1)
.8eb5						xt_r_from:
.8eb5						w_r_from:
.8eb5		68		pla		                pla                     ; LSB
.8eb6		7a		ply		                ply                     ; MSB
.8eb7		1a		inc a		                inc a
.8eb8		85 25		sta $25		                sta tmp1                ; LSB
.8eba		d0 01		bne $8ebd	                bne +
.8ebc		c8		iny		                iny
.8ebd						+
.8ebd		84 26		sty $26		                sty tmp1+1              ; MSB
.8ebf		ca		dex		                dex
.8ec0		ca		dex		                dex
.8ec1		68		pla		                pla             ; LSB
.8ec2		95 00		sta $00,x	                sta 0,x
.8ec4		68		pla		                pla             ; MSB
.8ec5		95 01		sta $01,x	                sta 1,x
.8ec7		6c 25 00	jmp ($0025)	z_r_from:       jmp (tmp1)
.8eca						xt_recurse:
.8eca						w_recurse:
.8eca		a0 00		ldy #$00	                ldy #0
.8ecc		a9 20		lda #$20	                lda #OpJSR
.8ece		91 00		sta ($00),y	                sta (cp),y
.8ed0		c8		iny		                iny
.8ed1		24 1c		bit $1c		                bit status
.8ed3		70 0c		bvs $8ee1	                bvs _nt_in_workword
.8ed5		a5 06		lda $06		                lda workword
.8ed7		91 00		sta ($00),y	                sta (cp),y
.8ed9		c8		iny		                iny
.8eda		a5 07		lda $07		                lda workword+1
.8edc		91 00		sta ($00),y	                sta (cp),y
.8ede		c8		iny		                iny
.8edf		80 1b		bra $8efc	                bra _update_cp
.8ee1						_nt_in_workword:
.8ee1		a5 06		lda $06		                lda workword            ; LSB
.8ee3		18		clc		                clc
.8ee4		69 04		adc #$04	                adc #4
.8ee6		85 25		sta $25		                sta tmp1
.8ee8		a5 07		lda $07		                lda workword+1          ; MSB
.8eea		69 00		adc #$00	                adc #0
.8eec		85 26		sta $26		                sta tmp1+1
.8eee		b2 25		lda ($25)	                lda (tmp1)
.8ef0		91 00		sta ($00),y	                sta (cp),y
.8ef2		5a		phy		                phy
.8ef3		a0 01		ldy #$01	                ldy #1
.8ef5		b1 25		lda ($25),y	                lda (tmp1),y
.8ef7		7a		ply		                ply
.8ef8		c8		iny		                iny
.8ef9		91 00		sta ($00),y	                sta (cp),y
.8efb		c8		iny		                iny
.8efc						_update_cp:
.8efc		98		tya		                tya
.8efd		18		clc		                clc
.8efe		65 00		adc $00		                adc cp
.8f00		85 00		sta $00		                sta cp
.8f02		90 02		bcc $8f06	                bcc _done
.8f04		e6 01		inc $01		                inc cp+1
.8f06						_done:
.8f06		60		rts		z_recurse:      rts
.8f07						xt_refill:
.8f07						w_refill:
.8f07		a5 0a		lda $0a		                lda insrc               ; cheat: We only check LSB
.8f09		d0 2d		bne $8f38	                bne _src_not_kbd
.8f0b		ca		dex		                dex
.8f0c		ca		dex		                dex
.8f0d		ca		dex		                dex
.8f0e		ca		dex		                dex
.8f0f		a5 0c		lda $0c		                lda cib                 ; address of CIB is NOS
.8f11		95 02		sta $02,x	                sta 2,x
.8f13		a5 0d		lda $0d		                lda cib+1
.8f15		95 03		sta $03,x	                sta 3,x
.8f17		64 0e		stz $0e		                stz ciblen              ; go in with empty buffer
.8f19		64 0f		stz $0f		                stz ciblen+1
.8f1b		a9 ff		lda #$ff	                lda #bsize              ; max number of chars is TOS
.8f1d		95 00		sta $00,x	                sta 0,x
.8f1f		74 01		stz $01,x	                stz 1,x                 ; cheat: We only accept max 255
.8f21		20 e7 80	jsr $80e7	                jsr w_accept           ; ( addr n1 -- n2)
.8f24		b5 00		lda $00,x	                lda 0,x
.8f26		85 0e		sta $0e		                sta ciblen
.8f28		b5 01		lda $01,x	                lda 1,x
.8f2a		85 0f		sta $0f		                sta ciblen+1            ; though we only accept 255 chars
.8f2c		64 10		stz $10		                stz toin
.8f2e		64 11		stz $11		                stz toin+1
.8f30		a9 ff		lda #$ff	                lda #$FF                ; overwrite with TRUE flag
.8f32		95 00		sta $00,x	                sta 0,x
.8f34		95 01		sta $01,x	                sta 1,x
.8f36		80 10		bra $8f48	                bra _done
.8f38						_src_not_kbd:
.8f38		1a		inc a		                ina
.8f39		d0 08		bne $8f43	                bne _src_not_string
.8f3b		ca		dex		                dex
.8f3c		ca		dex		                dex
.8f3d		74 00		stz $00,x	                stz 0,x
.8f3f		74 01		stz $01,x	                stz 1,x
.8f41		80 05		bra $8f48	                bra z_refill
.8f43						_src_not_string:
.8f43		a9 01		lda #$01	                lda #err_badsource
.8f45		4c ea d7	jmp $d7ea	                jmp error
.8f48						_done:
.8f48		60		rts		z_refill:       rts
.8f49						xt_repeat:
.8f49		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8f4c						w_repeat:
.8f4c		20 22 82	jsr $8222	                jsr w_again
.8f4f		4c 75 86	jmp $8675	                jmp w_then
.8f52						z_repeat:
.8f52						xt_right_bracket:
.8f52						w_right_bracket:
.8f52		a9 ff		lda #$ff	                lda #$FF
.8f54		85 1a		sta $1a		                sta state
.8f56		85 1b		sta $1b		                sta state+1
.8f58						z_right_bracket:
.8f58		60		rts		                rts
.8f59						xt_rot:
.8f59		20 de d7	jsr $d7de	                jsr underflow_3
.8f5c						w_rot:
.8f5c		b4 05		ldy $05,x	                ldy 5,x         ; MSB first
.8f5e		b5 03		lda $03,x	                lda 3,x
.8f60		95 05		sta $05,x	                sta 5,x
.8f62		b5 01		lda $01,x	                lda 1,x
.8f64		95 03		sta $03,x	                sta 3,x
.8f66		94 01		sty $01,x	                sty 1,x
.8f68		b4 04		ldy $04,x	                ldy 4,x         ; LSB next
.8f6a		b5 02		lda $02,x	                lda 2,x
.8f6c		95 04		sta $04,x	                sta 4,x
.8f6e		b5 00		lda $00,x	                lda 0,x
.8f70		95 02		sta $02,x	                sta 2,x
.8f72		94 00		sty $00,x	                sty 0,x
.8f74		60		rts		z_rot:          rts
.8f75						xt_rshift:
.8f75		20 d9 d7	jsr $d7d9	                jsr underflow_2
.8f78						w_rshift:
.8f78		b5 00		lda $00,x	                lda 0,x
.8f7a		29 0f		and #$0f	                and #%00001111
.8f7c		f0 08		beq $8f86	                beq _done               ; if 0 shifts, quit
.8f7e		a8		tay		                tay
.8f7f						_loop:
.8f7f		56 03		lsr $03,x	                lsr 3,x
.8f81		76 02		ror $02,x	                ror 2,x
.8f83		88		dey		                dey
.8f84		d0 f9		bne $8f7f	                bne _loop
.8f86						_done:
.8f86		e8		inx		                inx
.8f87		e8		inx		                inx
.8f88		60		rts		z_rshift:       rts
.8f89						xt_s_backslash_quote:
.8f89						w_s_backslash_quote:
.8f89		a9 ff		lda #$ff	                lda #$FF
.8f8b		85 27		sta $27		                sta tmp2
.8f8d		64 28		stz $28		                stz tmp2+1
.8f8f		20 a6 8f	jsr $8fa6	                jsr s_quote_start
.8f92						z_s_backslash_quote:
.8f92		60		rts		                rts
.8f93						convert_hex_value:
.8f93		c9 41		cmp #$41	        cmp #'A'
.8f95		90 07		bcc $8f9e	        bcc _digit
.8f97		29 df		and #$df	        and #$DF                ; Make it uppercase.
.8f99		38		sec		        sec
.8f9a		e9 37		sbc #$37	        sbc #'7'                ; gives value 10 for 'A'
.8f9c		80 03		bra $8fa1	        bra _done
.8f9e						_digit:
.8f9e		38		sec		        sec
.8f9f		e9 30		sbc #$30	        sbc #'0'
.8fa1						_done:
.8fa1		60		rts		        rts
.8fa2						xt_s_quote:
.8fa2						w_s_quote:
.8fa2		64 27		stz $27		                stz tmp2
.8fa4		64 28		stz $28		                stz tmp2+1
.8fa6						s_quote_start:
.8fa6		a5 1a		lda $1a		                lda state               ; check whether we're interpeting (0) or compiling (-1)
.8fa8		05 1b		ora $1b		                ora state+1             ; paranoid
.8faa		48		pha		                pha                     ; save zero / nonzero for post-processing
.8fab		f0 0b		beq $8fb8	                beq _interpeting        ; just write string directly
.8fad		18		clc		                clc
.8fae		a5 00		lda $00		                lda cp
.8fb0		69 05		adc #$05	                adc #5                  ; reserve five bytes for the prologue (see below)
.8fb2		85 00		sta $00		                sta cp
.8fb4		90 02		bcc $8fb8	                bcc +
.8fb6		e6 01		inc $01		                inc cp+1
.8fb8						+
.8fb8						_interpeting:
.8fb8		20 e7 88	jsr $88e7	                jsr w_here              ; ( addr )
.8fbb						_savechars_loop:
.8fbb		a5 11		lda $11		                lda toin+1              ; MSB
.8fbd		c5 0f		cmp $0f		                cmp ciblen+1
.8fbf		90 2a		bcc $8feb	                bcc _input_fine         ; unsigned comparison
.8fc1		a5 10		lda $10		                lda toin                ; LSB
.8fc3		c5 0e		cmp $0e		                cmp ciblen
.8fc5		90 24		bcc $8feb	                bcc _input_fine
.8fc7		a5 27		lda $27		                lda tmp2
.8fc9		48		pha		                pha
.8fca		a5 28		lda $28		                lda tmp2+1
.8fcc		48		pha		                pha
.8fcd		a5 29		lda $29		                lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
.8fcf		48		pha		                pha
.8fd0		20 07 8f	jsr $8f07	                jsr w_refill           ; ( -- f )
.8fd3		68		pla		                pla
.8fd4		85 29		sta $29		                sta tmp3
.8fd6		68		pla		                pla
.8fd7		85 28		sta $28		                sta tmp2+1
.8fd9		68		pla		                pla
.8fda		85 27		sta $27		                sta tmp2
.8fdc		b5 00		lda $00,x	                lda 0,x
.8fde		15 01		ora $01,x	                ora 1,x
.8fe0		d0 05		bne $8fe7	                bne _refill_ok
.8fe2		a9 06		lda #$06	                lda #err_refill
.8fe4		4c ea d7	jmp $d7ea	                jmp error
.8fe7						_refill_ok:
.8fe7		e8		inx		                inx
.8fe8		e8		inx		                inx
.8fe9		80 d0		bra $8fbb	                bra _savechars_loop
.8feb						_input_fine:
.8feb		a5 0c		lda $0c		                lda cib
.8fed		18		clc		                clc
.8fee		65 10		adc $10		                adc toin        ; LSB
.8ff0		85 25		sta $25		                sta tmp1
.8ff2		a5 0d		lda $0d		                lda cib+1
.8ff4		65 11		adc $11		                adc toin+1      ; MSB
.8ff6		85 26		sta $26		                sta tmp1+1
.8ff8		b2 25		lda ($25)	                lda (tmp1)
.8ffa		24 27		bit $27		                bit tmp2
.8ffc		30 03		bmi $9001	                bmi _handle_escapes    ; Only checking bit 7
.8ffe		4c 69 90	jmp $9069	                jmp _regular_char
.9001						_handle_escapes:
.9001		24 28		bit $28		                bit tmp2+1
.9003		30 03		bmi $9008	                bmi _escaped
.9005		4c 5f 90	jmp $905f	                jmp _not_escaped
.9008						_escaped:
.9008		70 21		bvs $902b	                bvs _check_esc_chars
.900a		a9 01		lda #$01	                lda #1
.900c		24 28		bit $28		                bit tmp2+1
.900e		d0 10		bne $9020	                bne _esc_x_second_digit
.9010		e6 28		inc $28		                inc tmp2+1  ; Adjust flag for second digit next time.
.9012		b2 25		lda ($25)	                lda (tmp1)  ; Get the char again.
.9014		20 93 8f	jsr $8f93	                jsr convert_hex_value
.9017		0a		asl a		                asl
.9018		0a		asl a		                asl
.9019		0a		asl a		                asl
.901a		0a		asl a		                asl
.901b		85 29		sta $29		                sta tmp3    ; Save it for later.
.901d		4c 70 90	jmp $9070	                jmp _next_character
.9020						_esc_x_second_digit:
.9020		64 28		stz $28		                stz tmp2+1
.9022		b2 25		lda ($25)	                lda (tmp1)
.9024		20 93 8f	jsr $8f93	                jsr convert_hex_value
.9027		05 29		ora $29		                ora tmp3
.9029		80 42		bra $906d	                bra _save_character
.902b						_check_esc_chars:
.902b		64 28		stz $28		                stz tmp2+1
.902d		c9 61		cmp #$61	                cmp #'a'
.902f		30 1a		bmi $904b	                bmi _check_esc_quote
.9031		c9 7b		cmp #$7b	                cmp #'z'+1
.9033		10 16		bpl $904b	                bpl _check_esc_quote
.9035		a8		tay		                tay
.9036		b9 3b 90	lda $903b,y	                lda escape_tr_table - 'a',y   ; fake base address to index with a-z directly
.9039		d0 03		bne $903e	                bne _esc_replace
.903b		98		tya		                tya                     ; revert if no translation
.903c		80 0d		bra $904b	                bra _check_esc_quote
.903e		10 2d		bpl $906d	_esc_replace:   bpl _save_character     ; simple replacement
.9040		29 7f		and #$7f	                and #$7F                ; clear hi bit
.9042		f0 29		beq $906d	                beq _save_character     ; NUL we can just output
.9044		20 bc 97	jsr $97bc	                jsr cmpl_a              ; else output first char (CR)
.9047		a9 0a		lda #$0a	                lda #10                 ; followed by LF
.9049		80 22		bra $906d	                bra _save_character
.904b						_check_esc_quote:
.904b		c9 22		cmp #$22	                cmp #'"'
.904d		f0 1e		beq $906d	                beq _save_character
.904f		c9 78		cmp #$78	                cmp #'x'
.9051		d0 06		bne $9059	                bne _check_esc_backslash
.9053		a9 be		lda #$be	                lda #%10111110        ; Clear bits 6 and 0
.9055		85 28		sta $28		                sta tmp2+1
.9057		80 17		bra $9070	                bra _next_character
.9059						_check_esc_backslash:
.9059		c9 5c		cmp #$5c	                cmp #'\'
.905b		d0 0c		bne $9069	                bne _regular_char
.905d		80 0e		bra $906d	                bra _save_character
.905f						_not_escaped:
.905f		c9 5c		cmp #$5c	                cmp #'\'
.9061		d0 06		bne $9069	                bne _regular_char
.9063		a9 ff		lda #$ff	                lda #$FF
.9065		85 28		sta $28		                sta tmp2+1
.9067		80 07		bra $9070	                bra _next_character
.9069						_regular_char:
.9069		c9 22		cmp #$22	                cmp #'"'
.906b		f0 0c		beq $9079	                beq _found_string_end
.906d						_save_character:
.906d		20 bc 97	jsr $97bc	                jsr cmpl_a
.9070						_next_character:
.9070		e6 10		inc $10		                inc toin
.9072		d0 02		bne $9076	                bne _savechars_loop_longjump
.9074		e6 11		inc $11		                inc toin+1
.9076						_savechars_loop_longjump:
.9076		4c bb 8f	jmp $8fbb	                jmp _savechars_loop
.9079						_found_string_end:
.9079		e6 10		inc $10		                inc toin
.907b		d0 02		bne $907f	                bne +
.907d		e6 11		inc $11		                inc toin+1
.907f						+
.907f		20 e7 88	jsr $88e7	                jsr w_here
.9082		20 db 8c	jsr $8cdb	                jsr w_over
.9085		20 bb 8b	jsr $8bbb	                jsr w_minus    ; HERE - addr gives string length
.9088		68		pla		                pla                     ; fetch the state flag (0 = interpret)
.9089		f0 10		beq $909b	                beq _done
.908b		38		sec		                sec                     ; rewind the CP to addr-5
.908c		b5 02		lda $02,x	                lda 2,x
.908e		e9 05		sbc #$05	                sbc #5
.9090		85 00		sta $00		                sta cp
.9092		b5 03		lda $03,x	                lda 3,x
.9094		e9 00		sbc #$00	                sbc #0
.9096		85 01		sta $01		                sta cp+1
.9098		20 2f a2	jsr $a22f	                jsr w_sliteral         ; ( addr u -- )
.909b						_done:
.909b		60		rts		z_s_quote:      rts
.909c						escape_tr_table:
>909c		07				    .byte   7               ; a -> BEL (ASCII value 7)
>909d		08				    .byte   8               ; b -> Backspace (ASCII value 8)
>909e		00 00				    .byte   0,0             ; c, d no escape
>90a0		1b				    .byte   27              ; e -> ESC (ASCII value 27)
>90a1		0c				    .byte   12              ; f -> FF (ASCII value 12)
>90a2		00 00 00 00 00			    .byte   0,0,0,0,0       ; g,h,i,j,k
>90a7		0a				    .byte   10              ; l -> LF (ASCII value 10)
>90a8		8d				    .byte   13+128          ; m -> CR/LF pair (ASCII values 13, 10)
>90a9		0a				    .byte   10              ; n behaves like l --> lf
>90aa		00 00				    .byte   0,0             ; o,p
>90ac		22				    .byte   34              ; q -> Double quote (ASCII value 34)
>90ad		0d				    .byte   13              ; r ->  CR (ASCII value 13)
>90ae		00				    .byte   0               ; s
>90af		09				    .byte   9               ; t -> Horizontal TAB (ASCII value 9)
>90b0		00				    .byte   0               ; u
>90b1		0b				    .byte   11              ; v -> Vertical TAB (ASCII value 11)
>90b2		00 00 00			    .byte   0,0,0           ; w,x,y   (x is a special case later)
>90b5		80				    .byte   0+128           ; z -> NULL (ASCII value 0)
.90b6						xt_s_to_d:
.90b6		20 d4 d7	jsr $d7d4	                jsr underflow_1
.90b9						w_s_to_d:
.90b9		ca		dex		                dex
.90ba		ca		dex		                dex
.90bb		74 00		stz $00,x	                stz 0,x
.90bd		74 01		stz $01,x	                stz 1,x
.90bf		b5 03		lda $03,x	                lda 3,x
.90c1		10 04		bpl $90c7	                bpl _done
.90c3		d6 00		dec $00,x	                dec 0,x
.90c5		d6 01		dec $01,x	                dec 1,x
.90c7						_done:
.90c7		60		rts		z_s_to_d:       rts
.90c8						xt_semicolon:
.90c8						w_semicolon:
.90c8		24 1c		bit $1c		                bit status              ; check bit 6 (overflow flag)
.90ca		70 11		bvs $90dd	                bvs _colonword
.90cc		a9 60		lda #$60	                lda #OpRTS
.90ce		20 bc 97	jsr $97bc	                jsr cmpl_a
.90d1		ca		dex		                dex
.90d2		ca		dex		                dex
.90d3		a5 06		lda $06		                lda workword
.90d5		95 00		sta $00,x	                sta 0,x
.90d7		a5 07		lda $07		                lda workword+1
.90d9		95 01		sta $01,x	                sta 1,x
.90db		80 53		bra $9130	                bra _semicolon_done
.90dd						_colonword:
.90dd		a9 10		lda #$10	                lda #%00010000
.90df		25 1c		and $1c		                and status
.90e1		f0 08		beq $90eb	                beq +
.90e3		a0 01		ldy #$01	                ldy #1
.90e5		b1 06		lda ($06),y	                lda (workword),y
.90e7		29 f7		and #$f7	                and #255-NN
.90e9		91 06		sta ($06),y	                sta (workword),y
.90eb						+
.90eb		a0 06		ldy #$06	                ldy #6
.90ed		a5 00		lda $00		                lda cp
.90ef		91 06		sta ($06),y	                sta (workword),y
.90f1		c8		iny		                iny
.90f2		a5 01		lda $01		                lda cp+1
.90f4		91 06		sta ($06),y	                sta (workword),y
.90f6		a9 60		lda #$60	                lda #OpRTS
.90f8		20 bc 97	jsr $97bc	                jsr cmpl_a
.90fb		24 1c		bit $1c		                bit status
.90fd		10 26		bpl $9125	                bpl _new_word   ; Bit 7 is clear = new word
.90ff		ca		dex		                dex
.9100		ca		dex		                dex
.9101		ca		dex		                dex
.9102		ca		dex		                dex
.9103		b2 06		lda ($06)	                lda (workword)
.9105		95 00		sta $00,x	                sta 0,x
.9107		74 01		stz $01,x	                stz 1,x
.9109		a5 06		lda $06		                lda workword
.910b		18		clc		                clc
.910c		69 08		adc #$08	                adc #8
.910e		95 02		sta $02,x	                sta 2,x
.9110		a5 07		lda $07		                lda workword+1
.9112		69 00		adc #$00	                adc #0                  ; only want carry
.9114		95 03		sta $03,x	                sta 3,x
.9116		a9 02		lda #$02	                lda #str_redefined       ; address of string "redefined"
.9118		20 10 d8	jsr $d810	                jsr print_string_no_lf
.911b		20 b4 94	jsr $94b4	                jsr w_type
.911e		20 b5 91	jsr $91b5	                jsr w_space
.9121		a9 80		lda #$80	                lda #%10000000
.9123		14 1c		trb $1c		                trb status
.9125						_new_word:
.9125		a5 06		lda $06		                lda workword
.9127		85 02		sta $02		                sta dp
.9129		a5 07		lda $07		                lda workword+1
.912b		85 03		sta $03		                sta dp+1
.912d		20 40 d7	jsr $d740	                jsr dp_to_current       ; Save the updated DP to the
.9130						_semicolon_done:
.9130		64 1a		stz $1a		                stz state
.9132		64 1b		stz $1b		                stz state+1
.9134		60		rts		z_semicolon:    rts
.9135						xt_sign:
.9135		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9138						w_sign:
.9138		b5 01		lda $01,x	                lda 1,x         ; check MSB of TOS
.913a		30 04		bmi $9140	                bmi _minus
.913c		e8		inx		                inx
.913d		e8		inx		                inx
.913e		80 09		bra $9149	                bra _done
.9140						_minus:
.9140		a9 2d		lda #$2d	                lda #'-'
.9142		95 00		sta $00,x	                sta 0,x         ; overwrite TOS
.9144		74 01		stz $01,x	                stz 1,x         ; paranoid
.9146		20 fc 88	jsr $88fc	                jsr w_hold
.9149						_done:
.9149		60		rts		z_sign:         rts
.914a						xt_slash:
.914a		20 d9 d7	jsr $d7d9	                jsr underflow_2
.914d						w_slash:
.914d		a9 00		lda #$00	                lda #0
.914f		80 05		bra $9156	                bra slashmod_common
.9151						xt_slash_mod:
.9151		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9154						w_slash_mod:
.9154		a9 ff		lda #$ff	                lda #$FF                ; falls through to _common
.9156						slashmod_common:
.9156		48		pha		                pha
.9157		20 59 93	jsr $9359	                jsr w_to_r             ; >R
.915a		20 b9 90	jsr $90b9	                jsr w_s_to_d           ; S>D
.915d		20 b5 8e	jsr $8eb5	                jsr w_r_from           ; R>
.9160		20 6f 91	jsr $916f	                jsr w_sm_slash_rem     ; SM/REM
.9163		68		pla		                pla
.9164		d0 05		bne $916b	                bne _done
.9166		20 1e 92	jsr $921e	                jsr w_swap
.9169		e8		inx		                inx             ; DROP
.916a		e8		inx		                inx
.916b						_done:
.916b						z_slash_mod:
.916b		60		rts		z_slash:        rts
.916c						xt_sm_slash_rem:
.916c		20 de d7	jsr $d7de	                jsr underflow_3 ; contains double number
.916f						w_sm_slash_rem:
.916f		b5 03		lda $03,x	                lda 3,x
.9171		48		pha		                pha
.9172		b5 01		lda $01,x	                lda 1,x
.9174		55 03		eor $03,x	                eor 3,x
.9176		48		pha		                pha
.9177		20 d2 80	jsr $80d2	                jsr w_abs
.917a		e8		inx		                inx             ; pretend we pushed n1 to R
.917b		e8		inx		                inx
.917c		20 b8 9e	jsr $9eb8	                jsr w_dabs
.917f		ca		dex		                dex
.9180		ca		dex		                dex
.9181		20 39 95	jsr $9539	                jsr w_um_slash_mod     ; UM/MOD
.9184		68		pla		                pla
.9185		10 03		bpl $918a	                bpl +
.9187		20 f9 8b	jsr $8bf9	                jsr w_negate
.918a						+
.918a		68		pla		                pla
.918b		10 07		bpl $9194	                bpl _done
.918d		e8		inx		                inx             ; pretend we pushed quotient to R
.918e		e8		inx		                inx
.918f		20 f9 8b	jsr $8bf9	                jsr w_negate
.9192		ca		dex		                dex
.9193		ca		dex		                dex
.9194						_done:
.9194		60		rts		z_sm_slash_rem: rts
.9195						xt_source:
.9195						w_source:
.9195		ca		dex		                dex
.9196		ca		dex		                dex
.9197		a5 0c		lda $0c		                lda cib
.9199		95 00		sta $00,x	                sta 0,x
.919b		a5 0d		lda $0d		                lda cib+1
.919d		95 01		sta $01,x	                sta 1,x
.919f		ca		dex		                dex
.91a0		ca		dex		                dex
.91a1		a5 0e		lda $0e		                lda ciblen
.91a3		95 00		sta $00,x	                sta 0,x
.91a5		a5 0f		lda $0f		                lda ciblen+1
.91a7		95 01		sta $01,x	                sta 1,x
.91a9		60		rts		z_source:       rts
.91aa						xt_source_id:
.91aa						w_source_id:
.91aa		ca		dex		                dex
.91ab		ca		dex		                dex
.91ac		a5 0a		lda $0a		                lda insrc
.91ae		95 00		sta $00,x	                sta 0,x
.91b0		a5 0b		lda $0b		                lda insrc+1
.91b2		95 01		sta $01,x	                sta 1,x
.91b4		60		rts		z_source_id:    rts
.91b5						xt_space:
.91b5						w_space:
.91b5		a9 20		lda #$20	                lda #AscSP
.91b7		20 86 86	jsr $8686	                jsr emit_a
.91ba		60		rts		z_space:        rts
.91bb						xt_spaces:
.91bb		20 d4 d7	jsr $d7d4	                jsr underflow_1
.91be						w_spaces:
.91be		b5 01		lda $01,x	                lda 1,x         ; ANS says this word takes a signed value
.91c0		30 10		bmi $91d2	                bmi _done       ; but prints no spaces for negative values.
.91c2		b4 00		ldy $00,x	                ldy 0,x
.91c4		f0 08		beq $91ce	                beq _msb
.91c6						_loop:
.91c6		a9 20		lda #$20	                lda #AscSP
.91c8		20 86 86	jsr $8686	                jsr emit_a      ; user routine preserves X and Y
.91cb		88		dey		                dey
.91cc		d0 f8		bne $91c6	                bne _loop       ; Y is zero on exit so looping again emits 256 more spaces
.91ce						_msb:
.91ce		d6 01		dec $01,x	                dec 1,x         ; when decrementing MSB goes negative, it was zero so we're done
.91d0		10 f4		bpl $91c6	                bpl _loop       ; otherwise emit another 256 spaces
.91d2		e8		inx		_done:          inx
.91d3		e8		inx		                inx
.91d4		60		rts		z_spaces:       rts
.91d5						xt_star:
.91d5		20 d9 d7	jsr $d7d9	                jsr underflow_2
.91d8						w_star:
.91d8		20 7b 95	jsr $957b	                jsr w_um_star
.91db		e8		inx		                inx
.91dc		e8		inx		                inx
.91dd		60		rts		z_star:         rts
.91de						xt_star_slash:
.91de		20 de d7	jsr $d7de	                jsr underflow_3
.91e1						w_star_slash:
.91e1		20 ed 91	jsr $91ed	                jsr w_star_slash_mod
.91e4		20 1e 92	jsr $921e	                jsr w_swap
.91e7		e8		inx		                inx
.91e8		e8		inx		                inx
.91e9						z_star_slash:
.91e9		60		rts		                rts
.91ea						xt_star_slash_mod:
.91ea		20 de d7	jsr $d7de	                jsr underflow_3
.91ed						w_star_slash_mod:
.91ed		20 59 93	jsr $9359	                jsr w_to_r
.91f0		20 02 8b	jsr $8b02	                jsr w_m_star
.91f3		20 b5 8e	jsr $8eb5	                jsr w_r_from
.91f6		20 6f 91	jsr $916f	                jsr w_sm_slash_rem
.91f9						z_star_slash_mod:
.91f9		60		rts		                rts
.91fa						xt_state:
.91fa						w_state:
.91fa		ca		dex		                dex
.91fb		ca		dex		                dex
.91fc		a9 1a		lda #$1a	                lda #<state
.91fe		95 00		sta $00,x	                sta 0,x
.9200		a9 00		lda #$00	                lda #>state
.9202		95 01		sta $01,x	                sta 1,x
.9204		60		rts		z_state:        rts
.9205						xt_store:
.9205		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9208						w_store:
.9208		b5 02		lda $02,x	                lda 2,x         ; LSB
.920a		81 00		sta ($00,x)	                sta (0,x)
.920c		f6 00		inc $00,x	                inc 0,x
.920e		d0 02		bne $9212	                bne +
.9210		f6 01		inc $01,x	                inc 1,x
.9212						+
.9212		b5 03		lda $03,x	                lda 3,x         ; MSB
.9214		81 00		sta ($00,x)	                sta (0,x)
.9216		e8		inx		                inx             ; 2DROP
.9217		e8		inx		                inx
.9218		e8		inx		                inx
.9219		e8		inx		                inx
.921a		60		rts		z_store:        rts
.921b						xt_swap:
.921b		20 d9 d7	jsr $d7d9	                jsr underflow_2
.921e						w_swap:
.921e		b5 00		lda $00,x	                lda 0,x         ; LSB
.9220		b4 02		ldy $02,x	                ldy 2,x
.9222		95 02		sta $02,x	                sta 2,x
.9224		94 00		sty $00,x	                sty 0,x
.9226		b5 01		lda $01,x	                lda 1,x         ; MSB
.9228		b4 03		ldy $03,x	                ldy 3,x
.922a		95 03		sta $03,x	                sta 3,x
.922c		94 01		sty $01,x	                sty 1,x
.922e		60		rts		z_swap:         rts
.922f						xt_tick:
.922f						w_tick:
.922f		20 24 8d	jsr $8d24	                jsr w_parse_name       ; ( -- addr u )
.9232		b5 00		lda $00,x	                lda 0,x
.9234		15 01		ora $01,x	                ora 1,x
.9236		d0 05		bne $923d	                bne +
.9238		a9 05		lda #$05	                lda #err_noname
.923a		4c ea d7	jmp $d7ea	                jmp error
.923d						+
.923d		20 5d 9b	jsr $9b5d	                jsr w_find_name        ; ( addr u -- nt )
.9240		b5 00		lda $00,x	                lda 0,x
.9242		15 01		ora $01,x	                ora 1,x
.9244		d0 05		bne $924b	                bne +
.9246		a9 08		lda #$08	                lda #err_syntax
.9248		4c ea d7	jmp $d7ea	                jmp error
.924b						+
.924b		20 a6 9c	jsr $9ca6	                jsr w_name_to_int      ; ( nt -- xt )
.924e		60		rts		z_tick:         rts
.924f						xt_to:
.924f						w_to:
.924f		20 2f 92	jsr $922f	                jsr w_tick             ; ( [n] xt )
.9252		b5 00		lda $00,x	                lda 0,x                 ; LSB
.9254		18		clc		                clc
.9255		69 03		adc #$03	                adc #3
.9257		85 25		sta $25		                sta tmp1
.9259		b5 01		lda $01,x	                lda 1,x                 ; MSB
.925b		69 00		adc #$00	                adc #0                  ; we just want the carry
.925d		85 26		sta $26		                sta tmp1+1
.925f		a5 1a		lda $1a		                lda state
.9261		05 1b		ora $1b		                ora state+1
.9263		f0 14		beq $9279	                beq _interpret
.9265		a5 25		lda $25		                lda tmp1            ; replace TOS with tmp1
.9267		95 00		sta $00,x	                sta 0,x
.9269		a5 26		lda $26		                lda tmp1+1
.926b		95 01		sta $01,x	                sta 1,x
.926d		20 d3 89	jsr $89d3	                jsr w_literal      ; generate the runtime for LITERAL tmp1
.9270		a0 92		ldy #$92	                ldy #>w_store      ; write the runtime for !
.9272		a9 08		lda #$08	                lda #<w_store
.9274		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.9277		80 11		bra $928a	                bra _done
.9279						_interpret:
.9279		20 d9 d7	jsr $d7d9	                jsr underflow_2
.927c		e8		inx		                inx
.927d		e8		inx		                inx                     ; leaving just ( n )
.927e		b5 00		lda $00,x	                lda 0,x
.9280		92 25		sta ($25)	                sta (tmp1)              ; LSB
.9282		a0 01		ldy #$01	                ldy #1
.9284		b5 01		lda $01,x	                lda 1,x                 ; MSB
.9286		91 25		sta ($25),y	                sta (tmp1),y            ; fall through to common
.9288		e8		inx		                inx                     ; DROP
.9289		e8		inx		                inx
.928a						_done:
.928a		60		rts		z_to:           rts
.928b						xt_to_body:
.928b		20 d4 d7	jsr $d7d4	                jsr underflow_1
.928e						w_to_body:
.928e		20 5c 86	jsr $865c	                jsr w_dup              ; ( xt xt )
.9291		20 20 9c	jsr $9c20	                jsr w_int_to_name      ; ( xt nt )
.9294		f6 00		inc $00,x	                inc 0,x
.9296		d0 02		bne $929a	                bne +
.9298		f6 01		inc $01,x	                inc 1,x
.929a						+
.929a		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.929c		29 10		and #$10	                and #HC
.929e		f0 0b		beq $92ab	                beq _no_cfa
.92a0		18		clc		                clc
.92a1		b5 02		lda $02,x	                lda 2,x         ; LSB
.92a3		69 03		adc #$03	                adc #3
.92a5		95 02		sta $02,x	                sta 2,x
.92a7		90 02		bcc $92ab	                bcc _no_cfa
.92a9		f6 03		inc $03,x	                inc 3,x         ; MSB
.92ab						_no_cfa:
.92ab		e8		inx		                inx             ; get rid of the nt
.92ac		e8		inx		                inx
.92ad		60		rts		z_to_body:      rts
.92ae						xt_to_in:
.92ae						w_to_in:
.92ae		ca		dex		                dex
.92af		ca		dex		                dex
.92b0		a9 10		lda #$10	                lda #<toin
.92b2		95 00		sta $00,x	                sta 0,x
.92b4		a9 00		lda #$00	                lda #>toin      ; paranoid, should be zero
.92b6		95 01		sta $01,x	                sta 1,x
.92b8		60		rts		z_to_in:        rts
.92b9						xt_to_number:
.92b9		20 e3 d7	jsr $d7e3	                jsr underflow_4
.92bc						w_to_number:
.92bc		b5 06		lda $06,x	                lda 6,x         ; ud-lo LSB
.92be		85 2d		sta $2d		                sta scratch
.92c0		b5 07		lda $07,x	                lda 7,x         ; ud-lo MSB
.92c2		85 2e		sta $2e		                sta scratch+1
.92c4		b5 04		lda $04,x	                lda 4,x         ; ud-hi LSB
.92c6		85 2f		sta $2f		                sta scratch+2
.92c8		b5 05		lda $05,x	                lda 5,x         ; ud-hi MSB
.92ca		85 30		sta $30		                sta scratch+3
.92cc		ca		dex		                dex
.92cd		ca		dex		                dex
.92ce						_loop:
.92ce		a1 04		lda ($04,x)	                lda (4,x)
.92d0		95 00		sta $00,x	                sta 0,x                 ; ( ud-lo ud-hi addr u char )
.92d2		74 01		stz $01,x	                stz 1,x                 ; paranoid
.92d4		20 01 9b	jsr $9b01	                jsr w_digit_question   ; ( char -- n -1 | char 0 )
.92d7		b5 00		lda $00,x	                lda 0,x
.92d9		d0 04		bne $92df	                bne _digit_ok
.92db		e8		inx		                inx
.92dc		e8		inx		                inx
.92dd		80 67		bra $9346	                bra _done       ; ( ud-lo ud-hi addr u char )
.92df						_digit_ok:
.92df		b5 02		lda $02,x	                lda 2,x
.92e1		85 31		sta $31		                sta scratch+4
.92e3		b5 03		lda $03,x	                lda 3,x
.92e5		85 32		sta $32		                sta scratch+5
.92e7		a5 2f		lda $2f		                lda scratch+2
.92e9		95 02		sta $02,x	                sta 2,x         ; NOS
.92eb		a5 30		lda $30		                lda scratch+3
.92ed		95 03		sta $03,x	                sta 3,x
.92ef		a5 18		lda $18		                lda base
.92f1		95 00		sta $00,x	                sta 0,x         ; TOS
.92f3		74 01		stz $01,x	                stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
.92f5		20 7b 95	jsr $957b	                jsr w_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
.92f8		b5 02		lda $02,x	                lda 2,x         ; ud-hi-lo
.92fa		85 33		sta $33		                sta scratch+6
.92fc		b5 03		lda $03,x	                lda 3,x
.92fe		85 34		sta $34		                sta scratch+7
.9300		a5 2d		lda $2d		                lda scratch
.9302		95 02		sta $02,x	                sta 2,x
.9304		a5 2e		lda $2e		                lda scratch+1
.9306		95 03		sta $03,x	                sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
.9308		a5 18		lda $18		                lda base
.930a		95 00		sta $00,x	                sta 0,x
.930c		74 01		stz $01,x	                stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
.930e		20 7b 95	jsr $957b	                jsr w_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
.9311		b5 00		lda $00,x	                lda 0,x
.9313		85 2f		sta $2f		                sta scratch+2
.9315		b5 01		lda $01,x	                lda 1,x
.9317		85 30		sta $30		                sta scratch+3
.9319		b5 02		lda $02,x	                lda 2,x
.931b		85 2d		sta $2d		                sta scratch
.931d		b5 03		lda $03,x	                lda 3,x
.931f		85 2e		sta $2e		                sta scratch+1
.9321		18		clc		                clc
.9322		a5 2d		lda $2d		                lda scratch     ; ud-lo LSB
.9324		65 31		adc $31		                adc scratch+4   ; n LSB
.9326		85 2d		sta $2d		                sta scratch     ; this is the new ud-lo
.9328		a5 2e		lda $2e		                lda scratch+1   ; ud-lo MSB
.932a		65 32		adc $32		                adc scratch+5   ; n MSB
.932c		85 2e		sta $2e		                sta scratch+1
.932e		a5 2f		lda $2f		                lda scratch+2   ; LSB
.9330		65 33		adc $33		                adc scratch+6
.9332		85 2f		sta $2f		                sta scratch+2   ; this is the new ud-hi
.9334		a5 30		lda $30		                lda scratch+3   ; MSB
.9336		65 34		adc $34		                adc scratch+7
.9338		85 30		sta $30		                sta scratch+3
.933a		e8		inx		                inx
.933b		e8		inx		                inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
.933c		f6 04		inc $04,x	                inc 4,x
.933e		d0 02		bne $9342	                bne +
.9340		f6 05		inc $05,x	                inc 5,x
.9342						+
.9342		d6 02		dec $02,x	                dec 2,x
.9344		d0 88		bne $92ce	                bne _loop
.9346						_done:
.9346		e8		inx		                inx
.9347		e8		inx		                inx             ; ( ud-lo ud-hi addr u )
.9348		a5 2d		lda $2d		                lda scratch     ; new ud-lo
.934a		95 06		sta $06,x	                sta 6,x
.934c		a5 2e		lda $2e		                lda scratch+1
.934e		95 07		sta $07,x	                sta 7,x
.9350		a5 2f		lda $2f		                lda scratch+2
.9352		95 04		sta $04,x	                sta 4,x
.9354		a5 30		lda $30		                lda scratch+3
.9356		95 05		sta $05,x	                sta 5,x
.9358		60		rts		z_to_number:    rts
.9359						xt_to_r:
.9359						w_to_r:
.9359		68		pla		                pla                     ; LSB
.935a		7a		ply		                ply                     ; MSB
.935b		1a		inc a		                inc a
.935c		85 25		sta $25		                sta tmp1                ; LSB
.935e		d0 01		bne $9361	                bne +
.9360		c8		iny		                iny
.9361						+
.9361		84 26		sty $26		                sty tmp1+1              ; MSB
.9363		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9366		b5 01		lda $01,x	                lda 1,x         ; MSB
.9368		48		pha		                pha
.9369		b5 00		lda $00,x	                lda 0,x         ; LSB
.936b		48		pha		                pha
.936c		e8		inx		                inx
.936d		e8		inx		                inx
.936e		6c 25 00	jmp ($0025)	z_to_r:         jmp (tmp1)
.9371						xt_true:
.9371						w_true:
.9371		ca		dex		                dex
.9372		ca		dex		                dex
.9373		a9 ff		lda #$ff	                lda #$FF
.9375		95 00		sta $00,x	                sta 0,x
.9377		95 01		sta $01,x	                sta 1,x
.9379		60		rts		z_true:         rts
.937a						xt_tuck:
.937a		20 d9 d7	jsr $d7d9	                jsr underflow_2
.937d						w_tuck:
.937d		ca		dex		                dex
.937e		ca		dex		                dex
.937f		b4 04		ldy $04,x	                ldy 4,x         ; LSB
.9381		b5 02		lda $02,x	                lda 2,x
.9383		95 04		sta $04,x	                sta 4,x
.9385		94 02		sty $02,x	                sty 2,x
.9387		95 00		sta $00,x	                sta 0,x
.9389		b4 05		ldy $05,x	                ldy 5,x         ; MSB
.938b		b5 03		lda $03,x	                lda 3,x
.938d		95 05		sta $05,x	                sta 5,x
.938f		94 03		sty $03,x	                sty 3,x         ; bba
.9391		95 01		sta $01,x	                sta 1,x         ; baa
.9393		60		rts		z_tuck:         rts
.9394						xt_two_drop:
.9394		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9397						w_two_drop:
.9397		e8		inx		                inx
.9398		e8		inx		                inx
.9399		e8		inx		                inx
.939a		e8		inx		                inx
.939b		60		rts		z_two_drop:     rts
.939c						xt_two_dup:
.939c		20 d9 d7	jsr $d7d9	                jsr underflow_2
.939f						w_two_dup:
.939f		ca		dex		                dex
.93a0		ca		dex		                dex
.93a1		ca		dex		                dex
.93a2		ca		dex		                dex
.93a3		b5 04		lda $04,x	                lda 4,x         ; TOS
.93a5		95 00		sta $00,x	                sta 0,x
.93a7		b5 05		lda $05,x	                lda 5,x
.93a9		95 01		sta $01,x	                sta 1,x
.93ab		b5 06		lda $06,x	                lda 6,x         ; NOS
.93ad		95 02		sta $02,x	                sta 2,x
.93af		b5 07		lda $07,x	                lda 7,x
.93b1		95 03		sta $03,x	                sta 3,x
.93b3		60		rts		z_two_dup:      rts
.93b4						xt_two_fetch:
.93b4		20 d4 d7	jsr $d7d4	                jsr underflow_1
.93b7						w_two_fetch:
.93b7		b5 00		lda $00,x	                lda 0,x
.93b9		85 25		sta $25		                sta tmp1
.93bb		b4 01		ldy $01,x	                ldy 1,x
.93bd		84 26		sty $26		                sty tmp1+1
.93bf		ca		dex		                dex             ; reuse one stack element
.93c0		ca		dex		                dex
.93c1		b2 25		lda ($25)	                lda (tmp1)      ; copy LSB
.93c3		95 00		sta $00,x	                sta 0,x
.93c5		a0 01		ldy #$01	                ldy #1          ; copy next
.93c7		b1 25		lda ($25),y	                lda (tmp1),y
.93c9		95 01		sta $01,x	                sta 1,x
.93cb		c8		iny		                iny             ; copy next
.93cc		b1 25		lda ($25),y	                lda (tmp1),y
.93ce		95 02		sta $02,x	                sta 2,x
.93d0		c8		iny		                iny             ; copy next
.93d1		b1 25		lda ($25),y	                lda (tmp1),y
.93d3		95 03		sta $03,x	                sta 3,x
.93d5		60		rts		z_two_fetch:    rts
.93d6						xt_two_over:
.93d6		20 e3 d7	jsr $d7e3	                jsr underflow_4
.93d9						w_two_over:
.93d9		ca		dex		                dex
.93da		ca		dex		                dex
.93db		ca		dex		                dex
.93dc		ca		dex		                dex
.93dd		b5 08		lda $08,x	                lda 8,x
.93df		95 00		sta $00,x	                sta 0,x
.93e1		b5 09		lda $09,x	                lda 9,x
.93e3		95 01		sta $01,x	                sta 1,x
.93e5		b5 0a		lda $0a,x	                lda 10,x
.93e7		95 02		sta $02,x	                sta 2,x
.93e9		b5 0b		lda $0b,x	                lda 11,x
.93eb		95 03		sta $03,x	                sta 3,x
.93ed		60		rts		z_two_over:     rts
.93ee						xt_two_r_fetch:
.93ee						w_two_r_fetch:
.93ee		68		pla		                pla                     ; LSB
.93ef		7a		ply		                ply                     ; MSB
.93f0		1a		inc a		                inc a
.93f1		85 25		sta $25		                sta tmp1                ; LSB
.93f3		d0 01		bne $93f6	                bne +
.93f5		c8		iny		                iny
.93f6						+
.93f6		84 26		sty $26		                sty tmp1+1              ; MSB
.93f8		8a		txa		                txa             ; arrange for Y = SP; X -= 4
.93f9		ba		tsx		                tsx
.93fa		da		phx		                phx             ; 65c02 has no TXY, so do it the hard way
.93fb		7a		ply		                ply
.93fc		38		sec		                sec
.93fd		e9 04		sbc #$04	                sbc #4
.93ff		aa		tax		                tax
.9400		b9 01 01	lda $0101,y	                lda $101,y
.9403		95 00		sta $00,x	                sta 0,x
.9405		b9 02 01	lda $0102,y	                lda $102,y
.9408		95 01		sta $01,x	                sta 1,x
.940a		b9 03 01	lda $0103,y	                lda $103,y
.940d		95 02		sta $02,x	                sta 2,x
.940f		b9 04 01	lda $0104,y	                lda $104,y
.9412		95 03		sta $03,x	                sta 3,x
.9414		6c 25 00	jmp ($0025)	z_two_r_fetch:  jmp (tmp1)
.9417						xt_two_r_from:
.9417						w_two_r_from:
.9417		68		pla		                pla
.9418		7a		ply		                ply                     ; MSB
.9419		1a		inc a		                inc a
.941a		85 25		sta $25		                sta tmp1                ; LSB
.941c		d0 01		bne $941f	                bne +
.941e		c8		iny		                iny
.941f						+
.941f		84 26		sty $26		                sty tmp1+1              ; MSB
.9421		ca		dex		                dex
.9422		ca		dex		                dex
.9423		ca		dex		                dex
.9424		ca		dex		                dex
.9425		68		pla		                pla                     ; LSB
.9426		95 00		sta $00,x	                sta 0,x
.9428		68		pla		                pla                     ; MSB
.9429		95 01		sta $01,x	                sta 1,x
.942b		68		pla		                pla                     ; LSB
.942c		95 02		sta $02,x	                sta 2,x
.942e		68		pla		                pla                     ; MSB
.942f		95 03		sta $03,x	                sta 3,x
.9431		6c 25 00	jmp ($0025)	z_two_r_from:   jmp (tmp1)
.9434						xt_two_slash:
.9434		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9437						w_two_slash:
.9437		b5 01		lda $01,x	                lda 1,x
.9439		0a		asl a		                asl                     ; save the sign
.943a		76 01		ror $01,x	                ror 1,x
.943c		76 00		ror $00,x	                ror 0,x
.943e		60		rts		z_two_slash:    rts
.943f						xt_two_star:
.943f						xt_cells:
.943f		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9442						w_two_star:
.9442						w_cells:
.9442		16 00		asl $00,x	                asl 0,x
.9444		36 01		rol $01,x	                rol 1,x
.9446						z_cells:
.9446		60		rts		z_two_star:     rts
.9447						xt_two_store:
.9447		20 de d7	jsr $d7de	                jsr underflow_3
.944a						w_two_store:
.944a		b5 00		lda $00,x	                lda 0,x
.944c		85 25		sta $25		                sta tmp1
.944e		b4 01		ldy $01,x	                ldy 1,x
.9450		84 26		sty $26		                sty tmp1+1
.9452		e8		inx		                inx
.9453		e8		inx		                inx
.9454		b5 00		lda $00,x	                lda 0,x         ; copy MSB
.9456		92 25		sta ($25)	                sta (tmp1)
.9458		b5 01		lda $01,x	                lda 1,x         ; copy next
.945a		a0 01		ldy #$01	                ldy #1
.945c		91 25		sta ($25),y	                sta (tmp1),y
.945e		b5 02		lda $02,x	                lda 2,x         ; copy next
.9460		c8		iny		                iny
.9461		91 25		sta ($25),y	                sta (tmp1),y
.9463		b5 03		lda $03,x	                lda 3,x         ; copy MSB
.9465		c8		iny		                iny
.9466		91 25		sta ($25),y	                sta (tmp1),y
.9468		e8		inx		                inx             ; 2DROP
.9469		e8		inx		                inx
.946a		e8		inx		                inx
.946b		e8		inx		                inx
.946c		60		rts		z_two_store:    rts
.946d						xt_two_swap:
.946d		20 e3 d7	jsr $d7e3	                jsr underflow_4
.9470						w_two_swap:
.9470		b5 00		lda $00,x	                lda 0,x
.9472		b4 04		ldy $04,x	                ldy 4,x
.9474		95 04		sta $04,x	                sta 4,x
.9476		94 00		sty $00,x	                sty 0,x
.9478		b5 01		lda $01,x	                lda 1,x
.947a		b4 05		ldy $05,x	                ldy 5,x
.947c		95 05		sta $05,x	                sta 5,x
.947e		94 01		sty $01,x	                sty 1,x
.9480		b5 02		lda $02,x	                lda 2,x
.9482		b4 06		ldy $06,x	                ldy 6,x
.9484		95 06		sta $06,x	                sta 6,x
.9486		94 02		sty $02,x	                sty 2,x
.9488		b5 03		lda $03,x	                lda 3,x
.948a		b4 07		ldy $07,x	                ldy 7,x
.948c		95 07		sta $07,x	                sta 7,x
.948e		94 03		sty $03,x	                sty 3,x
.9490		60		rts		z_two_swap:     rts
.9491						xt_two_to_r:
.9491						w_two_to_r:
.9491		68		pla		                pla                     ; LSB
.9492		7a		ply		                ply                     ; MSB
.9493		1a		inc a		                inc a
.9494		85 25		sta $25		                sta tmp1                ; LSB
.9496		d0 01		bne $9499	                bne +
.9498		c8		iny		                iny
.9499						+
.9499		84 26		sty $26		                sty tmp1+1              ; MSB
.949b		20 d9 d7	jsr $d7d9	                jsr underflow_2
.949e		b5 03		lda $03,x	                lda 3,x         ; MSB
.94a0		48		pha		                pha
.94a1		b5 02		lda $02,x	                lda 2,x         ; LSB
.94a3		48		pha		                pha
.94a4		b5 01		lda $01,x	                lda 1,x         ; MSB
.94a6		48		pha		                pha
.94a7		b5 00		lda $00,x	                lda 0,x         ; LSB
.94a9		48		pha		                pha
.94aa		e8		inx		                inx
.94ab		e8		inx		                inx
.94ac		e8		inx		                inx
.94ad		e8		inx		                inx
.94ae		6c 25 00	jmp ($0025)	z_two_to_r:     jmp (tmp1)
.94b1						xt_type:
.94b1		20 d9 d7	jsr $d7d9	                jsr underflow_2
.94b4						w_type:
.94b4		b5 02		lda $02,x	                lda 2,x
.94b6		85 25		sta $25		                sta tmp1
.94b8		b5 03		lda $03,x	                lda 3,x
.94ba		85 26		sta $26		                sta tmp1+1
.94bc						_loop:
.94bc		b5 00		lda $00,x	                lda 0,x
.94be		15 01		ora $01,x	                ora 1,x
.94c0		f0 15		beq $94d7	                beq _done
.94c2		b2 25		lda ($25)	                lda (tmp1)
.94c4		20 86 86	jsr $8686	                jsr emit_a      ; avoids stack foolery
.94c7		e6 25		inc $25		                inc tmp1
.94c9		d0 02		bne $94cd	                bne +
.94cb		e6 26		inc $26		                inc tmp1+1
.94cd						+
.94cd		b5 00		lda $00,x	                lda 0,x
.94cf		d0 02		bne $94d3	                bne +
.94d1		d6 01		dec $01,x	                dec 1,x
.94d3						+
.94d3		d6 00		dec $00,x	                dec 0,x
.94d5		80 e5		bra $94bc	                bra _loop
.94d7						_done:
.94d7		e8		inx		                inx
.94d8		e8		inx		                inx
.94d9		e8		inx		                inx
.94da		e8		inx		                inx
.94db		60		rts		z_type:         rts
.94dc						xt_u_dot:
.94dc		20 d4 d7	jsr $d7d4	                jsr underflow_1
.94df						w_u_dot:
.94df		20 40 d8	jsr $d840	                jsr print_u
.94e2		a9 20		lda #$20	                lda #AscSP
.94e4		20 86 86	jsr $8686	                jsr emit_a
.94e7		60		rts		z_u_dot:        rts
.94e8						xt_u_dot_r:
.94e8		20 d9 d7	jsr $d7d9	                jsr underflow_2
.94eb						w_u_dot_r:
.94eb		20 59 93	jsr $9359	                jsr w_to_r
.94ee		20 66 9e	jsr $9e66	                jsr w_zero
.94f1		20 ad 89	jsr $89ad	                jsr w_less_number_sign
.94f4		20 89 8c	jsr $8c89	                jsr w_number_sign_s
.94f7		20 67 8c	jsr $8c67	                jsr w_number_sign_greater
.94fa		20 b5 8e	jsr $8eb5	                jsr w_r_from
.94fd		20 db 8c	jsr $8cdb	                jsr w_over
.9500		20 bb 8b	jsr $8bbb	                jsr w_minus
.9503		20 be 91	jsr $91be	                jsr w_spaces
.9506		20 b4 94	jsr $94b4	                jsr w_type
.9509		60		rts		z_u_dot_r:      rts
.950a						xt_u_greater_than:
.950a		20 d9 d7	jsr $d7d9	                jsr underflow_2
.950d						w_u_greater_than:
.950d		b5 00		lda $00,x	                lda 0,x
.950f		d5 02		cmp $02,x	                cmp 2,x
.9511		b5 01		lda $01,x	                lda 1,x
.9513		f5 03		sbc $03,x	                sbc 3,x
.9515		e8		inx		                inx
.9516		e8		inx		                inx
.9517		a9 00		lda #$00	                lda #0
.9519		69 ff		adc #$ff	                adc #$FF
.951b		95 00		sta $00,x	                sta 0,x         ; store flag
.951d		95 01		sta $01,x	                sta 1,x
.951f		60		rts		z_u_greater_than:    rts
.9520						xt_u_less_than:
.9520		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9523						w_u_less_than:
.9523		b5 02		lda $02,x	                lda 2,x
.9525		d5 00		cmp $00,x	                cmp 0,x
.9527		b5 03		lda $03,x	                lda 3,x
.9529		f5 01		sbc $01,x	                sbc 1,x
.952b		e8		inx		                inx
.952c		e8		inx		                inx
.952d		a9 00		lda #$00	                lda #0
.952f		69 ff		adc #$ff	                adc #$FF
.9531		95 00		sta $00,x	                sta 0,x         ; store flag
.9533		95 01		sta $01,x	                sta 1,x
.9535		60		rts		z_u_less_than:    rts
.9536						xt_um_slash_mod:
.9536		20 de d7	jsr $d7de	                jsr underflow_3
.9539						w_um_slash_mod:
.9539		b5 00		lda $00,x	                lda 0,x
.953b		15 01		ora $01,x	                ora 1,x
.953d		d0 05		bne $9544	                bne _not_zero
.953f		a9 04		lda #$04	                lda #err_divzero
.9541		4c ea d7	jmp $d7ea	                jmp error
.9544						_not_zero:
.9544		a9 11		lda #$11	                lda #17
.9546		85 23		sta $23		                sta tmptos
.9548						_loop:
.9548		36 04		rol $04,x	                rol 4,x
.954a		36 05		rol $05,x	                rol 5,x
.954c		c6 23		dec $23		                dec tmptos
.954e		f0 22		beq $9572	                beq _done
.9550		36 02		rol $02,x	                rol 2,x
.9552		36 03		rol $03,x	                rol 3,x
.9554		64 25		stz $25		                stz tmp1        ; store the bit we got from hi cell (MSB)
.9556		26 25		rol $25		                rol tmp1
.9558		38		sec		                sec
.9559		b5 02		lda $02,x	                lda 2,x
.955b		f5 00		sbc $00,x	                sbc 0,x
.955d		85 26		sta $26		                sta tmp1+1
.955f		b5 03		lda $03,x	                lda 3,x
.9561		f5 01		sbc $01,x	                sbc 1,x
.9563		a8		tay		                tay
.9564		a5 25		lda $25		                lda tmp1
.9566		e9 00		sbc #$00	                sbc #0
.9568		90 de		bcc $9548	                bcc _loop
.956a		a5 26		lda $26		                lda tmp1+1
.956c		95 02		sta $02,x	                sta 2,x
.956e		94 03		sty $03,x	                sty 3,x         ; used as temp storage
.9570		80 d6		bra $9548	                bra _loop
.9572						_done:
.9572		e8		inx		                inx
.9573		e8		inx		                inx
.9574		20 1e 92	jsr $921e	                jsr w_swap
.9577		60		rts		z_um_slash_mod: rts
.9578						xt_um_star:
.9578		20 d9 d7	jsr $d7d9	                jsr underflow_2
.957b						w_um_star:
.957b		18		clc		                clc
.957c		b5 00		lda $00,x	                lda 0,x         ; copy TOS to tmp2
.957e		e9 00		sbc #$00	                sbc #0
.9580		85 27		sta $27		                sta tmp2
.9582		b5 01		lda $01,x	                lda 1,x
.9584		e9 00		sbc #$00	                sbc #0
.9586		90 31		bcc $95b9	                bcc _zero       ; is TOS zero?
.9588		85 28		sta $28		                sta tmp2+1
.958a		a9 00		lda #$00	                lda #0
.958c		85 25		sta $25		                sta tmp1
.958e		86 29		stx $29		                stx tmp3        ; tested for exit from outer loop
.9590		ca		dex		                dex
.9591		ca		dex		                dex
.9592						_outer_loop:
.9592		a0 08		ldy #$08	                ldy #8          ; counter inner loop
.9594		56 04		lsr $04,x	                lsr 4,x         ; think "2,x" then later "3,x"
.9596						_inner_loop:
.9596		90 0c		bcc $95a4	                bcc _no_add
.9598		85 26		sta $26		                sta tmp1+1      ; save time, don't CLC
.959a		a5 25		lda $25		                lda tmp1
.959c		65 27		adc $27		                adc tmp2
.959e		85 25		sta $25		                sta tmp1
.95a0		a5 26		lda $26		                lda tmp1+1
.95a2		65 28		adc $28		                adc tmp2+1
.95a4						_no_add:
.95a4		6a		ror a		                ror
.95a5		66 25		ror $25		                ror tmp1
.95a7		76 04		ror $04,x	                ror 4,x         ; think "2,x" then later "3,x"
.95a9		88		dey		                dey
.95aa		d0 ea		bne $9596	                bne _inner_loop ; go back for one more shift?
.95ac		e8		inx		                inx
.95ad		e4 29		cpx $29		                cpx tmp3
.95af		d0 e1		bne $9592	                bne _outer_loop ; go back for eight more shifts?
.95b1		95 01		sta $01,x	                sta 1,x
.95b3		a5 25		lda $25		                lda tmp1
.95b5		95 00		sta $00,x	                sta 0,x
.95b7		80 04		bra $95bd	                bra _done
.95b9						_zero:
.95b9		74 02		stz $02,x	                stz 2,x
.95bb		74 03		stz $03,x	                stz 3,x
.95bd						_done:
.95bd		60		rts		z_um_star:      rts
.95be						xt_unloop:
.95be						w_unloop:
.95be		a4 1f		ldy $1f		                ldy loopctrl
.95c0		88		dey		                dey
.95c1		88		dey		                dey
.95c2		88		dey		                dey
.95c3		88		dey		                dey
.95c4		84 1f		sty $1f		                sty loopctrl
.95c6		30 05		bmi $95cd	                bmi z_unloop            ; no active loops?
.95c8		b9 00 01	lda $0100,y	                lda loopindex,y         ; else re-cache the LSB of loopindex
.95cb		85 20		sta $20		                sta loopidx0
.95cd		60		rts		z_unloop:       rts
.95ce						xt_until:
.95ce		20 d4 d7	jsr $d7d4	                jsr underflow_1
.95d1						w_until:
.95d1		20 ec 97	jsr $97ec	                jsr cmpl_0branch_tos
.95d4		60		rts		z_until:        rts
.95d5						xt_unused:
.95d5						w_unused:
.95d5		ca		dex		                dex
.95d6		ca		dex		                dex
.95d7		a9 00		lda #$00	                lda #<cp_end
.95d9		38		sec		                sec
.95da		e5 00		sbc $00		                sbc cp
.95dc		95 00		sta $00,x	                sta 0,x
.95de		a9 7c		lda #$7c	                lda #>cp_end
.95e0		e5 01		sbc $01		                sbc cp+1
.95e2		95 01		sta $01,x	                sta 1,x
.95e4		60		rts		z_unused:       rts
.95e5						xt_variable:
.95e5						w_variable:
.95e5		20 f2 83	jsr $83f2	                jsr w_create
.95e8		a9 00		lda #$00	                lda #0
.95ea		20 bc 97	jsr $97bc	                jsr cmpl_a
.95ed		20 bc 97	jsr $97bc	                jsr cmpl_a
.95f0		60		rts		z_variable:     rts
.95f1						xt_while:
.95f1		20 d4 d7	jsr $d7d4	                jsr underflow_1
.95f4						w_while:
.95f4		20 d7 97	jsr $97d7	                jsr cmpl_0branch_later          ; branch to location we'll determine later
.95f7		20 1e 92	jsr $921e	                jsr w_swap
.95fa		60		rts		z_while:        rts
.95fb						xt_within:
.95fb		20 de d7	jsr $d7de	                jsr underflow_3
.95fe						w_within:
.95fe		20 db 8c	jsr $8cdb	                jsr w_over
.9601		20 bb 8b	jsr $8bbb	                jsr w_minus
.9604		20 59 93	jsr $9359	                jsr w_to_r
.9607		20 bb 8b	jsr $8bbb	                jsr w_minus
.960a		20 b5 8e	jsr $8eb5	                jsr w_r_from
.960d		20 23 95	jsr $9523	                jsr w_u_less_than
.9610		60		rts		z_within:       rts
.9611						xt_word:
.9611		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9614						w_word:
.9614		a4 10		ldy $10		                ldy toin                ; >IN
.9616						_loop:
.9616		c4 0e		cpy $0e		                cpy ciblen              ; quit if end of input
.9618		f0 09		beq $9623	                beq _found_char
.961a		b1 0c		lda ($0c),y	                lda (cib),y
.961c		d5 00		cmp $00,x	                cmp 0,x                 ; ASCII of delimiter
.961e		d0 03		bne $9623	                bne _found_char
.9620		c8		iny		                iny
.9621		80 f3		bra $9616	                bra _loop
.9623						_found_char:
.9623		84 10		sty $10		                sty toin
.9625		20 82 8d	jsr $8d82	                jsr w_parse            ; Returns ( addr u )
.9628		b5 00		lda $00,x	                lda 0,x
.962a		92 00		sta ($00)	                sta (cp)                ; Save length of string
.962c		48		pha		                pha                     ; Keep copy of length for later
.962d		20 5c 86	jsr $865c	                jsr w_dup              ; ( addr u u )
.9630		a5 00		lda $00		                lda cp
.9632		18		clc		                clc
.9633		69 01		adc #$01	                adc #1
.9635		95 02		sta $02,x	                sta 2,x                 ; LSB of CP
.9637		a5 01		lda $01		                lda cp+1
.9639		69 00		adc #$00	                adc #0
.963b		95 03		sta $03,x	                sta 3,x                 ; ( addr cp+1 u )
.963d		20 d7 8b	jsr $8bd7	                jsr w_move
.9640		ca		dex		                dex
.9641		ca		dex		                dex
.9642		a5 00		lda $00		                lda cp
.9644		95 00		sta $00,x	                sta 0,x
.9646		a5 01		lda $01		                lda cp+1
.9648		95 01		sta $01,x	                sta 1,x
.964a		68		pla		                pla                     ; length of string
.964b		18		clc		                clc
.964c		65 00		adc $00		                adc cp
.964e		85 00		sta $00		                sta cp
.9650		90 02		bcc $9654	                bcc z_word
.9652		e6 01		inc $01		                inc cp+1
.9654		60		rts		z_word:         rts
.9655						xt_xor:
.9655		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9658						w_xor:
.9658		b5 00		lda $00,x	                lda 0,x
.965a		55 02		eor $02,x	                eor 2,x
.965c		95 02		sta $02,x	                sta 2,x
.965e		b5 01		lda $01,x	                lda 1,x
.9660		55 03		eor $03,x	                eor 3,x
.9662		95 03		sta $03,x	                sta 3,x
.9664		e8		inx		                inx
.9665		e8		inx		                inx
.9666		60		rts		z_xor:          rts
.9667						xt_zero_equal:
.9667		20 d4 d7	jsr $d7d4	                jsr underflow_1
.966a						w_zero_equal:
.966a		b5 00		lda $00,x	                lda 0,x
.966c		15 01		ora $01,x	                ora 1,x
.966e		f0 02		beq $9672	                beq _zero       ; if 0, A is inverse of the TRUE (-1) we want
.9670		a9 ff		lda #$ff	                lda #$FF        ; else set A inverse of the FALSE (0) we want
.9672						_zero:
.9672		49 ff		eor #$ff	                eor #$FF        ; now just invert:
.9674		95 00		sta $00,x	                sta 0,x
.9676		95 01		sta $01,x	                sta 1,x
.9678		60		rts		z_zero_equal:   rts
.9679						xt_zero_greater:
.9679		20 d4 d7	jsr $d7d4	                jsr underflow_1
.967c						w_zero_greater:
.967c		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS is negative)
.967e		b5 01		lda $01,x	                lda 1,x         ; MSB
.9680		30 05		bmi $9687	                bmi _done       ; TOS is negative, keep FLASE
.9682		15 00		ora $00,x	                ora 0,x
.9684		f0 01		beq $9687	                beq _done       ; TOS is zero, keep FALSE
.9686		88		dey		                dey             ; TOS is postive, make true
.9687						_done:
.9687		98		tya		                tya
.9688		95 00		sta $00,x	                sta 0,x
.968a		95 01		sta $01,x	                sta 1,x
.968c		60		rts		z_zero_greater: rts
.968d						xt_zero_less:
.968d		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9690						w_zero_less:
.9690		a0 00		ldy #$00	                ldy #0          ; Default is FALSE (TOS positive)
.9692		b5 01		lda $01,x	                lda 1,x         ; MSB
.9694		10 01		bpl $9697	                bpl _done       ; TOS is positive, so keep FALSE
.9696		88		dey		                dey             ; TOS is negative, make TRUE
.9697						_done:
.9697		98		tya		                tya
.9698		95 00		sta $00,x	                sta 0,x
.969a		95 01		sta $01,x	                sta 1,x
.969c		60		rts		z_zero_less:    rts
.969d						xt_zero_unequal:
.969d		20 d4 d7	jsr $d7d4	                jsr underflow_1
.96a0						w_zero_unequal:
.96a0		b5 00		lda $00,x	                lda 0,x
.96a2		15 01		ora $01,x	                ora 1,x
.96a4		f0 02		beq $96a8	                beq _zero
.96a6		a9 ff		lda #$ff	                lda #$FF
.96a8						_zero:
.96a8		95 00		sta $00,x	                sta 0,x
.96aa		95 01		sta $01,x	                sta 1,x
.96ac		60		rts		z_zero_unequal: rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/compile.asm

.96ad						compile_nt_comma:
.96ad		20 5c 86	jsr $865c	        jsr w_dup                       ; ( nt nt )
.96b0		20 a6 9c	jsr $9ca6	        jsr w_name_to_int               ; ( nt xt )
.96b3		20 5c 86	jsr $865c	        jsr w_dup                       ; ( nt xt xt )
.96b6		20 5c 8f	jsr $8f5c	        jsr w_rot                       ; ( xt xt nt )
.96b9		80 12		bra $96cd	        bra compile_comma_common
.96bb						xt_compile_comma:
.96bb		20 d4 d7	jsr $d7d4	                jsr underflow_1
.96be						w_compile_comma:
.96be		20 5c 86	jsr $865c	                jsr w_dup               ; keep an unadjusted copy of xt
.96c1		20 5c 86	jsr $865c	                jsr w_dup               ; plus one to convert to nt
.96c4		20 20 9c	jsr $9c20	                jsr w_int_to_name
.96c7		b5 00		lda $00,x	                lda 0,x
.96c9		15 01		ora $01,x	                ora 1,x
.96cb		f0 73		beq $9740	                beq cmpl_as_call        ; No nt so unknown size; must compile as a JSR
.96cd						compile_comma_common:
.96cd		20 5c 86	jsr $865c	                jsr w_dup
.96d0		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; status is at nt+1
.96d3		a1 00		lda ($00,x)	                lda (0,x)               ; get status byte
.96d5		e8		inx		                inx                     ; drop pointer
.96d6		e8		inx		                inx
.96d7		85 29		sta $29		                sta tmp3                ; keep copy of status byte
.96d9		29 0c		and #$0c	                and #AN+NN              ; check if never native (NN)
.96db		c9 08		cmp #$08	                cmp #NN                 ; NN=1, AN=0?  i.e. not ST=AN+AN
.96dd		f0 61		beq $9740	                beq cmpl_as_call
.96df		20 48 9e	jsr $9e48	                jsr w_wordsize
.96e2		a5 29		lda $29		                lda tmp3
.96e4		29 0c		and #$0c	                and #ST                 ; Check the Stack Thrash flag (ST=NN+AN)
.96e6		c9 0c		cmp #$0c	                cmp #ST
.96e8		d0 16		bne $9700	                bne _check_uf
=10						_strip_sz = 10  ; skip the standard 10 byte header which saves return address + 1 to tmp1
.96ea		18		clc		                clc
.96eb		b5 02		lda $02,x	                lda 2,x
.96ed		69 0a		adc #$0a	                adc #_strip_sz
.96ef		95 02		sta $02,x	                sta 2,x
.96f1		90 02		bcc $96f5	                bcc +
.96f3		f6 03		inc $03,x	                inc 3,x                 ; we just care about the carry
.96f5						+
.96f5		38		sec		                sec
.96f6		b5 00		lda $00,x	                lda 0,x
.96f8		e9 0a		sbc #$0a	                sbc #_strip_sz
.96fa		95 00		sta $00,x	                sta 0,x
.96fc		b0 02		bcs $9700	                bcs +
.96fe		d6 01		dec $01,x	                dec 1,x                 ; we just care about the borrow
.9700						+
.9700						_check_uf:
.9700		a0 02		ldy #$02	                ldy #uf_strip_offset
.9702		b1 08		lda ($08),y	                lda (up),y
.9704		c8		iny		                iny
.9705		11 08		ora ($08),y	                ora (up),y
.9707		f0 1e		beq $9727	                beq _check_limit
.9709		20 db 8c	jsr $8cdb	                jsr w_over
.970c		20 6f 97	jsr $976f	                jsr has_uf_check
.970f		90 16		bcc $9727	                bcc _check_limit        ; not an underflow check
.9711		18		clc		                clc
.9712		b5 02		lda $02,x	                lda 2,x
.9714		69 03		adc #$03	                adc #3
.9716		95 02		sta $02,x	                sta 2,x
.9718		90 02		bcc $971c	                bcc +
.971a		f6 03		inc $03,x	                inc 3,x                  ; we just care about the carry
.971c						+
.971c		38		sec		                sec
.971d		b5 00		lda $00,x	                lda 0,x
.971f		e9 03		sbc #$03	                sbc #3
.9721		95 00		sta $00,x	                sta 0,x
.9723		b0 02		bcs $9727	                bcs +
.9725		d6 01		dec $01,x	                dec 1,x                  ; we just care about the borrow
.9727						+
.9727						_check_limit:
.9727		a5 29		lda $29		                lda tmp3
.9729		29 0c		and #$0c	                and #AN+NN              ; check Always Native (AN) bit
.972b		c9 04		cmp #$04	                cmp #AN                 ; AN=1, NN=0?  (i.e. not ST=AN+NN)
.972d		f0 2c		beq $975b	                beq cmpl_inline         ; always natively compile
.972f						cmpl_by_limit:
.972f		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.9731		b5 01		lda $01,x	                lda 1,x                 ; MSB of word size
.9733		d1 08		cmp ($08),y	                cmp (up),y              ; user-defined limit MSB
.9735		90 24		bcc $975b	                bcc cmpl_inline         ; borrow (C=0) means size < limit
.9737		d0 07		bne $9740	                bne cmpl_as_call        ; else non-zero means size > limit
.9739		88		dey		                dey
.973a		b1 08		lda ($08),y	                lda (up),y              ; user-defined limit LSB
.973c		d5 00		cmp $00,x	                cmp 0,x
.973e		b0 1b		bcs $975b	                bcs cmpl_inline         ; not bigger, so good to go
.9740						cmpl_as_call:
.9740		a5 29		lda $29		                lda tmp3
.9742		29 0c		and #$0c	                and #ST
.9744		d0 08		bne $974e	                bne +
.9746		20 56 86	jsr $8656	                jsr w_drop              ; no stack juggling, use middle (xt or xt')
.9749		20 0a 8c	jsr $8c0a	                jsr w_nip
.974c		80 03		bra $9751	                bra _cmpl
.974e						+
.974e		20 97 93	jsr $9397	                jsr w_two_drop          ; stack juggling, must use first (xt)
.9751						_cmpl:
.9751		a9 20		lda #$20	                lda #OpJSR
.9753		20 bc 97	jsr $97bc	                jsr cmpl_a
.9756		20 ae 83	jsr $83ae	                jsr w_comma
.9759		38		sec		                sec
.975a		60		rts		                rts
.975b						cmpl_inline:
.975b		20 e7 88	jsr $88e7	                jsr w_here
.975e		20 1e 92	jsr $921e	                jsr w_swap
.9761		20 5c 86	jsr $865c	                jsr w_dup
.9764		20 2a 82	jsr $822a	                jsr w_allot            ; allocate space for the word
.9767		20 d7 8b	jsr $8bd7	                jsr w_move
.976a		20 56 86	jsr $8656	                jsr w_drop             ; drop original xt
.976d		18		clc		                clc
.976e						z_compile_comma:
.976e		60		rts		                rts
.976f						has_uf_check:
.976f		a1 00		lda ($00,x)	                lda (0, x)              ; fetch byte @ addr
.9771		c9 20		cmp #$20	                cmp #OpJSR
.9773		d0 18		bne $978d	                bne _not_uf             ; not a JSR
.9775		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.9778		20 e9 87	jsr $87e9	                jsr w_fetch             ; get JSR address to TOS
.977b		b5 00		lda $00,x	                lda 0, x                ; LSB of jsr address
.977d		38		sec		                sec
.977e		e9 d4		sbc #$d4	                sbc #<underflow_1
.9780		a8		tay		                tay                     ; stash LSB of result and finish subtraction
.9781		b5 01		lda $01,x	                lda 1, x                ; MSB of jsr address
.9783		e9 d7		sbc #$d7	                sbc #>underflow_1
.9785		d0 06		bne $978d	                bne _not_uf             ; MSB of result must be zero
.9787		c0 10		cpy #$10	                cpy #(underflow_4-underflow_1+1)
.9789		b0 02		bcs $978d	                bcs _not_uf             ; LSB is too big
.978b		38		sec		                sec                     ; C=1 means it is an UF check
>978c		24				                .byte OpBITzp           ; mask the clc, with no effect on carry
.978d		18		clc		_not_uf:        clc                     ; C=0 means it isn't a UF check
.978e		e8		inx		                inx                     ; clean up stack
.978f		e8		inx		                inx
.9790		60		rts		                rts
.9791						cmpl_jump_later:
.9791		ca		dex		                dex
.9792		ca		dex		                dex
.9793		a5 01		lda $01		                lda cp+1
.9795		95 01		sta $01,x	                sta 1,x
.9797		a5 00		lda $00		                lda cp
.9799		1a		inc a		                inc a
.979a		95 00		sta $00,x	                sta 0,x
.979c		d0 0a		bne $97a8	                bne cmpl_jump
.979e		f6 01		inc $01,x	                inc 1,x
.97a0		80 06		bra $97a8	                bra cmpl_jump
.97a2						cmpl_jump_tos:
.97a2		b5 00		lda $00,x	                lda 0,x         ; set up for cmpl_jump Y/A
.97a4		b4 01		ldy $01,x	                ldy 1,x
.97a6		e8		inx		                inx
.97a7		e8		inx		                inx
.97a8						cmpl_jump:
.97a8		48		pha		                pha             ; save LSB of address
.97a9		a9 10		lda #$10	                lda #%00010000  ; unset bit 4 to flag as never-native
.97ab		14 1c		trb $1c		                trb status
.97ad		a9 4c		lda #$4c	                lda #OpJMP      ; load opcode for JMP
.97af		80 03		bra $97b4	                bra +
.97b1						cmpl_subroutine:
.97b1		48		pha		                pha             ; save LSB of address
.97b2		a9 20		lda #$20	                lda #OpJSR      ; load opcode for JSR and fall through
.97b4						+
.97b4		20 bc 97	jsr $97bc	                jsr cmpl_a      ; compile opcode
.97b7		68		pla		                pla             ; retrieve address LSB; fall thru to cmpl_word
.97b8						cmpl_word:
.97b8		20 bc 97	jsr $97bc	                jsr cmpl_a      ; compile LSB of address
.97bb		98		tya		                tya             ; fall thru for MSB
.97bc						cmpl_a:
.97bc		92 00		sta ($00)	                sta (cp)
.97be		e6 00		inc $00		                inc cp
.97c0		d0 02		bne $97c4	                bne _done
.97c2		e6 01		inc $01		                inc cp+1
.97c4						_done:
.97c4		60		rts		                rts
.97c5						check_nc_limit:
.97c5		48		pha		                pha
.97c6		38		sec		                sec
.97c7		a0 01		ldy #$01	                ldy #nc_limit_offset+1
.97c9		b1 08		lda ($08),y	                lda (up),y              ; if MSB non zero we're good, leave with C=0
.97cb		f0 01		beq $97ce	                beq +
.97cd		18		clc		                clc
.97ce						+
.97ce		68		pla		                pla
.97cf		90 05		bcc $97d6	                bcc _done
.97d1		3a		dec a		                dea                     ; simplify test to A-1 < nc-limit
.97d2		88		dey		                dey
.97d3		d1 08		cmp ($08),y	                cmp (up),y              ; A-1 < LSB leaves C=0, else C=1
.97d5		1a		inc a		                ina                     ; restore A, preserves carry
.97d6						_done:
.97d6		60		rts		                rts
.97d7						cmpl_0branch_later:
.97d7		20 66 9e	jsr $9e66	                jsr w_zero             ; dummy placeholder, which forces long jmp in native version
.97da		20 ec 97	jsr $97ec	                jsr cmpl_0branch_tos    ; generate native or subroutine branch code
.97dd		20 e7 88	jsr $88e7	                jsr w_here             ; either way the target address is two bytes before here
.97e0		38		sec		                sec
.97e1		b5 00		lda $00,x	                lda 0,x
.97e3		e9 02		sbc #$02	                sbc #2
.97e5		95 00		sta $00,x	                sta 0,x
.97e7		b0 02		bcs $97eb	                bcs +
.97e9		d6 01		dec $01,x	                dec 1,x
.97eb						+
.97eb		60		rts		                rts
.97ec						cmpl_0branch_tos:
.97ec		a9 0b		lda #$0b	                lda #ztest_runtime_size+5       ; typical size of inline form
.97ee		20 c5 97	jsr $97c5	                jsr check_nc_limit              ; returns C=0 if we should native compile
.97f1		90 0a		bcc $97fd	                bcc _inline
.97f3		a0 98		ldy #$98	                ldy #>zero_branch_runtime
.97f5		a9 4e		lda #$4e	                lda #<zero_branch_runtime
.97f7		20 b1 97	jsr $97b1	                jsr cmpl_subroutine             ; call the 0branch runtime
.97fa		4c ae 83	jmp $83ae	                jmp w_comma                    ; add the payload and return
.97fd						_inline:
.97fd		a0 00		ldy #$00	                ldy #0
.97ff						-
.97ff		b9 4e 98	lda $984e,y	                lda ztest_runtime,y
.9802		20 bc 97	jsr $97bc	                jsr cmpl_a
.9805		c8		iny		                iny
.9806		c0 06		cpy #$06	                cpy #ztest_runtime_size
.9808		d0 f5		bne $97ff	                bne -
.980a		b5 00		lda $00,x	                lda 0,x
.980c		15 01		ora $01,x	                ora 1,x
.980e		f0 31		beq $9841	                beq _long               ; always use the long form if target is 0
.9810		20 5c 86	jsr $865c	                jsr w_dup
.9813		20 e7 88	jsr $88e7	                jsr w_here
.9816		18		clc		                clc
.9817		a9 02		lda #$02	                lda #2
.9819		75 00		adc $00,x	                adc 0,x
.981b		95 00		sta $00,x	                sta 0,x
.981d		90 02		bcc $9821	                bcc +
.981f		f6 01		inc $01,x	                inc 1,x
.9821						+
.9821		20 bb 8b	jsr $8bbb	                jsr w_minus
.9824		e8		inx		                inx             ; pre-drop offset and use wraparound indexing to preserve flags
.9825		e8		inx		                inx
.9826		b5 ff		lda $ff,x	                lda $ff,x
.9828		a8		tay		                tay             ; Y=MSB of offset
.9829		b5 fe		lda $fe,x	                lda $fe,x       ; A=LSB, setting N flag to bit 7
.982b		30 04		bmi $9831	                bmi _minus
.982d		c0 00		cpy #$00	                cpy #0          ; if LSB is positive we need MSB = 0
.982f		80 02		bra $9833	                bra +
.9831		c0 ff		cpy #$ff	_minus:         cpy #$ff        ; if LSB is negative we need MSB = ff
.9833		d0 0c		bne $9841	+               bne _long
.9835		a9 f0		lda #$f0	                lda #OpBEQ
.9837		20 bc 97	jsr $97bc	                jsr cmpl_a
.983a		b5 fe		lda $fe,x	                lda $fe,x
.983c		e8		inx		                inx             ; drop the original address we used to calc offset
.983d		e8		inx		                inx
.983e		4c bc 97	jmp $97bc	                jmp cmpl_a
.9841						_long:
.9841		a9 d0		lda #$d0	                lda #OpBNE
.9843		20 bc 97	jsr $97bc	                jsr cmpl_a
.9846		a9 03		lda #$03	                lda #3
.9848		20 bc 97	jsr $97bc	                jsr cmpl_a
.984b		4c a2 97	jmp $97a2	                jmp cmpl_jump_tos
.984e						zero_branch_runtime:
.984e						ztest_runtime:
.984e		e8		inx		                inx
.984f		e8		inx		                inx
.9850		b5 fe		lda $fe,x	                lda $FE,x           ; wraparound so inx doesn't wreck Z status
.9852		15 ff		ora $ff,x	                ora $FF,x
=6						ztest_runtime_size = * - ztest_runtime
.9854						zbranch_runtime:
.9854		7a		ply		                ply
.9855		84 25		sty $25		                sty tmp1
.9857		7a		ply		                ply
.9858		84 26		sty $26		                sty tmp1+1
.985a		a8		tay		                tay             ; test if A = 0 which tells us whether to branch
.985b		f0 0d		beq $986a	                beq _branch
.985d		18		clc		                clc
.985e		a5 25		lda $25		                lda tmp1        ; LSB
.9860		69 03		adc #$03	                adc #3          ; skip two bytes plus the extra for jsr/rts behavior
.9862		85 25		sta $25		                sta tmp1
.9864		90 11		bcc $9877	                bcc _jmp
.9866		e6 26		inc $26		                inc tmp1+1
.9868		80 0d		bra $9877	                bra _jmp
.986a						_branch:
.986a		a0 01		ldy #$01	                ldy #1
.986c		b1 25		lda ($25),y	                lda (tmp1),y
.986e		48		pha		                pha                     ; stash the LSB until we've read the MSB too
.986f		c8		iny		                iny
.9870		b1 25		lda ($25),y	                lda (tmp1),y
.9872		85 26		sta $26		                sta tmp1+1              ; update tmp1 with our branch target
.9874		68		pla		                pla
.9875		85 25		sta $25		                sta tmp1
.9877						_jmp:
.9877		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tools.asm

.987a						xt_bye:
.987a						w_bye:
.987a		4c 21 f0	jmp $f021	                jmp kernel_bye
.987d						z_bye:
.987d						xt_dot_s:
.987d						w_dot_s:
.987d		20 0b 85	jsr $850b	                jsr w_depth    ; ( -- u )
.9880		a9 3c		lda #$3c	                lda #'<'
.9882		20 86 86	jsr $8686	                jsr emit_a
.9885		b5 00		lda $00,x	                lda 0,x
.9887		48		pha		                pha
.9888		ca		dex		                dex             ; DUP
.9889		ca		dex		                dex
.988a		95 00		sta $00,x	                sta 0,x
.988c		74 01		stz $01,x	                stz 1,x
.988e		20 40 d8	jsr $d840	                jsr print_u
.9891		a9 3e		lda #$3e	                lda #'>'
.9893		20 86 86	jsr $8686	                jsr emit_a
.9896		a9 20		lda #$20	                lda #AscSP      ; ASCII for SPACE
.9898		20 86 86	jsr $8686	                jsr emit_a
.989b		e8		inx		                inx
.989c		e8		inx		                inx
.989d		e0 78		cpx #$78	                cpx #dsp0
.989f		f0 1e		beq $98bf	                beq _done
.98a1		7a		ply		                ply
.98a2		a9 77		lda #$77	                lda #dsp0-1     ; go up one to avoid garbage
.98a4		85 29		sta $29		                sta tmp3
.98a6		64 2a		stz $2a		                stz tmp3+1      ; must be zero page on the 65c02
.98a8						_loop:
.98a8		ca		dex		                dex
.98a9		ca		dex		                dex
.98aa		b2 29		lda ($29)	                lda (tmp3)
.98ac		95 01		sta $01,x	                sta 1,x
.98ae		c6 29		dec $29		                dec tmp3
.98b0		b2 29		lda ($29)	                lda (tmp3)
.98b2		95 00		sta $00,x	                sta 0,x
.98b4		c6 29		dec $29		                dec tmp3
.98b6		5a		phy		                phy
.98b7		20 ec 85	jsr $85ec	                jsr w_dot
.98ba		7a		ply		                ply
.98bb		88		dey		                dey
.98bc		d0 ea		bne $98a8	                bne _loop
.98be		48		pha		                pha             ; dummy to balance stack
.98bf						_done:
.98bf		68		pla		                pla
.98c0		60		rts		z_dot_s:        rts
.98c1						xt_dump:
.98c1		20 d9 d7	jsr $d7d9	                jsr underflow_2
.98c4						w_dump:
.98c4						_row:
.98c4		b5 03		lda $03,x	                lda 3,x
.98c6		85 28		sta $28		                sta tmp2+1
.98c8		b5 02		lda $02,x	                lda 2,x
.98ca		85 27		sta $27		                sta tmp2
.98cc		20 ec 83	jsr $83ec	                jsr w_cr
.98cf		a0 10		ldy #$10	                ldy #16                 ; max 16
.98d1		b5 01		lda $01,x	                lda 1,x                 ; if u > 256 keep 16
.98d3		d0 09		bne $98de	                bne +
.98d5		b5 00		lda $00,x	                lda 0,x                 ; if u = 0 we're done
.98d7		f0 61		beq $993a	                beq _done
.98d9		c9 10		cmp #$10	                cmp #16                 ; if u < 16 do what's left
.98db		b0 01		bcs $98de	                bcs +
.98dd		a8		tay		                tay
.98de						+
.98de		84 25		sty $25		                sty tmp1                ; temporary storage for loop counter
.98e0		a9 40		lda #$40	                lda #$40                ; bit 6 set on first pass and bit 7 on second
.98e2		85 26		sta $26		                sta tmp1+1              ; so we can use bit tmp1+1 to check N flag
.98e4		a0 01		ldy #$01	                ldy #1
.98e6						-
.98e6		b9 27 00	lda $0027,y	                lda tmp2,y
.98e9		20 a1 d6	jsr $d6a1	                jsr byte_to_ascii
.98ec		88		dey		                dey
.98ed		10 f7		bpl $98e6	                bpl -
.98ef		20 b5 91	jsr $91b5	                jsr w_space
.98f2						_pass:
.98f2		a0 00		ldy #$00	                ldy #0
.98f4						_bytes:
.98f4		98		tya		                tya
.98f5		29 07		and #$07	                and #7
.98f7		d0 03		bne $98fc	                bne +
.98f9		20 b5 91	jsr $91b5	                jsr w_space             ; extra space before bytes 0 and 8
.98fc						+
.98fc		b1 27		lda ($27),y	                lda (tmp2),y
.98fe		24 26		bit $26		                bit tmp1+1              ; which pass are we on?
.9900		30 08		bmi $990a	                bmi _ascii              ; bit 7 set on second pass
.9902		20 a1 d6	jsr $d6a1	                jsr byte_to_ascii       ; show byte value
.9905		20 b5 91	jsr $91b5	                jsr w_space
.9908		80 0a		bra $9914	                bra _nextbyte
.990a						_ascii:
.990a		20 bb d7	jsr $d7bb	                jsr is_printable        ; show ascii char
.990d		b0 02		bcs $9911	                bcs +
.990f		a9 2e		lda #$2e	                lda #'.'                ; use dot if not printable
.9911						+
.9911		20 86 86	jsr $8686	                jsr emit_a
.9914						_nextbyte:
.9914		c8		iny		                iny
.9915		c4 25		cpy $25		                cpy tmp1
.9917		d0 db		bne $98f4	                bne _bytes
.9919		06 26		asl $26		                asl tmp1+1              ; $40 -> $80 -> 0
.991b		f0 13		beq $9930	                beq +                   ; done both passes?
.991d		88		dey		                dey                     ; Y-1 is 0...15
.991e		98		tya		                tya
.991f		49 0f		eor #$0f	                eor #$f                 ; 15-(Y-1) is 16-Y
.9921		85 1e		sta $1e		                sta tmpdsp
.9923		0a		asl a		                asl a                   ; A is 2*(16-Y)
.9924		c9 10		cmp #$10	                cmp #16
.9926		65 1e		adc $1e		                adc tmpdsp              ; 3*(16-Y) + 1 if Y<9
.9928		20 74 a4	jsr $a474	                jsr push_a_tos
.992b		20 be 91	jsr $91be	                jsr w_spaces
.992e		80 c2		bra $98f2	                bra _pass
.9930						+
.9930		a5 25		lda $25		                lda tmp1
.9932		20 74 a4	jsr $a474	                jsr push_a_tos
.9935		20 0f a2	jsr $a20f	                jsr w_slash_string      ; ( addr n k -- addr+k n-k )
.9938		80 8a		bra $98c4	                bra _row                ; new row
.993a						_done:
.993a		e8		inx		                inx
.993b		e8		inx		                inx
.993c		e8		inx		                inx
.993d		e8		inx		                inx
.993e		60		rts		z_dump:         rts
.993f						xt_question:
.993f						w_question:
.993f		20 e9 87	jsr $87e9	                jsr w_fetch
.9942		20 ec 85	jsr $85ec	                jsr w_dot
.9945		60		rts		z_question:     rts
.9946						xt_see:
.9946						w_see:
.9946		20 24 8d	jsr $8d24	                jsr w_parse_name       ; ( addr u )
.9949		20 5d 9b	jsr $9b5d	                jsr w_find_name        ; ( nt | 0 )
.994c		b5 00		lda $00,x	                lda 0,x
.994e		15 01		ora $01,x	                ora 1,x
.9950		d0 05		bne $9957	                bne +
.9952		a9 05		lda #$05	                lda #err_noname
.9954		4c ea d7	jmp $d7ea	                jmp error
.9957						+
.9957		20 ec 83	jsr $83ec	                jsr w_cr
.995a		a5 18		lda $18		                lda base
.995c		48		pha		                pha
.995d		20 f2 88	jsr $88f2	                jsr w_hex
.9960		a9 08		lda #$08	                lda #str_see_nt
.9962		20 10 d8	jsr $d810	                jsr print_string_no_lf
.9965		20 5c 86	jsr $865c	                jsr w_dup              ; ( nt nt )
.9968		20 df 94	jsr $94df	                jsr w_u_dot
.996b		20 b5 91	jsr $91b5	                jsr w_space            ; ( nt )
.996e		20 5c 86	jsr $865c	                jsr w_dup              ; ( nt nt )
.9971		20 a6 9c	jsr $9ca6	                jsr w_name_to_int      ; ( nt xt )
.9974		a9 09		lda #$09	                lda #str_see_xt
.9976		20 10 d8	jsr $d810	                jsr print_string_no_lf
.9979		20 5c 86	jsr $865c	                jsr w_dup              ; ( nt xt xt )
.997c		20 df 94	jsr $94df	                jsr w_u_dot
.997f		20 ec 83	jsr $83ec	                jsr w_cr               ; ( nt xt )
.9982		20 db 8c	jsr $8cdb	                jsr w_over              ; ( nt xt nt )
.9985		20 bf 8c	jsr $8cbf	                jsr w_one_plus          ; ( nt xt nt+1 )
.9988		a1 00		lda ($00,x)	                lda (0,x)
.998a		95 00		sta $00,x	                sta 0,x                 ; stash status flag byte
.998c		74 01		stz $01,x	                stz 1,x                 ; placeholder for synthetic flags
.998e		48		pha		                pha                     ; save a copy of flags for later
.998f		29 0c		and #$0c	                and #ST                 ; calculate ST flag
.9991		c9 0c		cmp #$0c	                cmp #ST
.9993		f0 01		beq $9996	                beq +                   ; C=1 when ST set
.9995		18		clc		                clc
.9996						+
.9996		36 01		rol $01,x	                rol 1,x                 ; add to flag byte
.9998		20 db 8c	jsr $8cdb	                jsr w_over
.999b		20 6f 97	jsr $976f	                jsr has_uf_check        ; C=1 when UF set
.999e		36 01		rol $01,x	                rol 1,x                 ; add to flag byte
.99a0		a9 05		lda #$05	                lda #N_FLAGS            ; count off status byte flags
.99a2		85 23		sta $23		                sta tmptos
.99a4		a9 be		lda #$be	                lda #<see_flags_template
.99a6		85 29		sta $29		                sta tmp3                ; LSB
.99a8		a9 d3		lda #$d3	                lda #>see_flags_template
.99aa		85 2a		sta $2a		                sta tmp3+1              ; MSB
.99ac		a0 00		ldy #$00	                ldy #0                  ; index the string
.99ae						_loop:
.99ae		b1 29		lda ($29),y	                lda (tmp3),y            ; next char in template
.99b0		10 04		bpl $99b6	                bpl +                   ; end of string?
.99b2		a0 ff		ldy #$ff	                ldy #$ff                ; flag end of loop
.99b4		29 7f		and #$7f	                and #$7f                ; clear high bit of A to get last character
.99b6						+
.99b6		d0 16		bne $99ce	                bne _emit               ; flag placeholder?
.99b8		20 b5 91	jsr $91b5	                jsr w_space             ; no stack effect
.99bb		c6 23		dec $23		                dec tmptos
.99bd		30 04		bmi $99c3	                bmi _synthetic          ; more core status flags?
.99bf		56 00		lsr $00,x	                lsr 0,x                 ; shift next flag bit into carry
.99c1		80 02		bra $99c5	                bra +
.99c3						_synthetic:
.99c3		56 01		lsr $01,x	                lsr 1,x                 ; show synthetic flags after core ones
.99c5						+
.99c5		a9 30		lda #$30	                lda #'0'                ; convert C=0/1 into '0' or '1'
.99c7		69 00		adc #$00	                adc #0
.99c9		20 86 86	jsr $8686	                jsr emit_a              ; write the flag digit
.99cc		a9 20		lda #$20	                lda #' '                ; fall through and add trailing space
.99ce						_emit:
.99ce		20 86 86	jsr $8686	                jsr emit_a
.99d1		c8		iny		                iny
.99d2		d0 da		bne $99ae	                bne _loop
.99d4		20 ec 83	jsr $83ec	                jsr w_cr
.99d7		e8		inx		                inx
.99d8		e8		inx		                inx                     ; ( nt xt )
.99d9		a9 0a		lda #$0a	                lda #str_see_size
.99db		20 10 d8	jsr $d810	                jsr print_string_no_lf
.99de		20 1e 92	jsr $921e	                jsr w_swap              ; ( xt nt )
.99e1		20 48 9e	jsr $9e48	                jsr w_wordsize          ; ( xt u )
.99e4		20 5c 86	jsr $865c	                jsr w_dup               ; ( xt u u )
.99e7		20 d8 84	jsr $84d8	                jsr w_decimal
.99ea		68		pla		                pla                     ; fetch flag byte we saved earlier
.99eb		29 10		and #$10	                and #HC                 ; does it have CFA?
.99ed		48		pha		                pha                     ; we'll need to check once more
.99ee		f0 0c		beq $99fc	                beq +
.99f0		a9 0b		lda #$0b	                lda #str_see_cfapfa
.99f2		20 10 d8	jsr $d810	                jsr print_string_no_lf  ; print "CFA: 3  PFA: "
.99f5		38		sec		                sec
.99f6		b5 00		lda $00,x	                lda 0,x                 ; reduce to u-3
.99f8		e9 03		sbc #$03	                sbc #3
.99fa		95 00		sta $00,x	                sta 0,x                 ; assume u < 256
.99fc						+
.99fc		20 df 94	jsr $94df	                jsr w_u_dot             ; print u (or u-3 for PFA)
.99ff		20 ec 83	jsr $83ec	                jsr w_cr
.9a02		20 9f 93	jsr $939f	                jsr w_two_dup           ; ( xt u xt u )
.9a05		20 f2 88	jsr $88f2	                jsr w_hex
.9a08		20 c4 98	jsr $98c4	                jsr w_dump
.9a0b		68		pla		                pla                     ; recover HC flag
.9a0c		f0 06		beq $9a14	                beq +
.9a0e		a9 03		lda #$03	                lda #3
.9a10		95 00		sta $00,x	                sta 0,x                 ; for CFA words, just show three bytes
.9a12		74 01		stz $01,x	                stz 1,x
.9a14						+
.9a14		20 7d a2	jsr $a27d	                jsr w_disasm
.9a17		68		pla		                pla
.9a18		85 18		sta $18		                sta base
.9a1a		60		rts		z_see:          rts
.9a1b						xt_words:
.9a1b						w_words:
.9a1b		20 ec 83	jsr $83ec	                jsr w_cr
.9a1e		a9 00		lda #$00	                lda #0
.9a20		48		pha		                pha
.9a21		ca		dex		                dex                     ; Make room on the stack for
.9a22		ca		dex		                dex                     ; a dictionary pointer.
.9a23		64 29		stz $29		                stz tmp3                ; Start at the beginning of
.9a25						_wordlist_loop:
.9a25		a0 22		ldy #$22	                ldy #num_order_offset   ; Check against byte variable #ORDER.
.9a27		a5 29		lda $29		                lda tmp3
.9a29		d1 08		cmp ($08),y	                cmp (up),y              ; See if we are done.
.9a2b		d0 02		bne $9a2f	                bne _have_wordlist
.9a2d		80 45		bra $9a74	                bra _words_done
.9a2f						_have_wordlist:
.9a2f		18		clc		                clc                     ; Index into byte array SEARCH-ORDER.
.9a30		69 23		adc #$23	                adc #search_order_offset
.9a32		a8		tay		                tay
.9a33		b1 08		lda ($08),y	                lda (up),y              ; Get the index into array WORDLISTS
.9a35		0a		asl a		                asl                     ; Turn offset into cells offset.
.9a36		18		clc		                clc
.9a37		69 0a		adc #$0a	                adc #wordlists_offset
.9a39		a8		tay		                tay
.9a3a		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9a3c		95 00		sta $00,x	                sta 0,x                 ; on the stack. ( nt )
.9a3e		c8		iny		                iny
.9a3f		b1 08		lda ($08),y	                lda (up),y
.9a41		95 01		sta $01,x	                sta 1,x
.9a43						_loop:
.9a43		20 5c 86	jsr $865c	                jsr w_dup              ; ( nt nt )
.9a46		20 c3 9c	jsr $9cc3	                jsr w_name_to_string   ; ( nt addr u )
.9a49		68		pla		                pla
.9a4a		18		clc		                clc
.9a4b		75 00		adc $00,x	                adc 0,x
.9a4d		1a		inc a		                ina                     ; don't forget the space between words
.9a4e		c9 4f		cmp #$4f	                cmp #MAX_LINE_LENGTH    ; usually 79
.9a50		90 06		bcc $9a58	                bcc +
.9a52		20 ec 83	jsr $83ec	                jsr w_cr
.9a55		b5 00		lda $00,x	                lda 0,x                 ; After going to next line, start
.9a57		1a		inc a		                ina                     ; with length of this word.
.9a58						+
.9a58		48		pha		                pha
.9a59		20 b4 94	jsr $94b4	                jsr w_type             ; ( nt )
.9a5c		a9 20		lda #$20	                lda #AscSP
.9a5e		20 86 86	jsr $8686	                jsr emit_a
.9a61		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+
.9a64		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+
.9a67		20 e9 87	jsr $87e9	                jsr w_fetch            ; @ ( nt+1 )
.9a6a		b5 00		lda $00,x	                lda 0,x
.9a6c		15 01		ora $01,x	                ora 1,x
.9a6e		d0 d3		bne $9a43	                bne _loop
.9a70		e6 29		inc $29		                inc tmp3
.9a72		80 b1		bra $9a25	                bra _wordlist_loop
.9a74						_words_done:
.9a74		68		pla		                pla                     ; dump counter
.9a75		e8		inx		                inx
.9a76		e8		inx		                inx
.9a77		60		rts		z_words:        rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/tali.asm

.9a78						xt_allow_native:
.9a78						w_allow_native:
.9a78		20 2d d7	jsr $d72d	                jsr current_to_dp
.9a7b		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9a7d		b1 02		lda ($02),y	                lda (dp),y
.9a7f		29 f3		and #$f3	                and #$FF-NN-AN  ; AN and NN flag is clear.
.9a81		91 02		sta ($02),y	                sta (dp),y
.9a83						z_allow_native:
.9a83		60		rts		                rts
.9a84						xt_always_native:
.9a84						w_always_native:
.9a84		20 2d d7	jsr $d72d	                jsr current_to_dp
.9a87		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9a89		b1 02		lda ($02),y	                lda (dp),y
.9a8b		09 04		ora #$04	                ora #AN         ; Make sure AN flag is set
.9a8d		29 f7		and #$f7	                and #$FF-NN     ; and NN flag is clear.
.9a8f		91 02		sta ($02),y	                sta (dp),y
.9a91						z_always_native:
.9a91		60		rts		                rts
.9a92						xt_bell:
.9a92						w_bell:
.9a92		a9 07		lda #$07	                lda #7          ; ASCII value for BELL (aka ctrl-G)
.9a94		20 86 86	jsr $8686	                jsr emit_a
.9a97		60		rts		z_bell:         rts
.9a98						xt_bounds:
.9a98		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9a9b						w_bounds:
.9a9b		18		clc		                clc
.9a9c		b5 00		lda $00,x	                lda 0,x                 ; LSB u
.9a9e		b4 02		ldy $02,x	                ldy 2,x                 ; LSB addr
.9aa0		75 02		adc $02,x	                adc 2,x
.9aa2		95 02		sta $02,x	                sta 2,x                 ; LSB addr+u
.9aa4		94 00		sty $00,x	                sty 0,x
.9aa6		b5 01		lda $01,x	                lda 1,x                 ; MSB u
.9aa8		b4 03		ldy $03,x	                ldy 3,x                 ; MSB addr
.9aaa		75 03		adc $03,x	                adc 3,x
.9aac		95 03		sta $03,x	                sta 3,x                 ; MSB addr+u
.9aae		94 01		sty $01,x	                sty 1,x
.9ab0		60		rts		z_bounds:       rts
.9ab1						xt_cleave:
.9ab1		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9ab4						w_cleave:
.9ab4		20 1a a1	jsr $a11a	                jsr w_minus_leading    ; -LEADING ( addr u )
.9ab7		20 07 9c	jsr $9c07	                jsr w_input_to_r       ; save old imput state
.9aba		b5 00		lda $00,x	                lda 0,x         ; u is new ciblen
.9abc		85 0e		sta $0e		                sta ciblen
.9abe		b5 01		lda $01,x	                lda 1,x
.9ac0		85 0f		sta $0f		                sta ciblen+1
.9ac2		b5 02		lda $02,x	                lda 2,x         ; addr is new cib
.9ac4		85 0c		sta $0c		                sta cib
.9ac6		b5 03		lda $03,x	                lda 3,x
.9ac8		85 0d		sta $0d		                sta cib+1
.9aca		64 10		stz $10		                stz toin        ; >IN pointer is zero
.9acc		64 11		stz $11		                stz toin+1
.9ace		20 24 8d	jsr $8d24	                jsr w_parse_name       ; ( addr u addr-s u-s )
.9ad1		b5 00		lda $00,x	                lda 0,x
.9ad3		15 01		ora $01,x	                ora 1,x
.9ad5		f0 23		beq $9afa	                beq _done
.9ad7		b5 04		lda $04,x	                lda 4,x         ; LSB of original u
.9ad9		38		sec		                sec
.9ada		f5 00		sbc $00,x	                sbc 0,x
.9adc		95 04		sta $04,x	                sta 4,x
.9ade		b5 05		lda $05,x	                lda 5,x         ; MSB of original u
.9ae0		f5 01		sbc $01,x	                sbc 1,x
.9ae2		95 05		sta $05,x	                sta 5,x
.9ae4		b5 06		lda $06,x	                lda 6,x         ; LSB of original addr
.9ae6		18		clc		                clc
.9ae7		75 00		adc $00,x	                adc 0,x
.9ae9		95 06		sta $06,x	                sta 6,x
.9aeb		b5 07		lda $07,x	                lda 7,x         ; MSB of original addr
.9aed		75 01		adc $01,x	                adc 1,x
.9aef		95 07		sta $07,x	                sta 7,x
.9af1		20 70 94	jsr $9470	                jsr w_two_swap         ; ( addr-s u-s addr u )
.9af4		20 1a a1	jsr $a11a	                jsr w_minus_leading
.9af7		20 70 94	jsr $9470	                jsr w_two_swap         ; ( addr u addr-s u-s )
.9afa						_done:
.9afa		20 14 9e	jsr $9e14	                jsr w_r_to_input
.9afd		60		rts		z_cleave:       rts
.9afe						xt_digit_question:
.9afe		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9b01						w_digit_question:
.9b01		ca		dex		                dex
.9b02		ca		dex		                dex
.9b03		74 00		stz $00,x	                stz 0,x                 ; default flag is failure
.9b05		74 01		stz $01,x	                stz 1,x
.9b07		74 03		stz $03,x	                stz 3,x                 ; paranoid
.9b09		b5 02		lda $02,x	                lda 2,x
.9b0b		c9 30		cmp #$30	                cmp #'0'
.9b0d		90 23		bcc $9b32	                bcc _done               ; failure flag already set
.9b0f		c9 3a		cmp #$3a	                cmp #'9'+1               ; this is actually ":"
.9b11		90 12		bcc $9b25	                bcc _checkbase
.9b13		c9 41		cmp #$41	                cmp #'A'
.9b15		90 1b		bcc $9b32	                bcc _done               ; failure flag is already set
.9b17		c9 61		cmp #$61	                cmp #'a'
.9b19		90 07		bcc $9b22	                bcc _case_done          ; not lower case, too low
.9b1b		c9 7b		cmp #$7b	                cmp #'z'+1
.9b1d		b0 03		bcs $9b22	                bcs _case_done          ; not lower case, too high
.9b1f		18		clc		                clc                     ; just right
.9b20		69 e0		adc #$e0	                adc #$E0                ; offset to upper case (wraps)
.9b22						_case_done:
.9b22		38		sec		                sec
.9b23		e9 07		sbc #$07	                sbc #7                  ; fall through to _checkbase
.9b25						_checkbase:
.9b25		38		sec		                sec
.9b26		e9 30		sbc #$30	                sbc #'0'                 ; this is also the conversion step
.9b28		c5 18		cmp $18		                cmp base
.9b2a		b0 06		bcs $9b32	                bcs _done               ; already have false flag
.9b2c		95 02		sta $02,x	                sta 2,x                 ; put number in NOS
.9b2e		d6 00		dec $00,x	                dec 0,x                 ; set success flag
.9b30		d6 01		dec $01,x	                dec 1,x
.9b32						_done:
.9b32						z_digit_question:
.9b32		60		rts		                rts
.9b33						xt_execute_parsing:
.9b33		20 de d7	jsr $d7de	                jsr underflow_3
.9b36						w_execute_parsing:
.9b36		20 07 9c	jsr $9c07	                jsr w_input_to_r       ; save normal input for later
.9b39		20 ed 9c	jsr $9ced	                jsr w_not_rot          ; -ROT ( xt addr u )
.9b3c		b5 00		lda $00,x	                lda 0,x                 ; TOS is new ciblen
.9b3e		85 0e		sta $0e		                sta ciblen
.9b40		b5 01		lda $01,x	                lda 1,x
.9b42		85 0f		sta $0f		                sta ciblen+1
.9b44		b5 02		lda $02,x	                lda 2,x                 ; NOS is new cib
.9b46		85 0c		sta $0c		                sta cib
.9b48		b5 03		lda $03,x	                lda 3,x
.9b4a		85 0d		sta $0d		                sta cib+1
.9b4c		64 10		stz $10		                stz toin                ; Set >IN to zero
.9b4e		64 11		stz $11		                stz toin+1
.9b50		20 97 93	jsr $9397	                jsr w_two_drop         ; 2DROP ( xt )
.9b53		20 d4 87	jsr $87d4	                jsr w_execute
.9b56		20 14 9e	jsr $9e14	                jsr w_r_to_input
.9b59						z_execute_parsing:
.9b59		60		rts		                rts
.9b5a						xt_find_name:
.9b5a		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9b5d						w_find_name:
.9b5d		b5 00		lda $00,x	                lda 0,x
.9b5f		15 01		ora $01,x	                ora 1,x
.9b61		d0 03		bne $9b66	                bne _nonempty
.9b63		4c 97 9b	jmp $9b97	                jmp _fail_done
.9b66						_nonempty:
.9b66		64 29		stz $29		                stz tmp3                ; Start at the beginning
.9b68						_wordlist_loop:
.9b68		a0 22		ldy #$22	                ldy #num_order_offset   ; Compare to byte variable #ORDER
.9b6a		a5 29		lda $29		                lda tmp3
.9b6c		d1 08		cmp ($08),y	                cmp (up),y              ; Check to see if we are done
.9b6e		f0 27		beq $9b97	                beq _fail_done
.9b70		18		clc		                clc             ; SEARCH-ORDER is array of bytes.
.9b71		69 23		adc #$23	                adc #search_order_offset
.9b73		a8		tay		                tay
.9b74		b1 08		lda ($08),y	                lda (up),y      ; Get the id byte, which is the offset
.9b76		0a		asl a		                asl                     ; Turn offset into cells offset.
.9b77		18		clc		                clc
.9b78		69 0a		adc #$0a	                adc #wordlists_offset
.9b7a		a8		tay		                tay
.9b7b		b1 08		lda ($08),y	                lda (up),y
.9b7d		85 25		sta $25		                sta tmp1
.9b7f		c8		iny		                iny
.9b80		b1 08		lda ($08),y	                lda (up),y
.9b82		85 26		sta $26		                sta tmp1+1
.9b84		20 b8 d6	jsr $d6b8	                jsr find_header_name
.9b87		d0 04		bne $9b8d	                bne _success
.9b89		e6 29		inc $29		                inc tmp3
.9b8b		80 db		bra $9b68	                bra _wordlist_loop
.9b8d						_success:
.9b8d		a5 25		lda $25		                lda tmp1
.9b8f		95 02		sta $02,x	                sta 2,x
.9b91		a5 26		lda $26		                lda tmp1+1
.9b93		95 03		sta $03,x	                sta 3,x
.9b95		80 04		bra $9b9b	                bra _done
.9b97						_fail_done:
.9b97		74 02		stz $02,x	                stz 2,x         ; failure flag
.9b99		74 03		stz $03,x	                stz 3,x
.9b9b						_done:
.9b9b		e8		inx		                inx
.9b9c		e8		inx		                inx
.9b9d		60		rts		z_find_name:    rts
.9b9e						xt_havekey:
.9b9e						w_havekey:
.9b9e		ca		dex		                dex
.9b9f		ca		dex		                dex
.9ba0		a9 16		lda #$16	                lda #<havekey
.9ba2		95 00		sta $00,x	                sta 0,x
.9ba4		a9 00		lda #$00	                lda #>havekey
.9ba6		95 01		sta $01,x	                sta 1,x
.9ba8		60		rts		z_havekey:      rts
.9ba9						xt_hexstore:
.9ba9		20 de d7	jsr $d7de	                jsr underflow_3
.9bac						w_hexstore:
.9bac		20 5c 86	jsr $865c	                jsr w_dup              ; Save copy of original address
.9baf		20 91 94	jsr $9491	                jsr w_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
.9bb2						_loop:
.9bb2		b5 00		lda $00,x	                lda 0,x
.9bb4		15 01		ora $01,x	                ora 1,x
.9bb6		f0 36		beq $9bee	                beq _done
.9bb8		20 b4 9a	jsr $9ab4	                jsr w_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.9bbb		20 91 94	jsr $9491	                jsr w_two_to_r
.9bbe		20 66 9e	jsr $9e66	                jsr w_zero
.9bc1		20 66 9e	jsr $9e66	                jsr w_zero
.9bc4		20 17 94	jsr $9417	                jsr w_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.9bc7		20 bc 92	jsr $92bc	                jsr w_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.9bca		b5 00		lda $00,x	                lda 0,x
.9bcc		15 01		ora $01,x	                ora 1,x
.9bce		d0 17		bne $9be7	                bne _have_chars_left
.9bd0		20 97 93	jsr $9397	                jsr w_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
.9bd3		20 b2 9e	jsr $9eb2	                jsr w_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
.9bd6		20 9e 8e	jsr $8e9e	                jsr w_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.9bd9		20 3a 83	jsr $833a	                jsr w_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
.9bdc		20 b5 8e	jsr $8eb5	                jsr w_r_from           ; R>
.9bdf		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+
.9be2		20 59 93	jsr $9359	                jsr w_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.9be5		80 cb		bra $9bb2	                bra _loop
.9be7						_have_chars_left:
.9be7		8a		txa		                txa
.9be8		18		clc		                clc
.9be9		69 08		adc #$08	                adc #8
.9beb		aa		tax		                tax
.9bec		80 c4		bra $9bb2	                bra _loop
.9bee						_done:
.9bee		e8		inx		                inx
.9bef		e8		inx		                inx
.9bf0		e8		inx		                inx
.9bf1		e8		inx		                inx                     ; 2DROP
.9bf2		20 17 94	jsr $9417	                jsr w_two_r_from       ; ( addr2+n addr2 )
.9bf5		20 1e 92	jsr $921e	                jsr w_swap
.9bf8		20 bb 8b	jsr $8bbb	                jsr w_minus            ; ( n )
.9bfb		60		rts		z_hexstore:     rts
.9bfc						xt_input:
.9bfc						w_input:
.9bfc		ca		dex		                dex
.9bfd		ca		dex		                dex
.9bfe		a9 14		lda #$14	                lda #<input
.9c00		95 00		sta $00,x	                sta 0,x
.9c02		a9 00		lda #$00	                lda #>input
.9c04		95 01		sta $01,x	                sta 1,x
.9c06		60		rts		z_input:        rts
.9c07						xt_input_to_r:
.9c07						w_input_to_r:
.9c07		68		pla		                pla
.9c08		85 25		sta $25		                sta tmp1
.9c0a		68		pla		                pla
.9c0b		85 26		sta $26		                sta tmp1+1
.9c0d		a0 07		ldy #$07	                ldy #7
.9c0f						_loop:
.9c0f		b9 0a 00	lda $000a,y	                lda insrc,y     ; insrc+7 is toin+1
.9c12		48		pha		                pha
.9c13		88		dey		                dey
.9c14		10 f9		bpl $9c0f	                bpl _loop
.9c16		a5 26		lda $26		                lda tmp1+1
.9c18		48		pha		                pha
.9c19		a5 25		lda $25		                lda tmp1
.9c1b		48		pha		                pha
.9c1c		60		rts		z_input_to_r: 	rts
.9c1d						xt_int_to_name:
.9c1d		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9c20						w_int_to_name:
.9c20		ca		dex		                dex
.9c21		ca		dex		                dex
.9c22		74 00		stz $00,x	                stz 0,x
.9c24		74 01		stz $01,x	                stz 1,x
.9c26						_wordlist_loop:
.9c26		b5 00		lda $00,x	                lda 0,x                 ; Get the current wordlist.
.9c28		0a		asl a		                asl                     ; Turn offset into cells offset.
.9c29		18		clc		                clc
.9c2a		69 0a		adc #$0a	                adc #wordlists_offset
.9c2c		a8		tay		                tay
.9c2d		b1 08		lda ($08),y	                lda (up),y              ; Save the DP for this wordlist
.9c2f		85 27		sta $27		                sta tmp2                ; into tmp2
.9c31		c8		iny		                iny
.9c32		b1 08		lda ($08),y	                lda (up),y
.9c34		85 28		sta $28		                sta tmp2+1
.9c36		a5 27		lda $27		                lda tmp2
.9c38		05 28		ora $28		                ora tmp2+1
.9c3a		f0 36		beq $9c72	                beq _next_wordlist
.9c3c		b5 02		lda $02,x	                lda 2,x         ; Target xt is now behind wordlist id.
.9c3e		85 29		sta $29		                sta tmp3        ; Save target xt in tmp3
.9c40		b5 03		lda $03,x	                lda 3,x
.9c42		85 2a		sta $2a		                sta tmp3+1
.9c44						_loop:
.9c44		a0 04		ldy #$04	                ldy #4          ; xt is four bytes down
.9c46		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB of xt of current nt
.9c48		c5 29		cmp $29		                cmp tmp3
.9c4a		d0 07		bne $9c53	                bne _no_match
.9c4c		c8		iny		                iny
.9c4d		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB of xt of current nt
.9c4f		c5 2a		cmp $2a		                cmp tmp3+1
.9c51		f0 30		beq $9c83	                beq _match
.9c53						_no_match:
.9c53		18		clc		                clc
.9c54		a5 27		lda $27		                lda tmp2
.9c56		69 02		adc #$02	                adc #2
.9c58		85 27		sta $27		                sta tmp2
.9c5a		90 02		bcc $9c5e	                bcc +
.9c5c		e6 28		inc $28		                inc tmp2+1
.9c5e						+
.9c5e		a0 00		ldy #$00	                ldy #0
.9c60		b1 27		lda ($27),y	                lda (tmp2),y
.9c62		48		pha		                pha
.9c63		c8		iny		                iny
.9c64		11 27		ora ($27),y	                ora (tmp2),y
.9c66		f0 09		beq $9c71	                beq _zero
.9c68		b1 27		lda ($27),y	                lda (tmp2),y
.9c6a		85 28		sta $28		                sta tmp2+1
.9c6c		68		pla		                pla
.9c6d		85 27		sta $27		                sta tmp2
.9c6f		80 d3		bra $9c44	                bra _loop
.9c71						_zero:
.9c71		68		pla		                pla             ; Leftover from above loop
.9c72						_next_wordlist:
.9c72		b5 00		lda $00,x	                lda 0,x
.9c74		1a		inc a		                ina
.9c75		95 00		sta $00,x	                sta 0,x
.9c77		c9 0c		cmp #$0c	                cmp #max_wordlists
.9c79		d0 ab		bne $9c26	                bne _wordlist_loop
.9c7b		e8		inx		                inx
.9c7c		e8		inx		                inx
.9c7d		74 00		stz $00,x	                stz 0,x
.9c7f		74 01		stz $01,x	                stz 1,x
.9c81		80 0a		bra $9c8d	                bra z_int_to_name
.9c83						_match:
.9c83		e8		inx		                inx
.9c84		e8		inx		                inx
.9c85		a5 27		lda $27		                lda tmp2
.9c87		95 00		sta $00,x	                sta 0,x
.9c89		a5 28		lda $28		                lda tmp2+1
.9c8b		95 01		sta $01,x	                sta 1,x
.9c8d		60		rts		z_int_to_name:  rts
.9c8e						xt_latestnt:
.9c8e						w_latestnt:
.9c8e		ca		dex		                dex
.9c8f		ca		dex		                dex
.9c90		20 2d d7	jsr $d72d	                jsr current_to_dp
.9c93		a5 02		lda $02		                lda dp
.9c95		95 00		sta $00,x	                sta 0,x
.9c97		a5 03		lda $03		                lda dp+1
.9c99		95 01		sta $01,x	                sta 1,x
.9c9b		60		rts		z_latestnt:     rts
.9c9c						xt_latestxt:
.9c9c						w_latestxt:
.9c9c		20 8e 9c	jsr $9c8e	                jsr w_latestnt         ; ( nt )
.9c9f		20 a6 9c	jsr $9ca6	                jsr w_name_to_int      ; ( xt )
.9ca2		60		rts		z_latestxt:     rts
.9ca3						xt_name_to_int:
.9ca3		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9ca6						w_name_to_int:
.9ca6		b5 00		lda $00,x	                lda 0,x
.9ca8		18		clc		                clc
.9ca9		69 04		adc #$04	                adc #4
.9cab		85 29		sta $29		                sta tmp3
.9cad		b5 01		lda $01,x	                lda 1,x
.9caf		90 01		bcc $9cb2	                bcc _done
.9cb1		1a		inc a		                ina
.9cb2						_done:
.9cb2		85 2a		sta $2a		                sta tmp3+1
.9cb4		a0 00		ldy #$00	                ldy #0
.9cb6		b1 29		lda ($29),y	                lda (tmp3),y
.9cb8		95 00		sta $00,x	                sta 0,x
.9cba		c8		iny		                iny
.9cbb		b1 29		lda ($29),y	                lda (tmp3),y
.9cbd		95 01		sta $01,x	                sta 1,x
.9cbf		60		rts		z_name_to_int:  rts
.9cc0						xt_name_to_string:
.9cc0		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9cc3						w_name_to_string:
.9cc3		ca		dex		                dex
.9cc4		ca		dex		                dex
.9cc5		a1 02		lda ($02,x)	                lda (2,x)
.9cc7		95 00		sta $00,x	                sta 0,x
.9cc9		74 01		stz $01,x	                stz 1,x
.9ccb		b5 02		lda $02,x	                lda 2,x         ; LSB
.9ccd		18		clc		                clc
.9cce		69 08		adc #$08	                adc #8
.9cd0		95 02		sta $02,x	                sta 2,x
.9cd2		90 02		bcc $9cd6	                bcc z_name_to_string
.9cd4		f6 03		inc $03,x	                inc 3,x         ; MSB
.9cd6						z_name_to_string:
.9cd6		60		rts		                rts
.9cd7						xt_nc_limit:
.9cd7						w_nc_limit:
.9cd7		a9 00		lda #$00	                lda #nc_limit_offset
.9cd9		4c 92 d6	jmp $d692	                jmp push_upvar_tos
.9cdc						z_nc_limit:
.9cdc						xt_never_native:
.9cdc						w_never_native:
.9cdc		20 2d d7	jsr $d72d	                jsr current_to_dp
.9cdf		a0 01		ldy #$01	                ldy #1          ; offset for header flag byte
.9ce1		b1 02		lda ($02),y	                lda (dp),y
.9ce3		09 08		ora #$08	                ora #NN         ; Make sure NN flag is set
.9ce5		29 fb		and #$fb	                and #$FF-AN     ; and AN flag is clear.
.9ce7		91 02		sta ($02),y	                sta (dp),y
.9ce9						z_never_native:
.9ce9		60		rts		                rts
.9cea						xt_not_rot:
.9cea		20 de d7	jsr $d7de	                jsr underflow_3
.9ced						w_not_rot:
.9ced		b4 01		ldy $01,x	                ldy 1,x         ; MSB first
.9cef		b5 03		lda $03,x	                lda 3,x
.9cf1		95 01		sta $01,x	                sta 1,x
.9cf3		b5 05		lda $05,x	                lda 5,x
.9cf5		95 03		sta $03,x	                sta 3,x
.9cf7		94 05		sty $05,x	                sty 5,x
.9cf9		b4 00		ldy $00,x	                ldy 0,x         ; LSB second
.9cfb		b5 02		lda $02,x	                lda 2,x
.9cfd		95 00		sta $00,x	                sta 0,x
.9cff		b5 04		lda $04,x	                lda 4,x
.9d01		95 02		sta $02,x	                sta 2,x
.9d03		94 04		sty $04,x	                sty 4,x
.9d05		60		rts		z_not_rot:      rts
.9d06						xt_number:
.9d06		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9d09						w_number:
.9d09		64 1e		stz $1e		                stz tmpdsp      ; %n000 000d
.9d0b		a5 18		lda $18		                lda base
.9d0d		48		pha		                pha
.9d0e		20 9f 93	jsr $939f	                jsr w_two_dup
.9d11		a1 02		lda ($02,x)	                lda (2,x)
.9d13		c9 23		cmp #$23	                cmp #'#'                ; decimal?
.9d15		d0 04		bne $9d1b	                bne _check_hex
.9d17		a9 0a		lda #$0a	                lda #10
.9d19		80 42		bra $9d5d	                bra _base_changed
.9d1b						_check_hex:
.9d1b		c9 24		cmp #$24	                cmp #'$'
.9d1d		d0 04		bne $9d23	                bne _check_binary
.9d1f		a9 10		lda #$10	                lda #16
.9d21		80 3a		bra $9d5d	                bra _base_changed
.9d23						_check_binary:
.9d23		c9 25		cmp #$25	                cmp #'%'
.9d25		d0 04		bne $9d2b	                bne _check_char
.9d27		a9 02		lda #$02	                lda #2
.9d29		80 32		bra $9d5d	                bra _base_changed
.9d2b						_check_char:
.9d2b		c9 27		cmp #$27	                cmp #"'"
.9d2d		d0 3a		bne $9d69	                bne _check_minus
.9d2f		b5 00		lda $00,x	                lda 0,x         ; Get the length
.9d31		c9 03		cmp #$03	                cmp #3
.9d33		d0 26		bne $9d5b	                bne _not_a_char
.9d35		b5 01		lda $01,x	                lda 1,x
.9d37		d0 22		bne $9d5b	                bne _not_a_char ; No compare needed to check for non-zero.
.9d39		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d3b		18		clc		                clc
.9d3c		69 02		adc #$02	                adc #2          ; length of string
.9d3e		85 23		sta $23		                sta tmptos
.9d40		b5 03		lda $03,x	                lda 3,x
.9d42		69 00		adc #$00	                adc #0          ; only need carry
.9d44		85 24		sta $24		                sta tmptos+1
.9d46		b2 23		lda ($23)	                lda (tmptos)
.9d48		c9 27		cmp #$27	                cmp #"'"
.9d4a		d0 0f		bne $9d5b	                bne _not_a_char
.9d4c		f6 02		inc $02,x	                inc 2,x
.9d4e		d0 02		bne $9d52	                bne +
.9d50		f6 03		inc $03,x	                inc 3,x
.9d52						+
.9d52		a1 02		lda ($02,x)	                lda (2,x)
.9d54		95 02		sta $02,x	                sta 2,x
.9d56		74 03		stz $03,x	                stz 3,x
.9d58		4c db 9d	jmp $9ddb	                jmp _drop_original_string ; Single flag will drop the TOS for us.
.9d5b						_not_a_char:
.9d5b		80 5c		bra $9db9	                bra _number_error
.9d5d						_base_changed:
.9d5d		85 18		sta $18		                sta base        ; Switch to the new base
.9d5f		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d61		d0 02		bne $9d65	                bne +
.9d63		f6 03		inc $03,x	                inc 3,x
.9d65						+
.9d65		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d67		a1 02		lda ($02,x)	                lda (2,x)       ; Load the first char again
.9d69						_check_minus:
.9d69		c9 2d		cmp #$2d	                cmp #'-'
.9d6b		d0 0c		bne $9d79	                bne _check_dot
.9d6d		a9 80		lda #$80	                lda #$80
.9d6f		85 1e		sta $1e		                sta tmpdsp      ; set the sign bit
.9d71		f6 02		inc $02,x	                inc 2,x         ; start one character later
.9d73		d0 02		bne $9d77	                bne +
.9d75		f6 03		inc $03,x	                inc 3,x
.9d77						+
.9d77		d6 00		dec $00,x	                dec 0,x         ; decrease string length by one
.9d79						_check_dot:
.9d79		b5 02		lda $02,x	                lda 2,x         ; LSB of address
.9d7b		18		clc		                clc
.9d7c		75 00		adc $00,x	                adc 0,x         ; length of string
.9d7e		85 23		sta $23		                sta tmptos
.9d80		b5 03		lda $03,x	                lda 3,x
.9d82		69 00		adc #$00	                adc #0          ; only need carry
.9d84		85 24		sta $24		                sta tmptos+1
.9d86		a5 23		lda $23		                lda tmptos
.9d88		d0 02		bne $9d8c	                bne +
.9d8a		c6 24		dec $24		                dec tmptos+1
.9d8c						+
.9d8c		c6 23		dec $23		                dec tmptos
.9d8e		b2 23		lda ($23)	                lda (tmptos)
.9d90		c9 2e		cmp #$2e	                cmp #'.'
.9d92		d0 04		bne $9d98	                bne _main
.9d94		e6 1e		inc $1e		                inc tmpdsp
.9d96		d6 00		dec $00,x	                dec 0,x
.9d98						_main:
.9d98		ca		dex		                dex
.9d99		ca		dex		                dex
.9d9a		ca		dex		                dex
.9d9b		ca		dex		                dex
.9d9c		b5 04		lda $04,x	                lda 4,x         ; LSB of length
.9d9e		95 00		sta $00,x	                sta 0,x
.9da0		74 01		stz $01,x	                stz 1,x         ; MSB, max length 255 chars
.9da2		b5 06		lda $06,x	                lda 6,x         ; LSB of address
.9da4		95 02		sta $02,x	                sta 2,x
.9da6		b5 07		lda $07,x	                lda 7,x         ; MSB of address
.9da8		95 03		sta $03,x	                sta 3,x
.9daa		74 04		stz $04,x	                stz 4,x         ; clear space for ud
.9dac		74 05		stz $05,x	                stz 5,x
.9dae		74 06		stz $06,x	                stz 6,x
.9db0		74 07		stz $07,x	                stz 7,x
.9db2		20 bc 92	jsr $92bc	                jsr w_to_number        ; (ud addr u -- ud addr u )
.9db5		b5 00		lda $00,x	                lda 0,x
.9db7		f0 1e		beq $9dd7	                beq _all_converted
.9db9						_number_error:
.9db9		20 97 93	jsr $9397	                jsr w_two_drop ; >NUMBER modified addr u
.9dbc		20 97 93	jsr $9397	                jsr w_two_drop ; ud   (partially converted number)
.9dbf		a9 3e		lda #$3e	                lda #'>'
.9dc1		20 86 86	jsr $8686	                jsr emit_a
.9dc4		20 b4 94	jsr $94b4	                jsr w_type
.9dc7		a9 3c		lda #$3c	                lda #'<'
.9dc9		20 86 86	jsr $8686	                jsr emit_a
.9dcc		20 b5 91	jsr $91b5	                jsr w_space
.9dcf		68		pla		                pla
.9dd0		85 18		sta $18		                sta base
.9dd2		a9 08		lda #$08	                lda #err_syntax
.9dd4		4c ea d7	jmp $d7ea	                jmp error
.9dd7						_all_converted:
.9dd7		e8		inx		                inx ; Drop the current addr u
.9dd8		e8		inx		                inx
.9dd9		e8		inx		                inx
.9dda		e8		inx		                inx
.9ddb						_drop_original_string:
.9ddb		20 70 94	jsr $9470	                jsr w_two_swap  ; Drop the original addr u
.9dde		20 97 93	jsr $9397	                jsr w_two_drop  ; (was saved for unknown word error message)
.9de1		a5 1e		lda $1e		                lda tmpdsp      ; flag for double/minus
.9de3		a0 20		ldy #$20	                ldy #%00100000  ; status bit 5 for double(1) or single(0)
.9de5		0a		asl a		                asl             ; %n000 000d => %0000 00d0, C=n, Z=d
.9de6		f0 0a		beq $9df2	                beq _single
.9de8		98		tya		                tya
.9de9		04 1c		tsb $1c		                tsb status
.9deb		90 0f		bcc $9dfc	                bcc _done       ; no minus, all done
.9ded		20 d7 9e	jsr $9ed7	                jsr w_dnegate
.9df0		80 0a		bra $9dfc	                bra _done
.9df2						_single:
.9df2		e8		inx		                inx
.9df3		e8		inx		                inx
.9df4		98		tya		                tya
.9df5		14 1c		trb $1c		                trb status
.9df7		90 03		bcc $9dfc	                bcc _done       ; no minus, all done
.9df9		20 f9 8b	jsr $8bf9	                jsr w_negate
.9dfc						_done:
.9dfc		68		pla		                pla
.9dfd		85 18		sta $18		                sta base
.9dff		60		rts		z_number:       rts
.9e00						xt_editor_wordlist:
.9e00						xt_one:
.9e00						w_editor_wordlist:
.9e00						w_one:
.9e00		ca		dex		                dex
.9e01		ca		dex		                dex
.9e02		a9 01		lda #$01	                lda #1
.9e04		95 00		sta $00,x	                sta 0,x
.9e06		74 01		stz $01,x	                stz 1,x
.9e08						z_editor_wordlist:
.9e08						z_one:
.9e08		60		rts		                rts
.9e09						xt_output:
.9e09						w_output:
.9e09		ca		dex		                dex
.9e0a		ca		dex		                dex
.9e0b		a9 12		lda #$12	                lda #<output
.9e0d		95 00		sta $00,x	                sta 0,x
.9e0f		a9 00		lda #$00	                lda #>output
.9e11		95 01		sta $01,x	                sta 1,x
.9e13		60		rts		z_output:       rts
.9e14						xt_r_to_input:
.9e14						w_r_to_input:
.9e14		68		pla		                pla
.9e15		85 25		sta $25		                sta tmp1
.9e17		68		pla		                pla
.9e18		85 26		sta $26		                sta tmp1+1
.9e1a		a0 00		ldy #$00	                ldy #0
.9e1c						_loop:
.9e1c		68		pla		                pla
.9e1d		99 0a 00	sta $000a,y	                sta insrc,y
.9e20		c8		iny		                iny
.9e21		c0 08		cpy #$08	                cpy #8
.9e23		d0 f7		bne $9e1c	                bne _loop
.9e25		a5 26		lda $26		                lda tmp1+1
.9e27		48		pha		                pha
.9e28		a5 25		lda $25		                lda tmp1
.9e2a		48		pha		                pha
.9e2b		60		rts		z_r_to_input: 	rts
.9e2c						xt_strip_underflow:
.9e2c						w_strip_underflow:
.9e2c		a9 02		lda #$02	                lda #uf_strip_offset
.9e2e		4c 92 d6	jmp $d692	                jmp push_upvar_tos
.9e31						z_strip_underflow:
.9e31						xt_assembler_wordlist:
.9e31						xt_two:
.9e31						w_assembler_wordlist:
.9e31						w_two:
.9e31		ca		dex		                dex
.9e32		ca		dex		                dex
.9e33		a9 02		lda #$02	                lda #2
.9e35		95 00		sta $00,x	                sta 0,x
.9e37		74 01		stz $01,x	                stz 1,x
.9e39						z_assembler_wordlist:
.9e39		60		rts		z_two:          rts
.9e3a						xt_useraddr:
.9e3a						w_useraddr:
.9e3a		ca		dex		                dex
.9e3b		ca		dex		                dex
.9e3c		a9 08		lda #$08	                lda #<up
.9e3e		95 00		sta $00,x	                sta 0,x
.9e40		a9 00		lda #$00	                lda #>up
.9e42		95 01		sta $01,x	                sta 1,x
.9e44		60		rts		z_useraddr:     rts
.9e45						xt_wordsize:
.9e45		20 d4 d7	jsr $d7d4	                jsr underflow_1
.9e48						w_wordsize:
.9e48		b5 00		lda $00,x	                lda 0,x
.9e4a		85 25		sta $25		                sta tmp1
.9e4c		b5 01		lda $01,x	                lda 1,x
.9e4e		85 26		sta $26		                sta tmp1+1
.9e50		a0 06		ldy #$06	                ldy #6
.9e52		b1 25		lda ($25),y	                lda (tmp1),y    ; LSB of z
.9e54		88		dey		                dey
.9e55		88		dey		                dey
.9e56		38		sec		                sec
.9e57		f1 25		sbc ($25),y	                sbc (tmp1),y    ; LSB of xt
.9e59		95 00		sta $00,x	                sta 0,x
.9e5b		a0 07		ldy #$07	                ldy #7
.9e5d		b1 25		lda ($25),y	                lda (tmp1),y    ; MSB of z
.9e5f		88		dey		                dey
.9e60		88		dey		                dey
.9e61		f1 25		sbc ($25),y	                sbc (tmp1),y    ; MSB of xt
.9e63		95 01		sta $01,x	                sta 1,x
.9e65		60		rts		z_wordsize:     rts
.9e66						xt_case:
.9e66						xt_false:
.9e66						xt_forth_wordlist:
.9e66						xt_zero:
.9e66						w_case:
.9e66						w_false:
.9e66						w_forth_wordlist:
.9e66						w_zero:
.9e66		ca		dex		                dex             ; push
.9e67		ca		dex		                dex
.9e68		74 00		stz $00,x	                stz 0,x
.9e6a		74 01		stz $01,x	                stz 1,x
.9e6c						z_case:
.9e6c						z_false:
.9e6c						z_forth_wordlist:
.9e6c						z_zero:
.9e6c		60		rts		                rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/double.asm

.9e6d						xt_d_minus:
.9e6d		20 e3 d7	jsr $d7e3	                jsr underflow_4 ; two double numbers
.9e70						w_d_minus:
.9e70		38		sec		                sec
.9e71		b5 06		lda $06,x	                lda 6,x         ; LSB of lower word
.9e73		f5 02		sbc $02,x	                sbc 2,x
.9e75		95 06		sta $06,x	                sta 6,x
.9e77		b5 07		lda $07,x	                lda 7,x         ; MSB of lower word
.9e79		f5 03		sbc $03,x	                sbc 3,x
.9e7b		95 07		sta $07,x	                sta 7,x
.9e7d		b5 04		lda $04,x	                lda 4,x         ; LSB of upper word
.9e7f		f5 00		sbc $00,x	                sbc 0,x
.9e81		95 04		sta $04,x	                sta 4,x
.9e83		b5 05		lda $05,x	                lda 5,x         ; MSB of upper word
.9e85		f5 01		sbc $01,x	                sbc 1,x
.9e87		95 05		sta $05,x	                sta 5,x
.9e89		e8		inx		                inx
.9e8a		e8		inx		                inx
.9e8b		e8		inx		                inx
.9e8c		e8		inx		                inx
.9e8d		60		rts		z_d_minus:      rts
.9e8e						xt_d_plus:
.9e8e		20 e3 d7	jsr $d7e3	                jsr underflow_4 ; two double numbers
.9e91						w_d_plus:
.9e91		18		clc		                clc
.9e92		b5 02		lda $02,x	                lda 2,x         ; LSB of lower word
.9e94		75 06		adc $06,x	                adc 6,x
.9e96		95 06		sta $06,x	                sta 6,x
.9e98		b5 03		lda $03,x	                lda 3,x         ; MSB of lower word
.9e9a		75 07		adc $07,x	                adc 7,x
.9e9c		95 07		sta $07,x	                sta 7,x
.9e9e		b5 00		lda $00,x	                lda 0,x         ; LSB of upper word
.9ea0		75 04		adc $04,x	                adc 4,x
.9ea2		95 04		sta $04,x	                sta 4,x
.9ea4		b5 01		lda $01,x	                lda 1,x         ; MSB of upper word
.9ea6		75 05		adc $05,x	                adc 5,x
.9ea8		95 05		sta $05,x	                sta 5,x
.9eaa		e8		inx		                inx
.9eab		e8		inx		                inx
.9eac		e8		inx		                inx
.9ead		e8		inx		                inx
.9eae		60		rts		z_d_plus:       rts
.9eaf						xt_d_to_s:
.9eaf		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9eb2						w_d_to_s:
.9eb2		e8		inx		                inx
.9eb3		e8		inx		                inx
.9eb4		60		rts		z_d_to_s:       rts
.9eb5						xt_dabs:
.9eb5		20 d9 d7	jsr $d7d9	                jsr underflow_2 ; double number
.9eb8						w_dabs:
.9eb8		b5 01		lda $01,x	                lda 1,x         ; MSB of high cell
.9eba		10 17		bpl $9ed3	                bpl _done       ; positive, we get off light
.9ebc		a0 00		ldy #$00	                ldy #0
.9ebe		38		sec		                sec
.9ebf		98		tya		                tya
.9ec0		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9ec2		95 02		sta $02,x	                sta 2,x
.9ec4		98		tya		                tya
.9ec5		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9ec7		95 03		sta $03,x	                sta 3,x
.9ec9		98		tya		                tya
.9eca		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9ecc		95 00		sta $00,x	                sta 0,x
.9ece		98		tya		                tya
.9ecf		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9ed1		95 01		sta $01,x	                sta 1,x
.9ed3						_done:
.9ed3		60		rts		z_dabs:         rts
.9ed4						xt_dnegate:
.9ed4		20 d9 d7	jsr $d7d9	                jsr underflow_2 ; double number
.9ed7						w_dnegate:
.9ed7		a0 00		ldy #$00	     		ldy #0
.9ed9		38		sec		                sec
.9eda		98		tya		                tya
.9edb		f5 02		sbc $02,x	                sbc 2,x         ; LSB of low cell
.9edd		95 02		sta $02,x	                sta 2,x
.9edf		98		tya		                tya
.9ee0		f5 03		sbc $03,x	                sbc 3,x         ; MSB of low cell
.9ee2		95 03		sta $03,x	                sta 3,x
.9ee4		98		tya		                tya
.9ee5		f5 00		sbc $00,x	                sbc 0,x         ; LSB of high cell
.9ee7		95 00		sta $00,x	                sta 0,x
.9ee9		98		tya		                tya
.9eea		f5 01		sbc $01,x	                sbc 1,x         ; MSB of high cell
.9eec		95 01		sta $01,x	                sta 1,x
.9eee		60		rts		z_dnegate:      rts
.9eef						xt_d_dot:
.9eef		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9ef2						w_d_dot:
.9ef2		20 7d 93	jsr $937d	                jsr w_tuck
.9ef5		20 b8 9e	jsr $9eb8	                jsr w_dabs
.9ef8		20 ad 89	jsr $89ad	                jsr w_less_number_sign
.9efb		20 89 8c	jsr $8c89	                jsr w_number_sign_s
.9efe		20 5c 8f	jsr $8f5c	                jsr w_rot
.9f01		20 38 91	jsr $9138	                jsr w_sign
.9f04		20 67 8c	jsr $8c67	                jsr w_number_sign_greater
.9f07		20 b4 94	jsr $94b4	                jsr w_type
.9f0a		20 b5 91	jsr $91b5	                jsr w_space
.9f0d		60		rts		z_d_dot:        rts
.9f0e						xt_d_dot_r:
.9f0e		20 de d7	jsr $d7de	                jsr underflow_3
.9f11						w_d_dot_r:
.9f11		20 59 93	jsr $9359	                jsr w_to_r
.9f14		20 7d 93	jsr $937d	                jsr w_tuck
.9f17		20 b8 9e	jsr $9eb8	                jsr w_dabs
.9f1a		20 ad 89	jsr $89ad	                jsr w_less_number_sign
.9f1d		20 89 8c	jsr $8c89	                jsr w_number_sign_s
.9f20		20 5c 8f	jsr $8f5c	                jsr w_rot
.9f23		20 38 91	jsr $9138	                jsr w_sign
.9f26		20 67 8c	jsr $8c67	                jsr w_number_sign_greater
.9f29		20 b5 8e	jsr $8eb5	                jsr w_r_from
.9f2c		20 db 8c	jsr $8cdb	                jsr w_over
.9f2f		20 bb 8b	jsr $8bbb	                jsr w_minus
.9f32		20 be 91	jsr $91be	                jsr w_spaces
.9f35		20 b4 94	jsr $94b4	                jsr w_type
.9f38		60		rts		z_d_dot_r:      rts
.9f39						xt_m_star_slash:
.9f39		20 e3 d7	jsr $d7e3	                jsr underflow_4
.9f3c						w_m_star_slash:
.9f3c		20 9f 93	jsr $939f	                jsr w_two_dup
.9f3f		20 58 96	jsr $9658	                jsr w_xor
.9f42		20 1e 92	jsr $921e	                jsr w_swap
.9f45		20 d2 80	jsr $80d2	                jsr w_abs
.9f48		20 59 93	jsr $9359	                jsr w_to_r
.9f4b		20 1e 92	jsr $921e	                jsr w_swap
.9f4e		20 d2 80	jsr $80d2	                jsr w_abs
.9f51		20 59 93	jsr $9359	                jsr w_to_r
.9f54		20 db 8c	jsr $8cdb	                jsr w_over
.9f57		20 58 96	jsr $9658	                jsr w_xor
.9f5a		20 ed 9c	jsr $9ced	                jsr w_not_rot          ; rot rot
.9f5d		20 b8 9e	jsr $9eb8	                jsr w_dabs
.9f60		20 1e 92	jsr $921e	                jsr w_swap
.9f63		20 9e 8e	jsr $8e9e	                jsr w_r_fetch
.9f66		20 7b 95	jsr $957b	                jsr w_um_star
.9f69		20 5c 8f	jsr $8f5c	                jsr w_rot
.9f6c		20 b5 8e	jsr $8eb5	                jsr w_r_from
.9f6f		20 7b 95	jsr $957b	                jsr w_um_star
.9f72		20 5c 8f	jsr $8f5c	                jsr w_rot
.9f75		20 66 9e	jsr $9e66	                jsr w_zero
.9f78		20 91 9e	jsr $9e91	                jsr w_d_plus
.9f7b		20 9e 8e	jsr $8e9e	                jsr w_r_fetch
.9f7e		20 39 95	jsr $9539	                jsr w_um_slash_mod
.9f81		20 ed 9c	jsr $9ced	                jsr w_not_rot          ; rot rot
.9f84		20 b5 8e	jsr $8eb5	                jsr w_r_from
.9f87		20 39 95	jsr $9539	                jsr w_um_slash_mod
.9f8a		20 1e 92	jsr $921e	                jsr w_swap
.9f8d		20 56 86	jsr $8656	                jsr w_drop
.9f90		20 1e 92	jsr $921e	                jsr w_swap
.9f93		20 5c 8f	jsr $8f5c	                jsr w_rot
.9f96		e8		inx		                inx                     ; pre-drop TOS
.9f97		e8		inx		                inx
.9f98		b5 ff		lda $ff,x	                lda $ff,x               ; and check sign bit MSB
.9f9a		10 03		bpl $9f9f	                bpl z_m_star_slash      ; ... 0< if ...
.9f9c		20 d7 9e	jsr $9ed7	                jsr w_dnegate
.9f9f		60		rts		z_m_star_slash: rts
.9fa0						xt_two_constant:
.9fa0		20 d9 d7	jsr $d7d9	                jsr underflow_2
.9fa3						w_two_constant:
.9fa3		a9 04		lda #$04	                lda #4
.9fa5		85 1e		sta $1e		                sta tmpdsp              ; PFA size 4
.9fa7		20 f6 83	jsr $83f6	                jsr create_dovar
.9faa		20 ae 83	jsr $83ae	                jsr w_comma
.9fad		20 ae 83	jsr $83ae	                jsr w_comma
.9fb0		20 b7 85	jsr $85b7	                jsr does_runtime    ; does> turns into these two routines.
.9fb3		20 6b d6	jsr $d66b	                jsr dodoes
.9fb6		20 b7 93	jsr $93b7	                jsr w_two_fetch
.9fb9		60		rts		z_two_constant: rts
.9fba						xt_two_literal:
.9fba		20 d9 d7	jsr $d7d9	                jsr underflow_2 ; double number
.9fbd						w_two_literal:
.9fbd		a9 14		lda #$14	                lda #2 * template_push_tos_size
.9fbf		20 c5 97	jsr $97c5	                jsr check_nc_limit
.9fc2		b0 09		bcs $9fcd	                bcs _no_inline
.9fc4		20 1e 92	jsr $921e	                jsr w_swap
.9fc7		20 d3 89	jsr $89d3	                jsr w_literal
.9fca		4c d3 89	jmp $89d3	                jmp w_literal
.9fcd						_no_inline:
.9fcd		a0 9f		ldy #$9f	                ldy #>two_literal_runtime
.9fcf		a9 e0		lda #$e0	                lda #<two_literal_runtime
.9fd1		20 b1 97	jsr $97b1	                jsr cmpl_subroutine
.9fd4		a0 04		ldy #$04	                ldy #4
.9fd6						-
.9fd6		b5 00		lda $00,x	                lda 0,x         ; move four bytes from the stack to cp
.9fd8		20 bc 97	jsr $97bc	                jsr cmpl_a
.9fdb		e8		inx		                inx
.9fdc		88		dey		                dey
.9fdd		d0 f7		bne $9fd6	                bne -
.9fdf		60		rts		z_two_literal:  rts
.9fe0						two_literal_runtime:
.9fe0		68		pla		                pla             ; LSB of address
.9fe1		85 25		sta $25		                sta tmp1
.9fe3		7a		ply		                ply             ; MSB of address
.9fe4		84 26		sty $26		                sty tmp1+1
.9fe6		18		clc		                clc             ; add four to the return address
.9fe7		69 04		adc #$04	                adc #4
.9fe9		90 01		bcc $9fec	                bcc +
.9feb		c8		iny		                iny
.9fec						+
.9fec		5a		phy		                phy             ; and re-stack
.9fed		48		pha		                pha
.9fee		a0 04		ldy #$04	                ldy #4
.9ff0						-
.9ff0		b1 25		lda ($25),y	                lda (tmp1),y    ; copy trailing four bytes to the stack
.9ff2		ca		dex		                dex
.9ff3		95 00		sta $00,x	                sta 0,x
.9ff5		88		dey		                dey
.9ff6		d0 f8		bne $9ff0	                bne -
.9ff8		60		rts		                rts
.9ff9						xt_two_variable:
.9ff9						w_two_variable:
.9ff9		ca		dex		                dex
.9ffa		ca		dex		                dex
.9ffb		a9 04		lda #$04	                lda #4
.9ffd		95 00		sta $00,x	                sta 0,x
.9fff		74 01		stz $01,x	                stz 1,x
.a001		85 1e		sta $1e		                sta tmpdsp              ; PFA size 4
.a003		20 f6 83	jsr $83f6	                jsr create_dovar
.a006		20 2a 82	jsr $822a	                jsr w_allot
.a009		60		rts		z_two_variable: rts
.a00a						xt_ud_dot:
.a00a		20 d9 d7	jsr $d7d9	                jsr underflow_2 ; double number
.a00d						w_ud_dot:
.a00d		20 ad 89	jsr $89ad	                jsr w_less_number_sign
.a010		20 89 8c	jsr $8c89	                jsr w_number_sign_s
.a013		20 67 8c	jsr $8c67	                jsr w_number_sign_greater
.a016		20 b4 94	jsr $94b4	                jsr w_type
.a019		20 b5 91	jsr $91b5	                jsr w_space
.a01c		60		rts		z_ud_dot:        rts
.a01d						xt_ud_dot_r:
.a01d		20 de d7	jsr $d7de	                jsr underflow_3
.a020						w_ud_dot_r:
.a020		20 59 93	jsr $9359	                jsr w_to_r
.a023		20 ad 89	jsr $89ad	                jsr w_less_number_sign
.a026		20 89 8c	jsr $8c89	                jsr w_number_sign_s
.a029		20 67 8c	jsr $8c67	                jsr w_number_sign_greater
.a02c		20 b5 8e	jsr $8eb5	                jsr w_r_from
.a02f		20 db 8c	jsr $8cdb	                jsr w_over
.a032		20 bb 8b	jsr $8bbb	                jsr w_minus
.a035		20 be 91	jsr $91be	                jsr w_spaces
.a038		20 b4 94	jsr $94b4	                jsr w_type
.a03b		60		rts		z_ud_dot_r:      rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/string.asm

.a03c						xt_cmove:
.a03c		20 de d7	jsr $d7de	                jsr underflow_3
.a03f						w_cmove:
.a03f		b5 02		lda $02,x	                lda 2,x
.a041		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.a043		b5 03		lda $03,x	                lda 3,x
.a045		85 28		sta $28		                sta tmp2+1
.a047		b5 04		lda $04,x	                lda 4,x
.a049		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.a04b		b5 05		lda $05,x	                lda 5,x
.a04d		85 26		sta $26		                sta tmp1+1
.a04f		a0 00		ldy #$00	                ldy #0
.a051		b5 01		lda $01,x	                lda 1,x         ; number of whole pages to move
.a053		f0 0f		beq $a064	                beq _dopartial
.a055						_page:
.a055		b1 25		lda ($25),y	                lda (tmp1),y
.a057		91 27		sta ($27),y	                sta (tmp2),y
.a059		c8		iny		                iny
.a05a		d0 f9		bne $a055	                bne _page
.a05c		e6 26		inc $26		                inc tmp1+1
.a05e		e6 28		inc $28		                inc tmp2+1
.a060		d6 01		dec $01,x	                dec 1,x
.a062		d0 f1		bne $a055	                bne _page
.a064						_dopartial:
.a064		b5 00		lda $00,x	                lda 0,x         ; length of last page
.a066		f0 09		beq $a071	                beq _done
.a068						_partial:
.a068		b1 25		lda ($25),y	                lda (tmp1),y
.a06a		91 27		sta ($27),y	                sta (tmp2),y
.a06c		c8		iny		                iny
.a06d		d6 00		dec $00,x	                dec 0,x
.a06f		d0 f7		bne $a068	                bne _partial
.a071						_done:
.a071		8a		txa		                txa
.a072		18		clc		                clc
.a073		69 06		adc #$06	                adc #6
.a075		aa		tax		                tax
.a076		60		rts		z_cmove:        rts
.a077						xt_cmove_up:
.a077		20 de d7	jsr $d7de	                jsr underflow_3
.a07a						w_cmove_up:
.a07a		b5 02		lda $02,x	                lda 2,x
.a07c		85 27		sta $27		                sta tmp2        ; use tmp2 because easier to remember
.a07e		b5 03		lda $03,x	                lda 3,x
.a080		18		clc		                clc
.a081		75 01		adc $01,x	                adc 1,x
.a083		85 28		sta $28		                sta tmp2+1      ; point to last page of destination
.a085		b5 04		lda $04,x	                lda 4,x
.a087		85 25		sta $25		                sta tmp1        ; use tmp1 because easier to remember
.a089		b5 05		lda $05,x	                lda 5,x
.a08b		18		clc		                clc
.a08c		75 01		adc $01,x	                adc 1,x
.a08e		85 26		sta $26		                sta tmp1+1      ; point to last page of source
.a090		f6 01		inc $01,x	                inc 1,x         ; allows us to use bne with dec 1,x below
.a092		b4 00		ldy $00,x	                ldy 0,x         ; length of last page
.a094		f0 0e		beq $a0a4	                beq _nopartial
.a096						_outerloop:
.a096		88		dey		                dey
.a097		f0 07		beq $a0a0	                beq _finishpage
.a099						_innerloop:
.a099		b1 25		lda ($25),y	                lda (tmp1),y
.a09b		91 27		sta ($27),y	                sta (tmp2),y
.a09d		88		dey		                dey
.a09e		d0 f9		bne $a099	                bne _innerloop
.a0a0						_finishpage:
.a0a0		b2 25		lda ($25)	                lda (tmp1)      ; handle y = 0 separately
.a0a2		92 27		sta ($27)	                sta (tmp2)
.a0a4						_nopartial:
.a0a4		c6 26		dec $26		                dec tmp1+1      ; back up to previous pages
.a0a6		c6 28		dec $28		                dec tmp2+1
.a0a8		d6 01		dec $01,x	                dec 1,x
.a0aa		d0 ea		bne $a096	                bne _outerloop
.a0ac		8a		txa		                txa
.a0ad		18		clc		                clc
.a0ae		69 06		adc #$06	                adc #6
.a0b0		aa		tax		                tax
.a0b1		60		rts		z_cmove_up:     rts
.a0b2						xt_compare:
.a0b2		20 e3 d7	jsr $d7e3	                jsr underflow_4
.a0b5						w_compare:
.a0b5		b5 02		lda $02,x	                lda 2,x
.a0b7		85 27		sta $27		                sta tmp2
.a0b9		b5 03		lda $03,x	                lda 3,x
.a0bb		85 28		sta $28		                sta tmp2+1
.a0bd		b5 06		lda $06,x	                lda 6,x
.a0bf		85 25		sta $25		                sta tmp1
.a0c1		b5 07		lda $07,x	                lda 7,x
.a0c3		85 26		sta $26		                sta tmp1+1
.a0c5						_compare_loop:
.a0c5		b5 04		lda $04,x	                lda 4,x
.a0c7		15 05		ora $05,x	                ora 5,x
.a0c9		f0 2c		beq $a0f7	                beq _str1_done
.a0cb		b5 00		lda $00,x	                lda 0,x
.a0cd		15 01		ora $01,x	                ora 1,x
.a0cf		f0 3a		beq $a10b	                beq _greater    ; Str2 empty first
.a0d1		b2 25		lda ($25)	                lda (tmp1)
.a0d3		d2 27		cmp ($27)	                cmp (tmp2)
.a0d5		90 26		bcc $a0fd	                bcc _less
.a0d7		d0 32		bne $a10b	                bne _greater
.a0d9		e6 25		inc $25		                inc tmp1
.a0db		d0 02		bne $a0df	                bne +
.a0dd		e6 26		inc $26		                inc tmp1+1
.a0df						+
.a0df		e6 27		inc $27		                inc tmp2
.a0e1		d0 02		bne $a0e5	                bne +
.a0e3		e6 28		inc $28		                inc tmp2+1
.a0e5						+
.a0e5		b5 04		lda $04,x	                lda 4,x
.a0e7		d0 02		bne $a0eb	                bne +
.a0e9		d6 05		dec $05,x	                dec 5,x
.a0eb						+
.a0eb		d6 04		dec $04,x	                dec 4,x
.a0ed		b5 00		lda $00,x	                lda 0,x
.a0ef		d0 02		bne $a0f3	                bne +
.a0f1		d6 01		dec $01,x	                dec 1,x
.a0f3						+
.a0f3		d6 00		dec $00,x	                dec 0,x
.a0f5		80 ce		bra $a0c5	                bra _compare_loop
.a0f7						_str1_done:
.a0f7		b5 00		lda $00,x	                lda 0,x
.a0f9		15 01		ora $01,x	                ora 1,x
.a0fb		f0 08		beq $a105	                beq _equal      ; Both out of letters
.a0fd						_less:
.a0fd		a9 ff		lda #$ff	                lda #$FF
.a0ff		95 06		sta $06,x	                sta 6,x
.a101		95 07		sta $07,x	                sta 7,x
.a103		80 0c		bra $a111	                bra _done
.a105						_equal:
.a105		74 06		stz $06,x	                stz 6,x
.a107		74 07		stz $07,x	                stz 7,x
.a109		80 06		bra $a111	                bra _done
.a10b						_greater:
.a10b		a9 01		lda #$01	                lda #1
.a10d		95 06		sta $06,x	                sta 6,x
.a10f		74 07		stz $07,x	                stz 7,x
.a111						_done:
.a111		8a		txa		                txa
.a112		18		clc		                clc
.a113		69 06		adc #$06	                adc #6
.a115		aa		tax		                tax
.a116		60		rts		z_compare:      rts
.a117						xt_minus_leading:
.a117		20 d9 d7	jsr $d7d9	                jsr underflow_2
.a11a						w_minus_leading:
.a11a						_loop:
.a11a		b5 00		lda $00,x	                lda 0,x
.a11c		15 01		ora $01,x	                ora 1,x
.a11e		f0 0f		beq $a12f	                beq _done
.a120		a1 02		lda ($02,x)	                lda (2,x)               ; get first character
.a122		20 c7 d7	jsr $d7c7	                jsr is_whitespace
.a125		90 08		bcc $a12f	                bcc _done
.a127		20 00 9e	jsr $9e00	                jsr w_one              ; ( addr u 1 )
.a12a		20 0f a2	jsr $a20f	                jsr w_slash_string     ; ( addr+ u-1 )
.a12d		80 eb		bra $a11a	                bra _loop
.a12f						_done:
.a12f						z_minus_leading:
.a12f		60		rts		                rts
.a130						xt_minus_trailing:
.a130		20 d9 d7	jsr $d7d9	                jsr underflow_2
.a133						w_minus_trailing:
.a133		b5 00		lda $00,x	                lda 0,x         ; LSB of n
.a135		15 01		ora $01,x	                ora 1,x         ; MSB of n
.a137		f0 33		beq $a16c	                beq _done
.a139		18		clc		                clc
.a13a		b5 02		lda $02,x	                lda 2,x         ; LSB of addr
.a13c		75 00		adc $00,x	                adc 0,x
.a13e		85 25		sta $25		                sta tmp1
.a140		b5 03		lda $03,x	                lda 3,x         ; MSB of addr
.a142		75 01		adc $01,x	                adc 1,x
.a144		85 26		sta $26		                sta tmp1+1
.a146		a5 25		lda $25		                lda tmp1
.a148		d0 02		bne $a14c	                bne +
.a14a		c6 26		dec $26		                dec tmp1+1
.a14c						+
.a14c		c6 25		dec $25		                dec tmp1
.a14e						_loop:
.a14e		b2 25		lda ($25)	                lda (tmp1)
.a150		c9 20		cmp #$20	                cmp #AscSP
.a152		d0 18		bne $a16c	                bne _done
.a154		a5 25		lda $25		                lda tmp1
.a156		d0 02		bne $a15a	                bne +
.a158		c6 26		dec $26		                dec tmp1+1
.a15a						+
.a15a		c6 25		dec $25		                dec tmp1
.a15c		b5 00		lda $00,x	                lda 0,x
.a15e		d0 02		bne $a162	                bne +
.a160		d6 01		dec $01,x	                dec 1,x
.a162						+
.a162		d6 00		dec $00,x	                dec 0,x
.a164		b5 00		lda $00,x	                lda 0,x
.a166		15 01		ora $01,x	                ora 1,x
.a168		f0 02		beq $a16c	                beq _done       ; Count has reached zero - we're done!
.a16a		80 e2		bra $a14e	                bra _loop
.a16c						_done:
.a16c						z_minus_trailing:
.a16c		60		rts		                rts
.a16d						xt_search:
.a16d		20 e3 d7	jsr $d7e3	                jsr underflow_4
.a170						w_search:
.a170		b5 00		lda $00,x	                lda 0,x
.a172		15 01		ora $01,x	                ora 1,x
.a174		d0 0b		bne $a181	                bne _start_search
.a176		e8		inx		                inx             ; Remove u2
.a177		e8		inx		                inx
.a178		a9 ff		lda #$ff	                lda #$FF        ; Turn addr2 into a true flag
.a17a		95 00		sta $00,x	                sta 0,x
.a17c		95 01		sta $01,x	                sta 1,x
.a17e		4c 0b a2	jmp $a20b	                jmp z_search
.a181						_start_search:
.a181		20 66 9e	jsr $9e66	                jsr w_zero
.a184						_search_loop:
.a184		18		clc		                clc
.a185		b5 00		lda $00,x	                lda 0,x
.a187		75 02		adc $02,x	                adc 2,x
.a189		85 25		sta $25		                sta tmp1
.a18b		b5 01		lda $01,x	                lda 1,x
.a18d		75 03		adc $03,x	                adc 3,x
.a18f		d5 07		cmp $07,x	                cmp 7,x
.a191		90 12		bcc $a1a5	                bcc _init_comparison ; Obviously less
.a193		d0 06		bne $a19b	                bne _not_found
.a195		b5 06		lda $06,x	                lda 6,x
.a197		c5 25		cmp $25		                cmp tmp1
.a199		b0 0a		bcs $a1a5	                bcs _init_comparison
.a19b						_not_found:
.a19b		e8		inx		                inx             ; Remove offset
.a19c		e8		inx		                inx
.a19d		e8		inx		                inx             ; Remove u2
.a19e		e8		inx		                inx
.a19f		74 00		stz $00,x	                stz 0,x         ; Turn addr2 into a false flag
.a1a1		74 01		stz $01,x	                stz 1,x
.a1a3		80 66		bra $a20b	                bra z_search
.a1a5						_init_comparison:
.a1a5		18		clc		                clc
.a1a6		b5 08		lda $08,x	                lda 8,x
.a1a8		75 00		adc $00,x	                adc 0,x
.a1aa		85 25		sta $25		                sta tmp1
.a1ac		b5 09		lda $09,x	                lda 9,x
.a1ae		75 01		adc $01,x	                adc 1,x
.a1b0		85 26		sta $26		                sta tmp1+1
.a1b2		b5 04		lda $04,x	                lda 4,x
.a1b4		85 27		sta $27		                sta tmp2
.a1b6		b5 05		lda $05,x	                lda 5,x
.a1b8		85 28		sta $28		                sta tmp2+1
.a1ba		b5 02		lda $02,x	                lda 2,x
.a1bc		85 29		sta $29		                sta tmp3
.a1be		b5 03		lda $03,x	                lda 3,x
.a1c0		85 2a		sta $2a		                sta tmp3+1
.a1c2						_comparison_loop:
.a1c2		b2 25		lda ($25)	                lda (tmp1)
.a1c4		d2 27		cmp ($27)	                cmp (tmp2)
.a1c6		f0 05		beq $a1cd	                beq _letters_match
.a1c8		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.a1cb		80 b7		bra $a184	                bra _search_loop
.a1cd						_letters_match:
.a1cd		e6 25		inc $25		                inc tmp1
.a1cf		d0 02		bne $a1d3	                bne +
.a1d1		e6 26		inc $26		                inc tmp1+1
.a1d3						+
.a1d3		e6 27		inc $27		                inc tmp2
.a1d5		d0 02		bne $a1d9	                bne +
.a1d7		e6 28		inc $28		                inc tmp2+1
.a1d9						+
.a1d9		a5 29		lda $29		                lda tmp3
.a1db		d0 02		bne $a1df	                bne +
.a1dd		c6 2a		dec $2a		                dec tmp3+1
.a1df						+
.a1df		c6 29		dec $29		                dec tmp3
.a1e1		a5 29		lda $29		                lda tmp3
.a1e3		05 2a		ora $2a		                ora tmp3+1
.a1e5		d0 db		bne $a1c2	                bne _comparison_loop ; Check the next letter
.a1e7		18		clc		                clc
.a1e8		b5 00		lda $00,x	                lda 0,x
.a1ea		75 08		adc $08,x	                adc 8,x
.a1ec		95 08		sta $08,x	                sta 8,x
.a1ee		b5 01		lda $01,x	                lda 1,x
.a1f0		75 09		adc $09,x	                adc 9,x
.a1f2		95 09		sta $09,x	                sta 9,x
.a1f4		38		sec		                sec
.a1f5		b5 06		lda $06,x	                lda 6,x
.a1f7		f5 00		sbc $00,x	                sbc 0,x
.a1f9		95 06		sta $06,x	                sta 6,x
.a1fb		b5 07		lda $07,x	                lda 7,x
.a1fd		f5 01		sbc $01,x	                sbc 1,x
.a1ff		95 07		sta $07,x	                sta 7,x
.a201		e8		inx		                inx             ; drop offset
.a202		e8		inx		                inx
.a203		e8		inx		                inx             ; drop u2
.a204		e8		inx		                inx
.a205		a9 ff		lda #$ff	                lda #$FF
.a207		95 00		sta $00,x	                sta 0,x         ; Turn addr2 into a true flag.
.a209		95 01		sta $01,x	                sta 1,x
.a20b		60		rts		z_search:       rts
.a20c						xt_slash_string:
.a20c		20 de d7	jsr $d7de	                jsr underflow_3
.a20f						w_slash_string:
.a20f		18		clc		                clc             ; 3OS+TOS
.a210		b5 00		lda $00,x	                lda 0,x
.a212		75 04		adc $04,x	                adc 4,x
.a214		95 04		sta $04,x	                sta 4,x
.a216		b5 01		lda $01,x	                lda 1,x
.a218		75 05		adc $05,x	                adc 5,x
.a21a		95 05		sta $05,x	                sta 5,x
.a21c		38		sec		                sec             ; NOS-TOS
.a21d		b5 02		lda $02,x	                lda 2,x
.a21f		f5 00		sbc $00,x	                sbc 0,x
.a221		95 02		sta $02,x	                sta 2,x
.a223		b5 03		lda $03,x	                lda 3,x
.a225		f5 01		sbc $01,x	                sbc 1,x
.a227		95 03		sta $03,x	                sta 3,x
.a229		e8		inx		                inx
.a22a		e8		inx		                inx
.a22b		60		rts		z_slash_string: rts
.a22c						xt_sliteral:
.a22c		20 d9 d7	jsr $d7d9	                jsr underflow_2
.a22f						w_sliteral:
.a22f		a0 a2		ldy #$a2	                ldy #>sliteral_runtime
.a231		a9 4d		lda #$4d	                lda #<sliteral_runtime
.a233		20 b1 97	jsr $97b1	                jsr cmpl_subroutine     ; jsr sliteral_runtime
.a236		b5 00		lda $00,x	                lda 0,x
.a238		b4 01		ldy $01,x	                ldy 1,x
.a23a		20 b8 97	jsr $97b8	                jsr cmpl_word           ; .word u
.a23d		20 e7 88	jsr $88e7	                jsr w_here
.a240		20 1e 92	jsr $921e	                jsr w_swap
.a243		20 5c 86	jsr $865c	                jsr w_dup               ; allocate space for the string
.a246		20 2a 82	jsr $822a	                jsr w_allot
.a249		20 d7 8b	jsr $8bd7	                jsr w_move              ; .text < u bytes >
.a24c		60		rts		z_sliteral:     rts
.a24d						sliteral_runtime:
.a24d		ca		dex		                dex             ; make space on the stack
.a24e		ca		dex		                dex
.a24f		ca		dex		                dex
.a250		ca		dex		                dex
.a251		18		clc		                clc
.a252		68		pla		                pla             ; LSB of return address
.a253		85 25		sta $25		                sta tmp1
.a255		69 03		adc #$03	                adc #3          ; calculate string offset
.a257		95 02		sta $02,x	                sta 2,x         ; LSB of string address
.a259		7a		ply		                ply             ; MSB of address
.a25a		84 26		sty $26		                sty tmp1+1
.a25c		90 01		bcc $a25f	                bcc +
.a25e		c8		iny		                iny
.a25f						+
.a25f		94 03		sty $03,x	                sty 3,x         ; MSB of string address
.a261		a0 02		ldy #$02	                ldy #2          ; copy u to TOS
.a263		b1 25		lda ($25),y	                lda (tmp1),y
.a265		95 01		sta $01,x	                sta 1,x         ; MSB of u
.a267		88		dey		                dey
.a268		b1 25		lda ($25),y	                lda (tmp1),y
.a26a		95 00		sta $00,x	                sta 0,x         ; LSB of u
.a26c		18		clc		                clc             ; A still has LSB of u
.a26d		75 02		adc $02,x	                adc 2,x         ; LSB of continuation address
.a26f		85 25		sta $25		                sta tmp1
.a271		b5 01		lda $01,x	                lda 1,x
.a273		75 03		adc $03,x	                adc 3,x
.a275		85 26		sta $26		                sta tmp1+1
.a277		6c 25 00	jmp ($0025)	                jmp (tmp1)

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/disasm.asm

.a27a						xt_disasm:
.a27a		20 d9 d7	jsr $d7d9	                jsr underflow_2
.a27d						w_disasm:
.a27d		20 81 a2	jsr $a281	                jsr disassembler
.a280		60		rts		z_disasm:       rts
.a281						disassembler:
.a281		20 ec 83	jsr $83ec	                jsr w_cr       ; ( addr u )
.a284						_byte_loop:
.a284		20 db 8c	jsr $8cdb	                jsr w_over     ; ( addr u addr )
.a287		20 df 94	jsr $94df	                jsr w_u_dot    ; ( addr u )
.a28a		20 b5 91	jsr $91b5	                jsr w_space
.a28d		a9 e0		lda #$e0	                lda #<oc_index_table
.a28f		85 27		sta $27		                sta tmp2
.a291		a9 b3		lda #$b3	                lda #>oc_index_table
.a293		85 28		sta $28		                sta tmp2+1
.a295		a1 02		lda ($02,x)	                lda (2,x)       ; get opcode that addr points to
.a297		85 2d		sta $2d		                sta scratch     ; Save opcode
.a299		0a		asl a		                asl             ; multiply by two for offset
.a29a		90 02		bcc $a29e	                bcc +
.a29c		e6 28		inc $28		                inc tmp2+1      ; we're on second page
.a29e						+
.a29e		a8		tay		                tay             ; use Y as the index
.a29f		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a2a1		85 29		sta $29		                sta tmp3
.a2a3		48		pha		                pha
.a2a4		c8		iny		                iny
.a2a5		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a2a7		85 2a		sta $2a		                sta tmp3+1
.a2a9		48		pha		                pha
.a2aa		b2 29		lda ($29)	                lda (tmp3)
.a2ac		a8		tay		                tay                     ; save copy of lengths byte
.a2ad		10 2f		bpl $a2de	                bpl _no_operand         ; bit 7 clear, single-byte instruction
.a2af		20 00 9e	jsr $9e00	                jsr w_one
.a2b2		20 0f a2	jsr $a20f	                jsr w_slash_string
.a2b5		20 66 9e	jsr $9e66	                jsr w_zero             ; ( addr+1 u-1 0 ) ZERO does not use Y
.a2b8		a1 04		lda ($04,x)	                lda (4,x)
.a2ba		95 00		sta $00,x	                sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
.a2bc		85 2e		sta $2e		                sta scratch+1           ; Save a copy in the scratch buffer
.a2be		98		tya		                tya                     ; retrieve copy of lengths byte
.a2bf		2a		rol a		                rol                     ; shift bit 6 to bit 7
.a2c0		10 12		bpl $a2d4	                bpl _print_operand
.a2c2		20 ed 9c	jsr $9ced	                jsr w_not_rot           ; ( LSB addr u )
.a2c5		20 00 9e	jsr $9e00	                jsr w_one
.a2c8		20 0f a2	jsr $a20f	                jsr w_slash_string
.a2cb		20 5c 8f	jsr $8f5c	                jsr w_rot               ; ( addr+2 u-2 LSB )
.a2ce		a1 04		lda ($04,x)	                lda (4,x)
.a2d0		95 01		sta $01,x	                sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
.a2d2		85 2f		sta $2f		                sta scratch+2           ; Save a copy in the scratch buffer
.a2d4						_print_operand:
.a2d4		a9 05		lda #$05	                lda #5
.a2d6		20 74 a4	jsr $a474	                jsr push_a_tos               ; ( addr+n u-n opr 5 )
.a2d9		20 eb 94	jsr $94eb	                jsr w_u_dot_r           ; U.R ( addr+n u-n )
.a2dc		80 08		bra $a2e6	                bra _print_mnemonic
.a2de						_no_operand:
.a2de		a9 05		lda #$05	                lda #5
.a2e0		20 74 a4	jsr $a474	                jsr push_a_tos               ; ( addr u 5 )
.a2e3		20 be 91	jsr $91be	                jsr w_spaces            ; ( addr u )
.a2e6						_print_mnemonic:
.a2e6		20 b5 91	jsr $91b5	                jsr w_space
.a2e9		ca		dex		                dex
.a2ea		ca		dex		                dex                     ; ( addr u ? )
.a2eb		68		pla		                pla                     ; MSB
.a2ec		95 01		sta $01,x	                sta 1,x                 ; ( addr u MSB )
.a2ee		68		pla		                pla                     ; LSB
.a2ef		95 00		sta $00,x	                sta 0,x                 ; ( addr u addr-o )
.a2f1		20 db 83	jsr $83db	                jsr w_count            ; ( addr u addr-o u-o )
.a2f4		74 01		stz $01,x	                stz 1,x                 ; paranoid
.a2f6		b5 00		lda $00,x	                lda 0,x
.a2f8		29 07		and #$07	                and #%00000111          ; ( addr u addr-o u-o )
.a2fa		95 00		sta $00,x	                sta 0,x
.a2fc		20 b4 94	jsr $94b4	                jsr w_type             ; ( addr u )
.a2ff		a5 2d		lda $2d		                lda scratch
.a301		c9 20		cmp #$20	                cmp #OpJSR
.a303		d0 12		bne $a317	                bne _not_jsr
.a305		a9 05		lda #$05	                lda #5
.a307		20 74 a4	jsr $a474	                jsr push_a_tos
.a30a		20 be 91	jsr $91be	                jsr w_spaces
.a30d		20 a1 a3	jsr $a3a1	                jsr disasm_special
.a310		b0 39		bcs $a34b	                bcs _printing_done
.a312		20 64 a3	jsr $a364	                jsr disasm_jsr
.a315		b0 34		bcs $a34b	                bcs _printing_done
.a317						_not_jsr:
.a317		c9 80		cmp #$80	                cmp #OpBRA            ; is it bra?
.a319		f0 06		beq $a321	                beq _is_rel
.a31b		29 1f		and #$1f	                and #$1F
.a31d		49 10		eor #$10	                eor #$10            ; do bottom five bits match xxx10000 ?
.a31f		d0 2a		bne $a34b	                bne _printing_done
.a321						_is_rel:
.a321		a0 76		ldy #$76	                ldy #'v'            ; we'll indicate branch forward or back with v or ^
.a323		a5 2e		lda $2e		                lda scratch+1
.a325		20 74 a4	jsr $a474	                jsr push_a_tos
.a328		10 04		bpl $a32e	                bpl +
.a32a		d6 01		dec $01,x	                dec 1,x             ; for negative offsets extend the sign bit so add works out
.a32c		a0 5e		ldy #$5e	                ldy #'^'            ; it's a backward branch
.a32e		38		sec		+               sec                 ; start counting from address after opcode
.a32f		75 04		adc $04,x	                adc 4,x
.a331		95 00		sta $00,x	                sta 0,x
.a333		b5 01		lda $01,x	                lda 1,x
.a335		75 05		adc $05,x	                adc 5,x
.a337		95 01		sta $01,x	                sta 1,x
.a339		5a		phy		                phy                 ; save the direction indicator
.a33a		a9 09		lda #$09	                lda #9
.a33c		20 74 a4	jsr $a474	                jsr push_a_tos
.a33f		20 eb 94	jsr $94eb	                jsr w_u_dot_r      ; print the destination with 5 leading spaces
.a342		a9 20		lda #$20	                lda #AscSP          ; print space and branch direction indicator
.a344		20 86 86	jsr $8686	                jsr emit_a
.a347		68		pla		                pla
.a348		20 86 86	jsr $8686	                jsr emit_a
.a34b						_printing_done:
.a34b		20 ec 83	jsr $83ec	                jsr w_cr
.a34e		20 00 9e	jsr $9e00	                jsr w_one
.a351		20 0f a2	jsr $a20f	                jsr w_slash_string      ; ( addr u -- addr+1 u-1 )
.a354		b5 00		lda $00,x	                lda 0,x                 ; All done?
.a356		15 01		ora $01,x	                ora 1,x
.a358		f0 07		beq $a361	                beq _done
.a35a		b5 01		lda $01,x	                lda 1,x                 ; Catch mid-instruction ranges
.a35c		30 03		bmi $a361	                bmi _done
.a35e		4c 84 a2	jmp $a284	                jmp _byte_loop          ; out of range for BRA
.a361						_done:
.a361		4c 97 93	jmp $9397	                jmp w_two_drop         ; JSR/RTS
.a364						disasm_jsr:
.a364		ca		dex		                dex
.a365		ca		dex		                dex
.a366		a5 2e		lda $2e		                lda scratch+1
.a368		95 00		sta $00,x	                sta 0,x
.a36a		a5 2f		lda $2f		                lda scratch+2
.a36c		95 01		sta $01,x	                sta 1,x
.a36e		20 20 9c	jsr $9c20	                jsr w_int_to_name
.a371		b5 00		lda $00,x	                lda 0,x
.a373		15 01		ora $01,x	                ora 1,x
.a375		d0 1e		bne $a395	                bne _found_nt
.a377		a5 2e		lda $2e		                lda scratch+1
.a379		38		sec		                sec
.a37a		e9 03		sbc #$03	                sbc #3         ; Subtract 3 this time.
.a37c		95 00		sta $00,x	                sta 0,x
.a37e		a5 2f		lda $2f		                lda scratch+2
.a380		e9 00		sbc #$00	                sbc #0         ; Subtract the carry if needed.
.a382		95 01		sta $01,x	                sta 1,x
.a384		20 5c 86	jsr $865c	                jsr w_dup
.a387		20 6f 97	jsr $976f	                jsr has_uf_check
.a38a		90 11		bcc $a39d	                bcc _no_nt
.a38c		20 20 9c	jsr $9c20	                jsr w_int_to_name     ; Try looking again
.a38f		b5 00		lda $00,x	                lda 0,x
.a391		15 01		ora $01,x	                ora 1,x
.a393		f0 08		beq $a39d	                beq _no_nt
.a395						_found_nt:
.a395		20 c3 9c	jsr $9cc3	                jsr w_name_to_string
.a398		20 b4 94	jsr $94b4	                jsr w_type
.a39b		38		sec		                sec
.a39c		60		rts		                rts
.a39d						_no_nt:
.a39d		e8		inx		                inx
.a39e		e8		inx		                inx
.a39f		18		clc		                clc
.a3a0		60		rts		                rts
.a3a1						disasm_special:
.a3a1		a0 2c		ldy #$2c	                ldy #(_end_handlers - _special_handlers - 4)
.a3a3		b9 44 a4	lda $a444,y	_check:         lda _special_handlers,y
.a3a6		c5 2e		cmp $2e		                cmp scratch+1
.a3a8		d0 07		bne $a3b1	                bne _next
.a3aa		b9 45 a4	lda $a445,y	                lda _special_handlers+1,y
.a3ad		c5 2f		cmp $2f		                cmp scratch+2
.a3af		f0 08		beq $a3b9	                beq _found_handler
.a3b1		88		dey		_next:          dey
.a3b2		88		dey		                dey
.a3b3		88		dey		                dey
.a3b4		88		dey		                dey
.a3b5		10 ec		bpl $a3a3	                bpl _check
.a3b7		18		clc		                clc
.a3b8		60		rts		                rts
.a3b9						_found_handler:
.a3b9		84 32		sty $32		                sty scratch+5               ; store the offset for later
.a3bb		b9 47 a4	lda $a447,y	                lda _special_handlers+3,y   ; payload + prefix
.a3be		48		pha		                pha                         ; stash a copy for payload later
.a3bf		4a		lsr a		                lsr
.a3c0		4a		lsr a		                lsr
.a3c1		f0 06		beq $a3c9	                beq _no_prefix
.a3c3		18		clc		                clc
.a3c4		69 20		adc #$20	                adc #32
.a3c6		20 86 86	jsr $8686	                jsr emit_a                  ; print the char stored as (ch - 32) << 2
.a3c9						_no_prefix:
.a3c9		b9 46 a4	lda $a446,y	                lda _special_handlers+2,y   ; string index
.a3cc		20 10 d8	jsr $d810	                jsr print_string_no_lf
.a3cf		68		pla		                pla
.a3d0		29 03		and #$03	                and #3                      ; payload is 0, 1 or 2 words
.a3d2		f0 4b		beq $a41f	                beq _done
.a3d4		c9 03		cmp #$03	                cmp #3                      ; where 3 means a double-word
.a3d6		d0 05		bne $a3dd	                bne _show_payload
.a3d8		20 30 a4	jsr $a430	                jsr _print_2literal
.a3db		80 42		bra $a41f	                bra _done
.a3dd						_show_payload:
.a3dd		48		pha		                pha
.a3de		20 21 a4	jsr $a421	                jsr _print_literal
.a3e1		68		pla		                pla
.a3e2		3a		dec a		                dea
.a3e3		d0 f8		bne $a3dd	                bne _show_payload
.a3e5		a5 32		lda $32		                lda scratch+5
.a3e7		c9 14		cmp #$14	                cmp #_sliteral_handler - _special_handlers
.a3e9		d0 34		bne $a41f	                bne _done
.a3eb		20 db 8c	jsr $8cdb	                jsr w_over
.a3ee		20 b3 8c	jsr $8cb3	                jsr w_one_minus
.a3f1		20 e9 87	jsr $87e9	                jsr w_fetch         ; ( addr n u )
.a3f4		b5 01		lda $01,x	                lda 1,x
.a3f6		d0 06		bne $a3fe	                bne _truncate
.a3f8		b5 00		lda $00,x	                lda 0,x
.a3fa		c9 10		cmp #$10	                cmp #16
.a3fc		90 02		bcc $a400	                bcc +               ; length < 16?
.a3fe						_truncate:
.a3fe		a9 12		lda #$12	                lda #18             ; extra chars for ellipses
.a400						+
.a400		85 1e		sta $1e		                sta tmpdsp
.a402		b5 04		lda $04,x	                lda 4,x             ; tmp1 points 1 before string
.a404		85 25		sta $25		                sta tmp1
.a406		b5 05		lda $05,x	                lda 5,x
.a408		85 26		sta $26		                sta tmp1+1
.a40a		a0 01		ldy #$01	                ldy #1
.a40c						_snippet:
.a40c		b1 25		lda ($25),y	                lda (tmp1),y
.a40e		c0 10		cpy #$10	                cpy #16
.a410		90 02		bcc $a414	                bcc +
.a412		a9 2e		lda #$2e	                lda #'.'
.a414						+
.a414		20 86 86	jsr $8686	                jsr emit_a
.a417		c8		iny		                iny
.a418		c6 1e		dec $1e		                dec tmpdsp
.a41a		d0 f0		bne $a40c	                bne _snippet
.a41c		20 0f a2	jsr $a20f	                jsr w_slash_string
.a41f		38		sec		_done:          sec
.a420		60		rts		                rts
.a421						_print_literal:
.a421		20 db 8c	jsr $8cdb	                jsr w_over
.a424		20 bf 8c	jsr $8cbf	                jsr w_one_plus              ; ( addr u addr+1 )
.a427		20 3f 99	jsr $993f	                jsr w_question              ; Print the value at the address
.a42a		20 31 9e	jsr $9e31	                jsr w_two
.a42d		4c 0f a2	jmp $a20f	                jmp w_slash_string          ; leaving (addr+2 u-2)
.a430						_print_2literal:
.a430		20 db 8c	jsr $8cdb	                jsr w_over                  ; ( addr u addr+1 )
.a433		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.a436		20 b7 93	jsr $93b7	                jsr w_two_fetch
.a439		20 f2 9e	jsr $9ef2	                jsr w_d_dot                 ; fetch and print double word
.a43c		a9 04		lda #$04	                lda #4
.a43e		20 74 a4	jsr $a474	                jsr push_a_tos
.a441		4c 0f a2	jmp $a20f	                jmp w_slash_string          ; ( addr+4 u-4 )
.a444						_special_handlers:
>a444		d4 d7				    .word underflow_1
>a446		0c 44				        .byte str_disasm_sdc, 0 + ('1'-32)*4
>a448		d9 d7				    .word underflow_2
>a44a		0c 48				        .byte str_disasm_sdc, 0 + ('2'-32)*4
>a44c		de d7				    .word underflow_3
>a44e		0c 4c				        .byte str_disasm_sdc, 0 + ('3'-32)*4
>a450		e3 d7				    .word underflow_4
>a452		0c 50				        .byte str_disasm_sdc, 0 + ('4'-32)*4
>a454		18 8a				    .word literal_runtime
>a456		0d 01				        .byte str_disasm_lit, 1
.a458						_sliteral_handler:
>a458		4d a2				    .word sliteral_runtime
>a45a		0d cd				        .byte str_disasm_lit, 1 + ('S'-32)*4
>a45c		e0 9f				    .word two_literal_runtime
>a45e		0d 4b				        .byte str_disasm_lit, 3 + ('2'-32)*4
>a460		4e 98				    .word zero_branch_runtime
>a462		0e 01				        .byte str_disasm_0bra, 1
>a464		b0 8a				    .word loop_runtime
>a466		0f 01				        .byte str_disasm_loop, 1
>a468		c9 8a				    .word plus_loop_runtime
>a46a		0f 2d				        .byte str_disasm_loop, 1 + ('+'-32)*4
>a46c		75 85				    .word do_runtime
>a46e		10 00				        .byte str_disasm_do, 0
>a470		5d 85				    .word question_do_runtime
>a472		10 7d				        .byte str_disasm_do, 1 + ('?'-32)*4
.a474						_end_handlers:
.a474						push_a_tos:
.a474		ca		dex		                dex
.a475		ca		dex		                dex
.a476		95 00		sta $00,x	                sta 0,x
.a478		74 01		stz $01,x	                stz 1,x
.a47a						z_push_a_tos:
.a47a		60		rts		                rts
.a47b						disassembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/assembler.asm

.a47b						assembler:
.a47b						xt_asm_adc_h:
.a47b		a9 69		lda #$69	                lda #$69
.a47d		4c d4 a7	jmp $a7d4	                jmp asm_common
.a480						z_asm_adc_h:
.a480						xt_asm_adc_x:
.a480		a9 7d		lda #$7d	                lda #$7D
.a482		4c d4 a7	jmp $a7d4	                jmp asm_common
.a485						z_asm_adc_x:
.a485						xt_asm_adc_y:
.a485		a9 79		lda #$79	                lda #$79
.a487		4c d4 a7	jmp $a7d4	                jmp asm_common
.a48a						z_asm_adc_y:
.a48a						xt_asm_adc_z:
.a48a		a9 65		lda #$65	                lda #$65
.a48c		4c d4 a7	jmp $a7d4	                jmp asm_common
.a48f						z_asm_adc_z:
.a48f						xt_asm_adc_zi:
.a48f		a9 72		lda #$72	                lda #$72
.a491		4c d4 a7	jmp $a7d4	                jmp asm_common
.a494						z_asm_adc_zi:
.a494						xt_asm_adc_ziy:
.a494		a9 71		lda #$71	                lda #$71
.a496		4c d4 a7	jmp $a7d4	                jmp asm_common
.a499						z_asm_adc_ziy:
.a499						xt_asm_adc_zx:
.a499		a9 75		lda #$75	                lda #$75
.a49b		4c d4 a7	jmp $a7d4	                jmp asm_common
.a49e						z_asm_adc_zx:
.a49e						xt_asm_adc_zxi:
.a49e		a9 61		lda #$61	                lda #$61
.a4a0		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4a3						z_asm_adc_zxi:
.a4a3						xt_asm_and:
.a4a3		a9 2d		lda #$2d	                lda #$2D
.a4a5		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4a8						z_asm_and:
.a4a8						xt_asm_and_h:
.a4a8		a9 29		lda #$29	                lda #$29
.a4aa		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4ad						z_asm_and_h:
.a4ad						xt_asm_and_x:
.a4ad		a9 3d		lda #$3d	                lda #$3D
.a4af		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4b2						z_asm_and_x:
.a4b2						xt_asm_and_y:
.a4b2		a9 39		lda #$39	                lda #$39
.a4b4		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4b7						z_asm_and_y:
.a4b7						xt_asm_and_z:
.a4b7		a9 25		lda #$25	                lda #$25
.a4b9		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4bc						z_asm_and_z:
.a4bc						xt_asm_and_zi:
.a4bc		a9 32		lda #$32	                lda #$32
.a4be		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4c1						z_asm_and_zi:
.a4c1						xt_asm_and_ziy:
.a4c1		a9 31		lda #$31	                lda #$31
.a4c3		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4c6						z_asm_and_ziy:
.a4c6						xt_asm_and_zx:
.a4c6		a9 35		lda #$35	                lda #$35
.a4c8		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4cb						z_asm_and_zx:
.a4cb						xt_asm_and_zxi:
.a4cb		a9 21		lda #$21	                lda #$21
.a4cd		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4d0						z_asm_and_zxi:
.a4d0						xt_asm_asl:
.a4d0		a9 0e		lda #$0e	                lda #$0E
.a4d2		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4d5						z_asm_asl:
.a4d5						xt_asm_asl_a:
.a4d5		a9 0a		lda #$0a	                lda #$0A
.a4d7		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4da						z_asm_asl_a:
.a4da						xt_asm_asl_x:
.a4da		a9 1e		lda #$1e	                lda #$1E
.a4dc		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4df						z_asm_asl_x:
.a4df						xt_asm_asl_z:
.a4df		a9 06		lda #$06	                lda #$06
.a4e1		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4e4						z_asm_asl_z:
.a4e4						xt_asm_asl_zx:
.a4e4		a9 16		lda #$16	                lda #$16
.a4e6		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4e9						z_asm_asl_zx:
.a4e9						xt_asm_bcc:
.a4e9		a9 90		lda #$90	                lda #$90
.a4eb		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4ee						z_asm_bcc:
.a4ee						xt_asm_bcs:
.a4ee		a9 b0		lda #$b0	                lda #$B0
.a4f0		a0 02		ldy #$02	                ldy #2
.a4f2		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4f5						z_asm_bcs:
.a4f5						xt_asm_beq:
.a4f5		a9 f0		lda #$f0	                lda #$F0
.a4f7		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4fa						z_asm_beq:
.a4fa						xt_asm_bit:
.a4fa		a9 2c		lda #$2c	                lda #$2C
.a4fc		4c d4 a7	jmp $a7d4	                jmp asm_common
.a4ff						z_asm_bit:
.a4ff						xt_asm_bit_h:
.a4ff		a9 89		lda #$89	                lda #$89
.a501		4c d4 a7	jmp $a7d4	                jmp asm_common
.a504						z_asm_bit_h:
.a504						xt_asm_bit_x:
.a504		a9 3c		lda #$3c	                lda #$3C
.a506		4c d4 a7	jmp $a7d4	                jmp asm_common
.a509						z_asm_bit_x:
.a509						xt_asm_bit_z:
.a509		a9 24		lda #$24	                lda #$24
.a50b		4c d4 a7	jmp $a7d4	                jmp asm_common
.a50e						z_asm_bit_z:
.a50e						xt_asm_bit_zx:
.a50e		a9 34		lda #$34	                lda #$34
.a510		4c d4 a7	jmp $a7d4	                jmp asm_common
.a513						z_asm_bit_zx:
.a513						xt_asm_bmi:
.a513		a9 30		lda #$30	                lda #$30
.a515		4c d4 a7	jmp $a7d4	                jmp asm_common
.a518						z_asm_bmi:
.a518						xt_asm_bne:
.a518		a9 d0		lda #$d0	                lda #$D0
.a51a		4c d4 a7	jmp $a7d4	                jmp asm_common
.a51d						z_asm_bne:
.a51d						xt_asm_bpl:
.a51d		a9 10		lda #$10	                lda #$10
.a51f		4c d4 a7	jmp $a7d4	                jmp asm_common
.a522						z_asm_bpl:
.a522						xt_asm_bra:
.a522		a9 80		lda #$80	                lda #$80
.a524		4c d4 a7	jmp $a7d4	                jmp asm_common
.a527						z_asm_bra:
.a527						xt_asm_brk:
.a527		a9 00		lda #$00	                lda #$00
.a529		4c d4 a7	jmp $a7d4	                jmp asm_common
.a52c						z_asm_brk:
.a52c						xt_asm_bvc:
.a52c		a9 50		lda #$50	                lda #$50
.a52e		4c d4 a7	jmp $a7d4	                jmp asm_common
.a531						z_asm_bvc:
.a531						xt_asm_bvs:
.a531		a9 70		lda #$70	                lda #$70
.a533		4c d4 a7	jmp $a7d4	                jmp asm_common
.a536						z_asm_bvs:
.a536						xt_asm_clc:
.a536		a9 18		lda #$18	                lda #$18
.a538		4c d4 a7	jmp $a7d4	                jmp asm_common
.a53b						z_asm_clc:
.a53b						xt_asm_cld:
.a53b		a9 d8		lda #$d8	                lda #$D8
.a53d		4c d4 a7	jmp $a7d4	                jmp asm_common
.a540						z_asm_cld:
.a540						xt_asm_cli:
.a540		a9 58		lda #$58	                lda #$58
.a542		4c d4 a7	jmp $a7d4	                jmp asm_common
.a545						z_asm_cli:
.a545						xt_asm_clv:
.a545		a9 b8		lda #$b8	                lda #$B8
.a547		4c d4 a7	jmp $a7d4	                jmp asm_common
.a54a						z_asm_clv:
.a54a						xt_asm_cmp:
.a54a		a9 cd		lda #$cd	                lda #$CD
.a54c		4c d4 a7	jmp $a7d4	                jmp asm_common
.a54f						z_asm_cmp:
.a54f						xt_asm_cmp_h:
.a54f		a9 c9		lda #$c9	                lda #$C9
.a551		4c d4 a7	jmp $a7d4	                jmp asm_common
.a554						z_asm_cmp_h:
.a554						xt_asm_cmp_x:
.a554		a9 dd		lda #$dd	                lda #$DD
.a556		4c d4 a7	jmp $a7d4	                jmp asm_common
.a559						z_asm_cmp_x:
.a559						xt_asm_cmp_y:
.a559		a9 d9		lda #$d9	                lda #$D9
.a55b		4c d4 a7	jmp $a7d4	                jmp asm_common
.a55e						z_asm_cmp_y:
.a55e						xt_asm_cmp_z:
.a55e		a9 c5		lda #$c5	                lda #$C5
.a560		4c d4 a7	jmp $a7d4	                jmp asm_common
.a563						z_asm_cmp_z:
.a563						xt_asm_cmp_zi:
.a563		a9 d2		lda #$d2	                lda #$D2
.a565		4c d4 a7	jmp $a7d4	                jmp asm_common
.a568						z_asm_cmp_zi:
.a568						xt_asm_cmp_ziy:
.a568		a9 d1		lda #$d1	                lda #$D1
.a56a		4c d4 a7	jmp $a7d4	                jmp asm_common
.a56d						z_asm_cmp_ziy:
.a56d						xt_asm_cmp_zx:
.a56d		a9 d5		lda #$d5	                lda #$D5
.a56f		4c d4 a7	jmp $a7d4	                jmp asm_common
.a572						z_asm_cmp_zx:
.a572						xt_asm_cmp_zxi:
.a572		a9 c1		lda #$c1	                lda #$C1
.a574		4c d4 a7	jmp $a7d4	                jmp asm_common
.a577						z_asm_cmp_zxi:
.a577						xt_asm_cpx:
.a577		a9 ec		lda #$ec	                lda #$EC
.a579		4c d4 a7	jmp $a7d4	                jmp asm_common
.a57c						z_asm_cpx:
.a57c						xt_asm_cpx_h:
.a57c		a9 e0		lda #$e0	                lda #$E0
.a57e		4c d4 a7	jmp $a7d4	                jmp asm_common
.a581						z_asm_cpx_h:
.a581						xt_asm_cpx_z:
.a581		a9 e4		lda #$e4	                lda #$E4
.a583		4c d4 a7	jmp $a7d4	                jmp asm_common
.a586						z_asm_cpx_z:
.a586						xt_asm_cpy:
.a586		a9 cc		lda #$cc	                lda #$CC
.a588		a0 03		ldy #$03	                ldy #3
.a58a		4c d4 a7	jmp $a7d4	                jmp asm_common
.a58d						z_asm_cpy:
.a58d						xt_asm_cpy_h:
.a58d		a9 c0		lda #$c0	                lda #$C0
.a58f		4c d4 a7	jmp $a7d4	                jmp asm_common
.a592						z_asm_cpy_h:
.a592						xt_asm_cpy_z:
.a592		a9 c4		lda #$c4	                lda #$C4
.a594		4c d4 a7	jmp $a7d4	                jmp asm_common
.a597						z_asm_cpy_z:
.a597						xt_asm_dec:
.a597		a9 ce		lda #$ce	                lda #$CE
.a599		4c d4 a7	jmp $a7d4	                jmp asm_common
.a59c						z_asm_dec:
.a59c						xt_asm_dec_a:
.a59c		a9 3a		lda #$3a	                lda #$3A
.a59e		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5a1						z_asm_dec_a:
.a5a1						xt_asm_dec_x:
.a5a1		a9 de		lda #$de	                lda #$DE
.a5a3		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5a6						z_asm_dec_x:
.a5a6						xt_asm_dec_z:
.a5a6		a9 c6		lda #$c6	                lda #$C6
.a5a8		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5ab						z_asm_dec_z:
.a5ab						xt_asm_dec_zx:
.a5ab		a9 d6		lda #$d6	                lda #$D6
.a5ad		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5b0						z_asm_dec_zx:
.a5b0						xt_asm_dex:
.a5b0		a9 ca		lda #$ca	                lda #$CA
.a5b2		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5b5						z_asm_dex:
.a5b5						xt_asm_dey:
.a5b5		a9 88		lda #$88	                lda #$88
.a5b7		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5ba						z_asm_dey:
.a5ba						xt_asm_eor:
.a5ba		a9 4d		lda #$4d	                lda #$4D
.a5bc		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5bf						z_asm_eor:
.a5bf						xt_asm_eor_h:
.a5bf		a9 49		lda #$49	                lda #$49
.a5c1		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5c4						z_asm_eor_h:
.a5c4						xt_asm_eor_x:
.a5c4		a9 5d		lda #$5d	                lda #$5D
.a5c6		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5c9						z_asm_eor_x:
.a5c9						xt_asm_eor_y:
.a5c9		a9 59		lda #$59	                lda #$59
.a5cb		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5ce						z_asm_eor_y:
.a5ce						xt_asm_eor_z:
.a5ce		a9 45		lda #$45	                lda #$45
.a5d0		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5d3						z_asm_eor_z:
.a5d3						xt_asm_eor_zi:
.a5d3		a9 52		lda #$52	                lda #$52
.a5d5		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5d8						z_asm_eor_zi:
.a5d8						xt_asm_eor_ziy:
.a5d8		a9 51		lda #$51	                lda #$51
.a5da		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5dd						z_asm_eor_ziy:
.a5dd						xt_asm_eor_zx:
.a5dd		a9 55		lda #$55	                lda #$55
.a5df		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5e2						z_asm_eor_zx:
.a5e2						xt_asm_eor_zxi:
.a5e2		a9 41		lda #$41	                lda #$41
.a5e4		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5e7						z_asm_eor_zxi:
.a5e7						xt_asm_inc:
.a5e7		a9 ee		lda #$ee	                lda #$EE
.a5e9		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5ec						z_asm_inc:
.a5ec						xt_asm_inc_a:
.a5ec		a9 1a		lda #$1a	                lda #$1A
.a5ee		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5f1						z_asm_inc_a:
.a5f1						xt_asm_inc_x:
.a5f1		a9 fe		lda #$fe	                lda #$FE
.a5f3		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5f6						z_asm_inc_x:
.a5f6						xt_asm_inc_z:
.a5f6		a9 e6		lda #$e6	                lda #$E6
.a5f8		4c d4 a7	jmp $a7d4	                jmp asm_common
.a5fb						z_asm_inc_z:
.a5fb						xt_asm_inc_zx:
.a5fb		a9 f6		lda #$f6	                lda #$F6
.a5fd		4c d4 a7	jmp $a7d4	                jmp asm_common
.a600						z_asm_inc_zx:
.a600						xt_asm_inx:
.a600		a9 e8		lda #$e8	                lda #$E8
.a602		4c d4 a7	jmp $a7d4	                jmp asm_common
.a605						z_asm_inx:
.a605						xt_asm_iny:
.a605		a9 c8		lda #$c8	                lda #$C8
.a607		4c d4 a7	jmp $a7d4	                jmp asm_common
.a60a						z_asm_iny:
.a60a						xt_asm_jmp:
.a60a		4c a2 97	jmp $97a2	                jmp cmpl_jump_tos
.a60d						z_asm_jmp:
.a60d						xt_asm_jmp_i:
.a60d		a9 6c		lda #$6c	                lda #$6C
.a60f		4c d4 a7	jmp $a7d4	                jmp asm_common
.a612						z_asm_jmp_i:
.a612						xt_asm_jmp_xi:
.a612		a9 7c		lda #$7c	                lda #$7C
.a614		4c d4 a7	jmp $a7d4	                jmp asm_common
.a617						z_asm_jmp_xi:
.a617						xt_asm_jsr:
.a617		a9 20		lda #$20	                lda #$20
.a619		4c d4 a7	jmp $a7d4	                jmp asm_common
.a61c						z_asm_jsr:
.a61c						xt_asm_lda:
.a61c		a9 ad		lda #$ad	                lda #$AD
.a61e		4c d4 a7	jmp $a7d4	                jmp asm_common
.a621						z_asm_lda:
.a621						xt_asm_lda_h:
.a621		a9 a9		lda #$a9	                lda #$A9
.a623		4c d4 a7	jmp $a7d4	                jmp asm_common
.a626						z_asm_lda_h:
.a626						xt_asm_lda_x:
.a626		a9 bd		lda #$bd	                lda #$BD
.a628		4c d4 a7	jmp $a7d4	                jmp asm_common
.a62b						z_asm_lda_x:
.a62b						xt_asm_lda_y:
.a62b		a9 b9		lda #$b9	                lda #$B9
.a62d		4c d4 a7	jmp $a7d4	                jmp asm_common
.a630						z_asm_lda_y:
.a630						xt_asm_lda_z:
.a630		a9 a5		lda #$a5	                lda #$A5
.a632		4c d4 a7	jmp $a7d4	                jmp asm_common
.a635						z_asm_lda_z:
.a635						xt_asm_lda_zi:
.a635		a9 b2		lda #$b2	                lda #$B2
.a637		4c d4 a7	jmp $a7d4	                jmp asm_common
.a63a						z_asm_lda_zi:
.a63a						xt_asm_lda_ziy:
.a63a		a9 b1		lda #$b1	                lda #$B1
.a63c		4c d4 a7	jmp $a7d4	                jmp asm_common
.a63f						z_asm_lda_ziy:
.a63f						xt_asm_lda_zx:
.a63f		a9 b5		lda #$b5	                lda #$B5
.a641		4c d4 a7	jmp $a7d4	                jmp asm_common
.a644						z_asm_lda_zx:
.a644						xt_asm_lda_zxi:
.a644		a9 a1		lda #$a1	                lda #$A1
.a646		4c d4 a7	jmp $a7d4	                jmp asm_common
.a649						z_asm_lda_zxi:
.a649						xt_asm_ldx:
.a649		a9 ae		lda #$ae	                lda #$AE
.a64b		4c d4 a7	jmp $a7d4	                jmp asm_common
.a64e						z_asm_ldx:
.a64e						xt_asm_ldx_h:
.a64e		a9 a2		lda #$a2	                lda #$A2
.a650		4c d4 a7	jmp $a7d4	                jmp asm_common
.a653						z_asm_ldx_h:
.a653						xt_asm_ldx_y:
.a653		a9 be		lda #$be	                lda #$BE
.a655		4c d4 a7	jmp $a7d4	                jmp asm_common
.a658						z_asm_ldx_y:
.a658						xt_asm_ldx_z:
.a658		a9 a6		lda #$a6	                lda #$A6
.a65a		4c d4 a7	jmp $a7d4	                jmp asm_common
.a65d						z_asm_ldx_z:
.a65d						xt_asm_ldx_zy:
.a65d		a9 b6		lda #$b6	                lda #$B6
.a65f		4c d4 a7	jmp $a7d4	                jmp asm_common
.a662						z_asm_ldx_zy:
.a662						xt_asm_ldy:
.a662		a9 ac		lda #$ac	                lda #$AC
.a664		4c d4 a7	jmp $a7d4	                jmp asm_common
.a667						z_asm_ldy:
.a667						xt_asm_ldy_h:
.a667		a9 a0		lda #$a0	                lda #$A0
.a669		4c d4 a7	jmp $a7d4	                jmp asm_common
.a66c						z_asm_ldy_h:
.a66c						xt_asm_ldy_x:
.a66c		a9 bc		lda #$bc	                lda #$BC
.a66e		4c d4 a7	jmp $a7d4	                jmp asm_common
.a671						z_asm_ldy_x:
.a671						xt_asm_ldy_z:
.a671		a9 a4		lda #$a4	                lda #$A4
.a673		4c d4 a7	jmp $a7d4	                jmp asm_common
.a676						z_asm_ldy_z:
.a676						xt_asm_ldy_zx:
.a676		a9 b4		lda #$b4	                lda #$B4
.a678		4c d4 a7	jmp $a7d4	                jmp asm_common
.a67b						z_asm_ldy_zx:
.a67b						xt_asm_lsr:
.a67b		a9 4e		lda #$4e	                lda #$4E
.a67d		4c d4 a7	jmp $a7d4	                jmp asm_common
.a680						z_asm_lsr:
.a680						xt_asm_lsr_a:
.a680		a9 4a		lda #$4a	                lda #$4A
.a682		4c d4 a7	jmp $a7d4	                jmp asm_common
.a685						z_asm_lsr_a:
.a685						xt_asm_lsr_x:
.a685		a9 5e		lda #$5e	                lda #$5E
.a687		4c d4 a7	jmp $a7d4	                jmp asm_common
.a68a						z_asm_lsr_x:
.a68a						xt_asm_lsr_z:
.a68a		a9 46		lda #$46	                lda #$46
.a68c		4c d4 a7	jmp $a7d4	                jmp asm_common
.a68f						z_asm_lsr_z:
.a68f						xt_asm_lsr_zx:
.a68f		a9 56		lda #$56	                lda #$56
.a691		4c d4 a7	jmp $a7d4	                jmp asm_common
.a694						z_asm_lsr_zx:
.a694						xt_asm_nop:
.a694		a9 ea		lda #$ea	                lda #$EA
.a696		4c d4 a7	jmp $a7d4	                jmp asm_common
.a699						z_asm_nop:
.a699						xt_asm_ora:
.a699		a9 0d		lda #$0d	                lda #$0D
.a69b		4c d4 a7	jmp $a7d4	                jmp asm_common
.a69e						z_asm_ora:
.a69e						xt_asm_ora_h:
.a69e		a9 09		lda #$09	                lda #$09
.a6a0		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6a3						z_asm_ora_h:
.a6a3						xt_asm_ora_x:
.a6a3		a9 1d		lda #$1d	                lda #$1D
.a6a5		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6a8						z_asm_ora_x:
.a6a8						xt_asm_ora_y:
.a6a8		a9 19		lda #$19	                lda #$19
.a6aa		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6ad						z_asm_ora_y:
.a6ad						xt_asm_ora_z:
.a6ad		a9 05		lda #$05	                lda #$05
.a6af		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6b2						z_asm_ora_z:
.a6b2						xt_asm_ora_zi:
.a6b2		a9 12		lda #$12	                lda #$12
.a6b4		a0 02		ldy #$02	                ldy #2
.a6b6		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6b9						z_asm_ora_zi:
.a6b9						xt_asm_ora_ziy:
.a6b9		a9 11		lda #$11	                lda #$11
.a6bb		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6be						z_asm_ora_ziy:
.a6be						xt_asm_ora_zx:
.a6be		a9 15		lda #$15	                lda #$15
.a6c0		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6c3						z_asm_ora_zx:
.a6c3						xt_asm_ora_zxi:
.a6c3		a9 01		lda #$01	                lda #$01
.a6c5		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6c8						z_asm_ora_zxi:
.a6c8						xt_asm_pha:
.a6c8		a9 48		lda #$48	                lda #$48
.a6ca		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6cd						z_asm_pha:
.a6cd						xt_asm_php:
.a6cd		a9 08		lda #$08	                lda #$08
.a6cf		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6d2						z_asm_php:
.a6d2						xt_asm_phx:
.a6d2		a9 da		lda #$da	                lda #$DA
.a6d4		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6d7						z_asm_phx:
.a6d7						xt_asm_phy:
.a6d7		a9 5a		lda #$5a	                lda #$5A
.a6d9		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6dc						z_asm_phy:
.a6dc						xt_asm_pla:
.a6dc		a9 68		lda #$68	                lda #$68
.a6de		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6e1						z_asm_pla:
.a6e1						xt_asm_plp:
.a6e1		a9 28		lda #$28	                lda #$28
.a6e3		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6e6						z_asm_plp:
.a6e6						xt_asm_plx:
.a6e6		a9 fa		lda #$fa	                lda #$FA
.a6e8		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6eb						z_asm_plx:
.a6eb						xt_asm_ply:
.a6eb		a9 7a		lda #$7a	                lda #$7A
.a6ed		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6f0						z_asm_ply:
.a6f0						xt_asm_rol:
.a6f0		a9 2e		lda #$2e	                lda #$2E
.a6f2		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6f5						z_asm_rol:
.a6f5						xt_asm_rol_a:
.a6f5		a9 2a		lda #$2a	                lda #$2A
.a6f7		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6fa						z_asm_rol_a:
.a6fa						xt_asm_rol_x:
.a6fa		a9 3e		lda #$3e	                lda #$3E
.a6fc		4c d4 a7	jmp $a7d4	                jmp asm_common
.a6ff						z_asm_rol_x:
.a6ff						xt_asm_rol_z:
.a6ff		a9 26		lda #$26	                lda #$26
.a701		4c d4 a7	jmp $a7d4	                jmp asm_common
.a704						z_asm_rol_z:
.a704						xt_asm_rol_zx:
.a704		a9 36		lda #$36	                lda #$36
.a706		4c d4 a7	jmp $a7d4	                jmp asm_common
.a709						z_asm_rol_zx:
.a709						xt_asm_ror:
.a709		a9 6e		lda #$6e	                lda #$6E
.a70b		4c d4 a7	jmp $a7d4	                jmp asm_common
.a70e						z_asm_ror:
.a70e						xt_asm_ror_a:
.a70e		a9 6a		lda #$6a	                lda #$6A
.a710		4c d4 a7	jmp $a7d4	                jmp asm_common
.a713						z_asm_ror_a:
.a713						xt_asm_ror_x:
.a713		a9 7e		lda #$7e	                lda #$7E
.a715		4c d4 a7	jmp $a7d4	                jmp asm_common
.a718						z_asm_ror_x:
.a718						xt_asm_ror_z:
.a718		a9 66		lda #$66	                lda #$66
.a71a		4c d4 a7	jmp $a7d4	                jmp asm_common
.a71d						z_asm_ror_z:
.a71d						xt_asm_ror_zx:
.a71d		a9 76		lda #$76	                lda #$76
.a71f		4c d4 a7	jmp $a7d4	                jmp asm_common
.a722						z_asm_ror_zx:
.a722						xt_asm_rti:
.a722		a9 40		lda #$40	                lda #$40
.a724		4c d4 a7	jmp $a7d4	                jmp asm_common
.a727						z_asm_rti:
.a727						xt_asm_rts:
.a727		a9 60		lda #$60	                lda #$60
.a729		4c d4 a7	jmp $a7d4	                jmp asm_common
.a72c						z_asm_rts:
.a72c						xt_asm_sbc:
.a72c		a9 ed		lda #$ed	                lda #$ED
.a72e		4c d4 a7	jmp $a7d4	                jmp asm_common
.a731						z_asm_sbc:
.a731						xt_asm_sbc_h:
.a731		a9 e9		lda #$e9	                lda #$E9
.a733		4c d4 a7	jmp $a7d4	                jmp asm_common
.a736						z_asm_sbc_h:
.a736						xt_asm_sbc_x:
.a736		a9 fd		lda #$fd	                lda #$FD
.a738		4c d4 a7	jmp $a7d4	                jmp asm_common
.a73b						z_asm_sbc_x:
.a73b						xt_asm_sbc_y:
.a73b		a9 f9		lda #$f9	                lda #$F9
.a73d		4c d4 a7	jmp $a7d4	                jmp asm_common
.a740						z_asm_sbc_y:
.a740						xt_asm_sbc_z:
.a740		a9 e5		lda #$e5	                lda #$E5
.a742		4c d4 a7	jmp $a7d4	                jmp asm_common
.a745						z_asm_sbc_z:
.a745						xt_asm_sbc_zi:
.a745		a9 f2		lda #$f2	                lda #$F2
.a747		4c d4 a7	jmp $a7d4	                jmp asm_common
.a74a						z_asm_sbc_zi:
.a74a						xt_asm_sbc_ziy:
.a74a		a9 f1		lda #$f1	                lda #$F1
.a74c		4c d4 a7	jmp $a7d4	                jmp asm_common
.a74f						z_asm_sbc_ziy:
.a74f						xt_asm_sbc_zx:
.a74f		a9 f5		lda #$f5	                lda #$F5
.a751		4c d4 a7	jmp $a7d4	                jmp asm_common
.a754						z_asm_sbc_zx:
.a754						xt_asm_sbc_zxi:
.a754		a9 e1		lda #$e1	                lda #$E1
.a756		80 7c		bra $a7d4	                bra asm_common  ; <-- limit for BRA instead of JMP
.a758						z_asm_sbc_zxi:
.a758						xt_asm_sec:
.a758		a9 38		lda #$38	                lda #$38
.a75a		80 78		bra $a7d4	                bra asm_common
.a75c						z_asm_sec:
.a75c						xt_asm_sed:
.a75c		a9 f8		lda #$f8	                lda #$F8
.a75e		80 74		bra $a7d4	                bra asm_common
.a760						z_asm_sed:
.a760						xt_asm_sei:
.a760		a9 78		lda #$78	                lda #$78
.a762		80 70		bra $a7d4	                bra asm_common
.a764						z_asm_sei:
.a764						xt_asm_sta:
.a764		a9 8d		lda #$8d	                lda #$8D
.a766		80 6c		bra $a7d4	                bra asm_common
.a768						z_asm_sta:
.a768						xt_asm_sta_x:
.a768		a9 9d		lda #$9d	                lda #$9D
.a76a		80 68		bra $a7d4	                bra asm_common
.a76c						z_asm_sta_x:
.a76c						xt_asm_sta_y:
.a76c		a9 99		lda #$99	                lda #$99
.a76e		80 64		bra $a7d4	                bra asm_common
.a770						z_asm_sta_y:
.a770						xt_asm_sta_z:
.a770		a9 85		lda #$85	                lda #$85
.a772		80 60		bra $a7d4	                bra asm_common
.a774						z_asm_sta_z:
.a774						xt_asm_sta_zi:
.a774		a9 92		lda #$92	                lda #$92
.a776		80 5c		bra $a7d4	                bra asm_common
.a778						z_asm_sta_zi:
.a778						xt_asm_sta_ziy:
.a778		a9 91		lda #$91	                lda #$91
.a77a		80 58		bra $a7d4	                bra asm_common
.a77c						z_asm_sta_ziy:
.a77c						xt_asm_sta_zx:
.a77c		a9 95		lda #$95	                lda #$95
.a77e		80 54		bra $a7d4	                bra asm_common
.a780						z_asm_sta_zx:
.a780						xt_asm_sta_zxi:
.a780		a9 81		lda #$81	                lda #$81
.a782		80 50		bra $a7d4	                bra asm_common
.a784						z_asm_sta_zxi:
.a784						xt_asm_stx:
.a784		a9 8e		lda #$8e	                lda #$8E
.a786		80 4c		bra $a7d4	                bra asm_common
.a788						z_asm_stx:
.a788						xt_asm_stx_z:
.a788		a9 86		lda #$86	                lda #$86
.a78a		80 48		bra $a7d4	                bra asm_common
.a78c						z_asm_stx_z:
.a78c						xt_asm_stx_zy:
.a78c		a9 96		lda #$96	                lda #$96
.a78e		80 44		bra $a7d4	                bra asm_common
.a790						z_asm_stx_zy:
.a790						xt_asm_sty:
.a790		a9 8c		lda #$8c	                lda #$8C
.a792		80 40		bra $a7d4	                bra asm_common
.a794						z_asm_sty:
.a794						xt_asm_sty_z:
.a794		a9 84		lda #$84	                lda #$84
.a796		80 3c		bra $a7d4	                bra asm_common
.a798						z_asm_sty_z:
.a798						xt_asm_sty_zx:
.a798		a9 94		lda #$94	                lda #$94
.a79a		80 38		bra $a7d4	                bra asm_common
.a79c						z_asm_sty_zx:
.a79c						xt_asm_stz:
.a79c		a9 9c		lda #$9c	                lda #$9C
.a79e		80 34		bra $a7d4	                bra asm_common
.a7a0						z_asm_stz:
.a7a0						xt_asm_stz_x:
.a7a0		a9 9e		lda #$9e	                lda #$9E
.a7a2		80 30		bra $a7d4	                bra asm_common
.a7a4						z_asm_stz_x:
.a7a4						xt_asm_stz_z:
.a7a4		a9 64		lda #$64	                lda #$64
.a7a6		80 2c		bra $a7d4	                bra asm_common
.a7a8						z_asm_stz_z:
.a7a8						xt_asm_stz_zx:
.a7a8		a9 74		lda #$74	                lda #$74
.a7aa		80 28		bra $a7d4	                bra asm_common
.a7ac						z_asm_stz_zx:
.a7ac						xt_asm_tax:
.a7ac		a9 aa		lda #$aa	                lda #$AA
.a7ae		80 24		bra $a7d4	                bra asm_common
.a7b0						z_asm_tax:
.a7b0						xt_asm_tay:
.a7b0		a9 a8		lda #$a8	                lda #$A8
.a7b2		80 20		bra $a7d4	                bra asm_common
.a7b4						z_asm_tay:
.a7b4						xt_asm_trb:
.a7b4		a9 1c		lda #$1c	                lda #$1C
.a7b6		80 1c		bra $a7d4	                bra asm_common
.a7b8						z_asm_trb:
.a7b8						xt_asm_trb_z:
.a7b8		a9 14		lda #$14	                lda #$14
.a7ba		80 18		bra $a7d4	                bra asm_common
.a7bc						z_asm_trb_z:
.a7bc						xt_asm_tsb:
.a7bc		a9 0c		lda #$0c	                lda #$0C
.a7be		80 14		bra $a7d4	                bra asm_common
.a7c0						z_asm_tsb:
.a7c0						xt_asm_tsb_z:
.a7c0		a9 04		lda #$04	                lda #$04
.a7c2		80 10		bra $a7d4	                bra asm_common
.a7c4						z_asm_tsb_z:
.a7c4						xt_asm_tsx:
.a7c4		a9 ba		lda #$ba	                lda #$BA
.a7c6		80 0c		bra $a7d4	                bra asm_common
.a7c8						z_asm_tsx:
.a7c8						xt_asm_txa:
.a7c8		a9 8a		lda #$8a	                lda #$8A
.a7ca		80 08		bra $a7d4	                bra asm_common
.a7cc						z_asm_txa:
.a7cc						xt_asm_txs:
.a7cc		a9 9a		lda #$9a	                lda #$9A
.a7ce		80 04		bra $a7d4	                bra asm_common
.a7d0						z_asm_txs:
.a7d0						xt_asm_tya:
.a7d0		a9 98		lda #$98	                lda #$98
.a7d2		80 00		bra $a7d4	                bra asm_common
.a7d4						z_asm_tya:
.a7d4						asm_common:
.a7d4		a8		tay		                tay
.a7d5		20 bc 97	jsr $97bc	                jsr cmpl_a
.a7d8		a9 e0		lda #$e0	                lda #<oc_index_table
.a7da		85 27		sta $27		                sta tmp2
.a7dc		a9 b3		lda #$b3	                lda #>oc_index_table
.a7de		85 28		sta $28		                sta tmp2+1
.a7e0		98		tya		                tya             ; retrieve opcode
.a7e1		0a		asl a		                asl             ; times two for offset
.a7e2		90 02		bcc $a7e6	                bcc +
.a7e4		e6 28		inc $28		                inc tmp2+1
.a7e6						+
.a7e6		a8		tay		                tay             ; use Y as the index
.a7e7		b1 27		lda ($27),y	                lda (tmp2),y    ; LSB
.a7e9		85 29		sta $29		                sta tmp3
.a7eb		c8		iny		                iny
.a7ec		b1 27		lda ($27),y	                lda (tmp2),y    ; MSB
.a7ee		85 2a		sta $2a		                sta tmp3+1
.a7f0		b2 29		lda ($29)	                lda (tmp3)      ; get "lengths byte"
.a7f2		2a		rol a		                rol
.a7f3		2a		rol a		                rol
.a7f4		2a		rol a		                rol             ; Three times because we go through Carry
.a7f5		29 03		and #$03	                and #%00000011
.a7f7		a8		tay		                tay
.a7f8		88		dey		                dey
.a7f9		f0 12		beq $a80d	                beq _done
.a7fb		20 d4 d7	jsr $d7d4	                jsr underflow_1
.a7fe		b5 00		lda $00,x	                lda 0,x
.a800		20 bc 97	jsr $97bc	                jsr cmpl_a      ; does not use Y
.a803		88		dey		                dey
.a804		f0 05		beq $a80b	                beq _done_drop
.a806		b5 01		lda $01,x	                lda 1,x
.a808		20 bc 97	jsr $97bc	                jsr cmpl_a      ; Fall through to _done_drop
.a80b						_done_drop:
.a80b		e8		inx		                inx
.a80c		e8		inx		                inx             ; Fall through to _done
.a80d						_done:
.a80d		60		rts		                rts             ; Returns to original caller
.a80e						xt_asm_push_a:
.a80e		a0 00		ldy #$00	                ldy #0
.a810						_loop:
.a810		b9 74 a4	lda $a474,y	                lda push_a_tos,y
.a813		20 bc 97	jsr $97bc	                jsr cmpl_a      ; does not change Y
.a816		c8		iny		                iny
.a817		c0 06		cpy #$06	                cpy #z_push_a_tos - push_a_tos
.a819		d0 f5		bne $a810	                bne _loop
.a81b						_done:
.a81b						z_asm_push_a:
.a81b		60		rts		                rts
.a81c						xt_asm_back_jump:
.a81c						z_asm_back_jump:
.a81c		60		rts		                rts
.a81d						xt_asm_back_branch:
.a81d		20 e7 88	jsr $88e7	                jsr w_here             ; ( addr-l addr-h )
.a820		20 bb 8b	jsr $8bbb	                jsr w_minus            ; ( offset )
.a823		3a		dec a		                dea
.a824		3a		dec a		                dea
.a825						z_asm_back_branch:
.a825		60		rts		                rts
.a826						assembler_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/ed.asm

.a826						xt_ed:
.a826						w_ed:
.a826		20 2a a8	jsr $a82a	                jsr ed6502      ; kept in separate file
.a829		60		rts		z_ed:           rts
=$0035						ed_head  = tmped    ; pointer to first list element (addr) (2 bytes)
=$0037						ed_cur   = tmped+2  ; current line number (1 is first line) (2 bytes)
=$0039						ed_flags = tmped+4  ; Flags used by ed, where
=$003a						ed_base  = tmped+5  ; used to hold BASE and put it back at the end.
.a82a						ed6502:
.a82a		a5 18		lda $18		                lda base
.a82c		85 3a		sta $3a		                sta ed_base
.a82e		a9 0a		lda #$0a	                lda #10
.a830		85 18		sta $18		                sta base
.a832		64 35		stz $35		                stz ed_head
.a834		64 36		stz $36		                stz ed_head+1
.a836		64 37		stz $37		                stz ed_cur
.a838		64 38		stz $38		                stz ed_cur+1
.a83a		64 39		stz $39		                stz ed_flags
.a83c		20 66 9e	jsr $9e66	                jsr w_zero
.a83f		20 66 9e	jsr $9e66	                jsr w_zero             ; ( addr-t u-t )
.a842		20 ec 83	jsr $83ec	                jsr w_cr
.a845						ed_input_loop:
.a845		a9 81		lda #$81	                lda #%10000001
.a847		14 39		trb $39		                trb ed_flags
.a849		20 24 ad	jsr $ad24	                jsr ed_get_input
.a84c		a5 0e		lda $0e		                lda ciblen
.a84e		d0 1f		bne $a86f	                bne _command_mode
.a850		ca		dex		                dex
.a851		ca		dex		                dex                     ; ( addr-t u-t ? )
.a852		a5 37		lda $37		                lda ed_cur
.a854		95 00		sta $00,x	                sta 0,x
.a856		a5 38		lda $38		                lda ed_cur+1
.a858		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t u )
.a85a		a9 80		lda #$80	                lda #%10000000
.a85c		04 39		tsb $39		                tsb ed_flags
.a85e		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; ( addr-t u-t u+1 )
.a861		20 40 ad	jsr $ad40	                jsr ed_is_valid_line
.a864		b0 03		bcs $a869	                bcs +
.a866		4c 14 ad	jmp $ad14	                jmp ed_error_1drop
.a869						+
.a869		20 66 9e	jsr $9e66	                jsr w_zero             ; ( addr-t u-t u+1 0 )
.a86c		4c 3a a9	jmp $a93a	                jmp _line_number_only_from_external
.a86f						_command_mode:
.a86f		20 66 9e	jsr $9e66	                jsr w_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
.a872		20 66 9e	jsr $9e66	                jsr w_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
.a875		b2 0c		lda ($0c)	                lda (cib)
.a877		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII '.'
.a879		d0 3a		bne $a8b5	                bne _prefix_dollar
.a87b		20 35 ad	jsr $ad35	                jsr ed_have_text
.a87e		a5 37		lda $37		                lda ed_cur
.a880		95 02		sta $02,x	                sta 2,x
.a882		a5 38		lda $38		                lda ed_cur+1
.a884		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a886		a9 80		lda #$80	                lda #%10000000
.a888		04 39		tsb $39		                tsb ed_flags
.a88a		a5 0e		lda $0e		                lda ciblen
.a88c		3a		dec a		                dea                     ; sets Z if A was 1
.a88d		d0 03		bne $a892	                bne +
.a88f		4c 3a a9	jmp $a93a	                jmp _line_number_only_from_external
.a892						+
.a892		ca		dex		                dex
.a893		ca		dex		                dex
.a894		ca		dex		                dex
.a895		ca		dex		                dex
.a896		a5 0c		lda $0c		                lda cib
.a898		95 02		sta $02,x	                sta 2,x
.a89a		a5 0d		lda $0d		                lda cib+1
.a89c		95 03		sta $03,x	                sta 3,x
.a89e		a5 0e		lda $0e		                lda ciblen
.a8a0		95 00		sta $00,x	                sta 0,x
.a8a2		a5 0f		lda $0f		                lda ciblen+1
.a8a4		95 01		sta $01,x	                sta 1,x
.a8a6		20 b3 8c	jsr $8cb3	                jsr w_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
.a8a9		20 1e 92	jsr $921e	                jsr w_swap             ; ( addr-t u-t para1 0 u-1 addr )
.a8ac		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
.a8af		20 1e 92	jsr $921e	                jsr w_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
.a8b2		4c 92 a9	jmp $a992	                jmp _check_for_para2
.a8b5						_prefix_dollar:
.a8b5		b2 0c		lda ($0c)	                lda (cib)
.a8b7		c9 24		cmp #$24	                cmp #'$'
.a8b9		d0 1c		bne $a8d7	                bne _prefix_percent
.a8bb		20 35 ad	jsr $ad35	                jsr ed_have_text
.a8be		e8		inx		                inx
.a8bf		e8		inx		                inx                     ; ( addr-t u-t 0 )
.a8c0		20 62 ad	jsr $ad62	                jsr ed_last_line          ; ( addr-t u-t 0 para1 )
.a8c3		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr-t u-t para1 0 )
.a8c6		a9 80		lda #$80	                lda #%10000000
.a8c8		04 39		tsb $39		                tsb ed_flags
.a8ca		a5 0e		lda $0e		                lda ciblen
.a8cc		3a		dec a		                dea                     ; sets Z if A was 1
.a8cd		d0 03		bne $a8d2	                bne +
.a8cf		4c 3a a9	jmp $a93a	                jmp _line_number_only_from_external
.a8d2						+
.a8d2		a0 01		ldy #$01	                ldy #01
.a8d4		4c 0e aa	jmp $aa0e	                jmp _check_command
.a8d7						_prefix_percent:
.a8d7		b2 0c		lda ($0c)	                lda (cib)
.a8d9		c9 25		cmp #$25	                cmp #'%'                ; ASCII '%'
.a8db		f0 04		beq $a8e1	                beq _whole_text
.a8dd		c9 2c		cmp #$2c	                cmp #','                ; ASCII ','
.a8df		d0 17		bne $a8f8	                bne _prefix_semicolon
.a8e1						_whole_text:
.a8e1		20 35 ad	jsr $ad35	                jsr ed_have_text
.a8e4		a9 01		lda #$01	                lda #01
.a8e6		95 02		sta $02,x	                sta 2,x                 ; LSB of NOS is para 1
.a8e8		74 03		stz $03,x	                stz 3,x                 ; ( addr-t u-t para1 0 )
.a8ea						_semicolon_entry:
.a8ea		e8		inx		                inx
.a8eb		e8		inx		                inx                     ; DROP ( addr-t u-t para1 )
.a8ec		20 62 ad	jsr $ad62	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a8ef		a9 80		lda #$80	                lda #%10000000
.a8f1		04 39		tsb $39		                tsb ed_flags
.a8f3		a0 01		ldy #$01	                ldy #01
.a8f5		4c 0e aa	jmp $aa0e	                jmp _check_command
.a8f8						_prefix_semicolon:
.a8f8		b2 0c		lda ($0c)	                lda (cib)
.a8fa		c9 3b		cmp #$3b	                cmp #';'                ; ASCII ';'
.a8fc		d0 0d		bne $a90b	                bne _prefix_number
.a8fe		20 35 ad	jsr $ad35	                jsr ed_have_text
.a901		a5 37		lda $37		                lda ed_cur
.a903		95 02		sta $02,x	                sta 2,x
.a905		a5 38		lda $38		                lda ed_cur+1
.a907		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t cur 0 )
.a909		80 df		bra $a8ea	                bra _semicolon_entry
.a90b						_prefix_number:
.a90b		20 66 9e	jsr $9e66	                jsr w_zero
.a90e		20 66 9e	jsr $9e66	                jsr w_zero             ; ( addr-t u-t 0 0 0 0 )
.a911		ca		dex		                dex
.a912		ca		dex		                dex
.a913		ca		dex		                dex
.a914		ca		dex		                dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
.a915		a5 0c		lda $0c		                lda cib
.a917		95 02		sta $02,x	                sta 2,x
.a919		a5 0d		lda $0d		                lda cib+1
.a91b		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
.a91d		a5 0e		lda $0e		                lda ciblen
.a91f		95 00		sta $00,x	                sta 0,x
.a921		a5 0f		lda $0f		                lda ciblen+1
.a923		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
.a925		20 bc 92	jsr $92bc	                jsr w_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
.a928		b5 00		lda $00,x	                lda 0,x
.a92a		15 01		ora $01,x	                ora 1,x
.a92c		d0 24		bne $a952	                bne _have_unconverted_chars
.a92e		e8		inx		                inx
.a92f		e8		inx		                inx
.a930		e8		inx		                inx
.a931		e8		inx		                inx                     ; 2DROP ( addr-t u-t 0 0 ud )
.a932		20 b2 9e	jsr $9eb2	                jsr w_d_to_s           ; D>S ( addr-t u-t 0 0 u )
.a935		20 ed 9c	jsr $9ced	                jsr w_not_rot          ; -ROT ( addr-t u-t u 0 0 )
.a938		e8		inx		                inx
.a939		e8		inx		                inx                     ; ( addr-t u-t u 0 ) drop through
.a93a						_line_number_only_from_external:
.a93a		20 1e 92	jsr $921e	                jsr w_swap             ; ( addr-t u-t 0 u )
.a93d		20 40 ad	jsr $ad40	                jsr ed_is_valid_line
.a940		b0 03		bcs $a945	                bcs +
.a942		4c 12 ad	jmp $ad12	                jmp ed_error_2drop
.a945						+
.a945		20 1e 92	jsr $921e	                jsr w_swap             ; ( addr-t u-t u 0 )
.a948		20 cf ad	jsr $adcf	                jsr ed_para1_to_cur
.a94b		a9 80		lda #$80	                lda #%10000000
.a94d		04 39		tsb $39		                tsb ed_flags
.a94f		4c ed ab	jmp $abed	                jmp ed_cmd_p_from_external
.a952						_have_unconverted_chars:
.a952		20 5c 86	jsr $865c	                jsr w_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
.a955		ca		dex		                dex
.a956		ca		dex		                dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
.a957		a5 0e		lda $0e		                lda ciblen
.a959		95 00		sta $00,x	                sta 0,x
.a95b		a5 0f		lda $0f		                lda ciblen+1
.a95d		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
.a95f		20 5d 87	jsr $875d	                jsr w_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
.a962		b5 00		lda $00,x	                lda 0,x
.a964		15 01		ora $01,x	                ora 1,x
.a966		f0 0e		beq $a976	                beq _no_command_yet
.a968		8a		txa		                txa
.a969		18		clc		                clc
.a96a		69 0a		adc #$0a	                adc #10
.a96c		aa		tax		                tax                     ; ( addr-t u-t 0 0 )
.a96d		a9 80		lda #$80	                lda #%10000000
.a96f		14 39		trb $39		                trb ed_flags
.a971		a0 00		ldy #$00	                ldy #00
.a973		4c 0e aa	jmp $aa0e	                jmp _check_command
.a976						_no_command_yet:
.a976		e8		inx		                inx
.a977		e8		inx		                inx                     ; ( ... 0 0 ud addr2 u2 )
.a978		20 59 93	jsr $9359	                jsr w_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
.a97b		20 ed 9c	jsr $9ced	                jsr w_not_rot          ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.a97e		20 b2 9e	jsr $9eb2	                jsr w_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.a981		b5 00		lda $00,x	                lda 0,x                 ; LSB
.a983		95 06		sta $06,x	                sta 6,x
.a985		b5 01		lda $01,x	                lda 1,x                 ; MSB
.a987		95 07		sta $07,x	                sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
.a989		e8		inx		                inx
.a98a		e8		inx		                inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
.a98b		20 b5 8e	jsr $8eb5	                jsr w_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.a98e		a9 80		lda #$80	                lda #%10000000
.a990		04 39		tsb $39		                tsb ed_flags
.a992						_check_for_para2:
.a992		a1 02		lda ($02,x)	                lda (2,x)
.a994		c9 2c		cmp #$2c	                cmp #','                ; ASCII code for ',' (comma)
.a996		f0 0d		beq $a9a5	                beq _got_comma
.a998		38		sec		                sec
.a999		a5 0e		lda $0e		                lda ciblen
.a99b		f5 00		sbc $00,x	                sbc 0,x
.a99d		a8		tay		                tay
.a99e		e8		inx		                inx
.a99f		e8		inx		                inx
.a9a0		e8		inx		                inx
.a9a1		e8		inx		                inx                     ; 2DROP ( addr-t u-t para1 0 )
.a9a2		4c 0e aa	jmp $aa0e	                jmp _check_command
.a9a5						_got_comma:
.a9a5		f6 02		inc $02,x	                inc 2,x
.a9a7		d0 02		bne $a9ab	                bne +
.a9a9		f6 03		inc $03,x	                inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
.a9ab						+
.a9ab		b5 01		lda $01,x	                lda 1,x
.a9ad		f0 02		beq $a9b1	                beq +
.a9af		d6 01		dec $01,x	                dec 1,x
.a9b1						+
.a9b1		d6 00		dec $00,x	                dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
.a9b3		a1 02		lda ($02,x)	                lda (2,x)
.a9b5		c9 24		cmp #$24	                cmp #$24                ; ASCII for '$'
.a9b7		d0 14		bne $a9cd	                bne _para2_not_dollar
.a9b9		38		sec		                sec
.a9ba		a5 0e		lda $0e		                lda ciblen
.a9bc		f5 02		sbc $02,x	                sbc 2,x
.a9be		a8		tay		                tay
.a9bf		c8		iny		                iny
.a9c0		5a		phy		                phy
.a9c1		8a		txa		                txa
.a9c2		18		clc		                clc
.a9c3		69 06		adc #$06	                adc #06
.a9c5		aa		tax		                tax                     ; ( addr-t u-t para1 )
.a9c6		20 62 ad	jsr $ad62	                jsr ed_last_line          ; ( addr-t u-t para1 para2 )
.a9c9		7a		ply		                ply
.a9ca		4c 0e aa	jmp $aa0e	                jmp _check_command
.a9cd						_para2_not_dollar:
.a9cd		20 59 93	jsr $9359	                jsr w_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.a9d0		20 66 9e	jsr $9e66	                jsr w_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.a9d3		20 66 9e	jsr $9e66	                jsr w_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.a9d6		20 5c 8f	jsr $8f5c	                jsr w_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.a9d9		20 b5 8e	jsr $8eb5	                jsr w_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
.a9dc		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.a9df		20 59 93	jsr $9359	                jsr w_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.a9e2		20 bc 92	jsr $92bc	                jsr w_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.a9e5		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.a9e8		20 b5 8e	jsr $8eb5	                jsr w_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.a9eb		20 5d 87	jsr $875d	                jsr w_equal            ; = ( ... para1 0 ud addr3 u3 f )
.a9ee		b5 00		lda $00,x	                lda 0,x
.a9f0		15 01		ora $01,x	                ora 1,x
.a9f2		f0 08		beq $a9fc	                beq _second_number
.a9f4		8a		txa		                txa
.a9f5		18		clc		                clc
.a9f6		69 0c		adc #$0c	                adc #12
.a9f8		aa		tax		                tax                     ; back to ( addr-t u-t )
.a9f9		4c 16 ad	jmp $ad16	                jmp ed_error
.a9fc						_second_number:
.a9fc		e8		inx		                inx
.a9fd		e8		inx		                inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
.a9fe		38		sec		                sec
.a9ff		a5 0e		lda $0e		                lda ciblen
.aa01		f5 00		sbc $00,x	                sbc 0,x
.aa03		48		pha		                pha
.aa04		20 97 93	jsr $9397	                jsr w_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
.aa07		20 b2 9e	jsr $9eb2	                jsr w_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
.aa0a		20 0a 8c	jsr $8c0a	                jsr w_nip              ; NIP ( addr-t u-t para1 para2 )
.aa0d		7a		ply		                ply
.aa0e						_check_command:
.aa0e		24 39		bit $39		                bit ed_flags
.aa10		30 08		bmi $aa1a	                bmi _check_command_have_arg
.aa12		a5 37		lda $37		                lda ed_cur
.aa14		95 02		sta $02,x	                sta 2,x
.aa16		a5 38		lda $38		                lda ed_cur+1
.aa18		95 03		sta $03,x	                sta 3,x
.aa1a						_check_command_have_arg:
.aa1a		b1 0c		lda ($0c),y	                lda (cib),y             ; get mystery char from input
.aa1c		85 25		sta $25		                sta tmp1
.aa1e		da		phx		                phx
.aa1f		a2 00		ldx #$00	                ldx #00
.aa21						_cmd_loop:
.aa21		bd fa ad	lda $adfa,x	                lda ed_cmd_list,x
.aa24		f0 07		beq $aa2d	                beq _illegal_command    ; zero marks end of list
.aa26		c5 25		cmp $25		                cmp tmp1
.aa28		f0 07		beq $aa31	                beq _found_cmd
.aa2a		e8		inx		                inx
.aa2b		80 f4		bra $aa21	                bra _cmd_loop
.aa2d						_illegal_command:
.aa2d		fa		plx		                plx
.aa2e		4c 12 ad	jmp $ad12	                jmp ed_error_2drop
.aa31						_found_cmd:
.aa31		8a		txa		                txa
.aa32		0a		asl a		                asl
.aa33		aa		tax		                tax                     ; X * 2 for table
.aa34		7c 05 ae	jmp ($ae05,x)	                jmp (ed_cmd_table,x)
.aa37						ed_next_command:
.aa37		e8		inx		                inx
.aa38		e8		inx		                inx
.aa39		e8		inx		                inx
.aa3a		e8		inx		                inx                     ; ( addr-t u-t ) Fall through
.aa3b		4c 45 a8	jmp $a845	                jmp ed_input_loop
.aa3e						ed_all_done:
.aa3e		64 0e		stz $0e		                stz ciblen
.aa40		64 0f		stz $0f		                stz ciblen+1
.aa42		20 97 93	jsr $9397	                jsr w_two_drop                 ; 2DROP ( addr-t u-t )
.aa45		a5 3a		lda $3a		                lda ed_base
.aa47		85 18		sta $18		                sta base
.aa49		60		rts		                rts
.aa4a						ed_cmd_a:
.aa4a		fa		plx		                plx
.aa4b		e8		inx		                inx
.aa4c		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.aa4d						ed_entry_cmd_i:
.aa4d		20 98 ad	jsr $ad98	                jsr ed_num_to_addr        ;  ( addr-t u-t addr1 )
.aa50		20 ec 83	jsr $83ec	                jsr w_cr
.aa53						_next_string_loop:
.aa53		20 24 ad	jsr $ad24	                jsr ed_get_input
.aa56		b2 0c		lda ($0c)	                lda (cib)
.aa58		c9 2e		cmp #$2e	                cmp #'.'                ; ASCII for '.'
.aa5a		d0 16		bne $aa72	                bne _add_line
.aa5c		a4 0e		ldy $0e		                ldy ciblen
.aa5e		c0 01		cpy #$01	                cpy #01
.aa60		d0 10		bne $aa72	                bne _add_line
.aa62		a4 0f		ldy $0f		                ldy ciblen+1
.aa64		d0 0c		bne $aa72	                bne _add_line
.aa66		e8		inx		                inx
.aa67		e8		inx		                inx
.aa68		a9 40		lda #$40	                lda #%01000000
.aa6a		04 39		tsb $39		                tsb ed_flags
.aa6c		20 ec 83	jsr $83ec	                jsr w_cr
.aa6f		4c 45 a8	jmp $a845	                jmp ed_input_loop
.aa72						_add_line:
.aa72		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( addr-t u-t addr1 addr1 )
.aa75		20 e7 88	jsr $88e7	                jsr w_here             ; HERE ( addr-t u-t addr1 addr1 here )
.aa78		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
.aa7b		20 e9 87	jsr $87e9	                jsr w_fetch            ; @  ( addr-t u-t addr1 here addr2 )
.aa7e		20 ae 83	jsr $83ae	                jsr w_comma            ; ,  ( addr-t u-t addr1 here )
.aa81		20 7d 93	jsr $937d	                jsr w_tuck             ; TUCK ( addr-t u-t here addr1 here )
.aa84		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr-t u-t here here addr1 )
.aa87		20 08 92	jsr $9208	                jsr w_store            ; ! ( addr-t u-t here )
.aa8a		20 e7 88	jsr $88e7	                jsr w_here             ; HERE ( addr-t u-t here here2)
.aa8d		a5 00		lda $00		                lda cp
.aa8f		18		clc		                clc
.aa90		69 04		adc #$04	                adc #04
.aa92		85 00		sta $00		                sta cp
.aa94		90 02		bcc $aa98	                bcc +
.aa96		e6 01		inc $01		                inc cp+1
.aa98						+
.aa98		e6 37		inc $37		                inc ed_cur
.aa9a		d0 02		bne $aa9e	                bne +
.aa9c		e6 38		inc $38		                inc ed_cur+1
.aa9e						+
.aa9e		20 e7 88	jsr $88e7	                jsr w_here     ; HERE ( addr-t u-t here here2 here3 )
.aaa1		20 5c 86	jsr $865c	                jsr w_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
.aaa4		ca		dex		                dex
.aaa5		ca		dex		                dex             ; ( addr-t u-t here here2 here3 here3 ? )
.aaa6		a5 0c		lda $0c		                lda cib
.aaa8		95 00		sta $00,x	                sta 0,x
.aaaa		a5 0d		lda $0d		                lda cib+1
.aaac		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
.aaae		20 1e 92	jsr $921e	                jsr w_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
.aab1		ca		dex		                dex
.aab2		ca		dex		                dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
.aab3		a5 0e		lda $0e		                lda ciblen
.aab5		95 00		sta $00,x	                sta 0,x
.aab7		a5 0f		lda $0f		                lda ciblen+1
.aab9		95 01		sta $01,x	                sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
.aabb		20 d7 8b	jsr $8bd7	                jsr w_move     ; ( addr-t u-t here here2 here3 )
.aabe		18		clc		                clc
.aabf		a5 00		lda $00		                lda cp
.aac1		65 0e		adc $0e		                adc ciblen
.aac3		85 00		sta $00		                sta cp
.aac5		90 06		bcc $aacd	                bcc +
.aac7		a5 01		lda $01		                lda cp+1
.aac9		65 0f		adc $0f		                adc ciblen+1
.aacb		85 01		sta $01		                sta cp+1
.aacd						+
.aacd		20 db 8c	jsr $8cdb	                jsr w_over             ; OVER ( addr-t u-t here here2 here3 here2 )
.aad0		20 08 92	jsr $9208	                jsr w_store            ; ! ( addr-t u-t here here2 )
.aad3		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+
.aad6		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+ ( addr-t u-t here here2+2 )
.aad9		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
.aadc		a5 0e		lda $0e		                lda ciblen
.aade		95 02		sta $02,x	                sta 2,x
.aae0		a5 0f		lda $0f		                lda ciblen+1
.aae2		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
.aae4		20 08 92	jsr $9208	                jsr w_store            ; ! ( addr-t u-t here )
.aae7		20 ec 83	jsr $83ec	                jsr w_cr
.aaea		4c 53 aa	jmp $aa53	                jmp _next_string_loop
.aaed						ed_cmd_d:
.aaed		fa		plx		                plx
.aaee		20 35 ad	jsr $ad35	                jsr ed_have_text
.aaf1		20 8a ad	jsr $ad8a	                jsr ed_no_line_zero
.aaf4		b5 00		lda $00,x	                lda 0,x
.aaf6		15 01		ora $01,x	                ora 1,x
.aaf8		d0 08		bne $ab02	                bne +
.aafa		20 db 8c	jsr $8cdb	                jsr w_over             ; ( addr-t u-t para1 0 para1 )
.aafd		20 3f ab	jsr $ab3f	                jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
.ab00		80 33		bra $ab35	                bra _cmd_d_done
.ab02						+
.ab02		20 40 ad	jsr $ad40	                jsr ed_is_valid_line      ; result is in C flag
.ab05		b0 03		bcs $ab0a	                bcs _cmd_d_loop
.ab07		4c 12 ad	jmp $ad12	                jmp ed_error_2drop
.ab0a						_cmd_d_loop:
.ab0a		20 9f 93	jsr $939f	                jsr w_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ab0d		20 d5 88	jsr $88d5	                jsr w_greater_than     ; > ( addr-t u-t para1 para2 f )
.ab10		b5 00		lda $00,x	                lda 0,x
.ab12		15 01		ora $01,x	                ora 1,x
.ab14		d0 0d		bne $ab23	                bne _cmd_d_done_with_flag
.ab16		e8		inx		                inx
.ab17		e8		inx		                inx                     ; Get rid of the flag from >
.ab18		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( addr-t u-t para1 para2 para2 )
.ab1b		20 3f ab	jsr $ab3f	                jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
.ab1e		20 b3 8c	jsr $8cb3	                jsr w_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
.ab21		80 e7		bra $ab0a	                bra _cmd_d_loop
.ab23						_cmd_d_done_with_flag:
.ab23		e8		inx		                inx                     ; ( addr-t u-t para1 para2 )
.ab24		e8		inx		                inx
.ab25		b5 02		lda $02,x	                lda 2,x
.ab27		d0 02		bne $ab2b	                bne +
.ab29		d6 03		dec $03,x	                dec 3,x
.ab2b						+
.ab2b		d6 02		dec $02,x	                dec 2,x
.ab2d		b5 02		lda $02,x	                lda 2,x
.ab2f		85 37		sta $37		                sta ed_cur
.ab31		b5 03		lda $03,x	                lda 3,x
.ab33		85 38		sta $38		                sta ed_cur+1            ; drop through to _cmd_d_done
.ab35						_cmd_d_done:
.ab35		a9 40		lda #$40	                lda #%01000000
.ab37		04 39		tsb $39		                tsb ed_flags
.ab39		20 ec 83	jsr $83ec	                jsr w_cr
.ab3c		4c 37 aa	jmp $aa37	                jmp ed_next_command
.ab3f						_cmd_d_common:
.ab3f		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( addr-t u-t u u )
.ab42		20 98 ad	jsr $ad98	                jsr ed_num_to_addr        ; ( addr-t u-t u addr )
.ab45		20 e9 87	jsr $87e9	                jsr w_fetch            ; @ ( addr-t u-t u addr1 )
.ab48		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr-t u-t addr1 u )
.ab4b		20 b3 8c	jsr $8cb3	                jsr w_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
.ab4e		20 98 ad	jsr $ad98	                jsr ed_num_to_addr        ; ( addr-t u-t addr1 addr-1 )
.ab51		20 08 92	jsr $9208	                jsr w_store            ; ! ( addr-t u-t )
.ab54		60		rts		                rts
.ab55						ed_cmd_equ:
.ab55		fa		plx		                plx
.ab56		a5 35		lda $35		                lda ed_head
.ab58		05 36		ora $36		                ora ed_head+1
.ab5a		d0 08		bne $ab64	                bne _cmd_equ_have_text
.ab5c		ca		dex		                dex
.ab5d		ca		dex		                dex
.ab5e		74 00		stz $00,x	                stz 0,x
.ab60		74 01		stz $01,x	                stz 1,x                 ; ( addr-t u-t para1 para2 0 )
.ab62		80 21		bra $ab85	                bra _cmd_equ_done
.ab64						_cmd_equ_have_text:
.ab64		20 8a ad	jsr $ad8a	                jsr ed_no_line_zero
.ab67		24 39		bit $39		                bit ed_flags
.ab69		30 0c		bmi $ab77	                bmi _cmd_equ_have_para
.ab6b		ca		dex		                dex
.ab6c		ca		dex		                dex                     ; ( addr-t u-t para1 para2 ? )
.ab6d		a5 37		lda $37		                lda ed_cur
.ab6f		95 00		sta $00,x	                sta 0,x
.ab71		a5 38		lda $38		                lda ed_cur+1
.ab73		95 01		sta $01,x	                sta 1,x
.ab75		80 0e		bra $ab85	                bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
.ab77						_cmd_equ_have_para:
.ab77		b5 00		lda $00,x	                lda 0,x
.ab79		15 01		ora $01,x	                ora 1,x
.ab7b		d0 05		bne $ab82	                bne _cmd_equ_two_paras
.ab7d		20 db 8c	jsr $8cdb	                jsr w_over             ; ( addr-t u-t para1 para2 para1)
.ab80		80 03		bra $ab85	                bra _cmd_equ_done
.ab82						_cmd_equ_two_paras:
.ab82		20 5c 86	jsr $865c	                jsr w_dup              ; ( addr-t u-t para1 para2 para2) drop through
.ab85						_cmd_equ_done:
.ab85		20 ec 83	jsr $83ec	                jsr w_cr               ; number goes on new line
.ab88		20 df 94	jsr $94df	                jsr w_u_dot            ; ( addr-t u-t para1 para2 )
.ab8b		20 ec 83	jsr $83ec	                jsr w_cr
.ab8e		4c 37 aa	jmp $aa37	                jmp ed_next_command
.ab91						ed_cmd_f:
.ab91		fa		plx		                plx
.ab92		24 39		bit $39		                bit ed_flags
.ab94		30 17		bmi $abad	                bmi _cmd_f_have_para
.ab96		20 ec 83	jsr $83ec	                jsr w_cr
.ab99		20 59 93	jsr $9359	                jsr w_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
.ab9c		20 5c 8f	jsr $8f5c	                jsr w_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
.ab9f		20 5c 86	jsr $865c	                jsr w_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
.aba2		20 df 94	jsr $94df	                jsr w_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
.aba5		20 ed 9c	jsr $9ced	                jsr w_not_rot          ; -ROT ( addr-t u-t 0 ) ( R: 0 )
.aba8		20 b5 8e	jsr $8eb5	                jsr w_r_from           ; R>   ( addr-t u-t 0 0 )
.abab		80 11		bra $abbe	                bra _cmd_f_done
.abad						_cmd_f_have_para:
.abad		20 db 8c	jsr $8cdb	                jsr w_over
.abb0		20 ec 83	jsr $83ec	                jsr w_cr
.abb3		20 df 94	jsr $94df	                jsr w_u_dot
.abb6		b5 02		lda $02,x	                lda 2,x
.abb8		95 06		sta $06,x	                sta 6,x
.abba		b5 03		lda $03,x	                lda 3,x
.abbc		95 07		sta $07,x	                sta 7,x                 ; fall through to _cmd_f_done
.abbe						_cmd_f_done:
.abbe		20 ec 83	jsr $83ec	                jsr w_cr
.abc1		4c 37 aa	jmp $aa37	                jmp ed_next_command
.abc4						ed_cmd_i:
.abc4		fa		plx		                plx
.abc5		e8		inx		                inx
.abc6		e8		inx		                inx                     ;  DROP ( addr-t u-t para1 )
.abc7		24 39		bit $39		                bit ed_flags
.abc9		30 08		bmi $abd3	                bmi _cmd_i_have_para
.abcb		a5 37		lda $37		                lda ed_cur
.abcd		95 00		sta $00,x	                sta 0,x
.abcf		a5 38		lda $38		                lda ed_cur+1
.abd1		95 01		sta $01,x	                sta 1,x                 ;  ( addr-t u-t cur ) drop through
.abd3						_cmd_i_have_para:
.abd3		b5 00		lda $00,x	                lda 0,x
.abd5		15 01		ora $01,x	                ora 1,x
.abd7		f0 09		beq $abe2	                beq _cmd_i_done
.abd9		20 b3 8c	jsr $8cb3	                jsr w_one_minus        ; 1-  ( addr-t u-t para1-1 )
.abdc		20 66 9e	jsr $9e66	                jsr w_zero             ; 0   ( addr-t u-t para1-1 0 )
.abdf		20 83 8b	jsr $8b83	                jsr w_max              ; MAX ( addr-t u-t para1-1 | 0 )
.abe2						_cmd_i_done:
.abe2		4c 4d aa	jmp $aa4d	                jmp ed_entry_cmd_i
.abe5						ed_cmd_n:
.abe5		fa		plx		                plx
.abe6		a9 01		lda #$01	                lda #%00000001
.abe8		04 39		tsb $39		                tsb ed_flags
.abea		80 05		bra $abf1	                bra ed_cmd_p_entry_for_cmd_n
.abec						ed_cmd_p:
.abec		fa		plx		                plx
.abed						ed_cmd_p_from_external:
.abed		a9 01		lda #$01	                lda #%00000001
.abef		14 39		trb $39		                trb ed_flags
.abf1						ed_cmd_p_entry_for_cmd_n:
.abf1		20 35 ad	jsr $ad35	                jsr ed_have_text
.abf4		20 8a ad	jsr $ad8a	                jsr ed_no_line_zero
.abf7		20 ec 83	jsr $83ec	                jsr w_cr
.abfa		b5 00		lda $00,x	                lda 0,x
.abfc		15 01		ora $01,x	                ora 1,x
.abfe		d0 10		bne $ac10	                bne _cmd_p_loop
.ac00		b5 02		lda $02,x	                lda 2,x
.ac02		85 37		sta $37		                sta ed_cur
.ac04		b5 03		lda $03,x	                lda 3,x
.ac06		85 38		sta $38		                sta ed_cur+1
.ac08		20 db 8c	jsr $8cdb	                jsr w_over             ; OVER ( addr-t u-t para1 para2 para1 )
.ac0b		20 39 ac	jsr $ac39	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac0e		80 26		bra $ac36	                bra _cmd_p_all_done
.ac10						_cmd_p_loop:
.ac10		20 9f 93	jsr $939f	                jsr w_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
.ac13		20 d5 88	jsr $88d5	                jsr w_greater_than     ; > ( addr-t u-t para1 para2 f )
.ac16		b5 00		lda $00,x	                lda 0,x
.ac18		15 01		ora $01,x	                ora 1,x
.ac1a		d0 10		bne $ac2c	                bne _cmd_p_done
.ac1c		e8		inx		                inx
.ac1d		e8		inx		                inx                     ; Get rid of the flag from >
.ac1e		20 db 8c	jsr $8cdb	                jsr w_over             ; ( addr-t u-t para1 para2 para1 )
.ac21		20 39 ac	jsr $ac39	                jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
.ac24		f6 02		inc $02,x	                inc 2,x
.ac26		d0 02		bne $ac2a	                bne +
.ac28		f6 03		inc $03,x	                inc 3,x
.ac2a						+
.ac2a		80 e4		bra $ac10	                bra _cmd_p_loop
.ac2c						_cmd_p_done:
.ac2c		e8		inx		                inx
.ac2d		e8		inx		                inx                     ; fall through to _cmp_p_all_done
.ac2e		b5 00		lda $00,x	                lda 0,x
.ac30		85 37		sta $37		                sta ed_cur
.ac32		b5 01		lda $01,x	                lda 1,x
.ac34		85 38		sta $38		                sta ed_cur+1
.ac36						_cmd_p_all_done:
.ac36		4c 37 aa	jmp $aa37	                jmp ed_next_command
.ac39						_cmd_p_common:
.ac39		a5 39		lda $39		                lda ed_flags
.ac3b		4a		lsr a		                lsr                     ; bit 0 now in carry
.ac3c		90 0b		bcc $ac49	                bcc _cmd_p_common_no_num
.ac3e		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( addr-t u-t para1 para1 )
.ac41		20 df 94	jsr $94df	                jsr w_u_dot            ; U. ( addr-t u-t para1 )
.ac44		a9 09		lda #$09	                lda #$09                 ; ASCII for Tab
.ac46		20 86 86	jsr $8686	                jsr emit_a
.ac49						_cmd_p_common_no_num:
.ac49		20 98 ad	jsr $ad98	                jsr ed_num_to_addr        ; ( addr-t u-t addr )
.ac4c		20 d8 ad	jsr $add8	                jsr ed_print_addr
.ac4f		60		rts		                rts
.ac50						ed_cmd_q:
.ac50		fa		plx		                plx
.ac51		24 39		bit $39		                bit ed_flags            ; bit 6 is change flag
.ac53		50 03		bvc $ac58	                bvc +
.ac55		4c 12 ad	jmp $ad12	                jmp ed_error_2drop
.ac58						+
.ac58		4c 3e aa	jmp $aa3e	                jmp ed_all_done            ; can't fall thru because of PLX
.ac5b						ed_cmd_qq:
.ac5b		fa		plx		                plx
.ac5c		4c 3e aa	jmp $aa3e	                jmp ed_all_done
.ac5f						ed_cmd_w:
.ac5f		fa		plx		                plx
.ac60		20 35 ad	jsr $ad35	                jsr ed_have_text
.ac63		24 39		bit $39		                bit ed_flags
.ac65		30 13		bmi $ac7a	                bmi _cmd_w_have_para
.ac67		b5 06		lda $06,x	                lda 6,x
.ac69		15 07		ora $07,x	                ora 7,x
.ac6b		d0 03		bne $ac70	                bne +
.ac6d		4c 12 ad	jmp $ad12	                jmp ed_error_2drop
.ac70						+
.ac70		b5 06		lda $06,x	                lda 6,x
.ac72		95 02		sta $02,x	                sta 2,x
.ac74		b5 07		lda $07,x	                lda 7,x
.ac76		95 03		sta $03,x	                sta 3,x                 ; ( addr-t u-t addr-t ? )
.ac78		80 08		bra $ac82	                bra _cmd_w_para_ready
.ac7a						_cmd_w_have_para:
.ac7a		b5 02		lda $02,x	                lda 2,x
.ac7c		95 06		sta $06,x	                sta 6,x
.ac7e		b5 03		lda $03,x	                lda 3,x
.ac80		95 07		sta $07,x	                sta 7,x                 ; drop through to _cmd_w_para_ready
.ac82						_cmd_w_para_ready:
.ac82		a9 35		lda #$35	                lda #<ed_head
.ac84		95 00		sta $00,x	                sta 0,x
.ac86		a9 00		lda #$00	                lda #>ed_head
.ac88		95 01		sta $01,x	                sta 1,x                 ; ( addr-t u-t addr-t addr-h )
.ac8a		20 db 8c	jsr $8cdb	                jsr w_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
.ac8d		20 59 93	jsr $9359	                jsr w_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.ac90						_cmd_w_loop:
.ac90		20 e9 87	jsr $87e9	                jsr w_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.ac93		b5 00		lda $00,x	                lda 0,x
.ac95		15 01		ora $01,x	                ora 1,x
.ac97		f0 55		beq $acee	                beq _cmd_w_eol
.ac99		20 9f 93	jsr $939f	                jsr w_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.ac9c		20 91 94	jsr $9491	                jsr w_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
.ac9f		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
.aca2		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
.aca5		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
.aca8		20 e9 87	jsr $87e9	                jsr w_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
.acab		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
.acae		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
.acb1		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
.acb4		20 e9 87	jsr $87e9	                jsr w_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
.acb7		20 ed 9c	jsr $9ced	                jsr w_not_rot          ; -ROT ( u-s addr-t addr-s ) ( R: ... )
.acba		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
.acbd		20 5c 8f	jsr $8f5c	                jsr w_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
.acc0		20 5c 86	jsr $865c	                jsr w_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
.acc3		20 59 93	jsr $9359	                jsr w_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
.acc6		20 d7 8b	jsr $8bd7	                jsr w_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
.acc9		20 b5 8e	jsr $8eb5	                jsr w_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
.accc		20 17 94	jsr $9417	                jsr w_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
.accf		20 ed 9c	jsr $9ced	                jsr w_not_rot          ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
.acd2		20 29 8e	jsr $8e29	                jsr w_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
.acd5		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.acd8		ca		dex		                dex
.acd9		ca		dex		                dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
.acda		a9 0a		lda #$0a	                lda #AscLF              ; ASCII for LF
.acdc		95 00		sta $00,x	                sta 0,x
.acde		74 01		stz $01,x	                stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ace0		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ace3		20 08 92	jsr $9208	                jsr w_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
.ace6		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
.ace9		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
.acec		80 a2		bra $ac90	                bra _cmd_w_loop
.acee						_cmd_w_eol:
.acee		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.acf1		20 b5 8e	jsr $8eb5	                jsr w_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
.acf4		20 bb 8b	jsr $8bbb	                jsr w_minus            ; - ( addr-t u-t addr-n u )
.acf7		b5 00		lda $00,x	                lda 0,x
.acf9		95 04		sta $04,x	                sta 4,x
.acfb		b5 01		lda $01,x	                lda 1,x
.acfd		95 05		sta $05,x	                sta 5,x                 ; ( addr-t u addr-n u )
.acff		20 ec 83	jsr $83ec	                jsr w_cr
.ad02		20 5c 86	jsr $865c	                jsr w_dup              ; DUP ( addr-t u addr-n u u )
.ad05		20 df 94	jsr $94df	                jsr w_u_dot            ; U. ( addr-t u addr-n u )
.ad08		20 ec 83	jsr $83ec	                jsr w_cr
.ad0b		a9 40		lda #$40	                lda #%01000000
.ad0d		14 39		trb $39		                trb ed_flags
.ad0f		4c 37 aa	jmp $aa37	                jmp ed_next_command
.ad12						ed_error_2drop:
.ad12		e8		inx		                inx
.ad13		e8		inx		                inx                     ; drop through to _error_1drop
.ad14						ed_error_1drop:
.ad14		e8		inx		                inx
.ad15		e8		inx		                inx                     ; drop through to _error
.ad16						ed_error:
.ad16		20 ec 83	jsr $83ec	                jsr w_cr
.ad19		a9 3f		lda #$3f	                lda #'?'
.ad1b		20 86 86	jsr $8686	                jsr emit_a
.ad1e		20 ec 83	jsr $83ec	                jsr w_cr
.ad21		4c 45 a8	jmp $a845	                jmp ed_input_loop
.ad24						ed_get_input:
.ad24		20 07 8f	jsr $8f07	                jsr w_refill           ;  ( addr-t u-t f )
.ad27		b5 00		lda $00,x	                lda 0,x
.ad29		15 01		ora $01,x	                ora 1,x
.ad2b		d0 05		bne $ad32	                bne +
.ad2d		7a		ply		                ply
.ad2e		7a		ply		                ply
.ad2f		4c 14 ad	jmp $ad14	                jmp ed_error_1drop
.ad32						+
.ad32		e8		inx		                inx
.ad33		e8		inx		                inx
.ad34		60		rts		                rts
.ad35						ed_have_text:
.ad35		a5 35		lda $35		                lda ed_head
.ad37		05 36		ora $36		                ora ed_head+1
.ad39		d0 04		bne $ad3f	                bne +
.ad3b		7a		ply		                ply
.ad3c		7a		ply		                ply
.ad3d		80 d7		bra $ad16	                bra ed_error
.ad3f						+
.ad3f		60		rts		                rts
.ad40						ed_is_valid_line:
.ad40		38		sec		                sec                             ; default is legal line number
.ad41		b5 00		lda $00,x	                lda 0,x
.ad43		15 01		ora $01,x	                ora 1,x
.ad45		f0 19		beq $ad60	                beq _is_valid_line_nope_zero    ; ( n )
.ad47		20 5c 86	jsr $865c	                jsr w_dup                      ; DUP ( n n )
.ad4a		20 62 ad	jsr $ad62	                jsr ed_last_line                  ; ( n n last )
.ad4d		20 1e 92	jsr $921e	                jsr w_swap                     ; SWAP ( n last n )
.ad50		20 be 89	jsr $89be	                jsr w_less_than                ; < ( n f )
.ad53		b5 00		lda $00,x	                lda 0,x                         ; 0 flag is good
.ad55		15 01		ora $01,x	                ora 1,x
.ad57		d0 05		bne $ad5e	                bne _is_valid_line_too_small
.ad59		e8		inx		                inx
.ad5a		e8		inx		                inx                     ; DROP flag ( n )
.ad5b		38		sec		                sec                     ; Who knows what's happened to C by now
.ad5c		80 03		bra $ad61	                bra _is_valid_line_done ; only one exit from this routine
.ad5e						_is_valid_line_too_small:
.ad5e		e8		inx		                inx
.ad5f		e8		inx		                inx                     ; drop through to _is_valid_line_zero
.ad60						_is_valid_line_nope_zero:
.ad60		18		clc		                clc                     ; drop through to _is_valid_line_done
.ad61						_is_valid_line_done:
.ad61		60		rts		                rts
.ad62						ed_last_line:
.ad62		64 25		stz $25		                stz tmp1
.ad64		64 26		stz $26		                stz tmp1+1
.ad66		ca		dex		                dex
.ad67		ca		dex		                dex                     ; ( ? )
.ad68		a9 35		lda #$35	                lda #<ed_head
.ad6a		95 00		sta $00,x	                sta 0,x
.ad6c		a9 00		lda #$00	                lda #>ed_head
.ad6e		95 01		sta $01,x	                sta 1,x                 ; ( addr )
.ad70						_last_line_loop:
.ad70		20 e9 87	jsr $87e9	                jsr w_fetch            ; ( addr | 0 )
.ad73		b5 00		lda $00,x	                lda 0,x
.ad75		15 01		ora $01,x	                ora 1,x
.ad77		f0 08		beq $ad81	                beq _last_line_done
.ad79		e6 25		inc $25		                inc tmp1
.ad7b		d0 02		bne $ad7f	                bne +
.ad7d		e6 26		inc $26		                inc tmp1+1
.ad7f						+
.ad7f		80 ef		bra $ad70	                bra _last_line_loop
.ad81						_last_line_done:
.ad81		a5 25		lda $25		                lda tmp1
.ad83		95 00		sta $00,x	                sta 0,x
.ad85		a5 26		lda $26		                lda tmp1+1
.ad87		95 01		sta $01,x	                sta 1,x                 ; ( u )
.ad89		60		rts		                rts
.ad8a						ed_no_line_zero:
.ad8a		b5 02		lda $02,x	                lda 2,x
.ad8c		15 03		ora $03,x	                ora 3,x
.ad8e		d0 07		bne $ad97	                bne _no_line_zero_done
.ad90		24 39		bit $39		                bit ed_flags
.ad92		10 03		bpl $ad97	                bpl _no_line_zero_done
.ad94		4c 12 ad	jmp $ad12	                jmp ed_error_2drop
.ad97						_no_line_zero_done:
.ad97		60		rts		                rts
.ad98						ed_num_to_addr:
.ad98		ca		dex		                dex
.ad99		ca		dex		                dex                     ; ( u ? )
.ad9a		a9 35		lda #$35	                lda #<ed_head
.ad9c		95 00		sta $00,x	                sta 0,x
.ad9e		a9 00		lda #$00	                lda #>ed_head
.ada0		95 01		sta $01,x	                sta 1,x                 ; ( u addr-h )
.ada2		b5 02		lda $02,x	                lda 2,x
.ada4		15 03		ora $03,x	                ora 3,x
.ada6		d0 05		bne $adad	                bne _num_to_addr_loop
.ada8		20 0a 8c	jsr $8c0a	                jsr w_nip              ; ( addr-h )
.adab		80 21		bra $adce	                bra _num_to_addr_done
.adad						_num_to_addr_loop:
.adad		20 e9 87	jsr $87e9	                jsr w_fetch            ; @ ( u addr1 )
.adb0		b5 00		lda $00,x	                lda 0,x
.adb2		15 01		ora $01,x	                ora 1,x
.adb4		d0 05		bne $adbb	                bne +
.adb6		20 0a 8c	jsr $8c0a	                jsr w_nip              ; NIP ( addr1 )
.adb9		80 13		bra $adce	                bra _num_to_addr_done
.adbb						+
.adbb		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( addr1 u )
.adbe		20 b3 8c	jsr $8cb3	                jsr w_one_minus        ; 1- ( addr1 u-1 )
.adc1		b5 00		lda $00,x	                lda 0,x
.adc3		15 01		ora $01,x	                ora 1,x
.adc5		f0 05		beq $adcc	                beq _num_to_addr_finished
.adc7		20 1e 92	jsr $921e	                jsr w_swap             ; SWAP ( u-1 addr1 )
.adca		80 e1		bra $adad	                bra _num_to_addr_loop
.adcc						_num_to_addr_finished:
.adcc		e8		inx		                inx
.adcd		e8		inx		                inx                     ; ( addr )
.adce						_num_to_addr_done:
.adce		60		rts		                rts
.adcf						ed_para1_to_cur:
.adcf		b5 02		lda $02,x	                lda 2,x
.add1		85 37		sta $37		                sta ed_cur
.add3		b5 03		lda $03,x	                lda 3,x
.add5		85 38		sta $38		                sta ed_cur+1
.add7		60		rts		                rts
.add8						ed_print_addr:
.add8		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.addb		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; ( addr+2 )
.adde		20 5c 86	jsr $865c	                jsr w_dup              ; ( addr+2 addr+2 )
.ade1		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.ade4		20 bf 8c	jsr $8cbf	                jsr w_one_plus         ; ( addr+2 addr+4 )
.ade7		20 e9 87	jsr $87e9	                jsr w_fetch            ; ( addr+2 u-s )
.adea		20 1e 92	jsr $921e	                jsr w_swap             ; ( u-s addr+2 )
.aded		20 e9 87	jsr $87e9	                jsr w_fetch            ; ( u-s addr-s )
.adf0		20 1e 92	jsr $921e	                jsr w_swap             ; ( addr-s u-s )
.adf3		20 b4 94	jsr $94b4	                jsr w_type
.adf6		20 ec 83	jsr $83ec	                jsr w_cr
.adf9		60		rts		                rts
>adfa		61 66 69 64 70 6e 3d 77		ed_cmd_list:    .text "afidpn=wqQ", 0
>ae02		71 51 00
.ae05						ed_cmd_table:
>ae05		4a aa 91 ab c4 ab ed aa		                .word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>ae0d		ec ab e5 ab
>ae11		55 ab 5f ac 50 ac 5b ac		                .word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.ae19						ed6502_end:

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/block.asm

.ae19						xt_blk:
.ae19						w_blk:
.ae19		a9 04		lda #$04	                lda #blk_offset
.ae1b		4c 92 d6	jmp $d692	                jmp push_upvar_tos
.ae1e						z_blk:
.ae1e						xt_blkbuffer:
.ae1e						w_blkbuffer:
.ae1e		ca		dex		                dex
.ae1f		ca		dex		                dex
.ae20		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ae22		b1 08		lda ($08),y	                lda (up),y
.ae24		95 00		sta $00,x	                sta 0,x
.ae26		c8		iny		                iny             ; Move along to the next byte
.ae27		b1 08		lda ($08),y	                lda (up),y
.ae29		95 01		sta $01,x	                sta 1,x
.ae2b		60		rts		z_blkbuffer:    rts
.ae2c						xt_block:
.ae2c						w_block:
.ae2c		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae2e		b1 08		lda ($08),y	                lda (up),y
.ae30		d5 00		cmp $00,x	                cmp 0,x
.ae32		d0 0f		bne $ae43	                bne _not_in_buffer
.ae34		c8		iny		                iny
.ae35		b1 08		lda ($08),y	                lda (up),y
.ae37		d5 01		cmp $01,x	                cmp 1,x
.ae39		d0 08		bne $ae43	                bne _not_in_buffer
.ae3b		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae3d		b1 08		lda ($08),y	                lda (up),y
.ae3f		29 01		and #$01	                and #1          ; Check the in-use flag (bit 0)
.ae41		d0 30		bne $ae73	                bne _done       ; It's already in the buffer and in use.
.ae43						_not_in_buffer:
.ae43		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae45		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.ae47		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.ae49		d0 0c		bne $ae57	                bne _buffer_available ; Unused or not dirty = available
.ae4b		20 1e ae	jsr $ae1e	                jsr w_blkbuffer
.ae4e		20 ce af	jsr $afce	                jsr w_buffblocknum
.ae51		20 e9 87	jsr $87e9	                jsr w_fetch
.ae54		20 bb af	jsr $afbb	                jsr w_block_write
.ae57						_buffer_available:
.ae57		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.ae59		b5 00		lda $00,x	                lda 0,x
.ae5b		91 08		sta ($08),y	                sta (up),y
.ae5d		c8		iny		                iny
.ae5e		b5 01		lda $01,x	                lda 1,x
.ae60		91 08		sta ($08),y	                sta (up),y
.ae62		20 1e ae	jsr $ae1e	                jsr w_blkbuffer
.ae65		20 1e 92	jsr $921e	                jsr w_swap
.ae68		20 a3 af	jsr $afa3	                jsr w_block_read
.ae6b		a9 01		lda #$01	                lda #1
.ae6d		a0 30		ldy #$30	                ldy #buffstatus_offset
.ae6f		91 08		sta ($08),y	                sta (up),y
.ae71		ca		dex		                dex
.ae72		ca		dex		                dex
.ae73						_done:
.ae73		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.ae75		b1 08		lda ($08),y	                lda (up),y
.ae77		95 00		sta $00,x	                sta 0,x
.ae79		c8		iny		                iny
.ae7a		b1 08		lda ($08),y	                lda (up),y
.ae7c		95 01		sta $01,x	                sta 1,x
.ae7e		60		rts		z_block:        rts
.ae7f						xt_block_ramdrive_init:
.ae7f		20 d4 d7	jsr $d7d4	                jsr underflow_1
.ae82						w_block_ramdrive_init:
.ae82		20 4d a2	jsr $a24d	                jsr sliteral_runtime
>ae85		18 01				                .word ramdrive_code_end-ramdrive_code
.ae87						ramdrive_code:
>ae87		62 61 73 65 20 40 20 73		                .text "base @ swap decimal"
>ae8f		77 61 70 20 64 65 63 69 6d 61 6c
>ae9a		20 31 30 32 34 20 2a		                .text " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
>aea1		20 64 75 70			                .text " dup"    ; ( Save a copy for formatting it at the end )
>aea5		20 62 75 66 66 65 72 3a		                .text " buffer: ramdrive" ; ( Create ramdrive )
>aead		20 72 61 6d 64 72 69 76 65
>aeb6		20 3a 20 62 6c 6f 63 6b		                .text " : block-read-ramdrive"  ; ( addr u -- )
>aebe		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65
>aecc		20 72 61 6d 64 72 69 76		                .text " ramdrive swap 1024 * + swap 1024 move ;"
>aed4		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>aee4		73 77 61 70 20 31 30 32 34 20 6d 6f 76 65 20 3b
>aef4		20 3a 20 62 6c 6f 63 6b		                .text " : block-write-ramdrive" ; ( addr u -- )
>aefc		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65
>af0b		20 72 61 6d 64 72 69 76		                .text " ramdrive swap 1024 * + 1024 move ;"
>af13		65 20 73 77 61 70 20 31 30 32 34 20 2a 20 2b 20
>af23		31 30 32 34 20 6d 6f 76 65 20 3b
>af2e		20 27 20 62 6c 6f 63 6b		                .text " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
>af36		2d 72 65 61 64 2d 72 61 6d 64 72 69 76 65 20 62
>af46		6c 6f 63 6b 2d 72 65 61 64 2d 76 65 63 74 6f 72
>af56		20 21
>af58		20 27 20 62 6c 6f 63 6b		                .text " ' block-write-ramdrive block-write-vector !"
>af60		2d 77 72 69 74 65 2d 72 61 6d 64 72 69 76 65 20
>af70		62 6c 6f 63 6b 2d 77 72 69 74 65 2d 76 65 63 74
>af80		6f 72 20 21
>af84		20 72 61 6d 64 72 69 76		                .text " ramdrive swap blank base !"
>af8c		65 20 73 77 61 70 20 62 6c 61 6e 6b 20 62 61 73
>af9c		65 20 21
.af9f						ramdrive_code_end:
.af9f		20 81 88	jsr $8881	                jsr w_evaluate
.afa2						z_block_ramdrive_init:
.afa2		60		rts		                rts
.afa3						xt_block_read:
.afa3						w_block_read:
.afa3		a0 32		ldy #$32	                ldy #blockread_offset
.afa5		b1 08		lda ($08),y	                lda (up),y
.afa7		85 25		sta $25		                sta tmp1
.afa9		c8		iny		                iny
.afaa		b1 08		lda ($08),y	                lda (up),y
.afac		85 26		sta $26		                sta tmp1+1
.afae		6c 25 00	jmp ($0025)	                jmp (tmp1)
.afb1						z_block_read:
.afb1						xt_block_read_vector:
.afb1						w_block_read_vector:
.afb1		a9 32		lda #$32	                lda #blockread_offset
.afb3		4c 92 d6	jmp $d692	                jmp push_upvar_tos
.afb6						z_block_read_vector:
.afb6						xt_block_word_error:
.afb6						w_block_word_error:
.afb6		a9 0c		lda #$0c	                lda #err_blockwords
.afb8		4c ea d7	jmp $d7ea	                jmp error       ; no RTS needed
.afbb						xt_block_write:
.afbb						w_block_write:
.afbb		a0 34		ldy #$34	                ldy #blockwrite_offset
.afbd		b1 08		lda ($08),y	                lda (up),y
.afbf		85 25		sta $25		                sta tmp1
.afc1		c8		iny		                iny
.afc2		b1 08		lda ($08),y	                lda (up),y
.afc4		85 26		sta $26		                sta tmp1+1
.afc6		6c 25 00	jmp ($0025)	                jmp (tmp1)
.afc9						z_block_write:
.afc9						xt_block_write_vector:
.afc9						w_block_write_vector:
.afc9		a9 34		lda #$34	                lda #blockwrite_offset
.afcb		4c 92 d6	jmp $d692	                jmp push_upvar_tos
.afce						z_block_write_vector:
.afce						xt_buffblocknum:
.afce						w_buffblocknum:
.afce		a9 2e		lda #$2e	                lda #buffblocknum_offset
.afd0		4c 92 d6	jmp $d692	                jmp push_upvar_tos
.afd3						z_buffblocknum:
.afd3						xt_buffer:
.afd3						w_buffer:
.afd3		a0 30		ldy #$30	                ldy #buffstatus_offset
.afd5		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.afd7		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.afd9		d0 0c		bne $afe7	                bne _buffer_available ; Unused or not dirty = available
.afdb		20 1e ae	jsr $ae1e	                jsr w_blkbuffer
.afde		20 ce af	jsr $afce	                jsr w_buffblocknum
.afe1		20 e9 87	jsr $87e9	                jsr w_fetch
.afe4		20 bb af	jsr $afbb	                jsr w_block_write
.afe7						_buffer_available:
.afe7		a0 2e		ldy #$2e	                ldy #buffblocknum_offset
.afe9		b5 00		lda $00,x	                lda 0,x
.afeb		91 08		sta ($08),y	                sta (up),y
.afed		c8		iny		                iny
.afee		b5 01		lda $01,x	                lda 1,x
.aff0		91 08		sta ($08),y	                sta (up),y
.aff2		a9 01		lda #$01	                lda #1
.aff4		a0 30		ldy #$30	                ldy #buffstatus_offset
.aff6		91 08		sta ($08),y	                sta (up),y
.aff8		a0 2c		ldy #$2c	                ldy #blkbuffer_offset
.affa		b1 08		lda ($08),y	                lda (up),y
.affc		95 00		sta $00,x	                sta 0,x
.affe		c8		iny		                iny
.afff		b1 08		lda ($08),y	                lda (up),y
.b001		95 01		sta $01,x	                sta 1,x
.b003		60		rts		z_buffer:       rts
.b004						xt_buffstatus:
.b004						w_buffstatus:
.b004		a9 30		lda #$30	                lda #buffstatus_offset
.b006		4c 92 d6	jmp $d692	                jmp push_upvar_tos
.b009						z_buffstatus:
.b009						xt_empty_buffers:
.b009						w_empty_buffers:
.b009		a0 30		ldy #$30	                ldy #buffstatus_offset
.b00b		a9 00		lda #$00	                lda #0
.b00d		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b00f						z_empty_buffers:
.b00f		60		rts		                rts
.b010						xt_flush:
.b010						w_flush:
.b010		20 6b b0	jsr $b06b	                jsr w_save_buffers
.b013		a0 30		ldy #$30	                ldy #buffstatus_offset
.b015		a9 00		lda #$00	                lda #0
.b017		91 08		sta ($08),y	                sta (up),y      ; Only LSB is used.
.b019						z_flush:
.b019		60		rts		                rts
.b01a						xt_list:
.b01a		20 d4 d7	jsr $d7d4	                jsr underflow_1
.b01d						w_list:
.b01d		20 86 b0	jsr $b086	                jsr w_scr
.b020		20 08 92	jsr $9208	                jsr w_store
.b023		20 25 b1	jsr $b125	                jsr w_editor_l
.b026		60		rts		z_list:         rts
.b027						xt_load:
.b027		20 d4 d7	jsr $d7d4	                jsr underflow_1
.b02a						w_load:
.b02a		a0 05		ldy #$05	                ldy #blk_offset+1
.b02c		b1 08		lda ($08),y	                lda (up),y
.b02e		48		pha		                pha
.b02f		88		dey		                dey
.b030		b1 08		lda ($08),y	                lda (up),y
.b032		48		pha		                pha
.b033		b5 00		lda $00,x	                lda 0,x
.b035		91 08		sta ($08),y	                sta (up),y
.b037		c8		iny		                iny
.b038		b5 01		lda $01,x	                lda 1,x
.b03a		91 08		sta ($08),y	                sta (up),y
.b03c		20 2c ae	jsr $ae2c	                jsr w_block
.b03f		ca		dex		                dex
.b040		ca		dex		                dex
.b041		a9 04		lda #$04	                lda #4
.b043		95 01		sta $01,x	                sta 1,x
.b045		74 00		stz $00,x	                stz 0,x
.b047		20 78 88	jsr $8878	                jsr load_evaluate
.b04a		a0 04		ldy #$04	                ldy #blk_offset
.b04c		68		pla		                pla
.b04d		91 08		sta ($08),y	                sta (up),y
.b04f		c8		iny		                iny
.b050		68		pla		                pla
.b051		91 08		sta ($08),y	                sta (up),y
.b053		88		dey		                dey
.b054		11 08		ora ($08),y	                ora (up),y
.b056		f0 12		beq $b06a	                beq _done
.b058		ca		dex		                dex
.b059		ca		dex		                dex
.b05a		a0 04		ldy #$04	                ldy #blk_offset
.b05c		b1 08		lda ($08),y	                lda (up),y
.b05e		95 00		sta $00,x	                sta 0,x
.b060		c8		iny		                iny
.b061		b1 08		lda ($08),y	                lda (up),y
.b063		95 01		sta $01,x	                sta 1,x
.b065		20 2c ae	jsr $ae2c	                jsr w_block
.b068		e8		inx		                inx
.b069		e8		inx		                inx
.b06a						_done:
.b06a		60		rts		z_load:         rts
.b06b						xt_save_buffers:
.b06b						w_save_buffers:
.b06b		a0 30		ldy #$30	                ldy #buffstatus_offset
.b06d		b1 08		lda ($08),y	                lda (up),y      ; Only bits 0 and 1 are used, so only
.b06f		c9 03		cmp #$03	                cmp #3          ; LSB is needed.
.b071		d0 12		bne $b085	                bne _done       ; Either not used or not dirty = done!
.b073		20 1e ae	jsr $ae1e	                jsr w_blkbuffer
.b076		20 ce af	jsr $afce	                jsr w_buffblocknum
.b079		20 e9 87	jsr $87e9	                jsr w_fetch
.b07c		20 bb af	jsr $afbb	                jsr w_block_write
.b07f		a9 01		lda #$01	                lda #1
.b081		a0 30		ldy #$30	                ldy #buffstatus_offset
.b083		91 08		sta ($08),y	                sta (up),y
.b085						_done:
.b085		60		rts		z_save_buffers: rts
.b086						xt_scr:
.b086						w_scr:
.b086		a9 06		lda #$06	                lda #scr_offset
.b088		4c 92 d6	jmp $d692	                jmp push_upvar_tos
.b08b						z_scr:
.b08b						xt_thru:
.b08b		20 d9 d7	jsr $d7d9	                jsr underflow_2
.b08e						w_thru:
.b08e		b5 01		lda $01,x	                lda 1,x
.b090		48		pha		                pha
.b091		b5 00		lda $00,x	                lda 0,x
.b093		48		pha		                pha
.b094		e8		inx		                inx
.b095		e8		inx		                inx
.b096						_thru_loop:
.b096		b5 01		lda $01,x	                lda 1,x
.b098		48		pha		                pha
.b099		b5 00		lda $00,x	                lda 0,x
.b09b		48		pha		                pha
.b09c		20 2a b0	jsr $b02a	                jsr w_load
.b09f		68		pla		                pla
.b0a0		85 25		sta $25		                sta tmp1
.b0a2		68		pla		                pla
.b0a3		85 26		sta $26		                sta tmp1+1
.b0a5		68		pla		                pla
.b0a6		85 27		sta $27		                sta tmp2
.b0a8		68		pla		                pla
.b0a9		85 28		sta $28		                sta tmp2+1
.b0ab		c5 26		cmp $26		                cmp tmp1+1
.b0ad		d0 08		bne $b0b7	                bne _next_screen
.b0af		a5 27		lda $27		                lda tmp2        ; Compare the LSB
.b0b1		c5 25		cmp $25		                cmp tmp1
.b0b3		d0 02		bne $b0b7	                bne _next_screen
.b0b5		80 18		bra $b0cf	                bra _done       ; We just did the last screen.
.b0b7						_next_screen:
.b0b7		a5 28		lda $28		                lda tmp2+1
.b0b9		48		pha		                pha
.b0ba		a5 27		lda $27		                lda tmp2
.b0bc		48		pha		                pha
.b0bd		e6 25		inc $25		                inc tmp1
.b0bf		d0 02		bne $b0c3	                bne +
.b0c1		e6 26		inc $26		                inc tmp1+1
.b0c3						+
.b0c3		ca		dex		                dex
.b0c4		ca		dex		                dex
.b0c5		a5 25		lda $25		                lda tmp1
.b0c7		95 00		sta $00,x	                sta 0,x
.b0c9		a5 26		lda $26		                lda tmp1+1
.b0cb		95 01		sta $01,x	                sta 1,x
.b0cd		80 c7		bra $b096	                bra _thru_loop
.b0cf						_done:
.b0cf		60		rts		z_thru:         rts
.b0d0						xt_update:
.b0d0						w_update:
.b0d0		a0 30		ldy #$30	                ldy #buffstatus_offset
.b0d2		b1 08		lda ($08),y	                lda (up),y
.b0d4		09 02		ora #$02	                ora #2          ; Turn on dirty flag (bit 2)
.b0d6		91 08		sta ($08),y	                sta (up),y
.b0d8		60		rts		z_update:       rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/editor.asm

.b0d9						xt_editor_screen_helper:
.b0d9						w_editor_screen_helper:
.b0d9		20 5c 86	jsr $865c	                jsr w_dup
.b0dc		20 86 b0	jsr $b086	                jsr w_scr
.b0df		20 08 92	jsr $9208	                jsr w_store
.b0e2		4c d3 af	jmp $afd3	                jmp w_buffer
.b0e5						xt_editor_enter_screen:
.b0e5						w_editor_enter_screen:
.b0e5		20 d9 b0	jsr $b0d9	                jsr w_editor_screen_helper
.b0e8		20 56 86	jsr $8656	                jsr w_drop
.b0eb		64 35		stz $35		                stz ed_head
.b0ed						_prompt_loop:
.b0ed		ca		dex		                dex
.b0ee		ca		dex		                dex
.b0ef		a5 35		lda $35		                lda ed_head
.b0f1		95 00		sta $00,x	                sta 0,x
.b0f3		74 01		stz $01,x	                stz 1,x
.b0f5		20 b4 b1	jsr $b1b4	                jsr w_editor_o
.b0f8		e6 35		inc $35		                inc ed_head
.b0fa		a9 10		lda #$10	                lda #16
.b0fc		c5 35		cmp $35		                cmp ed_head
.b0fe		d0 ed		bne $b0ed	                bne _prompt_loop
.b100						z_editor_enter_screen:
.b100		60		rts		                rts
.b101						xt_editor_erase_screen:
.b101						w_editor_erase_screen:
.b101		20 d9 b0	jsr $b0d9	                jsr w_editor_screen_helper
.b104		ca		dex		                dex
.b105		ca		dex		                dex
.b106		74 00		stz $00,x	                stz 0,x
.b108		a9 04		lda #$04	                lda #4          ; 4 in MSB makes 1024 ($400).
.b10a		95 01		sta $01,x	                sta 1,x
.b10c		20 79 87	jsr $8779	                jsr w_blank
.b10f		20 d0 b0	jsr $b0d0	                jsr w_update
.b112						z_editor_erase_screen:
.b112		60		rts		                rts
.b113						xt_editor_el:
.b113						w_editor_el:
.b113		20 9e b1	jsr $b19e	                jsr w_editor_line
.b116		ca		dex		                dex
.b117		ca		dex		                dex
.b118		a9 40		lda #$40	                lda #64
.b11a		95 00		sta $00,x	                sta 0,x
.b11c		74 01		stz $01,x	                stz 1,x
.b11e		20 79 87	jsr $8779	                jsr w_blank
.b121		20 d0 b0	jsr $b0d0	                jsr w_update
.b124		60		rts		z_editor_el:    rts
.b125						xt_editor_l:
.b125						w_editor_l:
.b125		ca		dex		                dex             ; Put SCR on the stack.
.b126		ca		dex		                dex
.b127		a0 06		ldy #$06	                ldy #scr_offset
.b129		b1 08		lda ($08),y	                lda (up),y
.b12b		95 00		sta $00,x	                sta 0,x
.b12d		c8		iny		                iny
.b12e		b1 08		lda ($08),y	                lda (up),y
.b130		95 01		sta $01,x	                sta 1,x
.b132		20 2c ae	jsr $ae2c	                jsr w_block    ; Get the current screen.
.b135		20 ec 83	jsr $83ec	                jsr w_cr
.b138		20 4d a2	jsr $a24d	                jsr sliteral_runtime
>b13b		08 00				                .word _after_screen_msg-_screen_msg
.b13d						_screen_msg:
>b13d		53 63 72 65 65 6e 20 23		                .text "Screen #"
.b145						_after_screen_msg:
.b145		20 b4 94	jsr $94b4	                jsr w_type
.b148		20 86 b0	jsr $b086	                jsr w_scr
.b14b		20 e9 87	jsr $87e9	                jsr w_fetch
.b14e		ca		dex		                dex
.b14f		ca		dex		                dex
.b150		a9 04		lda #$04	                lda #4          ; four spaces
.b152		95 00		sta $00,x	                sta 0,x
.b154		74 01		stz $01,x	                stz 1,x
.b156		20 eb 94	jsr $94eb	                jsr w_u_dot_r
.b159		64 29		stz $29		                stz tmp3
.b15b						_line_loop:
.b15b		20 ec 83	jsr $83ec	                jsr w_cr
.b15e		ca		dex		                dex
.b15f		ca		dex		                dex
.b160		ca		dex		                dex
.b161		ca		dex		                dex
.b162		74 03		stz $03,x	                stz 3,x
.b164		a5 29		lda $29		                lda tmp3
.b166		95 02		sta $02,x	                sta 2,x
.b168		74 01		stz $01,x	                stz 1,x
.b16a		a9 02		lda #$02	                lda #2
.b16c		95 00		sta $00,x	                sta 0,x
.b16e		20 eb 94	jsr $94eb	                jsr w_u_dot_r
.b171		20 b5 91	jsr $91b5	                jsr w_space
.b174		20 5c 86	jsr $865c	                jsr w_dup
.b177		ca		dex		                dex
.b178		ca		dex		                dex
.b179		a9 40		lda #$40	                lda #64
.b17b		95 00		sta $00,x	                sta 0,x
.b17d		74 01		stz $01,x	                stz 1,x
.b17f		20 b4 94	jsr $94b4	                jsr w_type
.b182		18		clc		                clc
.b183		a9 40		lda #$40	                lda #64
.b185		75 00		adc $00,x	                adc 0,x
.b187		95 00		sta $00,x	                sta 0,x
.b189		90 02		bcc $b18d	                bcc +
.b18b		f6 01		inc $01,x	                inc 1,x
.b18d						+
.b18d		e6 29		inc $29		                inc tmp3
.b18f		a5 29		lda $29		                lda tmp3
.b191		c9 10		cmp #$10	                cmp #16
.b193		d0 c6		bne $b15b	                bne _line_loop
.b195		20 ec 83	jsr $83ec	                jsr w_cr
.b198		e8		inx		                inx
.b199		e8		inx		                inx
.b19a		60		rts		z_editor_l:     rts
.b19b						xt_editor_line:
.b19b		20 d4 d7	jsr $d7d4	                jsr underflow_1
.b19e						w_editor_line:
.b19e		a0 06		ldy #$06	                ldy #6          ; *64 is same as left shift 6 times.
.b1a0						_shift_tos_left:
.b1a0		16 00		asl $00,x	                asl 0,x         ; Shift TOS to the left
.b1a2		36 01		rol $01,x	                rol 1,x         ; ROL brings MSb from lower byte.
.b1a4		88		dey		                dey
.b1a5		d0 f9		bne $b1a0	                bne _shift_tos_left
.b1a7		20 86 b0	jsr $b086	                jsr w_scr
.b1aa		20 e9 87	jsr $87e9	                jsr w_fetch
.b1ad		20 2c ae	jsr $ae2c	                jsr w_block
.b1b0		20 29 8e	jsr $8e29	                jsr w_plus
.b1b3		60		rts		z_editor_line:  rts
.b1b4						xt_editor_o:
.b1b4						w_editor_o:
.b1b4		20 ec 83	jsr $83ec	                jsr w_cr
.b1b7		20 5c 86	jsr $865c	                jsr w_dup
.b1ba		20 31 9e	jsr $9e31	                jsr w_two
.b1bd		20 eb 94	jsr $94eb	                jsr w_u_dot_r
.b1c0		20 b5 91	jsr $91b5	                jsr w_space
.b1c3		a9 2a		lda #$2a	                lda #'*'
.b1c5		20 86 86	jsr $8686	                jsr emit_a
.b1c8		20 b5 91	jsr $91b5	                jsr w_space
.b1cb		20 9e b1	jsr $b19e	                jsr w_editor_line
.b1ce		20 5c 86	jsr $865c	                jsr w_dup      ; Save a copy of the line address for later.
.b1d1		ca		dex		                dex
.b1d2		ca		dex		                dex
.b1d3		a9 40		lda #$40	                lda #64         ; chars/line
.b1d5		95 00		sta $00,x	                sta 0,x
.b1d7		74 01		stz $01,x	                stz 1,x
.b1d9		20 e7 80	jsr $80e7	                jsr w_accept
.b1dc		20 5c 86	jsr $865c	                jsr w_dup
.b1df		20 ed 9c	jsr $9ced	                jsr w_not_rot  ; -rot
.b1e2		20 29 8e	jsr $8e29	                jsr w_plus
.b1e5		ca		dex		                dex
.b1e6		ca		dex		                dex
.b1e7		a9 40		lda #$40	                lda #64         ; chars/line
.b1e9		95 00		sta $00,x	                sta 0,x
.b1eb		74 01		stz $01,x	                stz 1,x
.b1ed		20 5c 8f	jsr $8f5c	                jsr w_rot
.b1f0		20 bb 8b	jsr $8bbb	                jsr w_minus
.b1f3		20 79 87	jsr $8779	                jsr w_blank
.b1f6		20 d0 b0	jsr $b0d0	                jsr w_update
.b1f9		60		rts		z_editor_o:     rts

;******  Return to file: platform/../words/all.asm


;******  Processing file: platform/../words/wordlist.asm

.b1fa						xt_also:
.b1fa						w_also:
.b1fa		20 25 b2	jsr $b225	                jsr w_get_order
.b1fd		20 db 8c	jsr $8cdb	                jsr w_over
.b200		20 1e 92	jsr $921e	                jsr w_swap
.b203		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.b206		20 2e b3	jsr $b32e	                jsr w_set_order
.b209		60		rts		z_also:         rts
.b20a						xt_definitions:
.b20a						w_definitions:
.b20a		a0 23		ldy #$23	                ldy #search_order_offset    ; Transfer byte variable
.b20c		b1 08		lda ($08),y	                lda (up),y                  ; SEARCH_ORDER[0] to
.b20e		a0 08		ldy #$08	                ldy #current_offset         ; byte variable CURRENT.
.b210		91 08		sta ($08),y	                sta (up),y
.b212		60		rts		z_definitions:  rts
.b213						xt_forth:
.b213						w_forth:
.b213		a0 23		ldy #$23	                ldy #search_order_offset
.b215		a9 00		lda #$00	                lda #0          ; The WID for Forth is 0.
.b217		91 08		sta ($08),y	                sta (up),y
.b219						z_forth:
.b219		60		rts		                rts
.b21a						xt_get_current:
.b21a						w_get_current:
.b21a		ca		dex		                dex
.b21b		ca		dex		                dex
.b21c		a0 08		ldy #$08	                ldy #current_offset
.b21e		b1 08		lda ($08),y	                lda (up),y
.b220		95 00		sta $00,x	                sta 0,x         ; CURRENT is a byte variable
.b222		74 01		stz $01,x	                stz 1,x         ; so the MSB is zero.
.b224		60		rts		z_get_current:  rts
.b225						xt_get_order:
.b225						w_get_order:
.b225		a0 22		ldy #$22	                ldy #num_order_offset
.b227		b1 08		lda ($08),y	                lda (up),y
.b229		85 25		sta $25		                sta tmp1
.b22b		f0 16		beq $b243	                beq _done       ; If zero, there are no wordlists.
.b22d						_loop:
.b22d		c6 25		dec $25		                dec tmp1        ; Count down by bytes.
.b22f		a9 23		lda #$23	                lda #search_order_offset
.b231		18		clc		                clc
.b232		65 25		adc $25		                adc tmp1
.b234		a8		tay		                tay
.b235		ca		dex		                dex
.b236		ca		dex		                dex
.b237		b1 08		lda ($08),y	                lda (up),y
.b239		95 00		sta $00,x	                sta 0,x         ; Search order array is bytes, so
.b23b		74 01		stz $01,x	                stz 1,x         ; put a zero in the high byte.
.b23d		a9 00		lda #$00	                lda #0
.b23f		c5 25		cmp $25		                cmp tmp1
.b241		d0 ea		bne $b22d	                bne _loop
.b243						_done:
.b243		ca		dex		                dex
.b244		ca		dex		                dex
.b245		a0 22		ldy #$22	                ldy #num_order_offset
.b247		b1 08		lda ($08),y	                lda (up),y
.b249		95 00		sta $00,x	                sta 0,x
.b24b		74 01		stz $01,x	                stz 1,x         ; We only support 8 wordlists.
.b24d		60		rts		z_get_order:    rts
.b24e						xt_only:
.b24e						w_only:
.b24e		20 71 93	jsr $9371	                jsr w_true
.b251		20 2e b3	jsr $b32e	                jsr w_set_order
.b254		60		rts		z_only:         rts
.b255						xt_order:
.b255						w_order:
.b255		20 ec 83	jsr $83ec	                jsr w_cr
.b258		20 25 b2	jsr $b225	                jsr w_get_order         ; ( wid_n ... wid_1 n )
.b25b		e8		inx		                inx                     ; pre-drop n
.b25c		e8		inx		                inx
.b25d		b5 fe		lda $fe,x	                lda $fe,x                 ; assumes no more than 255 wordlists
.b25f		f0 1e		beq $b27f	                beq _done
.b261		85 1e		sta $1e		                sta tmpdsp
.b263						_loop:
.b263		b5 00		lda $00,x	                lda 0,x                 ; fetch wid to A and drop it
.b265		e8		inx		                inx
.b266		e8		inx		                inx
.b267		20 80 b2	jsr $b280	                jsr order_print_wid_string   ; internal helper function
.b26a		c6 1e		dec $1e		                dec tmpdsp
.b26c		d0 f5		bne $b263	                bne _loop
.b26e		20 b5 91	jsr $91b5	                jsr w_space
.b271		20 b5 91	jsr $91b5	                jsr w_space
.b274		20 1a b2	jsr $b21a	                jsr w_get_current      ; ( wid )
.b277		b5 00		lda $00,x	                lda 0,x
.b279		20 80 b2	jsr $b280	                jsr order_print_wid_string
.b27c		20 ec 83	jsr $83ec	                jsr w_cr
.b27f						_done:
.b27f						z_order:
.b27f		60		rts		                rts
.b280						order_print_wid_string:
.b280		c9 04		cmp #$04	                cmp #4
.b282		90 09		bcc $b28d	                bcc _output_string      ; less than 4, print a real string
.b284		ca		dex		                dex
.b285		ca		dex		                dex
.b286		95 00		sta $00,x	                sta 0,x
.b288		74 01		stz $01,x	                stz 1,x
.b28a		4c df 94	jmp $94df	                jmp w_u_dot            ; JSR/RTS as this routine is not compiled
.b28d						_output_string:
.b28d		a8		tay		                tay
.b28e		b9 94 b2	lda $b294,y	                lda _wid_data,y
.b291		4c 10 d8	jmp $d810	                jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
.b294						_wid_data:
>b294		04				        .byte str_wid_forth            ; WID 0: "Forth "
>b295		05				        .byte str_wid_editor           ; WID 1: "Editor "
>b296		06				        .byte str_wid_assembler        ; WID 2: "Assembler "
>b297		07				        .byte str_wid_root             ; WID 3: "Root "
.b298						xt_previous:
.b298						w_previous:
.b298		20 25 b2	jsr $b225	                jsr w_get_order
.b29b		20 0a 8c	jsr $8c0a	                jsr w_nip
.b29e		20 b3 8c	jsr $8cb3	                jsr w_one_minus
.b2a1		20 2e b3	jsr $b32e	                jsr w_set_order
.b2a4		60		rts		z_previous:     rts
.b2a5						xt_root_wordlist:
.b2a5						w_root_wordlist:
.b2a5		ca		dex		                dex             ; The WID for the Root wordlist is 3.
.b2a6		ca		dex		                dex
.b2a7		a9 03		lda #$03	                lda #3
.b2a9		95 00		sta $00,x	                sta 0,x
.b2ab		74 01		stz $01,x	                stz 1,x
.b2ad						z_root_wordlist:
.b2ad		60		rts		                rts
.b2ae						xt_search_wordlist:
.b2ae		20 de d7	jsr $d7de	                jsr underflow_3
.b2b1						w_search_wordlist:
.b2b1		a5 08		lda $08		                lda up
.b2b3		18		clc		                clc
.b2b4		69 0a		adc #$0a	                adc #wordlists_offset
.b2b6		85 27		sta $27		                sta tmp2
.b2b8		a5 09		lda $09		                lda up+1
.b2ba		69 00		adc #$00	                adc #0          ; Adding carry
.b2bc		85 28		sta $28		                sta tmp2+1
.b2be		b5 00		lda $00,x	                lda 0,x
.b2c0		0a		asl a		                asl             ; Convert wid to offset in cells (x2)
.b2c1		65 27		adc $27		                adc tmp2
.b2c3		85 27		sta $27		                sta tmp2
.b2c5		90 02		bcc $b2c9	                bcc +
.b2c7		e6 28		inc $28		                inc tmp2+1      ; Propagate carry if needed.
.b2c9						+
.b2c9		e8		inx		                inx
.b2ca		e8		inx		                inx
.b2cb		b5 00		lda $00,x	                lda 0,x
.b2cd		15 01		ora $01,x	                ora 1,x
.b2cf		f0 4e		beq $b31f	                beq _done
.b2d1		a5 27		lda $27		                lda tmp2
.b2d3		05 28		ora $28		                ora tmp2+1
.b2d5		f0 48		beq $b31f	                beq _done
.b2d7		b2 27		lda ($27)	                lda (tmp2)              ; nt of first word in Dictionary
.b2d9		85 25		sta $25		                sta tmp1
.b2db		e6 27		inc $27		                inc tmp2                ; Move to the upper byte
.b2dd		d0 02		bne $b2e1	                bne +
.b2df		e6 28		inc $28		                inc tmp2+1
.b2e1						+
.b2e1		b2 27		lda ($27)	                lda (tmp2)
.b2e3		85 26		sta $26		                sta tmp1+1
.b2e5		20 b8 d6	jsr $d6b8	                jsr find_header_name
.b2e8		f0 31		beq $b31b	                beq _fail_done
.b2ea		e8		inx		                inx
.b2eb		e8		inx		                inx
.b2ec		a5 25		lda $25		                lda tmp1
.b2ee		95 00		sta $00,x	                sta 0,x
.b2f0		a5 26		lda $26		                lda tmp1+1
.b2f2		95 01		sta $01,x	                sta 1,x
.b2f4		20 5c 86	jsr $865c	                jsr w_dup              ; ( nt nt )
.b2f7		20 a6 9c	jsr $9ca6	                jsr w_name_to_int      ; ( nt xt )
.b2fa		20 1e 92	jsr $921e	                jsr w_swap             ; ( xt nt )
.b2fd		a0 00		ldy #$00	                ldy #0                  ; Prepare flag
.b2ff		f6 00		inc $00,x	                inc 0,x
.b301		d0 02		bne $b305	                bne +
.b303		f6 01		inc $01,x	                inc 1,x                 ; ( xt nt+1 )
.b305						+
.b305		a1 00		lda ($00,x)	                lda (0,x)               ; ( xt char )
.b307		29 02		and #$02	                and #IM
.b309		d0 08		bne $b313	                bne _immediate          ; bit set, we're immediate
.b30b		a9 ff		lda #$ff	                lda #$FF                ; We're not immediate, return -1
.b30d		95 00		sta $00,x	                sta 0,x
.b30f		95 01		sta $01,x	                sta 1,x
.b311		80 0e		bra $b321	                bra _done_nodrop
.b313						_immediate:
.b313		a9 01		lda #$01	                lda #1                  ; We're immediate, return 1
.b315		95 00		sta $00,x	                sta 0,x
.b317		74 01		stz $01,x	                stz 1,x
.b319		80 06		bra $b321	                bra _done_nodrop
.b31b						_fail_done:
.b31b		74 02		stz $02,x	                stz 2,x         ; failure flag
.b31d		74 03		stz $03,x	                stz 3,x
.b31f						_done:
.b31f		e8		inx		                inx
.b320		e8		inx		                inx
.b321						_done_nodrop:
.b321						z_search_wordlist:
.b321		60		rts		                rts
.b322						xt_set_current:
.b322		20 d4 d7	jsr $d7d4	                jsr underflow_1
.b325						w_set_current:
.b325		a0 08		ldy #$08	                ldy #current_offset
.b327		b5 00		lda $00,x	                lda 0,x         ; CURRENT is byte variable
.b329		91 08		sta ($08),y	                sta (up),y      ; so only the LSB is used.
.b32b		e8		inx		                inx
.b32c		e8		inx		                inx
.b32d		60		rts		z_set_current:  rts
.b32e						xt_set_order:
.b32e						w_set_order:
.b32e		a9 ff		lda #$ff	                lda #$FF
.b330		d5 01		cmp $01,x	                cmp 1,x
.b332		d0 12		bne $b346	                bne _start
.b334		d5 00		cmp $00,x	                cmp 0,x
.b336		d0 0e		bne $b346	                bne _start
.b338		ca		dex		                dex             ; Make room for the count.
.b339		ca		dex		                dex
.b33a		74 03		stz $03,x	                stz 3,x         ; ROOT-WORDLIST is 3
.b33c		a9 03		lda #$03	                lda #3
.b33e		95 02		sta $02,x	                sta 2,x
.b340		74 01		stz $01,x	                stz 1,x         ; Count is 1.
.b342		a9 01		lda #$01	                lda #1
.b344		95 00		sta $00,x	                sta 0,x
.b346						_start:
.b346		a0 22		ldy #$22	                ldy #num_order_offset
.b348		b5 00		lda $00,x	                lda 0,x
.b34a		91 08		sta ($08),y	                sta (up),y      ; #ORDER is a byte variable.
.b34c		85 25		sta $25		                sta tmp1        ; Save a copy for zero check and looping.
.b34e		e8		inx		                inx             ; Drop the count off the data stack.
.b34f		e8		inx		                inx
.b350		a5 25		lda $25		                lda tmp1
.b352		f0 0d		beq $b361	                beq _done       ; If zero, there are no wordlists.
.b354		a0 23		ldy #$23	                ldy #search_order_offset
.b356						_loop:
.b356		b5 00		lda $00,x	                lda 0,x         ; The search order is a byte array
.b358		91 08		sta ($08),y	                sta (up),y      ; so only save the LSB
.b35a		c8		iny		                iny
.b35b		e8		inx		                inx
.b35c		e8		inx		                inx
.b35d		c6 25		dec $25		                dec tmp1
.b35f		d0 f5		bne $b356	                bne _loop
.b361						_done:
.b361		60		rts		z_set_order:    rts
.b362						xt_to_order:
.b362						w_to_order:
.b362		20 59 93	jsr $9359	                jsr w_to_r
.b365		20 25 b2	jsr $b225	                jsr w_get_order
.b368		20 b5 8e	jsr $8eb5	                jsr w_r_from
.b36b		20 1e 92	jsr $921e	                jsr w_swap
.b36e		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.b371		20 2e b3	jsr $b32e	                jsr w_set_order
.b374		60		rts		z_to_order:     rts
.b375						xt_wordlist:
.b375						w_wordlist:
.b375		a0 09		ldy #$09	                ldy #num_wordlists_offset
.b377		b1 08		lda ($08),y	                lda (up),y      ; This is a byte variable, so only
.b379		c9 0c		cmp #$0c	                cmp #max_wordlists
.b37b		d0 05		bne $b382	                bne _ok
.b37d		a9 0b		lda #$0b	                lda #err_wordlist
.b37f		4c ea d7	jmp $d7ea	                jmp error
.b382						_ok:
.b382		1a		inc a		                ina             ; Increment the wordlist#
.b383		91 08		sta ($08),y	                sta (up),y      ; Save it into byte variable #wordlists
.b385		ca		dex		                dex             ; and put it on the stack.
.b386		ca		dex		                dex
.b387		95 00		sta $00,x	                sta 0,x
.b389		74 01		stz $01,x	                stz 1,x         ; 12 is the max, so upper byte is always zero.
.b38b		60		rts		z_wordlist:     rts

;******  Return to file: platform/../words/all.asm


;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../definitions.asm

=$0000						ram_start = $0000          ; start of installed RAM, must include zpage
=$0000						zpage     = ram_start      ; begin of Zero Page ($0000-$00ff)
=$0100						stack0    = $0100          ; begin of Return Stack ($0100-$01ff)
=$7f						zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
=32767						ram_end   = $8000-1        ; end of installed RAM
=31744						hist_buff = ram_end-$03ff  ; begin of history buffers
=$ff						rsp0      = $ff              ; initial Return Stack Pointer (65c02 stack)
=$ff						bsize     = $ff              ; size of input/output buffers
=$0000						user0     = zpage            ; TaliForth2 system variables
=512						buffer0   = stack0+$100      ; input buffer ($0200-$02ff)
=768						cp0       = buffer0+bsize+1  ; Dictionary starts after last buffer
=31744						cp_end    = hist_buff        ; Last RAM byte available for code
=$ff						padoffset = $ff              ; offset from CP to PAD (holds number strings)
=120						dsp0      = zpage_end-7    ; initial Data Stack Pointer
.b38c						cold_zp_table:
>b38c	0000	00 08				cp:         .word cp0+256+1024      ; Compiler Pointer
>b38e	0002	6f bb				dp:         .word dictionary_start  ; Dictionary Pointer
>b390	0004	00 00				ip:         .word 0                 ; Instruction Pointer (current xt)
>b392	0006	00 00				workword:   .word 0                 ; nt (not xt!) of word being compiled, except in
>b394	0008	00 03				up:         .word cp0               ; Forth user vars at start of available RAM
>b396	000a	00 00				insrc:      .word 0                 ; input source for SOURCE-ID (0 for keyboard)
>b398	000c	00 02				cib:        .word buffer0           ; address of current input buffer
>b39a	000e	00 00				ciblen:     .word 0                 ; length of current input buffer
>b39c	0010	00 00				toin:       .word 0                 ; pointer to CIB (>IN in Forth)
>b39e	0012	22 f0				output:     .word kernel_putc       ; vector for EMIT
>b3a0	0014	26 f0				input:      .word kernel_getc       ; vector for KEY
>b3a2	0016	34 f0				havekey:    .word kernel_kbhit      ; vector for KEY?
>b3a4	0018	0a 00				base:       .word 10                ; number radix, default decimal
>b3a6	001a	00 00				state:      .word 0                 ; STATE: -1 compile, 0 interpret
>b3a8	001c	00 00				status:     .word 0                 ; internal status used by CREATE : :NONAME ; ACCEPT NUMBER
>b3aa	001e					tmpdsp:     .byte ?         ; temporary DSP (X) storage (single byte)
>b3ab	001f					loopctrl:   .byte ?         ; Offset from lcbstack0 to current loop control block for DO/LOOP/+LOOP
>b3ac	0020					loopidx0    .byte ?         ; cached LSB of current loop index for LOOP (not +LOOP)
=$0100						lcbstack0 = stack0
=256						loopindex = lcbstack0+0     ; loop control block index for adjusted loopindex
=258						loopfufa  = lcbstack0+2     ; loop control block offset for limit fudge factor
>b3ad	0021					loopleave:  .word ?         ; tmp for LEAVE chaining ;TODO could it use existing tmp?
>b3af	0023					tmptos:     .word ?         ; temporary TOS storage
>b3b1	0025					tmp1:       .word ?         ; temporary storage
>b3b3	0027					tmp2:       .word ?         ; temporary storage
>b3b5	0029					tmp3:       .word ?         ; temporary storage (especially for print)
>b3b7	002b					tohold:     .word ?         ; pointer for formatted output
>b3b9	002d					scratch:    .word ?,?,?,?   ; 8 byte scratchpad (see UM/MOD)
>b3c1	0035					tmped:      .word ?,?,?     ; temporary for editors
.b3aa						cold_zp_table_end:
.b3aa						cold_user_table:
>b3aa	0000	14 00				nc_limit_offset:        .word 20        ; byte limit for Native Compile size
>b3ac	0002	00 00				uf_strip_offset:        .word 0         ; flag to strip underflow detection (0 off)
>b3ae	0004	00 00				blk_offset:             .word 0         ; BLK
>b3b0	0006	00 00				scr_offset:             .word 0         ; SCR
=12						max_wordlists = 12    ; Maximum number of wordlists supported (4 built-in, 8 user wordlists)
.b3b2	0008					marker_start_offset:
>b3b2	0008	00				current_offset:         .byte 0         ; CURRENT = FORTH-WORDLIST (compilation wordlist)
>b3b3	0009	04				num_wordlists_offset:   .byte 4         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
.b3b4	000a					wordlists_offset:
>b3b4	000a	6f bb				    .word dictionary_start              ; FORTH-WORDLIST
>b3b6	000c	de c9				    .word editor_dictionary_start       ; EDITOR-WORDLIST
>b3b8	000e	2e ca				    .word assembler_dictionary_start    ; ASSEMBLER-WORDLIST
>b3ba	0010	9d c9				    .word root_dictionary_start         ; ROOT-WORDLIST
>b3bc	0012	00 00 00 00 00 00 00 00		    .word 0,0,0,0,0,0,0,0               ; Space for 8 User wordlists
>b3c4	001a	00 00 00 00 00 00 00 00
>b3cc	0022	01				num_order_offset:       .byte 1         ; #ORDER (Number of wordlists in search order)
.b3cd	0023					search_order_offset:
>b3cd	0023	00 00 00 00 00 00 00 00		    .byte 0,0,0,0,0,0,0,0,0             ; SEARCH-ORDER (9 bytes to keep offsets even)
>b3d5	002b	00
.b3d6	002c					marker_end_offset:
>b3d6	002c	00 04				blkbuffer_offset:       .word cp0+256   ; Address of buffer (right after USER vars)
>b3d8	002e	00 00				buffblocknum_offset:    .word 0         ; Block number current in buffer
>b3da	0030	00 00				buffstatus_offset:      .word 0         ; Buffer status (bit 0 = used, bit 1 = dirty) (not in use)
>b3dc	0032	b6 af				blockread_offset:       .word xt_block_word_error   ; Vector to block reading routine
>b3de	0034	b6 af				blockwrite_offset:      .word xt_block_word_error   ; Vector to block writing routine
.b3e0						cold_user_table_end:
=$03						AscCC   = $03  ; break (CTRL-c)
=$07						AscBELL = $07  ; bell sound
=$08						AscBS   = $08  ; backspace
=$0a						AscLF   = $0A  ; line feed
=$0d						AscCR   = $0D  ; carriage return
=$1b						AscESC  = $1B  ; escape
=$20						AscSP   = $20  ; space
=$7f						AscDEL  = $7F  ; delete (CTRL-h)
=$10						AscCP   = $10  ; CTRL-p (used to recall previous input history)
=$0e						AscCN   = $0E  ; CTRL-n (used to recall next input history)
=$20						OpJSR   = $20
=$4c						OpJMP   = $4C
=$d0						OpBNE   = $D0
=$f0						OpBEQ   = $F0
=$60						OpRTS   = $60
=$80						OpBRA   = $80
=$24						OpBITzp = $24   ; used to save a branch occasionally
=5						N_FLAGS = 5                 ; Bits 5-7 are currently unused.
=1						CO = 1                      ; Compile Only
=2						IM = 2                      ; Immediate Word
=4						AN = 4                      ; Always Native Compile
=8						NN = 8                      ; Never Native Compile
=12						ST = AN+NN                  ; Stack juggling to be stripped for native compile
=16						HC = 16                     ; Word has Code Field Area (CFA)
=79						MAX_LINE_LENGTH  = 79      ; assumes 80 character lines

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../opcodes.asm

.b3e0						oc_index_table:
>b3e0		e0 b5 e4 b5 8b ba 8b ba		        .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc07
>b3e8		ec b5 f2 b5 f8 b5 fe b5
>b3f0		05 b6 09 b6 0f b6 8b ba		        .word oc08, oc09, oc0A, oc__, oc0C, oc0D, oc0E, oc0F
>b3f8		15 b6 19 b6 1d b6 21 b6
>b400		26 b6 2a b6 32 b6 8b ba		        .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
>b408		39 b6 3f b6 46 b6 4d b6
>b410		54 b6 58 b6 5e b6 8b ba		        .word oc18, oc19, oc1A, oc__, oc1C, oc1D, oc1E, oc1F
>b418		64 b6 68 b6 6e b6 74 b6
>b420		79 b6 7d b6 8b ba 8b ba		        .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
>b428		85 b6 8b b6 91 b6 97 b6
>b430		9e b6 a2 b6 a8 b6 8b ba		        .word oc28, oc29, oc2A, oc__, oc2C, oc2D, oc2E, oc2F
>b438		ae b6 b2 b6 b7 b6 bb b6
>b440		c0 b6 c4 b6 cc b6 8b ba		        .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
>b448		d3 b6 db b6 e2 b6 e9 b6
>b450		f0 b6 f4 b6 fa b6 8b ba		        .word oc38, oc39, oc3A, oc__, oc3C, oc3D, oc3E, oc3F
>b458		00 b7 06 b7 0c b7 12 b7
>b460		17 b7 1b b7 8b ba 8b ba		        .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
>b468		8b ba 23 b7 29 b7 2f b7
>b470		36 b7 3a b7 40 b7 8b ba		        .word oc48, oc49, oc4A, oc__, oc4C, oc4D, oc4E, oc4F
>b478		46 b7 4a b7 4e b7 52 b7
>b480		57 b7 5b b7 63 b7 8b ba		        .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
>b488		8b ba 6a b7 71 b7 78 b7
>b490		7f b7 83 b7 89 b7 8b ba		        .word oc58, oc59, oc5A, oc__, oc__, oc5D, oc5E, oc5F
>b498		8b ba 8d b7 93 b7 99 b7
>b4a0		9e b7 a2 b7 8b ba 8b ba		        .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
>b4a8		aa b7 b0 b7 b6 b7 bc b7
>b4b0		c3 b7 c7 b7 cd b7 8b ba		        .word oc68, oc69, oc6A, oc__, oc6C, oc6D, oc6E, oc6F
>b4b8		d3 b7 d9 b7 dd b7 e1 b7
>b4c0		e6 b7 ea b7 f2 b7 8b ba		        .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
>b4c8		f9 b7 00 b8 07 b8 0e b8
>b4d0		15 b8 19 b8 1f b8 8b ba		        .word oc78, oc79, oc7A, oc__, oc7C, oc7D, oc7E, oc7F
>b4d8		23 b8 2a b8 30 b8 36 b8
>b4e0		3b b8 3f b8 8b ba 8b ba		        .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc87
>b4e8		47 b8 4d b8 53 b8 59 b8
>b4f0		60 b8 64 b8 6a b8 8b ba		        .word oc88, oc89, oc8A, oc__, oc8C, oc8D, oc8E, oc8F
>b4f8		6e b8 72 b8 76 b8 7a b8
>b500		7f b8 83 b8 8b b8 8b ba		        .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
>b508		92 b8 99 b8 a0 b8 a7 b8
>b510		ae b8 b2 b8 b8 b8 8b ba		        .word oc98, oc99, oc9A, oc__, oc9C, oc9D, oc9E, oc9F
>b518		bc b8 c0 b8 c6 b8 cc b8
>b520		d1 b8 d7 b8 df b8 8b ba		        .word ocA0, ocA1, ocA2, oc__, ocA4, ocA5, ocA6, ocA7
>b528		e5 b8 eb b8 f1 b8 f7 b8
>b530		fe b8 02 b9 08 b9 8b ba		        .word ocA8, ocA9, ocAA, oc__, ocAC, ocAD, ocAE, ocAF
>b538		0c b9 10 b9 14 b9 18 b9
>b540		1d b9 21 b9 29 b9 8b ba		        .word ocB0, ocB1, ocB2, oc__, ocB4, ocB5, ocB6, ocB7
>b548		30 b9 37 b9 3e b9 45 b9
>b550		4c b9 50 b9 56 b9 8b ba		        .word ocB8, ocB9, ocBA, oc__, ocBC, ocBD, ocBE, ocBF
>b558		5a b9 60 b9 66 b9 6c b9
>b560		71 b9 77 b9 8b ba 8b ba		        .word ocC0, ocC1, oc__, oc__, ocC4, ocC5, ocC6, ocC7
>b568		7f b9 85 b9 8b b9 91 b9
>b570		98 b9 9c b9 a2 b9 8b ba		        .word ocC8, ocC9, ocCA, oc__, ocCC, ocCD, ocCE, ocCF
>b578		a6 b9 aa b9 ae b9 b2 b9
>b580		b7 b9 bb b9 c3 b9 8b ba		        .word ocD0, ocD1, ocD2, oc__, oc__, ocD5, ocD6, ocD7
>b588		8b ba ca b9 d1 b9 d8 b9
>b590		df b9 e3 b9 e9 b9 8b ba		        .word ocD8, ocD9, ocDA, oc__, oc__, ocDD, ocDE, ocDF
>b598		8b ba ed b9 f3 b9 f9 b9
>b5a0		fe b9 04 ba 8b ba 8b ba		        .word ocE0, ocE1, oc__, oc__, ocE4, ocE5, ocE6, ocE7
>b5a8		0c ba 12 ba 18 ba 1e ba
>b5b0		25 ba 29 ba 2f ba 8b ba		        .word ocE8, ocE9, ocEA, oc__, ocEC, ocED, ocEE, ocEF
>b5b8		33 ba 37 ba 3b ba 3f ba
>b5c0		44 ba 48 ba 50 ba 8b ba		        .word ocF0, ocF1, ocF2, oc__, oc__, ocF5, ocF6, ocF7
>b5c8		8b ba 57 ba 5e ba 65 ba
>b5d0		6c ba 70 ba 76 ba 8b ba		        .word ocF8, ocF9, ocFA, oc__, oc__, ocFD, ocFE, ocFF
>b5d8		8b ba 7a ba 80 ba 86 ba
>b5e0		83 62 72 6b				oc00:	.text 2*64+3, "brk"              ; enforce the signature byte
>b5e4		87 6f 72 61 2e 7a 78 69			oc01:	.text 2*64+7, "ora.zxi"
>b5ec		85 74 73 62 2e 7a		    oc04:   .text 2*64+5, "tsb.z"
>b5f2		85 6f 72 61 2e 7a			oc05:	.text 2*64+5, "ora.z"
>b5f8		85 61 73 6c 2e 7a			oc06:	.text 2*64+5, "asl.z"
>b5fe		86 72 6d 62 30 2e 7a			oc07:	.text 2*64+6, "rmb0.z"
>b605		43 70 68 70				oc08:	.text 1*64+3, "php"
>b609		85 6f 72 61 2e 23			oc09:	.text 2*64+5, "ora.#"
>b60f		45 61 73 6c 2e 61			oc0A:	.text 1*64+5, "asl.a"
>b615		c3 74 73 62				oc0C:	.text 3*64+3, "tsb"
>b619		c3 6f 72 61				oc0D:	.text 3*64+3, "ora"
>b61d		c3 61 73 6c				oc0E:	.text 3*64+3, "asl"
>b621		c4 62 62 72 30				oc0F:	.text 3*64+4, "bbr0"
>b626		83 62 70 6c				oc10:	.text 2*64+3, "bpl"
>b62a		87 6f 72 61 2e 7a 69 79			oc11:	.text 2*64+7, "ora.ziy"
>b632		86 6f 72 61 2e 7a 69			oc12:	.text 2*64+6, "ora.zi"
>b639		85 74 72 62 2e 7a			oc14:	.text 2*64+5, "trb.z"
>b63f		86 6f 72 61 2e 7a 78			oc15:	.text 2*64+6, "ora.zx"
>b646		86 61 73 6c 2e 7a 78			oc16:	.text 2*64+6, "asl.zx"
>b64d		86 72 6d 62 31 2e 7a			oc17:	.text 2*64+6, "rmb1.z"
>b654		43 63 6c 63				oc18:	.text 1*64+3, "clc"
>b658		c5 6f 72 61 2e 79			oc19:	.text 3*64+5, "ora.y"
>b65e		45 69 6e 63 2e 61			oc1A:	.text 1*64+5, "inc.a"
>b664		c3 74 72 62				oc1C:	.text 3*64+3, "trb"
>b668		c5 6f 72 61 2e 78			oc1D:	.text 3*64+5, "ora.x"
>b66e		c5 61 73 6c 2e 78			oc1E:	.text 3*64+5, "asl.x"
>b674		c4 62 62 72 31				oc1F:	.text 3*64+4, "bbr1"
>b679		c3 6a 73 72				oc20:	.text 3*64+3, "jsr"
>b67d		87 61 6e 64 2e 7a 78 69			oc21:	.text 2*64+7, "and.zxi"
>b685		85 62 69 74 2e 7a			oc24:	.text 2*64+5, "bit.z"
>b68b		85 61 6e 64 2e 7a			oc25:	.text 2*64+5, "and.z"
>b691		85 72 6f 6c 2e 7a			oc26:	.text 2*64+5, "rol.z"
>b697		86 72 6d 62 32 2e 7a			oc27:	.text 2*64+6, "rmb2.z"
>b69e		43 70 6c 70				oc28:	.text 1*64+3, "plp"
>b6a2		85 61 6e 64 2e 23			oc29:	.text 2*64+5, "and.#"
>b6a8		45 72 6f 6c 2e 61			oc2A:	.text 1*64+5, "rol.a"
>b6ae		c3 62 69 74				oc2C:	.text 3*64+3, "bit"
>b6b2		c4 61 6e 64 2e				oc2D:	.text 3*64+4, "and."
>b6b7		c3 72 6f 6c				oc2E:	.text 3*64+3, "rol"
>b6bb		c4 62 62 72 32				oc2F:	.text 3*64+4, "bbr2"
>b6c0		83 62 6d 69				oc30:	.text 2*64+3, "bmi"
>b6c4		87 61 6e 64 2e 7a 69 79			oc31:	.text 2*64+7, "and.ziy"
>b6cc		86 61 6e 64 2e 7a 69			oc32:	.text 2*64+6, "and.zi"
>b6d3		87 62 69 74 2e 7a 78 69			oc34:	.text 2*64+7, "bit.zxi"
>b6db		86 61 6e 64 2e 7a 78			oc35:	.text 2*64+6, "and.zx"
>b6e2		86 72 6f 6c 2e 7a 78			oc36:	.text 2*64+6, "rol.zx"
>b6e9		86 72 6d 62 33 2e 7a			oc37:	.text 2*64+6, "rmb3.z"
>b6f0		43 73 65 63				oc38:	.text 1*64+3, "sec"
>b6f4		c5 61 6e 64 2e 79			oc39:	.text 3*64+5, "and.y"
>b6fa		45 64 65 63 2e 61			oc3A:	.text 1*64+5, "dec.a"
>b700		c5 62 69 74 2e 78			oc3C:	.text 3*64+5, "bit.x"
>b706		c5 61 6e 64 2e 78			oc3D:	.text 3*64+5, "and.x"
>b70c		c5 72 6f 6c 2e 78			oc3E:	.text 3*64+5, "rol.x"
>b712		c4 62 62 72 33				oc3F:	.text 3*64+4, "bbr3"
>b717		43 72 74 69				oc40:	.text 1*64+3, "rti"
>b71b		87 65 6f 72 2e 7a 78 69			oc41:	.text 2*64+7, "eor.zxi"
>b723		85 65 6f 72 2e 7a			oc45:	.text 2*64+5, "eor.z"
>b729		85 6c 73 72 2e 7a			oc46:	.text 2*64+5, "lsr.z"
>b72f		86 72 62 6d 34 2e 7a			oc47:	.text 2*64+6, "rbm4.z"
>b736		43 70 68 61				oc48:	.text 1*64+3, "pha"
>b73a		85 65 6f 72 2e 23			oc49:	.text 2*64+5, "eor.#"
>b740		45 6c 73 72 2e 61			oc4A:	.text 1*64+5, "lsr.a"
>b746		c3 6a 6d 70				oc4C:	.text 3*64+3, "jmp"
>b74a		c3 65 6f 72				oc4D:	.text 3*64+3, "eor"
>b74e		c3 6c 73 72				oc4E:	.text 3*64+3, "lsr"
>b752		c4 62 62 72 34				oc4F:	.text 3*64+4, "bbr4"
>b757		83 62 76 63				oc50:	.text 2*64+3, "bvc"
>b75b		87 65 6f 72 2e 7a 69 79			oc51:	.text 2*64+7, "eor.ziy"
>b763		86 65 6f 72 2e 7a 69			oc52:	.text 2*64+6, "eor.zi"
>b76a		86 65 6f 72 2e 7a 78			oc55:	.text 2*64+6, "eor.zx"
>b771		86 6c 73 72 2e 7a 78			oc56:	.text 2*64+6, "lsr.zx"
>b778		86 72 62 6d 35 2e 7a			oc57:	.text 2*64+6, "rbm5.z"
>b77f		43 63 6c 69				oc58:	.text 1*64+3, "cli"
>b783		c5 65 6f 72 2e 79			oc59:	.text 3*64+5, "eor.y"
>b789		43 70 68 79				oc5A:	.text 1*64+3, "phy"
>b78d		c5 65 6f 72 2e 78			oc5D:	.text 3*64+5, "eor.x"
>b793		c5 6c 73 72 2e 78			oc5E:	.text 3*64+5, "lsr.x"
>b799		c4 62 62 72 35				oc5F:	.text 3*64+4, "bbr5"
>b79e		43 72 74 73				oc60:	.text 1*64+3, "rts"
>b7a2		87 61 64 63 2e 7a 78 69			oc61:	.text 2*64+7, "adc.zxi"
>b7aa		85 73 74 7a 2e 7a			oc64:	.text 2*64+5, "stz.z"
>b7b0		85 61 64 63 2e 7a			oc65:	.text 2*64+5, "adc.z"
>b7b6		85 72 6f 72 2e 7a			oc66:	.text 2*64+5, "ror.z"
>b7bc		86 72 6d 62 36 2e 7a			oc67:	.text 2*64+6, "rmb6.z"
>b7c3		43 70 6c 61				oc68:	.text 1*64+3, "pla"
>b7c7		85 61 64 63 2e 23			oc69:	.text 2*64+5, "adc.#"
>b7cd		45 72 6f 72 2e 61			oc6A:	.text 1*64+5, "ror.a"
>b7d3		c5 6a 6d 70 2e 69			oc6C:	.text 3*64+5, "jmp.i"
>b7d9		c3 61 64 63				oc6D:	.text 3*64+3, "adc"
>b7dd		c3 72 6f 72				oc6E:	.text 3*64+3, "ror"
>b7e1		c4 62 62 72 36				oc6F:	.text 3*64+4, "bbr6"
>b7e6		83 62 76 73				oc70:	.text 2*64+3, "bvs"
>b7ea		87 61 64 63 2e 7a 69 79			oc71:	.text 2*64+7, "adc.ziy"
>b7f2		86 61 64 63 2e 7a 69			oc72:	.text 2*64+6, "adc.zi"
>b7f9		86 73 74 7a 2e 7a 78			oc74:	.text 2*64+6, "stz.zx"
>b800		86 61 64 63 2e 7a 78			oc75:	.text 2*64+6, "adc.zx"
>b807		86 72 6f 72 2e 7a 78			oc76:	.text 2*64+6, "ror.zx"
>b80e		86 72 6d 62 37 2e 7a			oc77:	.text 2*64+6, "rmb7.z"
>b815		43 73 65 69				oc78:	.text 1*64+3, "sei"
>b819		c5 61 64 63 2e 79			oc79:	.text 3*64+5, "adc.y"
>b81f		43 70 6c 79				oc7A:	.text 1*64+3, "ply"
>b823		c6 6a 6d 70 2e 78 69			oc7C:	.text 3*64+6, "jmp.xi"
>b82a		c5 61 64 63 2e 78			oc7D:	.text 3*64+5, "adc.x"
>b830		c5 72 6f 72 2e 78			oc7E:	.text 3*64+5, "ror.x"
>b836		c4 62 62 72 37				oc7F:	.text 3*64+4, "bbr7"
>b83b		83 62 72 61				oc80:	.text 2*64+3, "bra"
>b83f		87 73 74 61 2e 7a 78 69			oc81:	.text 2*64+7, "sta.zxi"
>b847		85 73 74 79 2e 7a			oc84:	.text 2*64+5, "sty.z"
>b84d		85 73 74 61 2e 7a			oc85:	.text 2*64+5, "sta.z"
>b853		85 73 74 78 2e 7a			oc86:	.text 2*64+5, "stx.z"
>b859		86 73 6d 62 30 2e 7a			oc87:	.text 2*64+6, "smb0.z"
>b860		43 64 65 79				oc88:	.text 1*64+3, "dey"
>b864		85 62 69 74 2e 23			oc89:	.text 2*64+5, "bit.#"
>b86a		43 74 78 61				oc8A:	.text 1*64+3, "txa"
>b86e		c3 73 74 79				oc8C:	.text 3*64+3, "sty"
>b872		c3 73 74 61				oc8D:	.text 3*64+3, "sta"
>b876		c3 73 74 78				oc8E:	.text 3*64+3, "stx"
>b87a		c4 62 62 73 30				oc8F:	.text 3*64+4, "bbs0"
>b87f		83 62 63 63				oc90:	.text 2*64+3, "bcc"
>b883		87 73 74 61 2e 7a 69 79			oc91:	.text 2*64+7, "sta.ziy"
>b88b		86 73 74 61 2e 7a 69			oc92:	.text 2*64+6, "sta.zi"
>b892		86 73 74 79 2e 7a 78			oc94:	.text 2*64+6, "sty.zx"
>b899		86 73 74 61 2e 7a 78			oc95:	.text 2*64+6, "sta.zx"
>b8a0		86 73 74 78 2e 7a 79			oc96:	.text 2*64+6, "stx.zy"
>b8a7		86 73 6d 62 31 2e 7a			oc97:	.text 2*64+6, "smb1.z"
>b8ae		43 74 79 61				oc98:	.text 1*64+3, "tya"
>b8b2		c5 73 74 61 2e 79			oc99:	.text 3*64+5, "sta.y"
>b8b8		43 74 78 73				oc9A:	.text 1*64+3, "txs"
>b8bc		c3 73 74 7a				oc9C:	.text 3*64+3, "stz"
>b8c0		c5 73 74 61 2e 78			oc9D:	.text 3*64+5, "sta.x"
>b8c6		c5 73 74 7a 2e 78			oc9E:	.text 3*64+5, "stz.x"
>b8cc		c4 62 62 73 31				oc9F:	.text 3*64+4, "bbs1"
>b8d1		85 6c 64 79 2e 23			ocA0:	.text 2*64+5, "ldy.#"
>b8d7		87 6c 64 61 2e 7a 78 69			ocA1:	.text 2*64+7, "lda.zxi"
>b8df		85 6c 64 78 2e 23			ocA2:	.text 2*64+5, "ldx.#"
>b8e5		85 6c 64 79 2e 7a			ocA4:	.text 2*64+5, "ldy.z"
>b8eb		85 6c 64 61 2e 7a			ocA5:	.text 2*64+5, "lda.z"
>b8f1		85 6c 64 78 2e 7a			ocA6:	.text 2*64+5, "ldx.z"
>b8f7		86 73 6d 62 32 2e 7a			ocA7:	.text 2*64+6, "smb2.z"
>b8fe		43 74 61 79				ocA8:	.text 1*64+3, "tay"
>b902		85 6c 64 61 2e 23			ocA9:	.text 2*64+5, "lda.#"
>b908		43 74 61 78				ocAA:	.text 1*64+3, "tax"
>b90c		c3 6c 64 79				ocAC:	.text 3*64+3, "ldy"
>b910		c3 6c 64 61				ocAD:	.text 3*64+3, "lda"
>b914		c3 6c 64 78				ocAE:	.text 3*64+3, "ldx"
>b918		c4 62 62 73 32				ocAF:	.text 3*64+4, "bbs2"
>b91d		83 62 63 73				ocB0:	.text 2*64+3, "bcs"
>b921		87 6c 64 61 2e 7a 69 79			ocB1:	.text 2*64+7, "lda.ziy"
>b929		86 6c 64 61 2e 7a 69			ocB2:	.text 2*64+6, "lda.zi"
>b930		86 6c 64 79 2e 7a 78			ocB4:	.text 2*64+6, "ldy.zx"
>b937		86 6c 64 61 2e 7a 78			ocB5:	.text 2*64+6, "lda.zx"
>b93e		86 6c 64 78 2e 7a 79			ocB6:	.text 2*64+6, "ldx.zy"
>b945		86 73 6d 62 33 2e 7a			ocB7:	.text 2*64+6, "smb3.z"
>b94c		43 63 6c 76				ocB8:	.text 1*64+3, "clv"
>b950		c5 6c 64 61 2e 79			ocB9:	.text 3*64+5, "lda.y"
>b956		43 74 73 78				ocBA:	.text 1*64+3, "tsx"
>b95a		c5 6c 64 79 2e 78			ocBC:	.text 3*64+5, "ldy.x"
>b960		c5 6c 64 61 2e 78			ocBD:	.text 3*64+5, "lda.x"
>b966		c5 6c 64 78 2e 79			ocBE:	.text 3*64+5, "ldx.y"
>b96c		c4 62 62 73 34				ocBF:	.text 3*64+4, "bbs4"
>b971		85 63 70 79 2e 23			ocC0:	.text 2*64+5, "cpy.#"
>b977		87 63 6d 70 2e 7a 78 69			ocC1:	.text 2*64+7, "cmp.zxi"
>b97f		85 63 70 79 2e 7a			ocC4:	.text 2*64+5, "cpy.z"
>b985		85 63 6d 70 2e 7a			ocC5:	.text 2*64+5, "cmp.z"
>b98b		85 64 65 63 2e 7a			ocC6:	.text 2*64+5, "dec.z"
>b991		86 73 6d 62 34 2e 7a			ocC7:	.text 2*64+6, "smb4.z"
>b998		43 69 6e 79				ocC8:	.text 1*64+3, "iny"
>b99c		85 63 6d 70 2e 23			ocC9:	.text 2*64+5, "cmp.#"
>b9a2		43 64 65 78				ocCA:	.text 1*64+3, "dex"
>b9a6		c3 63 70 79				ocCC:	.text 3*64+3, "cpy"
>b9aa		c3 63 6d 70				ocCD:	.text 3*64+3, "cmp"
>b9ae		c3 64 65 63				ocCE:	.text 3*64+3, "dec"
>b9b2		c4 62 62 73 34				ocCF:	.text 3*64+4, "bbs4"
>b9b7		83 62 6e 65				ocD0:	.text 2*64+3, "bne"
>b9bb		87 63 6d 70 2e 7a 69 79			ocD1:	.text 2*64+7, "cmp.ziy"
>b9c3		86 63 6d 70 2e 7a 69			ocD2:	.text 2*64+6, "cmp.zi"
>b9ca		86 63 6d 70 2e 7a 78			ocD5:	.text 2*64+6, "cmp.zx"
>b9d1		86 64 65 63 2e 7a 78			ocD6:	.text 2*64+6, "dec.zx"
>b9d8		86 73 6d 62 35 2e 7a			ocD7:	.text 2*64+6, "smb5.z"
>b9df		43 63 6c 64				ocD8:	.text 1*64+3, "cld"
>b9e3		c5 63 6d 70 2e 79			ocD9:	.text 3*64+5, "cmp.y"
>b9e9		43 70 68 78				ocDA:	.text 1*64+3, "phx"
>b9ed		c5 63 6d 70 2e 78			ocDD:	.text 3*64+5, "cmp.x"
>b9f3		c5 64 65 63 2e 78			ocDE:	.text 3*64+5, "dec.x"
>b9f9		c4 62 62 73 35				ocDF:	.text 3*64+4, "bbs5"
>b9fe		85 63 70 78 2e 23			ocE0:	.text 2*64+5, "cpx.#"
>ba04		87 73 62 63 2e 7a 78 69			ocE1:	.text 2*64+7, "sbc.zxi"
>ba0c		85 63 70 78 2e 7a			ocE4:	.text 2*64+5, "cpx.z"
>ba12		85 73 62 63 2e 7a			ocE5:	.text 2*64+5, "sbc.z"
>ba18		85 69 6e 63 2e 7a			ocE6:	.text 2*64+5, "inc.z"
>ba1e		86 73 6d 62 36 2e 7a			ocE7:	.text 2*64+6, "smb6.z"
>ba25		43 69 6e 78				ocE8:	.text 1*64+3, "inx"
>ba29		85 73 62 63 2e 23			ocE9:	.text 2*64+5, "sbc.#"
>ba2f		43 6e 6f 70				ocEA:	.text 1*64+3, "nop"
>ba33		c3 63 70 78				ocEC:	.text 3*64+3, "cpx"
>ba37		c3 73 62 63				ocED:	.text 3*64+3, "sbc"
>ba3b		c3 69 6e 63				ocEE:	.text 3*64+3, "inc"
>ba3f		c4 62 62 73 36				ocEF:	.text 3*64+4, "bbs6"
>ba44		83 62 65 71				ocF0:	.text 2*64+3, "beq"
>ba48		87 73 62 63 2e 7a 69 79			ocF1:	.text 2*64+7, "sbc.ziy"
>ba50		86 73 62 63 2e 7a 69			ocF2:	.text 2*64+6, "sbc.zi"
>ba57		86 73 62 63 2e 7a 78			ocF5:	.text 2*64+6, "sbc.zx"
>ba5e		86 69 6e 63 2e 7a 78			ocF6:	.text 2*64+6, "inc.zx"
>ba65		86 73 6d 62 37 2e 7a			ocF7:	.text 2*64+6, "smb7.z"
>ba6c		43 73 65 64				ocF8:	.text 1*64+3, "sed"
>ba70		c5 73 62 63 2e 79			ocF9:	.text 3*64+5, "sbc.y"
>ba76		43 70 6c 78				ocFA:	.text 1*64+3, "plx"
>ba7a		c5 73 62 63 2e 78			ocFD:	.text 3*64+5, "sbc.x"
>ba80		c5 69 6e 63 2e 78			ocFE:	.text 3*64+5, "inc.x"
>ba86		c4 62 62 73 37				ocFF:	.text 3*64+4, "bbs7"
>ba8b		01 3f					oc__:	.text 1, "?"

;******  Return to file: platform/../taliforth.asm

.ba8d						forth_words_start:
>ba8d		20 63 72 20 2e 28 20 54		.binary "forth_words.asc"
>ba95		61 6c 69 20 46 6f 72 74 68 20 32 20 66 6f 72 20
>baa5		74 68 65 20 36 35 63 30 32 29 20 63 72 20 2e 28
>bab5		20 56 65 72 73 69 6f 6e 20 31 2e 31 20 30 36 2e
>bac5		20 41 70 72 20 32 30 32 34 20 29 20 63 72 20 2e
>bad5		28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>bae5		2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>baf5		65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>bb05		77 65 6c 6c 2c 20 50 61 74 72 69 63 6b 20 53 75
>bb15		72 72 79 29 20 63 72 20 2e 28 20 54 61 6c 69 20
>bb25		46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77 69
>bb35		74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e 4f
>bb45		20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e 28
>bb55		20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20 65
>bb65		78 69 74 29 20 63 72 20
.bb6d						forth_words_end:
.bb6d						user_words_start:
>bb6d		20 20				.binary "user_words.asc"
.bb6f						user_words_end:

;******  Processing file: platform/../words/headers.asm

.bb6f						dictionary_start:
.bb6f						nt_drop:
>bb6f		04 00				        .byte 4, 0
>bb71		7b bb 53 86 58 86		        .word nt_dup, xt_drop, z_drop
>bb77		64 72 6f 70			        .text "drop"
.bb7b						nt_dup:
>bb7b		03 00				        .byte 3, 0
>bb7d		86 bb 59 86 66 86		        .word nt_swap, xt_dup, z_dup
>bb83		64 75 70			        .text "dup"
.bb86						nt_swap:
>bb86		04 00				        .byte 4, 0
>bb88		92 bb 1b 92 2e 92		        .word nt_store, xt_swap, z_swap
>bb8e		73 77 61 70			        .text "swap"
.bb92						nt_store:
>bb92		01 00				        .byte 1, 0
>bb94		9b bb 05 92 1a 92		        .word nt_fetch, xt_store, z_store
>bb9a		21				        .text "!"
.bb9b						nt_fetch:
>bb9b		01 00				        .byte 1, 0
>bb9d		a4 bb e6 87 f8 87		        .word nt_over, xt_fetch, z_fetch
>bba3		40				        .text "@"
.bba4						nt_over:
>bba4		04 00				        .byte 4, 0
>bba6		b0 bb d8 8c e5 8c		        .word nt_to_r, xt_over, z_over
>bbac		6f 76 65 72			        .text "over"
.bbb0						nt_to_r:
>bbb0		02 0d				        .byte 2, CO+ST       ; native skips stack juggling
>bbb2		ba bb 59 93 6e 93		        .word nt_r_from, xt_to_r, z_to_r
>bbb8		3e 72				        .text ">r"
.bbba						nt_r_from:
>bbba		02 0d				        .byte 2, CO+ST          ; native skips stack juggling
>bbbc		c4 bb b5 8e c7 8e		        .word nt_r_fetch, xt_r_from, z_r_from
>bbc2		72 3e				        .text "r>"
.bbc4						nt_r_fetch:
>bbc4		02 0d				        .byte 2, CO+ST          ; native skips stack juggling
>bbc6		ce bb 9e 8e b2 8e		        .word nt_nip, xt_r_fetch, z_r_fetch
>bbcc		72 40				        .text "r@"
.bbce						nt_nip:
>bbce		03 00				        .byte 3, 0
>bbd0		d9 bb 07 8c 14 8c		        .word nt_rot, xt_nip, z_nip
>bbd6		6e 69 70			        .text "nip"
.bbd9						nt_rot:
>bbd9		03 00				        .byte 3, 0
>bbdb		e4 bb 59 8f 74 8f		        .word nt_not_rot, xt_rot, z_rot
>bbe1		72 6f 74			        .text "rot"
.bbe4						nt_not_rot:
>bbe4		04 00				        .byte 4, 0
>bbe6		f0 bb ea 9c 05 9d		        .word nt_tuck, xt_not_rot, z_not_rot
>bbec		2d 72 6f 74			        .text "-rot"
.bbf0						nt_tuck:
>bbf0		04 00				        .byte 4, 0
>bbf2		fc bb 7a 93 93 93		        .word nt_comma, xt_tuck, z_tuck
>bbf8		74 75 63 6b			        .text "tuck"
.bbfc						nt_comma:
>bbfc		01 00				        .byte 1, 0
>bbfe		05 bc ab 83 b9 83		        .word nt_c_fetch, xt_comma, z_comma
>bc04		2c				        .text ","
.bc05						nt_c_fetch:
>bc05		02 00				        .byte 2, 0
>bc07		0f bc 2d 83 36 83		        .word nt_c_store, xt_c_fetch, z_c_fetch
>bc0d		63 40				        .text "c@"
.bc0f						nt_c_store:
>bc0f		02 00				        .byte 2, 0
>bc11		19 bc 37 83 42 83		        .word nt_plus_store, xt_c_store, z_c_store
>bc17		63 21				        .text "c!"
.bc19						nt_plus_store:
>bc19		02 00				        .byte 2, 0
>bc1b		23 bc 39 8e 53 8e		        .word nt_zero, xt_plus_store, z_plus_store
>bc21		2b 21				        .text "+!"
.bc23						nt_zero:
>bc23		01 00				        .byte 1, 0
>bc25		2c bc 66 9e 6c 9e		        .word nt_one, xt_zero, z_zero
>bc2b		30				        .text "0"
.bc2c						nt_one:
>bc2c		01 00				        .byte 1, 0
>bc2e		35 bc 00 9e 08 9e		        .word nt_two, xt_one, z_one
>bc34		31				        .text "1"
.bc35						nt_two:
>bc35		01 00				        .byte 1, 0
>bc37		3e bc 31 9e 39 9e		        .word nt_execute, xt_two, z_two
>bc3d		32				        .text "2"
.bc3e						nt_execute:
>bc3e		07 00				        .byte 7, 0
>bc40		4d bc d1 87 d7 87		        .word nt_emit, xt_execute, z_execute
>bc46		65 78 65 63 75 74 65		        .text "execute"
.bc4d						nt_emit:
>bc4d		04 08				        .byte 4, NN
>bc4f		59 bc 7f 86 89 86		        .word nt_type, xt_emit, z_emit
>bc55		65 6d 69 74			        .text "emit"
.bc59						nt_type:
>bc59		04 00				        .byte 4, 0
>bc5b		65 bc b1 94 db 94		        .word nt_dot, xt_type, z_type
>bc61		74 79 70 65			        .text "type"
.bc65						nt_dot:
>bc65		01 00				        .byte 1, 0
>bc67		6e bc e9 85 0a 86		        .word nt_u_dot, xt_dot, z_dot
>bc6d		2e				        .text "."
.bc6e						nt_u_dot:
>bc6e		02 00				        .byte 2, 0
>bc70		78 bc dc 94 e7 94		        .word nt_u_dot_r, xt_u_dot, z_u_dot
>bc76		75 2e				        .text "u."
.bc78						nt_u_dot_r:
>bc78		03 00				        .byte 3, 0
>bc7a		83 bc e8 94 09 95		        .word nt_dot_r, xt_u_dot_r, z_u_dot_r
>bc80		75 2e 72			        .text "u.r"
.bc83						nt_dot_r:
>bc83		02 00				        .byte 2, 0
>bc85		8d bc 25 86 52 86		        .word nt_d_dot, xt_dot_r, z_dot_r
>bc8b		2e 72				        .text ".r"
.bc8d						nt_d_dot:
>bc8d		02 00				        .byte 2, 0
>bc8f		97 bc ef 9e 0d 9f		        .word nt_d_dot_r, xt_d_dot, z_d_dot
>bc95		64 2e				        .text "d."
.bc97						nt_d_dot_r:
>bc97		03 00				        .byte 3, 0
>bc99		a2 bc 0e 9f 38 9f		        .word nt_m_star_slash, xt_d_dot_r, z_d_dot_r
>bc9f		64 2e 72			        .text "d.r"
.bca2						nt_m_star_slash:
>bca2		03 00				        .byte 3, 0
>bca4		ad bc 39 9f 9f 9f		        .word nt_ud_dot, xt_m_star_slash, z_m_star_slash
>bcaa		6d 2a 2f			        .text "m*/"
.bcad						nt_ud_dot:
>bcad		03 00				        .byte 3, 0
>bcaf		b8 bc 0a a0 1c a0		        .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
>bcb5		75 64 2e			        .text "ud."
.bcb8						nt_ud_dot_r:
>bcb8		04 00				        .byte 4, 0
>bcba		c4 bc 1d a0 3b a0		        .word nt_question, xt_ud_dot_r, z_ud_dot_r
>bcc0		75 64 2e 72			        .text "ud.r"
.bcc4						nt_question:
>bcc4		01 00				        .byte 1, 0
>bcc6		cd bc 3f 99 45 99		        .word nt_false, xt_question, z_question
>bccc		3f				        .text "?"
.bccd						nt_false:
>bccd		05 00				        .byte 5, 0
>bccf		da bc 66 9e 6c 9e		        .word nt_true, xt_false, z_false
>bcd5		66 61 6c 73 65			        .text "false"
.bcda						nt_true:
>bcda		04 00				        .byte 4, 0
>bcdc		e6 bc 71 93 79 93		        .word nt_space, xt_true, z_true
>bce2		74 72 75 65			        .text "true"
.bce6						nt_space:
>bce6		05 00				        .byte 5, 0
>bce8		f3 bc b5 91 ba 91		        .word nt_two_dup, xt_space, z_space
>bcee		73 70 61 63 65			        .text "space"
.bcf3						nt_two_dup:
>bcf3		04 00				        .byte 4, 0
>bcf5		ff bc 9c 93 b3 93		        .word nt_question_dup, xt_two_dup, z_two_dup
>bcfb		32 64 75 70			        .text "2dup"
.bcff						nt_question_dup:
>bcff		04 00				        .byte 4, 0
>bd01		0b bd 8a 8e 9d 8e		        .word nt_plus, xt_question_dup, z_question_dup
>bd07		3f 64 75 70			        .text "?dup"
.bd0b						nt_plus:
>bd0b		01 00				        .byte 1, 0
>bd0d		14 bd 26 8e 38 8e		        .word nt_minus, xt_plus, z_plus
>bd13		2b				        .text "+"
.bd14						nt_minus:
>bd14		01 00				        .byte 1, 0
>bd16		1d bd b8 8b ca 8b		        .word nt_one_minus, xt_minus, z_minus
>bd1c		2d				        .text "-"
.bd1d						nt_one_minus:
>bd1d		02 00				        .byte 2, 0
>bd1f		27 bd b0 8c bb 8c		        .word nt_one_plus, xt_one_minus, z_one_minus
>bd25		31 2d				        .text "1-"
.bd27						nt_one_plus:
>bd27		02 00				        .byte 2, 0
>bd29		31 bd bc 8c c5 8c		        .word nt_two_star, xt_one_plus, z_one_plus
>bd2f		31 2b				        .text "1+"
.bd31						nt_two_star:
>bd31		02 00				        .byte 2, 0
>bd33		3b bd 3f 94 46 94		        .word nt_two_slash, xt_two_star, z_two_star
>bd39		32 2a				        .text "2*"
.bd3b						nt_two_slash:
>bd3b		02 00				        .byte 2, 0
>bd3d		45 bd 34 94 3e 94		        .word nt_abs, xt_two_slash, z_two_slash
>bd43		32 2f				        .text "2/"
.bd45						nt_abs:
>bd45		03 00				        .byte 3, 0
>bd47		50 bd cf 80 e3 80		        .word nt_dabs, xt_abs, z_abs
>bd4d		61 62 73			        .text "abs"
.bd50						nt_dabs:
>bd50		04 00				        .byte 4, 0
>bd52		5c bd b5 9e d3 9e		        .word nt_and, xt_dabs, z_dabs
>bd58		64 61 62 73			        .text "dabs"
.bd5c						nt_and:
>bd5c		03 00				        .byte 3, 0
>bd5e		67 bd 90 82 a1 82		        .word nt_or, xt_and, z_and
>bd64		61 6e 64			        .text "and"
.bd67						nt_or:
>bd67		02 00				        .byte 2, 0
>bd69		71 bd c6 8c d7 8c		        .word nt_xor, xt_or, z_or
>bd6f		6f 72				        .text "or"
.bd71						nt_xor:
>bd71		03 00				        .byte 3, 0
>bd73		7c bd 55 96 66 96		        .word nt_rshift, xt_xor, z_xor
>bd79		78 6f 72			        .text "xor"
.bd7c						nt_rshift:
>bd7c		06 00				        .byte 6, 0
>bd7e		8a bd 75 8f 88 8f		        .word nt_lshift, xt_rshift, z_rshift
>bd84		72 73 68 69 66 74		        .text "rshift"
.bd8a						nt_lshift:
>bd8a		06 00				        .byte 6, 0
>bd8c		98 bd eb 8a fe 8a		        .word nt_pick, xt_lshift, z_lshift
>bd92		6c 73 68 69 66 74		        .text "lshift"
.bd98						nt_pick:
>bd98		04 00				        .byte 4, 0    ; underflow check is complicated, leave off here
>bd9a		a4 bd 15 8e 25 8e		        .word nt_char, xt_pick, z_pick
>bda0		70 69 63 6b			        .text "pick"
.bda4						nt_char:
>bda4		04 00				        .byte 4, 0
>bda6		b0 bd 53 83 69 83		        .word nt_bracket_char, xt_char, z_char
>bdac		63 68 61 72			        .text "char"
.bdb0						nt_bracket_char:
>bdb0		06 03				        .byte 6, CO+IM
>bdb2		be bd 0d 83 13 83		        .word nt_char_plus, xt_bracket_char, z_bracket_char
>bdb8		5b 63 68 61 72 5d		        .text "[char]"
.bdbe						nt_char_plus:
>bdbe		05 00				        .byte 5, 0
>bdc0		cb bd bc 8c c5 8c		        .word nt_chars, xt_char_plus, z_char_plus ; same as 1+
>bdc6		63 68 61 72 2b			        .text "char+"
.bdcb						nt_chars:
>bdcb		05 00				        .byte 5, 0      ; deleted during compile
>bdcd		d8 bd 6a 83 6d 83		        .word nt_cells, xt_chars, z_chars
>bdd3		63 68 61 72 73			        .text "chars"
.bdd8						nt_cells:
>bdd8		05 00				        .byte 5, 0
>bdda		e5 bd 3f 94 46 94		        .word nt_cell_plus, xt_cells, z_cells  ; same as 2*
>bde0		63 65 6c 6c 73			        .text "cells"
.bde5						nt_cell_plus:
>bde5		05 00				        .byte 5, 0
>bde7		f2 bd 43 83 52 83		        .word nt_here, xt_cell_plus, z_cell_plus
>bded		63 65 6c 6c 2b			        .text "cell+"
.bdf2						nt_here:
>bdf2		04 00				        .byte 4, 0
>bdf4		fe bd e7 88 f1 88		        .word nt_equal, xt_here, z_here
>bdfa		68 65 72 65			        .text "here"
.bdfe						nt_equal:
>bdfe		01 00				        .byte 1, 0
>be00		07 be 5a 87 75 87		        .word nt_not_equals, xt_equal, z_equal
>be06		3d				        .text "="
.be07						nt_not_equals:
>be07		02 00				        .byte 2, 0
>be09		11 be 15 8c 32 8c		        .word nt_less_than, xt_not_equals, z_not_equals
>be0f		3c 3e				        .text "<>"
.be11						nt_less_than:
>be11		01 00				        .byte 1, 0
>be13		1a be bb 89 cf 89		        .word nt_u_less_than, xt_less_than, z_less_than
>be19		3c				        .text "<"
.be1a						nt_u_less_than:
>be1a		02 00				        .byte 2, 0
>be1c		24 be 20 95 35 95		        .word nt_u_greater_than, xt_u_less_than, z_u_less_than
>be22		75 3c				        .text "u<"
.be24						nt_u_greater_than:
>be24		02 00				        .byte 2, 0
>be26		2e be 0a 95 1f 95		        .word nt_greater_than, xt_u_greater_than, z_u_greater_than
>be2c		75 3e				        .text "u>"
.be2e						nt_greater_than:
>be2e		01 00				        .byte 1, 0
>be30		37 be d2 88 e6 88		        .word nt_zero_equal, xt_greater_than, z_greater_than
>be36		3e				        .text ">"
.be37						nt_zero_equal:
>be37		02 00				        .byte 2, 0
>be39		41 be 67 96 78 96		        .word nt_zero_unequal, xt_zero_equal, z_zero_equal
>be3f		30 3d				        .text "0="
.be41						nt_zero_unequal:
>be41		03 00				        .byte 3, 0
>be43		4c be 9d 96 ac 96		        .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
>be49		30 3c 3e			        .text "0<>"
.be4c						nt_zero_greater:
>be4c		02 00				        .byte 2, 0
>be4e		56 be 79 96 8c 96		        .word nt_zero_less, xt_zero_greater, z_zero_greater
>be54		30 3e				        .text "0>"
.be56						nt_zero_less:
>be56		02 00				        .byte 2, 0
>be58		60 be 8d 96 9c 96		        .word nt_min, xt_zero_less, z_zero_less
>be5e		30 3c				        .text "0<"
.be60						nt_min:
>be60		03 00				        .byte 3, 0
>be62		6b be 9c 8b b7 8b		        .word nt_max, xt_min, z_min
>be68		6d 69 6e			        .text "min"
.be6b						nt_max:
>be6b		03 00				        .byte 3, 0
>be6d		76 be 80 8b 9b 8b		        .word nt_two_drop, xt_max, z_max
>be73		6d 61 78			        .text "max"
.be76						nt_two_drop:
>be76		05 00				        .byte 5, 0
>be78		83 be 94 93 9b 93		        .word nt_two_swap, xt_two_drop, z_two_drop
>be7e		32 64 72 6f 70			        .text "2drop"
.be83						nt_two_swap:
>be83		05 00				        .byte 5, 0
>be85		90 be 6d 94 90 94		        .word nt_two_over, xt_two_swap, z_two_swap
>be8b		32 73 77 61 70			        .text "2swap"
.be90						nt_two_over:
>be90		05 00				        .byte 5, 0
>be92		9d be d6 93 ed 93		        .word nt_two_store, xt_two_over, z_two_over
>be98		32 6f 76 65 72			        .text "2over"
.be9d						nt_two_store:
>be9d		02 00				        .byte 2, 0
>be9f		a7 be 47 94 6c 94		        .word nt_two_fetch, xt_two_store, z_two_store
>bea5		32 21				        .text "2!"
.bea7						nt_two_fetch:
>bea7		02 00				        .byte 2, 0
>bea9		b1 be b4 93 d5 93		        .word nt_two_variable, xt_two_fetch, z_two_fetch
>beaf		32 40				        .text "2@"
.beb1						nt_two_variable:
>beb1		09 00				        .byte 9, 0
>beb3		c2 be f9 9f 09 a0		        .word nt_two_constant, xt_two_variable, z_two_variable
>beb9		32 76 61 72 69 61 62 6c		        .text "2variable"
>bec1		65
.bec2						nt_two_constant:
>bec2		09 00				        .byte 9, 0
>bec4		d3 be a0 9f b9 9f		        .word nt_two_literal, xt_two_constant, z_two_constant
>beca		32 63 6f 6e 73 74 61 6e		        .text "2constant"
>bed2		74
.bed3						nt_two_literal:
>bed3		08 02				        .byte 8, IM
>bed5		e3 be ba 9f df 9f		        .word nt_two_r_fetch, xt_two_literal, z_two_literal
>bedb		32 6c 69 74 65 72 61 6c		        .text "2literal"
.bee3						nt_two_r_fetch:
>bee3		03 0d				        .byte 3, CO+ST          ; native skips stack juggling
>bee5		ee be ee 93 14 94		        .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
>beeb		32 72 40			        .text "2r@"
.beee						nt_two_r_from:
>beee		03 0d				        .byte 3, CO+ST          ; native skips stack juggling
>bef0		f9 be 17 94 31 94		        .word nt_two_to_r, xt_two_r_from, z_two_r_from
>bef6		32 72 3e			        .text "2r>"
.bef9						nt_two_to_r:
>bef9		03 0d				        .byte 3, CO+ST       ; native skips stack juggling
>befb		04 bf 91 94 ae 94		        .word nt_invert, xt_two_to_r, z_two_to_r
>bf01		32 3e 72			        .text "2>r"
.bf04						nt_invert:
>bf04		06 00				        .byte 6, 0
>bf06		12 bf 30 89 3f 89		        .word nt_negate, xt_invert, z_invert
>bf0c		69 6e 76 65 72 74		        .text "invert"
.bf12						nt_negate:
>bf12		06 00				        .byte 6, 0
>bf14		20 bf f6 8b 06 8c		        .word nt_dnegate, xt_negate, z_negate
>bf1a		6e 65 67 61 74 65		        .text "negate"
.bf20						nt_dnegate:
>bf20		07 00				        .byte 7, 0
>bf22		2f bf d4 9e ee 9e		        .word nt_c_comma, xt_dnegate, z_dnegate
>bf28		64 6e 65 67 61 74 65		        .text "dnegate"
.bf2f						nt_c_comma:
>bf2f		02 00				        .byte 2, 0
>bf31		39 bf 22 83 2c 83		        .word nt_bounds, xt_c_comma, z_c_comma
>bf37		63 2c				        .text "c,"
.bf39						nt_bounds:
>bf39		06 00				        .byte 6, 0
>bf3b		47 bf 98 9a b0 9a		        .word nt_spaces, xt_bounds, z_bounds
>bf41		62 6f 75 6e 64 73		        .text "bounds"
.bf47						nt_spaces:
>bf47		06 00				        .byte 6, 0
>bf49		55 bf bb 91 d4 91		        .word nt_bl, xt_spaces, z_spaces
>bf4f		73 70 61 63 65 73		        .text "spaces"
.bf55						nt_bl:
>bf55		02 00				        .byte 2, 0
>bf57		5f bf 04 83 0c 83		        .word nt_minus_trailing, xt_bl, z_bl
>bf5d		62 6c				        .text "bl"
.bf5f						nt_minus_trailing:
>bf5f		09 00				        .byte 9, 0
>bf61		70 bf 30 a1 6c a1		        .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
>bf67		2d 74 72 61 69 6c 69 6e		        .text "-trailing"
>bf6f		67
.bf70						nt_minus_leading:
>bf70		08 00				        .byte 8, 0
>bf72		80 bf 17 a1 2f a1		        .word nt_slash_string, xt_minus_leading, z_minus_leading
>bf78		2d 6c 65 61 64 69 6e 67		        .text "-leading"
.bf80						nt_slash_string:
>bf80		07 00				        .byte 7, 0
>bf82		8f bf 0c a2 2b a2		        .word nt_refill, xt_slash_string, z_slash_string
>bf88		2f 73 74 72 69 6e 67		        .text "/string"
.bf8f						nt_refill:
>bf8f		06 00				        .byte 6, 0
>bf91		9d bf 07 8f 48 8f		        .word nt_accept, xt_refill, z_refill
>bf97		72 65 66 69 6c 6c		        .text "refill"
.bf9d						nt_accept:
>bf9d		06 08				        .byte 6, NN
>bf9f		ab bf e4 80 dc 81		        .word nt_input_to_r, xt_accept, z_accept
>bfa5		61 63 63 65 70 74		        .text "accept"
.bfab						nt_input_to_r:
>bfab		07 08				        .byte 7, NN
>bfad		ba bf 07 9c 1c 9c		        .word nt_r_to_input, xt_input_to_r, z_input_to_r
>bfb3		69 6e 70 75 74 3e 72		        .text "input>r"
.bfba						nt_r_to_input:
>bfba		07 08				        .byte 7, NN
>bfbc		c9 bf 14 9e 2b 9e		        .word nt_unused, xt_r_to_input, z_r_to_input
>bfc2		72 3e 69 6e 70 75 74		        .text "r>input"
.bfc9						nt_unused:
>bfc9		06 00				        .byte 6, 0
>bfcb		d7 bf d5 95 e4 95		        .word nt_depth, xt_unused, z_unused
>bfd1		75 6e 75 73 65 64		        .text "unused"
.bfd7						nt_depth:
>bfd7		05 00				        .byte 5, 0
>bfd9		e4 bf 0b 85 19 85		        .word nt_key, xt_depth, z_depth
>bfdf		64 65 70 74 68			        .text "depth"
.bfe4						nt_key:
>bfe4		03 00				        .byte 3, 0
>bfe6		ef bf 73 89 7c 89		        .word nt_keyq, xt_key, z_key
>bfec		6b 65 79			        .text "key"
.bfef						nt_keyq:
>bfef		04 00				        .byte 4, 0
>bff1		fb bf 80 89 8e 89		        .word nt_allot, xt_keyq, z_keyq
>bff7		6b 65 79 3f			        .text "key?"
.bffb						nt_allot:
>bffb		05 00				        .byte 5, 0
>bffd		08 c0 27 82 8f 82		        .word nt_create, xt_allot, z_allot
>c003		61 6c 6c 6f 74			        .text "allot"
.c008						nt_create:
>c008		06 00				        .byte 6, 0
>c00a		16 c0 f2 83 d7 84		        .word nt_does, xt_create, z_create
>c010		63 72 65 61 74 65		        .text "create"
.c016						nt_does:
>c016		05 03				        .byte 5, CO+IM
>c018		23 c0 a8 85 b6 85		        .word nt_variable, xt_does, z_does
>c01e		64 6f 65 73 3e			        .text "does>"
.c023						nt_variable:
>c023		08 00				        .byte 8, 0
>c025		33 c0 e5 95 f0 95		        .word nt_constant, xt_variable, z_variable
>c02b		76 61 72 69 61 62 6c 65		        .text "variable"
.c033						nt_constant:
>c033		08 00				        .byte 8, 0
>c035		43 c0 c6 83 d7 83		        .word nt_value, xt_constant, z_constant
>c03b		63 6f 6e 73 74 61 6e 74		        .text "constant"
.c043						nt_value:
>c043		05 00				        .byte 5, 0
>c045		50 c0 c6 83 d7 83		        .word nt_to, xt_value, z_value          ; same code as CONSTANT
>c04b		76 61 6c 75 65			        .text "value"
.c050						nt_to:
>c050		02 0a				        .byte 2, NN+IM
>c052		5a c0 4f 92 8a 92		        .word nt_s_to_d, xt_to, z_to
>c058		74 6f				        .text "to"
.c05a						nt_s_to_d:
>c05a		03 00				        .byte 3, 0
>c05c		65 c0 b6 90 c7 90		        .word nt_d_to_s, xt_s_to_d, z_s_to_d
>c062		73 3e 64			        .text "s>d"
.c065						nt_d_to_s:
>c065		03 00				        .byte 3, 0
>c067		70 c0 af 9e b4 9e		        .word nt_d_minus, xt_d_to_s, z_d_to_s
>c06d		64 3e 73			        .text "d>s"
.c070						nt_d_minus:
>c070		02 00				        .byte 2, 0
>c072		7a c0 6d 9e 8d 9e		        .word nt_d_plus, xt_d_minus, z_d_minus
>c078		64 2d				        .text "d-"
.c07a						nt_d_plus:
>c07a		02 00				        .byte 2, 0
>c07c		84 c0 8e 9e ae 9e		        .word nt_erase, xt_d_plus, z_d_plus
>c082		64 2b				        .text "d+"
.c084						nt_erase:
>c084		05 00				        .byte 5, 0
>c086		91 c0 83 87 d0 87		        .word nt_blank, xt_erase, z_erase
>c08c		65 72 61 73 65			        .text "erase"
.c091						nt_blank:
>c091		05 00				        .byte 5, 0
>c093		9e c0 76 87 d0 87		        .word nt_fill, xt_blank, z_blank
>c099		62 6c 61 6e 6b			        .text "blank"
.c09e						nt_fill:
>c09e		04 00				        .byte 4, 0
>c0a0		aa c0 8e 87 d0 87		        .word nt_find_name, xt_fill, z_fill
>c0a6		66 69 6c 6c			        .text "fill"
.c0aa						nt_find_name:
>c0aa		09 00				        .byte 9, 0
>c0ac		bb c0 5a 9b 9d 9b		        .word nt_tick, xt_find_name, z_find_name
>c0b2		66 69 6e 64 2d 6e 61 6d		        .text "find-name"
>c0ba		65
.c0bb						nt_tick:
>c0bb		01 00				        .byte 1, 0
>c0bd		c4 c0 2f 92 4e 92		        .word nt_bracket_tick, xt_tick, z_tick
>c0c3		27				        .text "'"
.c0c4						nt_bracket_tick:
>c0c4		03 03				        .byte 3, CO+IM
>c0c6		cf c0 14 83 1a 83		        .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
>c0cc		5b 27 5d			        .text "[']"
.c0cf						nt_name_to_int:
>c0cf		08 00				        .byte 8, 0
>c0d1		df c0 a3 9c bf 9c		        .word nt_int_to_name, xt_name_to_int, z_name_to_int
>c0d7		6e 61 6d 65 3e 69 6e 74		        .text "name>int"
.c0df						nt_int_to_name:
>c0df		08 00				        .byte 8, 0
>c0e1		ef c0 1d 9c 8d 9c		        .word nt_name_to_string, xt_int_to_name, z_int_to_name
>c0e7		69 6e 74 3e 6e 61 6d 65		        .text "int>name"
.c0ef						nt_name_to_string:
>c0ef		0b 00				        .byte 11, 0
>c0f1		02 c1 c0 9c d6 9c		        .word nt_to_body, xt_name_to_string, z_name_to_string
>c0f7		6e 61 6d 65 3e 73 74 72		        .text "name>string"
>c0ff		69 6e 67
.c102						nt_to_body:
>c102		05 00				        .byte 5, 0
>c104		0f c1 8b 92 ad 92		        .word nt_defer, xt_to_body, z_to_body
>c10a		3e 62 6f 64 79			        .text ">body"
.c10f						nt_defer:
>c10f		05 00				        .byte 5, 0
>c111		1c c1 df 84 f1 84		        .word nt_latestxt, xt_defer, z_defer
>c117		64 65 66 65 72			        .text "defer"
.c11c						nt_latestxt:
>c11c		08 00				        .byte 8, 0
>c11e		2c c1 9c 9c a2 9c		        .word nt_latestnt, xt_latestxt, z_latestxt
>c124		6c 61 74 65 73 74 78 74		        .text "latestxt"
.c12c						nt_latestnt:
>c12c		08 00				        .byte 8, 0
>c12e		3c c1 8e 9c 9b 9c		        .word nt_parse_name, xt_latestnt, z_latestnt
>c134		6c 61 74 65 73 74 6e 74		        .text "latestnt"
.c13c						nt_parse_name:
>c13c		0a 08				        .byte 10, NN
>c13e		4e c1 24 8d 14 8e		        .word nt_parse, xt_parse_name, z_parse_name
>c144		70 61 72 73 65 2d 6e 61		        .text "parse-name"
>c14c		6d 65
.c14e						nt_parse:
>c14e		05 00				        .byte 5, 0
>c150		5b c1 7f 8d 14 8e		        .word nt_execute_parsing, xt_parse, z_parse
>c156		70 61 72 73 65			        .text "parse"
.c15b						nt_execute_parsing:
>c15b		0f 00				        .byte 15, 0
>c15d		72 c1 33 9b 59 9b		        .word nt_source, xt_execute_parsing, z_execute_parsing
>c163		65 78 65 63 75 74 65 2d		        .text "execute-parsing"
>c16b		70 61 72 73 69 6e 67
.c172						nt_source:
>c172		06 00				        .byte 6, 0
>c174		80 c1 95 91 a9 91		        .word nt_source_id, xt_source, z_source
>c17a		73 6f 75 72 63 65		        .text "source"
.c180						nt_source_id:
>c180		09 00				        .byte 9, 0
>c182		91 c1 aa 91 b4 91		        .word nt_colon, xt_source_id, z_source_id
>c188		73 6f 75 72 63 65 2d 69		        .text "source-id"
>c190		64
.c191						nt_colon:
>c191		01 00				        .byte 1, 0
>c193		9a c1 6e 83 8e 83		        .word nt_semicolon, xt_colon, z_colon
>c199		3a				        .text ":"
.c19a						nt_semicolon:
>c19a		01 03				        .byte 1, CO+IM
>c19c		a3 c1 c8 90 34 91		        .word nt_colon_noname, xt_semicolon, z_semicolon
>c1a2		3b				        .text ";"
.c1a3						nt_colon_noname:
>c1a3		07 00				        .byte 7, 0
>c1a5		b2 c1 8f 83 aa 83		        .word nt_compile_comma, xt_colon_noname, z_colon_noname
>c1ab		3a 6e 6f 6e 61 6d 65		        .text ":noname"
.c1b2						nt_compile_comma:
>c1b2		08 08				        .byte 8, NN
>c1b4		c2 c1 bb 96 6e 97		        .word nt_left_bracket, xt_compile_comma, z_compile_comma
>c1ba		63 6f 6d 70 69 6c 65 2c		        .text "compile,"
.c1c2						nt_left_bracket:
>c1c2		01 03				        .byte 1, IM+CO
>c1c4		cb c1 a8 89 ac 89		        .word nt_right_bracket, xt_left_bracket, z_left_bracket
>c1ca		5b				        .text "["
.c1cb						nt_right_bracket:
>c1cb		01 02				        .byte 1, IM
>c1cd		d4 c1 52 8f 58 8f		        .word nt_literal, xt_right_bracket, z_right_bracket
>c1d3		5d				        .text "]"
.c1d4						nt_literal:
>c1d4		07 03				        .byte 7, IM+CO
>c1d6		e3 c1 d0 89 0d 8a		        .word nt_sliteral, xt_literal, z_literal
>c1dc		6c 69 74 65 72 61 6c		        .text "literal"
.c1e3						nt_sliteral:
>c1e3		08 03				        .byte 8, CO+IM
>c1e5		f3 c1 2c a2 4c a2		        .word nt_dot_quote, xt_sliteral, z_sliteral
>c1eb		73 6c 69 74 65 72 61 6c		        .text "sliteral"
.c1f3						nt_dot_quote:
>c1f3		02 03				        .byte 2, CO+IM
>c1f5		fd c1 1a 86 24 86		        .word nt_s_quote, xt_dot_quote, z_dot_quote
>c1fb		2e 22				        .text ".", $22
.c1fd						nt_s_quote:
>c1fd		02 0a				        .byte 2, IM+NN
>c1ff		07 c2 a2 8f 9b 90		        .word nt_s_backslash_quote, xt_s_quote, z_s_quote
>c205		73 22				        .text "s", $22
.c207						nt_s_backslash_quote:
>c207		03 02				        .byte 3, IM
>c209		12 c2 89 8f 92 8f		        .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
>c20f		73 5c 22			        .text "s", $5C, $22
.c212						nt_postpone:
>c212		08 03				        .byte 8, IM+CO
>c214		22 c2 54 8e 89 8e		        .word nt_immediate, xt_postpone, z_postpone
>c21a		70 6f 73 74 70 6f 6e 65		        .text "postpone"
.c222						nt_immediate:
>c222		09 00				        .byte 9, 0
>c224		33 c2 24 89 2f 89		        .word nt_compile_only, xt_immediate, z_immediate
>c22a		69 6d 6d 65 64 69 61 74		        .text "immediate"
>c232		65
.c233						nt_compile_only:
>c233		0c 00				        .byte 12, 0
>c235		47 c2 ba 83 c5 83		        .word nt_never_native, xt_compile_only, z_compile_only
>c23b		63 6f 6d 70 69 6c 65 2d		        .text "compile-only"
>c243		6f 6e 6c 79
.c247						nt_never_native:
>c247		0c 00				        .byte 12, 0
>c249		5b c2 dc 9c e9 9c		        .word nt_always_native, xt_never_native, z_never_native
>c24f		6e 65 76 65 72 2d 6e 61		        .text "never-native"
>c257		74 69 76 65
.c25b						nt_always_native:
>c25b		0d 00				        .byte 13, 0
>c25d		70 c2 84 9a 91 9a		        .word nt_allow_native, xt_always_native, z_always_native
>c263		61 6c 77 61 79 73 2d 6e		        .text "always-native"
>c26b		61 74 69 76 65
.c270						nt_allow_native:
>c270		0c 00				        .byte 12, 0
>c272		84 c2 78 9a 83 9a		        .word nt_nc_limit, xt_allow_native, z_allow_native
>c278		61 6c 6c 6f 77 2d 6e 61		        .text "allow-native"
>c280		74 69 76 65
.c284						nt_nc_limit:
>c284		08 08				        .byte 8, NN
>c286		94 c2 d7 9c dc 9c		        .word nt_strip_underflow, xt_nc_limit, z_nc_limit
>c28c		6e 63 2d 6c 69 6d 69 74		        .text "nc-limit"
.c294						nt_strip_underflow:
>c294		0f 08				        .byte 15, NN
>c296		ab c2 2c 9e 31 9e		        .word nt_abort, xt_strip_underflow, z_strip_underflow
>c29c		73 74 72 69 70 2d 75 6e		        .text "strip-underflow"
>c2a4		64 65 72 66 6c 6f 77
.c2ab						nt_abort:
>c2ab		05 00				        .byte 5, 0
>c2ad		b8 c2 5e 80 af 80		        .word nt_abort_quote, xt_abort, z_abort
>c2b3		61 62 6f 72 74			        .text "abort"
.c2b8						nt_abort_quote:
>c2b8		06 0b				        .byte 6, CO+IM+NN
>c2ba		c6 c2 af 80 b9 80		        .word nt_do, xt_abort_quote, z_abort_quote
>c2c0		61 62 6f 72 74 22		        .text "abort", $22
.c2c6						nt_do:
>c2c6		02 0b				        .byte 2, CO+IM+NN
>c2c8		d0 c2 44 85 5d 85		        .word nt_question_do, xt_do, z_do
>c2ce		64 6f				        .text "do"
.c2d0						nt_question_do:
>c2d0		03 0b				        .byte 3, CO+IM+NN
>c2d2		db c2 1a 85 5d 85		        .word nt_i, xt_question_do, z_question_do
>c2d8		3f 64 6f			        .text "?do"
.c2db						nt_i:
>c2db		01 01				        .byte 1, CO
>c2dd		e4 c2 0b 89 1f 89		        .word nt_j, xt_i, z_i
>c2e3		69				        .text "i"
.c2e4						nt_j:
>c2e4		01 01				        .byte 1, CO
>c2e6		ed c2 59 89 72 89		        .word nt_loop, xt_j, z_j
>c2ec		6a				        .text "j"
.c2ed						nt_loop:
>c2ed		04 03				        .byte 4, CO+IM
>c2ef		f9 c2 37 8a af 8a		        .word nt_plus_loop, xt_loop, z_loop
>c2f5		6c 6f 6f 70			        .text "loop"
.c2f9						nt_plus_loop:
>c2f9		05 03				        .byte 5, CO+IM
>c2fb		06 c3 4b 8a af 8a		        .word nt_exit, xt_plus_loop, z_plus_loop
>c301		2b 6c 6f 6f 70			        .text "+loop"
.c306						nt_exit:
>c306		04 05				        .byte 4, AN+CO
>c308		12 c3 e5 87 e6 87		        .word nt_unloop, xt_exit, z_exit
>c30e		65 78 69 74			        .text "exit"
.c312						nt_unloop:
>c312		06 01				        .byte 6, CO
>c314		20 c3 be 95 cd 95		        .word nt_leave, xt_unloop, z_unloop
>c31a		75 6e 6c 6f 6f 70		        .text "unloop"
.c320						nt_leave:
>c320		05 03				        .byte 5, CO+IM
>c322		2d c3 92 89 a7 89		        .word nt_recurse, xt_leave, z_leave
>c328		6c 65 61 76 65			        .text "leave"
.c32d						nt_recurse:
>c32d		07 0b				        .byte 7, CO+IM+NN
>c32f		3c c3 ca 8e 06 8f		        .word nt_quit, xt_recurse, z_recurse
>c335		72 65 63 75 72 73 65		        .text "recurse"
.c33c						nt_quit:
>c33c		04 00				        .byte 4, 0
>c33e		48 c3 60 80 af 80		        .word nt_begin, xt_quit, z_quit
>c344		71 75 69 74			        .text "quit"
.c348						nt_begin:
>c348		05 03				        .byte 5, CO+IM
>c34a		55 c3 e7 88 f1 88		        .word nt_again, xt_begin, z_begin
>c350		62 65 67 69 6e			        .text "begin"
.c355						nt_again:
>c355		05 03				        .byte 5, CO+IM
>c357		62 c3 1f 82 25 82		        .word nt_state, xt_again, z_again
>c35d		61 67 61 69 6e			        .text "again"
.c362						nt_state:
>c362		05 00				        .byte 5, 0
>c364		6f c3 fa 91 04 92		        .word nt_evaluate, xt_state, z_state
>c36a		73 74 61 74 65			        .text "state"
.c36f						nt_evaluate:
>c36f		08 00				        .byte 8, 0
>c371		7f c3 7e 88 d1 88		        .word nt_base, xt_evaluate, z_evaluate
>c377		65 76 61 6c 75 61 74 65		        .text "evaluate"
.c37f						nt_base:
>c37f		04 00				        .byte 4, 0
>c381		8b c3 fb 82 03 83		        .word nt_digit_question, xt_base, z_base
>c387		62 61 73 65			        .text "base"
.c38b						nt_digit_question:
>c38b		06 00				        .byte 6, 0
>c38d		99 c3 fe 9a 32 9b		        .word nt_number, xt_digit_question, z_digit_question
>c393		64 69 67 69 74 3f		        .text "digit?"
.c399						nt_number:
>c399		06 00				        .byte 6, 0
>c39b		a7 c3 06 9d ff 9d		        .word nt_to_number, xt_number, z_number
>c3a1		6e 75 6d 62 65 72		        .text "number"
.c3a7						nt_to_number:
>c3a7		07 00				        .byte 7, 0
>c3a9		b6 c3 b9 92 58 93		        .word nt_hex, xt_to_number, z_to_number
>c3af		3e 6e 75 6d 62 65 72		        .text ">number"
.c3b6						nt_hex:
>c3b6		03 00				        .byte 3, 0
>c3b8		c1 c3 f2 88 f8 88		        .word nt_decimal, xt_hex, z_hex
>c3be		68 65 78			        .text "hex"
.c3c1						nt_decimal:
>c3c1		07 00				        .byte 7, 0
>c3c3		d0 c3 d8 84 de 84		        .word nt_count, xt_decimal, z_decimal
>c3c9		64 65 63 69 6d 61 6c		        .text "decimal"
.c3d0						nt_count:
>c3d0		05 00				        .byte 5, 0
>c3d2		dd c3 d8 83 eb 83		        .word nt_m_star, xt_count, z_count
>c3d8		63 6f 75 6e 74			        .text "count"
.c3dd						nt_m_star:
>c3dd		02 00				        .byte 2, 0
>c3df		e7 c3 ff 8a 19 8b		        .word nt_um_star, xt_m_star, z_m_star
>c3e5		6d 2a				        .text "m*"
.c3e7						nt_um_star:
>c3e7		03 00				        .byte 3, 0
>c3e9		f2 c3 78 95 bd 95		        .word nt_star, xt_um_star, z_um_star
>c3ef		75 6d 2a			        .text "um*"
.c3f2						nt_star:
>c3f2		01 00				        .byte 1, 0
>c3f4		fb c3 d5 91 dd 91		        .word nt_um_slash_mod, xt_star, z_star
>c3fa		2a				        .text "*"
.c3fb						nt_um_slash_mod:
>c3fb		06 00				        .byte 6, 0
>c3fd		09 c4 36 95 77 95		        .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
>c403		75 6d 2f 6d 6f 64		        .text "um/mod"
.c409						nt_sm_slash_rem:
>c409		06 00				        .byte 6, 0
>c40b		17 c4 6c 91 94 91		        .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
>c411		73 6d 2f 72 65 6d		        .text "sm/rem"
.c417						nt_fm_slash_mod:
>c417		06 00				        .byte 6, 0
>c419		25 c4 41 88 77 88		        .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
>c41f		66 6d 2f 6d 6f 64		        .text "fm/mod"
.c425						nt_slash:
>c425		01 00				        .byte 1, 0
>c427		2e c4 4a 91 6b 91		        .word nt_slash_mod, xt_slash, z_slash
>c42d		2f				        .text "/"
.c42e						nt_slash_mod:
>c42e		04 00				        .byte 4, 0
>c430		3a c4 51 91 6b 91		        .word nt_mod, xt_slash_mod, z_slash_mod
>c436		2f 6d 6f 64			        .text "/mod"
.c43a						nt_mod:
>c43a		03 00				        .byte 3, 0
>c43c		45 c4 cb 8b d3 8b		        .word nt_star_slash_mod, xt_mod, z_mod
>c442		6d 6f 64			        .text "mod"
.c445						nt_star_slash_mod:
>c445		05 00				        .byte 5, 0
>c447		52 c4 ea 91 f9 91		        .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
>c44d		2a 2f 6d 6f 64			        .text "*/mod"
.c452						nt_star_slash:
>c452		02 00				        .byte 2, 0
>c454		5c c4 de 91 e9 91		        .word nt_backslash, xt_star_slash, z_star_slash
>c45a		2a 2f				        .text "*/"
.c45c						nt_backslash:
>c45c		01 02				        .byte 1, IM
>c45e		65 c4 d0 82 fa 82		        .word nt_move, xt_backslash, z_backslash
>c464		5c				        .byte '\'
.c465						nt_move:
>c465		04 08				        .byte 4, NN
>c467		71 c4 d4 8b f5 8b		        .word nt_cmove_up, xt_move, z_move
>c46d		6d 6f 76 65			        .text "move"
.c471						nt_cmove_up:
>c471		06 00				        .byte 6, 0
>c473		7f c4 77 a0 b1 a0		        .word nt_cmove, xt_cmove_up, z_cmove_up
>c479		63 6d 6f 76 65 3e		        .text "cmove>"
.c47f						nt_cmove:
>c47f		05 00				        .byte 5, 0
>c481		8c c4 3c a0 76 a0		        .word nt_pad, xt_cmove, z_cmove
>c487		63 6d 6f 76 65			        .text "cmove"
.c48c						nt_pad:
>c48c		03 00				        .byte 3, 0
>c48e		97 c4 e6 8c f5 8c		        .word nt_cleave, xt_pad, z_pad
>c494		70 61 64			        .text "pad"
.c497						nt_cleave:
>c497		06 00				        .byte 6, 0
>c499		a5 c4 b1 9a fd 9a		        .word nt_hexstore, xt_cleave, z_cleave
>c49f		63 6c 65 61 76 65		        .text "cleave"
.c4a5						nt_hexstore:
>c4a5		08 00				        .byte 8, 0
>c4a7		b5 c4 a9 9b fb 9b		        .word nt_within, xt_hexstore, z_hexstore
>c4ad		68 65 78 73 74 6f 72 65		        .text "hexstore"
.c4b5						nt_within:
>c4b5		06 00				        .byte 6, 0
>c4b7		c3 c4 fb 95 10 96		        .word nt_to_in, xt_within, z_within
>c4bd		77 69 74 68 69 6e		        .text "within"
.c4c3						nt_to_in:
>c4c3		03 00				        .byte 3, 0
>c4c5		ce c4 ae 92 b8 92		        .word nt_less_number_sign, xt_to_in, z_to_in
>c4cb		3e 69 6e			        .text ">in"
.c4ce						nt_less_number_sign:
>c4ce		02 00				        .byte 2, 0
>c4d0		d8 c4 ad 89 ba 89		        .word nt_number_sign, xt_less_number_sign, z_less_number_sign
>c4d6		3c 23				        .text "<#"
.c4d8						nt_number_sign:
>c4d8		01 00				        .byte 1, 0
>c4da		e1 c4 33 8c 63 8c		        .word nt_number_sign_s, xt_number_sign, z_number_sign
>c4e0		23				        .text "#"
.c4e1						nt_number_sign_s:
>c4e1		02 00				        .byte 2, 0
>c4e3		eb c4 86 8c 96 8c		        .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
>c4e9		23 73				        .text "#s"
.c4eb						nt_number_sign_greater:
>c4eb		02 00				        .byte 2, 0
>c4ed		f5 c4 64 8c 85 8c		        .word nt_hold, xt_number_sign_greater, z_number_sign_greater
>c4f3		23 3e				        .text "#>"
.c4f5						nt_hold:
>c4f5		04 00				        .byte 4, 0
>c4f7		01 c5 f9 88 0a 89		        .word nt_sign, xt_hold, z_hold
>c4fd		68 6f 6c 64			        .text "hold"
.c501						nt_sign:
>c501		04 00				        .byte 4, 0
>c503		0d c5 35 91 49 91		        .word nt_output, xt_sign, z_sign
>c509		73 69 67 6e			        .text "sign"
.c50d						nt_output:
>c50d		06 00				        .byte 6, 0
>c50f		1b c5 09 9e 13 9e		        .word nt_input, xt_output, z_output
>c515		6f 75 74 70 75 74		        .text "output"
.c51b						nt_input:
>c51b		05 00				        .byte 5, 0
>c51d		28 c5 fc 9b 06 9c		        .word nt_havekey, xt_input, z_input
>c523		69 6e 70 75 74			        .text "input"
.c528						nt_havekey:
>c528		07 00				        .byte 7, 0
>c52a		37 c5 9e 9b a8 9b		        .word nt_cr, xt_havekey, z_havekey
>c530		68 61 76 65 6b 65 79		        .text "havekey"
.c537						nt_cr:
>c537		02 00				        .byte 2, 0
>c539		41 c5 ec 83 f1 83		        .word nt_page, xt_cr, z_cr
>c53f		63 72				        .text "cr"
.c541						nt_page:
>c541		04 00				        .byte 4, 0
>c543		4d c5 f6 8c 13 8d		        .word nt_at_xy, xt_page, z_page
>c549		70 61 67 65			        .text "page"
.c54d						nt_at_xy:
>c54d		05 00				        .byte 5, 0
>c54f		5a c5 a2 82 cf 82		        .word nt_marker, xt_at_xy, z_at_xy
>c555		61 74 2d 78 79			        .text "at-xy"
.c55a						nt_marker:
>c55a		06 02				        .byte 6, IM
>c55c		68 c5 1a 8b 4a 8b		        .word nt_words, xt_marker, z_marker
>c562		6d 61 72 6b 65 72		        .text "marker"
.c568						nt_words:
>c568		05 00				        .byte 5, 0
>c56a		75 c5 1b 9a 77 9a		        .word nt_wordsize, xt_words, z_words
>c570		77 6f 72 64 73			        .text "words"
.c575						nt_wordsize:
>c575		08 00				        .byte 8, 0
>c577		85 c5 45 9e 65 9e		        .word nt_aligned, xt_wordsize, z_wordsize
>c57d		77 6f 72 64 73 69 7a 65		        .text "wordsize"
.c585						nt_aligned:
>c585		07 00				        .byte 7, 0
>c587		94 c5 26 82 26 82		        .word nt_align, xt_aligned, z_aligned   ; same code as ALIGN
>c58d		61 6c 69 67 6e 65 64		        .text "aligned"
.c594						nt_align:
>c594		05 00				        .byte 5, 0
>c596		a1 c5 26 82 26 82		        .word nt_bell, xt_align, z_align
>c59c		61 6c 69 67 6e			        .text "align"
.c5a1						nt_bell:
>c5a1		04 00				        .byte 4, 0
>c5a3		ad c5 92 9a 97 9a		        .word nt_dump, xt_bell, z_bell
>c5a9		62 65 6c 6c			        .text "bell"
.c5ad						nt_dump:
>c5ad		04 00				        .byte 4, 0
>c5af		b9 c5 c1 98 3e 99		        .word nt_dot_s, xt_dump, z_dump
>c5b5		64 75 6d 70			        .text "dump"
.c5b9						nt_dot_s:
>c5b9		02 00				        .byte 2, 0
>c5bb		c3 c5 7d 98 c0 98		        .word +, xt_dot_s, z_dot_s
>c5c1		2e 73				        .text ".s"
.c5c3						+
.c5c3						nt_disasm:
>c5c3		06 00				        .byte 6, 0
>c5c5		d1 c5 7a a2 80 a2		        .word +, xt_disasm, z_disasm
>c5cb		64 69 73 61 73 6d		        .text "disasm"
.c5d1						+
.c5d1						nt_compare:
>c5d1		07 00				        .byte 7, 0
>c5d3		e0 c5 b2 a0 16 a1		        .word nt_search, xt_compare, z_compare
>c5d9		63 6f 6d 70 61 72 65		        .text "compare"
.c5e0						nt_search:
>c5e0		06 08				        .byte 6, NN
>c5e2		ee c5 6d a1 0b a2		        .word +, xt_search, z_search
>c5e8		73 65 61 72 63 68		        .text "search"
.c5ee						+
.c5ee						nt_environment_q:
>c5ee		0c 00				        .byte 12, 0
>c5f0		02 c6 a1 86 1d 87		        .word +, xt_environment_q, z_environment_q
>c5f6		65 6e 76 69 72 6f 6e 6d		        .text "environment?"
>c5fe		65 6e 74 3f
.c602						+
.c602						nt_find:
>c602		04 00				        .byte 4, 0
>c604		0e c6 f9 87 40 88		        .word nt_word, xt_find, z_find
>c60a		66 69 6e 64			        .text "find"
.c60e						nt_word:
>c60e		04 00				        .byte 4, 0
>c610		1a c6 11 96 54 96		        .word nt_paren, xt_word, z_word
>c616		77 6f 72 64			        .text "word"
.c61a						nt_paren:
>c61a		01 02				        .byte 1, IM
>c61c		23 c6 14 8d 23 8d		        .word nt_dot_paren, xt_paren, z_paren
>c622		28				        .text "("
.c623						nt_dot_paren:
>c623		02 02				        .byte 2, IM
>c625		2d c6 0b 86 19 86		        .word nt_if, xt_dot_paren, z_dot_paren
>c62b		2e 28				        .text ".("
.c62d						nt_if:
>c62d		02 0b				        .byte 2, IM+CO+NN
>c62f		37 c6 20 89 23 89		        .word nt_then, xt_if, z_if
>c635		69 66				        .text "if"
.c637						nt_then:
>c637		04 0b				        .byte 4, IM+CO+NN
>c639		43 c6 72 86 7e 86		        .word nt_else, xt_then, z_then
>c63f		74 68 65 6e			        .text "then"
.c643						nt_else:
>c643		04 0b				        .byte 4, IM+CO+NN
>c645		4f c6 67 86 7e 86		        .word nt_repeat, xt_else, z_else
>c64b		65 6c 73 65			        .text "else"
.c64f						nt_repeat:
>c64f		06 0b				        .byte 6, IM+CO+NN
>c651		5d c6 49 8f 52 8f		        .word nt_until, xt_repeat, z_repeat
>c657		72 65 70 65 61 74		        .text "repeat"
.c65d						nt_until:
>c65d		05 0b				        .byte 5, IM+CO+NN
>c65f		6a c6 ce 95 d4 95		        .word nt_while, xt_until, z_until
>c665		75 6e 74 69 6c			        .text "until"
.c66a						nt_while:
>c66a		05 0b				        .byte 5, IM+CO+NN
>c66c		77 c6 f1 95 fa 95		        .word nt_case, xt_while, z_while
>c672		77 68 69 6c 65			        .text "while"
.c677						nt_case:
>c677		04 0b				        .byte 4, IM+CO+NN
>c679		83 c6 66 9e 6c 9e		        .word nt_of, xt_case, z_case    ; shares code with ZERO
>c67f		63 61 73 65			        .text "case"
.c683						nt_of:
>c683		02 0b				        .byte 2, IM+CO+NN
>c685		8d c6 97 8c af 8c		        .word nt_endof, xt_of, z_of
>c68b		6f 66				        .text "of"
.c68d						nt_endof:
>c68d		05 0b				        .byte 5, IM+CO+NN
>c68f		9a c6 67 86 7e 86		        .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
>c695		65 6e 64 6f 66			        .text "endof"
.c69a						nt_endcase:
>c69a		07 0b				        .byte 7, IM+CO+NN
>c69c		a9 c6 89 86 a0 86		        .word nt_defer_fetch, xt_endcase, z_endcase
>c6a2		65 6e 64 63 61 73 65		        .text "endcase"
.c6a9						nt_defer_fetch:
>c6a9		06 00				        .byte 6, 0
>c6ab		b7 c6 f7 84 00 85		        .word nt_defer_store, xt_defer_fetch, z_defer_fetch
>c6b1		64 65 66 65 72 40		        .text "defer@"
.c6b7						nt_defer_store:
>c6b7		06 00				        .byte 6, 0
>c6b9		c5 c6 01 85 0a 85		        .word nt_is, xt_defer_store, z_defer_store
>c6bf		64 65 66 65 72 21		        .text "defer!"
.c6c5						nt_is:
>c6c5		02 02				        .byte 2, IM
>c6c7		cf c6 40 89 58 89		        .word nt_action_of, xt_is, z_is
>c6cd		69 73				        .text "is"
.c6cf						nt_action_of:
>c6cf		09 02				        .byte 9, IM
>c6d1		e0 c6 06 82 1e 82		        .word nt_useraddr, xt_action_of, z_action_of
>c6d7		61 63 74 69 6f 6e 2d 6f		        .text "action-of"
>c6df		66
.c6e0						nt_useraddr:
>c6e0		08 00				        .byte 8, 0
>c6e2		f0 c6 3a 9e 44 9e		        .word nt_buffer_colon, xt_useraddr, z_useraddr
>c6e8		75 73 65 72 61 64 64 72		        .text "useraddr"
.c6f0						nt_buffer_colon:
>c6f0		07 00				        .byte 7, 0
>c6f2		ff c6 1b 83 21 83		        .word +, xt_buffer_colon, z_buffer_colon
>c6f8		62 75 66 66 65 72 3a		        .text "buffer:"
.c6ff						+
.c6ff						nt_buffstatus:
>c6ff		0a 00				        .byte 10, 0
>c701		11 c7 04 b0 09 b0		        .word nt_buffblocknum, xt_buffstatus, z_buffstatus
>c707		62 75 66 66 73 74 61 74		        .text "buffstatus"
>c70f		75 73
.c711						nt_buffblocknum:
>c711		0c 00				        .byte 12, 0
>c713		25 c7 ce af d3 af		        .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
>c719		62 75 66 66 62 6c 6f 63		        .text "buffblocknum"
>c721		6b 6e 75 6d
.c725						nt_blkbuffer:
>c725		09 00				        .byte 9, 0
>c727		36 c7 1e ae 2b ae		        .word nt_scr, xt_blkbuffer, z_blkbuffer
>c72d		62 6c 6b 62 75 66 66 65		        .text "blkbuffer"
>c735		72
.c736						nt_scr:
>c736		03 08				        .byte 3, NN
>c738		41 c7 86 b0 8b b0		        .word nt_blk, xt_scr, z_scr
>c73e		73 63 72			        .text "scr"
.c741						nt_blk:
>c741		03 08				        .byte 3, NN
>c743		4c c7 19 ae 1e ae		        .word nt_block_write, xt_blk, z_blk
>c749		62 6c 6b			        .text "blk"
.c74c						nt_block_write:
>c74c		0b 08				        .byte 11, NN
>c74e		5f c7 bb af c9 af		        .word nt_block_write_vector, xt_block_write, z_block_write
>c754		62 6c 6f 63 6b 2d 77 72		        .text "block-write"
>c75c		69 74 65
.c75f						nt_block_write_vector:
>c75f		12 08				        .byte 18, NN
>c761		79 c7 c9 af ce af		        .word nt_block_read, xt_block_write_vector, z_block_write_vector
>c767		62 6c 6f 63 6b 2d 77 72		        .text "block-write-vector"
>c76f		69 74 65 2d 76 65 63 74 6f 72
.c779						nt_block_read:
>c779		0a 08				        .byte 10, NN
>c77b		8b c7 a3 af b1 af		        .word nt_block_read_vector, xt_block_read, z_block_read
>c781		62 6c 6f 63 6b 2d 72 65		        .text "block-read"
>c789		61 64
.c78b						nt_block_read_vector:
>c78b		11 08				        .byte 17, NN
>c78d		a4 c7 b1 af b6 af		        .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
>c793		62 6c 6f 63 6b 2d 72 65		        .text "block-read-vector"
>c79b		61 64 2d 76 65 63 74 6f 72
.c7a4						nt_save_buffers:
>c7a4		0c 00				        .byte 12, 0
>c7a6		b8 c7 6b b0 85 b0		        .word nt_block, xt_save_buffers, z_save_buffers
>c7ac		73 61 76 65 2d 62 75 66		        .text "save-buffers"
>c7b4		66 65 72 73
.c7b8						nt_block:
>c7b8		05 00				        .byte 5, 0
>c7ba		c5 c7 2c ae 7e ae		        .word nt_update, xt_block, z_block
>c7c0		62 6c 6f 63 6b			        .text "block"
.c7c5						nt_update:
>c7c5		06 00				        .byte 6, 0
>c7c7		d3 c7 d0 b0 d8 b0		        .word nt_buffer, xt_update, z_update
>c7cd		75 70 64 61 74 65		        .text "update"
.c7d3						nt_buffer:
>c7d3		06 00				        .byte 6, 0
>c7d5		e1 c7 d3 af 03 b0		        .word nt_empty_buffers, xt_buffer, z_buffer
>c7db		62 75 66 66 65 72		        .text "buffer"
.c7e1						nt_empty_buffers:
>c7e1		0d 00				        .byte 13, 0
>c7e3		f6 c7 09 b0 0f b0		        .word nt_flush, xt_empty_buffers, z_empty_buffers
>c7e9		65 6d 70 74 79 2d 62 75		        .text "empty-buffers"
>c7f1		66 66 65 72 73
.c7f6						nt_flush:
>c7f6		05 00				        .byte 5, 0
>c7f8		03 c8 10 b0 19 b0		        .word nt_load, xt_flush, z_flush
>c7fe		66 6c 75 73 68			        .text "flush"
.c803						nt_load:
>c803		04 00				        .byte 4, 0
>c805		0f c8 27 b0 6a b0		        .word nt_thru, xt_load, z_load
>c80b		6c 6f 61 64			        .text "load"
.c80f						nt_thru:
>c80f		04 00				        .byte 4, 0
>c811		1b c8 8b b0 cf b0		        .word +, xt_thru, z_thru
>c817		74 68 72 75			        .text "thru"
.c81b						+
.c81b						nt_list:
>c81b		04 00				        .byte 4, 0
>c81d		27 c8 1a b0 26 b0		        .word +, xt_list, z_list
>c823		6c 69 73 74			        .text "list"
.c827						+
.c827						nt_block_ramdrive_init:
>c827		13 00				        .byte 19, 0
>c829		42 c8 7f ae a2 af		        .word +, xt_block_ramdrive_init, z_block_ramdrive_init
>c82f		62 6c 6f 63 6b 2d 72 61		        .text "block-ramdrive-init"
>c837		6d 64 72 69 76 65 2d 69 6e 69 74
.c842						+
.c842						nt_definitions:
>c842		0b 00				        .byte 11, 0
>c844		55 c8 0a b2 12 b2		        .word nt_wordlist, xt_definitions, z_definitions
>c84a		64 65 66 69 6e 69 74 69		        .text "definitions"
>c852		6f 6e 73
.c855						nt_wordlist:
>c855		08 00				        .byte 8, 0
>c857		65 c8 75 b3 8b b3		        .word nt_search_wordlist, xt_wordlist, z_wordlist
>c85d		77 6f 72 64 6c 69 73 74		        .text "wordlist"
.c865						nt_search_wordlist:
>c865		0f 00				        .byte 15, 0
>c867		7c c8 ae b2 21 b3		        .word nt_set_current, xt_search_wordlist, z_search_wordlist
>c86d		73 65 61 72 63 68 2d 77		        .text "search-wordlist"
>c875		6f 72 64 6c 69 73 74
.c87c						nt_set_current:
>c87c		0b 00				        .byte 11, 0
>c87e		8f c8 22 b3 2d b3		        .word nt_get_current, xt_set_current, z_set_current
>c884		73 65 74 2d 63 75 72 72		        .text "set-current"
>c88c		65 6e 74
.c88f						nt_get_current:
>c88f		0b 00				        .byte 11, 0
>c891		a2 c8 1a b2 24 b2		        .word nt_set_order, xt_get_current, z_get_current
>c897		67 65 74 2d 63 75 72 72		        .text "get-current"
>c89f		65 6e 74
.c8a2						nt_set_order:
>c8a2		09 00				        .byte 9, 0
>c8a4		b3 c8 2e b3 61 b3		        .word nt_get_order, xt_set_order, z_set_order
>c8aa		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c8b2		72
.c8b3						nt_get_order:
>c8b3		09 00				        .byte 9, 0
>c8b5		c4 c8 25 b2 4d b2		        .word nt_root_wordlist, xt_get_order, z_get_order
>c8bb		67 65 74 2d 6f 72 64 65		        .text "get-order"
>c8c3		72
.c8c4						nt_root_wordlist:
>c8c4		0d 00				        .byte 13, 0
>c8c6		d9 c8 a5 b2 ad b2		        .word +, xt_root_wordlist, z_root_wordlist
>c8cc		72 6f 6f 74 2d 77 6f 72		        .text "root-wordlist"
>c8d4		64 6c 69 73 74
.c8d9						+
.c8d9						nt_assembler_wordlist:
>c8d9		12 00				        .byte 18, 0
>c8db		f3 c8 31 9e 39 9e		        .word +, xt_assembler_wordlist, z_assembler_wordlist
>c8e1		61 73 73 65 6d 62 6c 65		        .text "assembler-wordlist"
>c8e9		72 2d 77 6f 72 64 6c 69 73 74
.c8f3						+
.c8f3						nt_editor_wordlist:
>c8f3		0f 00				        .byte 15, 0
>c8f5		0a c9 00 9e 08 9e		        .word +, xt_editor_wordlist, z_editor_wordlist
>c8fb		65 64 69 74 6f 72 2d 77		        .text "editor-wordlist"
>c903		6f 72 64 6c 69 73 74
.c90a						+
.c90a						nt_forth_wordlist:
>c90a		0e 00				        .byte 14, 0
>c90c		20 c9 66 9e 6c 9e		        .word nt_only, xt_forth_wordlist, z_forth_wordlist
>c912		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c91a		72 64 6c 69 73 74
.c920						nt_only:
>c920		04 00				        .byte 4, 0
>c922		2c c9 4e b2 54 b2		        .word nt_also, xt_only, z_only
>c928		6f 6e 6c 79			        .text "only"
.c92c						nt_also:
>c92c		04 00				        .byte 4, 0
>c92e		38 c9 fa b1 09 b2		        .word nt_previous, xt_also, z_also
>c934		61 6c 73 6f			        .text "also"
.c938						nt_previous:
>c938		08 00				        .byte 8, 0
>c93a		48 c9 98 b2 a4 b2		        .word nt_to_order, xt_previous, z_previous
>c940		70 72 65 76 69 6f 75 73		        .text "previous"
.c948						nt_to_order:
>c948		06 00				        .byte 6, 0
>c94a		56 c9 62 b3 74 b3		        .word nt_order, xt_to_order, z_to_order
>c950		3e 6f 72 64 65 72		        .text ">order"
.c956						nt_order:
>c956		05 00				        .byte 5, 0
>c958		63 c9 55 b2 7f b2		        .word nt_forth, xt_order, z_order
>c95e		6f 72 64 65 72			        .text "order"
.c963						nt_forth:
>c963		05 00				        .byte 5, 0
>c965		70 c9 13 b2 19 b2		        .word +, xt_forth, z_forth
>c96b		66 6f 72 74 68			        .text "forth"
.c970						+
>c970		03 08				nt_see: .byte 3, NN
>c972		7b c9 46 99 1a 9a		        .word +, xt_see, z_see
>c978		73 65 65			        .text "see"
.c97b						+
.c97b						nt_ed:
>c97b		03 08				        .byte 3, NN
>c97d		86 c9 26 a8 29 a8		        .word +, xt_ed, z_ed
>c983		65 64 3a			        .text "ed:"
.c986						+
.c986						nt_cold:
>c986		04 00				        .byte 4, 0
>c988		92 c9 00 80 af 80		        .word nt_bye, xt_cold, z_cold
>c98e		63 6f 6c 64			        .text "cold"
.c992						nt_bye:
>c992		03				        .byte 3         ; length of word strings
>c993		00				        .byte 0         ; status byte
>c994		00 00				        .word 0000      ; next word in Dictionary, 0000 signals end
>c996		7a 98				        .word xt_bye    ; start of code block (xt of this word)
>c998		7d 98				        .word z_bye     ; end of code (RTS)
>c99a		62 79 65			        .text "bye"     ; word name, always lower case, not zero-terminated
.c99d						root_dictionary_start:
.c99d						nt_root_set_order:
>c99d		09 00				        .byte 9, 0
>c99f		ae c9 2e b3 61 b3		        .word nt_root_forth, xt_set_order, z_set_order
>c9a5		73 65 74 2d 6f 72 64 65		        .text "set-order"
>c9ad		72
.c9ae						nt_root_forth:
>c9ae		05 00				        .byte 5, 0
>c9b0		bb c9 13 b2 19 b2		        .word nt_root_forth_wordlist, xt_forth, z_forth
>c9b6		66 6f 72 74 68			        .text "forth"
.c9bb						nt_root_forth_wordlist:
>c9bb		0e 00				        .byte 14, 0
>c9bd		d1 c9 66 9e 6c 9e		        .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
>c9c3		66 6f 72 74 68 2d 77 6f		        .text "forth-wordlist"
>c9cb		72 64 6c 69 73 74
.c9d1						nt_root_words:
>c9d1		05 00				        .byte 5, 0
>c9d3		00 00 1b 9a 77 9a		        .word 0000, xt_words, z_words
>c9d9		77 6f 72 64 73			        .text "words"
.c9de						editor_dictionary_start:
.c9de						nt_editor_o:
>c9de		01 00				        .byte 1, 0
>c9e0		e7 c9 b4 b1 f9 b1		        .word nt_editor_line, xt_editor_o, z_editor_o
>c9e6		6f				        .text "o"
.c9e7						nt_editor_line:
>c9e7		04 00				        .byte 4, 0
>c9e9		f3 c9 9b b1 b3 b1		        .word nt_editor_l, xt_editor_line, z_editor_line
>c9ef		6c 69 6e 65			        .text "line"
.c9f3						nt_editor_l:
>c9f3		01 00				        .byte 1, 0
>c9f5		fc c9 25 b1 9a b1		        .word nt_editor_el, xt_editor_l, z_editor_l
>c9fb		6c				        .text "l"
.c9fc						nt_editor_el:
>c9fc		02 00				        .byte 2, 0
>c9fe		06 ca 13 b1 24 b1		        .word nt_editor_erase_screen, xt_editor_el, z_editor_el
>ca04		65 6c				        .text "el"
.ca06						nt_editor_erase_screen:
>ca06		0c 00				        .byte 12, 0
>ca08		1a ca 01 b1 12 b1		        .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
>ca0e		65 72 61 73 65 2d 73 63		        .text "erase-screen"
>ca16		72 65 65 6e
.ca1a						nt_editor_enter_screen:
>ca1a		0c 00				        .byte 12, 0
>ca1c		00 00 e5 b0 00 b1		        .word 0000, xt_editor_enter_screen, z_editor_enter_screen
>ca22		65 6e 74 65 72 2d 73 63		        .text "enter-screen"
>ca2a		72 65 65 6e
.ca2e						assembler_dictionary_start:
.ca2e						nt_asm_adc_h:
>ca2e		05 0a						.byte 5, IM+NN
>ca30		3b ca				                .word nt_asm_adc_x
>ca32		7b a4 80 a4					.word xt_asm_adc_h, z_asm_adc_h
>ca36		61 64 63 2e 23					.text "adc.#"
.ca3b						nt_asm_adc_x:
>ca3b		05 0a						.byte 5, IM+NN
>ca3d		48 ca				                .word nt_asm_adc_y
>ca3f		80 a4 85 a4					.word xt_asm_adc_x, z_asm_adc_x
>ca43		61 64 63 2e 78					.text "adc.x"
.ca48						nt_asm_adc_y:
>ca48		05 0a						.byte 5, IM+NN
>ca4a		55 ca				                .word nt_asm_adc_z
>ca4c		85 a4 8a a4					.word xt_asm_adc_y, z_asm_adc_y
>ca50		61 64 63 2e 79					.text "adc.y"
.ca55						nt_asm_adc_z:
>ca55		05 0a						.byte 5, IM+NN
>ca57		62 ca				                .word nt_asm_adc_zi
>ca59		8a a4 8f a4					.word xt_asm_adc_z, z_asm_adc_z
>ca5d		61 64 63 2e 7a					.text "adc.z"
.ca62						nt_asm_adc_zi:
>ca62		06 0a						.byte 6, IM+NN
>ca64		70 ca				                .word nt_asm_adc_ziy
>ca66		8f a4 94 a4					.word xt_asm_adc_zi, z_asm_adc_zi
>ca6a		61 64 63 2e 7a 69				.text "adc.zi"
.ca70						nt_asm_adc_ziy:
>ca70		07 0a						.byte 7, IM+NN
>ca72		7f ca				                .word nt_asm_adc_zx
>ca74		94 a4 99 a4					.word xt_asm_adc_ziy, z_asm_adc_ziy
>ca78		61 64 63 2e 7a 69 79				.text "adc.ziy"
.ca7f						nt_asm_adc_zx:
>ca7f		06 0a						.byte 6, IM+NN
>ca81		8d ca				                .word nt_asm_adc_zxi
>ca83		99 a4 9e a4					.word xt_asm_adc_zx, z_asm_adc_zx
>ca87		61 64 63 2e 7a 78				.text "adc.zx"
.ca8d						nt_asm_adc_zxi:
>ca8d		07 0a						.byte 7, IM+NN
>ca8f		9c ca				                .word nt_asm_and
>ca91		9e a4 a3 a4					.word xt_asm_adc_zxi, z_asm_adc_zxi
>ca95		61 64 63 2e 7a 78 69				.text "adc.zxi"
.ca9c						nt_asm_and:
>ca9c		04 0a						.byte 4, IM+NN
>ca9e		a8 ca				                .word nt_asm_and_h
>caa0		a3 a4 a8 a4					.word xt_asm_and, z_asm_and
>caa4		61 6e 64 2e					.text "and."
.caa8						nt_asm_and_h:
>caa8		05 0a						.byte 5, IM+NN
>caaa		b5 ca				                .word nt_asm_and_x
>caac		a8 a4 ad a4					.word xt_asm_and_h, z_asm_and_h
>cab0		61 6e 64 2e 23					.text "and.#"
.cab5						nt_asm_and_x:
>cab5		05 0a						.byte 5, IM+NN
>cab7		c2 ca				                .word nt_asm_and_y
>cab9		ad a4 b2 a4					.word xt_asm_and_x, z_asm_and_x
>cabd		61 6e 64 2e 78					.text "and.x"
.cac2						nt_asm_and_y:
>cac2		05 0a						.byte 5, IM+NN
>cac4		cf ca				                .word nt_asm_and_z
>cac6		b2 a4 b7 a4					.word xt_asm_and_y, z_asm_and_y
>caca		61 6e 64 2e 79					.text "and.y"
.cacf						nt_asm_and_z:
>cacf		05 0a						.byte 5, IM+NN
>cad1		dc ca				                .word nt_asm_and_zi
>cad3		b7 a4 bc a4					.word xt_asm_and_z, z_asm_and_z
>cad7		61 6e 64 2e 7a					.text "and.z"
.cadc						nt_asm_and_zi:
>cadc		06 0a						.byte 6, IM+NN
>cade		ea ca				                .word nt_asm_and_ziy
>cae0		bc a4 c1 a4					.word xt_asm_and_zi, z_asm_and_zi
>cae4		61 6e 64 2e 7a 69				.text "and.zi"
.caea						nt_asm_and_ziy:
>caea		07 0a						.byte 7, IM+NN
>caec		f9 ca				                .word nt_asm_and_zx
>caee		c1 a4 c6 a4					.word xt_asm_and_ziy, z_asm_and_ziy
>caf2		61 6e 64 2e 7a 69 79				.text "and.ziy"
.caf9						nt_asm_and_zx:
>caf9		06 0a						.byte 6, IM+NN
>cafb		07 cb				                .word nt_asm_and_zxi
>cafd		c6 a4 cb a4					.word xt_asm_and_zx, z_asm_and_zx
>cb01		61 6e 64 2e 7a 78				.text "and.zx"
.cb07						nt_asm_and_zxi:
>cb07		07 0a						.byte 7, IM+NN
>cb09		16 cb				                .word nt_asm_asl
>cb0b		cb a4 d0 a4					.word xt_asm_and_zxi, z_asm_and_zxi
>cb0f		61 6e 64 2e 7a 78 69				.text "and.zxi"
.cb16						nt_asm_asl:
>cb16		03 0a						.byte 3, IM+NN
>cb18		21 cb				                .word nt_asm_asl_a
>cb1a		d0 a4 d5 a4					.word xt_asm_asl, z_asm_asl
>cb1e		61 73 6c					.text "asl"
.cb21						nt_asm_asl_a:
>cb21		05 0a						.byte 5, IM+NN
>cb23		2e cb				                .word nt_asm_asl_x
>cb25		d5 a4 da a4					.word xt_asm_asl_a, z_asm_asl_a
>cb29		61 73 6c 2e 61					.text "asl.a"
.cb2e						nt_asm_asl_x:
>cb2e		05 0a						.byte 5, IM+NN
>cb30		3b cb				                .word nt_asm_asl_z
>cb32		da a4 df a4					.word xt_asm_asl_x, z_asm_asl_x
>cb36		61 73 6c 2e 78					.text "asl.x"
.cb3b						nt_asm_asl_z:
>cb3b		05 0a						.byte 5, IM+NN
>cb3d		48 cb				                .word nt_asm_asl_zx
>cb3f		df a4 e4 a4					.word xt_asm_asl_z, z_asm_asl_z
>cb43		61 73 6c 2e 7a					.text "asl.z"
.cb48						nt_asm_asl_zx:
>cb48		06 0a						.byte 6, IM+NN
>cb4a		56 cb				                .word nt_asm_bcc
>cb4c		e4 a4 e9 a4					.word xt_asm_asl_zx, z_asm_asl_zx
>cb50		61 73 6c 2e 7a 78				.text "asl.zx"
.cb56						nt_asm_bcc:
>cb56		03 0a						.byte 3, IM+NN
>cb58		61 cb				                .word nt_asm_bcs
>cb5a		e9 a4 ee a4					.word xt_asm_bcc, z_asm_bcc
>cb5e		62 63 63					.text "bcc"
.cb61						nt_asm_bcs:
>cb61		03 0a						.byte 3, IM+NN
>cb63		6c cb				                .word nt_asm_beq
>cb65		ee a4 f5 a4					.word xt_asm_bcs, z_asm_bcs
>cb69		62 63 73					.text "bcs"
.cb6c						nt_asm_beq:
>cb6c		03 0a						.byte 3, IM+NN
>cb6e		77 cb				                .word nt_asm_bit
>cb70		f5 a4 fa a4					.word xt_asm_beq, z_asm_beq
>cb74		62 65 71					.text "beq"
.cb77						nt_asm_bit:
>cb77		03 0a						.byte 3, IM+NN
>cb79		82 cb				                .word nt_asm_bit_h
>cb7b		fa a4 ff a4					.word xt_asm_bit, z_asm_bit
>cb7f		62 69 74					.text "bit"
.cb82						nt_asm_bit_h:
>cb82		05 0a						.byte 5, IM+NN
>cb84		8f cb				                .word nt_asm_bit_x
>cb86		ff a4 04 a5					.word xt_asm_bit_h, z_asm_bit_h
>cb8a		62 69 74 2e 23					.text "bit.#"
.cb8f						nt_asm_bit_x:
>cb8f		05 0a						.byte 5, IM+NN
>cb91		9c cb				                .word nt_asm_bit_z
>cb93		04 a5 09 a5					.word xt_asm_bit_x, z_asm_bit_x
>cb97		62 69 74 2e 78					.text "bit.x"
.cb9c						nt_asm_bit_z:
>cb9c		05 0a						.byte 5, IM+NN
>cb9e		a9 cb				                .word nt_asm_bit_zx
>cba0		09 a5 0e a5					.word xt_asm_bit_z, z_asm_bit_z
>cba4		62 69 74 2e 7a					.text "bit.z"
.cba9						nt_asm_bit_zx:
>cba9		06 0a						.byte 6, IM+NN
>cbab		b7 cb				                .word nt_asm_bmi
>cbad		0e a5 13 a5					.word xt_asm_bit_zx, z_asm_bit_zx
>cbb1		62 69 74 2e 7a 78				.text "bit.zx"
.cbb7						nt_asm_bmi:
>cbb7		03 0a						.byte 3, IM+NN
>cbb9		c2 cb				                .word nt_asm_bne
>cbbb		13 a5 18 a5					.word xt_asm_bmi, z_asm_bmi
>cbbf		62 6d 69					.text "bmi"
.cbc2						nt_asm_bne:
>cbc2		03 0a						.byte 3, IM+NN
>cbc4		cd cb				                .word nt_asm_bpl
>cbc6		18 a5 1d a5					.word xt_asm_bne, z_asm_bne
>cbca		62 6e 65					.text "bne"
.cbcd						nt_asm_bpl:
>cbcd		03 0a						.byte 3, IM+NN
>cbcf		d8 cb				                .word nt_asm_bra
>cbd1		1d a5 22 a5					.word xt_asm_bpl, z_asm_bpl
>cbd5		62 70 6c					.text "bpl"
.cbd8						nt_asm_bra:
>cbd8		03 0a						.byte 3, IM+NN
>cbda		e3 cb				                .word nt_asm_brk
>cbdc		22 a5 27 a5					.word xt_asm_bra, z_asm_bra
>cbe0		62 72 61					.text "bra"
.cbe3						nt_asm_brk:
>cbe3		03 0a						.byte 3, IM+NN
>cbe5		ee cb				                .word nt_asm_bvc
>cbe7		27 a5 2c a5					.word xt_asm_brk, z_asm_brk
>cbeb		62 72 6b					.text "brk"
.cbee						nt_asm_bvc:
>cbee		03 0a						.byte 3, IM+NN
>cbf0		f9 cb				                .word nt_asm_bvs
>cbf2		2c a5 31 a5					.word xt_asm_bvc, z_asm_bvc
>cbf6		62 76 63					.text "bvc"
.cbf9						nt_asm_bvs:
>cbf9		03 0a						.byte 3, IM+NN
>cbfb		04 cc				                .word nt_asm_clc
>cbfd		31 a5 36 a5					.word xt_asm_bvs, z_asm_bvs
>cc01		62 76 73					.text "bvs"
.cc04						nt_asm_clc:
>cc04		03 0a						.byte 3, IM+NN
>cc06		0f cc				                .word nt_asm_cld
>cc08		36 a5 3b a5					.word xt_asm_clc, z_asm_clc
>cc0c		63 6c 63					.text "clc"
.cc0f						nt_asm_cld:
>cc0f		03 0a						.byte 3, IM+NN
>cc11		1a cc				                .word nt_asm_cli
>cc13		3b a5 40 a5					.word xt_asm_cld, z_asm_cld
>cc17		63 6c 64					.text "cld"
.cc1a						nt_asm_cli:
>cc1a		03 0a						.byte 3, IM+NN
>cc1c		25 cc				                .word nt_asm_clv
>cc1e		40 a5 45 a5					.word xt_asm_cli, z_asm_cli
>cc22		63 6c 69					.text "cli"
.cc25						nt_asm_clv:
>cc25		03 0a						.byte 3, IM+NN
>cc27		30 cc				                .word nt_asm_cmp
>cc29		45 a5 4a a5					.word xt_asm_clv, z_asm_clv
>cc2d		63 6c 76					.text "clv"
.cc30						nt_asm_cmp:
>cc30		03 0a						.byte 3, IM+NN
>cc32		3b cc				                .word nt_asm_cmp_h
>cc34		4a a5 4f a5					.word xt_asm_cmp, z_asm_cmp
>cc38		63 6d 70					.text "cmp"
.cc3b						nt_asm_cmp_h:
>cc3b		05 0a						.byte 5, IM+NN
>cc3d		48 cc				                .word nt_asm_cmp_x
>cc3f		4f a5 54 a5					.word xt_asm_cmp_h, z_asm_cmp_h
>cc43		63 6d 70 2e 23					.text "cmp.#"
.cc48						nt_asm_cmp_x:
>cc48		05 0a						.byte 5, IM+NN
>cc4a		55 cc				                .word nt_asm_cmp_y
>cc4c		54 a5 59 a5					.word xt_asm_cmp_x, z_asm_cmp_x
>cc50		63 6d 70 2e 78					.text "cmp.x"
.cc55						nt_asm_cmp_y:
>cc55		05 0a						.byte 5, IM+NN
>cc57		62 cc				                .word nt_asm_cmp_z
>cc59		59 a5 5e a5					.word xt_asm_cmp_y, z_asm_cmp_y
>cc5d		63 6d 70 2e 79					.text "cmp.y"
.cc62						nt_asm_cmp_z:
>cc62		05 0a						.byte 5, IM+NN
>cc64		6f cc				                .word nt_asm_cmp_zi
>cc66		5e a5 63 a5					.word xt_asm_cmp_z, z_asm_cmp_z
>cc6a		63 6d 70 2e 7a					.text "cmp.z"
.cc6f						nt_asm_cmp_zi:
>cc6f		06 0a						.byte 6, IM+NN
>cc71		7d cc				                .word nt_asm_cmp_ziy
>cc73		63 a5 68 a5					.word xt_asm_cmp_zi, z_asm_cmp_zi
>cc77		63 6d 70 2e 7a 69				.text "cmp.zi"
.cc7d						nt_asm_cmp_ziy:
>cc7d		07 0a						.byte 7, IM+NN
>cc7f		8c cc				                .word nt_asm_cmp_zx
>cc81		68 a5 6d a5					.word xt_asm_cmp_ziy, z_asm_cmp_ziy
>cc85		63 6d 70 2e 7a 69 79				.text "cmp.ziy"
.cc8c						nt_asm_cmp_zx:
>cc8c		06 0a						.byte 6, IM+NN
>cc8e		9a cc				                .word nt_asm_cmp_zxi
>cc90		6d a5 72 a5					.word xt_asm_cmp_zx, z_asm_cmp_zx
>cc94		63 6d 70 2e 7a 78				.text "cmp.zx"
.cc9a						nt_asm_cmp_zxi:
>cc9a		07 0a						.byte 7, IM+NN
>cc9c		a9 cc				                .word nt_asm_cpx
>cc9e		72 a5 77 a5					.word xt_asm_cmp_zxi, z_asm_cmp_zxi
>cca2		63 6d 70 2e 7a 78 69				.text "cmp.zxi"
.cca9						nt_asm_cpx:
>cca9		03 0a						.byte 3, IM+NN
>ccab		b4 cc				                .word nt_asm_cpx_h
>ccad		77 a5 7c a5					.word xt_asm_cpx, z_asm_cpx
>ccb1		63 70 78					.text "cpx"
.ccb4						nt_asm_cpx_h:
>ccb4		05 0a						.byte 5, IM+NN
>ccb6		c1 cc				                .word nt_asm_cpx_z
>ccb8		7c a5 81 a5					.word xt_asm_cpx_h, z_asm_cpx_h
>ccbc		63 70 78 2e 23					.text "cpx.#"
.ccc1						nt_asm_cpx_z:
>ccc1		05 0a						.byte 5, IM+NN
>ccc3		ce cc				                .word nt_asm_cpy
>ccc5		81 a5 86 a5					.word xt_asm_cpx_z, z_asm_cpx_z
>ccc9		63 70 78 2e 7a					.text "cpx.z"
.ccce						nt_asm_cpy:
>ccce		03 0a						.byte 3, IM+NN
>ccd0		d9 cc				                .word nt_asm_cpy_h
>ccd2		86 a5 8d a5					.word xt_asm_cpy, z_asm_cpy
>ccd6		63 70 79					.text "cpy"
.ccd9						nt_asm_cpy_h:
>ccd9		05 0a						.byte 5, IM+NN
>ccdb		e6 cc				                .word nt_asm_cpy_z
>ccdd		8d a5 92 a5					.word xt_asm_cpy_h, z_asm_cpy_h
>cce1		63 70 79 2e 23					.text "cpy.#"
.cce6						nt_asm_cpy_z:
>cce6		05 0a						.byte 5, IM+NN
>cce8		f3 cc				                .word nt_asm_dec
>ccea		92 a5 97 a5					.word xt_asm_cpy_z, z_asm_cpy_z
>ccee		63 70 79 2e 7a					.text "cpy.z"
.ccf3						nt_asm_dec:
>ccf3		03 0a						.byte 3, IM+NN
>ccf5		fe cc				                .word nt_asm_dec_a
>ccf7		97 a5 9c a5					.word xt_asm_dec, z_asm_dec
>ccfb		64 65 63					.text "dec"
.ccfe						nt_asm_dec_a:
>ccfe		05 0a						.byte 5, IM+NN
>cd00		0b cd				                .word nt_asm_dec_x
>cd02		9c a5 a1 a5					.word xt_asm_dec_a, z_asm_dec_a
>cd06		64 65 63 2e 61					.text "dec.a"
.cd0b						nt_asm_dec_x:
>cd0b		05 0a						.byte 5, IM+NN
>cd0d		18 cd				                .word nt_asm_dec_z
>cd0f		a1 a5 a6 a5					.word xt_asm_dec_x, z_asm_dec_x
>cd13		64 65 63 2e 78					.text "dec.x"
.cd18						nt_asm_dec_z:
>cd18		05 0a						.byte 5, IM+NN
>cd1a		25 cd				                .word nt_asm_dec_zx
>cd1c		a6 a5 ab a5					.word xt_asm_dec_z, z_asm_dec_z
>cd20		64 65 63 2e 7a					.text "dec.z"
.cd25						nt_asm_dec_zx:
>cd25		06 0a						.byte 6, IM+NN
>cd27		33 cd				                .word nt_asm_dex
>cd29		ab a5 b0 a5					.word xt_asm_dec_zx, z_asm_dec_zx
>cd2d		64 65 63 2e 7a 78				.text "dec.zx"
.cd33						nt_asm_dex:
>cd33		03 0a						.byte 3, IM+NN
>cd35		3e cd				                .word nt_asm_dey
>cd37		b0 a5 b5 a5					.word xt_asm_dex, z_asm_dex
>cd3b		64 65 78					.text "dex"
.cd3e						nt_asm_dey:
>cd3e		03 0a						.byte 3, IM+NN
>cd40		49 cd				                .word nt_asm_eor
>cd42		b5 a5 ba a5					.word xt_asm_dey, z_asm_dey
>cd46		64 65 79					.text "dey"
.cd49						nt_asm_eor:
>cd49		03 0a						.byte 3, IM+NN
>cd4b		54 cd				                .word nt_asm_eor_h
>cd4d		ba a5 bf a5					.word xt_asm_eor, z_asm_eor
>cd51		65 6f 72					.text "eor"
.cd54						nt_asm_eor_h:
>cd54		05 0a						.byte 5, IM+NN
>cd56		61 cd				                .word nt_asm_eor_x
>cd58		bf a5 c4 a5					.word xt_asm_eor_h, z_asm_eor_h
>cd5c		65 6f 72 2e 23					.text "eor.#"
.cd61						nt_asm_eor_x:
>cd61		05 0a						.byte 5, IM+NN
>cd63		6e cd				                .word nt_asm_eor_y
>cd65		c4 a5 c9 a5					.word xt_asm_eor_x, z_asm_eor_x
>cd69		65 6f 72 2e 78					.text "eor.x"
.cd6e						nt_asm_eor_y:
>cd6e		05 0a						.byte 5, IM+NN
>cd70		7b cd				                .word nt_asm_eor_z
>cd72		c9 a5 ce a5					.word xt_asm_eor_y, z_asm_eor_y
>cd76		65 6f 72 2e 79					.text "eor.y"
.cd7b						nt_asm_eor_z:
>cd7b		05 0a						.byte 5, IM+NN
>cd7d		88 cd				                .word nt_asm_eor_zi
>cd7f		ce a5 d3 a5					.word xt_asm_eor_z, z_asm_eor_z
>cd83		65 6f 72 2e 7a					.text "eor.z"
.cd88						nt_asm_eor_zi:
>cd88		06 0a						.byte 6, IM+NN
>cd8a		96 cd				                .word nt_asm_eor_ziy
>cd8c		d3 a5 d8 a5					.word xt_asm_eor_zi, z_asm_eor_zi
>cd90		65 6f 72 2e 7a 69				.text "eor.zi"
.cd96						nt_asm_eor_ziy:
>cd96		07 0a						.byte 7, IM+NN
>cd98		a5 cd				                .word nt_asm_eor_zx
>cd9a		d8 a5 dd a5					.word xt_asm_eor_ziy, z_asm_eor_ziy
>cd9e		65 6f 72 2e 7a 69 79				.text "eor.ziy"
.cda5						nt_asm_eor_zx:
>cda5		06 0a						.byte 6, IM+NN
>cda7		b3 cd				                .word nt_asm_eor_zxi
>cda9		dd a5 e2 a5					.word xt_asm_eor_zx, z_asm_eor_zx
>cdad		65 6f 72 2e 7a 78				.text "eor.zx"
.cdb3						nt_asm_eor_zxi:
>cdb3		07 0a						.byte 7, IM+NN
>cdb5		c2 cd				                .word nt_asm_inc
>cdb7		e2 a5 e7 a5					.word xt_asm_eor_zxi, z_asm_eor_zxi
>cdbb		65 6f 72 2e 7a 78 69				.text "eor.zxi"
.cdc2						nt_asm_inc:
>cdc2		03 0a						.byte 3, IM+NN
>cdc4		cd cd				                .word nt_asm_inc_a
>cdc6		e7 a5 ec a5					.word xt_asm_inc, z_asm_inc
>cdca		69 6e 63					.text "inc"
.cdcd						nt_asm_inc_a:
>cdcd		05 0a						.byte 5, IM+NN
>cdcf		da cd				                .word nt_asm_inc_x
>cdd1		ec a5 f1 a5					.word xt_asm_inc_a, z_asm_inc_a
>cdd5		69 6e 63 2e 61					.text "inc.a"
.cdda						nt_asm_inc_x:
>cdda		05 0a						.byte 5, IM+NN
>cddc		e7 cd				                .word nt_asm_inc_z
>cdde		f1 a5 f6 a5					.word xt_asm_inc_x, z_asm_inc_x
>cde2		69 6e 63 2e 78					.text "inc.x"
.cde7						nt_asm_inc_z:
>cde7		05 0a						.byte 5, IM+NN
>cde9		f4 cd				                .word nt_asm_inc_zx
>cdeb		f6 a5 fb a5					.word xt_asm_inc_z, z_asm_inc_z
>cdef		69 6e 63 2e 7a					.text "inc.z"
.cdf4						nt_asm_inc_zx:
>cdf4		06 0a						.byte 6, IM+NN
>cdf6		02 ce				                .word nt_asm_inx
>cdf8		fb a5 00 a6					.word xt_asm_inc_zx, z_asm_inc_zx
>cdfc		69 6e 63 2e 7a 78				.text "inc.zx"
.ce02						nt_asm_inx:
>ce02		03 0a						.byte 3, IM+NN
>ce04		0d ce				                .word nt_asm_iny
>ce06		00 a6 05 a6					.word xt_asm_inx, z_asm_inx
>ce0a		69 6e 78					.text "inx"
.ce0d						nt_asm_iny:
>ce0d		03 0a						.byte 3, IM+NN
>ce0f		18 ce				                .word nt_asm_jmp
>ce11		05 a6 0a a6					.word xt_asm_iny, z_asm_iny
>ce15		69 6e 79					.text "iny"
.ce18						nt_asm_jmp:
>ce18		03 0a						.byte 3, IM+NN
>ce1a		23 ce				                .word nt_asm_jmp_i
>ce1c		0a a6 0d a6					.word xt_asm_jmp, z_asm_jmp
>ce20		6a 6d 70					.text "jmp"
.ce23						nt_asm_jmp_i:
>ce23		05 0a						.byte 5, IM+NN
>ce25		30 ce				                .word nt_asm_jmp_xi
>ce27		0d a6 12 a6					.word xt_asm_jmp_i, z_asm_jmp_i
>ce2b		6a 6d 70 2e 69					.text "jmp.i"
.ce30						nt_asm_jmp_xi:
>ce30		06 0a						.byte 6, IM+NN
>ce32		3e ce				                .word nt_asm_jsr
>ce34		12 a6 17 a6					.word xt_asm_jmp_xi, z_asm_jmp_xi
>ce38		6a 6d 70 2e 78 69				.text "jmp.xi"
.ce3e						nt_asm_jsr:
>ce3e		03 0a						.byte 3, IM+NN
>ce40		49 ce				                .word nt_asm_lda
>ce42		17 a6 1c a6					.word xt_asm_jsr, z_asm_jsr
>ce46		6a 73 72					.text "jsr"
.ce49						nt_asm_lda:
>ce49		03 0a						.byte 3, IM+NN
>ce4b		54 ce				                .word nt_asm_lda_h
>ce4d		1c a6 21 a6					.word xt_asm_lda, z_asm_lda
>ce51		6c 64 61					.text "lda"
.ce54						nt_asm_lda_h:
>ce54		05 0a						.byte 5, IM+NN
>ce56		61 ce				                .word nt_asm_lda_x
>ce58		21 a6 26 a6					.word xt_asm_lda_h, z_asm_lda_h
>ce5c		6c 64 61 2e 23					.text "lda.#"
.ce61						nt_asm_lda_x:
>ce61		05 0a						.byte 5, IM+NN
>ce63		6e ce				                .word nt_asm_lda_y
>ce65		26 a6 2b a6					.word xt_asm_lda_x, z_asm_lda_x
>ce69		6c 64 61 2e 78					.text "lda.x"
.ce6e						nt_asm_lda_y:
>ce6e		05 0a						.byte 5, IM+NN
>ce70		7b ce				                .word nt_asm_lda_z
>ce72		2b a6 30 a6					.word xt_asm_lda_y, z_asm_lda_y
>ce76		6c 64 61 2e 79					.text "lda.y"
.ce7b						nt_asm_lda_z:
>ce7b		05 0a						.byte 5, IM+NN
>ce7d		88 ce				                .word nt_asm_lda_zi
>ce7f		30 a6 35 a6					.word xt_asm_lda_z, z_asm_lda_z
>ce83		6c 64 61 2e 7a					.text "lda.z"
.ce88						nt_asm_lda_zi:
>ce88		06 0a						.byte 6, IM+NN
>ce8a		96 ce				                .word nt_asm_lda_ziy
>ce8c		35 a6 3a a6					.word xt_asm_lda_zi, z_asm_lda_zi
>ce90		6c 64 61 2e 7a 69				.text "lda.zi"
.ce96						nt_asm_lda_ziy:
>ce96		07 0a						.byte 7, IM+NN
>ce98		a5 ce				                .word nt_asm_lda_zx
>ce9a		3a a6 3f a6					.word xt_asm_lda_ziy, z_asm_lda_ziy
>ce9e		6c 64 61 2e 7a 69 79				.text "lda.ziy"
.cea5						nt_asm_lda_zx:
>cea5		06 0a						.byte 6, IM+NN
>cea7		b3 ce				                .word nt_asm_lda_zxi
>cea9		3f a6 44 a6					.word xt_asm_lda_zx, z_asm_lda_zx
>cead		6c 64 61 2e 7a 78				.text "lda.zx"
.ceb3						nt_asm_lda_zxi:
>ceb3		07 0a						.byte 7, IM+NN
>ceb5		c2 ce				                .word nt_asm_ldx
>ceb7		44 a6 49 a6					.word xt_asm_lda_zxi, z_asm_lda_zxi
>cebb		6c 64 61 2e 7a 78 69				.text "lda.zxi"
.cec2						nt_asm_ldx:
>cec2		03 0a						.byte 3, IM+NN
>cec4		cd ce				                .word nt_asm_ldx_h
>cec6		49 a6 4e a6					.word xt_asm_ldx, z_asm_ldx
>ceca		6c 64 78					.text "ldx"
.cecd						nt_asm_ldx_h:
>cecd		05 0a						.byte 5, IM+NN
>cecf		da ce				                .word nt_asm_ldx_y
>ced1		4e a6 53 a6					.word xt_asm_ldx_h, z_asm_ldx_h
>ced5		6c 64 78 2e 23					.text "ldx.#"
.ceda						nt_asm_ldx_y:
>ceda		05 0a						.byte 5, IM+NN
>cedc		e7 ce				                .word nt_asm_ldx_z
>cede		53 a6 58 a6					.word xt_asm_ldx_y, z_asm_ldx_y
>cee2		6c 64 78 2e 79					.text "ldx.y"
.cee7						nt_asm_ldx_z:
>cee7		05 0a						.byte 5, IM+NN
>cee9		f4 ce				                .word nt_asm_ldx_zy
>ceeb		58 a6 5d a6					.word xt_asm_ldx_z, z_asm_ldx_z
>ceef		6c 64 78 2e 7a					.text "ldx.z"
.cef4						nt_asm_ldx_zy:
>cef4		06 0a						.byte 6, IM+NN
>cef6		02 cf				                .word nt_asm_ldy
>cef8		5d a6 62 a6					.word xt_asm_ldx_zy, z_asm_ldx_zy
>cefc		6c 64 78 2e 7a 79				.text "ldx.zy"
.cf02						nt_asm_ldy:
>cf02		03 0a						.byte 3, IM+NN
>cf04		0d cf				                .word nt_asm_ldy_h
>cf06		62 a6 67 a6					.word xt_asm_ldy, z_asm_ldy
>cf0a		6c 64 79					.text "ldy"
.cf0d						nt_asm_ldy_h:
>cf0d		05 0a						.byte 5, IM+NN
>cf0f		1a cf				                .word nt_asm_ldy_x
>cf11		67 a6 6c a6					.word xt_asm_ldy_h, z_asm_ldy_h
>cf15		6c 64 79 2e 23					.text "ldy.#"
.cf1a						nt_asm_ldy_x:
>cf1a		05 0a						.byte 5, IM+NN
>cf1c		27 cf				                .word nt_asm_ldy_z
>cf1e		6c a6 71 a6					.word xt_asm_ldy_x, z_asm_ldy_x
>cf22		6c 64 79 2e 78					.text "ldy.x"
.cf27						nt_asm_ldy_z:
>cf27		05 0a						.byte 5, IM+NN
>cf29		34 cf				                .word nt_asm_ldy_zx
>cf2b		71 a6 76 a6					.word xt_asm_ldy_z, z_asm_ldy_z
>cf2f		6c 64 79 2e 7a					.text "ldy.z"
.cf34						nt_asm_ldy_zx:
>cf34		06 0a						.byte 6, IM+NN
>cf36		42 cf				                .word nt_asm_lsr
>cf38		76 a6 7b a6					.word xt_asm_ldy_zx, z_asm_ldy_zx
>cf3c		6c 64 79 2e 7a 78				.text "ldy.zx"
.cf42						nt_asm_lsr:
>cf42		03 0a						.byte 3, IM+NN
>cf44		4d cf				                .word nt_asm_lsr_a
>cf46		7b a6 80 a6					.word xt_asm_lsr, z_asm_lsr
>cf4a		6c 73 72					.text "lsr"
.cf4d						nt_asm_lsr_a:
>cf4d		05 0a						.byte 5, IM+NN
>cf4f		5a cf				                .word nt_asm_lsr_x
>cf51		80 a6 85 a6					.word xt_asm_lsr_a, z_asm_lsr_a
>cf55		6c 73 72 2e 61					.text "lsr.a"
.cf5a						nt_asm_lsr_x:
>cf5a		05 0a						.byte 5, IM+NN
>cf5c		67 cf				                .word nt_asm_lsr_z
>cf5e		85 a6 8a a6					.word xt_asm_lsr_x, z_asm_lsr_x
>cf62		6c 73 72 2e 78					.text "lsr.x"
.cf67						nt_asm_lsr_z:
>cf67		05 0a						.byte 5, IM+NN
>cf69		74 cf				                .word nt_asm_lsr_zx
>cf6b		8a a6 8f a6					.word xt_asm_lsr_z, z_asm_lsr_z
>cf6f		6c 73 72 2e 7a					.text "lsr.z"
.cf74						nt_asm_lsr_zx:
>cf74		06 0a						.byte 6, IM+NN
>cf76		82 cf				                .word nt_asm_nop
>cf78		8f a6 94 a6					.word xt_asm_lsr_zx, z_asm_lsr_zx
>cf7c		6c 73 72 2e 7a 78				.text "lsr.zx"
.cf82						nt_asm_nop:
>cf82		03 0a						.byte 3, IM+NN
>cf84		8d cf				                .word nt_asm_ora
>cf86		94 a6 99 a6					.word xt_asm_nop, z_asm_nop
>cf8a		6e 6f 70					.text "nop"
.cf8d						nt_asm_ora:
>cf8d		03 0a						.byte 3, IM+NN
>cf8f		98 cf				                .word nt_asm_ora_h
>cf91		99 a6 9e a6					.word xt_asm_ora, z_asm_ora
>cf95		6f 72 61					.text "ora"
.cf98						nt_asm_ora_h:
>cf98		05 0a						.byte 5, IM+NN
>cf9a		a5 cf				                .word nt_asm_ora_x
>cf9c		9e a6 a3 a6					.word xt_asm_ora_h, z_asm_ora_h
>cfa0		6f 72 61 2e 23					.text "ora.#"
.cfa5						nt_asm_ora_x:
>cfa5		05 0a						.byte 5, IM+NN
>cfa7		b2 cf				                .word nt_asm_ora_y
>cfa9		a3 a6 a8 a6					.word xt_asm_ora_x, z_asm_ora_x
>cfad		6f 72 61 2e 78					.text "ora.x"
.cfb2						nt_asm_ora_y:
>cfb2		05 0a						.byte 5, IM+NN
>cfb4		bf cf				                .word nt_asm_ora_z
>cfb6		a8 a6 ad a6					.word xt_asm_ora_y, z_asm_ora_y
>cfba		6f 72 61 2e 79					.text "ora.y"
.cfbf						nt_asm_ora_z:
>cfbf		05 0a						.byte 5, IM+NN
>cfc1		cc cf				                .word nt_asm_ora_zi
>cfc3		ad a6 b2 a6					.word xt_asm_ora_z, z_asm_ora_z
>cfc7		6f 72 61 2e 7a					.text "ora.z"
.cfcc						nt_asm_ora_zi:
>cfcc		06 0a						.byte 6, IM+NN
>cfce		da cf				                .word nt_asm_ora_ziy
>cfd0		b2 a6 b9 a6					.word xt_asm_ora_zi, z_asm_ora_zi
>cfd4		6f 72 61 2e 7a 69				.text "ora.zi"
.cfda						nt_asm_ora_ziy:
>cfda		07 0a						.byte 7, IM+NN
>cfdc		e9 cf				                .word nt_asm_ora_zx
>cfde		b9 a6 be a6					.word xt_asm_ora_ziy, z_asm_ora_ziy
>cfe2		6f 72 61 2e 7a 69 79				.text "ora.ziy"
.cfe9						nt_asm_ora_zx:
>cfe9		06 0a						.byte 6, IM+NN
>cfeb		f7 cf				                .word nt_asm_ora_zxi
>cfed		be a6 c3 a6					.word xt_asm_ora_zx, z_asm_ora_zx
>cff1		6f 72 61 2e 7a 78				.text "ora.zx"
.cff7						nt_asm_ora_zxi:
>cff7		07 0a						.byte 7, IM+NN
>cff9		06 d0				                .word nt_asm_pha
>cffb		c3 a6 c8 a6					.word xt_asm_ora_zxi, z_asm_ora_zxi
>cfff		6f 72 61 2e 7a 78 69				.text "ora.zxi"
.d006						nt_asm_pha:
>d006		03 0a						.byte 3, IM+NN
>d008		11 d0				                .word nt_asm_php
>d00a		c8 a6 cd a6					.word xt_asm_pha, z_asm_pha
>d00e		70 68 61					.text "pha"
.d011						nt_asm_php:
>d011		03 0a						.byte 3, IM+NN
>d013		1c d0				                .word nt_asm_phx
>d015		cd a6 d2 a6					.word xt_asm_php, z_asm_php
>d019		70 68 70					.text "php"
.d01c						nt_asm_phx:
>d01c		03 0a						.byte 3, IM+NN
>d01e		27 d0				                .word nt_asm_phy
>d020		d2 a6 d7 a6					.word xt_asm_phx, z_asm_phx
>d024		70 68 78					.text "phx"
.d027						nt_asm_phy:
>d027		03 0a						.byte 3, IM+NN
>d029		32 d0				                .word nt_asm_pla
>d02b		d7 a6 dc a6					.word xt_asm_phy, z_asm_phy
>d02f		70 68 79					.text "phy"
.d032						nt_asm_pla:
>d032		03 0a						.byte 3, IM+NN
>d034		3d d0				                .word nt_asm_plp
>d036		dc a6 e1 a6					.word xt_asm_pla, z_asm_pla
>d03a		70 6c 61					.text "pla"
.d03d						nt_asm_plp:
>d03d		03 0a						.byte 3, IM+NN
>d03f		48 d0				                .word nt_asm_plx
>d041		e1 a6 e6 a6					.word xt_asm_plp, z_asm_plp
>d045		70 6c 70					.text "plp"
.d048						nt_asm_plx:
>d048		03 0a						.byte 3, IM+NN
>d04a		53 d0				                .word nt_asm_ply
>d04c		e6 a6 eb a6					.word xt_asm_plx, z_asm_plx
>d050		70 6c 78					.text "plx"
.d053						nt_asm_ply:
>d053		03 0a						.byte 3, IM+NN
>d055		5e d0				                .word nt_asm_rol
>d057		eb a6 f0 a6					.word xt_asm_ply, z_asm_ply
>d05b		70 6c 79					.text "ply"
.d05e						nt_asm_rol:
>d05e		03 0a						.byte 3, IM+NN
>d060		69 d0				                .word nt_asm_rol_a
>d062		f0 a6 f5 a6					.word xt_asm_rol, z_asm_rol
>d066		72 6f 6c					.text "rol"
.d069						nt_asm_rol_a:
>d069		05 0a						.byte 5, IM+NN
>d06b		76 d0				                .word nt_asm_rol_x
>d06d		f5 a6 fa a6					.word xt_asm_rol_a, z_asm_rol_a
>d071		72 6f 6c 2e 61					.text "rol.a"
.d076						nt_asm_rol_x:
>d076		05 0a						.byte 5, IM+NN
>d078		83 d0				                .word nt_asm_rol_z
>d07a		fa a6 ff a6					.word xt_asm_rol_x, z_asm_rol_x
>d07e		72 6f 6c 2e 78					.text "rol.x"
.d083						nt_asm_rol_z:
>d083		05 0a						.byte 5, IM+NN
>d085		90 d0				                .word nt_asm_rol_zx
>d087		ff a6 04 a7					.word xt_asm_rol_z, z_asm_rol_z
>d08b		72 6f 6c 2e 7a					.text "rol.z"
.d090						nt_asm_rol_zx:
>d090		06 0a						.byte 6, IM+NN
>d092		9e d0				                .word nt_asm_ror
>d094		04 a7 09 a7					.word xt_asm_rol_zx, z_asm_rol_zx
>d098		72 6f 6c 2e 7a 78				.text "rol.zx"
.d09e						nt_asm_ror:
>d09e		03 0a						.byte 3, IM+NN
>d0a0		a9 d0				                .word nt_asm_ror_a
>d0a2		09 a7 0e a7					.word xt_asm_ror, z_asm_ror
>d0a6		72 6f 72					.text "ror"
.d0a9						nt_asm_ror_a:
>d0a9		05 0a						.byte 5, IM+NN
>d0ab		b6 d0				                .word nt_asm_ror_x
>d0ad		0e a7 13 a7					.word xt_asm_ror_a, z_asm_ror_a
>d0b1		72 6f 72 2e 61					.text "ror.a"
.d0b6						nt_asm_ror_x:
>d0b6		05 0a						.byte 5, IM+NN
>d0b8		c3 d0				                .word nt_asm_ror_z
>d0ba		13 a7 18 a7					.word xt_asm_ror_x, z_asm_ror_x
>d0be		72 6f 72 2e 78					.text "ror.x"
.d0c3						nt_asm_ror_z:
>d0c3		05 0a						.byte 5, IM+NN
>d0c5		d0 d0				                .word nt_asm_ror_zx
>d0c7		18 a7 1d a7					.word xt_asm_ror_z, z_asm_ror_z
>d0cb		72 6f 72 2e 7a					.text "ror.z"
.d0d0						nt_asm_ror_zx:
>d0d0		06 0a						.byte 6, IM+NN
>d0d2		de d0				                .word nt_asm_rti
>d0d4		1d a7 22 a7					.word xt_asm_ror_zx, z_asm_ror_zx
>d0d8		72 6f 72 2e 7a 78				.text "ror.zx"
.d0de						nt_asm_rti:
>d0de		03 0a						.byte 3, IM+NN
>d0e0		e9 d0				                .word nt_asm_rts
>d0e2		22 a7 27 a7					.word xt_asm_rti, z_asm_rti
>d0e6		72 74 69					.text "rti"
.d0e9						nt_asm_rts:
>d0e9		03 0a						.byte 3, IM+NN
>d0eb		f4 d0				                .word nt_asm_sbc
>d0ed		27 a7 2c a7					.word xt_asm_rts, z_asm_rts
>d0f1		72 74 73					.text "rts"
.d0f4						nt_asm_sbc:
>d0f4		03 0a						.byte 3, IM+NN
>d0f6		ff d0				                .word nt_asm_sbc_h
>d0f8		2c a7 31 a7					.word xt_asm_sbc, z_asm_sbc
>d0fc		73 62 63					.text "sbc"
.d0ff						nt_asm_sbc_h:
>d0ff		05 0a						.byte 5, IM+NN
>d101		0c d1				                .word nt_asm_sbc_x
>d103		31 a7 36 a7					.word xt_asm_sbc_h, z_asm_sbc_h
>d107		73 62 63 2e 23					.text "sbc.#"
.d10c						nt_asm_sbc_x:
>d10c		05 0a						.byte 5, IM+NN
>d10e		19 d1				                .word nt_asm_sbc_y
>d110		36 a7 3b a7					.word xt_asm_sbc_x, z_asm_sbc_x
>d114		73 62 63 2e 78					.text "sbc.x"
.d119						nt_asm_sbc_y:
>d119		05 0a						.byte 5, IM+NN
>d11b		26 d1				                .word nt_asm_sbc_z
>d11d		3b a7 40 a7					.word xt_asm_sbc_y, z_asm_sbc_y
>d121		73 62 63 2e 79					.text "sbc.y"
.d126						nt_asm_sbc_z:
>d126		05 0a						.byte 5, IM+NN
>d128		33 d1				                .word nt_asm_sbc_zi
>d12a		40 a7 45 a7					.word xt_asm_sbc_z, z_asm_sbc_z
>d12e		73 62 63 2e 7a					.text "sbc.z"
.d133						nt_asm_sbc_zi:
>d133		06 0a						.byte 6, IM+NN
>d135		41 d1				                .word nt_asm_sbc_ziy
>d137		45 a7 4a a7					.word xt_asm_sbc_zi, z_asm_sbc_zi
>d13b		73 62 63 2e 7a 69				.text "sbc.zi"
.d141						nt_asm_sbc_ziy:
>d141		07 0a						.byte 7, IM+NN
>d143		50 d1				                .word nt_asm_sbc_zx
>d145		4a a7 4f a7					.word xt_asm_sbc_ziy, z_asm_sbc_ziy
>d149		73 62 63 2e 7a 69 79				.text "sbc.ziy"
.d150						nt_asm_sbc_zx:
>d150		06 0a						.byte 6, IM+NN
>d152		5e d1				                .word nt_asm_sbc_zxi
>d154		4f a7 54 a7					.word xt_asm_sbc_zx, z_asm_sbc_zx
>d158		73 62 63 2e 7a 78				.text "sbc.zx"
.d15e						nt_asm_sbc_zxi:
>d15e		07 0a						.byte 7, IM+NN
>d160		6d d1				                .word nt_asm_sec
>d162		54 a7 58 a7					.word xt_asm_sbc_zxi, z_asm_sbc_zxi
>d166		73 62 63 2e 7a 78 69				.text "sbc.zxi"
.d16d						nt_asm_sec:
>d16d		03 0a						.byte 3, IM+NN
>d16f		78 d1				                .word nt_asm_sed
>d171		58 a7 5c a7					.word xt_asm_sec, z_asm_sec
>d175		73 65 63					.text "sec"
.d178						nt_asm_sed:
>d178		03 0a						.byte 3, IM+NN
>d17a		83 d1				                .word nt_asm_sei
>d17c		5c a7 60 a7					.word xt_asm_sed, z_asm_sed
>d180		73 65 64					.text "sed"
.d183						nt_asm_sei:
>d183		03 0a						.byte 3, IM+NN
>d185		8e d1				                .word nt_asm_sta
>d187		60 a7 64 a7					.word xt_asm_sei, z_asm_sei
>d18b		73 65 69					.text "sei"
.d18e						nt_asm_sta:
>d18e		03 0a						.byte 3, IM+NN
>d190		99 d1				                .word nt_asm_sta_x
>d192		64 a7 68 a7					.word xt_asm_sta, z_asm_sta
>d196		73 74 61					.text "sta"
.d199						nt_asm_sta_x:
>d199		05 0a						.byte 5, IM+NN
>d19b		a6 d1				                .word nt_asm_sta_y
>d19d		68 a7 6c a7					.word xt_asm_sta_x, z_asm_sta_x
>d1a1		73 74 61 2e 78					.text "sta.x"
.d1a6						nt_asm_sta_y:
>d1a6		05 0a						.byte 5, IM+NN
>d1a8		b3 d1				                .word nt_asm_sta_z
>d1aa		6c a7 70 a7					.word xt_asm_sta_y, z_asm_sta_y
>d1ae		73 74 61 2e 79					.text "sta.y"
.d1b3						nt_asm_sta_z:
>d1b3		05 0a						.byte 5, IM+NN
>d1b5		c0 d1				                .word nt_asm_sta_zi
>d1b7		70 a7 74 a7					.word xt_asm_sta_z, z_asm_sta_z
>d1bb		73 74 61 2e 7a					.text "sta.z"
.d1c0						nt_asm_sta_zi:
>d1c0		06 0a						.byte 6, IM+NN
>d1c2		ce d1				                .word nt_asm_sta_ziy
>d1c4		74 a7 78 a7					.word xt_asm_sta_zi, z_asm_sta_zi
>d1c8		73 74 61 2e 7a 69				.text "sta.zi"
.d1ce						nt_asm_sta_ziy:
>d1ce		07 0a						.byte 7, IM+NN
>d1d0		dd d1				                .word nt_asm_sta_zx
>d1d2		78 a7 7c a7					.word xt_asm_sta_ziy, z_asm_sta_ziy
>d1d6		73 74 61 2e 7a 69 79				.text "sta.ziy"
.d1dd						nt_asm_sta_zx:
>d1dd		06 0a						.byte 6, IM+NN
>d1df		eb d1				                .word nt_asm_sta_zxi
>d1e1		7c a7 80 a7					.word xt_asm_sta_zx, z_asm_sta_zx
>d1e5		73 74 61 2e 7a 78				.text "sta.zx"
.d1eb						nt_asm_sta_zxi:
>d1eb		07 0a						.byte 7, IM+NN
>d1ed		fa d1				                .word nt_asm_stx
>d1ef		80 a7 84 a7					.word xt_asm_sta_zxi, z_asm_sta_zxi
>d1f3		73 74 61 2e 7a 78 69				.text "sta.zxi"
.d1fa						nt_asm_stx:
>d1fa		03 0a						.byte 3, IM+NN
>d1fc		05 d2				                .word nt_asm_stx_z
>d1fe		84 a7 88 a7					.word xt_asm_stx, z_asm_stx
>d202		73 74 78					.text "stx"
.d205						nt_asm_stx_z:
>d205		05 0a						.byte 5, IM+NN
>d207		12 d2				                .word nt_asm_stx_zy
>d209		88 a7 8c a7					.word xt_asm_stx_z, z_asm_stx_z
>d20d		73 74 78 2e 7a					.text "stx.z"
.d212						nt_asm_stx_zy:
>d212		06 0a						.byte 6, IM+NN
>d214		20 d2				                .word nt_asm_sty
>d216		8c a7 90 a7					.word xt_asm_stx_zy, z_asm_stx_zy
>d21a		73 74 78 2e 7a 79				.text "stx.zy"
.d220						nt_asm_sty:
>d220		03 0a						.byte 3, IM+NN
>d222		2b d2				                .word nt_asm_sty_z
>d224		90 a7 94 a7					.word xt_asm_sty, z_asm_sty
>d228		73 74 79					.text "sty"
.d22b						nt_asm_sty_z:
>d22b		05 0a						.byte 5, IM+NN
>d22d		38 d2				                .word nt_asm_sty_zx
>d22f		94 a7 98 a7					.word xt_asm_sty_z, z_asm_sty_z
>d233		73 74 79 2e 7a					.text "sty.z"
.d238						nt_asm_sty_zx:
>d238		06 0a						.byte 6, IM+NN
>d23a		46 d2				                .word nt_asm_stz
>d23c		98 a7 9c a7					.word xt_asm_sty_zx, z_asm_sty_zx
>d240		73 74 79 2e 7a 78				.text "sty.zx"
.d246						nt_asm_stz:
>d246		03 0a						.byte 3, IM+NN
>d248		51 d2				                .word nt_asm_stz_x
>d24a		9c a7 a0 a7					.word xt_asm_stz, z_asm_stz
>d24e		73 74 7a					.text "stz"
.d251						nt_asm_stz_x:
>d251		05 0a						.byte 5, IM+NN
>d253		5e d2				                .word nt_asm_stz_z
>d255		a0 a7 a4 a7					.word xt_asm_stz_x, z_asm_stz_x
>d259		73 74 7a 2e 78					.text "stz.x"
.d25e						nt_asm_stz_z:
>d25e		05 0a						.byte 5, IM+NN
>d260		6b d2				                .word nt_asm_stz_zx
>d262		a4 a7 a8 a7					.word xt_asm_stz_z, z_asm_stz_z
>d266		73 74 7a 2e 7a					.text "stz.z"
.d26b						nt_asm_stz_zx:
>d26b		06 0a						.byte 6, IM+NN
>d26d		79 d2				                .word nt_asm_tax
>d26f		a8 a7 ac a7					.word xt_asm_stz_zx, z_asm_stz_zx
>d273		73 74 7a 2e 7a 78				.text "stz.zx"
.d279						nt_asm_tax:
>d279		03 0a						.byte 3, IM+NN
>d27b		84 d2				                .word nt_asm_tay
>d27d		ac a7 b0 a7					.word xt_asm_tax, z_asm_tax
>d281		74 61 78					.text "tax"
.d284						nt_asm_tay:
>d284		03 0a						.byte 3, IM+NN
>d286		8f d2				                .word nt_asm_trb
>d288		b0 a7 b4 a7					.word xt_asm_tay, z_asm_tay
>d28c		74 61 79					.text "tay"
.d28f						nt_asm_trb:
>d28f		03 0a						.byte 3, IM+NN
>d291		9a d2				                .word nt_asm_trb_z
>d293		b4 a7 b8 a7					.word xt_asm_trb, z_asm_trb
>d297		74 72 62					.text "trb"
.d29a						nt_asm_trb_z:
>d29a		05 0a						.byte 5, IM+NN
>d29c		a7 d2				                .word nt_asm_tsb
>d29e		b8 a7 bc a7					.word xt_asm_trb_z, z_asm_trb_z
>d2a2		74 72 62 2e 7a					.text "trb.z"
.d2a7						nt_asm_tsb:
>d2a7		03 0a						.byte 3, IM+NN
>d2a9		b2 d2				                .word nt_asm_tsb_z
>d2ab		bc a7 c0 a7					.word xt_asm_tsb, z_asm_tsb
>d2af		74 73 62					.text "tsb"
.d2b2						nt_asm_tsb_z:
>d2b2		05 0a						.byte 5, IM+NN
>d2b4		bf d2				                .word nt_asm_tsx
>d2b6		c0 a7 c4 a7					.word xt_asm_tsb_z, z_asm_tsb_z
>d2ba		74 73 62 2e 7a					.text "tsb.z"
.d2bf						nt_asm_tsx:
>d2bf		03 0a						.byte 3, IM+NN
>d2c1		ca d2				                .word nt_asm_txa
>d2c3		c4 a7 c8 a7					.word xt_asm_tsx, z_asm_tsx
>d2c7		74 73 78					.text "tsx"
.d2ca						nt_asm_txa:
>d2ca		03 0a						.byte 3, IM+NN
>d2cc		d5 d2				                .word nt_asm_txs
>d2ce		c8 a7 cc a7					.word xt_asm_txa, z_asm_txa
>d2d2		74 78 61					.text "txa"
.d2d5						nt_asm_txs:
>d2d5		03 0a						.byte 3, IM+NN
>d2d7		e0 d2				                .word nt_asm_tya
>d2d9		cc a7 d0 a7					.word xt_asm_txs, z_asm_txs
>d2dd		74 78 73					.text "txs"
.d2e0						nt_asm_tya:
>d2e0		03 0a						.byte 3, IM+NN
>d2e2		eb d2				                .word nt_asm_arrow
>d2e4		d0 a7 d4 a7					.word xt_asm_tya, z_asm_tya
>d2e8		74 79 61					.text "tya"
.d2eb						nt_asm_arrow:
>d2eb		03 02				                .byte 3, IM
>d2ed		f6 d2				                .word nt_asm_back_jump
>d2ef		e7 88 f1 88			                .word xt_asm_arrow, z_asm_arrow
>d2f3		2d 2d 3e			                .text "-->"
.d2f6						nt_asm_back_jump:
>d2f6		02 02				                .byte 2, IM
>d2f8		00 d3				                .word nt_asm_back_branch
>d2fa		1c a8 1c a8			                .word xt_asm_back_jump, z_asm_back_jump
>d2fe		3c 6a				                .text "<j"
.d300						nt_asm_back_branch:
>d300		02 02				                .byte 2, IM
>d302		0a d3				                .word nt_asm_push_a
>d304		1d a8 25 a8			                .word xt_asm_back_branch, z_asm_back_branch
>d308		3c 62				                .text "<b"
.d30a						nt_asm_push_a:
>d30a		06 0a				                .byte 6, IM+NN
>d30c		00 00				                .word 0000
>d30e		0e a8 1b a8			                .word xt_asm_push_a, z_asm_push_a
>d312		70 75 73 68 2d 61		                .text "push-a"

;******  Return to file: platform/../taliforth.asm


;******  Processing file: platform/../strings.asm

=0						ix := 0
=0						str_ok             = ix         ; unused?
=1						ix += 1
=1						str_compile        = ix         ; unused?
=2						ix += 1
=2						str_redefined      = ix
=3						ix += 1
=3						str_abc_upper      = ix         ; unused?
=4						ix += 1
=4						str_wid_forth      = ix
=5						ix += 1
=5						str_wid_editor     = ix
=6						ix += 1
=6						str_wid_assembler  = ix
=7						ix += 1
=7						str_wid_root       = ix
=8						ix += 1
=8						str_see_nt         = ix
=9						ix += 1
=9						str_see_xt         = ix
=10						ix += 1
=10						str_see_size       = ix
=11						ix += 1
=11						str_see_cfapfa     = ix
=12						ix += 1
=12						str_disasm_sdc     = ix
=13						ix += 1
=13						str_disasm_lit     = ix
=14						ix += 1
=14						str_disasm_0bra    = ix
=15						ix += 1
=15						str_disasm_loop    = ix
=16						ix += 1
=16						str_disasm_do      = ix
=17						ix += 1
.d318						string_table:
>d318		3a d3 3e d3 48 d3 53 d3		        .word s_ok, s_compiled, s_redefined, s_abc_upper              ; 0-3
>d320		8a d3 82 d3 77 d3 91 d3		        .word s_wid_forth, s_wid_editor, s_wid_asm, s_wid_root        ; 4-7
>d328		97 d3 9c d3 a1 d3 b2 d3		        .word s_see_nt, s_see_xt, s_see_size, s_see_cfapfa            ; 8-11
>d330		dc d3 ef d3 f8 d3 01 d4		        .word s_disasm_sdc, s_disasm_lit, s_disasm_0bra, s_disasm_loop, s_disasm_do ; 12-16
>d338		07 d4
>d33a		20 6f 6b 00			s_ok:         .text " ok", 0         ; note space at beginning
>d33e		20 63 6f 6d 70 69 6c 65		s_compiled:   .text " compiled", 0   ; note space at beginning
>d346		64 00
>d348		72 65 64 65 66 69 6e 65		s_redefined:  .text "redefined ", 0  ; note space at end
>d350		64 20 00
>d353		30 31 32 33 34 35 36 37		s_abc_upper:  .text "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
>d35b		38 39 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
>d36b		4f 50 51 52 53 54 55 56 57 58 59 5a
>d377		41 73 73 65 6d 62 6c 65		s_wid_asm:    .text "Assembler ", 0  ; Wordlist ID 2, note space at end
>d37f		72 20 00
>d382		45 64 69 74 6f 72 20 00		s_wid_editor: .text "Editor ", 0     ; Wordlist ID 1, note space at end
>d38a		46 6f 72 74 68 20 00		s_wid_forth:  .text "Forth ", 0      ; Wordlist ID 0, note space at end
>d391		52 6f 6f 74 20 00		s_wid_root:   .text "Root ", 0       ; Wordlist ID 3, note space at end
>d397		6e 74 3a 20 00			s_see_nt:     .text "nt: ", 0
>d39c		78 74 3a 20 00			s_see_xt:     .text "xt: ", 0
>d3a1		73 69 7a 65 20 28 64 65		s_see_size:   .text "size (decimal): ", 0
>d3a9		63 69 6d 61 6c 29 3a 20 00
>d3b2		43 46 41 20 33 20 20 50		s_see_cfapfa: .text "CFA 3  PFA ", 0
>d3ba		46 41 20 00
>d3be		66 6c 61 67 73 3a 20 43		see_flags_template:     .shift "flags: CO",0,"IM",0,"AN",0,"NN",0,"HC",0,"| UF",0,"ST",0
>d3c6		4f 00 49 4d 00 41 4e 00 4e 4e 00 48 43 00 7c 20
>d3d6		55 46 00 53 54 80
>d3dc		20 53 54 41 43 4b 20 44		s_disasm_sdc: .text " STACK DEPTH CHECK", 0
>d3e4		45 50 54 48 20 43 48 45 43 4b 00
>d3ef		4c 49 54 45 52 41 4c 20		s_disasm_lit: .text "LITERAL ", 0
>d3f7		00
>d3f8		30 42 52 41 4e 43 48 20		s_disasm_0bra: .text "0BRANCH ",0
>d400		00
>d401		4c 4f 4f 50 20 00		s_disasm_loop: .text "LOOP ",0
>d407		44 4f 20 00			s_disasm_do: .text "DO ",0
=0						err_allot        = 0
=1						err_badsource    = 1
=2						err_compileonly  = 2
=3						err_defer        = 3
=4						err_divzero      = 4
=5						err_noname       = 5
=6						err_refill       = 6
=7						err_state        = 7
=8						err_syntax       = 8
=9						err_underflow    = 9
=10						err_negallot     = 10
=11						err_wordlist     = 11
=12						err_blockwords   = 12
=13						err_returnstack  = 13
.d40b						error_table:
>d40b		27 d4 48 d4 68 d4 89 d4		        .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
>d413		a6 d4 b7 d4 c7 d4 f5 d4		        .word es_divzero, es_noname, es_refill, es_state        ;  4-7
>d41b		0d d5 2e d5 43 d5 5f d5		        .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
>d423		76 d5 b5 d5			        .word es_blockwords, es_returnstack                     ; 12-13
>d427		41 4c 4c 4f 54 20 75 73		es_allot:       .text "ALLOT using all available memory", 0
>d42f		69 6e 67 20 61 6c 6c 20 61 76 61 69 6c 61 62 6c
>d43f		65 20 6d 65 6d 6f 72 79 00
>d448		49 6c 6c 65 67 61 6c 20		es_badsource:   .text "Illegal SOURCE-ID during REFILL", 0
>d450		53 4f 55 52 43 45 2d 49 44 20 64 75 72 69 6e 67
>d460		20 52 45 46 49 4c 4c 00
>d468		49 6e 74 65 72 70 72 65		es_compileonly: .text "Interpreting a compile-only word", 0
>d470		74 69 6e 67 20 61 20 63 6f 6d 70 69 6c 65 2d 6f
>d480		6e 6c 79 20 77 6f 72 64 00
>d489		44 45 46 45 52 65 64 20		es_defer:       .text "DEFERed word not defined yet", 0
>d491		77 6f 72 64 20 6e 6f 74 20 64 65 66 69 6e 65 64
>d4a1		20 79 65 74 00
>d4a6		44 69 76 69 73 69 6f 6e		es_divzero:     .text "Division by zero", 0
>d4ae		20 62 79 20 7a 65 72 6f 00
>d4b7		50 61 72 73 69 6e 67 20		es_noname:      .text "Parsing failure", 0
>d4bf		66 61 69 6c 75 72 65 00
>d4c7		51 55 49 54 20 63 6f 75		es_refill:      .text "QUIT could not get input (REFILL returned -1)", 0
>d4cf		6c 64 20 6e 6f 74 20 67 65 74 20 69 6e 70 75 74
>d4df		20 28 52 45 46 49 4c 4c 20 72 65 74 75 72 6e 65
>d4ef		64 20 2d 31 29 00
>d4f5		41 6c 72 65 61 64 79 20		es_state:       .text "Already in compile mode", 0
>d4fd		69 6e 20 63 6f 6d 70 69 6c 65 20 6d 6f 64 65 00
>d50d		55 6e 64 65 66 69 6e 65		es_syntax:      .text "Undefined word or invalid number", 0
>d515		64 20 77 6f 72 64 20 6f 72 20 69 6e 76 61 6c 69
>d525		64 20 6e 75 6d 62 65 72 00
>d52e		44 61 74 61 20 73 74 61		es_underflow:   .text "Data stack underflow", 0
>d536		63 6b 20 75 6e 64 65 72 66 6c 6f 77 00
>d543		4d 61 78 20 6d 65 6d 6f		es_negallot:    .text "Max memory freed with ALLOT", 0
>d54b		72 79 20 66 72 65 65 64 20 77 69 74 68 20 41 4c
>d55b		4c 4f 54 00
>d55f		4e 6f 20 77 6f 72 64 6c		es_wordlist:    .text "No wordlists available", 0
>d567		69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>d576		50 6c 65 61 73 65 20 61		es_blockwords:  .text "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
>d57e		73 73 69 67 6e 20 76 65 63 74 6f 72 73 20 42 4c
>d58e		4f 43 4b 2d 52 45 41 44 2d 56 45 43 54 4f 52 20
>d59e		61 6e 64 20 42 4c 4f 43 4b 2d 57 52 49 54 45 2d
>d5ae		56 45 43 54 4f 52 00
>d5b5		52 65 74 75 72 6e 20 73		es_returnstack: .text "Return stack:", 0
>d5bd		74 61 63 6b 3a 00
>d5c3		0f 2f 43 4f 55 4e 54 45		envs_cs:        .text 15, "/COUNTED-STRING"
>d5cb		44 2d 53 54 52 49 4e 47
>d5d3		05 2f 48 4f 4c 44		envs_hold:      .text 5, "/HOLD"
>d5d9		04 2f 50 41 44			envs_pad:       .text 4, "/PAD"
>d5de		11 41 44 44 52 45 53 53		envs_aub:       .text 17, "ADDRESS-UNIT-BITS"
>d5e6		2d 55 4e 49 54 2d 42 49 54 53
>d5f0		07 46 4c 4f 4f 52 45 44		envs_floored:   .text 7, "FLOORED"
>d5f8		08 4d 41 58 2d 43 48 41		envs_max_char:  .text 8, "MAX-CHAR"
>d600		52
>d601		05 4d 41 58 2d 4e		envs_max_n:     .text 5, "MAX-N"
>d607		05 4d 41 58 2d 55		envs_max_u:     .text 5, "MAX-U"
>d60d		12 52 45 54 55 52 4e 2d		envs_rsc:       .text 18, "RETURN-STACK-CELLS"
>d615		53 54 41 43 4b 2d 43 45 4c 4c 53
>d620		0b 53 54 41 43 4b 2d 43		envs_sc:        .text 11, "STACK-CELLS"
>d628		45 4c 4c 53
>d62c		09 57 4f 52 44 4c 49 53		envs_wl:        .text 9, "WORDLISTS"
>d634		54 53
>d636		05 4d 41 58 2d 44		envs_max_d:     .text 5, "MAX-D"
>d63c		06 4d 41 58 2d 55 44		envs_max_ud:    .text 6, "MAX-UD"

;******  Return to file: platform/../taliforth.asm

.d643						doconst:
.d643		ca		dex		                dex             ; make room for constant
.d644		ca		dex		                dex
.d645		68		pla		                pla             ; LSB of return address
.d646		85 25		sta $25		                sta tmp1
.d648		68		pla		                pla             ; MSB of return address
.d649		85 26		sta $26		                sta tmp1+1
.d64b		a0 01		ldy #$01	                ldy #1
.d64d		b1 25		lda ($25),y	                lda (tmp1),y
.d64f		95 00		sta $00,x	                sta 0,x
.d651		c8		iny		                iny
.d652		b1 25		lda ($25),y	                lda (tmp1),y
.d654		95 01		sta $01,x	                sta 1,x
.d656		60		rts		                rts
.d657						dodefer:
.d657		68		pla		                pla             ; LSB
.d658		85 25		sta $25		                sta tmp1
.d65a		68		pla		                pla             ; MSB
.d65b		85 26		sta $26		                sta tmp1+1
.d65d		a0 01		ldy #$01	                ldy #1
.d65f		b1 25		lda ($25),y	                lda (tmp1),y
.d661		85 27		sta $27		                sta tmp2
.d663		c8		iny		                iny
.d664		b1 25		lda ($25),y	                lda (tmp1),y
.d666		85 28		sta $28		                sta tmp2+1
.d668		6c 27 00	jmp ($0027)	                jmp (tmp2)      ; This is actually a jump to the new target
.d66b						dodoes:
.d66b		7a		ply		                ply             ; LSB
.d66c		68		pla		                pla             ; MSB
.d66d		c8		iny		                iny
.d66e		d0 01		bne $d671	                bne +
.d670		1a		inc a		                ina
.d671						+
.d671		84 27		sty $27		                sty tmp2
.d673		85 28		sta $28		                sta tmp2+1
.d675		ca		dex		                dex
.d676		ca		dex		                dex
.d677		7a		ply		                ply
.d678		68		pla		                pla
.d679		c8		iny		                iny
.d67a		d0 01		bne $d67d	                bne +
.d67c		1a		inc a		                ina
.d67d						+
.d67d		94 00		sty $00,x	                sty 0,x         ; LSB
.d67f		95 01		sta $01,x	                sta 1,x         ; MSB
.d681		6c 27 00	jmp ($0027)	                jmp (tmp2)
.d684						dovar:
.d684		7a		ply		                ply             ; LSB
.d685		68		pla		                pla             ; MSB
.d686		c8		iny		                iny
.d687		d0 01		bne $d68a	                bne +
.d689		1a		inc a		                ina
.d68a						+
.d68a		ca		dex		                dex
.d68b		ca		dex		                dex
.d68c		95 01		sta $01,x	                sta 1,x
.d68e		98		tya		                tya
.d68f		95 00		sta $00,x	                sta 0,x
.d691		60		rts		                rts
.d692						push_upvar_tos:
.d692		ca		dex		                dex
.d693		ca		dex		                dex
.d694		18		clc		                clc
.d695		65 08		adc $08		                adc up
.d697		95 00		sta $00,x	                sta 0,x
.d699		a5 09		lda $09		                lda up+1
.d69b		90 01		bcc $d69e	                bcc +
.d69d		1a		inc a		                ina
.d69e						+
.d69e		95 01		sta $01,x	                sta 1,x
.d6a0		60		rts		                rts
.d6a1						byte_to_ascii:
.d6a1		48		pha		                pha
.d6a2		4a		lsr a		                lsr             ; convert high nibble first
.d6a3		4a		lsr a		                lsr
.d6a4		4a		lsr a		                lsr
.d6a5		4a		lsr a		                lsr
.d6a6		20 aa d6	jsr $d6aa	                jsr _nibble_to_ascii
.d6a9		68		pla		                pla
.d6aa						_nibble_to_ascii:
.d6aa		29 0f		and #$0f	                and #$F
.d6ac		09 30		ora #$30	                ora #'0'
.d6ae		c9 3a		cmp #$3a	                cmp #'9'+1
.d6b0		90 02		bcc $d6b4	                bcc +
.d6b2		69 06		adc #$06	                adc #6
.d6b4		4c 86 86	jmp $8686	+               jmp emit_a
.d6b7		60		rts		                rts
.d6b8						find_header_name:
.d6b8		b5 02		lda $02,x	                lda 2,x                 ; Copy mystery string to tmp2
.d6ba		85 27		sta $27		                sta tmp2
.d6bc		b5 03		lda $03,x	                lda 3,x
.d6be		85 28		sta $28		                sta tmp2+1
.d6c0						_loop:
.d6c0		b2 25		lda ($25)	                lda (tmp1)
.d6c2		d5 00		cmp $00,x	                cmp 0,x
.d6c4		d0 3a		bne $d700	                bne _next_entry
.d6c6		b2 27		lda ($27)	                lda (tmp2)      ; first character of mystery string
.d6c8		a0 08		ldy #$08	                ldy #8
.d6ca		51 25		eor ($25),y	                eor (tmp1),y    ; flag any mismatched bits
.d6cc		29 df		and #$df	                and #%11011111  ; but ignore upper/lower case bit
.d6ce		d0 30		bne $d700	                bne _next_entry ; definitely not equal if any bits differ
.d6d0		a5 25		lda $25		                lda tmp1
.d6d2		48		pha		                pha             ; Save original address on the stack
.d6d3		18		clc		                clc
.d6d4		69 08		adc #$08	                adc #8
.d6d6		85 25		sta $25		                sta tmp1
.d6d8		a5 26		lda $26		                lda tmp1+1
.d6da		48		pha		                pha
.d6db		90 03		bcc $d6e0	                bcc +
.d6dd		1a		inc a		                ina
.d6de		85 26		sta $26		                sta tmp1+1
.d6e0						+
.d6e0		b4 00		ldy $00,x	                ldy 0,x         ; index is length of string minus 1
.d6e2		88		dey		                dey
.d6e3						_next_char:
.d6e3		b1 27		lda ($27),y	                lda (tmp2),y    ; last char of mystery string
.d6e5		c9 5b		cmp #$5b	                cmp #'Z'+1
.d6e7		b0 06		bcs $d6ef	                bcs _check_char
.d6e9		c9 41		cmp #$41	                cmp #'A'
.d6eb		90 02		bcc $d6ef	                bcc _check_char
.d6ed		09 20		ora #$20	                ora #$20
.d6ef						_check_char:
.d6ef		d1 25		cmp ($25),y	                cmp (tmp1),y    ; last char of word we're testing against
.d6f1		d0 03		bne $d6f6	                bne _reset_tmp1
.d6f3		88		dey		                dey
.d6f4		10 ed		bpl $d6e3	                bpl _next_char
.d6f6						_reset_tmp1:
.d6f6		68		pla		                pla
.d6f7		85 26		sta $26		                sta tmp1+1
.d6f9		68		pla		                pla
.d6fa		85 25		sta $25		                sta tmp1
.d6fc		98		tya		                tya             ; leave A = $FF on success
.d6fd		c8		iny		                iny             ; if Y was $FF, we succeeded
.d6fe		f0 11		beq $d711	                beq _done
.d700						_next_entry:
.d700		a0 02		ldy #$02	                ldy #2
.d702		b1 25		lda ($25),y	                lda (tmp1),y
.d704		48		pha		                pha
.d705		c8		iny		                iny
.d706		b1 25		lda ($25),y	                lda (tmp1),y
.d708		85 26		sta $26		                sta tmp1+1
.d70a		68		pla		                pla
.d70b		85 25		sta $25		                sta tmp1
.d70d		05 26		ora $26		                ora tmp1+1
.d70f		d0 af		bne $d6c0	                bne _loop
.d711		c9 00		cmp #$00	_done:          cmp #0      ; A is 0 on failure and $FF on success
.d713		60		rts		                rts         ; so cmp #0 sets Z on failure and clears on success
.d714						compare_16bit:
.d714		b5 00		lda $00,x	                lda 0,x                 ; LSB of TOS
.d716		d5 02		cmp $02,x	                cmp 2,x                 ; LSB of NOS
.d718		f0 08		beq $d722	                beq _equal
.d71a		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d71c		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d71e		70 08		bvs $d728	                bvs _overflow
.d720		80 08		bra $d72a	                bra _not_equal
.d722						_equal:
.d722		b5 01		lda $01,x	                lda 1,x                 ; MSB of TOS
.d724		f5 03		sbc $03,x	                sbc 3,x                 ; MSB of NOS
.d726		50 04		bvc $d72c	                bvc _done
.d728						_overflow:
.d728		49 80		eor #$80	                eor #$80                ; complement negative flag
.d72a						_not_equal:
.d72a		09 01		ora #$01	                ora #1                  ; set Z=0 since we're not equal
.d72c						_done:
.d72c		60		rts		                rts
.d72d						current_to_dp:
.d72d		a0 08		ldy #$08	                ldy #current_offset
.d72f		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d731		0a		asl a		                asl             ; turn it into an offset (in cells)
.d732		18		clc		                clc
.d733		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d735		a8		tay		                tay
.d736		b1 08		lda ($08),y	                lda (up),y              ; get the dp for that wordlist.
.d738		85 02		sta $02		                sta dp
.d73a		c8		iny		                iny
.d73b		b1 08		lda ($08),y	                lda (up),y
.d73d		85 03		sta $03		                sta dp+1
.d73f		60		rts		                rts
.d740						dp_to_current:
.d740		a0 08		ldy #$08	                ldy #current_offset
.d742		b1 08		lda ($08),y	                lda (up),y      ; current is a byte variable
.d744		0a		asl a		                asl             ; turn it into an offset (in cells)
.d745		18		clc		                clc
.d746		69 0a		adc #$0a	                adc #wordlists_offset   ; add offset to wordlists base.
.d748		a8		tay		                tay
.d749		a5 02		lda $02		                lda dp
.d74b		91 08		sta ($08),y	                sta (up),y              ; get the dp for that wordlist.
.d74d		c8		iny		                iny
.d74e		a5 03		lda $03		                lda dp+1
.d750		91 08		sta ($08),y	                sta (up),y
.d752		60		rts		                rts
.d753						interpret:
.d753						_loop:
.d753		20 24 8d	jsr $8d24	                jsr w_parse_name       ; ( "string" -- addr u )
.d756		b5 00		lda $00,x	                lda 0,x
.d758		15 01		ora $01,x	                ora 1,x
.d75a		f0 5a		beq $d7b6	                beq _line_done
.d75c		20 9f 93	jsr $939f	                jsr w_two_dup          ; ( addr u -- addr u addr u )
.d75f		20 5d 9b	jsr $9b5d	                jsr w_find_name        ; ( addr u addr u -- addr u nt|0 )
.d762		b5 00		lda $00,x	                lda 0,x
.d764		15 01		ora $01,x	                ora 1,x
.d766		d0 19		bne $d781	                bne _got_name_token
.d768		e8		inx		                inx                     ; ( addr u 0 -- addr u )
.d769		e8		inx		                inx
.d76a		20 09 9d	jsr $9d09	                jsr w_number           ; ( addr u -- u|d )
.d76d		a5 1a		lda $1a		                lda state
.d76f		f0 e2		beq $d753	                beq _loop
.d771		a9 20		lda #$20	                lda #%00100000
.d773		24 1c		bit $1c		                bit status
.d775		d0 05		bne $d77c	                bne _double_number
.d777		20 d3 89	jsr $89d3	                jsr w_literal
.d77a		80 d7		bra $d753	                bra _loop
.d77c						_double_number:
.d77c		20 bd 9f	jsr $9fbd	                jsr w_two_literal
.d77f		80 d2		bra $d753	                bra _loop
.d781						_got_name_token:
.d781		b5 00		lda $00,x	                lda 0,x
.d783		95 04		sta $04,x	                sta 4,x
.d785		b5 01		lda $01,x	                lda 1,x
.d787		95 05		sta $05,x	                sta 5,x
.d789		e8		inx		                inx
.d78a		e8		inx		                inx
.d78b		e8		inx		                inx
.d78c		e8		inx		                inx                     ; ( nt )
.d78d		20 5c 86	jsr $865c	                jsr w_dup
.d790		20 bf 8c	jsr $8cbf	                jsr w_one_plus
.d793		a1 00		lda ($00,x)	                lda (0,x)
.d795		e8		inx		                inx
.d796		e8		inx		                inx
.d797		a4 1a		ldy $1a		                ldy state
.d799		d0 12		bne $d7ad	                bne _compile
.d79b		29 01		and #$01	                and #CO                 ; mask everything but Compile Only bit
.d79d		f0 05		beq $d7a4	                beq _interpret
.d79f		a9 02		lda #$02	                lda #err_compileonly
.d7a1		4c ea d7	jmp $d7ea	                jmp error
.d7a4						_interpret:
.d7a4		20 a6 9c	jsr $9ca6	                jsr w_name_to_int      ; ( nt - xt )
.d7a7		20 d4 87	jsr $87d4	                jsr w_execute
.d7aa		4c 53 d7	jmp $d753	                jmp _loop
.d7ad						_compile:
.d7ad		29 02		and #$02	                and #IM                 ; Mask all but IM bit
.d7af		d0 f3		bne $d7a4	                bne _interpret          ; IMMEDIATE word, execute right now
.d7b1		20 ad 96	jsr $96ad	                jsr compile_nt_comma
.d7b4		80 9d		bra $d753	                bra _loop
.d7b6						_line_done:
.d7b6		e8		inx		                inx
.d7b7		e8		inx		                inx
.d7b8		e8		inx		                inx
.d7b9		e8		inx		                inx
.d7ba		60		rts		                rts
.d7bb						is_printable:
.d7bb		c9 20		cmp #$20	                cmp #AscSP              ; $20
.d7bd		90 07		bcc $d7c6	                bcc _done
.d7bf		c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.d7c1		b0 02		bcs $d7c5	                bcs _failed
.d7c3		38		sec		                sec
>d7c4		24				                .byte OpBITzp
.d7c5						_failed:
.d7c5		18		clc		                clc
.d7c6						_done:
.d7c6		60		rts		                rts
.d7c7						is_whitespace:
.d7c7		c9 00		cmp #$00	                cmp #00         ; explicit comparison to leave Y untouched
.d7c9		90 08		bcc $d7d3	                bcc _done
.d7cb		c9 21		cmp #$21	                cmp #AscSP+1
.d7cd		b0 03		bcs $d7d2	                bcs _failed
.d7cf		38		sec		                sec
.d7d0		80 01		bra $d7d3	                bra _done
.d7d2						_failed:
.d7d2		18		clc		                clc
.d7d3						_done:
.d7d3		60		rts		                rts
.d7d4						underflow_1:
.d7d4		e0 77		cpx #$77	                cpx #dsp0-1
.d7d6		10 10		bpl $d7e8	                bpl underflow_error
.d7d8		60		rts		                rts
.d7d9						underflow_2:
.d7d9		e0 75		cpx #$75	                cpx #dsp0-3
.d7db		10 0b		bpl $d7e8	                bpl underflow_error
.d7dd		60		rts		                rts
.d7de						underflow_3:
.d7de		e0 73		cpx #$73	                cpx #dsp0-5
.d7e0		10 06		bpl $d7e8	                bpl underflow_error
.d7e2		60		rts		                rts
.d7e3						underflow_4:
.d7e3		e0 71		cpx #$71	                cpx #dsp0-7
.d7e5		10 01		bpl $d7e8	                bpl underflow_error
.d7e7		60		rts		                rts
.d7e8						underflow_error:
.d7e8		a9 09		lda #$09	                lda #err_underflow      ; fall through to error
.d7ea						error:
.d7ea		48		pha		                pha                     ; save error
.d7eb		20 29 d8	jsr $d829	                jsr print_error
.d7ee		20 ec 83	jsr $83ec	                jsr w_cr
.d7f1		68		pla		                pla
.d7f2		c9 09		cmp #$09	                cmp #err_underflow      ; should we display return stack?
.d7f4		d0 17		bne $d80d	                bne _no_underflow
.d7f6		a9 0d		lda #$0d	                lda #err_returnstack
.d7f8		20 29 d8	jsr $d829	                jsr print_error
.d7fb		ba		tsx		                tsx
.d7fc						-
.d7fc		e8		inx		                inx
.d7fd		f0 0b		beq $d80a	                beq +
.d7ff		20 b5 91	jsr $91b5	                jsr w_space
.d802		bd 00 01	lda $0100,x	                lda $100,x
.d805		20 a1 d6	jsr $d6a1	                jsr byte_to_ascii
.d808		80 f2		bra $d7fc	                bra -
.d80a						+
.d80a		20 ec 83	jsr $83ec	                jsr w_cr
.d80d						_no_underflow:
.d80d		4c 5e 80	jmp $805e	                jmp w_abort            ; no jsr, as we clobber return stack
.d810						print_string_no_lf:
.d810		0a		asl a		                asl
.d811		a8		tay		                tay
.d812		b9 18 d3	lda $d318,y	                lda string_table,y
.d815		85 29		sta $29		                sta tmp3                ; LSB
.d817		b9 19 d3	lda $d319,y	                lda string_table+1,y
.d81a		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d81c						print_common:
.d81c		a0 00		ldy #$00	                ldy #0
.d81e						_loop:
.d81e		b1 29		lda ($29),y	                lda (tmp3),y
.d820		f0 06		beq $d828	                beq _done               ; strings are zero-terminated
.d822		20 86 86	jsr $8686	                jsr emit_a              ; allows vectoring via output
.d825		c8		iny		                iny
.d826		80 f6		bra $d81e	                bra _loop
.d828						_done:
.d828		60		rts		                rts
.d829						print_error:
.d829		0a		asl a		                asl
.d82a		a8		tay		                tay
.d82b		b9 0b d4	lda $d40b,y	                lda error_table,y
.d82e		85 29		sta $29		                sta tmp3                ; LSB
.d830		c8		iny		                iny
.d831		b9 0b d4	lda $d40b,y	                lda error_table,y
.d834		85 2a		sta $2a		                sta tmp3+1              ; MSB
.d836		20 1c d8	jsr $d81c	                jsr print_common
.d839		60		rts		                rts
.d83a						print_string:
.d83a		20 10 d8	jsr $d810	                jsr print_string_no_lf
.d83d		4c ec 83	jmp $83ec	                jmp w_cr               ; JSR/RTS because never compiled
.d840						print_u:
.d840		20 66 9e	jsr $9e66	                jsr w_zero                     ; 0
.d843		20 ad 89	jsr $89ad	                jsr w_less_number_sign         ; <#
.d846		20 89 8c	jsr $8c89	                jsr w_number_sign_s            ; #S
.d849		20 67 8c	jsr $8c67	                jsr w_number_sign_greater      ; #>
.d84c		4c b4 94	jmp $94b4	                jmp w_type                     ; JSR/RTS because never compiled
.d84f						code_end:

;******  Return to file: platform/simulator.asm

=$f000						io_start = $f000                ; virtual hardware addresses for the simulators
>f000						                .byte ?
>f001						io_putc:        .byte ?         ; $f001     write byte to stdout
>f002						                .byte ?
>f003						io_kbhit:       .byte ?         ; $f003     read non-zero on key ready (c65 only)
>f004						io_getc:        .byte ?         ; $f004     non-blocking read input character (0 if no key)
>f005						                .byte ?
>f006						io_clk_start:   .byte ?         ; $f006     *read* to start cycle counter
>f007						io_clk_stop:    .byte ?         ; $f007     *read* to stop the cycle counter
>f008						io_clk_cycles:  .word ?,?       ; $f008-b   32-bit cycle count in NUXI order
>f00c						                .word ?,?
.f010						kernel_init:
.f010		78		sei		                sei             ; Disable interrupts
.f011		a2 00		ldx #$00	                ldx #0
.f013		bd 40 f0	lda $f040,x	-               lda s_kernel_id,x
.f016		f0 06		beq $f01e	                beq _done
.f018		20 22 f0	jsr $f022	                jsr kernel_putc
.f01b		e8		inx		                inx
.f01c		80 f5		bra $f013	                bra -
.f01e						_done:
.f01e		4c 00 80	jmp $8000	                jmp forth
.f021						kernel_bye:
.f021		00		brk #		                brk
.f022						kernel_putc:
.f022		8d 01 f0	sta $f001	                sta io_putc
.f025		60		rts		                rts

;******  Return to file: platform/platform-py65mon.asm

=$f002						io_bufc = io_putc+1
.f026						kernel_getc:
.f026		ad 02 f0	lda $f002	                lda io_bufc             ; first check the buffer
.f029		9c 02 f0	stz $f002	                stz io_bufc
.f02c		d0 05		bne $f033	                bne _done
.f02e						_loop:
.f02e		ad 04 f0	lda $f004	                lda io_getc
.f031		f0 fb		beq $f02e	                beq _loop
.f033						_done:
.f033		60		rts		                rts
.f034						kernel_kbhit:
.f034		ad 02 f0	lda $f002	                lda io_bufc             ; do we already have a character?
.f037		d0 06		bne $f03f	                bne _done
.f039		ad 04 f0	lda $f004	                lda io_getc             ; otherwise check and buffer the result
.f03c		8d 02 f0	sta $f002	                sta io_bufc
.f03f						_done:
.f03f		60		rts		                rts
.f040						s_kernel_id:
>f040		54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 default kernel for py65mon (04. Dec 2022)", AscLF, 0
>f048		74 68 20 32 20 64 65 66 61 75 6c 74 20 6b 65 72
>f058		6e 65 6c 20 66 6f 72 20 70 79 36 35 6d 6f 6e 20
>f068		28 30 34 2e 20 44 65 63 20 32 30 32 32 29 0a 00
>fffa		10 f0				v_nmi   .word kernel_init
>fffc		10 f0				v_reset .word kernel_init
>fffe		10 f0				v_irq   .word kernel_init

;******  End of listing
